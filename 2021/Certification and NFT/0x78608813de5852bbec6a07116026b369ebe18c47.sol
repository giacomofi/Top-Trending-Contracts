['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-02\n', '*/\n', '\n', '/*\n', ' * Crypto stamp Bridge Head\n', ' * Core element of the Crypto Stamp Bridge, an off-chain service connects the\n', ' * bridge heads on both sides to form the actual bridge system. Deposited\n', ' * tokens are actually owned by a separate token holder contract, but\n', ' * pull-based deposits are enacted via this bridge head contract as well.\n', ' *\n', ' * Developed by Capacity Blockchain Solutions GmbH <capacity.at>\n', ' * for Ã–sterreichische Post AG <post.at>\n', ' *\n', ' * Any usage of or interaction with this set of contracts is subject to the\n', ' * Terms & Conditions available at https://crypto.post.at/\n', ' */\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the token collection name.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\n', '\n', '/**\n', ' * @dev Required interface of an ERC1155 compliant contract, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/cryptography/ECDSA.sol\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise\n', '     * be too long), and then calling {toEthSignedMessageHash} on it.\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            revert("ECDSA: invalid signature length");\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        return recover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Overload of {ECDSA-recover} that receives the `v`,\n', '     * `r` and `s` signature fields separately.\n', '     */\n', '    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n Ã· 2 + 1, and for v in (282): v âˆˆ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n', '        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer != address(0), "ECDSA: invalid signature");\n', '\n', '        return signer;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n', '     * produces hash corresponding to the one signed with the\n', '     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n', '     * JSON-RPC method as part of EIP-191.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Typed Data, created from a\n', '     * `domainSeparator` and a `structHash`. This produces hash corresponding\n', '     * to the one signed with the\n', '     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n', '     * JSON-RPC method as part of EIP-712.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/proxy/Clones.sol\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '// File: contracts/ENSReverseRegistrarI.sol\n', '\n', '/*\n', ' * Interfaces for ENS Reverse Registrar\n', ' * See https://github.com/ensdomains/ens/blob/master/contracts/ReverseRegistrar.sol for full impl\n', ' * Also see https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/ENSReverseRegister.sol\n', ' *\n', ' * Use this as follows (registryAddress is the address of the ENS registry to use):\n', ' * -----\n', " * // This hex value is caclulated by namehash('addr.reverse')\n", ' * bytes32 public constant ENS_ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', ' * function registerReverseENS(address registryAddress, string memory calldata) external {\n', ' *     require(registryAddress != address(0), "need a valid registry");\n', ' *     address reverseRegistrarAddress = ENSRegistryOwnerI(registryAddress).owner(ENS_ADDR_REVERSE_NODE)\n', ' *     require(reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', ' *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\n', ' * }\n', ' * -----\n', ' * or\n', ' * -----\n', ' * function registerReverseENS(address reverseRegistrarAddress, string memory calldata) external {\n', ' *    require(reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', ' *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\n', ' * }\n', ' * -----\n', ' * ENS deployments can be found at https://docs.ens.domains/ens-deployments\n', ' * E.g. Etherscan can be used to look up that owner on those contracts.\n', ' * namehash.hash("addr.reverse") == "0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2"\n', ' * Ropsten: ens.owner(namehash.hash("addr.reverse")) == "0x6F628b68b30Dc3c17f345c9dbBb1E483c2b7aE5c"\n', ' * Mainnet: ens.owner(namehash.hash("addr.reverse")) == "0x084b1c3C81545d370f3634392De611CaaBFf8148"\n', ' */\n', '\n', 'interface ENSRegistryOwnerI {\n', '    function owner(bytes32 node) external view returns (address);\n', '}\n', '\n', 'interface ENSReverseRegistrarI {\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    /**\n', '     * @dev Sets the `name()` record for the reverse ENS record associated with\n', '     * the calling account.\n', '     * @param name The name to set for this address.\n', '     * @return The ENS node hash of the reverse record.\n', '     */\n', '    function setName(string calldata name) external returns (bytes32);\n', '}\n', '\n', '// File: contracts/BridgeDataI.sol\n', '\n', '/*\n', ' * Interface for data storage of the bridge.\n', ' */\n', '\n', 'interface BridgeDataI {\n', '\n', '    event AddressChanged(string name, address previousAddress, address newAddress);\n', '    event ConnectedChainChanged(string previousConnectedChainName, string newConnectedChainName);\n', '    event TokenURIBaseChanged(string previousTokenURIBase, string newTokenURIBase);\n', '    event TokenSunsetAnnounced(uint256 indexed timestamp);\n', '\n', '    /**\n', '     * @dev The name of the chain connected to / on the other side of this bridge head.\n', '     */\n', '    function connectedChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The name of our own chain, used in token URIs handed to deployed tokens.\n', '     */\n', '    function ownChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The base of ALL token URIs, e.g. https://example.com/\n', '     */\n', '    function tokenURIBase() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The sunset timestamp for all deployed tokens.\n', '     * If 0, no sunset is in place. Otherwise, if older than block timestamp,\n', '     * all transfers of the tokens are frozen.\n', '     */\n', '    function tokenSunsetTimestamp() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Set a token sunset timestamp.\n', '     */\n', '    function setTokenSunsetTimestamp(uint256 _timestamp) external;\n', '\n', '    /**\n', '     * @dev Set an address for a name.\n', '     */\n', '    function setAddress(string memory name, address newAddress) external;\n', '\n', '    /**\n', '     * @dev Get an address for a name.\n', '     */\n', '    function getAddress(string memory name) external view returns (address);\n', '}\n', '\n', '// File: contracts/BridgeHeadI.sol\n', '\n', '/*\n', ' * Interface for a Bridge Head.\n', ' */\n', '\n', '\n', 'interface BridgeHeadI {\n', '\n', '    /**\n', '     * @dev Emitted when an ERC721 token is deposited to the bridge.\n', '     */\n', '    event TokenDepositedERC721(address indexed tokenAddress, uint256 indexed tokenId, address indexed otherChainRecipient);\n', '\n', '    /**\n', '     * @dev Emitted when one or more ERC1155 tokens are deposited to the bridge.\n', '     */\n', '    event TokenDepositedERC1155Batch(address indexed tokenAddress, uint256[] tokenIds, uint256[] amounts, address indexed otherChainRecipient);\n', '\n', '    /**\n', '     * @dev Emitted when an ERC721 token is exited from the bridge.\n', '     */\n', '    event TokenExitedERC721(address indexed tokenAddress, uint256 indexed tokenId, address indexed recipient);\n', '\n', '    /**\n', '     * @dev Emitted when one or more ERC1155 tokens are exited from the bridge.\n', '     */\n', '    event TokenExitedERC1155Batch(address indexed tokenAddress, uint256[] tokenIds, uint256[] amounts, address indexed recipient);\n', '\n', '    /**\n', '     * @dev Emitted when a new bridged token is deployed.\n', '     */\n', '    event BridgedTokenDeployed(address indexed ownAddress, address indexed foreignAddress);\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev The bridge controller address\n', '     */\n', '    function bridgeControl() external view returns (address);\n', '\n', '    /**\n', '     * @dev The token holder contract connected to this bridge head\n', '     */\n', '    function tokenHolder() external view returns (TokenHolderI);\n', '\n', '    /**\n', '     * @dev The name of the chain connected to / on the other side of this bridge head.\n', '     */\n', '    function connectedChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The name of our own chain, used in token URIs handed to deployed tokens.\n', '     */\n', '    function ownChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The minimum amount of (valid) signatures that need to be present in `processExitData()`.\n', '     */\n', '    function minSignatures() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev True if deposits are possible at this time.\n', '     */\n', '    function depositEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev True if exits are possible at this time.\n', '     */\n', '    function exitEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev Called by token holder when a ERC721 token has been deposited and\n', '     * needs to be moved to the other side of the bridge.\n', '     */\n', '    function tokenDepositedERC721(address tokenAddress, uint256 tokenId, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by token holder when a ERC1155 token has been deposited and\n', '     * needs to be moved to the other side of the bridge. If it was no batch\n', '     * deposit, still this function is called with with only the one items in\n', '     * the batch.\n', '     */\n', '    function tokenDepositedERC1155Batch(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by people/contracts who want to move an ERC721 token to the\n', '     * other side of the bridge. Needs to be called by the current token owner.\n', '     */\n', '    function depositERC721(address tokenAddress, uint256 tokenId, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by people/contracts who want to move an ERC1155 token to the\n', '     * other side of the bridge. When only a single token ID is desposited,\n', '     * called with only one entry in the arrays. Needs to be called by the\n', '     * current token owner.\n', '     */\n', '    function depositERC1155Batch(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Process an exit message. Can be called by anyone, but requires data\n', '     * with valid signatures from a minimum of `minSignatures()` of allowed\n', '     * signer addresses and an exit nonce for the respective signer that has\n', '     * not been used yet. Also, all signers need to be ordered with ascending\n', '     * addresses for the call to succeed.\n', '     * The ABI-encoded payload is for a call on the bridge head contract.\n', '     * The signature is over the contract address, the chain ID, the exit\n', '     * nonce, and the payload.\n', '     */\n', '    function processExitData(bytes memory _payload, uint256 _expirationTimestamp, bytes[] memory _signatures, uint256[] memory _exitNonces) external;\n', '\n', '    /**\n', '     * @dev Return a predicted token address given the prototype name as listed\n', '     * in bridge data ("ERC721Prototype" or "ERC1155Prototype") and foreign\n', '     * token address.\n', '     */\n', '    function predictTokenAddress(string memory _prototypeName, address _foreignAddress) external view returns (address);\n', '\n', '    /**\n', '     * @dev Exit an ERC721 token from the bridge to a recipient. Can be owned\n', '     * by either the token holder or an address that is treated as an\n', '     * equivalent holder for the bride. If not existing, can be minted if\n', '     * allowed, or even a token deployed based in a given foreign address and\n', '     * symbol. If properties data is set, will send that to the token contract\n', '     * to set properties for the token.\n', '     */\n', '    function exitERC721(address _tokenAddress, uint256 _tokenId, address _recipient, address _foreignAddress, bool _allowMinting, string calldata _symbol, bytes calldata _propertiesData) external;\n', '\n', '    /**\n', '     * @dev Exit an already existing ERC721 token from the bridge to a\n', '     * recipient, owned currently by the bridge in some form.\n', '     */\n', '    function exitERC721Existing(address _tokenAddress, uint256 _tokenId, address _recipient) external;\n', '\n', '    /**\n', '     * @dev Exit ERC1155 token(s) from the bridge to a recipient. The token\n', '     * source can be the token holder, an equivalent, or a Collection. Only\n', '     * tokens owned by one source can be existed in one transaction. If the\n', '     * source is the zero address, tokens will be minted.\n', '     */\n', '    function exitERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient, address _foreignAddress, address _tokenSource) external;\n', '\n', '    /**\n', '     * @dev Exit an already existing ERC1155 token from the bridge to a\n', '     * recipient, owned currently by the token holder.\n', '     */\n', '    function exitERC1155BatchFromHolder(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient) external;\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function call etc.),\n', '     * we call that contract with this payload, e.g. to trigger actions in the name of the token holder.\n', '     */\n', '    function callAsHolder(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\n', '\n', '/**\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '// File: contracts/TokenHolderI.sol\n', '\n', '/*\n', ' * Interface for a Token Holder.\n', ' */\n', '\n', '\n', 'interface TokenHolderI is IERC165, IERC721Receiver, IERC1155Receiver {\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev The bridge head contract connected to this token holder\n', '     */\n', '    function bridgeHead() external view returns (BridgeHeadI);\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function call etc.),\n', '     * we call that contract with this payload, e.g. to trigger actions in the name of the bridge.\n', '     */\n', '    function externalCall(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '    /**\n', '     * @dev Transfer ERC721 tokens out of the holder contract.\n', '     */\n', '    function safeTransferERC721(address _tokenAddress, uint256 _tokenId, address _to) external;\n', '\n', '    /**\n', '     * @dev Transfer ERC1155 tokens out of the holder contract.\n', '     */\n', '    function safeTransferERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _to) external;\n', '\n', '}\n', '\n', '// File: contracts/ERC721ExistsI.sol\n', '\n', '/*\n', ' * Interface for an ERC721 compliant contract with an exists() function.\n', ' */\n', '\n', '\n', '/**\n', ' * @dev ERC721 compliant contract with an exists() function.\n', ' */\n', 'interface ERC721ExistsI is IERC721 {\n', '\n', '    // Returns whether the specified token exists\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '\n', '}\n', '\n', '// File: contracts/ERC721MintableI.sol\n', '\n', '/*\n', ' * Interfaces for mintable ERC721 compliant contracts.\n', ' */\n', '\n', '\n', '/**\n', ' * @dev ERC721 compliant contract with a safeMint() function.\n', ' */\n', 'interface ERC721MintableI is IERC721 {\n', '\n', '    /**\n', '     * @dev Function to safely mint a new token.\n', '     * Reverts if the given token ID already exists.\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function safeMint(address to, uint256 tokenId) external;\n', '\n', '}\n', '\n', '/**\n', ' * @dev ERC721 compliant contract with a safeMintWithData() function.\n', ' */\n', 'interface ERC721DataMintableI is IERC721 {\n', '\n', '    /**\n', '     * @dev Function to safely mint a new token with data.\n', '     * Reverts if the given token ID already exists.\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     * @param propdata bytes data to be used for token proerties\n', '     */\n', '    function safeMintWithData(address to, uint256 tokenId, bytes memory propdata) external;\n', '\n', '}\n', '\n', '/**\n', ' * @dev ERC721 compliant contract with a setPropertiesFromData() function.\n', ' */\n', 'interface ERC721SettablePropertiesI is IERC721 {\n', '\n', '    /**\n', '     * @dev Function to set properties from data for a token.\n', '     * Reverts if the given token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to be set properties for\n', '     * @param propdata bytes data to be used for token proerties\n', '     */\n', '    function setPropertiesFromData(uint256 tokenId, bytes memory propdata) external;\n', '\n', '}\n', '\n', '// File: contracts/CollectionsI.sol\n', '\n', '/*\n', ' * Interface for the Collections factory.\n', ' */\n', '\n', '\n', '/**\n', ' * @dev Outward-facing interface of a Collections contract.\n', ' */\n', 'interface CollectionsI is IERC721 {\n', '\n', '    /**\n', '     * @dev Emitted when a new collection is created.\n', '     */\n', '    event NewCollection(address indexed owner, address collectionAddress);\n', '\n', '    /**\n', '     * @dev Emitted when a collection is destroyed.\n', '     */\n', '    event KilledCollection(address indexed owner, address collectionAddress);\n', '\n', '    /**\n', '     * @dev Creates a new Collection. For calling from other contracts,\n', '     * returns the address of the new Collection.\n', '     */\n', '    function create(address _notificationContract,\n', '                    string calldata _ensName,\n', '                    string calldata _ensSubdomainName,\n', '                    address _ensSubdomainRegistrarAddress,\n', '                    address _ensReverseRegistrarAddress)\n', '    external payable\n', '    returns (address);\n', '\n', '    /**\n', '     * @dev Create a collection for a different owner. Only callable by a\n', '     * create controller role. For calling from other contracts, returns the\n', '     * address of the new Collection.\n', '     */\n', '    function createFor(address payable _newOwner,\n', '                       address _notificationContract,\n', '                       string calldata _ensName,\n', '                       string calldata _ensSubdomainName,\n', '                       address _ensSubdomainRegistrarAddress,\n', '                       address _ensReverseRegistrarAddress)\n', '    external payable\n', '    returns (address);\n', '\n', '    /**\n', '     * @dev Removes (burns) an empty Collection. Only the Collection contract itself can call this.\n', '     */\n', '    function burn(uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns if a Collection NFT exists for the specified `tokenId`.\n', '     */\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given `collectionAddr`.\n', '     */\n', '    function isApprovedOrOwnerOnCollection(address spender, address collectionAddr) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the Collection address for a token ID.\n', '     */\n', '    function collectionAddress(uint256 tokenId) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the token ID for a Collection address.\n', '     */\n', '    function tokenIdForCollection(address collectionAddr) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns true if a Collection exists at this address, false if not.\n', '     */\n', '    function collectionExists(address collectionAddr) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the owner of the Collection with the given address.\n', '     */\n', '    function collectionOwner(address collectionAddr) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns a Collection address owned by `owner` at a given `index` of\n', '     * its Collections list. Mirrors `tokenOfOwnerByIndex` in ERC721Enumerable.\n', '     */\n', '    function collectionOfOwnerByIndex(address owner, uint256 index) external view returns (address);\n', '\n', '}\n', '\n', '// File: contracts/CollectionI.sol\n', '\n', '/*\n', ' * Interface for a single Collection, which is a very lightweight contract that can be the owner of ERC721 tokens.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', 'interface CollectionI is IERC165, IERC721Receiver, IERC1155Receiver  {\n', '\n', '    /**\n', '     * @dev Emitted when the notification conmtract is changed.\n', '     */\n', '    event NotificationContractTransferred(address indexed previousNotificationContract, address indexed newNotificationContract);\n', '\n', '    /**\n', '     * @dev Emitted when an asset is added to the collection.\n', '     */\n', '    event AssetAdded(address tokenAddress, uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when an asset is removed to the collection.\n', '     */\n', '    event AssetRemoved(address tokenAddress, uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when the Collection is destroyed.\n', '     */\n', '    event CollectionDestroyed(address operator);\n', '\n', '    /**\n', '     * @dev True is this is the prototype, false if this is an active\n', '     * (clone/proxy) collection contract.\n', '     */\n', '    function isPrototype() external view returns (bool);\n', '\n', '    /**\n', '     * @dev The linked Collections factory (the ERC721 contract).\n', '     */\n', '    function collections() external view returns (CollectionsI);\n', '\n', '    /**\n', '     * @dev The linked notification contract (e.g. achievements).\n', '     */\n', '    function notificationContract() external view returns (address);\n', '\n', '    /**\n', '     * @dev Initializes a new Collection. Needs to be called by the Collections\n', '     * factory.\n', '     */\n', '    function initialRegister(address _notificationContract,\n', '                             string calldata _ensName,\n', '                             string calldata _ensSubdomainName,\n', '                             address _ensSubdomainRegistrarAddress,\n', '                             address _ensReverseRegistrarAddress)\n', '    external;\n', '\n', '    /**\n', '     * @dev Switch the notification contract to a different address. Set to the\n', '     * zero address to disable notifications. Can only be called by owner.\n', '     */\n', '    function transferNotificationContract(address _newNotificationContract) external;\n', '\n', '    /**\n', '     * @dev Get collection owner from ERC 721 parent (Collections factory).\n', '     */\n', '    function ownerAddress() external view returns (address);\n', '\n', '    /**\n', '     * @dev Determine if the Collection owns a specific asset.\n', '     */\n', '    function ownsAsset(address _tokenAddress, uint256 _tokenId) external view returns(bool);\n', '\n', '    /**\n', '     * @dev Get count of owned assets.\n', '     */\n', '    function ownedAssetsCount() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Make sure ownership of a certain asset is recorded correctly (added\n', "     * if the collection owns it or removed if it doesn't).\n", '     */\n', '    function syncAssetOwnership(address _tokenAddress, uint256 _tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfer an owned asset to a new owner (for ERC1155, a single item\n', '     * of that asset).\n', '     */\n', '    function safeTransferTo(address _tokenAddress, uint256 _tokenId, address _to) external;\n', '\n', '    /**\n', '     * @dev Transfer a certain amount of an owned asset to a new owner (for\n', '     * ERC721, _value is ignored).\n', '     */\n', '    function safeTransferTo(address _tokenAddress, uint256 _tokenId, address _to, uint256 _value) external;\n', '\n', '    /**\n', '     * @dev Destroy and burn an empty Collection. Can only be called by owner\n', '     * and only on empty collections.\n', '     */\n', '    function destroy() external;\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function\n', '     * call etc.), we call that contract with this payload, e.g. to trigger\n', '     * actions in the name of the collection.\n', '     */\n', '    function externalCall(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '    /**\n', '     * @dev Register ENS name. Can only be called by owner.\n', '     */\n', '    function registerENS(string calldata _name, address _registrarAddress) external;\n', '\n', '    /**\n', '     * @dev Register Reverse ENS name. Can only be called by owner.\n', '     */\n', '    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the total amount of tokens stored by the contract.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n', "     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n", '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n', '     * Use along with {totalSupply} to enumerate all tokens.\n', '     */\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/BridgedERC721I.sol\n', '\n', '/*\n', ' * Interface for a Bridged ERC721 token.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface BridgedERC721I is IERC721Metadata, IERC721Enumerable, ERC721ExistsI, ERC721MintableI {\n', '\n', '    event SignedTransfer(address operator, address indexed from, address indexed to, uint256 indexed tokenId, uint256 signedTransferNonce);\n', '\n', '    /**\n', '     * @dev True if this is the prototype, false if this is an active (clone/proxy) token contract.\n', '     */\n', '    function isPrototype() external view returns (bool);\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev Do initial registration of a clone. Should be called in the same\n', '     * transaction as the actual cloning. Can only be called once.\n', '     */\n', '    function initialRegister(address _bridgeDataAddress,\n', '                             string memory _symbol, string memory _name,\n', '                             string memory _orginalChainName, address _originalChainAddress) external;\n', '\n', '    /**\n', '     * @dev The base of the tokenURI\n', '     */\n', '    function baseURI() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The name of the original chain this token is bridged from.\n', '     */\n', '    function originalChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The address of this token on the original chain this is bridged from.\n', '     */\n', '    function originalChainAddress() external view returns (address);\n', '\n', '    /**\n', '     * @dev True if transfers are possible at this time.\n', '     */\n', '    function transferEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev The signed transfer nonce for an account.\n', '     */\n', '    function signedTransferNonce(address account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Outward-facing function for signed transfer: assembles the expected data and then calls the internal function to do the rest.\n', '     * Can called by anyone knowing about the right signature, but can only transfer to the given specific target.\n', '     */\n', '    function signedTransfer(uint256 tokenId, address to, bytes memory signature) external;\n', '\n', '    /**\n', '     * @dev Outward-facing function for operator-driven signed transfer: assembles the expected data and then calls the internal function to do the rest.\n', '     * Can transfer to any target, but only be called by the trusted operator contained in the signature.\n', '     */\n', '    function signedTransferWithOperator(uint256 tokenId, address to, bytes memory signature) external;\n', '\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n', ' * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155MetadataURI is IERC1155 {\n', '    /**\n', '     * @dev Returns the URI for token type `id`.\n', '     *\n', '     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n', '     * clients with the actual token type ID.\n', '     */\n', '    function uri(uint256 id) external view returns (string memory);\n', '}\n', '\n', '// File: contracts/ERC1155MintableI.sol\n', '\n', '/*\n', ' * Interfaces for mintable ERC721 compliant contracts.\n', ' */\n', '\n', '\n', '/**\n', ' * @dev ERC1155 compliant contract with mint() and mintBatch() functions.\n', ' */\n', 'interface ERC1155MintableI is IERC1155 {\n', '\n', '    /**\n', '     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function mint(address account, uint256 id, uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Batched version of {_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external;\n', '\n', '}\n', '\n', '// File: contracts/BridgedERC1155I.sol\n', '\n', '/*\n', ' * Interface for a Bridged ERC721 token.\n', ' */\n', '\n', '\n', '\n', '\n', 'interface BridgedERC1155I is IERC1155MetadataURI, ERC1155MintableI {\n', '\n', '    event SignedBatchTransfer(address operator, address indexed from, address indexed to, uint256[] ids, uint256[] amounts, uint256 signedTransferNonce);\n', '\n', '    /**\n', '     * @dev True if this is the prototype, false if this is an active (clone/proxy) token contract.\n', '     */\n', '    function isPrototype() external view returns (bool);\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev Do initial registration of a clone. Should be called in the same\n', '     * transaction as the actual cloning. Can only be called once.\n', '     */\n', '    function initialRegister(address _bridgeDataAddress, string memory _orginalChainName, address _originalChainAddress) external;\n', '\n', '    /**\n', '     * @dev The name of the original chain this token is bridged from.\n', '     */\n', '    function originalChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The address of this token on the original chain this is bridged from.\n', '     */\n', '    function originalChainAddress() external view returns (address);\n', '\n', '    /**\n', '     * @dev The signed transfer nonce for an account.\n', '     */\n', '    function signedTransferNonce(address account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev True if transfers are possible at this time.\n', '     */\n', '    function transferEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev Outward-facing function for signed transfer: assembles the expected data and then calls the internal function to do the rest.\n', '     * Can called by anyone knowing about the right signature, but can only transfer to the given specific target.\n', '     */\n', '    function signedBatchTransfer(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory signature) external;\n', '\n', '    /**\n', '     * @dev Outward-facing function for operator-driven signed transfer: assembles the expected data and then calls the internal function to do the rest.\n', '     * Can transfer to any target, but only be called by the trusted operator contained in the signature.\n', '     */\n', '    function signedBatchTransferWithOperator(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory signature) external;\n', '\n', '}\n', '\n', '// File: contracts/BridgeHead.sol\n', '\n', '/*\n', ' * Implements the Bridge Head on one side of the Crypto stamp bridge.\n', ' * The Bridge API interacts with this contract by listening to events and\n', ' * issuing relevant calls to functions on the Bridge Head the other side (which\n', ' * is another copy of this contract), as well as handing out or executing\n', ' * signed messages to be processed by this contract in response to events on\n', ' * that other Bridge Head.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract BridgeHead is BridgeHeadI {\n', '    using Address for address;\n', '\n', '    BridgeDataI public override bridgeData;\n', '\n', '    uint256 public depositSunsetTimestamp;\n', '\n', '    // Marks contracts that are treated as if they were token holder contracts, i.e. any tokens they own are treated as deposited.\n', '    // Note: all those addresses need to give approval for all tokens of affected contracts to this bridge head.\n', '    mapping(address => bool) public tokenHolderEquivalent;\n', '\n', '    uint256 public override minSignatures;\n', '\n', '    // Marks if an address belongs to an allowed signer for exits.\n', '    mapping(address => bool) public allowedSigner;\n', '\n', '    // Marks if an exit nonce for a specific signer address has been used.\n', '    // As we can give out exit messages to different users, we cannot guarantee an order but need to prevent replay.\n', '    mapping(address => mapping(uint256 => bool)) public exitNonceUsed;\n', '\n', '    event BridgeDataChanged(address indexed previousBridgeData, address indexed newBridgeData);\n', '    event MinSignaturesSet(uint256 minSignatures);\n', '    event DepositSunsetAnnounced(uint256 timestamp);\n', '    event AllowedSignerSet(address indexed signerAddress, bool enabled);\n', '    event TokenHolderEquivalentSet(address indexed holderAddress, bool enabled);\n', '\n', '    constructor(address _bridgeDataAddress, uint256 _minSignatures)\n', '    {\n', '        bridgeData = BridgeDataI(_bridgeDataAddress);\n', '        require(address(bridgeData) != address(0x0), "You need to provide an actual bridge data contract.");\n', '        minSignatures = _minSignatures;\n', '        require(minSignatures > 0, "At least one signature has to be required.");\n', '    }\n', '\n', '    modifier onlyBridgeControl()\n', '    {\n', '        require(msg.sender == bridgeData.getAddress("bridgeControl"), "bridgeControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier onlySelfOrBC()\n', '    {\n', '        require(msg.sender == address(this) || msg.sender == bridgeData.getAddress("bridgeControl"),\n', '                "Signed exit data or bridgeControl key required.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenAssignmentControl() {\n', '        require(msg.sender == bridgeData.getAddress("tokenAssignmentControl"), "tokenAssignmentControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenHolder() {\n', '        require(msg.sender == bridgeData.getAddress("tokenHolder"), "Only token holder can call this function.");\n', '        _;\n', '    }\n', '\n', '    modifier requireDepositEnabled() {\n', '        require(depositEnabled() == true, "This call only works when deposits are enabled.");\n', '        _;\n', '    }\n', '\n', '    modifier requireExitEnabled() {\n', '        require(exitEnabled() == true, "This call only works when exits are enabled.");\n', '        _;\n', '    }\n', '\n', '    /*** Enable adjusting variables after deployment ***/\n', '\n', '    function setBridgeData(BridgeDataI _newBridgeData)\n', '    external\n', '    onlyBridgeControl\n', '    {\n', '        require(address(_newBridgeData) != address(0x0), "You need to provide an actual bridge data contract.");\n', '        emit BridgeDataChanged(address(bridgeData), address(_newBridgeData));\n', '        bridgeData = _newBridgeData;\n', '    }\n', '\n', '    function setMinSignatures(uint256 _newMinSignatures)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        require(_newMinSignatures > 0, "At least one signature has to be required.");\n', '        minSignatures = _newMinSignatures;\n', '        emit MinSignaturesSet(minSignatures);\n', '    }\n', '\n', '    function setDepositSunsetTimestamp(uint256 _timestamp)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        depositSunsetTimestamp = _timestamp;\n', '        emit DepositSunsetAnnounced(_timestamp);\n', '    }\n', '\n', '    function setTokenSunsetTimestamp(uint256 _timestamp)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        bridgeData.setTokenSunsetTimestamp(_timestamp);\n', '    }\n', '\n', '    function setAllSunsetTimestamps(uint256 _timestamp)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        setDepositSunsetTimestamp(_timestamp);\n', '        bridgeData.setTokenSunsetTimestamp(_timestamp);\n', '    }\n', '\n', '    function setAllowedSigners(address[] memory _signerAddresses, bool _enabled)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        uint256 addrcount = _signerAddresses.length;\n', '        for (uint256 i = 0; i < addrcount; i++) {\n', '            allowedSigner[_signerAddresses[i]] = _enabled;\n', '            emit AllowedSignerSet(_signerAddresses[i], _enabled);\n', '        }\n', '    }\n', '\n', '    function setTokenHolderEquivalent(address[] memory _holderAddresses, bool _enabled)\n', '    public\n', '    onlyBridgeControl\n', '    {\n', '        uint256 addrcount = _holderAddresses.length;\n', '        for (uint256 i = 0; i < addrcount; i++) {\n', '            tokenHolderEquivalent[_holderAddresses[i]] = _enabled;\n', '            emit TokenHolderEquivalentSet(_holderAddresses[i], _enabled);\n', '        }\n', '    }\n', '\n', '    function bridgeControl()\n', '    public view override\n', '    returns (address) {\n', '        return bridgeData.getAddress("bridgeControl");\n', '    }\n', '\n', '    function tokenHolder()\n', '    public view override\n', '    returns (TokenHolderI) {\n', '        return TokenHolderI(bridgeData.getAddress("tokenHolder"));\n', '    }\n', '\n', '    function connectedChainName()\n', '    public view override\n', '    returns (string memory) {\n', '        return bridgeData.connectedChainName();\n', '    }\n', '\n', '    function ownChainName()\n', '    public view override\n', '    returns (string memory) {\n', '        return bridgeData.ownChainName();\n', '    }\n', '\n', '    // Return true if deposits are possible.\n', '    // This can have additional conditions to just the sunset variable, e.g. actually having a token holder set.\n', '    function depositEnabled()\n', '    public view override\n', '    returns (bool)\n', '    {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        return (bridgeData.getAddress("tokenHolder") != address(0x0)) && (depositSunsetTimestamp == 0 || depositSunsetTimestamp > block.timestamp);\n', '    }\n', '\n', '    // Return true if exits are possible.\n', '    // This can have additional conditions, e.g. actually having a token holder set.\n', '    function exitEnabled()\n', '    public view override\n', '    returns (bool)\n', '    {\n', '        return minSignatures > 0 && bridgeData.getAddress("tokenHolder") != address(0x0);\n', '    }\n', '\n', '    /*** deposit functionality ***/\n', '\n', '    // ERC721 token has been deposited, signal the bridge.\n', '    function tokenDepositedERC721(address _tokenAddress, uint256 _tokenId, address _otherChainRecipient)\n', '    external override\n', '    onlyTokenHolder\n', '    requireDepositEnabled\n', '    {\n', '        emit TokenDepositedERC721(_tokenAddress, _tokenId, _otherChainRecipient);\n', '    }\n', '\n', '    // ERC1155 tokens have been deposited, signal the bridge.\n', '    function tokenDepositedERC1155Batch(address _tokenAddress, uint256[] calldata _tokenIds, uint256[] calldata _amounts, address _otherChainRecipient)\n', '    external override\n', '    onlyTokenHolder\n', '    requireDepositEnabled\n', '    {\n', '        emit TokenDepositedERC1155Batch(_tokenAddress, _tokenIds, _amounts, _otherChainRecipient);\n', '    }\n', '\n', '    // Move an ERC721 token to the other side of the bridge, where _otherChainRecipient will receive it.\n', '    function depositERC721(address _tokenAddress, uint256 _tokenId, address _otherChainRecipient)\n', '    external override\n', '    requireDepositEnabled\n', '    {\n', '        IERC721(_tokenAddress).safeTransferFrom(msg.sender, bridgeData.getAddress("tokenHolder"), _tokenId, abi.encode(_otherChainRecipient));\n', '    }\n', '\n', '    // Move ERC1155 tokens to the other side of the bridge.\n', '    function depositERC1155Batch(address _tokenAddress, uint256[] calldata _tokenIds, uint256[] calldata _amounts, address _otherChainRecipient)\n', '    external override\n', '    requireDepositEnabled\n', '    {\n', '        IERC1155(_tokenAddress).safeBatchTransferFrom(msg.sender, bridgeData.getAddress("tokenHolder"), _tokenIds, _amounts, abi.encode(_otherChainRecipient));\n', '    }\n', '\n', '    /*** exit functionality ***/\n', '\n', '    function processExitData(bytes memory _payload, uint256 _expirationTimestamp, bytes[] memory _signatures, uint256[] memory _exitNonces)\n', '    external override\n', '    requireExitEnabled\n', '    {\n', '        require(_payload.length >= 4, "Payload is too short.");\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(_expirationTimestamp > block.timestamp, "Message is expired.");\n', '        uint256 sigCount = _signatures.length;\n', '        require(sigCount == _exitNonces.length, "Both input arrays need to be the same length.");\n', '        require(sigCount >= minSignatures, "Need to have enough signatures.");\n', '        // Check signatures.\n', '        address lastCheckedAddr;\n', '        for (uint256 i = 0; i < sigCount; i++) {\n', '            require(_signatures[i].length == 65, "Signature has wrong length.");\n', '            bytes32 data = keccak256(abi.encodePacked(address(this), block.chainid, _exitNonces[i], _expirationTimestamp, _payload));\n', '            bytes32 hash = ECDSA.toEthSignedMessageHash(data);\n', '            address signer = ECDSA.recover(hash, _signatures[i]);\n', '            require(allowedSigner[signer], "Signature does not match allowed signer.");\n', '            // Check that no signer is listed multiple times by requiring ascending order.\n', '            require(uint160(lastCheckedAddr) < uint160(signer), "Signers need ascending order and no repeats.");\n', '            lastCheckedAddr = signer;\n', '            // Check nonce.\n', '            require(exitNonceUsed[signer][_exitNonces[i]] == false, "Unable to replay exit message.");\n', '            exitNonceUsed[signer][_exitNonces[i]] = true;\n', '        }\n', '        // Execute the payload.\n', '        address(this).functionCall(_payload);\n', '    }\n', '\n', '    function predictTokenAddress(string memory _prototypeName, address _foreignAddress)\n', '    public view override\n', '    returns (address)\n', '    {\n', '        bytes32 cloneSalt = bytes32(uint256(uint160(_foreignAddress)));\n', '        address prototypeAddress = bridgeData.getAddress(_prototypeName);\n', '        return Clones.predictDeterministicAddress(prototypeAddress, cloneSalt);\n', '    }\n', '\n', '    function exitERC721(address _tokenAddress, uint256 _tokenId, address _recipient, address _foreignAddress, bool _allowMinting, string memory _symbol, bytes memory _propertiesData)\n', '    public override\n', '    onlySelfOrBC\n', '    requireExitEnabled\n', '    {\n', '        require(_tokenAddress != address(0) || _foreignAddress != address(0), "Either foreign or native token address needs to be given.");\n', '        if (_tokenAddress == address(0)) {\n', '            // No chain-native token address given, predict and potentially deploy it.\n', '            require(_allowMinting, "Minting needed for new token.");\n', '            bytes32 cloneSalt = bytes32(uint256(uint160(_foreignAddress)));\n', '            address prototypeERC721Address = bridgeData.getAddress("ERC721Prototype");\n', '            _tokenAddress = Clones.predictDeterministicAddress(prototypeERC721Address, cloneSalt);\n', '            if (!_tokenAddress.isContract()) {\n', '                // Deploy clone and do initial registration of that contract.\n', '                address newInstance = Clones.cloneDeterministic(prototypeERC721Address, cloneSalt);\n', '                require(newInstance == _tokenAddress, "Error deploying new token.");\n', '                BridgedERC721I(_tokenAddress).initialRegister(\n', '                    address(bridgeData), _symbol,\n', '                    string(abi.encodePacked("Bridged ", _symbol, " (from ", connectedChainName(), ")")),\n', '                    connectedChainName(), _foreignAddress);\n', '                emit BridgedTokenDeployed(_tokenAddress, _foreignAddress);\n', '            }\n', '        }\n', '        // Instantiate the token contract.\n', '        IERC721 token = IERC721(_tokenAddress);\n', '        if (_allowMinting && !ERC721ExistsI(_tokenAddress).exists(_tokenId)) {\n', "            // NFT doesn't exist, mint directly to recipient - if we have data, mint with that.\n", '            if (_propertiesData.length > 0) {\n', '                ERC721DataMintableI(_tokenAddress).safeMintWithData(_recipient, _tokenId, _propertiesData);\n', '            }\n', '            else {\n', '                ERC721MintableI(_tokenAddress).safeMint(_recipient, _tokenId);\n', '            }\n', '        }\n', '        else {\n', '            // The NFT should exist and the bridge should hold it, so hand it to the recipient.\n', "            // Note that .exists() is not in the ERC721 standard, so we can't test with that\n", '            // for generic tokens, but .ownerOf() should throw in that case.\n', '            address currentOwner = token.ownerOf(_tokenId);\n', '            // Set properties if needed.\n', '            if (_propertiesData.length > 0) {\n', '                ERC721SettablePropertiesI(_tokenAddress).setPropertiesFromData(_tokenId, _propertiesData);\n', '            }\n', '            // Now, do the safe transfer (should be the last state change to prevent re-entrancy).\n', '            if (currentOwner == bridgeData.getAddress("tokenHolder")) {\n', '                tokenHolder().safeTransferERC721(_tokenAddress, _tokenId, _recipient);\n', '            }\n', '            else if (tokenHolderEquivalent[currentOwner] == true) {\n', '                token.safeTransferFrom(currentOwner, _recipient, _tokenId);\n', '            }\n', '            else if (currentOwner.isContract() &&\n', '                     (IERC165(currentOwner).supportsInterface(type(CollectionI).interfaceId) ||\n', '                      ERC721ExistsI(bridgeData.getAddress("Collections")).exists(uint256(uint160(currentOwner)))) &&\n', '                     CollectionI(currentOwner).ownerAddress() == address(tokenHolder())) {\n', "                // It's a contract and either supports the Collection interface\n", '                // or is a token registered in Collections, so it is a Collection,\n', '                // and it is owned by the holder.\n', '                // The latter condition is there because the original Collections\n', '                // contract on Ethereum Layer 1 does not register its own\n', '                // interface via ERC165.\n', '                // And then, we need to assemble the payload and use callAsHolder\n', '                // as the current owner of the Collection needs to call the\n', '                // safeTransferTo function.\n', '                // NOTE: abi.encodeWithSelector(CollectionI.safeTransferTo.selector, ...)\n', '                // would be nicer but has issues with overloading, see\n', '                // https://github.com/ethereum/solidity/issues/3556\n', '                callAsHolder(payable(currentOwner), abi.encodeWithSignature("safeTransferTo(address,uint256,address)", _tokenAddress, _tokenId, _recipient));\n', '            }\n', '            else {\n', '                revert("Bridge has no access to this token.");\n', '            }\n', '        }\n', '        // If we get here, the exit has been performed successfully.\n', '        emit TokenExitedERC721(_tokenAddress, _tokenId, _recipient);\n', '    }\n', '\n', '    function exitERC721Existing(address _tokenAddress, uint256 _tokenId, address _recipient)\n', '    external override\n', '    {\n', '        exitERC721(_tokenAddress, _tokenId, _recipient, address(0), false, "", "");\n', '    }\n', '\n', '    function exitERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient, address _foreignAddress, address _tokenSource)\n', '    public override\n', '    onlySelfOrBC\n', '    requireExitEnabled\n', '    {\n', '        require(_tokenAddress != address(0) || _foreignAddress != address(0), "Either foreign or native token address needs to be given.");\n', '        if (_tokenAddress == address(0)) {\n', '            // No chain-native token address given, predict and potentially deploy it.\n', '            require(_tokenSource == address(0), "Minting source needed for new token.");\n', '            bytes32 cloneSalt = bytes32(uint256(uint160(_foreignAddress)));\n', '            address prototypeERC1155Address = bridgeData.getAddress("ERC1155Prototype");\n', '            _tokenAddress = Clones.predictDeterministicAddress(prototypeERC1155Address, cloneSalt);\n', '            if (!_tokenAddress.isContract()) {\n', '                address newInstance = Clones.cloneDeterministic(prototypeERC1155Address, cloneSalt);\n', '                require(newInstance == _tokenAddress, "Error deploying new token.");\n', '                BridgedERC1155I(_tokenAddress).initialRegister(address(bridgeData), connectedChainName(), _foreignAddress);\n', '                emit BridgedTokenDeployed(_tokenAddress, _foreignAddress);\n', '            }\n', '        }\n', '        // According to the token source, determine where to get the token(s) from.\n', "        // Actual transfer will fail if source doesn't have enough tokens.\n", '        // Note that safe transfer should be the last state change to prevent re-entrancy.\n', '        if (_tokenSource == address(0)) {\n', "            // NFT doesn't exist, mint directly to recipient.\n", '            ERC1155MintableI(_tokenAddress).mintBatch(_recipient, _tokenIds, _amounts);\n', '        }\n', '        else if (_tokenSource == bridgeData.getAddress("tokenHolder")) {\n', '            tokenHolder().safeTransferERC1155Batch(_tokenAddress, _tokenIds, _amounts, _recipient);\n', '        }\n', '        else if (tokenHolderEquivalent[_tokenSource] == true) {\n', '            IERC1155(_tokenAddress).safeBatchTransferFrom(_tokenSource, _recipient, _tokenIds, _amounts, "");\n', '        }\n', '        else if (_tokenSource.isContract() &&\n', '                 (IERC165(_tokenSource).supportsInterface(type(CollectionI).interfaceId) ||\n', '                 ERC721ExistsI(bridgeData.getAddress("Collections")).exists(uint256(uint160(_tokenSource)))) &&\n', '                 CollectionI(_tokenSource).ownerAddress() == address(tokenHolder())) {\n', "            // It's a contract and either supports the Collection interface\n", '            // or is a token registered in Collections, so it is a Collection,\n', '            // and it is owned by the holder.\n', '            // The latter condition is there because the original Collections\n', '            // contract on Ethereum Layer 1 does not register its own\n', '            // interface via ERC165.\n', '            // And then, we need to assemble the payload and use callAsHolder\n', '            // as the current owner of the Collection needs to call the\n', '            // safeTransferTo function.\n', '            // NOTE: abi.encodeWithSelector(CollectionI.safeTransferTo.selector, ...)\n', '            // would be nicer but has issues with overloading, see\n', '            // https://github.com/ethereum/solidity/issues/3556\n', '            uint256 batchcount = _tokenIds.length;\n', '            require(batchcount == _amounts.length, "Both token IDs and amounts need to be the same length.");\n', '            for (uint256 i = 0; i < batchcount; i++) {\n', '                callAsHolder(payable(_tokenSource), abi.encodeWithSignature("safeTransferTo(address,uint256,address,uint256)", _tokenAddress, _tokenIds[i], _recipient, _amounts[i]));\n', '            }\n', '        }\n', '        else {\n', '            revert("Bridge has no access to this token.");\n', '        }\n', '        // If we get here, the exit has been performed successfully.\n', '        emit TokenExitedERC1155Batch(_tokenAddress, _tokenIds, _amounts, _recipient);\n', '    }\n', '\n', '    function exitERC1155BatchFromHolder(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient)\n', '    external override\n', '    {\n', '        exitERC1155Batch(_tokenAddress, _tokenIds, _amounts, _recipient, address(0), bridgeData.getAddress("tokenHolder"));\n', '    }\n', '\n', '    /*** Forward calls to external contracts ***/\n', '\n', '    // Given a contract address and an already-encoded payload (with a function call etc.),\n', '    // we call that contract with this payload, e.g. to trigger actions in the name of the token holder.\n', '    function callAsHolder(address payable _remoteAddress, bytes memory _callPayload)\n', '    public override payable\n', '    onlySelfOrBC\n', '    {\n', '        tokenHolder().externalCall(_remoteAddress, _callPayload);\n', '    }\n', '\n', '    /*** Enable reverse ENS registration ***/\n', '\n', '    // Call this with the address of the reverse registrar for the respective network and the ENS name to register.\n', "    // The reverse registrar can be found as the owner of 'addr.reverse' in the ENS system.\n", '    // For Mainnet, the address needed is 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069\n', '    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        require(_reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', '        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\n', '    }\n', '\n', "    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\n", '\n', "    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\n", '    function rescueToken(address _foreignToken, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        IERC20 erc20Token = IERC20(_foreignToken);\n', '        erc20Token.transfer(_to, erc20Token.balanceOf(address(this)));\n', '    }\n', '\n', "    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\n", '    function approveNFTrescue(IERC721 _foreignNFT, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        _foreignNFT.setApprovalForAll(_to, true);\n', '    }\n', '\n', '}']