['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.7.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// ERC20 Interface\n', 'interface iERC20 {\n', '    function balanceOf(address) external view returns (uint256);\n', '    function transfer(address, uint) external returns (bool);\n', '    function approve(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '    function burn(uint) external;\n', '}\n', '// RUNE Interface\n', 'interface iRUNE {\n', '    function transferTo(address, uint) external returns (bool);\n', '}\n', '// ROUTER Interface\n', 'interface iROUTER {\n', '    function deposit(address, address, uint, string calldata) external;\n', '}\n', '\n', 'library SafeMath {\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a && c >= b);\n', '        return c;\n', '    }\n', '}\n', '\n', '// Router is managed by THORChain Vaults\n', 'contract Router {\n', '    using SafeMath for uint;\n', '    address public RUNE = 0x3155BA85D5F96b2d030a4966AF206230e46849cb;\n', '\n', '    struct Coin {\n', '        address asset;\n', '        uint amount;\n', '    }\n', '\n', '    // Vault allowance for each asset\n', '    mapping(address => mapping(address => uint)) public vaultAllowance;\n', '\n', '    // Emitted for all deposits, the memo distinguishes for swap, add, remove, donate etc\n', '    event Deposit(address indexed to, address indexed asset, uint amount, string memo);\n', '\n', '    // Emitted for all outgoing transfers, the vault dictates who sent it, memo used to track.\n', '    event TransferOut(address indexed vault, address indexed to, address asset, uint amount, string memo);\n', '\n', '    // Changes the spend allowance between vaults\n', '    event TransferAllowance(address indexed oldVault, address indexed newVault, address asset, uint amount, string memo);\n', '\n', '    // Specifically used to batch send the entire vault assets\n', '    event VaultTransfer(address indexed oldVault, address indexed newVault, Coin[] coins, string memo);\n', '\n', '    constructor() {}\n', '\n', '    // Deposit an asset with a memo. ETH is forwarded, ERC-20 stays in ROUTER\n', '    function deposit(address payable vault, address asset, uint amount, string memory memo) public payable {\n', '        uint safeAmount;\n', '        if(asset == address(0)){\n', '            safeAmount = msg.value;\n', '            vault.call{value:safeAmount}("");\n', '        } else if(asset == RUNE) {\n', '            safeAmount = amount;\n', '            iRUNE(RUNE).transferTo(address(this), amount);\n', '            iERC20(RUNE).burn(amount);\n', '        } else {\n', '            safeAmount = safeTransferFrom(asset, amount); // Transfer asset\n', '            vaultAllowance[vault][asset] = vaultAllowance[vault][asset].add(safeAmount); // Credit to chosen vault\n', '        }\n', '        emit Deposit(vault, asset, safeAmount, memo);\n', '    }\n', '\n', '    //############################## ALLOWANCE TRANSFERS ##############################\n', '\n', '    // Use for "moving" assets between vaults (asgard<>ygg), as well "churning" to a new Asgard\n', '    function transferAllowance(address router ,address newVault, address asset, uint amount, string memory memo) public {\n', '        if (router == address(this)){\n', '            _adjustAllowances(newVault, asset, amount);\n', '            emit TransferAllowance(msg.sender, newVault, asset, amount, memo);\n', '        } else {\n', '            _routerDeposit(router, newVault, asset, amount, memo);\n', '        }\n', '    }\n', '\n', '    //############################## ASSET TRANSFERS ##############################\n', '\n', '    // Any vault calls to transfer any asset to any recipient.\n', '    function transferOut(address payable to, address asset, uint amount, string memory memo) public payable {\n', '        uint safeAmount;\n', '        if(asset == address(0)){\n', '            safeAmount = msg.value;\n', '            to.call{value:msg.value}(""); // Send ETH\n', '        } else {\n', '            vaultAllowance[msg.sender][asset] = vaultAllowance[msg.sender][asset].sub(amount); // Reduce allowance\n', '            iERC20(asset).transfer(to, amount); // Send Asset\n', '            safeAmount = amount;\n', '        }\n', '        emit TransferOut(msg.sender, to, asset, safeAmount, memo);\n', '    }\n', '\n', '    // Batch Transfer\n', '    function batchTransferOut(address[] memory recipients, Coin[] memory coins, string[] memory memos) public payable {\n', '        for(uint i = 0; i < coins.length; i++){\n', '            transferOut(payable(recipients[i]), coins[i].asset, coins[i].amount, memos[i]);\n', '        }\n', '    }\n', '\n', '    //############################## VAULT MANAGEMENT ##############################\n', '\n', '    // A vault can call to "return" all assets to an asgard, including ETH. \n', '    function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) public payable {\n', '        if (router == address(this)){\n', '            for(uint i = 0; i < coins.length; i++){\n', '                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n', '            }\n', '            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \n', '        } else {\n', '            for(uint i = 0; i < coins.length; i++){\n', '                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n', '            }\n', '        }\n', '        asgard.call{value:msg.value}(""); //ETH amount needs to be parsed from tx.\n', '    }\n', '\n', '    //############################## HELPERS ##############################\n', '\n', '    // Safe transferFrom in case asset charges transfer fees\n', '    function safeTransferFrom(address _asset, uint _amount) internal returns(uint) {\n', '        uint _startBal = iERC20(_asset).balanceOf(address(this));\n', '        iERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n', '        return iERC20(_asset).balanceOf(address(this)).sub(_startBal);\n', '    }\n', '\n', '    // Decrements and Increments Allowances between two vaults\n', '    function _adjustAllowances(address _newVault, address _asset, uint _amount) internal {\n', '        vaultAllowance[msg.sender][_asset] = vaultAllowance[msg.sender][_asset].sub(_amount);\n', '        vaultAllowance[_newVault][_asset] = vaultAllowance[_newVault][_asset].add(_amount);\n', '    }\n', '\n', '    // Adjust allowance and forwards funds to new router, credits allowance to desired vault\n', '    function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n', '        vaultAllowance[msg.sender][_asset] = vaultAllowance[msg.sender][_asset].sub(_amount);\n', '        iERC20(_asset).approve(_router, _amount); // Approve to transfer\n', '        iROUTER(_router).deposit(_vault, _asset, _amount, _memo); // Transfer\n', '    }\n', '}']