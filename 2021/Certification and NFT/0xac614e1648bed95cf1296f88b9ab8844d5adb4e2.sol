['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\LiquidityMiningData.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'struct LiquidityMiningSetupConfiguration {\n', '    bool add;\n', '    uint256 index;\n', '    LiquidityMiningSetup data;\n', '}\n', '\n', '// liquidity mining setup struct\n', 'struct LiquidityMiningSetup {\n', '    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\n', '    uint256 objectId; // items object id for the liquidity pool token.\n', '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    uint256 startBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 endBlock; // liquidity mining setup end block (used only if free is false).\n', '    uint256 rewardPerBlock; // liquidity mining setup reward per single block.\n', '    uint256 currentRewardPerBlock; // liquidity mining setup current reward per single block.\n', '    uint256 totalSupply; // current liquidity added in this setup (used only if free is true).\n', '    uint256 lastBlockUpdate; // number of the block where an update was triggered.\n', '    uint256 maximumLiquidity; // maximum liquidity stakeable in the contract (used only if free is false).\n', '    uint256 currentStakedLiquidity; // currently staked liquidity (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', "    uint256 renewTimes; // if the locked setup is renewable or if it's one time (used only if free is false).\n", '    uint256 penaltyFee; // fee paid when the user exits a still active locked liquidity mining setup (used only if free is false).\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '}\n', '\n', '// position struct\n', 'struct LiquidityMiningPosition {\n', '    address uniqueOwner; // address representing the extension address, address(0) if objectId is populated.\n', '    uint256 setupIndex; // the setup index.\n', '    uint256 setupStartBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 setupEndBlock; // liquidity mining setup end block (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', '    // LiquidityPoolData liquidityPoolData; // amm liquidity pool data.\n', '    uint256 liquidityPoolTokenAmount;\n', '    uint256 reward; // position reward.\n', '    uint256 lockedRewardPerBlock; // position locked reward per block.\n', '    uint256 creationBlock; // block when this position was created.\n', '}\n', '\n', '// stake data struct\n', 'struct LiquidityMiningPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount; // amount of main token or liquidity pool token.\n', '    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMiningExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMiningExtension {\n', '\n', '    function init(bool byMint, address host) external;\n', '\n', '    function setHost(address host) external;\n', '\n', '    function data() external view returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount, address recipient) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMining.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMining {\n', '\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function setups() external view returns (LiquidityMiningSetup[] memory);\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '    \n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function safeApprove(address spender, uint256 amount) external;\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\DFOHub.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IDoubleProxy {\n', '    function proxy() external view returns (address);\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns (address);\n', '    function getStateHolderAddress() external view returns(address);\n', '    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function getFunctionalityData(string calldata codeName) external view returns(address, uint256, string memory, address, uint256);\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function getUint256(string calldata name) external view returns(uint256);\n', '    function getAddress(string calldata name) external view returns(address);\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\DFOBasedLiquidityMiningExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract DFOBasedLiquidityMiningExtension is ILiquidityMiningExtension {\n', '\n', '    string private constant FUNCTIONALITY_NAME = "manageLiquidityMining";\n', '\n', '    // wallet who has control on the extension\n', '    address internal _doubleProxy;\n', '\n', '    // mapping that contains all the liquidity mining contract linked to this extension\n', '    address internal _liquidityMiningContract;\n', '\n', '    // the reward token address linked to this liquidity mining contract\n', '    address internal _rewardTokenAddress;\n', '\n', '    // whether the token is by mint or by reserve\n', '    bool internal _byMint;\n', '\n', '    /** MODIFIERS */\n', '\n', '    /** @dev liquidityMiningOnly modifier used to check for unauthorized transfers. */\n', '    modifier liquidityMiningOnly() {\n', '        require(msg.sender == _liquidityMiningContract, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev hostOnly modifier used to check for unauthorized edits. */\n', '    modifier hostOnly() {\n', '        require(_isFromDFO(msg.sender), "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** PUBLIC METHODS */\n', '\n', '    function init(bool byMint, address host) public virtual override {\n', '        require(_liquidityMiningContract == address(0), "Already init");\n', '        require(host != address(0), "blank host");\n', '        _rewardTokenAddress = ILiquidityMining(_liquidityMiningContract = msg.sender)._rewardTokenAddress();\n', '        _byMint = byMint;\n', '        _doubleProxy = host;\n', '    }\n', '\n', '    /** @dev allows the DFO to update the double proxy address.\n', '      * @param newDoubleProxy new double proxy address.\n', '     */\n', '    function setHost(address newDoubleProxy) public virtual override hostOnly {\n', '        _doubleProxy = newDoubleProxy;\n', '    }\n', '\n', '    function data() view public virtual override returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress) {\n', '        return (_liquidityMiningContract, _byMint, _doubleProxy, _rewardTokenAddress);\n', '    }\n', '\n', '    /** @dev transfers the input amount to the caller liquidity mining contract.\n', '      * @param amount amount of erc20 to transfer or mint.\n', '     */\n', '    function transferTo(uint256 amount, address recipient) override public liquidityMiningOnly {\n', '        IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).submit(FUNCTIONALITY_NAME, abi.encode(address(0), 0, true, _rewardTokenAddress, recipient, amount, _byMint));\n', '    }\n', '\n', '    /** @dev transfers the input amount from the caller liquidity mining contract to the extension.\n', '      * @param amount amount of erc20 to transfer back or burn.\n', '     */\n', '    function backToYou(uint256 amount) override payable public liquidityMiningOnly {\n', '        if(_rewardTokenAddress != address(0)) {\n', '            _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), amount);\n', '            _safeApprove(_rewardTokenAddress, _getFunctionalityAddress(), amount);\n', '            IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).submit(FUNCTIONALITY_NAME, abi.encode(address(0), 0, false, _rewardTokenAddress, msg.sender, amount, _byMint));\n', '        } else {\n', '            IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).submit{value : amount}(FUNCTIONALITY_NAME, abi.encode(address(0), 0, false, _rewardTokenAddress, msg.sender, amount, _byMint));\n', '        }\n', '    }\n', '\n', '    /** @dev this function calls the liquidity mining contract with the given address and sets the given liquidity mining setups.\n', '      * @param liquidityMiningSetups array containing all the liquidity mining setups.\n', "      * @param setPinned if we're updating the pinned setup or not.\n", '      * @param pinnedIndex new pinned setup index.\n', '     */\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) public override hostOnly {\n', '        ILiquidityMining(_liquidityMiningContract).setLiquidityMiningSetups(liquidityMiningSetups, clearPinned, setPinned, pinnedIndex);\n', '    }\n', '\n', '    /** PRIVATE METHODS */\n', '\n', '    /** @dev this function returns the address of the functionality with the FUNCTIONALITY_NAME.\n', '      * @return functionalityAddress functionality FUNCTIONALITY_NAME address.\n', '     */\n', '    function _getFunctionalityAddress() private view returns(address functionalityAddress) {\n', '        (functionalityAddress,,,,) = IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).getFunctionalityData(FUNCTIONALITY_NAME);\n', '    }\n', '\n', '    /** @dev this function returns the address of the wallet of the linked DFO.\n', '      * @return linked DFO wallet address.\n', '     */\n', '    function _getDFOWallet() private view returns(address) {\n', '        return IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDWalletAddress();\n', '    }\n', '\n', '    /** @dev this function returns true if the sender is an authorized DFO functionality, false otherwise.\n', '      * @param sender address of the caller.\n', '      * @return true if the call is from a DFO, false otherwise.\n', '     */\n', '    function _isFromDFO(address sender) private view returns(bool) {\n', '        return IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(sender);\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}']