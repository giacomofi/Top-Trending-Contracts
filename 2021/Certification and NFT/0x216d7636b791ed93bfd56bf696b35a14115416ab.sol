['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/*\n', 'This contract allows anyone to atomically mutate ERC20 tokens to a new token and back at a 1:1 ratio.  \n', 'This contract is atomic, decentralized, and has no owner.\n', '*/\n', ' \n', '\n', 'abstract contract ERC20Basic {\n', '  function totalSupply() virtual public view returns (uint256);\n', '  function balanceOf(address who) virtual public view returns (uint256);\n', '  function transfer(address to, uint256 value) virtual public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender)\n', '    virtual public view returns (uint256);\n', '\n', '  function transferFrom(address from, address to, uint256 value)\n', '    virtual public returns (bool);\n', '\n', '  function approve(address spender, uint256 value) virtual public returns (bool);\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '}\n', '\n', 'abstract contract ApproveAndCallFallBack {\n', '\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\n', '\n', '}\n', ' \n', '\n', 'contract _AtomicProxyToken {\n', '    \n', '  \n', '    address public _originalToken;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8  public decimals = 8;\n', '    uint private _totalSupply;\n', '    \n', '    uint public supplyFactor = 100000000;\n', '\n', '    event  Approval(address src, address ext, uint amt);\n', '    event  Transfer(address src, address dst, uint amt); \n', '\n', '    mapping (address => uint)                       public  balances;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '    mapping (address => uint)                       public  nonces;\n', '    \n', '    uint256 immutable MAX_INT  = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '    \n', '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '    \n', '    /// @notice The EIP-712 typehash for the permit struct used by the contract\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\n', '\n', '  \n', '\n', '   constructor(string memory tokenName, string memory tokenSymbol, address mutatingToken){\n', '       name = tokenName;\n', '       symbol = tokenSymbol;\n', '       _originalToken = mutatingToken;\n', '   }    \n', '\n', '    /**\n', '     *  \n', '     * @dev Deposit original tokens, receive proxy tokens \n', '     * @param amount Amount of original tokens to charge\n', '     */\n', '    function depositTokens(address from, uint amount) internal returns (bool)\n', '    {\n', '        require( amount > 0 );\n', '        \n', '        require( ERC20( _originalToken ).transferFrom( from, address(this), amount) );\n', '            \n', '        balances[from] += (amount * supplyFactor);\n', '        _totalSupply += (amount * supplyFactor);\n', '        \n', '        emit Transfer(address(0x0), from, amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev Withdraw original tokens, dissipate proxy tokens \n', '     * @param amount Amount of original tokens to release\n', '     */\n', '    function withdrawTokens(uint amount) public returns (bool)\n', '    {\n', '        address from = msg.sender;\n', '        require( amount > 0 );\n', '        \n', '        balances[from] -= (amount * supplyFactor);\n', '        _totalSupply -=  (amount * supplyFactor);\n', '        \n', '        emit Transfer( from, address(0x0), amount);\n', '            \n', '        require( ERC20( _originalToken ).transfer( from, amount) ); \n', '        \n', '        return true;\n', '    }\n', '    \n', '    \n', '     /**\n', '     * Do not allow Ether to enter \n', '     */\n', '     fallback()  external payable  \n', '    {\n', '        revert();\n', '    }\n', '    \n', '    \n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function approve(address ext, uint amt) public returns (bool) {\n', '        allowance[msg.sender][ext] = amt;\n', '        emit Approval(msg.sender, ext, amt);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint tokens) public returns (bool) {\n', '        address from = msg.sender;\n', '        balances[from] = balances[from] - (tokens);\n', '        \n', '        balances[to] = balances[to] + (tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        balances[from] = balances[from] - (tokens);\n', '        allowance[from][msg.sender] = allowance[from][msg.sender] - (tokens);\n', '        balances[to] = balances[to] + (tokens);\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n', '\n', '        allowance[msg.sender][spender] = tokens;\n', '\n', '        emit Approval(msg.sender, spender, tokens);\n', '\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '\n', '        return true;\n', '\n', '    }\n', '    \n', '    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public returns (bool success) {\n', '        \n', '        require( token == _originalToken );\n', '        \n', '        require( depositTokens(from, tokens) );\n', '\n', '        return true;\n', '\n', '     }\n', '     \n', '     \n', '      /**\n', '     * @notice Triggers an approval from owner to spends\n', '     * @param owner The address to approve from\n', '     * @param spender The address to be approved\n', '     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n', '     * @param deadline The time at which to expire the signature\n', '     * @param v The recovery byte of the signature\n', '     * @param r Half of the ECDSA signature pair\n', '     * @param s Half of the ECDSA signature pair\n', '     */\n', '    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n', '        \n', '       \n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "permit: invalid signature");\n', '        require(signatory == owner, "permit: unauthorized");\n', '        require(block.timestamp <= deadline, "permit: signature expired");\n', '\n', '        allowance[owner][spender] = rawAmount;\n', '\n', '        emit Approval(owner, spender, rawAmount);\n', '    }\n', '    \n', '    \n', '    function getChainId() internal view returns (uint) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '\n', '}']