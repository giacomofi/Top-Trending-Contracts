['pragma solidity >=0.6.0 <0.8.0;\n', 'import "@openzeppelin/contracts/utils/Create2.sol";\n', '\n', 'contract FerrumDeployer {\n', '    uint256 constant EXTERNAL_HASH = 0x0ddafcd8600839ce553cacb17e362c83ea42ccfd1e8c8b3cb4d075124196dfc0;\n', '    uint256 constant INTERNAL_HASH = 0x27fd0863a54f729686099446389b11108e6e34e7364d1f8e38a43e1661a07f3a;\n', '    event Deployed(address);\n', '    function deploy(bytes32 salt, bytes calldata bytecode)\n', '    external returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(salt, INTERNAL_HASH, msg.sender)\n', '        );\n', '        address deployed = Create2.deploy(0, _data, bytecode);\n', '        emit Deployed(deployed);\n', '        return deployed;\n', '    }\n', '\n', '    /**\n', '     * @dev Use this method if you want to incorporate the sender address in the contract address.\n', '     */\n', '    function deployFromContract(bytes32 salt, address deployer, bytes calldata bytecode)\n', '    external returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(salt, EXTERNAL_HASH, deployer)\n', '        );\n', '        address deployed = Create2.deploy(0, _data, bytecode);\n', '        emit Deployed(deployed);\n', '        return deployed;\n', '    }\n', '\n', '    function computeAddressFromContract(bytes32 salt, bytes32 bytecodeHash, address deployer)\n', '    external pure returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(salt, EXTERNAL_HASH, deployer)\n', '        );\n', '        return Create2.computeAddress(_data, bytecodeHash, deployer);\n', '    }\n', '\n', '    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer)\n', '    external view returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(salt, INTERNAL_HASH, deployer)\n', '        );\n', '        return Create2.computeAddress(_data, bytecodeHash);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n', ' * `CREATE2` can be used to compute in advance the address where a smart\n', ' * contract will be deployed, which allows for interesting new mechanisms known\n', " * as 'counterfactual interactions'.\n", ' *\n', ' * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n', ' * information.\n', ' */\n', 'library Create2 {\n', '    /**\n', '     * @dev Deploys a contract using `CREATE2`. The address where the contract\n', '     * will be deployed can be known in advance via {computeAddress}.\n', '     *\n', '     * The bytecode for a contract can be obtained from Solidity with\n', '     * `type(contractName).creationCode`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `bytecode` must not be empty.\n', '     * - `salt` must have not been used for `bytecode` already.\n', '     * - the factory must have a balance of at least `amount`.\n', '     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n', '     */\n', '    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n', '        address addr;\n', '        require(address(this).balance >= amount, "Create2: insufficient balance");\n', '        require(bytecode.length != 0, "Create2: bytecode length is zero");\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n', '        }\n', '        require(addr != address(0), "Create2: Failed on deploy");\n', '        return addr;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n', '     * `bytecodeHash` or `salt` will result in a new destination address.\n', '     */\n', '    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n', '        return computeAddress(salt, bytecodeHash, address(this));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n', "     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n", '     */\n', '    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n', '        );\n', '        return address(uint256(_data));\n', '    }\n', '}']