['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '/**\n', ' * @title FixidityLib\n', ' * @author Gadi Guy, Alberto Cuesta Canada\n', ' * @notice This library provides fixed point arithmetic with protection against\n', ' * overflow. \n', ' * All operations are done with int256 and the operands must have been created \n', ' * with any of the newFrom* functions, which shift the comma digits() to the \n', ' * right and check for limits.\n', ' * When using this library be sure of using maxNewFixed() as the upper limit for\n', ' * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\n', " * maxFixedAdd() if you want to be certain that those operations don't \n", ' * overflow.\n', ' */\n', 'library FixidityLib {\n', '\n', '    /**\n', '     * @notice Number of positions that the comma is shifted to the right.\n', '     */\n', '    function digits() internal pure returns(uint8) {\n', '        return 24;\n', '    }\n', '    \n', '    /**\n', '     * @notice This is 1 in the fixed point units used in this library.\n', '     * @dev Test fixed1() equals 10^digits()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function fixed1() internal pure returns(int256) {\n', '        return 1000000000000000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice The amount of decimals lost on each multiplication operand.\n', '     * @dev Test mulPrecision() equals sqrt(fixed1)\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function mulPrecision() internal pure returns(int256) {\n', '        return 1000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be represented in an int256\n', '     * @dev Test maxInt256() equals 2^255 -1\n', '     */\n', '    function maxInt256() internal pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n', '    }\n', '\n', '    /**\n', '     * @notice Minimum value that can be represented in an int256\n', '     * @dev Test minInt256 equals (2^255) * (-1)\n', '     */\n', '    function minInt256() internal pure returns(int256) {\n', '        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be converted to fixed point. Optimize for\n', '     * @dev deployment. \n', '     * Test maxNewFixed() equals maxInt256() / fixed1()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxNewFixed() internal pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be converted to fixed point. Optimize for\n', '     * deployment. \n', '     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function minNewFixed() internal pure returns(int256) {\n', '        return -57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as an addition operator.\n', '     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\n', '     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\n', '     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \n', '     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\n', '     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \n', '     */\n', '    function maxFixedAdd() internal pure returns(int256) {\n', '        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum negative value that can be safely in a subtraction.\n', '     * @dev Test maxFixedSub() equals minInt256() / 2\n', '     */\n', '    function maxFixedSub() internal pure returns(int256) {\n', '        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a multiplication operator.\n', '     * @dev Calculated as sqrt(maxInt256()*fixed1()). \n', "     * Be careful with your sqrt() implementation. I couldn't find a calculator\n", '     * that would give the exact square root of maxInt256*fixed1 so this number\n', '     * is below the real number by no more than 3*10**28. It is safe to use as\n', '     * a limit for your multiplications, although powers of two of numbers over\n', '     * this value might still work.\n', '     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\n', '     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \n', '     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\n', '     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedMul() internal pure returns(int256) {\n', '        return 240615969168004498257251713877715648331380787511296;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a dividend.\n', '     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\n', '     * Test maxFixedDiv() equals maxInt256()/fixed1()\n', '     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\n', '     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedDiv() internal pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a divisor.\n', '     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\n', '     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\n', '     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedDivisor() internal pure returns(int256) {\n', '        return 1000000000000000000000000000000000000000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 to fixed point units, equivalent to multiplying\n', '     * by 10^digits().\n', '     * @dev Test newFixed(0) returns 0\n', '     * Test newFixed(1) returns fixed1()\n', '     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\n', '     * Test newFixed(maxNewFixed()+1) fails\n', '     */\n', '    function newFixed(int256 x)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        assert(x <= maxNewFixed());\n', '        assert(x >= minNewFixed());\n', '        return x * fixed1();\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 in the fixed point representation of this \n', '     * library to a non decimal. All decimal digits will be truncated.\n', '     */\n', '    function fromFixed(int256 x)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return x / fixed1();\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 which is already in some fixed point \n', '     * representation to a different fixed precision representation.\n', '     * Both the origin and destination precisions must be 38 or less digits.\n', '     * Origin values with a precision higher than the destination precision\n', '     * will be truncated accordingly.\n', '     * @dev \n', '     * Test convertFixed(1,0,0) returns 1;\n', '     * Test convertFixed(1,1,1) returns 1;\n', '     * Test convertFixed(1,1,0) returns 0;\n', '     * Test convertFixed(1,0,1) returns 10;\n', '     * Test convertFixed(10,1,0) returns 1;\n', '     * Test convertFixed(10,0,1) returns 100;\n', '     * Test convertFixed(100,1,0) returns 10;\n', '     * Test convertFixed(100,0,1) returns 1000;\n', '     * Test convertFixed(1000,2,0) returns 10;\n', '     * Test convertFixed(1000,0,2) returns 100000;\n', '     * Test convertFixed(1000,2,1) returns 100;\n', '     * Test convertFixed(1000,1,2) returns 10000;\n', '     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\n', '     * Test convertFixed(maxInt256,0,1) throws\n', '     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\n', '     * Test convertFixed(1,0,38) returns 10**38;\n', '     * Test convertFixed(maxInt256,39,0) throws\n', '     * Test convertFixed(1,0,39) throws\n', '     */\n', '    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        assert(_originDigits <= 38 && _destinationDigits <= 38);\n', '        \n', '        uint8 decimalDifference;\n', '        if ( _originDigits > _destinationDigits ){\n', '            decimalDifference = _originDigits - _destinationDigits;\n', '            return x/int256((uint128(10)**uint128(decimalDifference)));\n', '        }\n', '        else if ( _originDigits < _destinationDigits ){\n', '            decimalDifference = _destinationDigits - _originDigits;\n', '            // Cast uint8 -> uint128 is safe\n', '            // Exponentiation is safe:\n', '            //     _originDigits and _destinationDigits limited to 38 or less\n', '            //     decimalDifference = abs(_destinationDigits - _originDigits)\n', '            //     decimalDifference < 38\n', '            //     10**38 < 2**128-1\n', '            assert(x <= maxInt256()/int256(uint128(10)**uint128(decimalDifference)));\n', '            assert(x >= minInt256()/int256(uint128(10)**uint128(decimalDifference)));\n', '            return x*(int256(uint128(10)**uint128(decimalDifference)));\n', '        }\n', '        // _originDigits == digits()) \n', '        return x;\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 which is already in some fixed point \n', '     * representation to that of this library. The _originDigits parameter is the\n', '     * precision of x. Values with a precision higher than FixidityLib.digits()\n', '     * will be truncated accordingly.\n', '     */\n', '    function newFixed(int256 x, uint8 _originDigits)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return convertFixed(x, _originDigits, digits());\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 in the fixed point representation of this \n', '     * library to a different representation. The _destinationDigits parameter is the\n', '     * precision of the output x. Values with a precision below than \n', '     * FixidityLib.digits() will be truncated accordingly.\n', '     */\n', '    function fromFixed(int256 x, uint8 _destinationDigits)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return convertFixed(x, digits(), _destinationDigits);\n', '    }\n', '\n', '    /**\n', '     * @notice Converts two int256 representing a fraction to fixed point units,\n', '     * equivalent to multiplying dividend and divisor by 10^digits().\n', '     * @dev \n', '     * Test newFixedFraction(maxFixedDiv()+1,1) fails\n', '     * Test newFixedFraction(1,maxFixedDiv()+1) fails\n', '     * Test newFixedFraction(1,0) fails     \n', '     * Test newFixedFraction(0,1) returns 0\n', '     * Test newFixedFraction(1,1) returns fixed1()\n', '     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\n', '     * Test newFixedFraction(1,fixed1()) returns 1\n', '     * Test newFixedFraction(1,fixed1()-1) returns 0\n', '     */\n', '    function newFixedFraction(\n', '        int256 numerator, \n', '        int256 denominator\n', '        )\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        assert(numerator <= maxNewFixed());\n', '        assert(denominator <= maxNewFixed());\n', '        assert(denominator != 0);\n', '        int256 convertedNumerator = newFixed(numerator);\n', '        int256 convertedDenominator = newFixed(denominator);\n', '        return divide(convertedNumerator, convertedDenominator);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the integer part of a fixed point number.\n', '     * @dev \n', '     * Test integer(0) returns 0\n', '     * Test integer(fixed1()) returns fixed1()\n', '     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\n', '     * Test integer(-fixed1()) returns -fixed1()\n', '     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\n', '     */\n', '    function integer(int256 x) internal pure returns (int256) {\n', "        return (x / fixed1()) * fixed1(); // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice Returns the fractional part of a fixed point number. \n', '     * In the case of a negative number the fractional is also negative.\n', '     * @dev \n', '     * Test fractional(0) returns 0\n', '     * Test fractional(fixed1()) returns 0\n', '     * Test fractional(fixed1()-1) returns 10^24-1\n', '     * Test fractional(-fixed1()) returns 0\n', '     * Test fractional(-fixed1()+1) returns -10^24-1\n', '     */\n', '    function fractional(int256 x) internal pure returns (int256) {\n', "        return x - (x / fixed1()) * fixed1(); // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice Converts to positive if negative.\n', '     * Due to int256 having one more negative number than positive numbers \n', '     * abs(minInt256) reverts.\n', '     * @dev \n', '     * Test abs(0) returns 0\n', '     * Test abs(fixed1()) returns -fixed1()\n', '     * Test abs(-fixed1()) returns fixed1()\n', '     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\n', '     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\n', '     */\n', '    function abs(int256 x) internal pure returns (int256) {\n', '        if (x >= 0) {\n', '            return x;\n', '        } else {\n', '            int256 result = -x;\n', '            assert (result > 0);\n', '            return result;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice x+y. If any operator is higher than maxFixedAdd() it \n', '     * might overflow.\n', '     * In solidity maxInt256 + 1 = minInt256 and viceversa.\n', '     * @dev \n', '     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\n', '     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\n', '     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\n', '     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\n', '     * Test add(maxInt256(),maxInt256()) fails\n', '     * Test add(minInt256(),minInt256()) fails\n', '     */\n', '    function add(int256 x, int256 y) internal pure returns (int256) {\n', '        int256 z = x + y;\n', '        if (x > 0 && y > 0) assert(z > x && z > y);\n', '        if (x < 0 && y < 0) assert(z < x && z < y);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '     * @notice x-y. You can use add(x,-y) instead. \n', '     * @dev Tests covered by add(x,y)\n', '     */\n', '    function subtract(int256 x, int256 y) internal pure returns (int256) {\n', '        return add(x,-y);\n', '    }\n', '\n', '    /**\n', '     * @notice x*y. If any of the operators is higher than maxFixedMul() it \n', '     * might overflow.\n', '     * @dev \n', '     * Test multiply(0,0) returns 0\n', '     * Test multiply(maxFixedMul(),0) returns 0\n', '     * Test multiply(0,maxFixedMul()) returns 0\n', '     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\n', '     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\n', '     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\n', '     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\n', '     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\n', '     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\n', '     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\n', '     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\n', '     */\n', '    function multiply(int256 x, int256 y) internal pure returns (int256) {\n', '        if (x == 0 || y == 0) return 0;\n', '        if (y == fixed1()) return x;\n', '        if (x == fixed1()) return y;\n', '\n', '        // Separate into integer and fractional parts\n', '        // x = x1 + x2, y = y1 + y2\n', '        int256 x1 = integer(x) / fixed1();\n', '        int256 x2 = fractional(x);\n', '        int256 y1 = integer(y) / fixed1();\n', '        int256 y2 = fractional(y);\n', '        \n', '        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\n', '        int256 x1y1 = x1 * y1;\n', '        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\n', '        \n', '        // x1y1 needs to be multiplied back by fixed1\n', '        // solium-disable-next-line mixedcase\n', '        int256 fixed_x1y1 = x1y1 * fixed1();\n', '        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\n', '        x1y1 = fixed_x1y1;\n', '\n', '        int256 x2y1 = x2 * y1;\n', '        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\n', '\n', '        int256 x1y2 = x1 * y2;\n', '        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\n', '\n', '        x2 = x2 / mulPrecision();\n', '        y2 = y2 / mulPrecision();\n', '        int256 x2y2 = x2 * y2;\n', '        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\n', '\n', '        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\n', '        int256 result = x1y1;\n', '        result = add(result, x2y1); // Add checks for overflow\n', '        result = add(result, x1y2); // Add checks for overflow\n', '        result = add(result, x2y2); // Add checks for overflow\n', '        return result;\n', '    }\n', '    \n', '    /**\n', '     * @notice 1/x\n', '     * @dev \n', '     * Test reciprocal(0) fails\n', '     * Test reciprocal(fixed1()) returns fixed1()\n', '     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\n', '     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\n', '     */\n', '    function reciprocal(int256 x) internal pure returns (int256) {\n', '        assert(x != 0);\n', "        return (fixed1()*fixed1()) / x; // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice x/y. If the dividend is higher than maxFixedDiv() it \n', '     * might overflow. You can use multiply(x,reciprocal(y)) instead.\n', '     * There is a loss of precision on division for the lower mulPrecision() decimals.\n', '     * @dev \n', '     * Test divide(fixed1(),0) fails\n', '     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\n', '     * Test divide(maxFixedDiv()+1,1) throws\n', '     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\n', '     */\n', '    function divide(int256 x, int256 y) internal pure returns (int256) {\n', '        if (y == fixed1()) return x;\n', '        assert(y != 0);\n', '        assert(y <= maxFixedDivisor());\n', '        return multiply(x, reciprocal(y));\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IFuelTank {\n', '  function openNozzle() external;\n', '  function addTokens(address user, uint amount) external;\n', '}\n', '\n', 'contract MeowDAO is IERC20, Context {\n', '  using FixidityLib for int256;\n', '\n', '  uint256 _totalSupply = 0;\n', '  string private _name;\n', '  string private _symbol;\n', '\n', '  uint8 private _decimals = 13;\n', '  uint private _contractStart;\n', '\n', '  address public grumpyAddress;\n', '  address public grumpyFuelTankAddress;\n', '  uint public swapEndTime;\n', '\n', '  bool public launched = false;\n', '\n', '  uint256 public totalStartingSupply = 10**10 * 10**13; //10_000_000_000.0_000_000_000_000 10 billion MEOWS. 10^23\n', '\n', '  mapping (address => uint256) private _balances;\n', '  mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '  mapping (address => uint) public periodStart;\n', '  mapping (address => bool) public currentlyStaked;\n', '  mapping (address => uint) public unlockStartTime;\n', '  mapping (address => address) public currentVotes;\n', '  mapping (address => uint256) public voteWeights;\n', '\n', '  mapping (address => uint256) public stakingCoordinatesTime;\n', '  mapping (address => uint256) public stakingCoordinatesAmount;\n', '\n', '  mapping(address => uint256) public voteCounts;\n', '  address[] public voteIterator;\n', '  mapping(address => bool) public walletWasVotedFor;\n', '  address public currentCharityWallet;\n', '\n', '  constructor(address _grumpyAddress, address _grumpyFuelTankAddress, string memory __name, string memory __symbol) {\n', '    _name = __name;\n', '    _symbol = __symbol;\n', '\n', '    _contractStart = block.timestamp;\n', '\n', '    grumpyAddress = _grumpyAddress;\n', '    grumpyFuelTankAddress = _grumpyFuelTankAddress;\n', '\n', '    swapEndTime = block.timestamp + (86400 * 5);\n', '  }\n', '\n', '  function _swapGrumpyInternal(address user, uint256 amount) private {\n', '    require(block.timestamp < swapEndTime);\n', '    require(!isStaked(user), "cannot swap into staked wallet");\n', '    \n', '    IERC20(grumpyAddress).transferFrom(user, grumpyFuelTankAddress, amount);\n', '    IFuelTank(grumpyFuelTankAddress).addTokens(user, amount);\n', '\n', '    _balances[user] += amount;\n', '\n', '    _totalSupply += amount;\n', '\n', '    emit Transfer(address(0), user, amount);\n', '  }\n', '\n', '  function swapGrumpy(uint256 amount) public {\n', '    _swapGrumpyInternal(_msgSender(), amount);\n', '  }\n', '\n', '  function initializeCoinThruster() external {\n', '    require(block.timestamp >= swapEndTime, "NotReady");\n', '    require(launched == false, "AlreadyLaunched");\n', '\n', '    IFuelTank(grumpyFuelTankAddress).openNozzle();\n', '\n', '    if (totalStartingSupply > _totalSupply) {\n', '      uint256 remainingTokens = totalStartingSupply - _totalSupply;\n', '\n', '      _balances[grumpyFuelTankAddress] = _balances[grumpyFuelTankAddress] + remainingTokens;\n', '      _totalSupply += remainingTokens;\n', '\n', '      emit Transfer(address(0), grumpyFuelTankAddress, remainingTokens);\n', '    }\n', '\n', '    launched = true;\n', '  }\n', '\n', '  function getBlockTime() public view returns (uint) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  function isStaked(address wallet) public view returns (bool) {\n', '    return currentlyStaked[wallet];\n', '  }\n', '\n', '  function isUnlocked(address wallet) private returns (bool) {\n', '    uint unlockStarted = unlockStartTime[wallet];\n', '\n', '    if (unlockStarted == 0) return true;\n', '\n', '    uint unlockedAt = unlockStarted + (86400 * 5);\n', '\n', '    if (block.timestamp > unlockedAt) {\n', '      unlockStartTime[wallet] = 0;\n', '      return true;\n', '    }\n', '    else return false;\n', '  }\n', '\n', '  function _stakeWalletFor(address sender) private returns (bool) {\n', '    require(!isStaked(sender));\n', '    require(enoughFundsToStake(sender), "InsfcntFnds");\n', '    require(isUnlocked(sender), "WalletIsLocked");\n', '\n', '    currentlyStaked[sender] = true;\n', '    unlockStartTime[sender] = 0;\n', '    currentVotes[sender] = address(0);\n', '    periodStart[sender] = block.timestamp;\n', '\n', '    stakingCoordinatesTime[sender] = block.timestamp;\n', '    stakingCoordinatesAmount[sender] = _balances[sender];\n', '\n', '    return true;\n', '  }\n', '\n', '  function stakeWallet() public returns (bool) {\n', '    return _stakeWalletFor(_msgSender());\n', '  }\n', '\n', '  function _unstakeWalletFor(address sender, bool shouldReify) private {\n', '    require(isStaked(sender));\n', '\n', '    if (shouldReify) reifyYield(sender);\n', '\n', '    if (voteWeights[sender] != 0) {\n', '      removeVoteWeight(sender);\n', '      updateCharityWallet();\n', '    }\n', '\n', '    currentlyStaked[sender] = false;\n', '    currentVotes[sender] = address(0);\n', '    voteWeights[sender] = 0;\n', '    periodStart[sender] = 0;\n', '\n', '    stakingCoordinatesTime[sender] = 0;\n', '    stakingCoordinatesAmount[sender] = 0;\n', '\n', '    unlockStartTime[sender] = block.timestamp;\n', '  } \n', '\n', '  function unstakeWallet() public {\n', '    _unstakeWalletFor(_msgSender(), true);\n', '  }\n', '\n', '  function unstakeWalletSansReify() public {\n', '    _unstakeWalletFor(_msgSender(), false);\n', '  }\n', '\n', '  function voteIteratorLength() external view returns (uint) {\n', '    return voteIterator.length;\n', '  }\n', '\n', '  function voteWithRebuildIfNecessary(address charityWalletVote) public {\n', '    if (voteIterator.length == 12 && !walletWasVotedFor[charityWalletVote]) {\n', '      rebuildVotingIterator();\n', '    }\n', '    _voteForAddressBy(charityWalletVote, _msgSender());\n', '  }\n', '\n', '  function rebuildVotingIterator() public {\n', '    require(voteIterator.length == 12, "Voting Iterator not full");\n', '\n', '    address[12] memory voteCopy;\n', '    for (uint i = 0; i < 12; i++) {\n', '      voteCopy[i] = voteIterator[i];\n', '    }\n', '\n', '    //insertion sort copy\n', '    for (uint i = 1; i < 12; i++)\n', '    {\n', '      address keyAddress = voteCopy[i];\n', '      uint key = voteCounts[keyAddress];\n', '\n', '      uint j = i - 1;\n', '\n', '      bool broke = false;\n', '      while (j >= 0 && voteCounts[voteCopy[j]] < key) {\n', '        voteCopy[j + 1] = voteCopy[j];\n', '\n', '        if (j == 0) {\n', '          broke = true;\n', '          break;\n', '        }\n', '        else j--;\n', '      }\n', '\n', '      if (broke) voteCopy[0] = keyAddress;\n', '      else voteCopy[j + 1] = keyAddress;\n', '    }\n', '\n', '    for (uint i = 11; i >= 6; i--) {\n', '      address vote = voteCopy[i];\n', '      walletWasVotedFor[vote] = false;\n', '    }\n', '\n', '    delete voteIterator;\n', '    for (uint i = 0; i < 6; i++) {\n', '      voteIterator.push(voteCopy[i]);\n', '    }\n', '\n', '  }\n', '\n', '  function _voteForAddressBy(address charityWalletVote, address sender) private {\n', '    require(isStaked(sender));\n', '\n', '    trackCandidate(charityWalletVote);\n', '\n', '    removeVoteWeight(sender);\n', '    setVoteWeight(sender);\n', '    addVoteWeight(sender, charityWalletVote);\n', '    updateCharityWallet();\n', '  }\n', '\n', '  function trackCandidate(address charityWalletCandidate) private {\n', '    // If wallet was never voted for before add it to voteIterator\n', '    if (!walletWasVotedFor[charityWalletCandidate]) {\n', '      require(voteIterator.length < 12, "Vote Iterator must be rebuilt");\n', '\n', '      voteIterator.push(charityWalletCandidate);\n', '      walletWasVotedFor[charityWalletCandidate] = true;\n', '    }\n', '  }\n', '\n', '  function removeVoteWeight(address sender) private {\n', '    address vote = currentVotes[sender];\n', '    voteCounts[vote] = voteCounts[vote] - voteWeights[sender];\n', '  }\n', '\n', '  function setVoteWeight(address sender) private {\n', '    uint256 newVoteWeight = _balances[sender];\n', '    voteWeights[sender] = newVoteWeight;\n', '  }\n', '\n', '  function addVoteWeight(address sender, address charityWalletVote) private {\n', '    voteCounts[charityWalletVote] = voteCounts[charityWalletVote] + voteWeights[sender];\n', '    currentVotes[sender] = charityWalletVote;\n', '  }\n', '\n', '  function voteForAddress(address charityWalletVote) public {\n', '    _voteForAddressBy(charityWalletVote, _msgSender());\n', '  }\n', '\n', '  event NewCharityWallet(address oldW, address newW);\n', '\n', '  function updateCharityWallet() private {\n', '    uint256 maxVoteValue = 0; \n', '    address winner = address(0);\n', '\n', '    for (uint i = 0; i < voteIterator.length; i++) {\n', '      address currentWallet = voteIterator[i];\n', '      uint256 voteValue = voteCounts[currentWallet];\n', '\n', '      if (voteValue > maxVoteValue) {\n', '        maxVoteValue = voteValue;\n', '        winner = currentWallet;\n', '      }\n', '    }\n', '\n', '    if (currentCharityWallet == winner) return;\n', '\n', '    emit NewCharityWallet(currentCharityWallet, winner);\n', '\n', '    currentCharityWallet = winner;\n', '  }\n', '\n', '  function validCharityWallet() internal view returns (bool) {\n', '    return currentCharityWallet != address(0) && !isStaked(currentCharityWallet);\n', '  }\n', '\n', '  function getCompoundingFactor(address wallet) private view returns (uint) {\n', '    return block.timestamp - periodStart[wallet];\n', '  }\n', '\n', '  function calculateYield(uint256 principal, uint n) public pure returns (uint256) {\n', '    int256 fixedPrincipal = int256(principal).newFixed();\n', '\n', '    int256 rate = int256(2144017221509).newFixedFraction(1000000000000000000000);\n', '    int256 fixed2 = int256(2).newFixed();\n', '\n', '    while (n > 0) {\n', '      if (n % 2 == 1) {\n', '        fixedPrincipal = fixedPrincipal.add(fixedPrincipal.multiply(rate));\n', '        n -= 1;\n', '      }\n', '      else {\n', '        rate = (fixed2.multiply(rate))\n', '          .add(rate.multiply(rate));\n', '        n /= 2;\n', '      }\n', '    }\n', '    return uint256(fixedPrincipal.fromFixed()) - principal;\n', '  }\n', '\n', '  function getTransactionFee(uint256 txAmt) private view returns (uint256){\n', '    uint period = block.timestamp - _contractStart;\n', '\n', '    if (period > 31536000) return 0;\n', '    else if (period > 23652000) return txAmt / 400;\n', '    else if (period > 15768000) return txAmt / 200;\n', '    else if (period > 7884000) return (txAmt / 400) * 3;\n', '    else return txAmt / 100;\n', '  } \n', '\n', '  function reifyYield(address wallet) public {\n', "    require(isStaked(wallet), 'MstBeStkd');\n", '\n', '    uint compoundingFactor = getCompoundingFactor(wallet);\n', '\n', '    if (compoundingFactor < 60) return;\n', '\n', '    uint256 yield = calculateYield(_balances[wallet], compoundingFactor);\n', '\n', '    _balances[wallet] += yield;\n', '\n', '    if (validCharityWallet()) {\n', '      uint256 charityYield = (yield / 7) * 3;\n', '      _balances[currentCharityWallet] += charityYield;\n', '      _totalSupply += (yield + charityYield);\n', '    } else {\n', '      _totalSupply += yield;\n', '    }\n', '\n', '    periodStart[wallet] = block.timestamp;\n', '  }\n', '\n', '  function enoughFundsToStake(address wallet) private view returns (bool) {\n', '    return _balances[wallet] >= 10000000000000000;\n', '  }\n', '\n', '  function name() external view returns (string memory) {\n', '    return _name;\n', '  } \n', '\n', '  function symbol() external view returns (string memory) {\n', '    return _symbol;\n', '  }\n', '\n', '  function decimals() external view returns (uint8) {\n', '    return _decimals;\n', '  }\n', '\n', '  function contractStart() external view returns (uint) {\n', '    return _contractStart;\n', '  }\n', '\n', '  function totalSupply() external view override returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function balanceOf(address account) public view virtual override returns (uint256) {\n', '    uint b = _balances[account];\n', '\n', '    if (isStaked(account) && currentCharityWallet != account) {\n', '      return b + calculateYield(b, getCompoundingFactor(account));\n', '    }\n', '    return b;\n', '  }\n', '\n', '  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '    _transfer(_msgSender(), recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '    require(sender != address(0), "ERC20: transfer from the zero address");\n', '    require(recipient != address(0), "ERC20: transfer to the zero address");\n', '    require(!isStaked(sender), "StkdWlltCnntTrnsf");\n', '    require(isUnlocked(sender), "LockedWlltCnntTrnsfr");\n', '    require(_balances[sender] >= amount, "ERC20: transfer amount exceeds balance");\n', '\n', '    if (isStaked(recipient)) {\n', '      reifyYield(recipient);\n', '    }\n', '\n', '    uint sentAmount = amount; \n', '\n', '    if (validCharityWallet()) {\n', '      uint256 txFee = getTransactionFee(amount);\n', '\n', '      if (txFee != 0) {\n', '        sentAmount -= txFee;\n', '        _balances[currentCharityWallet] += txFee;\n', '      }\n', '    }\n', '\n', '    _balances[sender] -= amount;\n', '    _balances[recipient] += sentAmount;\n', '\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '    return _allowances[owner][spender];\n', '  }\n', '\n', '  function approve(address spender, uint256 amount) public override returns (bool) {\n', '    _approve(_msgSender(), spender, amount);\n', '    return true;\n', '  }\n', '\n', '  function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '    require(owner != address(0), "ERC20: approve from the zero address");\n', '    require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '    _allowances[owner][spender] = amount;\n', '    emit Approval(owner, spender, amount);\n', '  }\n', '\n', '  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '    _transfer(sender, recipient, amount);\n', '\n', '    uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '    require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '    _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '    _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '    return true;\n', '  }\n', '\n', '  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '    uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '    require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '    _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '    return true;\n', '  }\n', '}']