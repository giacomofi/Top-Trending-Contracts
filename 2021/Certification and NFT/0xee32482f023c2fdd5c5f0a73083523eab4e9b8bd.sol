['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-06\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at BscScan.com on 2021-04-09\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', '    RH Style Guide:\n', '        ContractsAndDataStructures\n', '        member_variables_\n', '        _argument_variables\n', '        local_variable\n', '        struct_member_variable\n', '        functionNames\n', '        SOME_CONSTANT\n', '        \n', '        \n', '        lhs_ = _rhs;\n', '        \n', '        _lhs == rhs_\n', '*/\n', 'abstract\n', 'contract OracleCallable {\n', '    \n', '    address private oracle_key_;\n', '    \n', '    event OracleKeyChanged(address indexed _oracle_key);\n', '    \n', '    constructor (address _oracle_key) {\n', '        oracle_key_ = _oracle_key;\n', '        emit OracleKeyChanged(_oracle_key);\n', '    }    \n', '    \n', '    modifier onlyOracle() {\n', '        require(oracle_key_ == msg.sender, "Caller is not the oracle");\n', '        _;\n', '    }    \n', '    \n', '    function changeOracleKeyInternal(address _oracle_key) internal\n', '    {\n', '        require(_oracle_key != address(0), "New oracle is the zero address");\n', '        emit OracleKeyChanged(_oracle_key);\n', '        oracle_key_ = _oracle_key;\n', '    }\n', '    \n', '    function changeOracleKey(address _oracle_key) external onlyOracle returns (bool success) \n', '    {\n', '        changeOracleKeyInternal(_oracle_key);\n', '        return true;\n', '    }   \n', '    \n', '    function getOracleKey() view public returns (address)\n', '    {\n', '        return oracle_key_;\n', '    }\n', '}\n', '\n', '\n', 'abstract\n', 'contract PigeonReceive is OracleCallable {\n', '    \n', '    event PigeonCallable (address _oracleKey);\n', '    \n', '    event PigeonArrived (\n', '         uint256  _source_chain_id,    uint256 _source_contract_id,     \n', '         uint256  _source_block_no,    uint256  _source_confirmations,   uint256 _source_txn_hash,\n', '         uint256 _source_topic0,      uint256 _source_topic1,          uint256 _source_topic2,\n', '         uint256 _source_topic3,      uint256 _source_topic4,          uint256 _source_topic5\n', '    );\n', '\n', '    constructor (address _oracleKey) OracleCallable (_oracleKey) \n', '    {\n', '        emit PigeonCallable(_oracleKey);\n', '    }\n', '\n', '    function pigeonArrive (\n', '        uint256  _source_chain_id,    uint256 _source_contract_id,\n', '        uint256  _source_block_no,    uint256  _source_confirmations,   uint256 _source_txn_hash,\n', '        uint256 _topic0, uint256 _topic1, uint256 _topic2, uint256 _topic3, uint256 _topic4, uint256 _topic5\n', '    ) onlyOracle external virtual returns (bool success)\n', '    {\n', '        emit PigeonArrived(\n', '           _source_chain_id, _source_contract_id,\n', '           _source_block_no, _source_confirmations, _source_txn_hash,\n', '           _topic0, _topic1, _topic2, _topic3, _topic4, _topic5);\n', '        return true;\n', '    }\n', '    \n', '}\n', '\n', 'abstract\n', 'contract PigeonInterface {\n', '    event PigeonCall(\n', '        uint256 _source_txn_hash, uint256 _source_event_id,\n', '        uint256 _dest_chain_id,  uint256 _dest_contract_id\n', '    );\n', '    \n', '    function pigeonSend(\n', '        uint256 _source_txn_hash,    uint256 _source_event_id,\n', '        uint256 _dest_chain_id,      uint256 _dest_contract_id) external virtual payable returns (bool success);\n', ' \n', '    function pigeonCost(uint256 _dest_chain_id) external view virtual returns (uint256 pigeon_call_cost);\n', '\n', '    function setPigeonCost(uint256 _dest_chain_id, uint256 cost) external virtual returns (bool success);\n', '    \n', '    function chainId() external view virtual returns (uint256);\n', '    \n', '    function getPigeonOracleKey() view virtual public returns (address);\n', '\n', '}\n', '\n', 'abstract\n', 'contract EIP20Interface {\n', '    function total_supply()\n', '        external view virtual returns (uint256);\n', '    function balanceOf(address _owner)\n', '        external view virtual returns (uint256 balance);\n', '    function allowance(address _owner, address _spender)\n', '        external view virtual returns (uint256 remaining);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        external virtual returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        external virtual returns (bool success);\n', '    function approve(address _spender, uint256 _value)\n', '        external virtual returns (bool success);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'abstract\n', 'contract\n', 'UniwarpVaultInterface is EIP20Interface {\n', '    uint256 constant VAULTED_EVENT_ID = 0x202c84ded448d8f25e219522de3b98e78675c6e8aeb88c805908fbc6fe6094c5;\n', '    event Vaulted (uint256 _vaulter, uint256 _dest_chain_id, uint256 _amount);\n', '    address constant public OFF_CHAIN = address(0xd15Ab1ed00000000000000000000000000000000);\n', '\n', '    function vaultFee(uint256 _dest_chain_id) view virtual external returns (uint256);\n', '    function vault(uint256 _dest_chain_id, uint256 _amount) virtual external payable returns (bool success);\n', '    function vaultFrom(address _from, uint256 _dest_chain_id, uint256 _amount) virtual external payable returns (bool success);\n', '    function chainId() view virtual external returns (uint256 _chain_id);\n', '}\n', '\n', 'abstract\n', 'contract \n', 'UniwarpDAOInterface {\n', '    struct Proposal\n', '    {\n', '        address proposer; // the proposer is required to also action the proposal at the end, thus they are responsible for gas fees\n', '        uint256 operation;  // see validateProposal()\n', '        uint256 chain_id;             \n', '        uint256 operand; // address or other operand to the vote, e.g. tokens_per_proposal when operation == 7\n', '        uint256 expiry_block; // block number when this proposal can be actioned\n', '        uint256 cancel_block;  // block number when this proposal can be cancelled\n', '        bytes32 explain1;\n', '        bytes32 explain2;\n', '        uint256 lockedTokens;\n', '        uint16 yay;    // "yes" votes\n', '        uint16 nay;    // "no" votes\n', '    }\n', '    \n', "    // this is like a blackhole address but it's a disabled holding location for coins that are currently 'off chain' (i.e. on a different chain after a vault event)\n", '            \n', '    uint256 constant PROPOSAL_ACTION_EVENT_ID = 0x3beb9a573715f796038dda8fdd3763a415c709081cb3cf432e48ff8b7ec600db;\n', '    event ProposalActioned (uint256 _operation, uint256 _operand_chain_id, uint256 _operand);\n', '\n', '\n', '    function viewProposal(uint256 _proposal_id) view virtual external returns (Proposal memory proposal);\n', '\n', '    function validateProposal(uint256 _operation, uint256 _operand_chain_id, uint256 _operand) virtual view public returns (bool success);\n', '    \n', '    function redeemVoteTokens(uint256 _proposal_id) virtual external returns(bool success);\n', '\n', '    function actionProposal(uint256 _proposal_id)  virtual external payable returns (bool success);\n', '\n', '    function actionProposalCost() view virtual external returns (uint256 amount);\n', '\n', '    function propose(uint256 _operation, uint256 _operand_chain_id, uint256 _operand, bytes32 _explain1, bytes32 _explain2) virtual external returns (uint256);\n', '\n', '    function cancelProposal(uint256 _proposal_id) virtual external returns (bool success);\n', '\n', '    function vote(uint256 _proposal_id, uint16 _yay, uint16 _nay) virtual external returns (bool success);\n', '\n', '    function getVotingChain() external view virtual returns (uint256 _chain_id);\n', '\n', '    function isVotingChain() external view virtual returns(bool _is_voting);\n', '\n', '    function isDisabled(uint256 _chain_id)  external view virtual returns(bool _is_disabled);\n', '\n', '    function getProposalCount() external view virtual returns (uint256);\n', '\n', '    function getTokensPerVote() external view virtual returns (uint256);\n', '\n', '    function getTokensPerProposal() external view virtual returns (uint256);\n', '\n', '    function getChainCount() external view virtual returns (uint256);\n', '\n', '    function getPigeonAddress() external view virtual  returns (address pigeon);\n', '    \n', '    function getProposalExpiry() external view virtual returns (uint256 expiry);\n', '\n', '\n', '}\n', '\n', 'contract Uniwarp is PigeonReceive, UniwarpVaultInterface, UniwarpDAOInterface {\n', '\n', '\n', '\n', '    function getProposalExpiry() external view override returns (uint256 expiry)\n', '    {\n', '        return voting_block_expiry_;\n', '    }\n', '\n', '    function isDisabled(uint256 _chain_id)  external view override returns(bool _is_disabled)\n', '    {\n', '        return disabled_chains_[_chain_id];\n', '    }\n', '\n', '    function getPigeonAddress() external view override returns (address pigeon)\n', '    {\n', '        return pigeon_address_;\n', '    }\n', '\n', '    function getProposalCount() external view override returns (uint256)\n', '    {\n', '        return proposal_count_;\n', '    }\n', '\n', '    function getTokensPerVote() external view override returns (uint256)\n', '    {\n', '        return tokens_per_vote_;\n', '    }\n', '\n', '    function getTokensPerProposal() external view override returns (uint256)\n', '    {\n', '        return tokens_per_proposal_;\n', '    }\n', '\n', '    function getChainCount() external view override returns (uint256)\n', '    {\n', '        return chain_count_;\n', '    }\n', '\n', '\n', '    function getVotingChain() external view override returns (uint256 _chain_id)\n', '    {\n', '        return voting_chain_id_;\n', '    }\n', '    \n', '    function isVotingChain() external view override returns(bool _is_voting)\n', '    {\n', '        return voting_chain_id_ == chain_id_;\n', '    }\n', '\n', '    function chainId() view override external returns (uint256 _chain_id)\n', '    {\n', '        return chain_id_;\n', '    }\n', '\n', '    mapping(bytes32 => bool) private alreadyArrived_;\n', '\n', '    function pigeonArrive (\n', '        uint256  _source_chain_id,    uint256 _source_contract_id,\n', '        uint256  _source_block_no,    uint256  _source_confirmations,   uint256 _source_txn_hash,\n', '        uint256 _topic0, uint256 _topic1, uint256 _topic2, uint256 _topic3, uint256 _topic4, uint256 _topic5)\n', '        onlyOracle checkDeleted external override returns (bool success)\n', '    {\n', '        \n', '        require(_topic0 == VAULTED_EVENT_ID || _topic0 == PROPOSAL_ACTION_EVENT_ID, "Pigeon received but not a valid event type.");\n', '        require(uniwarp_contracts_[_source_chain_id] == _source_contract_id, "Received pigeon from unknown contract...");\n', '        \n', '        bytes32 hash = keccak256(abi.encodePacked(_source_chain_id, _source_txn_hash, _topic0, _topic1, _topic2, _topic3));\n', '        require(!alreadyArrived_[hash], "Already processed this pigeon");\n', '        alreadyArrived_[hash] = true;\n', '        \n', '        if (_topic0 == VAULTED_EVENT_ID)\n', '        {\n', '\n', '            //require(_topic1 >> 96 == 0x0, "Invalid vault account on incoming pigeon");        \n', '            address vault_owner = address(uint160(_topic1));\n', '            require(_topic2 == chain_id_, "Pigeon received for wrong chainid!");\n', '            uint256 vault_amount = _topic3;\n', '        \n', '            require(vault_amount > 0, "Invalid pigeon (1)!");\n', '            require(vault_owner != address(0x0), "Invalid pigeon (2)!");\n', '            require(vault_amount <= balances_[OFF_CHAIN], "Offchain invariant failed!!!");\n', '        \n', '            uint256 old_balance = balances_[OFF_CHAIN];\n', '            balances_[OFF_CHAIN] -= vault_amount;\n', '            require(old_balance > balances_[OFF_CHAIN], "Internal error (1)");\n', '        \n', '            old_balance = balances_[vault_owner];\n', '            balances_[vault_owner] += vault_amount;\n', '            require(balances_[vault_owner] > old_balance, "Internal error (2)");\n', '            \n', '            \n', '            emit Transfer(OFF_CHAIN, vault_owner, vault_amount);\n', '        } \n', '        else if (_topic0 == PROPOSAL_ACTION_EVENT_ID)\n', '            actionProposalInternal(_topic1, _topic2, _topic3, false);\n', '\n', '        emit PigeonArrived(\n', '           _source_chain_id, _source_contract_id,\n', '           _source_block_no, _source_confirmations, _source_txn_hash,\n', '           _topic0, _topic1, _topic2, _topic3, _topic4, _topic5);\n', '\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '    uint256 constant private MAX_UINT256 = 2**256 - 1;\n', '\n', '    \n', '    mapping (address => uint256)  public balances_;\n', '    mapping (address => mapping (address => uint256)) public allowed_;\n', '    \n', '\n', '    uint256 public chain_id_;\n', '    uint256 public chain_count_;\n', '    mapping (uint256 => uint256) public chain_ids_;\n', '    mapping (uint256 => uint256) public uniwarp_contracts_;             // chain_id -> contract address (may not be an ethereum-based chain so address is uint256)\n', '    mapping (uint256 => mapping (address => uint256)) public votes_;    // proposal_id => voter => lockedTokens\n', '\n', '    mapping (uint256 => bool) public disabled_chains_;\n', '    \n', '    uint256 public total_supply_;\n', '    address public pigeon_address_;\n', '    \n', '    mapping (uint256 => Proposal) public proposals_;\n', '\n', '    uint256 public proposal_count_;\n', '    uint256 public voting_chain_id_;\n', '    uint256 public voting_block_expiry_;\n', '    uint256 public tokens_per_vote_ = 100000000000000000000000;\n', '    uint256 public tokens_per_proposal_ = 1000000000000000000000000;\n', '        \n', '    bool deleted_ = false;      // if this contract copy has been disabled (deleted) either because it was "removed" from the chain or changed to a new contract then refuse to do anything\n', '\n', '    modifier checkDeleted()\n', '    {\n', '        require(!deleted_, "This version of uniwarp on this chain has been deleted.");\n', '        _;\n', '    }\n', '    \n', '    modifier checkDisabled()\n', '    {\n', '        require(!disabled_chains_[chain_id_], "This version of uniwarp on this chain has been disabled.");\n', '        _;\n', '    }\n', '    \n', '    function viewProposal(uint256 _proposal_id) view override external returns (Proposal memory proposal)\n', '    {\n', '        require(proposals_[_proposal_id].operation > 0, "Invalid proposal");\n', '        return proposals_[_proposal_id];\n', '    }\n', '    \n', '    // sanity check the parameters to a proposal\n', '    function validateProposal(uint256 _operation, uint256 _operand_chain_id, uint256 _operand) override view public returns (bool success)\n', '    {\n', '        // 1 == add chain, 2 == remove chain, 3 == change pigeon address for a specified chain (for pigeonSend),\n', '        // 4 = propose new voting contract,   5 = propose new proposal block expiry,\n', '        // 6 = tokens_per_vote, 7 = tokens_per_proposal, 8 = change pigeon oracle key. 9 = change contract id on a chain, 10 = disable a chain (they can send off the chain but not receive)\n', '        // 11 = enable chain\n', '\n', '        require(_operation > 0 && _operation < 12, "Invalid proposed operation.");\n', '\n', '        if (_operation == 9) // change contract id on an existing chain\n', '        {\n', '            require(uniwarp_contracts_[_operand_chain_id] != 0x0, "Can only change a chain that exists");\n', '            require(_operand != 0x0, "Can\'t change to null contract");\n', '        }\n', '        else if (_operation == 1) // add chain\n', '        {\n', '            require(_operand_chain_id != chain_id_, "Cannot add this chain... it\'s already on this chain!");\n', '            require(uniwarp_contracts_[_operand_chain_id] == 0x0, "Cannot add chain, already added!");\n', '            require(_operand != 0x0, "Can\'t add null contract");\n', '        }\n', '        else if (_operation == 2) // remove chain\n', '        {\n', '            require(_operand_chain_id != voting_chain_id_, "Cannot remove this chain... it\'s the voting chain. Change voting chain first!");\n', '            require(uniwarp_contracts_[_operand_chain_id] != 0x0, "Cannot remove chain, doesn\'t exist!");\n', '            require(_operand == uniwarp_contracts_[_operand_chain_id], "Operand must be the contract address");\n', '        }\n', '        else if (_operation == 3)    /* change pigeon */\n', '        {\n', '            require(uniwarp_contracts_[_operand_chain_id] != 0x0, "Cannot change pigeon address on chain that\'s not added!");\n', '            require(_operand != 0x0, "Cannot set pigeon to 0x0");\n', '            if (_operand_chain_id == chain_id_)\n', '                require(PigeonInterface(address(uint160(_operand))).chainId() == chain_id_, "Invalid pigeon interface!");\n', '        }\n', '        else if (_operation == 4)    /* new voting contract (chain) */\n', '        {\n', '            require(_operand_chain_id != voting_chain_id_, "This is already the voting contract... you can only switch voting to a different chain");\n', '            require(_operand == uniwarp_contracts_[_operand_chain_id], "You can only propose another uniwarp contract as the new voting contract");\n', '            require(_operand != 0x0, "Please specify the uniwarp contract on the other end.");\n', '        }\n', '        else if (_operation == 5)    /* new voting expiry */\n', '        {\n', '            //require(_operand_chain_id == chain_id_, "Can only propose a voting expiry for this chain, the voting chain.");\n', '            require(chain_ids_[_operand_chain_id] != 0x0, "Chain must exist to change voting time.");\n', '            require(_operand <= 120960, "Cannot propose a voting expiry > 120960");\n', '        }\n', '        else if (_operation == 6)    /* new tokens_per_vote lockup */\n', '        {\n', '            require(_operand_chain_id == voting_chain_id_, "Can only propose a new tokens_per_vote for the voting chain.");\n', '            require(_operand > 10**19, "tokens_per_vote must be at least 10**19");\n', '        }\n', '        else if (_operation == 7)    /* new tokens_per_proposal lockup */\n', '        {\n', '            require(_operand_chain_id == voting_chain_id_, "Can only propose a new tokens_per_proposal for the voting chain.");\n', '            require(_operand > 10**20, "tokens_per_proposal must be at least 10**20");\n', '        }\n', '        else if (_operation == 8)    /* new pigeon oracle */\n', '        {\n', '            require(_operand_chain_id == 0x0, "Cannot specify a chain for the pigeon oracle, must be the same on all chains. Please use 0x0 for chain_id here.");\n', '            require(_operand != 0x0, "Cannot specify a null oracle key.");\n', '        }\n', '        else if (_operation == 10) // disable chain\n', '        {\n', '            require(_operand_chain_id != voting_chain_id_, "You cannot disable the voting chain!");\n', '            require(chain_ids_[_operand_chain_id] != 0x0, "Must specify an already added chain to disable");\n', '            require(!disabled_chains_[_operand_chain_id], "Chain was already disabled!");\n', '            require(_operand == uniwarp_contracts_[_operand_chain_id], "Operand must be the contract address");\n', '        }\n', '        else if (_operation == 11) // enable chain\n', '        {\n', '            require(chain_ids_[_operand_chain_id] != 0x0, "Must specify an already added chain to enable");\n', '            require(disabled_chains_[_operand_chain_id], "Chain was already enabled!");\n', '            require(_operand == uniwarp_contracts_[_operand_chain_id], "Operand must be the contract address");\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '  \n', '    function destroyProposal(uint256 _proposal_id) private\n', '    {\n', '        Proposal memory proposal = proposals_[_proposal_id];\n', '        \n', '        require(proposal.operation > 0, "Proposal does not exist");\n', '        // return tokens to user\n', '        \n', '        address proposer = proposal.proposer;\n', '        \n', '        require(proposer != OFF_CHAIN && proposer != address(0x0), "Internal error (1)");\n', '        \n', '        uint256 old_balance = balances_[proposer];\n', '        balances_[proposer] += proposal.lockedTokens;\n', '        require(old_balance < balances_[proposer], "Internal error (2)");\n', '        \n', '        // remove the proposal\n', '        delete proposals_[_proposal_id];\n', '    }\n', '    \n', '    function redeemVoteTokens(uint256 _proposal_id) checkDeleted checkDisabled override external returns(bool success)\n', '    {\n', '        // the below line prevents people closing their vote lock early\n', '        require(proposals_[_proposal_id].operation == 0, "Proposal must have expired or cancelled before vote can be redeemed");\n', '        \n', '        require(votes_[_proposal_id][msg.sender] > 0, "Vote does not exist or already redeemed");\n', '        \n', '        uint256 old_balance = balances_[msg.sender];\n', '        balances_[msg.sender] += votes_[_proposal_id][msg.sender];\n', '        require(old_balance < balances_[msg.sender], "Internal error");\n', '        \n', '        delete votes_[_proposal_id][msg.sender];\n', '        return true;\n', '    }\n', '\n', '    \n', '    function actionProposal(uint256 _proposal_id)  checkDeleted checkDisabled override external payable returns (bool success)\n', '    {\n', '        \n', '        Proposal memory proposal = proposals_[_proposal_id];\n', '        \n', '        require(block.number >= proposal.expiry_block,\n', '            "Either invalid proposal_id or expiry block hasn\'t occured yet.");\n', '            \n', '        require(proposal.operation > 0 && proposal.operation < 12,\n', '            "Invalid proposal");\n', '            \n', '        require(proposal.yay > proposal.nay * 2,\n', '            "Proposal can\'t be actioned because it did not pass the vote. Use cancel();");\n', '            \n', '        actionProposalInternal(proposal.operation, proposal.chain_id, proposal.operand, true);\n', '        destroyProposal(_proposal_id);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function actionProposalInternal(uint256 operation, uint256 operand_chain_id, uint256 operand, bool _broadcast) private\n', '    {\n', '\n', '        validateProposal(operation, operand_chain_id, operand);\n', '        \n', '        ProposalActioned(operation, operand_chain_id, operand);\n', '        \n', '        bool is_voting_chain = (chain_id_ == voting_chain_id_);\n', '        \n', '        if (is_voting_chain && _broadcast)\n', '        {\n', '            pigeonAction();\n', '        }\n', '         \n', '        // 1 == add chain, 2 == remove chain, 3 == change pigeon, 4 = propose new voting contract,\n', '        // 5 = propose new proposal block expiry, 6 = tokens_per_vote, 7 = tokens_per_proposal, 8 = change pigeon oracle key\n', '        // 9 = change contract id on a chain, 10 = disable chain, 11 = enable chain\n', '\n', '        if (operation == 1) // add chain\n', '        {\n', '            uniwarp_contracts_[operand_chain_id] = operand;\n', '            chain_ids_[chain_count_++] = operand_chain_id;\n', '        }\n', '        else if (operation == 2) // del chain\n', '        {\n', '            delete uniwarp_contracts_[operand_chain_id];\n', '            for (uint i = 0; i < chain_count_; ++i)\n', '                if (chain_ids_[i] == operand_chain_id)\n', '                    chain_ids_[i] = 0x0;\n', '            if (operand_chain_id == chain_id_)\n', '                deleted_ = true;\n', '                \n', '        }\n', '        else if (operation == 3) // change pigeon (sending contract) on a specific chain to a specific address\n', '        {\n', '            if (operand_chain_id == chain_id_)\n', '                pigeon_address_ = address(uint160(operand));\n', '        }\n', '        else if (operation == 4) // propose new voting chain\n', '        {\n', '            voting_chain_id_ = operand_chain_id;\n', '        }\n', '        else if (operation == 5) // propose new voting block expiry\n', '        {\n', "            // a proposal can change any chain's voting time even if its not the voting chain\n", '            // this is so this figure is adjustable ahead of moving the voting chain\n', '            if (operand_chain_id == chain_id_)\n', '                voting_block_expiry_ = operand;\n', '        }\n', '        else if (operation == 6) // propose new tokens_per_vote\n', '        {\n', '            tokens_per_vote_ = operand;\n', '        }\n', '        else if (operation == 7)\n', '        {\n', '            tokens_per_proposal_ = operand;\n', '        }\n', '        else if (operation == 8)\n', '        {\n', '            changeOracleKeyInternal(address(uint160(operand)));\n', '        }\n', '        else if (operation == 9) // change contract on chain\n', '        {\n', '            uniwarp_contracts_[operand_chain_id] = operand;\n', '            if (operand_chain_id == chain_id_)\n', '                deleted_ = true;\n', '        }\n', '        else if (operation == 10)   // disable chain\n', '        {\n', '            disabled_chains_[operand_chain_id] = true;\n', '        }\n', '        else if (operation == 11)  // enable chain\n', '        {\n', '            disabled_chains_[operand_chain_id] = false;\n', '        }\n', '    }\n', '    \n', '    // anyone can clear a proposal if 1.25 * voting_block_expiry_ has passed\n', '    function cancelProposal(uint256 _proposal_id) checkDeleted checkDisabled override external returns (bool success)\n', '    {\n', '        require(proposals_[_proposal_id].operation > 0, "Proposal does not exist");\n', '        require(proposals_[_proposal_id].cancel_block < block.number,\n', '            "Either invalid proposal_id or cancel block hasn\'t occured yet.");\n', '    \n', '        destroyProposal(_proposal_id);\n', '        return true;\n', '    }\n', '    \n', '    function twentyFivePercentMore(uint256 _number) pure private returns (uint256)\n', '    {\n', '        uint256 o = _number;\n', '        uint256 n = _number + (_number / 4);\n', '        require(n > o, "Invariant tripped");\n', '        return n;\n', '    }\n', '    \n', '    function propose(uint256 _operation, uint256 _operand_chain_id, uint256 _operand, bytes32 _explain1, bytes32 _explain2) checkDeleted checkDisabled override external returns (uint256) \n', '    {\n', '        require(chain_id_ == voting_chain_id_, "You can only propose on the voting chain");\n', '        require(balances_[msg.sender] >= tokens_per_proposal_, "Not enough UWR to propose");\n', '\n', '        validateProposal(_operation, _operand_chain_id, _operand);\n', '\n', "        // subtract the tokens from the user's balance until the proposal ends\n", '        uint256 old_balance = balances_[msg.sender];\n', '        balances_[msg.sender] -= tokens_per_proposal_;\n', '        require(old_balance > balances_[msg.sender], "Internal error");\n', '        \n', '        \n', '        uint256 id = proposal_count_++; // allocate a new proposal\n', '        proposals_[id].proposer     = msg.sender;\n', '        proposals_[id].operation    = _operation;\n', '        proposals_[id].chain_id     = _operand_chain_id;\n', '        proposals_[id].operand      = _operand;\n', '        proposals_[id].explain1     = _explain1;\n', '        proposals_[id].explain2     = _explain2;\n', '        proposals_[id].lockedTokens = tokens_per_proposal_;\n', '        \n', '        proposals_[id].expiry_block = block.number + voting_block_expiry_;\n', '        proposals_[id].cancel_block = block.number + twentyFivePercentMore(voting_block_expiry_);\n', '        \n', '        if (proposals_[id].expiry_block == block.number || block.number > proposals_[id].expiry_block)\n', '            proposals_[id].expiry_block = block.number + 100; // this is a fallback ~8 minutes on binance smart chain, only active if voting_block_expiry_ was never set or if it was really really big\n', '\n', '        return id;\n', '    }\n', '    \n', '    function vote(uint256 _proposal_id, uint16 _yay, uint16 _nay) external checkDeleted checkDisabled override returns (bool success)\n', '    {\n', '        require(chain_id_ == voting_chain_id_, "You can only vote on the voting chain");\n', '        require( !( _yay > 0 && _nay > 0 ), "You must either vote yay or nay... not both");\n', '        require(balances_[msg.sender] >= tokens_per_vote_ * _yay && \n', '                balances_[msg.sender] >= tokens_per_vote_ * _nay, "Not enough UWR to vote");\n', '                \n', '        require(proposals_[_proposal_id].operation > 0, "You are attempting to vote on a non existent proposal id");\n', '\n', '        require(block.number < proposals_[_proposal_id].expiry_block, "Proposal has already expired, either action() or cancel() it.");\n', '\n', '        uint256 old_balance = balances_[msg.sender];\n', '        uint256 charge = tokens_per_vote_ * (_yay + _nay);\n', '        balances_[msg.sender] -= charge;\n', '        votes_[_proposal_id][msg.sender] += charge;\n', '        require(old_balance > balances_[msg.sender], "Internal error");\n', '\n', '        uint16 old_yay = proposals_[_proposal_id].yay;\n', '        uint16 old_nay = proposals_[_proposal_id].nay;\n', '        proposals_[_proposal_id].yay += _yay;\n', '        proposals_[_proposal_id].nay += _nay;\n', '        require(old_yay <= proposals_[_proposal_id].yay && old_nay <= proposals_[_proposal_id].nay, "Internal error");\n', '        \n', '        return true;\n', '    }\n', '    \n', '\n', '    function actionProposalCost() view external checkDeleted checkDisabled override returns (uint256 amount)\n', '    {\n', '        require(chain_id_ == voting_chain_id_, "only on the voting chain");\n', '        uint256 cost = 0;\n', '        for (uint i = 0; i < chain_count_; ++i)\n', '        {\n', '            if (chain_ids_[i] == chain_id_ ||\n', '                chain_ids_[i] == 0x0 ||\n', '                uniwarp_contracts_[chain_ids_[i]] == 0x0)\n', '                continue;\n', '            \n', '            PigeonInterface p = PigeonInterface(pigeon_address_);    \n', '            cost += p.pigeonCost(chain_ids_[i]);\n', '        }\n', '        return cost;\n', '    }\n', '\n', '\n', '    function pigeonAction() internal\n', '    {\n', '        for (uint i = 0; i < chain_count_; ++i)\n', '        {\n', '            if (chain_ids_[i] == chain_id_ ||\n', '                chain_ids_[i] == 0x0 ||\n', '                uniwarp_contracts_[chain_ids_[i]] == 0x0)\n', '                continue;\n', '            \n', '            PigeonInterface p = PigeonInterface(pigeon_address_);    \n', '            p.pigeonSend{\n', '                value: p.pigeonCost(chain_ids_[i])\n', '            }(0x0, PROPOSAL_ACTION_EVENT_ID, chain_ids_[i], uniwarp_contracts_[chain_ids_[i]]);\n', '        }\n', '    }\n', '\n', '    function vaultFee(uint256 _dest_chain_id) view checkDeleted checkDisabled override external returns (uint256)\n', '    {\n', '        require(uniwarp_contracts_[_dest_chain_id] != 0x0, "Chain not supported");\n', '        return PigeonInterface(pigeon_address_).pigeonCost(_dest_chain_id);\n', '    }\n', '\n', '    // place tokens into a warp vault\n', '    // the vault will only be openable on the destination chain\n', '    // vaults can still be sent from a disabled contract, but not to a disabled contract \n', '    \n', '    function vaultInternal(address _from, uint256 _dest_chain_id, uint256 _amount) internal returns (bool success)\n', '    {\n', '        // todo: minimum vault amount?\n', '        require(balances_[_from] > 0, "You have no tokens!");\n', '        require(uniwarp_contracts_[_dest_chain_id] != 0x0, "Destination chain not currently supported.");\n', '        require(PigeonInterface(pigeon_address_).pigeonCost(_dest_chain_id) <= msg.value, "Insufficent vaulting fee. Please check vaultFee(network_id)");\n', '        require(!disabled_chains_[_dest_chain_id], "The chain you are vaulting to is currently disabled.");\n', '        \n', '        // there should be a require(balances_[_fram] >= _amount) here, but it was forgotten,\n', '        // fortunately solidity 0.8.x auto reverts if balance is insufficient here \n', '\n', '        balances_[_from] -= _amount;\n', '        balances_[OFF_CHAIN] += _amount;\n', '        \n', '        emit Vaulted(uint256(uint160(_from)), _dest_chain_id, _amount);\n', '\n', '        PigeonInterface p = PigeonInterface(pigeon_address_);    \n', '        p.pigeonSend{\n', '                value: p.pigeonCost(_dest_chain_id)\n', '        }(0x0, VAULTED_EVENT_ID, _dest_chain_id, uniwarp_contracts_[_dest_chain_id]);        \n', '        emit Transfer(_from, OFF_CHAIN, _amount);\n', '        return true;\n', '    }\n', '\n', '    function vault(uint256 _dest_chain_id, uint256 _amount) checkDeleted external payable override returns (bool success)\n', '    {\n', '        return vaultInternal(msg.sender, _dest_chain_id, _amount);\n', '    }\n', '\n', '\n', '    function vaultFrom(address _from, uint256 _dest_chain_id, uint256 _amount) checkDeleted external payable override returns (bool success)\n', '    {\n', '        uint256 current_allowance = allowed_[_from][msg.sender];\n', '        require(balances_[_from] >= _amount && current_allowance >= _amount);\n', '        if (current_allowance < MAX_UINT256)\n', '            allowed_[_from][msg.sender] -= _amount;\n', '            \n', '        vaultInternal(_from, _dest_chain_id, _amount);\n', '        \n', '        return true;\n', '    }\n', '\n', '\n', '    function name() external view returns ( string memory )\n', '    {\n', '        if (deleted_)\n', '            return "Uniwarp [Deleted]";\n', '        return "Uniwarp";\n', '    }\n', '    \n', '    function symbol() external view returns ( string memory )\n', '    {\n', '        if (deleted_)\n', '            return "UWRDELETED";\n', '        return "UWR";\n', '    }\n', '    \n', '    function decimals() external pure returns ( uint8 )\n', '    {\n', '        return 18;\n', '    }\n', '    \n', '    function total_supply() external view override returns ( uint256 )\n', '    {\n', '        if (deleted_)\n', '            return 0;\n', '            \n', '        return total_supply_; \n', '    }\n', '    \n', '    function chain_id() external view returns ( uint256 )\n', '    {\n', '        return chain_id_;\n', '    }\n', '    \n', '    \n', '    address setup_oracle_;\n', '    \n', '    function setupComplete() checkDisabled checkDeleted external returns (bool succcess)\n', '    {\n', '        setup_oracle_ = address(0x0);        \n', '        return true;\n', '    }\n', '    \n', '    function setupProposal(uint256 operation, uint256 operand_chain_id, uint256 operand) checkDisabled checkDeleted external returns (bool success)\n', '    {\n', '        \n', '        require(setup_oracle_ != address (0x0) && msg.sender == setup_oracle_, "The contract must be in setup mode and you must be the deployer.");\n', '        actionProposalInternal(operation, operand_chain_id, operand, false);\n', '        return true;\n', '    }\n', '    \n', '    function setupChains(uint256[] memory _chain_ids, uint256[] memory _uniwarp_contracts, bool setupDone) checkDisabled checkDeleted external returns (bool success)\n', '    {\n', '        require(setup_oracle_ != address (0x0) && msg.sender == setup_oracle_, "The contract must be in setup mode and you must be the deployer.");\n', '        if (setupDone)\n', '            setup_oracle_ = address(0x0);\n', '\n', '        return updateChains(_chain_ids, _uniwarp_contracts);   \n', '    }\n', '    \n', '    function updateChains(uint256[] memory _chain_ids, uint256[] memory _uniwarp_contracts) private returns (bool success)\n', '    {\n', '        bool voting_chain_found_in_chain_ids = false;\n', '        chain_count_ = _chain_ids.length;\n', '        for (uint i = 0; i < _chain_ids.length; ++i)\n', '        {\n', '            chain_ids_[i] = _chain_ids[i];\n', '            if (_chain_ids[i] == voting_chain_id_)\n', '                voting_chain_found_in_chain_ids = true;\n', '                    \n', '            if (_chain_ids[i] == chain_id_)\n', '                uniwarp_contracts_[chain_id_] = uint256(uint160(address(this)));\n', '            else\n', '                uniwarp_contracts_[_chain_ids[i]] = _uniwarp_contracts[i];\n', '        }\n', '        require(voting_chain_found_in_chain_ids, "You must specify the voting chain in the chain ids");\n', '        return true;\n', '    }\n', '    \n', '    constructor (\n', '        bool _is_first_chain,\n', '        uint256 _chain_id, \n', '\n', '        address _pigeon_address,\n', '        address _pigeon_oracle,\n', '\n', '        uint256 _voting_chain_id,     // votes are proxied to the uniwarp contract on the nominated chain and contract\n', '        \n', '        uint256 _voting_block_expiry,\n', '        \n', '        uint256[] memory _chain_ids, uint256[] memory _uniwarp_contracts\n', '        )\n', '        PigeonReceive (_pigeon_oracle) \n', '    {\n', '        setup_oracle_ = msg.sender;\n', '        total_supply_ = 100*(10**24); // 100 million warpies hard coded\n', '        chain_id_ = _chain_id;\n', '        pigeon_address_ = _pigeon_address;\n', '        voting_block_expiry_ = _voting_block_expiry;\n', '        voting_chain_id_ = _voting_chain_id;\n', '        \n', '        require(PigeonInterface(_pigeon_address).getPigeonOracleKey() == _pigeon_oracle, "Pigeon reported different oracle than provided");\n', '\n', '        if (_is_first_chain)\n', '        {\n', '            uint256 share = total_supply_/5.0;\n', '            /*\n', '            // these are test addresses for test rig\n', '            balances_[0x61b1D420b2852067eE1A4F79511fAb70b7F4F78c] += share;\n', '            balances_[0x61b1D420b2852067eE1A4F79511fAb70b7F4F78c] += share;\n', '            balances_[0x61b1D420b2852067eE1A4F79511fAb70b7F4F78c] += share;\n', '            balances_[0x5B199ee407a183bfA1cBAD4Cfac6b90470a104a9] += share;\n', '            balances_[0x5B199ee407a183bfA1cBAD4Cfac6b90470a104a9] += share;\n', '            */\n', '            balances_[0x241e6c88a09E9Bcfdd4C9cE718ac41757ae0Eaf6] += share; // s\n', '            balances_[0xdB72Dbcf738dDc8F691D39DE2FAa950a0378eeE3] += share; // w\n', '            balances_[0xA5497fb28af83B0C0172bD5A4FDc61c365D9eE3E] += share; // t\n', '            balances_[0xE9fFFE7c9b322c7065947A8232DDF1B8ff1C82f8] += share; // a\n', '            balances_[0x34070F4a89B0b8e51402Fb3C81413bcC192C7cC3] += share; // r\n', '            \n', '        }\n', '        else\n', '            balances_[OFF_CHAIN] = total_supply_;\n', '\n', '        updateChains(_chain_ids, _uniwarp_contracts);\n', '    }\n', '    \n', '    \n', '    function getPigeonOracleKey() view external returns (address)\n', '    {\n', '        return getOracleKey();\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _value) external override returns (bool success)\n', '    {\n', '        require(balances_[msg.sender] >= _value);\n', '        balances_[msg.sender] -= _value;\n', '        balances_[_to] += _value;\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external override returns (bool success)\n', '    {\n', '        uint256 current_allowance = allowed_[_from][msg.sender];\n', '        require(balances_[_from] >= _value && current_allowance >= _value, "Insufficent allowance");\n', '        balances_[_to] += _value;\n', '        balances_[_from] -= _value;\n', '        if (current_allowance < MAX_UINT256) {\n', '            allowed_[_from][msg.sender] -= _value;\n', '        }\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) external override view returns (uint256 balance)\n', '    {\n', '        return balances_[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) external override returns (bool success)\n', '    {\n', '        allowed_[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external override view returns (uint256 remaining)\n', '    {\n', '        return allowed_[_owner][_spender];\n', '    }\n', '}']