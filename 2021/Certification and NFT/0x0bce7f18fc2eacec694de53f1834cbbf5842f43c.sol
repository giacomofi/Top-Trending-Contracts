['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.3;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/// @title Contains 512-bit math functions\n', '/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n', '/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n', 'library FullMath {\n', '    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n', '    function mulDiv(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        // 512-bit multiply [prod1 prod0] = a * b\n', '        // Compute the product mod 2**256 and mod 2**256 - 1\n', '        // then use the Chinese Remainder Theorem to reconstruct\n', '        // the 512 bit result. The result is stored in two 256\n', '        // variables such that product = prod1 * 2**256 + prod0\n', '        uint256 prod0; // Least significant 256 bits of the product\n', '        uint256 prod1; // Most significant 256 bits of the product\n', '        assembly {\n', '            let mm := mulmod(a, b, not(0))\n', '            prod0 := mul(a, b)\n', '            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n', '        }\n', '\n', '        // Handle non-overflow cases, 256 by 256 division\n', '        if (prod1 == 0) {\n', '            require(denominator > 0);\n', '            assembly {\n', '                result := div(prod0, denominator)\n', '            }\n', '            return result;\n', '        }\n', '\n', '        // Make sure the result is less than 2**256.\n', '        // Also prevents denominator == 0\n', '        require(denominator > prod1);\n', '\n', '        ///////////////////////////////////////////////\n', '        // 512 by 256 division.\n', '        ///////////////////////////////////////////////\n', '\n', '        // Make division exact by subtracting the remainder from [prod1 prod0]\n', '        // Compute remainder using mulmod\n', '        uint256 remainder;\n', '        assembly {\n', '            remainder := mulmod(a, b, denominator)\n', '        }\n', '        // Subtract 256 bit number from 512 bit number\n', '        assembly {\n', '            prod1 := sub(prod1, gt(remainder, prod0))\n', '            prod0 := sub(prod0, remainder)\n', '        }\n', '\n', '        // Factor powers of two out of denominator\n', '        // Compute largest power of two divisor of denominator.\n', '        // Always >= 1.\n', '        uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n', '        // Divide denominator by power of two\n', '        assembly {\n', '            denominator := div(denominator, twos)\n', '        }\n', '\n', '        // Divide [prod1 prod0] by the factors of two\n', '        assembly {\n', '            prod0 := div(prod0, twos)\n', '        }\n', '        // Shift in bits from prod1 into prod0. For this we need\n', '        // to flip `twos` such that it is 2**256 / twos.\n', '        // If twos is zero, then it becomes one\n', '        assembly {\n', '            twos := add(div(sub(0, twos), twos), 1)\n', '        }\n', '        prod0 |= prod1 * twos;\n', '\n', '        // Invert denominator mod 2**256\n', '        // Now that denominator is an odd number, it has an inverse\n', '        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n', '        // Compute the inverse by starting with a seed that is correct\n', '        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n', '        uint256 inv = (3 * denominator) ^ 2;\n', '        // Now use Newton-Raphson iteration to improve the precision.\n', "        // Thanks to Hensel's lifting lemma, this also works in modular\n", '        // arithmetic, doubling the correct bits in each step.\n', '        inv *= 2 - denominator * inv; // inverse mod 2**8\n', '        inv *= 2 - denominator * inv; // inverse mod 2**16\n', '        inv *= 2 - denominator * inv; // inverse mod 2**32\n', '        inv *= 2 - denominator * inv; // inverse mod 2**64\n', '        inv *= 2 - denominator * inv; // inverse mod 2**128\n', '        inv *= 2 - denominator * inv; // inverse mod 2**256\n', '\n', '        // Because the division is now exact we can divide by multiplying\n', '        // with the modular inverse of denominator. This will give us the\n', '        // correct result modulo 2**256. Since the precoditions guarantee\n', '        // that the outcome is less than 2**256, this is the final result.\n', "        // We don't need to compute the high bits of the result and prod1\n", '        // is no longer required.\n', '        result = prod0 * inv;\n', '        return result;\n', '    }\n', '\n', '    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    function mulDivRoundingUp(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        result = mulDiv(a, b, denominator);\n', '        if (mulmod(a, b, denominator) > 0) {\n', '            require(result < type(uint256).max);\n', '            result++;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', 'abstract contract MinterReceiver is ERC165 {\n', '    function onSharesMinted(\n', '        uint40 stakeId,\n', '        address supplier,\n', '        uint72 stakedHearts,\n', '        uint72 stakeShares\n', '    ) external virtual;\n', '\n', '    function onEarningsMinted(uint40 stakeId, uint72 heartsEarned)\n', '        external\n', '        virtual;\n', '\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return\n', '            interfaceId == type(MinterReceiver).interfaceId ||\n', '            super.supportsInterface(interfaceId);\n', '    }\n', '}\n', '\n', 'contract ShareMarket is Ownable, MinterReceiver {\n', '    IERC20 public immutable hexContract;\n', '    address public immutable minterContract;\n', '    uint256 public buyerFee = 10;\n', '\n', '    uint256 private constant FEE_SCALE = 1000;\n', '\n', '    struct ShareOrder {\n', '        uint40 stakeId;\n', '        uint72 sharesPurchased;\n', '        address shareReceiver;\n', '    }\n', '    struct ShareListing {\n', '        uint8 buyerFee;\n', '        uint72 heartsStaked;\n', '        uint72 sharesTotal;\n', '        uint72 sharesAvailable;\n', '        uint72 heartsEarned;\n', '        uint72 supplierHeartsOwed;\n', '        address supplier;\n', '        mapping(address => uint72) shareOwners;\n', '    }\n', '    mapping(uint40 => ShareListing) public shareListings;\n', '\n', '    event BuyerFeeUpdate(uint8 oldFee, uint8 newFee);\n', '    event AddListing(\n', '        uint40 indexed stakeId,\n', '        address indexed supplier,\n', '        uint72 shares\n', '    );\n', '    event SharesUpdate(\n', '        uint40 indexed stakeId,\n', '        address indexed updater,\n', '        uint72 sharesAvailable\n', '    );\n', '    event AddEarnings(uint40 indexed stakeId, uint72 heartsEarned);\n', '    event BuyShares(\n', '        uint40 indexed stakeId,\n', '        address indexed owner,\n', '        uint72 sharesPurchased,\n', '        uint72 sharesOwned\n', '    );\n', '    event ClaimEarnings(\n', '        uint40 indexed stakeId,\n', '        address indexed claimer,\n', '        uint256 heartsClaimed\n', '    );\n', '    event SupplierWithdraw(\n', '        uint40 indexed stakeId,\n', '        address indexed supplier,\n', '        uint72 heartsWithdrawn\n', '    );\n', '\n', '    uint256 private unlocked = 1;\n', '    modifier lock() {\n', '        require(unlocked == 1, "LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    constructor(IERC20 _hex, address _minter) {\n', '        hexContract = _hex;\n', '        minterContract = _minter;\n', '    }\n', '\n', '    function updateBuyerFee(uint8 newBuyerFee) external onlyOwner {\n', '        emit BuyerFeeUpdate(uint8(buyerFee), newBuyerFee);\n', '        buyerFee = uint256(newBuyerFee);\n', '    }\n', '\n', '    function listingDetails(uint40 stakeId)\n', '        public\n', '        view\n', '        returns (\n', '            uint72 hearts,\n', '            uint72 shares,\n', '            uint72 sharesAvailable\n', '        )\n', '    {\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        hearts = listing.heartsStaked;\n', '        shares = _marketShares(listing.sharesTotal, listing.buyerFee);\n', '        sharesAvailable = listing.sharesAvailable;\n', '    }\n', '\n', '    function sharesOwned(uint40 stakeId, address owner)\n', '        public\n', '        view\n', '        returns (uint72)\n', '    {\n', '        return shareListings[stakeId].shareOwners[owner];\n', '    }\n', '\n', '    function _supplierShares(uint72 sharesTotal, uint256 fee)\n', '        private\n', '        pure\n', '        returns (uint72)\n', '    {\n', '        return uint72(FullMath.mulDiv(sharesTotal, fee, FEE_SCALE));\n', '    }\n', '\n', '    function _marketShares(uint72 sharesTotal, uint256 fee)\n', '        private\n', '        pure\n', '        returns (uint72)\n', '    {\n', '        return sharesTotal - _supplierShares(sharesTotal, fee);\n', '    }\n', '\n', '    function onSharesMinted(\n', '        uint40 stakeId,\n', '        address supplier,\n', '        uint72 stakedHearts,\n', '        uint72 stakeShares\n', '    ) external override {\n', '        require(msg.sender == minterContract, "CALLER_NOT_MINTER");\n', '\n', '        uint72 supplierShares = _supplierShares(stakeShares, buyerFee);\n', '        uint72 marketShares = _marketShares(stakeShares, buyerFee);\n', '\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        listing.buyerFee = uint8(buyerFee);\n', '        listing.heartsStaked = stakedHearts;\n', '        listing.sharesTotal = stakeShares;\n', '        listing.sharesAvailable = marketShares;\n', '        listing.supplier = supplier;\n', '        emit AddListing(stakeId, supplier, marketShares);\n', '\n', '        listing.shareOwners[supplier] = supplierShares;\n', '        emit BuyShares(stakeId, supplier, 0, supplierShares);\n', '    }\n', '\n', '    function onEarningsMinted(uint40 stakeId, uint72 heartsEarned)\n', '        external\n', '        override\n', '    {\n', '        require(msg.sender == minterContract, "CALLER_NOT_MINTER");\n', '\n', '        shareListings[stakeId].heartsEarned = heartsEarned;\n', '\n', '        emit AddEarnings(stakeId, heartsEarned);\n', '    }\n', '\n', '    function _buyShares(\n', '        uint40 stakeId,\n', '        address shareReceiver,\n', '        uint72 sharesPurchased\n', '    ) private returns (uint72 heartsOwed) {\n', '        require(sharesPurchased != 0, "INSUFFICIENT_SHARES_PURCHASED");\n', '\n', '        ShareListing storage listing = shareListings[stakeId];\n', '\n', '        require(\n', '            sharesPurchased <= listing.sharesAvailable,\n', '            "INSUFFICIENT_SHARES_AVAILABLE"\n', '        );\n', '\n', '        heartsOwed = uint72(\n', '            FullMath.mulDivRoundingUp(\n', '                sharesPurchased,\n', '                listing.heartsStaked,\n', '                _marketShares(listing.sharesTotal, listing.buyerFee)\n', '            )\n', '        );\n', '        require(heartsOwed != 0, "INSUFFICIENT_HEARTS_INPUT");\n', '\n', '        listing.sharesAvailable -= sharesPurchased;\n', '        emit SharesUpdate(stakeId, msg.sender, listing.sharesAvailable);\n', '\n', '        uint72 newSharesOwned =\n', '            listing.shareOwners[shareReceiver] + sharesPurchased;\n', '        listing.shareOwners[shareReceiver] = newSharesOwned;\n', '        listing.supplierHeartsOwed += heartsOwed;\n', '        emit BuyShares(stakeId, shareReceiver, sharesPurchased, newSharesOwned);\n', '\n', '        return heartsOwed;\n', '    }\n', '\n', '    function multiBuyShares(ShareOrder[] memory orders) external lock {\n', '        uint256 orderCount = orders.length;\n', '        require(orderCount <= 30, "EXCEEDED_ORDER_LIMIT");\n', '\n', '        uint256 totalHeartsOwed;\n', '        for (uint256 i = 0; i < orderCount; i++) {\n', '            ShareOrder memory order = orders[i];\n', '            totalHeartsOwed += _buyShares(\n', '                order.stakeId,\n', '                order.shareReceiver,\n', '                order.sharesPurchased\n', '            );\n', '        }\n', '\n', '        hexContract.transferFrom(msg.sender, address(this), totalHeartsOwed);\n', '    }\n', '\n', '    function buyShares(\n', '        uint40 stakeId,\n', '        address shareReceiver,\n', '        uint72 sharesPurchased\n', '    ) external lock {\n', '        uint72 heartsOwed = _buyShares(stakeId, shareReceiver, sharesPurchased);\n', '        hexContract.transferFrom(msg.sender, address(this), heartsOwed);\n', '    }\n', '\n', '    function claimEarnings(uint40 stakeId) external lock {\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        require(listing.heartsEarned != 0, "SHARES_NOT_MATURE");\n', '\n', '        uint72 ownedShares = listing.shareOwners[msg.sender];\n', '\n', '        if (msg.sender == listing.supplier) {\n', '            ownedShares += listing.sharesAvailable;\n', '            listing.sharesAvailable = 0;\n', '            emit SharesUpdate(stakeId, msg.sender, 0);\n', '        }\n', '\n', '        uint256 heartsOwed =\n', '            FullMath.mulDiv(\n', '                listing.heartsEarned,\n', '                ownedShares,\n', '                listing.sharesTotal\n', '            );\n', '        require(heartsOwed != 0, "NO_HEARTS_CLAIMABLE");\n', '\n', '        listing.shareOwners[msg.sender] = 0;\n', '        hexContract.transfer(msg.sender, heartsOwed);\n', '\n', '        emit ClaimEarnings(stakeId, msg.sender, heartsOwed);\n', '    }\n', '\n', '    function supplierWithdraw(uint40 stakeId) external lock {\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        require(msg.sender == listing.supplier, "SENDER_NOT_SUPPLIER");\n', '\n', '        uint72 heartsOwed = listing.supplierHeartsOwed;\n', '        require(heartsOwed != 0, "NO_HEARTS_OWED");\n', '\n', '        listing.supplierHeartsOwed = 0;\n', '        hexContract.transfer(msg.sender, heartsOwed);\n', '\n', '        emit SupplierWithdraw(stakeId, msg.sender, heartsOwed);\n', '    }\n', '}']