['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-01\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0\n', 'pragma solidity 0.6.12;\n', '\n', 'contract ProxyFactoryInitializable {\n', '  \n', '    event ProxyCreated(address indexed proxy, bytes returnData);\n', '\n', '    function deployMinimal(address _logic, bytes memory _data) external returns (address proxy, bytes memory returnData) {\n', '        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n', '        bytes20 targetBytes = bytes20(_logic);\n', '        assembly {\n', '        let clone := mload(0x40)\n', '        mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '        mstore(add(clone, 0x14), targetBytes)\n', '        mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '        proxy := create(0, clone, 0x37)\n', '        }\n', '        \n', '        if(_data.length > 0) {\n', '        bool success = false;\n', '        (success, returnData) = proxy.call(_data);\n', '        if (!success) {\n', '            string memory _revertMsg = _getRevertMsg(returnData);\n', '            revert(_revertMsg);\n', '        }\n', '        }\n', '\n', '        emit ProxyCreated(address(proxy), returnData);\n', '    }\n', '\n', '    /// @dev Get the revert message from a call\n', '    /// @notice This is needed in order to get the human-readable revert message from a call\n', '    /// @param _res Response of the call\n', '    /// @return Revert message string\n', '    function _getRevertMsg(bytes memory _res) internal pure returns (string memory) {\n', '        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n', "        if (_res.length < 68) return 'Transaction reverted silently';\n", '        bytes memory revertData = slice(_res, 4, _res.length - 4); // Remove the selector which is the first 4 bytes\n', '        return abi.decode(revertData, (string)); // All that remains is the revert string\n', '    }\n', '\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint256 _start,\n', '        uint256 _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_length + 31 >= _length, "slice_overflow");\n', '        require(_start + _length >= _start, "slice_overflow");\n', '        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '}']