['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-06\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'interface IGraSwapBlackList {\n', '    // event OwnerChanged(address);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AddedBlackLists(address[]);\n', '    event RemovedBlackLists(address[]);\n', '\n', '    function owner()external view returns (address);\n', '    // function newOwner()external view returns (address);\n', '    function isBlackListed(address)external view returns (bool);\n', '\n', '    // function changeOwner(address ownerToSet) external;\n', '    // function updateOwner() external;\n', '    function transferOwnership(address newOwner) external;\n', '    function addBlackLists(address[] calldata  accounts)external;\n', '    function removeBlackLists(address[] calldata  accounts)external;\n', '}\n', '\n', 'interface IGraWhiteList {\n', '    event AppendWhiter(address adder);\n', '    event RemoveWhiter(address remover);\n', '    \n', '    function appendWhiter(address account) external;\n', '    function removeWhiter(address account) external;\n', '    function isWhiter(address account) external;\n', '    function isNotWhiter(address account) external;\n', '}\n', '\n', 'interface IGraSwapToken is IERC20, IGraSwapBlackList, IGraWhiteList{\n', '    function burn(uint256 amount) external;\n', '    function burnFrom(address account, uint256 amount) external;\n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n', '    // function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\n', '    function batchTransfer(address[] memory addressList, uint256[] memory amountList) external returns (bool);\n', '}\n', '\n', 'interface IGraSwapFactory {\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\n', '    function setFeeToAddresses(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setFeeBPS(uint32 bps) external;\n', '    function setPairLogic(address implLogic) external;\n', '\n', '    function allPairsLength() external view returns (uint);\n', '    function feeTo_1() external view returns (address);\n', '    function feeTo_2() external view returns (address);\n', '    function feeToPrivate() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function feeBPS() external view returns (uint32);\n', '    function pairLogic() external returns (address);\n', '    function getTokensFromPair(address pair) external view returns (address stock, address money);\n', '    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\n', '}\n', '\n', 'interface IGraSwapRouter {\n', '    event AddLiquidity(uint stockAmount, uint moneyAmount, uint liquidity);\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function factory() external pure returns (address);\n', '\n', '    // liquidity\n', '    function addLiquidity(\n', '        address stock,\n', '        address money,\n', '        bool isOnlySwap,\n', '        uint amountStockDesired,\n', '        uint amountMoneyDesired,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountStock, uint amountMoney, uint liquidity);\n', '    function removeLiquidity(\n', '        address pair,\n', '        uint liquidity,\n', '        uint amountStockMin,\n', '        uint amountMoneyMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountStock, uint amountMoney);\n', '\n', '    // swap token\n', '    function swapToken(\n', '        address token,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '\n', '    // limit order\n', '    function limitOrder(\n', '        bool isBuy,\n', '        address pair,\n', '        uint prevKey,\n', '        uint price,\n', '        uint32 id,\n', '        uint stockAmount,\n', '        uint deadline\n', '    ) external payable;\n', '}\n', '\n', 'interface IGraSwapBuyback {\n', '    event BurnGras(uint256 burntAmt);\n', '\n', '    function graContract() external pure returns (address);\n', '    function router() external pure returns (address);\n', '    function factory() external pure returns (address);\n', '\n', '    function addMainToken(address token) external;\n', '    function removeMainToken(address token) external;\n', '    function isMainToken(address token) external view returns (bool);\n', '    function mainTokens() external view returns (address[] memory list);\n', '\n', '    function removeLiquidity(address[] calldata pairs) external;\n', '    function swapForMainToken(address[] calldata pairs) external;\n', '    function swapForGrasAndBurn(address[] calldata pairs) external;\n', '}\n', '\n', 'contract GraSwapBuyback is IGraSwapBuyback {\n', '\n', '    uint256 private constant _MAX_UINT256 = uint256(-1); \n', '    address private constant _ETH = address(0);\n', '\n', '    address public immutable override graContract;\n', '    address public immutable override router;\n', '    address public immutable override factory;\n', '\n', '    mapping (address => bool) private _mainTokens;\n', '    address[] private _mainTokenArr;\n', '\n', '    constructor(address _graContract, address _router, address _factory) public {\n', '        graContract = _graContract;\n', '        router = _router;\n', '        factory = _factory;\n', '\n', '        // add ETH & GraS to main token list\n', '        _mainTokens[_ETH] = true;\n', '        _mainTokenArr.push(_ETH);\n', '        _mainTokens[_graContract] = true;\n', '        _mainTokenArr.push(_graContract);\n', '    }\n', '\n', '    receive() external payable { }\n', '\n', '    // add token into main token list\n', '    function addMainToken(address token) external override {\n', '        require(msg.sender == IGraSwapToken(graContract).owner(), "GraSwapBuyback: NOT_Gra_OWNER");\n', '        if (!_mainTokens[token]) {\n', '            _mainTokens[token] = true;\n', '            _mainTokenArr.push(token);\n', '        }\n', '    }\n', '    // remove token from main token list\n', '    function removeMainToken(address token) external override {\n', '        require(msg.sender == IGraSwapToken(graContract).owner(), "GraSwapBuyback: NOT_Gra_OWNER");\n', '        require(token != _ETH, "GraSwapBuyback: REMOVE_ETH_FROM_MAIN");\n', '        require(token != graContract, "GraSwapBuyback: REMOVE_Gra_FROM_MAIN");\n', '        if (_mainTokens[token]) {\n', '            _mainTokens[token] = false;\n', '            uint256 lastIdx = _mainTokenArr.length - 1;\n', '            for (uint256 i = 2; i < lastIdx; i++) { // skip ETH & Gra\n', '                if (_mainTokenArr[i] == token) {\n', '                    _mainTokenArr[i] = _mainTokenArr[lastIdx];\n', '                    break;\n', '                }\n', '            }\n', '            _mainTokenArr.pop();\n', '        }\n', '    }\n', '    // check if token is in main token list\n', '    function isMainToken(address token) external view override returns (bool) {\n', '        return _mainTokens[token];\n', '    }\n', '    // query main token list\n', '    function mainTokens() external view override returns (address[] memory list) {\n', '        list = _mainTokenArr;\n', '    }\n', '\n', "    // remove Buyback's liquidity from all pairs\n", '    // swap got minor tokens for main tokens if possible\n', '    function removeLiquidity(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _removeLiquidity(pairs[i]);\n', '        }\n', '    }\n', '    function _removeLiquidity(address pair) private {\n', '        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "GraSwapBuyback: INVALID_PAIR");\n', '\n', '        uint256 amt = IERC20(pair).balanceOf(address(this));\n', '        // require(amt > 0, "GraSwapBuyback: NO_LIQUIDITY");\n', '        if (amt == 0) { return; }\n', '\n', '        IERC20(pair).approve(router, 0);\n', '        IERC20(pair).approve(router, amt);\n', '        IGraSwapRouter(router).removeLiquidity(\n', '            pair, amt, 0, 0, address(this), _MAX_UINT256);\n', '\n', '        // minor -> main\n', '        bool aIsMain = _mainTokens[a];\n', '        bool bIsMain = _mainTokens[b];\n', '        if ((aIsMain && !bIsMain) || (!aIsMain && bIsMain)) {\n', '            _swapForMainToken(pair);\n', '        }\n', '    }\n', '\n', '    // swap minor tokens for main tokens\n', '    function swapForMainToken(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _swapForMainToken(pairs[i]);\n', '        }\n', '    }\n', '    function _swapForMainToken(address pair) private {\n', '        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "GraSwapBuyback: INVALID_PAIR");\n', '\n', '        address mainToken;\n', '        address minorToken;\n', '        if (_mainTokens[a]) {\n', '            require(!_mainTokens[b], "GraSwapBuyback: SWAP_TWO_MAIN_TOKENS");\n', '            (mainToken, minorToken) = (a, b);\n', '        } else {\n', '            require(_mainTokens[b], "GraSwapBuyback: SWAP_TWO_MINOR_TOKENS");\n', '            (mainToken, minorToken) = (b, a);\n', '        }\n', '\n', '        uint256 minorTokenAmt = IERC20(minorToken).balanceOf(address(this));\n', '        // require(minorTokenAmt > 0, "GraSwapBuyback: NO_MINOR_TOKENS");\n', '        if (minorTokenAmt == 0) { return; }\n', '\n', '        address[] memory path = new address[](1);\n', '        path[0] = pair;\n', '\n', '        // minor -> main\n', '        IERC20(minorToken).approve(router, 0);\n', '        IERC20(minorToken).approve(router, minorTokenAmt);\n', '        IGraSwapRouter(router).swapToken(\n', '            minorToken, minorTokenAmt, 0, path, address(this), _MAX_UINT256);\n', '    }\n', '\n', '    // swap main tokens for Gras, then burn all Gras\n', '    function swapForGrasAndBurn(address[] calldata pairs) external override {\n', '        for (uint256 i = 0; i < pairs.length; i++) {\n', '            _swapForGras(pairs[i]);\n', '        }\n', '\n', '        // burn all Gras\n', '        uint256 allGras = IERC20(graContract).balanceOf(address(this));\n', '        if (allGras == 0) { return; }\n', '        IGraSwapToken(graContract).burn(allGras);\n', '        emit BurnGras(allGras);\n', '    }\n', '    function _swapForGras(address pair) private {\n', '        (address a, address b) = IGraSwapFactory(factory).getTokensFromPair(pair);\n', '        require(a != address(0) || b != address(0), "GraSwapBuyback: INVALID_PAIR");\n', '        require(a == graContract || b == graContract, "GraSwapBuyback: GraS_NOT_IN_PAIR");\n', '\n', '        address token = (a == graContract) ? b : a;\n', '        require(_mainTokens[token], "GraSwapBuyback: MAIN_TOKEN_NOT_IN_PAIR");\n', '\n', '        address[] memory path = new address[](1);\n', '        path[0] = pair;\n', '\n', '        if (token == _ETH) { // eth -> Gras\n', '            uint256 ethAmt = address(this).balance;\n', '            // require(ethAmt > 0, "GraSwapBuyback: NO_ETH");\n', '            if (ethAmt == 0) { return; }\n', '\n', '            IGraSwapRouter(router).swapToken{value: ethAmt}(\n', '                _ETH, ethAmt, 0, path, address(this), _MAX_UINT256);\n', '        } else { // main token -> Gras\n', '            uint256 tokenAmt = IERC20(token).balanceOf(address(this));\n', '            // require(tokenAmt > 0, "GraSwapBuyback: NO_MAIN_TOKENS");\n', '            if (tokenAmt == 0) { return; }\n', '\n', '            IERC20(token).approve(router, 0);\n', '            IERC20(token).approve(router, tokenAmt);\n', '            IGraSwapRouter(router).swapToken(\n', '                token, tokenAmt, 0, path, address(this), _MAX_UINT256);\n', '        }\n', '    }\n', '\n', '}']