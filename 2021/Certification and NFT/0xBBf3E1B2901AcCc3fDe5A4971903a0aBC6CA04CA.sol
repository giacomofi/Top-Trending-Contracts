['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-27\n', '*/\n', '\n', '// File: contracts\\lib\\IERC20.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.8.3;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\interface\\INestMining.sol\n', '\n', '/// @dev This interface defines the mining methods for nest\n', 'interface INestMining {\n', '    \n', '    /// @dev Post event\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param miner Address of miner\n', '    /// @param index Index of the price sheet\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    event Post(address tokenAddress, address miner, uint index, uint ethNum, uint price);\n', '\n', '    /* ========== Structures ========== */\n', '    \n', '    /// @dev Nest mining configuration structure\n', '    struct Config {\n', '        \n', '        // Eth number of each post. 30\n', '        // We can stop post and taking orders by set postEthUnit to 0 (closing and withdraw are not affected)\n', '        uint32 postEthUnit;\n', '\n', '        // Post fee(0.0001eth，DIMI_ETHER). 1000\n', '        uint16 postFeeUnit;\n', '\n', '        // Proportion of miners digging(10000 based). 8000\n', '        uint16 minerNestReward;\n', '        \n', '        // The proportion of token dug by miners is only valid for the token created in version 3.0\n', '        // (10000 based). 9500\n', '        uint16 minerNTokenReward;\n', '\n', '        // When the circulation of ntoken exceeds this threshold, post() is prohibited(Unit: 10000 ether). 500\n', '        uint32 doublePostThreshold;\n', '        \n', '        // The limit of ntoken mined blocks. 100\n', '        uint16 ntokenMinedBlockLimit;\n', '\n', '        // -- Public configuration\n', '        // The number of times the sheet assets have doubled. 4\n', '        uint8 maxBiteNestedLevel;\n', '        \n', '        // Price effective block interval. 20\n', '        uint16 priceEffectSpan;\n', '\n', '        // The amount of nest to pledge for each post（Unit: 1000). 100\n', '        uint16 pledgeNest;\n', '    }\n', '\n', '    /// @dev PriceSheetView structure\n', '    struct PriceSheetView {\n', '        \n', '        // Index of the price sheeet\n', '        uint32 index;\n', '\n', '        // Address of miner\n', '        address miner;\n', '\n', '        // The block number of this price sheet packaged\n', '        uint32 height;\n', '\n', '        // The remain number of this price sheet\n', '        uint32 remainNum;\n', '\n', '        // The eth number which miner will got\n', '        uint32 ethNumBal;\n', '\n', "        // The eth number which equivalent to token's value which miner will got\n", '        uint32 tokenNumBal;\n', '\n', '        // The pledged number of nest in this sheet. (Unit: 1000nest)\n', '        uint24 nestNum1k;\n', '\n', '        // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\n', '        uint8 level;\n', '\n', '        // Post fee shares, if there are many sheets in one block, this value is used to divide up mining value\n', '        uint8 shares;\n', '\n', '        // The token price. (1eth equivalent to (price) token)\n', '        uint152 price;\n', '    }\n', '\n', '    /* ========== Configuration ========== */\n', '\n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config memory config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Set the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @param ntokenAddress The ntoken address\n', '    function setNTokenAddress(address tokenAddress, address ntokenAddress) external;\n', '\n', '    /// @dev Get the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @return The ntoken address\n', '    function getNTokenAddress(address tokenAddress) external view returns (address);\n', '\n', '    /* ========== Mining ========== */\n', '\n', '    /// @notice Post a price sheet for TOKEN\n', '    /// @dev It is for TOKEN (except USDT and NTOKENs) whose NTOKEN has a total supply below a threshold (e.g. 5,000,000 * 1e18)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    function post(address tokenAddress, uint ethNum, uint tokenAmountPerEth) external payable;\n', '\n', '    /// @notice Post two price sheets for a token and its ntoken simultaneously \n', '    /// @dev Support dual-posts for TOKEN/NTOKEN, (ETH, TOKEN) + (ETH, NTOKEN)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    /// @param ntokenAmountPerEth The price of NTOKEN\n', '    function post2(address tokenAddress, uint ethNum, uint tokenAmountPerEth, uint ntokenAmountPerEth) external payable;\n', '\n', '    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n', '    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum * newTokenAmountPerEth\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeToken(address tokenAddress, uint index, uint takeNum, uint newTokenAmountPerEth) external payable;\n', '\n', '    /// @notice Call the function to buy ETH from a posted price sheet\n', '    /// @dev bite ETH by TOKEN(NTOKEN),  (-ethNumBal, +tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeEth(address tokenAddress, uint index, uint takeNum, uint newTokenAmountPerEth) external payable;\n', '    \n', '    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\n', '    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param index The index of the price sheet w.r.t. `token`\n', '    function close(address tokenAddress, uint index) external;\n', '\n', '    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param indices A list of indices of sheets w.r.t. `token`\n', '    function closeList(address tokenAddress, uint[] memory indices) external;\n', '\n', '    /// @notice Close two batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN1 contract\n', '    /// @param tokenIndices A list of indices of sheets w.r.t. `token`\n', '    /// @param ntokenIndices A list of indices of sheets w.r.t. `ntoken`\n', '    function closeList2(address tokenAddress, uint[] memory tokenIndices, uint[] memory ntokenIndices) external;\n', '\n', '    /// @dev The function updates the statistics of price sheets\n', '    ///     It calculates from priceInfo to the newest that is effective.\n', '    function stat(address tokenAddress) external;\n', '\n', '    /// @dev Settlement Commission\n', '    /// @param tokenAddress The token address\n', '    function settle(address tokenAddress) external;\n', '\n', '    /// @dev List sheets by page\n', '    /// @param tokenAddress Destination token address\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return List of price sheets\n', '    function list(address tokenAddress, uint offset, uint count, uint order) external view returns (PriceSheetView[] memory);\n', '\n', '    /// @dev Estimated mining amount\n', '    /// @param tokenAddress Destination token address\n', '    /// @return Estimated mining amount\n', '    function estimate(address tokenAddress) external view returns (uint);\n', '\n', '    /// @dev Query the quantity of the target quotation\n', "    /// @param tokenAddress Token address. The token can't mine. Please make sure you don't use the token address when calling\n", '    /// @param index The index of the sheet\n', '    /// @return minedBlocks Mined block period from previous block\n', '    /// @return totalShares Total shares of sheets in the block\n', '    function getMinedBlocks(address tokenAddress, uint index) external view returns (uint minedBlocks, uint totalShares);\n', '\n', '    /* ========== Accounts ========== */\n', '\n', '    /// @dev Withdraw assets\n', '    /// @param tokenAddress Destination token address\n', '    /// @param value The value to withdraw\n', '    function withdraw(address tokenAddress, uint value) external;\n', '\n', '    /// @dev View the number of assets specified by the user\n', '    /// @param tokenAddress Destination token address\n', '    /// @param addr Destination address\n', '    /// @return Number of assets\n', '    function balanceOf(address tokenAddress, address addr) external view returns (uint);\n', '\n', '    /// @dev Gets the address corresponding to the given index number\n', '    /// @param index The index number of the specified address\n', '    /// @return The address corresponding to the given index number\n', '    function indexAddress(uint index) external view returns (address);\n', '    \n', '    /// @dev Gets the registration index number of the specified address\n', '    /// @param addr Destination address\n', '    /// @return 0 means nonexistent, non-0 means index number\n', '    function getAccountIndex(address addr) external view returns (uint);\n', '\n', '    /// @dev Get the length of registered account array\n', '    /// @return The length of registered account array\n', '    function getAccountCount() external view returns (uint);\n', '}\n', '\n', '// File: contracts\\interface\\INestVote.sol\n', '\n', '/// @dev This interface defines the methods for voting\n', 'interface INestVote {\n', '\n', '    /// @dev Event of submitting a voting proposal\n', '    /// @param proposer Proposer address\n', '    /// @param contractAddress The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '    /// @param index Index of proposal\n', '    event NIPSubmitted(address proposer, address contractAddress, uint index);\n', '\n', '    /// @dev Voting event\n', '    /// @param voter Voter address\n', '    /// @param index Index of proposal\n', '    /// @param amount Amount of nest to vote\n', '    event NIPVote(address voter, uint index, uint amount);\n', '\n', '    /// @dev Proposal execute event\n', '    /// @param executor Executor address\n', '    /// @param index Index of proposal\n', '    event NIPExecute(address executor, uint index);\n', '\n', '    /// @dev Voting contract configuration structure\n', '    struct Config {\n', '\n', '        // Proportion of votes required (10000 based). 5100\n', '        uint32 acceptance;\n', '\n', '        // Voting time cycle (seconds). 5 * 86400\n', '        uint64 voteDuration;\n', '\n', '        // The number of nest votes need to be staked. 100000 nest\n', '        uint96 proposalStaking;\n', '    }\n', '\n', '    // Proposal\n', '    struct ProposalView {\n', '\n', '        // Index of proposal\n', '        uint index;\n', '        \n', '        // The immutable field and the variable field are stored separately\n', '        /* ========== Immutable field ========== */\n', '\n', '        // Brief of this proposal\n', '        string brief;\n', '\n', '        // The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '        address contractAddress;\n', '\n', '        // Voting start time\n', '        uint48 startTime;\n', '\n', '        // Voting stop time\n', '        uint48 stopTime;\n', '\n', '        // Proposer\n', '        address proposer;\n', '\n', '        // Staked nest amount\n', '        uint96 staked;\n', '\n', '        /* ========== Mutable field ========== */\n', '\n', '        // Gained value\n', '        // The maximum value of uint96 can be expressed as 79228162514264337593543950335, which is more than the total \n', '        // number of nest 10000000000 ether. Therefore, uint96 can be used to express the total number of votes\n', '        uint96 gainValue;\n', '\n', '        // The state of this proposal\n', '        uint32 state;  // 0: proposed | 1: accepted | 2: cancelled\n', '\n', '        // The executor of this proposal\n', '        address executor;\n', '\n', '        // The execution time (if any, such as block number or time stamp) is placed in the contract and is limited by the contract itself\n', '\n', '        // Circulation of nest\n', '        uint96 nestCirculation;\n', '    }\n', '    \n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config memory config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /* ========== VOTE ========== */\n', '    \n', '    /// @dev Initiate a voting proposal\n', '    /// @param contractAddress The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '    /// @param brief Brief of this propose\n', '    function propose(address contractAddress, string memory brief) external;\n', '\n', '    /// @dev vote\n', '    /// @param index Index of proposal\n', '    /// @param value Amount of nest to vote\n', '    function vote(uint index, uint value) external;\n', '\n', '    /// @dev Withdraw the nest of the vote. If the target vote is in the voting state, the corresponding number of votes will be cancelled\n', '    /// @param index Index of the proposal\n', '    function withdraw(uint index) external;\n', '\n', '    /// @dev Execute the proposal\n', '    /// @param index Index of the proposal\n', '    function execute(uint index) external;\n', '\n', '    /// @dev Cancel the proposal\n', '    /// @param index Index of the proposal\n', '    function cancel(uint index) external;\n', '\n', '    /// @dev Get proposal information\n', '    /// @param index Index of the proposal\n', '    /// @return Proposal information\n', '    function getProposeInfo(uint index) external view returns (ProposalView memory);\n', '\n', '    /// @dev Get the cumulative number of voting proposals\n', '    /// @return The cumulative number of voting proposals\n', '    function getProposeCount() external view returns (uint);\n', '\n', '    /// @dev List proposals by page\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return List of price proposals\n', '    function list(uint offset, uint count, uint order) external view returns (ProposalView[] memory);\n', '\n', '    /// @dev Get Circulation of nest\n', '    /// @return Circulation of nest\n', '    function getNestCirculation() external view returns (uint);\n', '\n', '    /// @dev Upgrades a proxy to the newest implementation of a contract\n', '    /// @param proxyAdmin The address of ProxyAdmin\n', '    /// @param proxy Proxy to be upgraded\n', '    /// @param implementation the address of the Implementation\n', '    function upgradeProxy(address proxyAdmin, address proxy, address implementation) external;\n', '\n', '    /// @dev Transfers ownership of the contract to a new account (`newOwner`)\n', '    ///      Can only be called by the current owner\n', '    /// @param proxyAdmin The address of ProxyAdmin\n', '    /// @param newOwner The address of new owner\n', '    function transferUpgradeAuthority(address proxyAdmin, address newOwner) external;\n', '}\n', '\n', '// File: contracts\\interface\\IVotePropose.sol\n', '\n', '/// @dev Interface to be implemented for voting contract\n', 'interface IVotePropose {\n', '\n', '    /// @dev Methods to be called after approved\n', '    function run() external;\n', '}\n', '\n', '// File: contracts\\interface\\INestMapping.sol\n', '\n', '/// @dev The interface defines methods for nest builtin contract address mapping\n', 'interface INestMapping {\n', '\n', '    /// @dev Set the built-in contract address of the system\n', '    /// @param nestTokenAddress Address of nest token contract\n', '    /// @param nestNodeAddress Address of nest node contract\n', '    /// @param nestLedgerAddress INestLedger implementation contract address\n', '    /// @param nestMiningAddress INestMining implementation contract address for nest\n', '    /// @param ntokenMiningAddress INestMining implementation contract address for ntoken\n', '    /// @param nestPriceFacadeAddress INestPriceFacade implementation contract address\n', '    /// @param nestVoteAddress INestVote implementation contract address\n', '    /// @param nestQueryAddress INestQuery implementation contract address\n', '    /// @param nnIncomeAddress NNIncome contract address\n', '    /// @param nTokenControllerAddress INTokenController implementation contract address\n', '    function setBuiltinAddress(\n', '        address nestTokenAddress,\n', '        address nestNodeAddress,\n', '        address nestLedgerAddress,\n', '        address nestMiningAddress,\n', '        address ntokenMiningAddress,\n', '        address nestPriceFacadeAddress,\n', '        address nestVoteAddress,\n', '        address nestQueryAddress,\n', '        address nnIncomeAddress,\n', '        address nTokenControllerAddress\n', '    ) external;\n', '\n', '    /// @dev Get the built-in contract address of the system\n', '    /// @return nestTokenAddress Address of nest token contract\n', '    /// @return nestNodeAddress Address of nest node contract\n', '    /// @return nestLedgerAddress INestLedger implementation contract address\n', '    /// @return nestMiningAddress INestMining implementation contract address for nest\n', '    /// @return ntokenMiningAddress INestMining implementation contract address for ntoken\n', '    /// @return nestPriceFacadeAddress INestPriceFacade implementation contract address\n', '    /// @return nestVoteAddress INestVote implementation contract address\n', '    /// @return nestQueryAddress INestQuery implementation contract address\n', '    /// @return nnIncomeAddress NNIncome contract address\n', '    /// @return nTokenControllerAddress INTokenController implementation contract address\n', '    function getBuiltinAddress() external view returns (\n', '        address nestTokenAddress,\n', '        address nestNodeAddress,\n', '        address nestLedgerAddress,\n', '        address nestMiningAddress,\n', '        address ntokenMiningAddress,\n', '        address nestPriceFacadeAddress,\n', '        address nestVoteAddress,\n', '        address nestQueryAddress,\n', '        address nnIncomeAddress,\n', '        address nTokenControllerAddress\n', '    );\n', '\n', '    /// @dev Get address of nest token contract\n', '    /// @return Address of nest token contract\n', '    function getNestTokenAddress() external view returns (address);\n', '\n', '    /// @dev Get address of nest node contract\n', '    /// @return Address of nest node contract\n', '    function getNestNodeAddress() external view returns (address);\n', '\n', '    /// @dev Get INestLedger implementation contract address\n', '    /// @return INestLedger implementation contract address\n', '    function getNestLedgerAddress() external view returns (address);\n', '\n', '    /// @dev Get INestMining implementation contract address for nest\n', '    /// @return INestMining implementation contract address for nest\n', '    function getNestMiningAddress() external view returns (address);\n', '\n', '    /// @dev Get INestMining implementation contract address for ntoken\n', '    /// @return INestMining implementation contract address for ntoken\n', '    function getNTokenMiningAddress() external view returns (address);\n', '\n', '    /// @dev Get INestPriceFacade implementation contract address\n', '    /// @return INestPriceFacade implementation contract address\n', '    function getNestPriceFacadeAddress() external view returns (address);\n', '\n', '    /// @dev Get INestVote implementation contract address\n', '    /// @return INestVote implementation contract address\n', '    function getNestVoteAddress() external view returns (address);\n', '\n', '    /// @dev Get INestQuery implementation contract address\n', '    /// @return INestQuery implementation contract address\n', '    function getNestQueryAddress() external view returns (address);\n', '\n', '    /// @dev Get NNIncome contract address\n', '    /// @return NNIncome contract address\n', '    function getNnIncomeAddress() external view returns (address);\n', '\n', '    /// @dev Get INTokenController implementation contract address\n', '    /// @return INTokenController implementation contract address\n', '    function getNTokenControllerAddress() external view returns (address);\n', '\n', '    /// @dev Registered address. The address registered here is the address accepted by nest system\n', '    /// @param key The key\n', '    /// @param addr Destination address. 0 means to delete the registration information\n', '    function registerAddress(string memory key, address addr) external;\n', '\n', '    /// @dev Get registered address\n', '    /// @param key The key\n', '    /// @return Destination address. 0 means empty\n', '    function checkAddress(string memory key) external view returns (address);\n', '}\n', '\n', '// File: contracts\\interface\\INestGovernance.sol\n', '\n', '/// @dev This interface defines the governance methods\n', 'interface INestGovernance is INestMapping {\n', '\n', '    /// @dev Set governance authority\n', '    /// @param addr Destination address\n', '    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \n', '    ///        implemented in the current system, only the difference between authorized and unauthorized. \n', '    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\n', '    function setGovernance(address addr, uint flag) external;\n', '\n', '    /// @dev Get governance rights\n', '    /// @param addr Destination address\n', '    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \n', '    ///        implemented in the current system, only the difference between authorized and unauthorized. \n', '    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\n', '    function getGovernance(address addr) external view returns (uint);\n', '\n', '    /// @dev Check whether the target address has governance rights for the given target\n', '    /// @param addr Destination address\n', '    /// @param flag Permission weight. The permission of the target address must be greater than this weight to pass the check\n', '    /// @return True indicates permission\n', '    function checkGovernance(address addr, uint flag) external view returns (bool);\n', '}\n', '\n', '// File: contracts\\interface\\IProxyAdmin.sol\n', '\n', '/// @dev This interface defines the ProxyAdmin methods\n', 'interface IProxyAdmin {\n', '\n', '    /// @dev Upgrades a proxy to the newest implementation of a contract\n', '    /// @param proxy Proxy to be upgraded\n', '    /// @param implementation the address of the Implementation\n', '    function upgrade(address proxy, address implementation) external;\n', '\n', '    /// @dev Transfers ownership of the contract to a new account (`newOwner`)\n', '    ///      Can only be called by the current owner\n', '    /// @param newOwner The address of new owner\n', '    function transferOwnership(address newOwner) external;\n', '}\n', '\n', '// File: contracts\\lib\\TransferHelper.sol\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// File: contracts\\interface\\INestLedger.sol\n', '\n', '/// @dev This interface defines the nest ledger methods\n', 'interface INestLedger {\n', '\n', '    /// @dev Application Flag Changed event\n', '    /// @param addr DAO application contract address\n', '    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    event ApplicationChanged(address addr, uint flag);\n', '    \n', '    /// @dev Configuration structure of nest ledger contract\n', '    struct Config {\n', '        \n', '        // nest reward scale(10000 based). 2000\n', '        uint16 nestRewardScale;\n', '\n', '        // // ntoken reward scale(10000 based). 8000\n', '        // uint16 ntokenRewardScale;\n', '    }\n', '    \n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config memory config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Set DAO application\n', '    /// @param addr DAO application contract address\n', '    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    function setApplication(address addr, uint flag) external;\n', '\n', '    /// @dev Check DAO application flag\n', '    /// @param addr DAO application contract address\n', '    /// @return Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    function checkApplication(address addr) external view returns (uint);\n', '\n', '    /// @dev Carve reward\n', '    /// @param ntokenAddress Destination ntoken address\n', '    function carveETHReward(address ntokenAddress) external payable;\n', '\n', '    /// @dev Add reward\n', '    /// @param ntokenAddress Destination ntoken address\n', '    function addETHReward(address ntokenAddress) external payable;\n', '\n', '    /// @dev The function returns eth rewards of specified ntoken\n', '    /// @param ntokenAddress The ntoken address\n', '    function totalETHRewards(address ntokenAddress) external view returns (uint);\n', '\n', '    /// @dev Pay\n', '    /// @param ntokenAddress Destination ntoken address. Indicates which ntoken to pay with\n', '    /// @param tokenAddress Token address of receiving funds (0 means ETH)\n', '    /// @param to Address to receive\n', '    /// @param value Amount to receive\n', '    function pay(address ntokenAddress, address tokenAddress, address to, uint value) external;\n', '\n', '    /// @dev Settlement\n', '    /// @param ntokenAddress Destination ntoken address. Indicates which ntoken to settle with\n', '    /// @param tokenAddress Token address of receiving funds (0 means ETH)\n', '    /// @param to Address to receive\n', '    /// @param value Amount to receive\n', '    function settle(address ntokenAddress, address tokenAddress, address to, uint value) external payable;\n', '}\n', '\n', '// File: contracts\\NestBase.sol\n', '\n', '/// @dev Base contract of nest\n', 'contract NestBase {\n', '\n', '    // Address of nest token contract\n', '    address constant NEST_TOKEN_ADDRESS = 0x04abEdA201850aC0124161F037Efd70c74ddC74C;\n', '\n', '    // Genesis block number of nest\n', '    // NEST token contract is created at block height 6913517. However, because the mining algorithm of nest1.0\n', '    // is different from that at present, a new mining algorithm is adopted from nest2.0. The new algorithm\n', '    // includes the attenuation logic according to the block. Therefore, it is necessary to trace the block\n', '    // where the nest begins to decay. According to the circulation when nest2.0 is online, the new mining\n', '    // algorithm is used to deduce and convert the nest, and the new algorithm is used to mine the nest2.0\n', '    // on-line flow, the actual block is 5120000\n', '    uint constant NEST_GENESIS_BLOCK = 5120000;\n', '\n', '    /// @dev To support open-zeppelin/upgrades\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function initialize(address nestGovernanceAddress) virtual public {\n', "        require(_governance == address(0), 'NEST:!initialize');\n", '        _governance = nestGovernanceAddress;\n', '    }\n', '\n', '    /// @dev INestGovernance implementation contract address\n', '    address public _governance;\n', '\n', '    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \n', '    ///      super.update(nestGovernanceAddress) when overriding, and override method without onlyGovernance\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function update(address nestGovernanceAddress) virtual public {\n', '\n', '        address governance = _governance;\n', '        require(governance == msg.sender || INestGovernance(governance).checkGovernance(msg.sender, 0), "NEST:!gov");\n', '        _governance = nestGovernanceAddress;\n', '    }\n', '\n', '    /// @dev Migrate funds from current contract to NestLedger\n', '    /// @param tokenAddress Destination token address.(0 means eth)\n', '    /// @param value Migrate amount\n', '    function migrate(address tokenAddress, uint value) external onlyGovernance {\n', '\n', '        address to = INestGovernance(_governance).getNestLedgerAddress();\n', '        if (tokenAddress == address(0)) {\n', '            INestLedger(to).addETHReward { value: value } (address(0));\n', '        } else {\n', '            TransferHelper.safeTransfer(tokenAddress, to, value);\n', '        }\n', '    }\n', '\n', '    //---------modifier------------\n', '\n', '    modifier onlyGovernance() {\n', '        require(INestGovernance(_governance).checkGovernance(msg.sender, 0), "NEST:!gov");\n', '        _;\n', '    }\n', '\n', '    modifier noContract() {\n', '        require(msg.sender == tx.origin, "NEST:!contract");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts\\NestVote.sol\n', '\n', '/// @dev nest voting contract, implemented the voting logic\n', 'contract NestVote is NestBase, INestVote {\n', '    \n', '    // constructor() { }\n', '\n', '    /// @dev Structure is used to represent a storage location. Storage variable can be used to avoid indexing from mapping many times\n', '    struct UINT {\n', '        uint value;\n', '    }\n', '\n', '    /// @dev Proposal information\n', '    struct Proposal {\n', '\n', '        // The immutable field and the variable field are stored separately\n', '        /* ========== Immutable field ========== */\n', '\n', '        // Brief of this proposal\n', '        string brief;\n', '\n', '        // The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '        address contractAddress;\n', '\n', '        // Voting start time\n', '        uint48 startTime;\n', '\n', '        // Voting stop time\n', '        uint48 stopTime;\n', '\n', '        // Proposer\n', '        address proposer;\n', '\n', '        // Staked nest amount\n', '        uint96 staked;\n', '\n', '        /* ========== Mutable field ========== */\n', '\n', '        // Gained value\n', '        // The maximum value of uint96 can be expressed as 79228162514264337593543950335, which is more than the total \n', '        // number of nest 10000000000 ether. Therefore, uint96 can be used to express the total number of votes\n', '        uint96 gainValue;\n', '\n', '        // The state of this proposal. 0: proposed | 1: accepted | 2: cancelled\n', '        uint32 state;\n', '\n', '        // The executor of this proposal\n', '        address executor;\n', '\n', '        // The execution time (if any, such as block number or time stamp) is placed in the contract and is limited by the contract itself\n', '    }\n', '    \n', '    // Configuration\n', '    Config _config;\n', '\n', '    // Array for proposals\n', '    Proposal[] public _proposalList;\n', '\n', '    // Staked ledger\n', '    mapping(uint =>mapping(address =>UINT)) public _stakedLedger;\n', '    \n', '    address _nestLedgerAddress;\n', '    //address _nestTokenAddress;\n', '    address _nestMiningAddress;\n', '    address _nnIncomeAddress;\n', '\n', '    uint32 constant PROPOSAL_STATE_PROPOSED = 0;\n', '    uint32 constant PROPOSAL_STATE_ACCEPTED = 1;\n', '    uint32 constant PROPOSAL_STATE_CANCELLED = 2;\n', '\n', '    uint constant NEST_TOTAL_SUPPLY = 10000000000 ether;\n', '\n', '    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \n', '    ///      super.update(nestGovernanceAddress) when overriding, and override method without onlyGovernance\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function update(address nestGovernanceAddress) override public {\n', '        super.update(nestGovernanceAddress);\n', '\n', '        (\n', '            //address nestTokenAddress\n', '            ,//_nestTokenAddress, \n', '            //address nestNodeAddress\n', '            ,\n', '            //address nestLedgerAddress\n', '            _nestLedgerAddress, \n', '            //address nestMiningAddress\n', '            _nestMiningAddress, \n', '            //address ntokenMiningAddress\n', '            ,\n', '            //address nestPriceFacadeAddress\n', '            ,\n', '            //address nestVoteAddress\n', '            ,\n', '            //address nestQueryAddress\n', '            ,\n', '            //address nnIncomeAddress\n', '            _nnIncomeAddress, \n', '            //address nTokenControllerAddress\n', '              \n', '        ) = INestGovernance(nestGovernanceAddress).getBuiltinAddress();\n', '    }\n', '\n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config memory config) override external onlyGovernance {\n', '        require(uint(config.acceptance) <= 10000, "NestVote:!value");\n', '        _config = config;\n', '    }\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() override external view returns (Config memory) {\n', '        return _config;\n', '    }\n', '\n', '    /* ========== VOTE ========== */\n', '    \n', '    /// @dev Initiate a voting proposal\n', '    /// @param contractAddress The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '    /// @param brief Brief of this propose\n', '    function propose(address contractAddress, string memory brief) override external noContract\n', '    {\n', '        // The target address cannot already have governance permission to prevent the governance permission from being covered\n', '        require(!INestGovernance(_governance).checkGovernance(contractAddress, 0), "NestVote:!governance");\n', '     \n', '        Config memory config = _config;\n', '        uint index = _proposalList.length;\n', '\n', '        // Create voting structure\n', '        _proposalList.push(Proposal(\n', '        \n', '            // Brief of this propose\n', '            //string brief;\n', '            brief,\n', '\n', '            // The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '            //address contractAddress;\n', '            contractAddress,\n', '\n', '            // Voting start time\n', '            //uint48 startTime;\n', '            uint48(block.timestamp),\n', '\n', '            // Voting stop time\n', '            //uint48 stopTime;\n', '            uint48(block.timestamp + uint(config.voteDuration)),\n', '\n', '            // Proposer\n', '            //address proposer;\n', '            msg.sender,\n', '\n', '            config.proposalStaking,\n', '\n', '            uint96(0), \n', '            \n', '            PROPOSAL_STATE_PROPOSED, \n', '\n', '            address(0)\n', '        ));\n', '\n', '        // Stake nest\n', '        IERC20(NEST_TOKEN_ADDRESS).transferFrom(msg.sender, address(this), uint(config.proposalStaking));\n', '\n', '        emit NIPSubmitted(msg.sender, contractAddress, index);\n', '    }\n', '\n', '    /// @dev vote\n', '    /// @param index Index of proposal\n', '    /// @param value Amount of nest to vote\n', '    function vote(uint index, uint value) override external noContract\n', '    {\n', '        // 1. Load the proposal\n', '        Proposal memory p = _proposalList[index];\n', '\n', '        // 2. Check\n', '        // Check time region\n', '        // Note: stop time is not include stopTime\n', '        require(block.timestamp >= uint(p.startTime) && block.timestamp < uint(p.stopTime), "NestVote:!time");\n', '        require(p.state == PROPOSAL_STATE_PROPOSED, "NestVote:!state");\n', '\n', '        // 3. Update voting ledger\n', '        UINT storage balance = _stakedLedger[index][msg.sender];\n', '        balance.value += value;\n', '\n', '        // 4. Update voting information\n', '        _proposalList[index].gainValue = uint96(uint(p.gainValue) + value);\n', '\n', '        // 5. Stake nest\n', '        IERC20(NEST_TOKEN_ADDRESS).transferFrom(msg.sender, address(this), value);\n', '\n', '        emit NIPVote(msg.sender, index, value);\n', '    }\n', '\n', '    /// @dev Withdraw the nest of the vote. If the target vote is in the voting state, the corresponding number of votes will be cancelled\n', '    /// @param index Index of the proposal\n', '    function withdraw(uint index) override external noContract\n', '    {\n', '        // 1. Update voting ledger\n', '        UINT storage balance = _stakedLedger[index][msg.sender];\n', '        uint balanceValue = balance.value;\n', '        balance.value = 0;\n', '\n', '        // 2. In the proposal state, the number of votes obtained needs to be updated\n', '        if (_proposalList[index].state == PROPOSAL_STATE_PROPOSED) {\n', '            _proposalList[index].gainValue = uint96(uint(_proposalList[index].gainValue) - balanceValue);\n', '        }\n', '\n', '        // 3. Return staked nest\n', '        IERC20(NEST_TOKEN_ADDRESS).transfer(msg.sender, balanceValue);\n', '    }\n', '\n', '    /// @dev Execute the proposal\n', '    /// @param index Index of the proposal\n', '    function execute(uint index) override external noContract\n', '    {\n', '        Config memory config = _config;\n', '\n', '        // 1. Load proposal\n', '        Proposal memory p = _proposalList[index];\n', '\n', '        // 2. Check status\n', '        require(p.state == PROPOSAL_STATE_PROPOSED, "NestVote:!state");\n', '        require(block.timestamp < uint(p.stopTime), "NestVote:!time");\n', '        // The target address cannot already have governance permission to prevent the governance permission from being covered\n', '        address governance = _governance;\n', '        require(!INestGovernance(governance).checkGovernance(p.contractAddress, 0), "NestVote:!governance");\n', '\n', '        // 3. Check the gaine rate\n', '        IERC20 nest = IERC20(NEST_TOKEN_ADDRESS);\n', '\n', '        // Calculate the circulation of nest\n', '        uint nestCirculation = _getNestCirculation(nest);\n', '        require(uint(p.gainValue) * 10000 >= nestCirculation * uint(config.acceptance), "NestVote:!gainValue");\n', '\n', '        // 3. Temporarily grant execution permission\n', '        INestGovernance(governance).setGovernance(p.contractAddress, 1);\n', '\n', '        // 4. Execute\n', '        _proposalList[index].state = PROPOSAL_STATE_ACCEPTED;\n', '        _proposalList[index].executor = msg.sender;\n', '        IVotePropose(p.contractAddress).run();\n', '\n', '        // 5. Delete execution permission\n', '        INestGovernance(governance).setGovernance(p.contractAddress, 0);\n', '        \n', '        // Return nest\n', '        nest.transfer(p.proposer, uint(p.staked));\n', '\n', '        emit NIPExecute(msg.sender, index);\n', '    }\n', '\n', '    /// @dev Cancel the proposal\n', '    /// @param index Index of the proposal\n', '    function cancel(uint index) override external noContract {\n', '\n', '        // 1. Load proposal\n', '        Proposal memory p = _proposalList[index];\n', '\n', '        // 2. Check state\n', '        require(p.state == PROPOSAL_STATE_PROPOSED, "NestVote:!state");\n', '        require(block.timestamp >= uint(p.stopTime), "NestVote:!time");\n', '\n', '        // 3. Update status\n', '        _proposalList[index].state = PROPOSAL_STATE_CANCELLED;\n', '\n', '        // 4. Return staked nest\n', '        IERC20(NEST_TOKEN_ADDRESS).transfer(p.proposer, uint(p.staked));\n', '    }\n', '\n', '    // Convert PriceSheet to PriceSheetView\n', '    //function _toPriceSheetView(PriceSheet memory sheet, uint index) private view returns (PriceSheetView memory) {\n', '    function _toProposalView(Proposal memory proposal, uint index, uint nestCirculation) private pure returns (ProposalView memory) {\n', '\n', '        return ProposalView(\n', '            // Index of the proposal\n', '            index,\n', '            // Brief of proposal\n', '            //string brief;\n', '            proposal.brief,\n', '            // The contract address which will be executed when the proposal is approved. (Must implemented IVotePropose)\n', '            //address contractAddress;\n', '            proposal.contractAddress,\n', '            // Voting start time\n', '            //uint48 startTime;\n', '            proposal.startTime,\n', '            // Voting stop time\n', '            //uint48 stopTime;\n', '            proposal.stopTime,\n', '            // Proposer\n', '            //address proposer;\n', '            proposal.proposer,\n', '            // Staked nest amount\n', '            //uint96 staked;\n', '            proposal.staked,\n', '            // Gained value\n', '            // The maximum value of uint96 can be expressed as 79228162514264337593543950335, which is more than the total \n', '            // number of nest 10000000000 ether. Therefore, uint96 can be used to express the total number of votes\n', '            //uint96 gainValue;\n', '            proposal.gainValue,\n', '            // The state of this proposal\n', '            //uint32 state;  // 0: proposed | 1: accepted | 2: cancelled\n', '            proposal.state,\n', '            // The executor of this proposal\n', '            //address executor;\n', '            proposal.executor,\n', '\n', '            // Circulation of nest\n', '            uint96(nestCirculation)\n', '        );\n', '    }\n', '\n', '    /// @dev Get proposal information\n', '    /// @param index Index of the proposal\n', '    /// @return Proposal information\n', '    function getProposeInfo(uint index) override external view returns (ProposalView memory) {\n', '        return _toProposalView(_proposalList[index], index, getNestCirculation());\n', '    }\n', '\n', '    /// @dev Get the cumulative number of voting proposals\n', '    /// @return The cumulative number of voting proposals\n', '    function getProposeCount() override external view returns (uint) {\n', '        return _proposalList.length;\n', '    }\n', '\n', '    /// @dev List proposals by page\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return List of price proposals\n', '    function list(uint offset, uint count, uint order) override external view returns (ProposalView[] memory) {\n', '        \n', '        Proposal[] storage proposalList = _proposalList;\n', '        ProposalView[] memory result = new ProposalView[](count);\n', '        uint nestCirculation = getNestCirculation();\n', '        uint length = proposalList.length;\n', '        uint i = 0;\n', '\n', '        // Reverse order\n', '        if (order == 0) {\n', '\n', '            uint index = length - offset;\n', '            uint end = index > count ? index - count : 0;\n', '            while (index > end) {\n', '                --index;\n', '                result[i++] = _toProposalView(proposalList[index], index, nestCirculation);\n', '            }\n', '        } \n', '        // Positive sequence\n', '        else {\n', '            \n', '            uint index = offset;\n', '            uint end = index + count;\n', '            if (end > length) {\n', '                end = length;\n', '            }\n', '            while (index < end) {\n', '                result[i++] = _toProposalView(proposalList[index], index, nestCirculation);\n', '                ++index;\n', '            }\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    // Get Circulation of nest\n', '    function _getNestCirculation(IERC20 nest) private view returns (uint) {\n', '\n', '        return NEST_TOTAL_SUPPLY \n', '            - nest.balanceOf(_nestMiningAddress)\n', '            - nest.balanceOf(_nnIncomeAddress)\n', '            - nest.balanceOf(_nestLedgerAddress)\n', '            - nest.balanceOf(address(0x1));\n', '    }\n', '\n', '    /// @dev Get Circulation of nest\n', '    /// @return Circulation of nest\n', '    function getNestCirculation() override public view returns (uint) {\n', '        return _getNestCirculation(IERC20(NEST_TOKEN_ADDRESS));\n', '    }\n', '\n', '    /// @dev Upgrades a proxy to the newest implementation of a contract\n', '    /// @param proxyAdmin The address of ProxyAdmin\n', '    /// @param proxy Proxy to be upgraded\n', '    /// @param implementation the address of the Implementation\n', '    function upgradeProxy(address proxyAdmin, address proxy, address implementation) override external onlyGovernance {\n', '        IProxyAdmin(proxyAdmin).upgrade(proxy, implementation);\n', '    }\n', '\n', '    /// @dev Transfers ownership of the contract to a new account (`newOwner`)\n', '    ///      Can only be called by the current owner\n', '    /// @param proxyAdmin The address of ProxyAdmin\n', '    /// @param newOwner The address of new owner\n', '    function transferUpgradeAuthority(address proxyAdmin, address newOwner) override external onlyGovernance {\n', '        IProxyAdmin(proxyAdmin).transferOwnership(newOwner);\n', '    }\n', '}']