['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IWhitelist {\n', '    event Whitelisted(bytes4 indexed key);\n', '\n', '    function addBytes4(bytes4 key) external;\n', '    function addManyBytes4(bytes4[] memory keys) external;\n', '    function isBytesWhitelisted(bytes memory subdomain) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Implements an owner-managed bytes4 whitelist and sets rules for valid aggregate `bytes`.\n', ' * A valid `bytes` combination is any combination of sequentially whitelisted `bytes4` from front to back.\n', ' */\n', 'contract EmojiWhitelist is Ownable, IWhitelist {\n', '    mapping (bytes4 => bool) whitelist;\n', '\n', '    function addBytes4(bytes4 key) public override onlyOwner {\n', '      addBytes4Internal(key);\n', '    }\n', '\n', '    function addManyBytes4(bytes4[] memory keys) public override onlyOwner {\n', '      for (uint i = 0; i < keys.length; i++) {\n', '        addBytes4Internal(keys[i]);\n', '      }\n', '    }\n', '\n', '    function isBytesWhitelisted(bytes memory subdomain) public override view returns (bool) {\n', '      for(uint i = 0; i < subdomain.length; i += 4) {\n', '        if(!whitelist[(toBytes4(slice(subdomain, i, 4)))]) {\n', '          return false;\n', '        }\n', '      }\n', '      return true;\n', '    }\n', '\n', '    // INTERNAL FUNCTIONS\n', '\n', '    function addBytes4Internal(bytes4 key) internal {\n', '      whitelist[key] = true;\n', '      emit Whitelisted(key);\n', '    }\n', '\n', '    function toBytes4(bytes memory _b) internal pure returns (bytes4 result) {\n', '      // solium-disable-next-line security/no-inline-assembly\n', '      assembly {\n', '        result := mload(add(_b, 32))\n', '      }\n', '    }\n', '\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint256 _start,\n', '        uint256 _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_length + 31 >= _length, "slice_overflow");\n', '        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n', '\n', '        bytes memory tempBytes;\n', '\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                // update free-memory pointer\n', '                // allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            // if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '                // zero out the 32 bytes slice we are about to return\n', '                // we need to do it because Solidity does not garbage collect\n', '                mstore(tempBytes, 0)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '}']