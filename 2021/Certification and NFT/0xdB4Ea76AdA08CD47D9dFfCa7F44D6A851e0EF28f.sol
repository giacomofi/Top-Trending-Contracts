['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.3;\n', '\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '\n', 'contract Governance is ReentrancyGuard {\n', '\n', '\tuint constant public governance_challenging_period = 10 days;\n', '\tuint constant public governance_freeze_period = 30 days;\n', '\n', '\taddress public votingTokenAddress;\n', '\taddress public governedContractAddress;\n', '\n', '\tmapping(address => uint) public balances;\n', '\n', '\tVotedValue[] public votedValues;\n', '\tmapping(string => VotedValue) public votedValuesMap;\n', '\n', '\n', '\tconstructor(address _governedContractAddress, address _votingTokenAddress){\n', '\t\tinit(_governedContractAddress, _votingTokenAddress);\n', '\t}\n', '\n', '\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\n', '\t\trequire(governedContractAddress == address(0), "governance already initialized");\n', '\t\tgovernedContractAddress = _governedContractAddress;\n', '\t\tvotingTokenAddress = _votingTokenAddress;\n', '\t}\n', '\n', '\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (address(votedValues[i]) == addr)\n', '\t\t\t\treturn true;\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (votedValues[i].hasVote(addr))\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\n', '\t\trequire(msg.sender == governedContractAddress, "not authorized");\n', '\t\tvotedValues.push(votedValue);\n', '\t\tvotedValuesMap[name] = votedValue;\n', '\t}\n', '\n', '\n', '\t// deposit\n', '\n', '\tfunction deposit(uint amount) payable external {\n', '\t\tdeposit(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction deposit(address from, uint amount) nonReentrant payable public {\n', '\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), "not allowed");\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\trequire(msg.value == amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), "failed to pull gov deposit");\n', '\t\t}\n', '\t\tbalances[from] += amount;\n', '\t}\n', '\n', '\n', '\t// withdrawal functions\n', '\n', '\tfunction withdraw() external {\n', '\t\twithdraw(balances[msg.sender]);\n', '\t}\n', '\n', '\tfunction withdraw(uint amount) nonReentrant public {\n', '\t\trequire(amount > 0, "zero withdrawal requested");\n', '\t\trequire(amount <= balances[msg.sender], "not enough balance");\n', '\t\trequire(isUntiedFromAllVotes(msg.sender), "some votes not removed yet");\n', '\t\tbalances[msg.sender] -= amount;\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\tpayable(msg.sender).transfer(amount);\n', '\t\telse\n', '\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), "failed to withdraw gov deposit");\n', '\t}\n', '}\n', '\n', '\n', 'abstract contract VotedValue is ReentrancyGuard {\n', '\tGovernance public governance;\n', '\tuint public challenging_period_start_ts;\n', '\tmapping(address => bool) public hasVote;\n', '\n', '\tconstructor(Governance _governance){\n', '\t\tgovernance = _governance;\n', '\t}\n', '\n', '\tfunction checkVoteChangeLock() view public {\n', '\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, "you cannot change your vote yet");\n', '\t}\n', '\n', '\tfunction checkChallengingPeriodExpiry() view public {\n', '\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), "challenging period not expired yet");\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueUint is VotedValue {\n', '\n', '\tfunction(uint) external validationCallback;\n', '\tfunction(uint) external commitCallback;\n', '\n', '\tuint public leader;\n', '\tuint public current_value;\n', '\n', '\tmapping(address => uint) public choices;\n', '\tmapping(uint => uint) public votesByValue;\n', '\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(uint value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueUintArray is VotedValue {\n', '\n', '\tfunction(uint[] memory) external validationCallback;\n', '\tfunction(uint[] memory) external commitCallback;\n', '\n', '\tuint[] public leader;\n', '\tuint[] public current_value;\n', '\n', '\tmapping(address => uint[]) public choices;\n', '\tmapping(bytes32 => uint) public votesByValue;\n', '\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\n', '\t\tif (a1.length != a2.length)\n', '\t\t\treturn false;\n', '\t\tfor (uint i = 0; i < a1.length; i++)\n', '\t\t\tif (a1[i] != a2[i])\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getKey(uint[] memory a) public pure returns (bytes32){\n', '\t\treturn keccak256(abi.encodePacked(a));\n', '\t}\n', '\n', '\tfunction vote(uint[] memory value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint[] memory value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\n', "\t\t// remove one's vote from the previous choice first\n", '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add it to the new choice, if any\n', '\t\tbytes32 key = getKey(value);\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[key] += balance;\n', '\t\tvotesByValueAddress[key][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint[] memory value) internal {\n', '\t\tbytes32 key = getKey(value);\n', '\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\n', '\t\tvotesByValueAddress[key][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(!equal(leader, current_value), "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueAddress is VotedValue {\n', '\n', '\tfunction(address) external validationCallback;\n', '\tfunction(address) external commitCallback;\n', '\n', '\taddress public leader;\n', '\taddress public current_value;\n', '\n', '\t// mapping(who => value)\n', '\tmapping(address => address) public choices;\n', '\n', '\t// mapping(value => votes)\n', '\tmapping(address => uint) public votesByValue;\n', '\n', '\t// mapping(value => mapping(who => votes))\n', '\tmapping(address => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(address value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(address value) private {\n', '\t\tvalidationCallback(value);\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(address value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueFactory {\n', '\n', '\taddress public votedValueUintMaster;\n', '\taddress public votedValueUintArrayMaster;\n', '\taddress public votedValueAddressMaster;\n', '\n', '\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\n', '\t\tvotedValueUintMaster = _votedValueUintMaster;\n', '\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\n', '\t\tvotedValueAddressMaster = _votedValueAddressMaster;\n', '\t}\n', '\n', '\n', '\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\n', '\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\n', '\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\n', '\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract GovernanceFactory {\n', '\n', '\taddress public governanceMaster;\n', '\n', '\tconstructor(address _governanceMaster) {\n', '\t\tgovernanceMaster = _governanceMaster;\n', '\t}\n', '\n', '\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\n', '\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\n', '\t\tgovernance.init(governedContractAddress, votingTokenAddress);\n', '\t\treturn governance;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\n', '\n', '\n', 'library CounterstakeLibrary {\n', '\n', '\tenum Side {no, yes}\n', '\n', '\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\n', '\tstruct Claim {\n', '\t\tuint amount;\n', '\t//\tint reward;\n', '\n', '\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\n', '\t\tuint32 txts;\n', '\t\tuint32 ts;\n', '\t\t\n', '\t\taddress payable claimant_address;\n', '\t\tuint32 expiry_ts;\n', '\t\tuint16 period_number;\n', '\t\tSide current_outcome;\n', '\t\tbool is_large;\n', '\t\tbool withdrawn;\n', '\t\tbool finished;\n', '\t\t\n', '\t\tstring sender_address;\n', '\t//\tstring txid;\n', '\t\tstring data;\n', '\t\tuint yes_stake;\n', '\t\tuint no_stake;\n', '\t//\tuint challenging_target;\n', '\t}\n', '\n', '\tstruct Settings {\n', '\t\taddress tokenAddress;\n', '\t\tuint16 ratio100;// = 100;\n', '\t\tuint16 counterstake_coef100;// = 150;\n', '\t\tuint32 min_tx_age;\n', '\t\tuint min_stake;\n', '\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\n', '\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\n', '\t\tuint large_threshold;\n', '\t}\n', '\n', '\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\n', '\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\n', '\tevent FinishedClaim(uint indexed claim_num, Side outcome);\n', '\n', '\n', '\tstruct ClaimRequest {\n', '\t\tstring txid;\n', '\t\tuint32 txts;\n', '\t\tuint amount;\n', '\t\tint reward;\n', '\t\tuint stake;\n', '\t\tuint required_stake;\n', '\t\taddress payable recipient_address;\n', '\t\tstring sender_address;\n', '\t\tstring data;\n', '\t}\n', '\n', '\tfunction claim(\n', '\t\tSettings storage settings,\n', '\t\tmapping(string => uint) storage claim_nums,\n', '\t\tmapping(uint => Claim) storage claims,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\n', '\t\tuint claim_num,\n', '\t\tClaimRequest memory req\n', '\t) external {\n', '\t\trequire(req.amount > 0, "0 claim");\n', '\t\trequire(req.stake >= req.required_stake, "the stake is too small");\n', '\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, "too early");\n', '\t\tif (req.recipient_address == address(0))\n', '\t\t\treq.recipient_address = payable(msg.sender);\n', '\t\tif (req.reward < 0)\n', '\t\t\trequire(req.recipient_address == payable(msg.sender), "the sender disallowed third-party claiming by setting a negative reward");\n', '\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\n', '\t\trequire(claim_nums[claim_id] == 0, "this transfer has already been claimed");\n', '\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\n', '\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\n', '\t\tclaim_nums[claim_id] = claim_num;\n', '\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\n', '\t\tclaims[claim_num] = Claim({\n', '\t\t\tamount: req.amount,\n', '\t\t//\treward: req.reward,\n', '\t\t\trecipient_address: req.recipient_address,\n', '\t\t\tclaimant_address: payable(msg.sender),\n', '\t\t\tsender_address: req.sender_address,\n', '\t\t//\ttxid: req.txid,\n', '\t\t\tdata: req.data,\n', '\t\t\tyes_stake: req.stake,\n', '\t\t\tno_stake: 0,\n', '\t\t\tcurrent_outcome: Side.yes,\n', '\t\t\tis_large: is_large,\n', '\t\t\tperiod_number: 0,\n', '\t\t\ttxts: req.txts,\n', '\t\t\tts: uint32(block.timestamp),\n', '\t\t\texpiry_ts: expiry_ts,\n', '\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\n', '\t\t\twithdrawn: false,\n', '\t\t\tfinished: false\n', '\t\t});\n', '\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\n', '\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\n', '\t//\treturn claim_id;\n', '\t}\n', '\n', '\n', '\tfunction challenge(\n', '\t\tSettings storage settings, \n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\tSide stake_on, \n', '\t\tuint stake\n', '\t) external {\n', '\t\trequire(block.timestamp < c.expiry_ts, "the challenging period has expired");\n', '\t\trequire(stake_on != c.current_outcome, "this outcome is already current");\n', '\t\tuint excess;\n', '\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\n', '\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\n', '\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\n', '\t\t\tuint accepted_stake = stake - excess;\n', '\t\t\tif (stake_on == Side.yes)\n', '\t\t\t\tc.yes_stake += accepted_stake;\n', '\t\t\telse\n', '\t\t\t\tc.no_stake += accepted_stake;\n', '\t\t\tif (would_override_current_outcome){\n', '\t\t\t\tc.period_number++;\n', '\t\t\t\tc.current_outcome = stake_on;\n', '\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\n', '\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\n', '\t\t\t}\n', '\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\n', '\t\t}\n', '\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\n', '\t\tif (excess > 0){\n', '\t\t\tif (settings.tokenAddress == address(0))\n', '\t\t\t\tpayable(msg.sender).transfer(excess);\n', '\t\t\telse\n', '\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), "failed to transfer the token");\n', '\t\t}\n', '\t}\n', '\n', '\n', '\n', '\tfunction finish(\n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\taddress payable to_address\n', '\t) external \n', '\treturns (bool, bool, uint)\n', '\t{\n', '\t\trequire(block.timestamp > c.expiry_ts, "challenging period is still ongoing");\n', '\t\tif (to_address == address(0))\n', '\t\t\tto_address = payable(msg.sender);\n', '\t\t\n', '\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\n', '\t\trequire(!(is_winning_claimant && c.withdrawn), "already withdrawn");\n', '\t\tuint won_stake;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\n', '\t\t\trequire(my_stake > 0 || is_winning_claimant, "you are not the recipient and you didn\'t stake on the winning outcome or you have already withdrawn");\n', '\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\n', '\t\t\tif (my_stake > 0)\n', '\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\n', '\t\t}\n', '\t\tif (is_winning_claimant)\n', '\t\t\tc.withdrawn = true;\n', '\t\tbool finished;\n', '\t\tif (!c.finished){\n', '\t\t\tfinished = true;\n', '\t\t\tc.finished = true;\n', '\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\n', "\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\n", '\t\t\temit FinishedClaim(claim_num, c.current_outcome);\n', '\t\t}\n', '\t\tdelete stakes[claim_num][c.current_outcome][to_address];\n', '\t\treturn (finished, is_winning_claimant, won_stake);\n', '\t}\n', '\n', '\n', '\n', '\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\n', '\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\n', '\t\tif (period_number > periods.length - 1)\n', '\t\t\tperiod_number = uint16(periods.length - 1);\n', '\t\treturn periods[period_number];\n', '\t}\n', '\n', '\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\n', '\t\trequire(periods.length > 0, "empty periods");\n', '\t\tuint prev_period = 0;\n', '\t\tfor (uint i = 0; i < periods.length; i++) {\n', '\t\t\trequire(periods[i] < 3 * 365 days, "some periods are longer than 3 years");\n', '\t\t\trequire(periods[i] >= prev_period, "subsequent periods cannot get shorter");\n', '\t\t\tprev_period = periods[i];\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\n', "\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\n", '\t}\n', '\n', '\n', '\tfunction uint2str(uint256 _i) private pure returns (string memory) {\n', '\t\tif (_i == 0)\n', '\t\t\treturn "0";\n', '\t\tuint256 j = _i;\n', '\t\tuint256 length;\n', '\t\twhile (j != 0) {\n', '\t\t\tlength++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(length);\n', '\t\tuint256 k = length;\n', '\t\tj = _i;\n', '\t\twhile (j != 0) {\n', '\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '\n', '\tfunction int2str(int256 _i) private pure returns (string memory) {\n', '\t\trequire(_i < type(int).max, "int too large");\n', "\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\n", '\t}\n', '\n', '\tfunction toAsciiString(address x) private pure returns (string memory) {\n', '\t\tbytes memory s = new bytes(40);\n', '\t\tfor (uint i = 0; i < 20; i++) {\n', '\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n', '\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\n', '\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n', '\t\t\ts[2*i] = char(hi);\n', '\t\t\ts[2*i+1] = char(lo);            \n', '\t\t}\n', '\t\treturn string(s);\n', '\t}\n', '\n', '\tfunction char(bytes1 b) private pure returns (bytes1 c) {\n', '\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n', '\t\telse return bytes1(uint8(b) + 0x57);\n', '\t}\n', '\n', '\tfunction isContract(address _addr) public view returns (bool){\n', '\t\tuint32 size;\n', '\t\tassembly {\n', '\t\t\tsize := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (size > 0);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', 'interface CounterstakeReceiver {\n', '\tfunction onReceivedFromClaim(uint claim_num, uint net_claimed_amount, uint won_stake, string memory sender_address, address claim_recipient_address, string memory data) external;\n', '}\n', '\n', 'abstract contract Counterstake is ReentrancyGuard {\n', '\n', '\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\n', '\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, CounterstakeLibrary.Side outcome, CounterstakeLibrary.Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\n', '\tevent FinishedClaim(uint indexed claim_num, CounterstakeLibrary.Side outcome);\n', '\n', '\tGovernance public governance;\n', '\tCounterstakeLibrary.Settings public settings;\n', '\n', '\n', '\tuint64 public last_claim_num;\n', '\tuint64[] public ongoing_claim_nums;\n', '\tmapping(uint => uint) public num2index;\n', '\n', '\tmapping(string => uint) public claim_nums;\n', '\tmapping(uint => CounterstakeLibrary.Claim) private claims;\n', '\tmapping(uint => mapping(CounterstakeLibrary.Side => mapping(address => uint))) public stakes;\n', '\n', '\tfunction getClaim(uint claim_num) external view returns (CounterstakeLibrary.Claim memory) {\n', '\t\treturn claims[claim_num];\n', '\t}\n', '\n', '\tfunction getClaim(string memory claim_id) external view returns (CounterstakeLibrary.Claim memory) {\n', '\t\treturn claims[claim_nums[claim_id]];\n', '\t}\n', '\n', '\tfunction getOngoingClaimNums() external view returns (uint64[] memory) {\n', '\t\treturn ongoing_claim_nums;\n', '\t}\n', '\n', '\n', '\tconstructor (address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) {\n', '\t\tinitCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods);\n', '\t}\n', '\n', '\tfunction initCounterstake(address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) public {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tsettings = CounterstakeLibrary.Settings({\n', '\t\t\ttokenAddress: _tokenAddr,\n', '\t\t\tcounterstake_coef100: _counterstake_coef100 > 100 ? _counterstake_coef100 : 150,\n', '\t\t\tratio100: _ratio100 > 0 ? _ratio100 : 100,\n', '\t\t\tmin_stake: 0,\n', '\t\t\tmin_tx_age: 0,\n', '\t\t\tchallenging_periods: _challenging_periods,\n', '\t\t\tlarge_challenging_periods: _large_challenging_periods,\n', '\t\t\tlarge_threshold: _large_threshold\n', '\t\t});\n', '\t}\n', '\n', '\t/*\n', '\tmodifier onlyETH(){\n', '\t\trequire(settings.tokenAddress == address(0), "ETH only");\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyERC20(){\n', '\t\trequire(settings.tokenAddress != address(0), "ERC20 only");\n', '\t\t_;\n', '\t}*/\n', '\n', '\tmodifier onlyVotedValueContract(){\n', '\t\trequire(governance.addressBelongsToGovernance(msg.sender), "not from voted value contract");\n', '\t\t_;\n', '\t}\n', '\n', '\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\n', '\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) virtual public {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = governanceFactory.createGovernance(address(this), settings.tokenAddress);\n', '\n', '\t\tgovernance.addVotedValue("ratio100", votedValueFactory.createVotedValueUint(governance, settings.ratio100, this.validateRatio, this.setRatio));\n', '\t\tgovernance.addVotedValue("counterstake_coef100", votedValueFactory.createVotedValueUint(governance, settings.counterstake_coef100, this.validateCounterstakeCoef, this.setCounterstakeCoef));\n', '\t\tgovernance.addVotedValue("min_stake", votedValueFactory.createVotedValueUint(governance, settings.min_stake, this.validateMinStake, this.setMinStake));\n', '\t\tgovernance.addVotedValue("min_tx_age", votedValueFactory.createVotedValueUint(governance, settings.min_tx_age, this.validateMinTxAge, this.setMinTxAge));\n', '\t\tgovernance.addVotedValue("large_threshold", votedValueFactory.createVotedValueUint(governance, settings.large_threshold, this.validateLargeThreshold, this.setLargeThreshold));\n', '\t\tgovernance.addVotedValue("challenging_periods", votedValueFactory.createVotedValueUintArray(governance, settings.challenging_periods, this.validateChallengingPeriods, this.setChallengingPeriods));\n', '\t\tgovernance.addVotedValue("large_challenging_periods", votedValueFactory.createVotedValueUintArray(governance, settings.large_challenging_periods, this.validateChallengingPeriods, this.setLargeChallengingPeriods));\n', '\t}\n', '\n', '\tfunction validateRatio(uint _ratio100) pure external {\n', '\t\trequire(_ratio100 > 0 && _ratio100 < 64000, "bad ratio");\n', '\t}\n', '\n', '\tfunction setRatio(uint _ratio100) onlyVotedValueContract external {\n', '\t\tsettings.ratio100 = uint16(_ratio100);\n', '\t}\n', '\n', '\t\n', '\tfunction validateCounterstakeCoef(uint _counterstake_coef100) pure external {\n', '\t\trequire(_counterstake_coef100 > 100 && _counterstake_coef100 < 64000, "bad counterstake coef");\n', '\t}\n', '\n', '\tfunction setCounterstakeCoef(uint _counterstake_coef100) onlyVotedValueContract external {\n', '\t\tsettings.counterstake_coef100 = uint16(_counterstake_coef100);\n', '\t}\n', '\n', '\t\n', '\tfunction validateMinStake(uint _min_stake) pure external {\n', '\t\t// anything goes\n', '\t}\n', '\n', '\tfunction setMinStake(uint _min_stake) onlyVotedValueContract external {\n', '\t\tsettings.min_stake = _min_stake;\n', '\t}\n', '\n', '\n', '\tfunction validateMinTxAge(uint _min_tx_age) pure external {\n', '\t\trequire(_min_tx_age < 4 weeks, "min tx age too large");\n', '\t}\n', '\n', '\tfunction setMinTxAge(uint _min_tx_age) onlyVotedValueContract external {\n', '\t\tsettings.min_tx_age = uint32(_min_tx_age);\n', '\t}\n', '\n', '\n', '\tfunction validateLargeThreshold(uint _large_threshold) pure external {\n', '\t\t// anything goes\n', '\t}\n', '\n', '\tfunction setLargeThreshold(uint _large_threshold) onlyVotedValueContract external {\n', '\t\tsettings.large_threshold = _large_threshold;\n', '\t}\n', '\n', '\n', '\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\n', '\t\tCounterstakeLibrary.validateChallengingPeriods(periods);\n', '\t}\n', '\n', '\tfunction setChallengingPeriods(uint[] memory _challenging_periods) onlyVotedValueContract external {\n', '\t\tsettings.challenging_periods = _challenging_periods;\n', '\t}\n', '\n', '\tfunction setLargeChallengingPeriods(uint[] memory _large_challenging_periods) onlyVotedValueContract external {\n', '\t\tsettings.large_challenging_periods = _large_challenging_periods;\n', '\t}\n', '\n', '\n', '\tfunction getChallengingPeriod(uint16 period_number, bool bLarge) external view returns (uint) {\n', '\t\treturn CounterstakeLibrary.getChallengingPeriod(settings, period_number, bLarge);\n', '\t}\n', '\n', '\tfunction getRequiredStake(uint amount) public view virtual returns (uint);\n', '\n', '\tfunction getMissingStake(uint claim_num, CounterstakeLibrary.Side stake_on) external view returns (uint) {\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.yes_stake > 0, "no such claim");\n', '\t\tuint current_stake = (stake_on == CounterstakeLibrary.Side.yes) ? c.yes_stake : c.no_stake;\n', '\t\treturn (c.current_outcome == CounterstakeLibrary.Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100 - current_stake;\n', '\t}\n', '\n', '\n', '\n', '\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, uint stake, string memory sender_address, address payable recipient_address, string memory data) nonReentrant payable external {\n', '\t\tif (recipient_address == address(0))\n', '\t\t\trecipient_address = payable(msg.sender);\n', '\t\tbool bThirdPartyClaiming = (recipient_address != payable(msg.sender) && reward >= 0);\n', '\t\tuint paid_amount;\n', '\t\tif (bThirdPartyClaiming) {\n', '\t\t\trequire(amount > uint(reward), "reward too large");\n', '\t\t\tpaid_amount = amount - uint(reward);\n', '\t\t}\n', '\t\treceiveMoneyInClaim(stake, paid_amount);\n', '\t\tuint required_stake = getRequiredStake(amount);\n', '\t\tCounterstakeLibrary.ClaimRequest memory req = CounterstakeLibrary.ClaimRequest({\n', '\t\t\ttxid: txid,\n', '\t\t\ttxts: txts,\n', '\t\t\tamount: amount,\n', '\t\t\treward: reward,\n', '\t\t\tstake: stake,\n', '\t\t\trequired_stake: required_stake,\n', '\t\t\trecipient_address: recipient_address,\n', '\t\t\tsender_address: sender_address,\n', '\t\t\tdata: data\n', '\t\t});\n', '\t\tlast_claim_num++;\n', '\t\tongoing_claim_nums.push(last_claim_num);\n', '\t\tnum2index[last_claim_num] = ongoing_claim_nums.length - 1;\n', '\n', '\t\tCounterstakeLibrary.claim(settings, claim_nums, claims, stakes, last_claim_num, req);\n', '\t\t\n', '\t\tif (bThirdPartyClaiming){\n', '\t\t\tsendToClaimRecipient(recipient_address, paid_amount);\n', '\t\t\tnotifyPaymentRecipient(recipient_address, paid_amount, 0, last_claim_num);\n', '\t\t}\n', '\t}\n', '\t\n', '\n', '\tfunction challenge(string calldata claim_id, CounterstakeLibrary.Side stake_on, uint stake) payable external {\n', '\t\tchallenge(claim_nums[claim_id], stake_on, stake);\n', '\t}\n', '\n', '\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) nonReentrant payable public {\n', '\t\treceiveStakeAsset(stake);\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.amount > 0, "no such claim");\n', '\t\tCounterstakeLibrary.challenge(settings, c, stakes, claim_num, stake_on, stake);\n', '\t}\n', '\n', '\tfunction withdraw(string memory claim_id) external {\n', '\t\twithdraw(claim_nums[claim_id], payable(0));\n', '\t}\n', '\n', '\tfunction withdraw(uint claim_num) external {\n', '\t\twithdraw(claim_num, payable(0));\n', '\t}\n', '\n', '\tfunction withdraw(string memory claim_id, address payable to_address) external {\n', '\t\twithdraw(claim_nums[claim_id], to_address);\n', '\t}\n', '\n', '\tfunction withdraw(uint claim_num, address payable to_address) nonReentrant public {\n', '\t\tif (to_address == address(0))\n', '\t\t\tto_address = payable(msg.sender);\n', '\t\trequire(claim_num > 0, "no such claim num");\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.amount > 0, "no such claim");\n', '\n', '\t\t(bool finished, bool is_winning_claimant, uint won_stake) = CounterstakeLibrary.finish(c, stakes, claim_num, to_address);\n', '\t\t\n', '\t\tif (finished){\n', '\t\t\tuint index = num2index[claim_num];\n', '\t\t\tuint last_index = ongoing_claim_nums.length - 1;\n', '\t\t\tif (index != last_index){ // move the last element in place of our removed element\n', '\t\t\t\trequire(index < last_index, "BUG index after last");\n', '\t\t\t\tuint64 claim_num_of_last_element = ongoing_claim_nums[last_index];\n', '\t\t\t\tnum2index[claim_num_of_last_element] = index;\n', '\t\t\t\tongoing_claim_nums[index] = claim_num_of_last_element;\n', '\t\t\t}\n', '\t\t\tongoing_claim_nums.pop();\n', '\t\t\tdelete num2index[claim_num];\n', '\t\t}\n', '\n', '\t\tuint claimed_amount_to_be_paid = is_winning_claimant ? c.amount : 0;\n', '\t\tsendWithdrawals(to_address, claimed_amount_to_be_paid, won_stake);\n', '\t\tnotifyPaymentRecipient(to_address, claimed_amount_to_be_paid, won_stake, claim_num);\n', '\t}\n', '\n', '\tfunction notifyPaymentRecipient(address payable payment_recipient_address, uint net_claimed_amount, uint won_stake, uint claim_num) private {\n', '\t\tif (CounterstakeLibrary.isContract(payment_recipient_address)){\n', '\t\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\t//\tCounterstakeReceiver(payment_recipient_address).onReceivedFromClaim(claim_num, is_winning_claimant ? claimed_amount : 0, won_stake);\n', '\t\t\t(bool res, ) = payment_recipient_address.call(abi.encodeWithSignature("onReceivedFromClaim(uint256,uint256,uint256,string,address,string)", claim_num, net_claimed_amount, won_stake, c.sender_address, c.recipient_address, c.data));\n', '\t\t\tif (!res){\n', '\t\t\t\t// ignore\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction receiveStakeAsset(uint stake_asset_amount) internal {\n', '\t\tif (settings.tokenAddress == address(0))\n', '\t\t\trequire(msg.value == stake_asset_amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(settings.tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), "failed to pull the token");\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendWithdrawals(address payable to_address, uint claimed_amount_to_be_paid, uint won_stake) internal virtual;\n', '\t\n', '\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal virtual;\n', '\n', '\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal virtual;\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'interface IOracle {\n', '\t// returns a fraction num/den\n', '\tfunction getPrice(string memory base, string memory quote) external view returns (uint num, uint den);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string public name;\n', '    string public symbol;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}.\n', '     *\n', '     * The defaut value of {decimals} is 18. To select a different value for\n', '     * {decimals} you should overload it.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        name = name_;\n', '        symbol = symbol_;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n', '     * overloaded;\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'interface IERC20WithSymbol is IERC20 {\n', '\tfunction symbol() external view returns (string memory);\n', '}\n', '\n', 'contract Import is ERC20, Counterstake {\n', '\n', '\n', '\tevent NewRepatriation(address sender_address, uint amount, uint reward, string home_address, string data);\n', '\n', '\taddress public oracleAddress;\n', '\n', '\t// min price of imported asset in terms of stake asset, to protect against malicious oracles\n', '\t// The price is multiplied by 1e20\n', '\tuint public min_price20;\n', '\n', '\tstring public home_network;\n', '\tstring public home_asset;\n', '\n', '\tbytes32 private constant base_hash = keccak256(abi.encodePacked("base"));\n', '\tbytes32 private constant zx_hash = keccak256(abi.encodePacked("0x0000000000000000000000000000000000000000"));\n', '\n', '\n', '\tconstructor (string memory _home_network, string memory _home_asset, string memory __name, string memory __symbol, address stakeTokenAddr, address oracleAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) \n', '\tCounterstake(stakeTokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods) \n', '\tERC20(__name, __symbol)\n', '\t{\n', '\t\tinitImport(_home_network, _home_asset, __name, __symbol, oracleAddr);\n', '\t}\n', '\n', '\tfunction initImport(string memory _home_network, string memory _home_asset, string memory __name, string memory __symbol, address oracleAddr) public\n', '\t{\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\toracleAddress = oracleAddr;\n', '\t\thome_network = _home_network;\n', '\t\thome_asset = _home_asset;\n', '\t\tname = __name;\n', '\t\tsymbol = __symbol;\n', '\t}\n', '\n', '\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) override virtual public {\n', '\t\tsuper.setupGovernance(governanceFactory, votedValueFactory);\n', '\t\tgovernance.addVotedValue("oracleAddress", votedValueFactory.createVotedValueAddress(governance, oracleAddress, this.validateOracle, this.setOracle));\n', '\t\tgovernance.addVotedValue("min_price20", votedValueFactory.createVotedValueUint(governance, min_price20, this.validateMinPrice, this.setMinPrice));\n', '\t}\n', '\n', '\tfunction getOraclePrice(address oracleAddr) view private returns (uint, uint) {\n', '\t\tbytes32 home_asset_hash = keccak256(abi.encodePacked(home_asset));\n', '\t\treturn IOracle(oracleAddr).getPrice(\n', '\t\t\thome_asset_hash == base_hash || home_asset_hash == zx_hash ? home_network : home_asset, \n', '\t\t\tsettings.tokenAddress == address(0) ? "_NATIVE_" : IERC20WithSymbol(settings.tokenAddress).symbol()\n', '\t\t);\n', '\t}\n', '\n', '\tfunction validateOracle(address oracleAddr) view external {\n', '\t\trequire(CounterstakeLibrary.isContract(oracleAddr), "bad oracle");\n', '\t\t(uint num, uint den) = getOraclePrice(oracleAddr);\n', '\t\trequire(num > 0 || den > 0, "no price from oracle");\n', '\t}\n', '\n', '\tfunction setOracle(address oracleAddr) onlyVotedValueContract external {\n', '\t\toracleAddress = oracleAddr;\n', '\t}\n', '\n', '\tfunction validateMinPrice(uint _min_price20) pure external {\n', '\t\t// anything goes\n', '\t}\n', '\n', '\tfunction setMinPrice(uint _min_price20) onlyVotedValueContract external {\n', '\t\tmin_price20 = _min_price20;\n', '\t}\n', '\n', '\n', '\t// repatriate\n', '\tfunction transferToHomeChain(string memory home_address, string memory data, uint amount, uint reward) external {\n', '\t\t_burn(msg.sender, amount);\n', '\t\temit NewRepatriation(msg.sender, amount, reward, home_address, data);\n', '\t}\n', '\n', '\tfunction getRequiredStake(uint amount) public view override returns (uint) {\n', '\t\t(uint num, uint den) = getOraclePrice(oracleAddress);\n', '\t\trequire(num > 0, "price num must be positive");\n', '\t\trequire(den > 0, "price den must be positive");\n', '\t\tuint stake_in_image_asset = amount * settings.ratio100 / 100;\n', '\t\treturn Math.max(Math.max(stake_in_image_asset * num / den, stake_in_image_asset * min_price20 / 1e20), settings.min_stake);\n', '\t}\n', '\n', '\n', '\tfunction sendWithdrawals(address payable to_address, uint paid_claimed_amount, uint won_stake) internal override {\n', '\t\tif (paid_claimed_amount > 0){\n', '\t\t\t_mint(to_address, paid_claimed_amount);\n', '\t\t}\n', '\t\tif (settings.tokenAddress == address(0))\n', '\t\t\tto_address.transfer(won_stake);\n', '\t\telse\n', '\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, won_stake), "failed to send the won stake");\n', '\t}\n', '\n', '\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal override {\n', '\t\tif (paid_amount > 0)\n', '\t\t\t_burn(msg.sender, paid_amount);\n', '\t\treceiveStakeAsset(stake);\n', '\t}\n', '\n', '\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal override {\n', '\t\t_mint(to_address, paid_amount);\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ImportAssistant is ERC20, ReentrancyGuard, CounterstakeReceiver {\n', '\n', '\tstruct UintBalance {\n', '\t\tuint stake;\n', '\t\tuint image;\n', '\t}\n', '\n', '\tstruct IntBalance {\n', '\t\tint stake;\n', '\t\tint image;\n', '\t}\n', '\n', '\taddress public bridgeAddress;\n', '\taddress public tokenAddress;\n', '\taddress public managerAddress;\n', '\n', '\tuint16 public management_fee10000;\n', '\tuint16 public success_fee10000;\n', '\n', '\tuint8 public exponent;\n', '\t\n', '\tuint16 public swap_fee10000;\n', '\n', '\tuint public ts;\n', '\tIntBalance public profit;\n', '\tUintBalance public mf;\n', '\tUintBalance public balance_in_work;\n', '\n', '\tmapping(uint => UintBalance) public balances_in_work;\n', '\n', '\tGovernance public governance;\n', '\n', '\n', '\tevent NewClaimFor(uint claim_num, address for_address, string txid, uint32 txts, uint amount, int reward, uint stake);\n', '\tevent AssistantChallenge(uint claim_num, CounterstakeLibrary.Side outcome, uint stake);\n', '    event NewManager(address previousManager, address newManager);\n', '\n', '\n', '\tmodifier onlyETH(){\n', '\t\trequire(tokenAddress == address(0), "ETH only");\n', '\t\t_;\n', '\t}\n', '\n', '/*\tmodifier onlyERC20(){\n', '\t\trequire(tokenAddress != address(0), "ERC20 only");\n', '\t\t_;\n', '\t}*/\n', '\n', '\tmodifier onlyBridge(){\n', '\t\trequire(msg.sender == bridgeAddress, "not from bridge");\n', '\t\t_;\n', '\t}\n', '\n', '    modifier onlyManager() {\n', '        require(msg.sender == managerAddress, "caller is not the manager");\n', '        _;\n', '    }\n', '\n', '\n', '\tconstructor(address bridgeAddr, address managerAddr, uint16 _management_fee10000, uint16 _success_fee10000, uint16 _swap_fee10000, uint8 _exponent, string memory name, string memory symbol) ERC20(name, symbol) {\n', '\t\tinitImportAssistant(bridgeAddr, managerAddr, _management_fee10000, _success_fee10000, _swap_fee10000, _exponent, name, symbol);\n', '\t}\n', '\n', '\tfunction initImportAssistant(address bridgeAddr, address managerAddr, uint16 _management_fee10000, uint16 _success_fee10000, uint16 _swap_fee10000, uint8 _exponent, string memory _name, string memory _symbol) public {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tname = _name;\n', '\t\tsymbol = _symbol;\n', '\t\tbridgeAddress = bridgeAddr;\n', '\t\tmanagement_fee10000 = _management_fee10000;\n', '\t\tsuccess_fee10000 = _success_fee10000;\n', '\t\tswap_fee10000 = _swap_fee10000;\n', '\t\trequire(_exponent == 1 || _exponent == 2 || _exponent == 4, "only exponents 1, 2 and 4 are supported");\n', '\t\texponent = _exponent;\n', '\t\tts = block.timestamp;\n', '\t\t(address tokenAddr, , , , , ) = Import(bridgeAddr).settings();\n', '\t\ttokenAddress = tokenAddr;\n', '\t\tif (tokenAddr != address(0))\n', '\t\t\tIERC20(tokenAddr).approve(bridgeAddr, type(uint).max);\n', '\t\tmanagerAddress = (managerAddr != address(0)) ? managerAddr : msg.sender;\n', '\t}\n', '\n', '\n', '\tfunction getGrossBalance() internal view returns (UintBalance memory bal) {\n', '\t\tuint stake_bal = (tokenAddress == address(0)) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '\t\tuint image_bal = IERC20(bridgeAddress).balanceOf(address(this));\n', '\t\tbal.stake = stake_bal + balance_in_work.stake;\n', '\t\tbal.image = image_bal + balance_in_work.image;\n', '\t}\n', '\n', '\tfunction updateMFAndGetBalances(uint just_received_stake_amount, uint just_received_image_amount, bool update) internal returns (UintBalance memory gross_balance, IntBalance memory net_balance) {\n', '\t\tgross_balance = getGrossBalance();\n', '\t\tgross_balance.stake -= just_received_stake_amount;\n', '\t\tgross_balance.image -= just_received_image_amount;\n', '\t\tuint new_mf_stake = mf.stake + gross_balance.stake * management_fee10000 * (block.timestamp - ts)/(360*24*3600)/1e4;\n', '\t\tuint new_mf_image = mf.image + gross_balance.image * management_fee10000 * (block.timestamp - ts)/(360*24*3600)/1e4;\n', '\t\tnet_balance.stake = int(gross_balance.stake) - int(new_mf_stake) - max(profit.stake * int16(success_fee10000)/1e4, 0);\n', '\t\tnet_balance.image = int(gross_balance.image) - int(new_mf_image) - max(profit.image * int16(success_fee10000)/1e4, 0);\n', "\t\t// to save gas, we don't update mf when the balances don't change\n", '\t\tif (update) {\n', '\t\t\tmf.stake = new_mf_stake;\n', '\t\t\tmf.image = new_mf_image;\n', '\t\t\tts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\t\n', '\n', '\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, string memory sender_address, address payable recipient_address, string memory data) onlyManager nonReentrant external {\n', '\t\trequire(reward >= 0, "negative reward");\n', '\t\tuint claim_num = Import(bridgeAddress).last_claim_num() + 1;\n', '\t\tuint required_stake = Import(bridgeAddress).getRequiredStake(amount);\n', '\t\tuint paid_amount = amount - uint(reward);\n', '\t\trequire(required_stake < uint(type(int).max), "required_stake too large");\n', '\t\trequire(paid_amount < uint(type(int).max), "paid_amount too large");\n', '\t\t{ // stack too deep\n', '\t\t\t(, IntBalance memory net_balance) = updateMFAndGetBalances(0, 0, false);\n', '\t\t\trequire(net_balance.stake > 0, "no net balance in stake asset");\n', '\t\t\trequire(net_balance.image > 0, "no net balance in image asset");\n', '\t\t\trequire(required_stake <= uint(net_balance.stake), "not enough balance in stake asset");\n', '\t\t\trequire(paid_amount <= uint(net_balance.image), "not enough balance in image asset");\n', '\t\t\tbalances_in_work[claim_num] = UintBalance({stake: required_stake, image: paid_amount});\n', '\t\t\tbalance_in_work.stake += required_stake;\n', '\t\t\tbalance_in_work.image += paid_amount;\n', '\t\t}\n', '\n', '\t\temit NewClaimFor(claim_num, recipient_address, txid, txts, amount, reward, required_stake);\n', '\n', '\t\tImport(bridgeAddress).claim{value: tokenAddress == address(0) ? required_stake : 0}(txid, txts, amount, reward, required_stake, sender_address, recipient_address, data);\n', '\t}\n', '\n', '\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) onlyManager nonReentrant external {\n', '\t\t(, IntBalance memory net_balance) = updateMFAndGetBalances(0, 0, false);\n', '\t\trequire(net_balance.stake > 0, "no net balance");\n', '\n', '\t\tuint missing_stake = Import(bridgeAddress).getMissingStake(claim_num, stake_on);\n', "\t\tif (stake == 0 || stake > missing_stake) // send the stake without excess as we can't account for it\n", '\t\t\tstake = missing_stake;\n', '\n', '\t\trequire(stake <= uint(net_balance.stake), "not enough balance");\n', '\t\tImport(bridgeAddress).challenge{value: tokenAddress == address(0) ? stake : 0}(claim_num, stake_on, stake);\n', '\t\tbalances_in_work[claim_num].stake += stake;\n', '\t\tbalance_in_work.stake += stake;\n', '\t\temit AssistantChallenge(claim_num, stake_on, stake);\n', '\t}\n', '\n', '\treceive() external payable onlyETH {\n', '\t\t// silently receive Ether from claims\n', '\t}\n', '\n', '\tfunction onReceivedFromClaim(uint claim_num, uint claimed_amount, uint won_stake, string memory, address, string memory) onlyBridge override external {\n', '\t\tupdateMFAndGetBalances(won_stake, claimed_amount, true); // this is already added to our balance\n', '\n', '\t\tUintBalance storage invested = balances_in_work[claim_num];\n', '\t\trequire(invested.stake > 0, "BUG: I didn\'t stake in this claim?");\n', '\n', '\t\tif (won_stake >= invested.stake){\n', '\t\t\tuint this_profit = won_stake - invested.stake;\n', '\t\t\trequire(this_profit < uint(type(int).max), "stake profit too large");\n', '\t\t\tprofit.stake += int(this_profit);\n', '\t\t}\n', '\t\telse { // avoid negative values\n', '\t\t\tuint loss = invested.stake - won_stake;\n', '\t\t\trequire(loss < uint(type(int).max), "stake loss too large");\n', '\t\t\tprofit.stake -= int(loss);\n', '\t\t}\n', '\n', '\t\tif (claimed_amount >= invested.image){\n', '\t\t\tuint this_profit = claimed_amount - invested.image;\n', '\t\t\trequire(this_profit < uint(type(int).max), "image profit too large");\n', '\t\t\tprofit.image += int(this_profit);\n', '\t\t}\n', '\t\telse { // avoid negative values\n', '\t\t\tuint loss = invested.image - claimed_amount;\n', '\t\t\trequire(loss < uint(type(int).max), "image loss too large");\n', '\t\t\tprofit.image -= int(loss);\n', '\t\t}\n', '\n', '\t\tbalance_in_work.stake -= invested.stake;\n', '\t\tbalance_in_work.image -= invested.image;\n', '\t\tdelete balances_in_work[claim_num];\n', '\t}\n', '\n', '\t// Record a loss, called by anybody.\n', '\t// Should be called only if I staked on the losing side only.\n', '\t// If I staked on the winning side too, the above function should be called.\n', '\tfunction recordLoss(uint claim_num) nonReentrant external {\n', '\t\tupdateMFAndGetBalances(0, 0, true);\n', '\n', '\t\tUintBalance storage invested = balances_in_work[claim_num];\n', '\t\trequire(invested.stake > 0, "this claim is already accounted for");\n', '\t\t\n', '\t\tCounterstakeLibrary.Claim memory c = Import(bridgeAddress).getClaim(claim_num);\n', '\t\trequire(c.amount > 0, "no such claim");\n', '\t\trequire(block.timestamp > c.expiry_ts, "not expired yet");\n', '\t\tCounterstakeLibrary.Side opposite_outcome = c.current_outcome == CounterstakeLibrary.Side.yes ? CounterstakeLibrary.Side.no : CounterstakeLibrary.Side.yes;\n', '\t\t\n', '\t\tuint my_winning_stake = Import(bridgeAddress).stakes(claim_num, c.current_outcome, address(this));\n', '\t\trequire(my_winning_stake == 0, "have a winning stake in this claim");\n', '\t\t\n', '\t\tuint my_losing_stake = Import(bridgeAddress).stakes(claim_num, opposite_outcome, address(this));\n', '\t\trequire(my_losing_stake > 0, "no losing stake in this claim");\n', '\t\trequire(invested.stake == my_losing_stake, "BUG: losing stake mismatch");\n', '\n', '\t\trequire(invested.stake < uint(type(int).max), "stake loss too large");\n', '\t\trequire(invested.image < uint(type(int).max), "image loss too large");\n', '\t\tprofit.stake -= int(invested.stake);\n', '\t\tprofit.image -= int(invested.image);\n', '\n', '\t\tbalance_in_work.stake -= invested.stake;\n', '\t\tbalance_in_work.image -= invested.image;\n', '\t\tdelete balances_in_work[claim_num];\n', '\t}\n', '\n', '\n', '\t// share issue/redeem functions\n', '\n', '\tfunction buyShares(uint stake_asset_amount, uint image_asset_amount) payable nonReentrant external {\n', '\t\tif (tokenAddress == address(0))\n', '\t\t\trequire(msg.value == stake_asset_amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), "failed to pull stake");\n', '\t\t}\n', '\t\trequire(IERC20(bridgeAddress).transferFrom(msg.sender, address(this), image_asset_amount), "failed to pull image");\n', '\n', '\t\t(UintBalance memory gross_balance, IntBalance memory net_balance) = updateMFAndGetBalances(stake_asset_amount, image_asset_amount, true);\n', '\t\trequire((gross_balance.stake == 0) == (totalSupply() == 0), "bad init state");\n', '\t\tuint shares_amount;\n', '\t\tif (totalSupply() == 0){ // initial issue\n', '\t\t\trequire(stake_asset_amount > 0 && image_asset_amount > 0, "must supply both assets for initial issue");\n', '\t\t\tshares_amount = getShares(stake_asset_amount, image_asset_amount) / 10**(18 - decimals());\n', '\t\t}\n', '\t\telse {\n', '\t\t\trequire(net_balance.stake > 0, "no stake net balance");\n', '\t\t\trequire(net_balance.image > 0, "no image net balance");\n', '\t\t\tuint new_shares_supply = totalSupply() * getShares(uint(net_balance.stake) + stake_asset_amount, uint(net_balance.image) + image_asset_amount) / getShares(uint(net_balance.stake), uint(net_balance.image));\n', '\t\t\tshares_amount = new_shares_supply - totalSupply();\n', '\t\t}\n', '\t\t_mint(msg.sender, shares_amount);\n', '\n', "\t\t// this should overflow now, not when we try to redeem. We won't see the error message, will revert while trying to evaluate the expression\n", '\t\trequire(Math.max(gross_balance.stake + stake_asset_amount, gross_balance.image + image_asset_amount) * totalSupply()**exponent > 0, "too many shares, would overflow");\n', '\t}\n', '\n', '\tfunction redeemShares(uint shares_amount) nonReentrant external {\n', '\t\tuint old_shares_supply = totalSupply();\n', '\n', '\t\t_burn(msg.sender, shares_amount);\n', '\t\t(, IntBalance memory net_balance) = updateMFAndGetBalances(0, 0, true);\n', '\t\trequire(net_balance.stake > 0, "negative net balance in stake asset");\n', '\t\trequire(net_balance.image > 0, "negative net balance in image asset");\n', '\t\trequire(uint(net_balance.stake) > balance_in_work.stake, "negative risk-free net balance in stake asset");\n', '\t\trequire(uint(net_balance.image) > balance_in_work.image, "negative risk-free net balance in image asset");\n', '\t\t\n', '\t\tuint stake_asset_amount = (uint(net_balance.stake) - balance_in_work.stake) * (old_shares_supply**exponent - (old_shares_supply - shares_amount)**exponent) / old_shares_supply**exponent;\n', '\t\tstake_asset_amount -= stake_asset_amount * swap_fee10000/10000;\n', '\n', '\t\tuint image_asset_amount = (uint(net_balance.image) - balance_in_work.image) * (old_shares_supply**exponent - (old_shares_supply - shares_amount)**exponent) / old_shares_supply**exponent;\n', '\t\timage_asset_amount -= image_asset_amount * swap_fee10000/10000;\n', '\t\t\n', '\t\tpayStakeTokens(msg.sender, stake_asset_amount);\n', '\t\tpayImageTokens(msg.sender, image_asset_amount);\n', '\t}\n', '\n', '\n', '\t// swapping finctions\n', '\n', '\tfunction swapImage2Stake(uint image_asset_amount) nonReentrant external {\n', '\t\trequire(IERC20(bridgeAddress).transferFrom(msg.sender, address(this), image_asset_amount), "failed to pull image");\n', '\n', '\t\t(, IntBalance memory net_balance) = updateMFAndGetBalances(0, image_asset_amount, false);\n', '\t\trequire(net_balance.stake > 0, "negative net balance in stake asset");\n', '\t\trequire(net_balance.image > 0, "negative net balance in image asset");\n', '\t\trequire(uint(net_balance.stake) > balance_in_work.stake, "negative risk-free net balance in stake asset");\n', '\n', '\t\tuint stake_asset_amount = (uint(net_balance.stake) - balance_in_work.stake) * image_asset_amount / (uint(net_balance.image) + image_asset_amount);\n', '\t\tstake_asset_amount -= stake_asset_amount * swap_fee10000/10000;\n', '\n', '\t\tpayStakeTokens(msg.sender, stake_asset_amount);\n', '\t}\n', '\n', '\tfunction swapStake2Image(uint stake_asset_amount) payable nonReentrant external {\n', '\t\tif (tokenAddress == address(0))\n', '\t\t\trequire(msg.value == stake_asset_amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), "failed to pull stake");\n', '\t\t}\n', '\n', '\t\t(, IntBalance memory net_balance) = updateMFAndGetBalances(stake_asset_amount, 0, false);\n', '\t\trequire(net_balance.stake > 0, "negative net balance in stake asset");\n', '\t\trequire(net_balance.image > 0, "negative net balance in image asset");\n', '\t\trequire(uint(net_balance.image) > balance_in_work.image, "negative risk-free net balance in image asset");\n', '\n', '\t\tuint image_asset_amount = (uint(net_balance.image) - balance_in_work.image) * stake_asset_amount / (uint(net_balance.stake) + stake_asset_amount);\n', '\t\timage_asset_amount -= image_asset_amount * swap_fee10000/10000;\n', '\n', '\t\tpayImageTokens(msg.sender, image_asset_amount);\n', '\t}\n', '\n', '\n', '\t// manager functions\n', '\n', '\tfunction withdrawManagementFee() onlyManager nonReentrant external {\n', '\t\tupdateMFAndGetBalances(0, 0, true);\n', '\t\tpayStakeTokens(msg.sender, mf.stake);\n', '\t\tpayImageTokens(msg.sender, mf.image);\n', '\t\tmf.stake = 0;\n', '\t\tmf.image = 0;\n', '\t}\n', '\n', '\tfunction withdrawSuccessFee() onlyManager nonReentrant external {\n', '\t\tupdateMFAndGetBalances(0, 0, true);\n', '\t\tif (profit.stake > 0) {\n', '\t\t\tuint sf = uint(profit.stake) * success_fee10000/1e4;\n', '\t\t\tpayStakeTokens(msg.sender, sf);\n', '\t\t\tprofit.stake = 0;\n', '\t\t}\n', '\t\tif (profit.image > 0) {\n', '\t\t\tuint sf = uint(profit.image) * success_fee10000/1e4;\n', '\t\t\tpayImageTokens(msg.sender, sf);\n', '\t\t\tprofit.image = 0;\n', '\t\t}\n', '\t}\n', '\n', '\t// zero address is allowed\n', '    function assignNewManager(address newManager) onlyManager external {\n', '\t\temit NewManager(managerAddress, newManager);\n', '        managerAddress = newManager;\n', '    }\n', '\n', '\n', '\t// governance functions\n', '\n', '\tmodifier onlyVotedValueContract(){\n', '\t\trequire(governance.addressBelongsToGovernance(msg.sender), "not from voted value contract");\n', '\t\t_;\n', '\t}\n', '\n', '\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\n', '\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = governanceFactory.createGovernance(address(this), address(this));\n', '\n', '\t\tgovernance.addVotedValue("swap_fee10000", votedValueFactory.createVotedValueUint(governance, swap_fee10000, this.validateSwapFee, this.setSwapFee));\n', '\t}\n', '\n', '\n', '\n', '\tfunction validateSwapFee(uint _swap_fee10000) pure external {\n', '\t\trequire(_swap_fee10000 < 10000, "bad swap fee");\n', '\t}\n', '\n', '\tfunction setSwapFee(uint _swap_fee10000) onlyVotedValueContract external {\n', '\t\tswap_fee10000 = uint16(_swap_fee10000);\n', '\t}\n', '\n', '\n', '\t// helper functions\n', '\n', '\tfunction payStakeTokens(address to, uint amount) internal {\n', '\t\tif (tokenAddress == address(0))\n', '\t\t\tpayable(to).transfer(amount);\n', '\t\telse\n', '\t\t\trequire(IERC20(tokenAddress).transfer(to, amount), "failed to transfer stake asset");\n', '\t}\n', '\n', '\tfunction payImageTokens(address to, uint amount) internal {\n', '\t\trequire(IERC20(bridgeAddress).transfer(to, amount), "failed to transfer image asset");\n', '\t}\n', '\n', '\tfunction getShares(uint stake_balance, uint image_balance) view internal returns (uint) {\n', '\t\tuint gm = sqrt(stake_balance * image_balance);\n', '\t\tif (exponent == 1)\n', '\t\t\treturn gm;\n', '\t\tif (exponent == 2)\n', '\t\t\treturn sqrt(gm);\n', '\t\tif (exponent == 4)\n', '\t\t\treturn sqrt(sqrt(gm));\n', '\t\trevert("bad exponent");\n', '\t}\n', '\n', '\t// for large exponents, we need more room to **exponent without overflow\n', '\tfunction decimals() public view override returns (uint8) {\n', '\t\treturn exponent > 2 ? 9 : 18;\n', '\t}\n', '\n', '\n', '\tfunction max(int a, int b) internal pure returns (int) {\n', '\t\treturn a > b ? a : b;\n', '\t}\n', '\n', '\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '\tfunction sqrt(uint y) internal pure returns (uint z) {\n', '\t\tif (y > 3) {\n', '\t\t\tz = y;\n', '\t\t\tuint x = y / 2 + 1;\n', '\t\t\twhile (x < z) {\n', '\t\t\t\tz = x;\n', '\t\t\t\tx = (y / x + x) / 2;\n', '\t\t\t}\n', '\t\t} else if (y != 0) {\n', '\t\t\tz = 1;\n', '\t\t}\n', '\t}\n', '\n', '}']