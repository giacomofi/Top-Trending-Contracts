['"""\n', '@title Greenwood AaveV2Escrow\n', '@notice Aave V2 integrations for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'interface AAVE_V2_CALCULATOR:\n', '    def calculateBorrow(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _collateralization_ratio: uint256, _version: String[11]) -> AaveV2BorrowCalculation: nonpayable\n', '    def calculateWithdraw(_borrow_context: AssetContext, _collateral_context: AssetContext, _escrow: address, _loan: Loan, _version: String[11]) -> AaveV2WithdrawCalculation: nonpayable\n', '    def calculateRepay(_borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _escrow: address, _loan: Loan, _version: String[11])-> AaveV2RepayCalculation: nonpayable\n', '\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11]) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', 'interface STORE:\n', '    def getAssetContext(_ticker: String[10]) -> AssetContext: view\n', '    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\n', '    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\n', '    def getLoan(_loan_key: bytes32) -> Loan: view\n', '    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\n', '\n', '# define the constants used by the contract\n', 'LOOP_LIMIT: constant(uint256) = 100\n', '\n', '# define the events emitted by the contract\n', 'event AddCollateral:\n', '    loanKey: bytes32\n', '    depositor: address\n', '    amount: uint256\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Borrow:\n', '    borrower: address\n', '    amount: uint256\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Liquidate:\n', '    loanKey: bytes32\n', '    outstanding: uint256\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Liquidation:\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    liquidator: address\n', '    loanKeys: bytes32[100]\n', '    redemptionAmount: uint256\n', '    repayAmount: uint256\n', '    blockNumber: uint256\n', '\n', 'event Repay:\n', '    borrower: address\n', '    repaymentAmount: uint256\n', '    repaymentAsset: address\n', '    redemptionAmount: uint256\n', '    redemptionAsset: address\n', '    blockNumber: uint256\n', '\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', 'event WithdrawCollateral:\n', '    loanKey: bytes32\n', '    amount: uint256\n', '    collateralAsset: address\n', '    collateralLocked: uint256\n', '    blockNumber: uint256\n', '\n', '# define the structs used by the contract\n', 'struct AaveV2BorrowCalculation:\n', '    requiredCollateral: uint256\n', '    borrowIndex: uint256\n', '    borrowAmount: uint256\n', '    originationFee: uint256\n', '\n', 'struct AaveV2RepayCalculation:\n', '    repayAmount: uint256\n', '    redemptionAmount: int128\n', '    requiredCollateral: uint256\n', '    outstanding: int128\n', '    borrowIndex: uint256\n', '\n', 'struct AaveV2WithdrawCalculation:\n', '    requiredCollateral: uint256\n', '    outstanding: uint256\n', '\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct Loan:\n', '    collateralAsset: address\n', '    borrowAsset: address\n', '    outstanding: uint256\n', '    collateralizationRatio: uint256\n', '    collateralLocked: uint256\n', '    borrower: address\n', '    lastBorrowIndex: uint256\n', '    repaymentTime: uint256\n', '\n', '# define the storage variables used by the contract\n', 'registry: public(address)\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @param _version The version of Greenwood to use\n', '    @return True if the caller is authorized, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "controller"\n', '    if keccak256(_role) == keccak256("controller"):\n', '\n', '        # get the address of the Controller from the Registry\n', '        escrow: address = REGISTRY(self.registry).getAddress("controller", _version)\n', '\n', '        # return the equality comparison boolean\n', '        return escrow == _caller\n', '    \n', '    # check if the requested role is "governance"\n', '    elif keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison boolean\n', '        return governance == _caller\n', '\n', '    # check if the requested role is "liquidator"\n', '    elif keccak256(_role) == keccak256("liquidator"):\n', '\n', '        # get the address of the Liquidator from the Registry\n', '        liquidator: address = REGISTRY(self.registry).getAddress("liquidator", _version)\n', '\n', '        # return the equality comparison boolean\n', '        return liquidator == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '@external\n', 'def borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]):\n', '    """\n', '    @notice Borrow assets from Aave V2\n', '    @param _borrow_ticker The ticker string of the asset being borrowed\n', '    @param _collateral_ticker The ticker string of the asset being used as collateral\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', "    @param _amount The amount of asset being borrowed scaled by the asset's decimals\n", '    @param _borrower The address of the borrower\n', '    @param _calculator The address of the Grenwood Calculator to use\n', '    @param _collateralization_ratio The collateralization ratio for the loan as a percentage\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', '    # require that the borrow amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** _borrow_context.decimals, decimal) > 0.0, "Borrow amount must be greater than 0"\n', '\n', '    # get requiredCollateral, borrowIndex, borrowAmount, and protocolFee from the Calculator\n', '    borrowCalculations: AaveV2BorrowCalculation = AAVE_V2_CALCULATOR(_calculator).calculateBorrow(_borrow_context, _collateral_context, _amount, _collateralization_ratio, _version)\n', '\n', '    # check if the origination fee is greater than 0\n', '    if borrowCalculations.originationFee > 0:\n', '\n', '        # get the address of the Treasury from the Registry\n', '        treasury: address = REGISTRY(self.registry).getAddress("treasury", _version)\n', '\n', '        # require that a Treasury address was returned from the Store\n', '        assert treasury != ZERO_ADDRESS, "No Treasury address returned from the Store"\n', '\n', '        # transfer the origination fee to the Treasury\n', '        transferResponse: Bytes[32] = raw_call(\n', '            _collateral_context.underlying,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(_borrower, bytes32),\n', '                convert(treasury, bytes32),\n', '                convert(borrowCalculations.originationFee, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(transferResponse) > 0:\n', '            assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '    # move collateral from the borrower to the Escrow using safeTransferFrom \n', '    transferFromResponse: Bytes[32] = raw_call(\n', '        _collateral_context.underlying,\n', '        concat(\n', '            method_id("transferFrom(address,address,uint256)"),\n', '            convert(_borrower, bytes32),\n', '            convert(self, bytes32),\n', '            convert(borrowCalculations.requiredCollateral, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(transferFromResponse) > 0:\n', '        assert convert(transferFromResponse, bool), "Failed safeTransferFrom"\n', '\n', '    # approve the collateral transfer from Escrow to the Aave V2 LendingPool\n', '    approveResponse: Bytes[32] = raw_call(\n', '        _collateral_context.underlying,\n', '        concat(\n', '            method_id("approve(address,uint256)"),\n', '            convert(_collateral_context.aaveV2LendingPool, bytes32),\n', '            convert(borrowCalculations.requiredCollateral, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(approveResponse) > 0:\n', '        assert convert(approveResponse, bool), "Failed approve"\n', '\n', '    # supply the collateral to Aave V2\n', '    raw_call(\n', '        _collateral_context.aaveV2LendingPool,\n', '        concat(\n', '            method_id("deposit(address,uint256,address,uint16)"),\n', '            convert(_collateral_context.underlying, bytes32),\n', '            convert(borrowCalculations.requiredCollateral, bytes32),\n', '            convert(self, bytes32),\n', '            convert(0, bytes32) \n', '        )\n', '    )\n', '\n', '    # execute the borrow on Aave V2\n', '    raw_call(\n', '        _borrow_context.aaveV2LendingPool,\n', '        concat(\n', '            method_id("borrow(address,uint256,uint256,uint16,address)"),\n', '            convert(_borrow_context.underlying, bytes32),\n', '            convert(_amount, bytes32),\n', '            convert(2, bytes32),\n', '            convert(0, bytes32),\n', '            convert(self, bytes32),\n', '        )\n', '    )\n', '\n', '    # transfer the borrowed asset to the borrower using safeTransfer\n', '    transferResponse: Bytes[32] = raw_call(\n', '        _borrow_context.underlying,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(_borrower, bytes32),\n', '            convert(_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(transferResponse) > 0:\n', '        assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '    # call recordLoan() on the Store to store the loan data\n', '    STORE(_store).recordLoan(_borrower, _borrow_context.underlying, _collateral_context.underlying, _collateralization_ratio, borrowCalculations.requiredCollateral, borrowCalculations.borrowIndex, _amount, "aavev2", _version)\n', '\n', '    # emit a Borrow event\n', '    log Borrow(_borrower, _amount, _borrow_context.underlying, _collateral_context.underlying, block.number)\n', '    \n', '@external\n', 'def repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\n', '    """\n', '    @notice Repay an Aave V2 loan\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the repayment scaled by the asset's decimals\n", '    @param _calculator The address of the Greenwood Calculator to use\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', '    # get the loan protocol from the Store\n', '    loanProtocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # get the rest of the loan data from the Store\n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # require that the outstanding balance of the loan is greater than 0\n', '    assert loan.outstanding > 0, "Outstanding balance must be greater than 0"\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '    \n', '    # require the the loan assets match the underlying assets of the contexts\n', '    assert borrowContext.underlying == loan.borrowAsset, "Borrow context mismatch"\n', '    assert collateralContext.underlying == loan.collateralAsset, "Collateral context mismatch"\n', '\n', '    # check if this is a full repayment\n', '    if _amount != MAX_UINT256:\n', '\n', '        # require that the repay amount is greater than 0 after scaling it down\n', '        assert convert(_amount, decimal) / convert(10 ** borrowContext.decimals, decimal) > 0.0, "Repayment amount must be greater than 0"\n', '    \n', '    # check that this loan was originated with Aave V2\n', '    if keccak256(loanProtocol) == keccak256("aavev2"):\n', '\n', '        # get the redemption amount from the Calculator\n', '        repayCalculations: AaveV2RepayCalculation = AAVE_V2_CALCULATOR(_calculator).calculateRepay(borrowContext, collateralContext, _amount, self, loan, _version)\n', '\n', '        # move the repayment asset (borrow asset) from the borrower to the Escrow\n', '        transferFromResponse: Bytes[32] = raw_call(\n', '            borrowContext.underlying,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(loan.borrower, bytes32),\n', '                convert(self, bytes32),\n', '                convert(repayCalculations.repayAmount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        ) \n', '        if len(transferFromResponse) > 0:\n', '            assert convert(transferFromResponse, bool), "Failed safeTransferFrom"\n', '        \n', '        # approve the Aave V2 LendingPool to access the token balance of the Escrow\n', '        approveResponse: Bytes[32] = raw_call(\n', '            borrowContext.underlying,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(borrowContext.aaveV2LendingPool, bytes32),\n', '                convert(repayCalculations.repayAmount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(approveResponse) > 0:\n', '            assert convert(approveResponse, bool), "Failed approve"    \n', '\n', '        # call repay() on the Aave V2 LendingPool\n', '        raw_call(\n', '            borrowContext.aaveV2LendingPool,\n', '            concat(\n', '                method_id("repay(address,uint256,uint256,address)"),\n', '                convert(borrowContext.underlying, bytes32),\n', '                convert(repayCalculations.repayAmount, bytes32),\n', '                convert(2, bytes32),\n', '                convert(self, bytes32)\n', '            ),\n', '        )\n', '\n', '        # check if the redemption amount is less than 0\n', '        if repayCalculations.redemptionAmount < 0:\n', '\n', '            # emit a Liquidate event because the loan is undercollateralized\n', '            log Liquidate(_loan_key, loan.outstanding, borrowContext.underlying, collateralContext.underlying, block.number)\n', '\n', '        # check if the redemption amount is greater than 0\n', '        elif repayCalculations.redemptionAmount > 0:\n', '\n', '            # allow the Aave V2 LendingPool to burn the aTokens\n', '            approveBurnResponse: Bytes[32] = raw_call(\n', '                collateralContext.aToken,\n', '                concat(\n', '                    method_id("approve(address,uint256)"),\n', '                    convert(collateralContext.aaveV2LendingPool, bytes32),\n', '                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(approveBurnResponse) > 0:\n', '                assert convert(approveBurnResponse, bool), "Failed approve"\n', '\n', '            # call withdraw() on the Aave V2 LendingPool\n', '            raw_call(\n', '                collateralContext.aaveV2LendingPool,\n', '                concat(\n', '                    method_id("withdraw(address,uint256,address)"),\n', '                    convert(collateralContext.underlying, bytes32),\n', '                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\n', '                    convert(self, bytes32)\n', '                ),\n', '            )\n', '            \n', '            # transfer the redeemed collateral asset back to the borrower\n', '            transferResponse: Bytes[32] = raw_call(\n', '                collateralContext.underlying,\n', '                concat(\n', '                    method_id("transfer(address,uint256)"),\n', '                    convert(loan.borrower, bytes32),\n', '                    convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(transferResponse) > 0:\n', '                assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '            # update the loan with collateral needed, checkpoint borrow index, and outstanding balance\n', '            STORE(_store).updateLoan(repayCalculations.requiredCollateral, repayCalculations.borrowIndex, _loan_key, convert(repayCalculations.outstanding, uint256), _version)\n', '\n', '            # emit a Repay event\n', '            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\n', '                \n', '        # check if the redemption amount is equal to 0\n', '        elif repayCalculations.redemptionAmount == 0:\n', '\n', '            # emit a Repay event\n', '            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\n', '    \n', '    # catch extraneous lending protocols\n', '    else:\n', '        raise "Unhandled protocol"\n', '\n', '\n', '@external\n', 'def addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]):\n', '    """\n', '    @notice Add collateral to Aave V2\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the deposit scaled by the asset's decimals\n", '    @param _depositor The address of the depositor\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store contract to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', "    # get the loan's protocol from the Store\n", '    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol was returned from the Store\n', '    assert keccak256(protocol) != keccak256(""), "No loan protocol returned from the Store"\n', '\n', '    # get the loan data from the Store\n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # get the context of the collateral asset from the Store\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', "    # require that the loan's collateral asset and underlying asset of the collateral context match\n", '    assert loan.collateralAsset == collateralContext.underlying, "Collateral context mismatch"\n', '\n', '    # require that the deposit amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0, "Deposit amount must be greater than 0"\n', '\n', '    # check if this loan was originated with Aave V2\n', '    if keccak256(protocol) == keccak256("aavev2"):\n', '\n', '        # move collateral from user to Escrow \n', '        transferFromResponse: Bytes[32] = raw_call(\n', '            collateralContext.underlying,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(_depositor, bytes32),\n', '                convert(self, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        ) \n', '        if len(transferFromResponse) > 0:\n', '            assert convert(transferFromResponse, bool), "Failed safeTransferFrom"\n', '\n', '        # approve the collateral transfer from Escrow to Aave V2\n', '        approveResponse: Bytes[32] = raw_call(\n', '            collateralContext.underlying,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(collateralContext.aaveV2LendingPool, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(approveResponse) > 0:\n', '            assert convert(approveResponse, bool), "Failed approve"\n', '\n', '        # supply the collateral to Aave V2\n', '        raw_call(\n', '            collateralContext.aaveV2LendingPool,\n', '            concat(\n', '                method_id("deposit(address,uint256,address,uint16)"),\n', '                convert(collateralContext.underlying, bytes32),\n', '                convert(_amount, bytes32),\n', '                convert(self, bytes32),\n', '                convert(0, bytes32) \n', '            )\n', '        )\n', '        \n', '        # add the amount of collateral to the existing amount of collateralLocked\n', '        collateralLocked: uint256 = loan.collateralLocked + _amount\n', '\n', '        # pass borrowIndex of 0 so this member of the  Loan truct is not updated\n', '        borrowIndex: uint256 = 0\n', '\n', '        # update the loan with the new value of collateral locked\n', '        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, loan.outstanding, _version)\n', '\n', '        # emit an AddCollateral event\n', '        log AddCollateral(_loan_key, _depositor, _amount, collateralContext.underlying, block.number)\n', '        \n', '    else:\n', '        raise "malformed protocol string"\n', '\n', '@external\n', 'def withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32,  _store: address, _version: String[11]):\n', '    """\n', '    @notice Withdraw collateral from Aave V2\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount to withdraw scaled by the asset's decimals\n", '    @param _calculator The address of the Greenwood Calculator to use\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', "    # get the loan's protocol from the Store \n", '    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol was returned from the Store\n', '    assert keccak256(protocol) != keccak256(""), "No loan protocol returned from the Store"\n', '\n', '    # get the loan data from the Store \n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '\n', '    # require the the loan assets match the underlying assets of the contexts\n', '    assert loan.borrowAsset == borrowContext.underlying, "Borrow context mismatch"\n', '    assert loan.collateralAsset == collateralContext.underlying, "Collateral context mismatch"\n', '\n', '    # require that the withdraw amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0, "Withdraw amount must be greater than 0"\n', '\n', '    # check if this loan was originated with Aave V2\n', '    if keccak256(protocol) == keccak256("aavev2"):\n', '\n', '        # get the withdraw calculations from the Calculator\n', '        withdrawCalculations: AaveV2WithdrawCalculation = AAVE_V2_CALCULATOR(_calculator).calculateWithdraw(borrowContext, collateralContext, self, loan, _version)\n', '\n', '        # require that this withdraw does not violate collateral requirements\n', '        assert loan.collateralLocked - _amount >= withdrawCalculations.requiredCollateral, "Withdraw amount violates collateral requirements"\n', '\n', '        # allow the Aave V2 LendingPool to burn the aTokens\n', '        approveBurnResponse: Bytes[32] = raw_call(\n', '            collateralContext.aToken,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(collateralContext.aaveV2LendingPool, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(approveBurnResponse) > 0:\n', '            assert convert(approveBurnResponse, bool), "Failed approve"\n', '\n', '        # call withdraw() on the Aave V2 LendingPool\n', '        raw_call(\n', '            collateralContext.aaveV2LendingPool,\n', '            concat(\n', '                method_id("withdraw(address,uint256,address)"),\n', '                convert(collateralContext.underlying, bytes32),\n', '                convert(_amount, bytes32),\n', '                convert(self, bytes32)\n', '            ),\n', '        )\n', '\n', '        # recalculate collateral locked by subtracting the withdraw amount from collateralLocked\n', '        collateralLocked: uint256 = loan.collateralLocked - _amount\n', '\n', '        # transfer the redeemed collateral asset back to the borrower\n', '        transferResponse: Bytes[32] = raw_call(\n', '            collateralContext.underlying,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(loan.borrower, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(transferResponse) > 0:\n', '            assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '        # pass borrowIndex of 0 so this member of the struct is not updated\n', '        borrowIndex: uint256 = 0\n', '\n', '        # update the loan with outstanding balance and collateral needed\n', '        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, withdrawCalculations.outstanding, _version)\n', '        \n', '        # emit a WithdrawCollateral event\n', '        log WithdrawCollateral(_loan_key, _amount, collateralContext.underlying, collateralLocked, block.number)\n', '\n', '    # revert, unhandled loan.protocol\n', '    else:\n', '        raise "malformed protocol string"\n', '\n', '@external\n', 'def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]):\n', '    """\n', '    @notice Liquidate undercollateralized loans\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _borrow_index The latest borrow index from the underlying lending protocol\n', '    @param _key_count The number of keys in the _loan_keys array\n', '    @param _liquidator The address of the liquidator\n', '    @param _redeem_amount The amount of collateral asset to redeem\n', '    @param _repay_amount The amount of borrowed asset to repay\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Liquidator or the Governance\n', '    assert self.isAuthorized(msg.sender, "liquidator", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Liquidator or Governance can call this method"\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', '    # require that the liquidation redemption amount is greater than 0\n', '    assert _redeem_amount > 0, "Liquidation redeem amount must be greater than 0"\n', '\n', '    # require that the liquidation repayment amount is greater than 0\n', '    assert _repay_amount > 0, "Liquidation repay amount must be greater than 0"\n', '\n', '    # move repayment asset (borrow asset) from Liquidator to Escrow\n', '    transferFromResponse: Bytes[32] = raw_call(\n', '        borrowContext.underlying,\n', '        concat(\n', '            method_id("transferFrom(address,address,uint256)"),\n', '            convert(_liquidator, bytes32),\n', '            convert(self, bytes32),\n', '            convert(_repay_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    ) \n', '    if len(transferFromResponse) > 0:\n', '        assert convert(transferFromResponse, bool), "Failed safeTransferFrom"\n', '\n', '    # approve the Aave V2 LendingPool to access the token balance of Escrow\n', '    approveResponse: Bytes[32] = raw_call(\n', '        borrowContext.underlying,\n', '        concat(\n', '            method_id("approve(address,uint256)"),\n', '            convert(borrowContext.aaveV2LendingPool, bytes32),\n', '            convert(_repay_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(approveResponse) > 0:\n', '        assert convert(approveResponse, bool), "Failed approve"\n', '\n', '    # call repay() on the Aave V2 LendingPool\n', '    raw_call(\n', '        borrowContext.aaveV2LendingPool,\n', '        concat(\n', '            method_id("repay(address,uint256,uint256,address)"),\n', '            convert(borrowContext.underlying, bytes32),\n', '            convert(_repay_amount, bytes32),\n', '            convert(2, bytes32),\n', '            convert(self, bytes32)\n', '        ),\n', '    )\n', '\n', '    # allow the Aave V2 LendingPool to burn the aTokens\n', '    approveBurnResponse: Bytes[32] = raw_call(\n', '        collateralContext.aToken,\n', '        concat(\n', '            method_id("approve(address,uint256)"),\n', '            convert(collateralContext.aaveV2LendingPool, bytes32),\n', '            convert(_redeem_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(approveBurnResponse) > 0:\n', '        assert convert(approveBurnResponse, bool), "Failed approve"\n', '\n', '    # call withdraw() on the Aave V2 LendingPool\n', '    raw_call(\n', '        collateralContext.aaveV2LendingPool,\n', '        concat(\n', '            method_id("withdraw(address,uint256,address)"),\n', '            convert(collateralContext.underlying, bytes32),\n', '            convert(_redeem_amount, bytes32),\n', '            convert(self, bytes32)\n', '        ),\n', '    )\n', '\n', '    # transfer the redeemed collateral asset to the liquidator\n', '    transferResponse: Bytes[32] = raw_call(\n', '        collateralContext.underlying,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(_liquidator, bytes32),\n', '            convert(_redeem_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(transferResponse) > 0:\n', '        assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '    # declare memory variable to store the number of loan keys that have been processed\n', '    loanKeyCounter: uint256 = 0\n', '\n', '    # update the outstanding balance and collateral needed for the loans\n', '    for i in range(LOOP_LIMIT):\n', '        if loanKeyCounter < _key_count:\n', '            STORE(_store).updateLoan(0, _borrow_index, _loan_keys[i], 0, _version)\n', '\n', '            # increment the loan key counter\n', '            loanKeyCounter += 1\n', '        \n', '        # all loan keys have been processed\n', '        elif loanKeyCounter == _key_count:\n', '\n', '            # halt loop execution\n', '            break\n', '\n', '        else:\n', '\n', '            # halt loop execution as a fallback case\n', '            break\n', '\n', '    # emit a Liquidation event\n', '    log Liquidation(borrowContext.underlying, collateralContext.underlying, _liquidator, _loan_keys, _redeem_amount, _repay_amount, block.number)\n', '\n', '@external\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)']