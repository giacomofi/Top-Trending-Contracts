['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-02\n', '*/\n', '\n', 'pragma solidity ^0.8.2;\n', '// SPDX-License-Identifier: MIT\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▀ ▀▓▌▐▓▓▓▓▓▀▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓ ▓▓▌▝▚▞▜▓ ▀▀ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▄▀▓▌▐▓▌▐▓▄▀▀▀▓▓▓▓▓▓▓▓▓▓▛▀▀▀▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▛▀▀▀▄▄▄▄▄▄▄▛▀▀▀▓▓▓▛▀▀▀▓▓▓▙▄▄▄▛▀▀▀▓▓▓▛▀▀▀▙▄▄▄▓▓▓▛▀▀▀▄▄▄▄▄▄▄▛▀▀▀▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▀▀▀▜▓▓▓▓▓▓▓▓▓▓▌   ▀▀▀▀▀▀▀▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▓███   ▐███▓▓▓▓▓▓▓▌          ▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▀▀▀▀▀▀▀▓▓▓▓▓▓▓▌   ▓▓▓▛▀▀▀▙▄▄▄▓▓▓▙▄▄▄▛▀▀▀▓▓▓▓▓▓▓▀▀▀▀▀▀▀▀▀▀▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌          ▓▓▓▓▓▓▓▌   ▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓          ▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▐▓▓▓  ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▓▓▓    ▓▓▓▓▓▓    ▐▓▓▓▓▓▌    ▐▓▓▓      ▐▓▓▓▌    ▐▓▓▓▓▓▌    ▓▓▓▓▓▓▓▌       ▓▓▓    ▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▌   ▓▓▓▓▌  ▓▓▓▓  ▐▌  ▓▓▓▓▌  ▓  ▐▓▓▓▓▌  ▓▓▓  ▐▓▓▓  ▐▓▓▓▓▌  ▓▓▓▓▓▓▓▓  ▐▓  ▐▓▓▓  ▐▓▓▓▌  ▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▙▄▄▄▓▓▓▓▌  ▓▓▓▓  ▐▌  ▓▓▓▓▌  ▓  ▐▓▓▓▓▓▓▓▓▓▓  ▐▓▓▓  ▐▓▓▓▓▓▓▓▓▓▓▌      ▐▓  ▐▓▓▓  ▐▓▓▓▓▓▓    ▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌  ▓▓▓▓  ▐▌  ▓▓▓▓▌  ▓  ▐▓▓▓▓▓▓▓▓▓▓  ▐▓▓▓  ▐▓▓▓▓▓▓▓▓   ▓▓▓▓  ▐▓  ▐▓▓▓  ▐▓▓▓▓▓▓▓▓▓▓  ▐▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌      ▓▓▓▓▓▓    ▐▓▓▓  ▐▓▓▓▓▓▓▓▓▓▓▓▓▌  ▓  ▐▓▓▓▓▓▓▓▓▓▓▌    ▓▓▓▓  ▐▓▓▓▓▓  ▐▓▓▓    ▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▌  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract ThePixelPortraits {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    enum CommissionStatus { queued, accepted, removed  }\n', '    \n', '    struct Commission {\n', '        string name;\n', '        address payable recipient;\n', '        uint bid;\n', '        CommissionStatus status;\n', '    }\n', '\n', '    uint MAX_INT = uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n', '\n', '    address payable public admin;\n', '    \n', '    mapping (string => uint) public names;\n', '    mapping (uint => Commission) public commissions;\n', '    \n', '    uint public minBid; // the number of wei required to create a commission\n', '    uint public newCommissionIndex; // the index of the next commission which should be created in the mapping\n', '    bool public callStarted; // ensures no re-entrancy can occur\n', '\n', '    modifier callNotStarted () {\n', '      require(!callStarted);\n', '      callStarted = true;\n', '      _;\n', '      callStarted = false;\n', '    }\n', '    \n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin, "not an admin");\n', '        _;\n', '    }\n', '    \n', '    constructor(address payable _admin, uint _minBid) {\n', '        admin = _admin;\n', '        minBid = _minBid;\n', '        newCommissionIndex = 1;\n', '    }\n', '     \n', '    function updateAdmin (address payable _newAdmin)\n', '    public\n', '    callNotStarted\n', '    onlyAdmin\n', '    {\n', '        admin = _newAdmin;\n', '        emit AdminUpdated(_newAdmin);\n', '    }\n', '    \n', '    function updateMinBid (uint _newMinBid)\n', '    public\n', '    callNotStarted\n', '    onlyAdmin\n', '    {\n', '        minBid = _newMinBid;\n', '        emit MinBidUpdated(_newMinBid);\n', '    }\n', '\n', '    function registerNames (string[] memory _names)\n', '    public\n', '    callNotStarted\n', '    onlyAdmin\n', '    {\n', '        for (uint i = 0; i < _names.length; i++){\n', '            require(names[toLower(_names[i])] == 0, "name not available"); // ensures the name is not taken\n', '            names[toLower(_names[i])] = MAX_INT;\n', '        }\n', '        emit NamesRegistered(_names);\n', '    }\n', '   \n', '    function commission (string memory _name) \n', '    public\n', '    callNotStarted\n', '    payable\n', '    {\n', '        require(validateName(_name), "name not valid"); // ensures the name is valid\n', '        require(names[toLower(_name)] == 0, "name not available"); // the name cannot be taken when you create your commission\n', '        require(msg.value >= minBid, "bid below minimum"); // must send the proper amount of into the bid\n', '        \n', '        // Next, initialize the new commission\n', '        Commission storage newCommission = commissions[newCommissionIndex];\n', '        newCommission.name = _name;\n', '        newCommission.recipient = payable(msg.sender);\n', '        newCommission.bid = msg.value;\n', '        newCommission.status = CommissionStatus.queued;\n', '              \n', '        emit NewCommission(newCommissionIndex, _name, msg.value, msg.sender);\n', '        \n', '        newCommissionIndex++; // for the subsequent commission to be added into the next slot \n', '    }\n', '    \n', '    \n', '    function updateCommissionName (uint _commissionIndex, string memory _newName) \n', '    public\n', '    callNotStarted\n', '    {\n', '        require(_commissionIndex < newCommissionIndex, "commission not valid"); // must be a valid previously instantiated commission\n', '        Commission storage selectedCommission = commissions[_commissionIndex];\n', '        require(msg.sender == selectedCommission.recipient, "commission not yours"); // may only be performed by the person who commissioned it\n', '        require(selectedCommission.status == CommissionStatus.queued, "commission not in queue"); // the commission must still be queued\n', '        require(validateName(_newName), "name not valid"); // ensures the name is valid\n', '        require(names[toLower(_newName)] == 0, "name not available"); // the name cannot be taken when you create your commission\n', '\n', '        selectedCommission.name = _newName;\n', '\n', '        emit CommissionNameUpdated(_commissionIndex, _newName);\n', '    }\n', '    \n', '    function rescindCommission (uint _commissionIndex) \n', '    public\n', '    callNotStarted\n', '    {\n', '        require(_commissionIndex < newCommissionIndex, "commission not valid"); // must be a valid previously instantiated commission\n', '        Commission storage selectedCommission = commissions[_commissionIndex];\n', '        require(msg.sender == selectedCommission.recipient, "commission not yours"); // may only be performed by the person who commissioned it\n', '        require(selectedCommission.status == CommissionStatus.queued, "commission not in queue"); // the commission must still be queued\n', '      \n', '        // we mark it as removed and return the individual their bid\n', '        selectedCommission.status = CommissionStatus.removed;\n', '        selectedCommission.recipient.transfer(selectedCommission.bid);\n', '        \n', '        emit CommissionRescinded(_commissionIndex);\n', '    }\n', '    \n', '    function increaseCommissionBid (uint _commissionIndex)\n', '    public\n', '    payable\n', '    callNotStarted\n', '    {\n', '        require(_commissionIndex < newCommissionIndex, "commission not valid"); // must be a valid previously instantiated commission\n', '        Commission storage selectedCommission = commissions[_commissionIndex];\n', '        require(msg.sender == selectedCommission.recipient, "commission not yours"); // may only be performed by the person who commissioned it\n', '        require(selectedCommission.status == CommissionStatus.queued, "commission not in queue"); // the commission must still be queued\n', '\n', "        // then we update the commission's bid\n", '        selectedCommission.bid = msg.value + selectedCommission.bid;\n', '        \n', '        emit CommissionBidUpdated(_commissionIndex, selectedCommission.bid);\n', '    }\n', '    \n', '    function processCommissions(uint[] memory _commissionIndexes)\n', '    public\n', '    onlyAdmin\n', '    callNotStarted\n', '    {\n', '        for (uint i = 0; i < _commissionIndexes.length; i++){\n', '            Commission storage selectedCommission = commissions[_commissionIndexes[i]];\n', '            \n', '            require(selectedCommission.status == CommissionStatus.queued, "commission not in the queue"); // the queue my not be empty when processing more commissions \n', "            require(names[toLower(selectedCommission.name)] == 0); // admins can't process commissions with names which are taken\n", '            \n', "            // the name isn't taken yet and will be accepted\n", '            selectedCommission.status = CommissionStatus.accepted; // first, we change the status of the commission to accepted\n', '            names[toLower(selectedCommission.name)] = _commissionIndexes[i]; // finally, we reserve the name for this commission\n', '            admin.transfer(selectedCommission.bid); // next we accept the payment for the commission\n', '            \n', '            emit CommissionProcessed(_commissionIndexes[i], selectedCommission.status);\n', '        }\n', '    }\n', '    \n', '    // Credit to Hashmasks for the following functions\n', '    function validateName (string memory str)\n', '    public \n', '    pure \n', '    returns (bool)\n', '    {\n', '        bytes memory b = bytes(str);\n', '        if(b.length < 1) return false;\n', '        if(b.length > 25) return false; // Cannot be longer than 25 characters\n', '        if(b[0] == 0x20) return false; // Leading space\n', '        if (b[b.length - 1] == 0x20) return false; // Trailing space\n', '\n', '        bytes1 lastChar = b[0];\n', '\n', '        for(uint i; i<b.length; i++){\n', '            bytes1 char = b[i];\n', '\n', '            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\n', '\n', '            if(\n', '                !(char >= 0x30 && char <= 0x39) && //9-0\n', '                !(char >= 0x41 && char <= 0x5A) && //A-Z\n', '                !(char >= 0x61 && char <= 0x7A) && //a-z\n', '                !(char == 0x20) //space\n', '            )\n', '                return false;\n', '\n', '            lastChar = char;\n', '        }\n', '\n', '        return true;\n', '    }\n', '    \n', '    function toLower (string memory str)\n', '    public \n', '    pure \n', '    returns (string memory)\n', '    {\n', '        bytes memory bStr = bytes(str);\n', '        bytes memory bLower = new bytes(bStr.length);\n', '        for (uint i = 0; i < bStr.length; i++) {\n', '            // Uppercase character\n', '            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\n', '                bLower[i] = bytes1(uint8(bStr[i]) + 32);\n', '            } else {\n', '                bLower[i] = bStr[i];\n', '            }\n', '        }\n', '        return string(bLower);\n', '    }\n', '    \n', '    event AdminUpdated(address _newAdmin);\n', '    event MinBidUpdated(uint _newMinBid);\n', '    event NamesRegistered(string[] _names);\n', '    event NewCommission(uint _commissionIndex, string _name, uint _bid, address _recipient);\n', '    event CommissionNameUpdated(uint _commissionIndex, string _newName);\n', '    event CommissionBidUpdated(uint _commissionIndex, uint _newBid);\n', '    event CommissionRescinded(uint _commissionIndex);\n', '    event CommissionProcessed(uint _commissionIndex, CommissionStatus _status);\n', '}']