['"""\n', '@title Liquidator\n', '@notice Loan liquidation contract for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'from vyper.interfaces import ERC20\n', '\n', 'interface AAVE_V2_PRICE_FEED:\n', '    def getAssetPrice(_asset: address) -> uint256: view\n', '\n', 'interface COMPTROLLER:\n', '    def markets(_c_token: address) -> (bool, uint256, bool): view\n', '\n', 'interface COMPOUND_PRICE_FEED:\n', '    def price(_ticker: String[10]) -> uint256: view\n', '\n', 'interface CTOKEN:\n', '    def mint(_mint_amount: uint256) -> uint256: payable\n', '    def borrow(_borrow_amount: uint256) -> uint256: payable\n', '    def repayBorrow(_repay_amount: uint256) -> uint256: payable\n', '    def borrowIndex() -> uint256: nonpayable\n', '    def redeemUnderlying(_redeem_amount: uint256) -> uint256: payable\n', '    def exchangeRateStored() -> uint256: nonpayable\n', '    def borrowRatePerBlock() -> uint256: nonpayable\n', '    def borrowBalanceCurrent(_account: address) -> uint256: nonpayable\n', '    def accrualBlockNumber() -> uint256: nonpayable\n', '\n', 'interface ESCROW:\n', '    def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]): payable\n', '\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', 'interface STORE:\n', '    def getAssetContext(_ticker: String[10]) -> AssetContext: view\n', '    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\n', '    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\n', '    def getLoan(_loan_key: bytes32) -> Loan: view\n', '    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\n', '\n', '# decalre the constants used by the contract\n', 'LOOP_LIMIT: constant(uint256) = 100\n', 'TEN_EXP_6: constant(uint256) = 1000000\n', 'TEN_EXP_18: constant(uint256) = 1000000000000000000\n', 'ZERO_BYTES_32: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000000000000\n', '\n', '# define the events used by the contract\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', '#  define the structs used by the contract\n', 'struct AaveV2CollateralCalculation:\n', '    isLiquidatable: bool\n', '    outstanding: uint256\n', '\n', 'struct AaveV2Data:\n', '    collateralAssetLTV: uint256\n', '    borrowIndex: uint256\n', '    variableDebtTokenAddress: address\n', '    escrowBorrowBalance: uint256\n', '    scaledBalanceOf: uint256\n', '    borrowAssetPriceExp: uint256\n', '    collateralAssetPriceExp: uint256\n', '\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct CompoundData:\n', '    collateralFactorMantissa: uint256\n', '    borrowIndex: uint256\n', '    borrowAssetPriceExp: uint256\n', '    collateralAssetPriceExp: uint256\n', '\n', 'struct CompoundCollateralCalculation:\n', '    isLiquidatable: bool\n', '    outstanding: uint256\n', '\n', 'struct Loan:\n', '    collateralAsset: address\n', '    borrowAsset: address\n', '    outstanding: uint256\n', '    collateralizationRatio: uint256\n', '    collateralLocked: uint256\n', '    borrower: address\n', '    lastBorrowIndex: uint256\n', '    repaymentTime: uint256\n', '\n', '# define the storage variables used by the contract\n', 'registry: public(address)\n', 'aaveV2Data: AaveV2Data\n', 'compoundData: CompoundData\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @param _version The version of Greenwood to use\n', '    @return True if the caller is authorized, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "controller"\n', '    if keccak256(_role) == keccak256("controller"):\n', '\n', '        # get the address of the Controller from the Registry\n', '        escrow: address = REGISTRY(self.registry).getAddress("controller", _version)\n', '\n', '        # return the equality comparison boolean\n', '        return escrow == _caller\n', '    \n', '    # check if the requested role is "governance"\n', '    elif keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison boolean\n', '        return governance == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '\n', '@internal\n', 'def fetchAaveV2Data(_borrow_context: AssetContext, _collateral_context: AssetContext, _escrow: address) -> AaveV2Data:\n', '    """\n', '    @notice Get Aave V2 data for liquidation calculations\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', '    @param _escrow The address of the Greenwood Escrow to use\n', '    @return AaveV2Data struct\n', '    """\n', '\n', '    # get the LTV ratio of the collateral asset\n', '    collateralReserveData: Bytes[768] = raw_call(\n', '        _collateral_context.aaveV2LendingPool,\n', '        concat(\n', '            method_id("getReserveData(address)"),\n', '            convert(_collateral_context.underlying, bytes32)\n', '        ),\n', '        max_outsize=768\n', '    )\n', '\n', '    # parse the LTV from collateralReserveData and convert it to a percentage\n', '    collateralAssetLTV: uint256 = convert(slice(collateralReserveData, 30, 2), uint256)\n', '\n', '    # get the current borrowIndex of the borrow asset\n', '    borrowReserveData: Bytes[768] = raw_call(\n', '        _borrow_context.aaveV2LendingPool,\n', '        concat(\n', '            method_id("getReserveData(address)"),\n', '            convert(_borrow_context.underlying, bytes32)\n', '        ),\n', '        max_outsize=768\n', '    )\n', '\n', '    # parse the variableBorrowIndex from borrowReserveData\n', '    borrowIndex: uint256 = convert(slice(borrowReserveData, 64, 32), uint256)\n', '\n', '    # parse the variableDebtTokenAddress from borrowReserveData\n', '    variableDebtTokenAddress: address = convert(convert(slice(borrowReserveData, 288, 32), bytes32), address)\n', '\n', '    # get variableDebtToken balance of the Escrow\n', '    escrowBorrowBalance: uint256 = ERC20(variableDebtTokenAddress).balanceOf(_escrow)\n', '\n', '    # get the variableDebtToken scaledBalanceOf the Escrow\n', '    scaledBalanceOfResponse: Bytes[32] = raw_call(\n', '        variableDebtTokenAddress,\n', '        concat(\n', '            method_id("scaledBalanceOf(address)"),\n', '            convert(_escrow, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )\n', '\n', '    # convert the scaledBalanceOfResponse to a uint256\n', '    scaledBalanceOf: uint256 = convert(scaledBalanceOfResponse, uint256)\n', '\n', '    # get the price of the borrow asset and the collateral asset denominated in ETH\n', '    borrowAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_borrow_context.aaveV2PriceFeed).getAssetPrice(_borrow_context.underlying)\n', '    collateralAssetPriceExp: uint256 = AAVE_V2_PRICE_FEED(_collateral_context.aaveV2PriceFeed).getAssetPrice(_collateral_context.underlying)\n', '\n', '    # scale down the prices and convert them to decimals\n', '    borrowAssetPrice: decimal = convert(borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\n', '    collateralAssetPrice: decimal = convert(collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\n', '\n', '    # return the data\n', '    return AaveV2Data({\n', '        collateralAssetLTV: collateralAssetLTV,\n', '        borrowIndex: borrowIndex,\n', '        variableDebtTokenAddress: variableDebtTokenAddress,\n', '        escrowBorrowBalance: escrowBorrowBalance,\n', '        scaledBalanceOf: scaledBalanceOf,\n', '        borrowAssetPriceExp: borrowAssetPriceExp,\n', '        collateralAssetPriceExp: collateralAssetPriceExp,\n', '    })\n', '\n', '@internal\n', 'def fetchCompoundData(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext) -> CompoundData:\n', '    """\n', '    @notice Get Compound data for liquidation calculations\n', '    @param _borrow_ticker The ticker string of the asset that is being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', '    @return CompoundData struct\n', '    """\n', '\n', '    # setup memory variables to handle comptroller return values\n', '    isListed: bool = False\n', '    collateralFactorMantissa: uint256 = 0\n', '    isComped: bool = False\n', '\n', '    # get the collateral factor for the collateral asset using the comptroller\n', '    isListed, collateralFactorMantissa, isComped  = COMPTROLLER(_collateral_context.comptroller).markets(_collateral_context.cToken)\n', '\n', '    # get the current borrowIndex from the cToken\n', '    borrowIndex: uint256 = CTOKEN(_borrow_context.cToken).borrowIndex()\n', '\n', '    # get the price of the borrow asset and the collateral asset denominated in USD\n', '    borrowAssetPriceExp: uint256 = COMPOUND_PRICE_FEED(_borrow_context.compoundPriceFeed).price(_borrow_ticker)\n', '    collateralAssetPriceExp: uint256 = COMPOUND_PRICE_FEED(_collateral_context.compoundPriceFeed).price(_collateral_ticker)\n', '\n', '    # return the data\n', '    return CompoundData({\n', '        collateralFactorMantissa: collateralFactorMantissa,\n', '        borrowIndex: borrowIndex,\n', '        borrowAssetPriceExp: borrowAssetPriceExp,\n', '        collateralAssetPriceExp: collateralAssetPriceExp\n', '    })\n', '\n', '@internal\n', 'def checkAaveV2Collateral(_borrow_context: AssetContext, _collateral_context: AssetContext, _aave_v2_data: AaveV2Data, _escrow: address, _loan: Loan) -> AaveV2CollateralCalculation:\n', '    """\n', '    @notice Calculate the required collateral and liquidatibility for an Aave V2 loan\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', '    @param _aave_v2_data The AaveV2Data struct with data for liquidation calculatios\n', '    @param _escrow The address of the Greenwood Escrow to use\n', '    @param _loan A Loan struct containing loan data\n', '    @return AaveV2CollateralCalculation struct\n', '    """\n', '\n', '    # scale down the LTV to a percentage\n', '    collateralAssetLTV: decimal = convert(_aave_v2_data.collateralAssetLTV, decimal) / 10000.0\n', '\n', '    # calculate the borrow balance increase of the Escrow\n', '    balanceIncrease: decimal = ((convert(_aave_v2_data.escrowBorrowBalance, decimal) - convert(_aave_v2_data.scaledBalanceOf, decimal)) * (convert(_loan.lastBorrowIndex, decimal) / convert(10 ** 27, decimal))) / convert(10 ** 18, decimal)\n', '\n', '    # declare a memory variable to store the amount of interest accrued\n', '    interestAccrued: decimal = 0.0\n', '\n', '    # check that the Escrow borrow balance is not equal to the balance increase to prevent division by 0\n', '    if convert(_aave_v2_data.escrowBorrowBalance, decimal) != balanceIncrease:\n', '\n', '        # calculate the interest accrued since the last action on the loan\n', '        interestAccrued = balanceIncrease / (convert(_aave_v2_data.escrowBorrowBalance, decimal) - balanceIncrease)\n', '\n', '    # apply interest accrued to the outstanding balance of the loan\n', '    borrowBalanceScaled: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\n', '\n', '    # scale down the prices and convert them to decimals\n', '    borrowAssetPrice: decimal = convert(_aave_v2_data.borrowAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\n', '    collateralAssetPrice: decimal = convert(_aave_v2_data.collateralAssetPriceExp, decimal) / convert(TEN_EXP_18, decimal)\n', '\n', '    # convert the borrow balance to a decimal and scale it down\n', '    borrowBalance: decimal = convert(borrowBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\n', '\n', '    # calculate the value of the borrow balance denominated in ETH\n', '    borrowAmountInETH: decimal = borrowBalance * borrowAssetPrice\n', '\n', '    # calculate the required collateral denominated in ETH\n', '    requiredCollateralInETH: decimal = borrowAmountInETH / collateralAssetLTV\n', '\n', '    # calculate the required collateral denominated in the collateral asset \n', '    requiredCollateral: decimal = requiredCollateralInETH / collateralAssetPrice\n', '\n', '    # calculate the required collateral for Greenwood denominated in the collateral asset \n', '    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\n', '\n', '    # scale the required collateral for Greenwood by the decimals of the collateral asset\n', '    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\n', '\n', '    # subtract the required collateral from the collateral locked to see if the loan is undercollateralized\n', '    collateralDifference: int128 = convert(_loan.collateralLocked, int128) - convert(requiredCollateralScaled, int128)\n', '\n', '    # check if the collateral difference is negative\n', '    if collateralDifference < 0:\n', '\n', '        # if the collateral difference is negative return True\n', '        return AaveV2CollateralCalculation({\n', '            isLiquidatable: True,\n', '            outstanding: borrowBalanceScaled\n', '        })\n', '\n', '    # check if the collateral difference is non-negative\n', '    elif collateralDifference >= 0:\n', '        \n', '        # if the collateral difference is non-negative return False\n', '        return AaveV2CollateralCalculation({\n', '            isLiquidatable: False,\n', '            outstanding: 0\n', '        })\n', '\n', '    else:\n', '\n', '        # return False as a fallback case\n', '        return AaveV2CollateralCalculation({\n', '            isLiquidatable: False,\n', '            outstanding: 0\n', '        })\n', '\n', '@internal\n', 'def checkCompoundCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _compound_data: CompoundData, _loan: Loan) -> CompoundCollateralCalculation:\n', '    """\n', '    @notice Calculate the required collateral and liquidatibility for a Compound loan\n', '    @param _borrow_ticker The ticker string of the asset that is being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', '    @param _compound_data The CompoundData struct with data for liquidation calculatios\n', '    @param _loan A Loan struct containing loan data\n', '    @return CompoundCollateralCalculation struct\n', '    """\n', '\n', '    # convert collateralFactorMantissa to a percentage\n', '    collateralFactor: decimal = convert(_compound_data.collateralFactorMantissa, decimal) / convert(TEN_EXP_18, decimal)\n', '\n', '    # calculate the interestAccrued since the last action on the loan\n', '    interestAccrued: decimal = convert(_compound_data.borrowIndex, decimal) / convert(_loan.lastBorrowIndex, decimal) - 1.0\n', '\n', '    # apply interest accrued to the outstanding balance of the loan\n', '    borrowBalanceScaled: uint256 = convert(convert(_loan.outstanding, decimal) * (1.0 + interestAccrued), uint256)\n', '\n', '    # convert the prices to decimals\n', '    borrowAssetPrice: decimal = convert(_compound_data.borrowAssetPriceExp, decimal) / convert(TEN_EXP_6, decimal)\n', '    collateralAssetPrice: decimal = convert(_compound_data.collateralAssetPriceExp, decimal) / convert(TEN_EXP_6, decimal)\n', '\n', '    # convert the borrow balance to a decimal and scale it down\n', '    borrowBalance: decimal = convert(borrowBalanceScaled, decimal) / convert(10 ** _borrow_context.decimals, decimal)\n', '\n', '    # calculate the value of the outstanding balance denominated in USD\n', '    borrowAmountInUSD: decimal = borrowBalance * borrowAssetPrice\n', '\n', '    # calculate the required collateral denominated in USD\n', '    requiredCollateralInUSD: decimal = borrowAmountInUSD / collateralFactor\n', '\n', '    # calculate the required collateral denominated in the collateral asset \n', '    requiredCollateral: decimal = requiredCollateralInUSD / collateralAssetPrice\n', '\n', '    # calculate the required collateral for Greenwood denominated in the collateral asset \n', '    requiredCollateralGreenwood: decimal = requiredCollateral * (convert(_loan.collateralizationRatio, decimal) / 100.0)\n', '\n', '    # scale the required collateral for Greenwood by the decimals of the collateral asset\n', '    requiredCollateralScaled: uint256 = convert(requiredCollateralGreenwood * convert(10 ** _collateral_context.decimals, decimal), uint256)\n', '\n', '    # subtract the required collateral from the collateral locked to see if the loan is undercollateralized\n', '    collateralDifference: int128 = convert(_loan.collateralLocked, int128) - convert(requiredCollateralScaled, int128)\n', '\n', '    # check if the collateral difference is negative\n', '    if collateralDifference < 0:\n', '\n', '        # if the collateral difference is negative return True\n', '        return CompoundCollateralCalculation({\n', '            isLiquidatable: True,\n', '            outstanding: borrowBalanceScaled\n', '        })\n', '\n', '    # check if the collateral difference is non-negative\n', '    elif collateralDifference >= 0:\n', '        \n', '        # if the collateral difference is non-negative return False\n', '        return CompoundCollateralCalculation({\n', '            isLiquidatable: False,\n', '            outstanding: 0\n', '        })\n', '\n', '    else:\n', '\n', '        # return False as a fallback case\n', '        return CompoundCollateralCalculation({\n', '            isLiquidatable: False,\n', '            outstanding: 0\n', '        })\n', '\n', '\n', '@external\n', '@payable\n', 'def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _aave_v2_escrow: address, _compound_escrow: address, _key_count: uint256, _liquidator: address, _loan_keys: bytes32[100], _aave_v2_loan_keys: bytes32[100], _compound_loan_keys: bytes32[100], _store: address, _version: String[11]):\n', '    """\n', '    @notice Compile undercollateralized loans for liquidation\n', '    @param _borrow_ticker The ticker string of the asset that is being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _store The address of the Greenwood AaveV2Escrow to use\n', '    @param _store The address of the Greenwood CompoundEscrow to use\n', '    @param _key_count The number of uinque identifiers in the _loan_keys array\n', '    @param _liquidator The address that submitted the liquidation request\n', '    @param _loan_keys An array of uinque identifiers for loans\n', '    @param _aave_v2_loan_keys An empty array to store loan keys for Aave V2 loans\n', '    @param _compound_loan_keys An empty array to store loan keys for Compound loans\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '\n', '    # declare memory variables to store the number of loan keys that have been processed and the current indexes of the loanKey arrays\n', '    loanKeyCounter: uint256 = 0\n', '    currentAaveV2Index: uint256 = 0\n', '    currentCompoundIndex: uint256 = 0\n', '\n', '    # declare memory variables to store the loan keys of loans that need to be liquidated\n', '    aaveV2LoanKeys: bytes32[100] = _aave_v2_loan_keys\n', '    compoundLoanKeys: bytes32[100] = _compound_loan_keys\n', '\n', '    # declare memory variables to store the status of fetched data\n', '    isAaveV2DataFetched: bool = False\n', '    isCompoundDataFetched: bool = False\n', '\n', '    # declare memory variables to accumulate outstanding balances and collateral locked\n', '    aaveV2Outstanding: uint256 = 0\n', '    compoundOutstanding: uint256 = 0\n', '    aaveV2CollateralLocked: uint256 = 0\n', '    compoundCollateralLocked: uint256 = 0\n', '\n', '    # loop over the loan keys\n', '    for i in range(LOOP_LIMIT):\n', '\n', '        if loanKeyCounter < _key_count:\n', '\n', '            # get the current loan key from loan keys\n', '            currentKey: bytes32 = _loan_keys[i]\n', '        \n', '            # get loan data from the Store\n', '            currentLoan: Loan = STORE(_store).getLoan(currentKey)\n', '\n', '            # require that a loan was returned\n', '            assert currentLoan.borrowAsset != ZERO_ADDRESS, "No loan returned from the Store"\n', '\n', '            # get loan protocol from the Store\n', '            currentProtocol: String[10] = STORE(_store).getLoanProtocol(currentKey)\n', '\n', '            # require that a loan protocol was returned\n', '            assert keccak256(currentProtocol) == keccak256("aavev2") or keccak256(currentProtocol) == keccak256("compound"), "Invalid protocol returned from the Store"\n', '\n', '            # require that the outstanding balance of the loan is non-negative\n', '            assert currentLoan.outstanding > 0, "Outstanding balance must be greater than 0"\n', '\n', '            # require that the underlying asset of the loan and contexts match\n', '            assert currentLoan.borrowAsset == borrowContext.underlying, "Borrow context mismatch"\n', '            assert currentLoan.collateralAsset == collateralContext.underlying, "Collateral context mismatch"\n', '\n', '            # check if the loan was originated with Aave V2 but Aave V2 data has not been fetched\n', '            if keccak256(currentProtocol) == keccak256("aavev2") and isAaveV2DataFetched == False:\n', '\n', '                # get Aave V2 data\n', '                self.aaveV2Data = self.fetchAaveV2Data(borrowContext, collateralContext, _aave_v2_escrow)\n', '\n', '                # prevent refetching the data\n', '                isAaveV2DataFetched = True\n', '\n', '                # check if the current loan is liquidatable\n', '                aaveV2CollateralCalculation: AaveV2CollateralCalculation = self.checkAaveV2Collateral(borrowContext, collateralContext, self.aaveV2Data , _aave_v2_escrow, currentLoan)\n', '\n', '                # handle the return from checkAaveV2Collateral\n', '                if aaveV2CollateralCalculation.isLiquidatable == True:\n', '\n', '                    # if the current loan is liquidatable write the loan key to a byte array\n', '                    aaveV2LoanKeys[currentAaveV2Index] = currentKey\n', '\n', '                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\n', '                    aaveV2Outstanding += aaveV2CollateralCalculation.outstanding\n', '\n', '                    # add the locked collateral to the overall collateral to redeem\n', '                    aaveV2CollateralLocked += currentLoan.collateralLocked\n', '\n', '                    # increment the index\n', '                    currentAaveV2Index += 1\n', '\n', '            # check if the loan was originated with Aave V2 and Aave V2 data has been fetched\n', '            elif keccak256(currentProtocol) == keccak256("aavev2") and isAaveV2DataFetched == True:\n', '                \n', '                # check if the current loan is liquidatable\n', '                aaveV2CollateralCalculation: AaveV2CollateralCalculation = self.checkAaveV2Collateral(borrowContext, collateralContext, self.aaveV2Data , _aave_v2_escrow, currentLoan)\n', '\n', '                # handle the return from checkAaveV2Collateral\n', '                if aaveV2CollateralCalculation.isLiquidatable == True:\n', '\n', '                    # if the current loan is liquidatable write the loan key to a byte array\n', '                    aaveV2LoanKeys[currentAaveV2Index] = currentKey\n', '\n', '                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\n', '                    aaveV2Outstanding += aaveV2CollateralCalculation.outstanding\n', '\n', '                    # add the locked collateral to the overall collateral to redeem\n', '                    aaveV2CollateralLocked += currentLoan.collateralLocked\n', '\n', '                    # increment the index\n', '                    currentAaveV2Index += 1\n', '            \n', '            # check if the loan was originated with Compound but Compound data has not been fetched\n', '            elif keccak256(currentProtocol) == keccak256("compound") and isCompoundDataFetched == False:\n', '\n', '                # fetch compound data\n', '                self.compoundData = self.fetchCompoundData(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext)\n', '\n', '                # set isCompoundDataFetched to True to prevent refetching the data\n', '                isCompoundDataFetched = True\n', '\n', '                # check if the current loan is liquidatable\n', '                compoundCollateralCalculation: CompoundCollateralCalculation = self.checkCompoundCollateral(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, self.compoundData, currentLoan)\n', '\n', '                # handle the return from checkCompoundCollateral\n', '                if compoundCollateralCalculation.isLiquidatable == True:\n', '\n', '                    # if the current loan is liquidatable write the loan key to a byte array\n', '                    compoundLoanKeys[currentCompoundIndex] = currentKey\n', '\n', '                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\n', '                    compoundOutstanding += compoundCollateralCalculation.outstanding\n', '\n', '                    # add the locked collateral to the overall collateral to redeem\n', '                    compoundCollateralLocked += currentLoan.collateralLocked\n', '\n', '                    # increment the index\n', '                    currentCompoundIndex += 1\n', '\n', '            # check if the loan was originated with Compound and Compound data has been fetched\n', '            elif keccak256(currentProtocol) == keccak256("compound") and isCompoundDataFetched == True:\n', '\n', '                # check if the current loan is liquidatable\n', '                compoundCollateralCalculation: CompoundCollateralCalculation = self.checkCompoundCollateral(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, self.compoundData, currentLoan)\n', '\n', '                # handle the return from checkCompoundCollateral\n', '                if compoundCollateralCalculation.isLiquidatable == True:\n', '\n', '                    # if the current loan is liquidatable write the loan key to a byte array\n', '                    compoundLoanKeys[currentCompoundIndex] = currentKey\n', '\n', '                    # add the outstanding balance to the overall outstanding balance for the batch of aave loans\n', '                    compoundOutstanding += compoundCollateralCalculation.outstanding\n', '\n', '                    # add the locked collateral to the overall collateral to redeem\n', '                    compoundCollateralLocked += currentLoan.collateralLocked\n', '\n', '                    # increment the index\n', '                    currentCompoundIndex += 1\n', '\n', '            # catch extraneous lending protocols\n', '            else:\n', '\n', '                # revert\n', '                raise "Unhandled loan protocol"\n', '\n', '            # increment the loan key counter\n', '            loanKeyCounter += 1\n', '\n', '        # all loan keys have been processed\n', '        elif loanKeyCounter == _key_count:\n', '\n', '            # halt loop execution\n', '            break\n', '\n', '        else:\n', '\n', '            # halt loop execution as a fallback case\n', '            break\n', '\n', '    # check if aaveV2LoanKeys is empty\n', '    if aaveV2LoanKeys[0] != ZERO_BYTES_32:\n', '        \n', '        # call liquidate on the Escrow with the aave v2 loan keys\n', '        ESCROW(_aave_v2_escrow).liquidate(_borrow_ticker, _collateral_ticker, self.aaveV2Data.borrowIndex, currentAaveV2Index, aaveV2LoanKeys, _liquidator, aaveV2CollateralLocked, aaveV2Outstanding, _store, _version)\n', '\n', '    # check if compoundLoanKeys is empty\n', '    if compoundLoanKeys[0] != ZERO_BYTES_32:\n', '\n', '        # call liquidate on the Escrow with the compound loan keys\n', '        ESCROW(_compound_escrow).liquidate(_borrow_ticker, _collateral_ticker, self.compoundData.borrowIndex, currentCompoundIndex, compoundLoanKeys, _liquidator, compoundCollateralLocked, compoundOutstanding, _store, _version, value=msg.value)\n', '\n', '\n', '@external\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)']