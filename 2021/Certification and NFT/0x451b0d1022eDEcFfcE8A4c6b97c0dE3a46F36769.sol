['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '// Sources flattened with hardhat v2.3.0 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/proxy/[email\xa0protected]\n', '\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity >=0.4.24 <0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function _isConstructor() private view returns (bool) {\n', '        return !Address.isContract(address(this));\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IMaintainersRegistry.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/**\n', ' * IMaintainersRegistry contract.\n', ' * @author Nikola Madjarevic\n', ' * Date created: 3.5.21.\n', ' * Github: madjarevicn\n', ' */\n', 'interface IMaintainersRegistry {\n', '    function isMaintainer(address _address) external view returns (bool);\n', '}\n', '\n', '\n', '// File contracts/ChainportMiddleware.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/**\n', ' * ChainportMiddleware contract.\n', ' * @author Nikola Madjarevic\n', ' * Date created: 4.5.21.\n', ' * Github: madjarevicn\n', ' */\n', 'contract ChainportMiddleware {\n', '\n', '    address public chainportCongress;\n', '    IMaintainersRegistry public maintainersRegistry;\n', '\n', '    // Only maintainer modifier\n', '    modifier onlyMaintainer {\n', '        require(maintainersRegistry.isMaintainer(msg.sender), "ChainportUpgradables: Restricted only to Maintainer");\n', '        _;\n', '    }\n', '\n', '    // Only chainport congress modifier\n', '    modifier onlyChainportCongress {\n', '        require(msg.sender == chainportCongress, "ChainportUpgradables: Restricted only to ChainportCongress");\n', '        _;\n', '    }\n', '\n', '    function setCongressAndMaintainers(\n', '        address _chainportCongress,\n', '        address _maintainersRegistry\n', '    )\n', '    internal\n', '    {\n', '        chainportCongress = _chainportCongress;\n', '        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);\n', '    }\n', '\n', '    function setMaintainersRegistry(\n', '        address _maintainersRegistry\n', '    )\n', '    public\n', '    onlyChainportCongress\n', '    {\n', '        maintainersRegistry = IMaintainersRegistry(_maintainersRegistry);\n', '    }\n', '}\n', '\n', '\n', '// File contracts/Validator.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '/**\n', ' * Validator contract.\n', ' * @author Nikola Madjarevic\n', ' * Date created: 3.5.21.\n', ' * Github: madjarevicn\n', ' */\n', 'contract Validator is Initializable, ChainportMiddleware {\n', '\n', '    address public signatoryAddress;\n', '\n', '    // Set initial signatory address and Chainport congress\n', '    function initialize(\n', '        address _signatoryAddress,\n', '        address _chainportCongress,\n', '        address _maintainersRegistry\n', '    )\n', '    public\n', '    initializer\n', '    {\n', '        signatoryAddress = _signatoryAddress;\n', '        setCongressAndMaintainers(_chainportCongress, _maintainersRegistry);\n', '    }\n', '\n', '    // Set / change signatory address\n', '    function setSignatoryAddress(\n', '        address _signatoryAddress\n', '    )\n', '    public\n', '    onlyChainportCongress\n', '    {\n', '        require(_signatoryAddress != address(0));\n', '        signatoryAddress = _signatoryAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice          Function to verify withdraw parameters and if signatory signed message\n', '     * @param           signedMessage is the message to verify\n', '     * @param           beneficiary is the address of user for who we signed message\n', '     * @param           token is the address of the token being withdrawn\n', '     * @param           amount is the amount of tokens user is attempting to withdraw\n', '     */\n', '    function verifyWithdraw(\n', '        bytes memory signedMessage,\n', '        address token,\n', '        uint256 amount,\n', '        address beneficiary,\n', '        uint256 nonce\n', '    )\n', '    external\n', '    view\n', '    returns (bool)\n', '    {\n', '        address messageSigner = recoverSignature(signedMessage, beneficiary, token, amount, nonce);\n', '        return messageSigner == signatoryAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice          Function to can check who signed the message\n', '     * @param           signedMessage is the message to verify\n', '     * @param           beneficiary is the address of user for who we signed message\n', '     * @param           token is the address of the token being withdrawn\n', '     * @param           amount is the amount of tokens user is attempting to withdraw\n', '     */\n', '    function recoverSignature(\n', '        bytes memory signedMessage,\n', '        address beneficiary,\n', '        address token,\n', '        uint256 amount,\n', '        uint256 nonce\n', '    )\n', '    public\n', '    pure\n', '    returns (address)\n', '    {\n', '        // Generate hash\n', '        bytes32 hash = keccak256(\n', '            abi.encodePacked(\n', "                keccak256(abi.encodePacked('bytes binding user withdrawal')),\n", '                keccak256(abi.encodePacked(beneficiary, token, amount, nonce))\n', '            )\n', '        );\n', '\n', '        // Recover signer message from signature\n', '        return recoverHash(hash,signedMessage,0);\n', '    }\n', '\n', '    /**\n', '     * @notice          Generalized recover sig for hash\n', '     * @dev             Built for easily integrating onwards with new contracts,\n', '     *                  since the message can be hashed on the another contract also.\n', '     * @param           hash is hash generated by encoding and hashing data\n', '     * @param           signature is the signature which should be verified.\n', '     */\n', '    function recoverSigFromHash(bytes32 hash, bytes memory signature)\n', '    public\n', '    view\n', '    returns (bool)\n', '    {\n', '        address signer = recoverHash(hash, signature, 0);\n', '        return signer == signatoryAddress;\n', '    }\n', '\n', '\n', '    function recoverHash(\n', '        bytes32 hash,\n', '        bytes memory sig,\n', '        uint idx\n', '    )\n', '    public\n', '    pure\n', '    returns (address)\n', '    {\n', '        // same as recoverHash in utils/sign.js\n', '        // The signature format is a compact form of:\n', '        //   {bytes32 r}{bytes32 s}{uint8 v}\n', '        // Compact means, uint8 is not padded to 32 bytes.\n', "        require (sig.length >= 65+idx, 'bad signature length');\n", '        idx += 32;\n', '        bytes32 r;\n', '        assembly\n', '        {\n', '            r := mload(add(sig, idx))\n', '        }\n', '\n', '        idx += 32;\n', '        bytes32 s;\n', '        assembly\n', '        {\n', '            s := mload(add(sig, idx))\n', '        }\n', '\n', '        idx += 1;\n', '        uint8 v;\n', '        assembly\n', '        {\n', '            v := mload(add(sig, idx))\n', '        }\n', '        if (v >= 32) { // handle case when signature was made with ethereum web3.eth.sign or getSign which is for signing ethereum transactions\n', '            v -= 32;\n', '            bytes memory prefix = "\\x19Ethereum Signed Message:\\n32"; // 32 is the number of bytes in the following hash\n', '            hash = keccak256(abi.encodePacked(prefix, hash));\n', '        }\n', '        if (v <= 1) v += 27;\n', "        require(v==27 || v==28,'bad sig v');\n", '        //https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol#L57\n', "        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, 'bad sig s');\n", '        return ecrecover(hash, v, r, s);\n', '\n', '    }\n', '\n', '}']