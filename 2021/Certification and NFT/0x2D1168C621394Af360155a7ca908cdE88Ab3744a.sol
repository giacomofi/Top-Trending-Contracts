['// SPDX-License-Identifier: MIT\n', '\n', '// P1 - P3: OK\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./AccessControl.sol";\n', '\n', 'import "./IUniswapV2.sol";\n', '\n', 'import "./BASKMakerHelpers.sol";\n', '\n', "// BaskMaker is MasterChef's left hand and kinda a wizard. He can cook up Bask from pretty much anything!\n", '// This contract handles "serving up" rewards for xBask holders by trading tokens collected from fees for Bask.\n', '\n', 'contract BASKMaker is BASKMakerHelpers, AccessControl {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IUniswapV2Factory constant sushiswapFactory = IUniswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n', '    IUniswapV2Factory constant uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n', '\n', '    mapping(address => address) internal _bridges;\n', '    mapping(bytes32 => address) internal _factories;\n', '\n', '    event LogFactorySet(address indexed fromToken, address indexed toToken, address indexed factory);\n', '    event LogBridgeSet(address indexed token, address indexed bridge);\n', '    event LogConvert(address indexed server, address indexed token0, uint256 amount0, uint256 amountBASK);\n', '\n', '    // Roles\n', '    bytes32 public constant MARKET_MAKER = keccak256("baskmaker.access.marketMaker");\n', '    bytes32 public constant MARKET_MAKER_ADMIN = keccak256("baskmaker.access.marketMaker.admin");\n', '\n', '    constructor(address _admin) {\n', '        _setRoleAdmin(MARKET_MAKER, MARKET_MAKER_ADMIN);\n', '        _setupRole(MARKET_MAKER_ADMIN, _admin);\n', '        _setupRole(MARKET_MAKER, _admin);\n', '        _setupRole(MARKET_MAKER, msg.sender);\n', '\n', '        setFactory(KNC, WETH, address(uniswapFactory));\n', '        setFactory(LRC, WETH, address(uniswapFactory));\n', '        setFactory(BAL, WETH, address(uniswapFactory));\n', '        setFactory(MTA, WETH, address(uniswapFactory));\n', '    }\n', '\n', '    // **** Modifiers ****\n', '\n', '    modifier onlyEOA() {\n', '        // Try to make flash-loan exploit harder to do by only allowing externally owned addresses.\n', '        require(msg.sender == tx.origin, "BaskMaker: must use EOA");\n', '        _;\n', '    }\n', '\n', '    modifier authorized() {\n', '        require(hasRole(MARKET_MAKER, msg.sender), "!authorized");\n', '        _;\n', '    }\n', '\n', '    // **** Stateless functions ****\n', '\n', '    function bridgeFor(address token) public view returns (address bridge) {\n', '        bridge = _bridges[token];\n', '        if (bridge == address(0)) {\n', '            bridge = WETH;\n', '        }\n', '    }\n', '\n', '    function factoryFor(address fromToken, address toToken) public view returns (address factory) {\n', '        bytes32 h = keccak256(abi.encode(fromToken, toToken));\n', '        factory = _factories[h];\n', '        if (factory == address(0)) {\n', '            factory = address(sushiswapFactory);\n', '        }\n', '    }\n', '\n', '    // **** Restricted functions ***\n', '\n', '    function setBridge(address token, address bridge) external authorized {\n', '        require(token != BASK && token != WETH && token != bridge, "BaskMaker: Invalid bridge");\n', '        // Effects\n', '        _bridges[token] = bridge;\n', '        emit LogBridgeSet(token, bridge);\n', '    }\n', '\n', '    function setFactory(\n', '        address fromToken,\n', '        address toToken,\n', '        address factory\n', '    ) public authorized {\n', '        require(\n', '            factory == address(sushiswapFactory) || factory == address(uniswapFactory),\n', '            "BaskMaker: Invalid factory"\n', '        );\n', '\n', '        // Effects\n', '        _factories[keccak256(abi.encode(fromToken, toToken))] = factory;\n', '        LogFactorySet(fromToken, toToken, factory);\n', '    }\n', '\n', '    // Burn BDPI and future baskets\n', '    function burn(address _token) external authorized {\n', '        uint256 _amount = IERC20(_token).balanceOf(address(this));\n', '        (bool success, ) = _token.call(abi.encodeWithSignature("burn(uint256)", _amount));\n', '        require(success, "!success");\n', '    }\n', '\n', '    function rescueERC20(address _token) external authorized {\n', '        uint256 _amount = IERC20(_token).balanceOf(address(this));\n', '        IERC20(_token).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    // F1 - F10: OK\n', "    // F3: _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple\n", '    // F6: There is an exploit to add lots of BASK to the xbask, run convert, then remove the BASK again.\n', "    //     As the size of the BaskBar has grown, this requires large amounts of funds and isn't super profitable anymore\n", '    //     The onlyEOA modifier prevents this being done with a flash loan.\n', '    // C1 - C24: OK\n', '    function convert(address token) external onlyEOA() {\n', '        _convert(token);\n', '    }\n', '\n', '    // F1 - F10: OK, see convert\n', '    // C1 - C24: OK\n', '    // C3: Loop is under control of the caller\n', '    function convertMultiple(address[] calldata tokens) external onlyEOA() {\n', '        // TODO: This can be optimized a fair bit, but this is safer and simpler for now\n', '        uint256 len = tokens.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            _convert(tokens[i]);\n', '        }\n', '    }\n', '\n', '    // **** Internal functions ****\n', '\n', '    // F1 - F10: OK\n', '    // C1- C24: OK\n', '    function _convert(address token) internal {\n', '        address token0 = _toUnderlying(token);\n', '        uint256 amount0 = IERC20(token0).balanceOf(address(this));\n', '\n', '        emit LogConvert(msg.sender, token0, amount0, _convertStep(token0, amount0));\n', '    }\n', '\n', '    // F1 - F10: OK\n', '    // C1 - C24: OK\n', '    // All safeTransfer, _swap, _toBASK, _convertStep: X1 - X5: OK\n', '    function _convertStep(address token, uint256 amount) internal returns (uint256) {\n', '        // Final case\n', '        if (token == WETH) {\n', '            return _toBASK(token, amount);\n', '        }\n', '\n', '        // Otherwise keep converting\n', '        address bridge = bridgeFor(token);\n', '        uint256 amountOut = _swap(token, bridge, amount, address(this));\n', '        return _convertStep(bridge, amountOut);\n', '    }\n', '\n', '    // F1 - F10: OK\n', '    // C1 - C24: OK\n', '    // All safeTransfer, swap: X1 - X5: OK\n', '    function _swap(\n', '        address fromToken,\n', '        address toToken,\n', '        uint256 amountIn,\n', '        address to\n', '    ) internal returns (uint256 amountOut) {\n', '        // Checks\n', '        // X1 - X5: OK\n', '        IUniswapV2Pair pair =\n', '            IUniswapV2Pair(IUniswapV2Factory(factoryFor(fromToken, toToken)).getPair(fromToken, toToken));\n', '        require(address(pair) != address(0), "BaskMaker: Cannot convert");\n', '\n', '        // Interactions\n', '        // X1 - X5: OK\n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '        uint256 amountInWithFee = amountIn.mul(997);\n', '        if (fromToken == pair.token0()) {\n', '            amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(0, amountOut, to, new bytes(0));\n', '            // TODO: Add maximum slippage?\n', '        } else {\n', '            amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(amountOut, 0, to, new bytes(0));\n', '            // TODO: Add maximum slippage?\n', '        }\n', '    }\n', '\n', '    // F1 - F10: OK\n', '    // C1 - C24: OK\n', '    function _toBASK(address token, uint256 amountIn) internal returns (uint256 amountOut) {\n', '        // X1 - X5: OK\n', '        amountOut = _swap(token, BASK, amountIn, XBASK);\n', '    }\n', '}']