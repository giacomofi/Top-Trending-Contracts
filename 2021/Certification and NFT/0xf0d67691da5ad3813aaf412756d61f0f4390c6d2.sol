['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '// File: @openzeppelin/upgrades-core/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/SafeCast.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IPowerOracle.sol\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IPowerOracle {\n', '  enum ReportInterval { LESS_THAN_MIN, OK, GREATER_THAN_MAX }\n', '\n', '  function pokeFromReporter(\n', '    uint256 reporterId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external;\n', '\n', '  function pokeFromSlasher(\n', '    uint256 slasherId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external;\n', '\n', '  function poke(string[] memory symbols_) external;\n', '\n', '  function slasherHeartbeat(uint256 slasherId) external;\n', '\n', '  /*** Owner Interface ***/\n', '  function setPowerPoke(address powerOracleStaking) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** Viewers ***/\n', '  function getPriceByAsset(address token) external view returns (uint256);\n', '\n', '  function getPriceBySymbol(string calldata symbol) external view returns (uint256);\n', '\n', '  function getPriceBySymbolHash(bytes32 symbolHash) external view returns (uint256);\n', '\n', '  function getUnderlyingPrice(address cToken) external view returns (uint256);\n', '\n', '  function assetPrices(address token) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/interfaces/IPowerPoke.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPowerPoke {\n', "  /*** CLIENT'S CONTRACT INTERFACE ***/\n", '  function authorizeReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporterWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinDeposit_\n', '  ) external view;\n', '\n', '  function authorizePoker(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizePokerWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinStake_\n', '  ) external view;\n', '\n', '  function slashReporter(uint256 slasherId_, uint256 times_) external;\n', '\n', '  function reward(\n', '    uint256 userId_,\n', '    uint256 gasUsed_,\n', '    uint256 compensationPlan_,\n', '    bytes calldata pokeOptions_\n', '  ) external;\n', '\n', '  /*** CLIENT OWNER INTERFACE ***/\n', '  function transferClientOwnership(address client_, address to_) external;\n', '\n', '  function addCredit(address client_, uint256 amount_) external;\n', '\n', '  function withdrawCredit(\n', '    address client_,\n', '    address to_,\n', '    uint256 amount_\n', '  ) external;\n', '\n', '  function setReportIntervals(\n', '    address client_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;\n', '\n', '  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;\n', '\n', '  function setFixedCompensations(\n', '    address client_,\n', '    uint256 eth_,\n', '    uint256 cvp_\n', '  ) external;\n', '\n', '  function setBonusPlan(\n', '    address client_,\n', '    uint256 planId_,\n', '    bool active_,\n', '    uint64 bonusNominator_,\n', '    uint64 bonusDenominator_,\n', '    uint64 perGas_\n', '  ) external;\n', '\n', '  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;\n', '\n', '  /*** POKER INTERFACE ***/\n', '  function withdrawRewards(uint256 userId_, address to_) external;\n', '\n', '  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;\n', '\n', '  /*** OWNER INTERFACE ***/\n', '  function addClient(\n', '    address client_,\n', '    address owner_,\n', '    bool canSlash_,\n', '    uint256 gasPriceLimit_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setClientActiveFlag(address client_, bool active_) external;\n', '\n', '  function setCanSlashFlag(address client_, bool canSlash) external;\n', '\n', '  function setOracle(address oracle_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** GETTERS ***/\n', '  function creditOf(address client_) external view returns (uint256);\n', '\n', '  function ownerOf(address client_) external view returns (address);\n', '\n', '  function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);\n', '\n', '  function getSlasherHeartbeat(address client_) external view returns (uint256);\n', '\n', '  function getGasPriceLimit(address client_) external view returns (uint256);\n', '\n', '  function getPokerBonus(\n', '    address client_,\n', '    uint256 bonusPlanId_,\n', '    uint256 gasUsed_,\n', '    uint256 userDeposit_\n', '  ) external view returns (uint256);\n', '\n', '  function getGasPriceFor(address client_) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/PowerOracleStorageV1.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', 'contract PowerOracleStorageV1 {\n', '  struct Price {\n', '    uint128 timestamp;\n', '    uint128 value;\n', '  }\n', '\n', '  struct Observation {\n', '    uint256 timestamp;\n', '    uint256 acc;\n', '  }\n', '\n', '  /// @notice The linked PowerOracleStaking contract address\n', '  IPowerPoke public powerPoke;\n', '\n', '  /// @notice Official prices and timestamps by symbol hash\n', '  mapping(bytes32 => Price) public prices;\n', '\n', '  /// @notice Last slasher update time by a user ID\n', '  mapping(uint256 => uint256) public lastSlasherUpdates;\n', '\n', '  /// @notice The old observation for each symbolHash\n', '  mapping(bytes32 => Observation) public oldObservations;\n', '\n', '  /// @notice The new observation for each symbolHash\n', '  mapping(bytes32 => Observation) public newObservations;\n', '}\n', '\n', '// File: contracts/Uniswap/UniswapConfig.sol\n', '\n', 'pragma solidity ^0.6.10;\n', '\n', 'interface CErc20 {\n', '    function underlying() external view returns (address);\n', '}\n', '\n', 'contract UniswapConfig {\n', '    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n', '    enum PriceSource {\n', '        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n', '        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n', '        REPORTER   /// implies the price is set by the reporter\n', '    }\n', '\n', '    /// @dev Describe how the USD price should be determined for an asset.\n', '    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n', '    struct TokenConfig {\n', '        address cToken;\n', '        address underlying;\n', '        bytes32 symbolHash;\n', '        uint256 baseUnit;\n', '        PriceSource priceSource;\n', '        uint256 fixedPrice;\n', '        address uniswapMarket;\n', '        bool isUniswapReversed;\n', '    }\n', '\n', '    /// @notice The max number of tokens this contract is hardcoded to support\n', '    /// @dev Do not change this variable without updating all the fields throughout the contract.\n', '    uint public constant maxTokens = 21;\n', '\n', '    /// @notice The number of tokens this contract actually supports\n', '    uint public immutable numTokens;\n', '\n', '    address internal immutable cToken00;\n', '    address internal immutable cToken01;\n', '    address internal immutable cToken02;\n', '    address internal immutable cToken03;\n', '    address internal immutable cToken04;\n', '    address internal immutable cToken05;\n', '    address internal immutable cToken06;\n', '    address internal immutable cToken07;\n', '    address internal immutable cToken08;\n', '    address internal immutable cToken09;\n', '    address internal immutable cToken10;\n', '    address internal immutable cToken11;\n', '    address internal immutable cToken12;\n', '    address internal immutable cToken13;\n', '    address internal immutable cToken14;\n', '    address internal immutable cToken15;\n', '    address internal immutable cToken16;\n', '    address internal immutable cToken17;\n', '    address internal immutable cToken18;\n', '    address internal immutable cToken19;\n', '    address internal immutable cToken20;\n', '//    address internal immutable cToken21;\n', '//    address internal immutable cToken22;\n', '//    address internal immutable cToken23;\n', '//    address internal immutable cToken24;\n', '//    address internal immutable cToken25;\n', '//    address internal immutable cToken26;\n', '//    address internal immutable cToken27;\n', '//    address internal immutable cToken28;\n', '//    address internal immutable cToken29;\n', '\n', '    address internal immutable underlying00;\n', '    address internal immutable underlying01;\n', '    address internal immutable underlying02;\n', '    address internal immutable underlying03;\n', '    address internal immutable underlying04;\n', '    address internal immutable underlying05;\n', '    address internal immutable underlying06;\n', '    address internal immutable underlying07;\n', '    address internal immutable underlying08;\n', '    address internal immutable underlying09;\n', '    address internal immutable underlying10;\n', '    address internal immutable underlying11;\n', '    address internal immutable underlying12;\n', '    address internal immutable underlying13;\n', '    address internal immutable underlying14;\n', '    address internal immutable underlying15;\n', '    address internal immutable underlying16;\n', '    address internal immutable underlying17;\n', '    address internal immutable underlying18;\n', '    address internal immutable underlying19;\n', '    address internal immutable underlying20;\n', '//    address internal immutable underlying21;\n', '//    address internal immutable underlying22;\n', '//    address internal immutable underlying23;\n', '//    address internal immutable underlying24;\n', '//    address internal immutable underlying25;\n', '//    address internal immutable underlying26;\n', '//    address internal immutable underlying27;\n', '//    address internal immutable underlying28;\n', '//    address internal immutable underlying29;\n', '\n', '    bytes32 internal immutable symbolHash00;\n', '    bytes32 internal immutable symbolHash01;\n', '    bytes32 internal immutable symbolHash02;\n', '    bytes32 internal immutable symbolHash03;\n', '    bytes32 internal immutable symbolHash04;\n', '    bytes32 internal immutable symbolHash05;\n', '    bytes32 internal immutable symbolHash06;\n', '    bytes32 internal immutable symbolHash07;\n', '    bytes32 internal immutable symbolHash08;\n', '    bytes32 internal immutable symbolHash09;\n', '    bytes32 internal immutable symbolHash10;\n', '    bytes32 internal immutable symbolHash11;\n', '    bytes32 internal immutable symbolHash12;\n', '    bytes32 internal immutable symbolHash13;\n', '    bytes32 internal immutable symbolHash14;\n', '    bytes32 internal immutable symbolHash15;\n', '    bytes32 internal immutable symbolHash16;\n', '    bytes32 internal immutable symbolHash17;\n', '    bytes32 internal immutable symbolHash18;\n', '    bytes32 internal immutable symbolHash19;\n', '    bytes32 internal immutable symbolHash20;\n', '//    bytes32 internal immutable symbolHash21;\n', '//    bytes32 internal immutable symbolHash22;\n', '//    bytes32 internal immutable symbolHash23;\n', '//    bytes32 internal immutable symbolHash24;\n', '//    bytes32 internal immutable symbolHash25;\n', '//    bytes32 internal immutable symbolHash26;\n', '//    bytes32 internal immutable symbolHash27;\n', '//    bytes32 internal immutable symbolHash28;\n', '//    bytes32 internal immutable symbolHash29;\n', '\n', '    uint256 internal immutable baseUnit00;\n', '    uint256 internal immutable baseUnit01;\n', '    uint256 internal immutable baseUnit02;\n', '    uint256 internal immutable baseUnit03;\n', '    uint256 internal immutable baseUnit04;\n', '    uint256 internal immutable baseUnit05;\n', '    uint256 internal immutable baseUnit06;\n', '    uint256 internal immutable baseUnit07;\n', '    uint256 internal immutable baseUnit08;\n', '    uint256 internal immutable baseUnit09;\n', '    uint256 internal immutable baseUnit10;\n', '    uint256 internal immutable baseUnit11;\n', '    uint256 internal immutable baseUnit12;\n', '    uint256 internal immutable baseUnit13;\n', '    uint256 internal immutable baseUnit14;\n', '    uint256 internal immutable baseUnit15;\n', '    uint256 internal immutable baseUnit16;\n', '    uint256 internal immutable baseUnit17;\n', '    uint256 internal immutable baseUnit18;\n', '    uint256 internal immutable baseUnit19;\n', '    uint256 internal immutable baseUnit20;\n', '//    uint256 internal immutable baseUnit21;\n', '//    uint256 internal immutable baseUnit22;\n', '//    uint256 internal immutable baseUnit23;\n', '//    uint256 internal immutable baseUnit24;\n', '//    uint256 internal immutable baseUnit25;\n', '//    uint256 internal immutable baseUnit26;\n', '//    uint256 internal immutable baseUnit27;\n', '//    uint256 internal immutable baseUnit28;\n', '//    uint256 internal immutable baseUnit29;\n', '\n', '    PriceSource internal immutable priceSource00;\n', '    PriceSource internal immutable priceSource01;\n', '    PriceSource internal immutable priceSource02;\n', '    PriceSource internal immutable priceSource03;\n', '    PriceSource internal immutable priceSource04;\n', '    PriceSource internal immutable priceSource05;\n', '    PriceSource internal immutable priceSource06;\n', '    PriceSource internal immutable priceSource07;\n', '    PriceSource internal immutable priceSource08;\n', '    PriceSource internal immutable priceSource09;\n', '    PriceSource internal immutable priceSource10;\n', '    PriceSource internal immutable priceSource11;\n', '    PriceSource internal immutable priceSource12;\n', '    PriceSource internal immutable priceSource13;\n', '    PriceSource internal immutable priceSource14;\n', '    PriceSource internal immutable priceSource15;\n', '    PriceSource internal immutable priceSource16;\n', '    PriceSource internal immutable priceSource17;\n', '    PriceSource internal immutable priceSource18;\n', '    PriceSource internal immutable priceSource19;\n', '    PriceSource internal immutable priceSource20;\n', '//    PriceSource internal immutable priceSource21;\n', '//    PriceSource internal immutable priceSource22;\n', '//    PriceSource internal immutable priceSource23;\n', '//    PriceSource internal immutable priceSource24;\n', '//    PriceSource internal immutable priceSource25;\n', '//    PriceSource internal immutable priceSource26;\n', '//    PriceSource internal immutable priceSource27;\n', '//    PriceSource internal immutable priceSource28;\n', '//    PriceSource internal immutable priceSource29;\n', '\n', '    uint256 internal immutable fixedPrice00;\n', '    uint256 internal immutable fixedPrice01;\n', '    uint256 internal immutable fixedPrice02;\n', '    uint256 internal immutable fixedPrice03;\n', '    uint256 internal immutable fixedPrice04;\n', '    uint256 internal immutable fixedPrice05;\n', '    uint256 internal immutable fixedPrice06;\n', '    uint256 internal immutable fixedPrice07;\n', '    uint256 internal immutable fixedPrice08;\n', '    uint256 internal immutable fixedPrice09;\n', '    uint256 internal immutable fixedPrice10;\n', '    uint256 internal immutable fixedPrice11;\n', '    uint256 internal immutable fixedPrice12;\n', '    uint256 internal immutable fixedPrice13;\n', '    uint256 internal immutable fixedPrice14;\n', '    uint256 internal immutable fixedPrice15;\n', '    uint256 internal immutable fixedPrice16;\n', '    uint256 internal immutable fixedPrice17;\n', '    uint256 internal immutable fixedPrice18;\n', '    uint256 internal immutable fixedPrice19;\n', '    uint256 internal immutable fixedPrice20;\n', '//    uint256 internal immutable fixedPrice21;\n', '//    uint256 internal immutable fixedPrice22;\n', '//    uint256 internal immutable fixedPrice23;\n', '//    uint256 internal immutable fixedPrice24;\n', '//    uint256 internal immutable fixedPrice25;\n', '//    uint256 internal immutable fixedPrice26;\n', '//    uint256 internal immutable fixedPrice27;\n', '//    uint256 internal immutable fixedPrice28;\n', '//    uint256 internal immutable fixedPrice29;\n', '\n', '    address internal immutable uniswapMarket00;\n', '    address internal immutable uniswapMarket01;\n', '    address internal immutable uniswapMarket02;\n', '    address internal immutable uniswapMarket03;\n', '    address internal immutable uniswapMarket04;\n', '    address internal immutable uniswapMarket05;\n', '    address internal immutable uniswapMarket06;\n', '    address internal immutable uniswapMarket07;\n', '    address internal immutable uniswapMarket08;\n', '    address internal immutable uniswapMarket09;\n', '    address internal immutable uniswapMarket10;\n', '    address internal immutable uniswapMarket11;\n', '    address internal immutable uniswapMarket12;\n', '    address internal immutable uniswapMarket13;\n', '    address internal immutable uniswapMarket14;\n', '    address internal immutable uniswapMarket15;\n', '    address internal immutable uniswapMarket16;\n', '    address internal immutable uniswapMarket17;\n', '    address internal immutable uniswapMarket18;\n', '    address internal immutable uniswapMarket19;\n', '    address internal immutable uniswapMarket20;\n', '//    address internal immutable uniswapMarket21;\n', '//    address internal immutable uniswapMarket22;\n', '//    address internal immutable uniswapMarket23;\n', '//    address internal immutable uniswapMarket24;\n', '//    address internal immutable uniswapMarket25;\n', '//    address internal immutable uniswapMarket26;\n', '//    address internal immutable uniswapMarket27;\n', '//    address internal immutable uniswapMarket28;\n', '//    address internal immutable uniswapMarket29;\n', '\n', '    bool internal immutable isUniswapReversed00;\n', '    bool internal immutable isUniswapReversed01;\n', '    bool internal immutable isUniswapReversed02;\n', '    bool internal immutable isUniswapReversed03;\n', '    bool internal immutable isUniswapReversed04;\n', '    bool internal immutable isUniswapReversed05;\n', '    bool internal immutable isUniswapReversed06;\n', '    bool internal immutable isUniswapReversed07;\n', '    bool internal immutable isUniswapReversed08;\n', '    bool internal immutable isUniswapReversed09;\n', '    bool internal immutable isUniswapReversed10;\n', '    bool internal immutable isUniswapReversed11;\n', '    bool internal immutable isUniswapReversed12;\n', '    bool internal immutable isUniswapReversed13;\n', '    bool internal immutable isUniswapReversed14;\n', '    bool internal immutable isUniswapReversed15;\n', '    bool internal immutable isUniswapReversed16;\n', '    bool internal immutable isUniswapReversed17;\n', '    bool internal immutable isUniswapReversed18;\n', '    bool internal immutable isUniswapReversed19;\n', '    bool internal immutable isUniswapReversed20;\n', '//    bool internal immutable isUniswapReversed21;\n', '//    bool internal immutable isUniswapReversed22;\n', '//    bool internal immutable isUniswapReversed23;\n', '//    bool internal immutable isUniswapReversed24;\n', '//    bool internal immutable isUniswapReversed25;\n', '//    bool internal immutable isUniswapReversed26;\n', '//    bool internal immutable isUniswapReversed27;\n', '//    bool internal immutable isUniswapReversed28;\n', '//    bool internal immutable isUniswapReversed29;\n', '\n', '    /**\n', '     * @notice Construct an immutable store of configs into the contract data\n', '     * @param configs The configs for the supported assets\n', '     */\n', '    constructor(TokenConfig[] memory configs) public {\n', '        require(configs.length <= maxTokens, "MAX_TOKENS");\n', '        numTokens = configs.length;\n', '\n', '        cToken00 = get(configs, 0).cToken;\n', '        cToken01 = get(configs, 1).cToken;\n', '        cToken02 = get(configs, 2).cToken;\n', '        cToken03 = get(configs, 3).cToken;\n', '        cToken04 = get(configs, 4).cToken;\n', '        cToken05 = get(configs, 5).cToken;\n', '        cToken06 = get(configs, 6).cToken;\n', '        cToken07 = get(configs, 7).cToken;\n', '        cToken08 = get(configs, 8).cToken;\n', '        cToken09 = get(configs, 9).cToken;\n', '        cToken10 = get(configs, 10).cToken;\n', '        cToken11 = get(configs, 11).cToken;\n', '        cToken12 = get(configs, 12).cToken;\n', '        cToken13 = get(configs, 13).cToken;\n', '        cToken14 = get(configs, 14).cToken;\n', '        cToken15 = get(configs, 15).cToken;\n', '        cToken16 = get(configs, 16).cToken;\n', '        cToken17 = get(configs, 17).cToken;\n', '        cToken18 = get(configs, 18).cToken;\n', '        cToken19 = get(configs, 19).cToken;\n', '        cToken20 = get(configs, 20).cToken;\n', '//        cToken21 = get(configs, 21).cToken;\n', '//        cToken22 = get(configs, 22).cToken;\n', '//        cToken23 = get(configs, 23).cToken;\n', '//        cToken24 = get(configs, 24).cToken;\n', '//        cToken25 = get(configs, 25).cToken;\n', '//        cToken26 = get(configs, 26).cToken;\n', '//        cToken27 = get(configs, 27).cToken;\n', '//        cToken28 = get(configs, 28).cToken;\n', '//        cToken29 = get(configs, 29).cToken;\n', '\n', '        underlying00 = get(configs, 0).underlying;\n', '        underlying01 = get(configs, 1).underlying;\n', '        underlying02 = get(configs, 2).underlying;\n', '        underlying03 = get(configs, 3).underlying;\n', '        underlying04 = get(configs, 4).underlying;\n', '        underlying05 = get(configs, 5).underlying;\n', '        underlying06 = get(configs, 6).underlying;\n', '        underlying07 = get(configs, 7).underlying;\n', '        underlying08 = get(configs, 8).underlying;\n', '        underlying09 = get(configs, 9).underlying;\n', '        underlying10 = get(configs, 10).underlying;\n', '        underlying11 = get(configs, 11).underlying;\n', '        underlying12 = get(configs, 12).underlying;\n', '        underlying13 = get(configs, 13).underlying;\n', '        underlying14 = get(configs, 14).underlying;\n', '        underlying15 = get(configs, 15).underlying;\n', '        underlying16 = get(configs, 16).underlying;\n', '        underlying17 = get(configs, 17).underlying;\n', '        underlying18 = get(configs, 18).underlying;\n', '        underlying19 = get(configs, 19).underlying;\n', '        underlying20 = get(configs, 20).underlying;\n', '//        underlying21 = get(configs, 21).underlying;\n', '//        underlying22 = get(configs, 22).underlying;\n', '//        underlying23 = get(configs, 23).underlying;\n', '//        underlying24 = get(configs, 24).underlying;\n', '//        underlying25 = get(configs, 25).underlying;\n', '//        underlying26 = get(configs, 26).underlying;\n', '//        underlying27 = get(configs, 27).underlying;\n', '//        underlying28 = get(configs, 28).underlying;\n', '//        underlying29 = get(configs, 29).underlying;\n', '\n', '        symbolHash00 = get(configs, 0).symbolHash;\n', '        symbolHash01 = get(configs, 1).symbolHash;\n', '        symbolHash02 = get(configs, 2).symbolHash;\n', '        symbolHash03 = get(configs, 3).symbolHash;\n', '        symbolHash04 = get(configs, 4).symbolHash;\n', '        symbolHash05 = get(configs, 5).symbolHash;\n', '        symbolHash06 = get(configs, 6).symbolHash;\n', '        symbolHash07 = get(configs, 7).symbolHash;\n', '        symbolHash08 = get(configs, 8).symbolHash;\n', '        symbolHash09 = get(configs, 9).symbolHash;\n', '        symbolHash10 = get(configs, 10).symbolHash;\n', '        symbolHash11 = get(configs, 11).symbolHash;\n', '        symbolHash12 = get(configs, 12).symbolHash;\n', '        symbolHash13 = get(configs, 13).symbolHash;\n', '        symbolHash14 = get(configs, 14).symbolHash;\n', '        symbolHash15 = get(configs, 15).symbolHash;\n', '        symbolHash16 = get(configs, 16).symbolHash;\n', '        symbolHash17 = get(configs, 17).symbolHash;\n', '        symbolHash18 = get(configs, 18).symbolHash;\n', '        symbolHash19 = get(configs, 19).symbolHash;\n', '        symbolHash20 = get(configs, 20).symbolHash;\n', '//        symbolHash21 = get(configs, 21).symbolHash;\n', '//        symbolHash22 = get(configs, 22).symbolHash;\n', '//        symbolHash23 = get(configs, 23).symbolHash;\n', '//        symbolHash24 = get(configs, 24).symbolHash;\n', '//        symbolHash25 = get(configs, 25).symbolHash;\n', '//        symbolHash26 = get(configs, 26).symbolHash;\n', '//        symbolHash27 = get(configs, 27).symbolHash;\n', '//        symbolHash28 = get(configs, 28).symbolHash;\n', '//        symbolHash29 = get(configs, 29).symbolHash;\n', '\n', '        baseUnit00 = get(configs, 0).baseUnit;\n', '        baseUnit01 = get(configs, 1).baseUnit;\n', '        baseUnit02 = get(configs, 2).baseUnit;\n', '        baseUnit03 = get(configs, 3).baseUnit;\n', '        baseUnit04 = get(configs, 4).baseUnit;\n', '        baseUnit05 = get(configs, 5).baseUnit;\n', '        baseUnit06 = get(configs, 6).baseUnit;\n', '        baseUnit07 = get(configs, 7).baseUnit;\n', '        baseUnit08 = get(configs, 8).baseUnit;\n', '        baseUnit09 = get(configs, 9).baseUnit;\n', '        baseUnit10 = get(configs, 10).baseUnit;\n', '        baseUnit11 = get(configs, 11).baseUnit;\n', '        baseUnit12 = get(configs, 12).baseUnit;\n', '        baseUnit13 = get(configs, 13).baseUnit;\n', '        baseUnit14 = get(configs, 14).baseUnit;\n', '        baseUnit15 = get(configs, 15).baseUnit;\n', '        baseUnit16 = get(configs, 16).baseUnit;\n', '        baseUnit17 = get(configs, 17).baseUnit;\n', '        baseUnit18 = get(configs, 18).baseUnit;\n', '        baseUnit19 = get(configs, 19).baseUnit;\n', '        baseUnit20 = get(configs, 20).baseUnit;\n', '//        baseUnit21 = get(configs, 21).baseUnit;\n', '//        baseUnit22 = get(configs, 22).baseUnit;\n', '//        baseUnit23 = get(configs, 23).baseUnit;\n', '//        baseUnit24 = get(configs, 24).baseUnit;\n', '//        baseUnit25 = get(configs, 25).baseUnit;\n', '//        baseUnit26 = get(configs, 26).baseUnit;\n', '//        baseUnit27 = get(configs, 27).baseUnit;\n', '//        baseUnit28 = get(configs, 28).baseUnit;\n', '//        baseUnit29 = get(configs, 29).baseUnit;\n', '\n', '        priceSource00 = get(configs, 0).priceSource;\n', '        priceSource01 = get(configs, 1).priceSource;\n', '        priceSource02 = get(configs, 2).priceSource;\n', '        priceSource03 = get(configs, 3).priceSource;\n', '        priceSource04 = get(configs, 4).priceSource;\n', '        priceSource05 = get(configs, 5).priceSource;\n', '        priceSource06 = get(configs, 6).priceSource;\n', '        priceSource07 = get(configs, 7).priceSource;\n', '        priceSource08 = get(configs, 8).priceSource;\n', '        priceSource09 = get(configs, 9).priceSource;\n', '        priceSource10 = get(configs, 10).priceSource;\n', '        priceSource11 = get(configs, 11).priceSource;\n', '        priceSource12 = get(configs, 12).priceSource;\n', '        priceSource13 = get(configs, 13).priceSource;\n', '        priceSource14 = get(configs, 14).priceSource;\n', '        priceSource15 = get(configs, 15).priceSource;\n', '        priceSource16 = get(configs, 16).priceSource;\n', '        priceSource17 = get(configs, 17).priceSource;\n', '        priceSource18 = get(configs, 18).priceSource;\n', '        priceSource19 = get(configs, 19).priceSource;\n', '        priceSource20 = get(configs, 20).priceSource;\n', '//        priceSource21 = get(configs, 21).priceSource;\n', '//        priceSource22 = get(configs, 22).priceSource;\n', '//        priceSource23 = get(configs, 23).priceSource;\n', '//        priceSource24 = get(configs, 24).priceSource;\n', '//        priceSource25 = get(configs, 25).priceSource;\n', '//        priceSource26 = get(configs, 26).priceSource;\n', '//        priceSource27 = get(configs, 27).priceSource;\n', '//        priceSource28 = get(configs, 28).priceSource;\n', '//        priceSource29 = get(configs, 29).priceSource;\n', '\n', '        fixedPrice00 = get(configs, 0).fixedPrice;\n', '        fixedPrice01 = get(configs, 1).fixedPrice;\n', '        fixedPrice02 = get(configs, 2).fixedPrice;\n', '        fixedPrice03 = get(configs, 3).fixedPrice;\n', '        fixedPrice04 = get(configs, 4).fixedPrice;\n', '        fixedPrice05 = get(configs, 5).fixedPrice;\n', '        fixedPrice06 = get(configs, 6).fixedPrice;\n', '        fixedPrice07 = get(configs, 7).fixedPrice;\n', '        fixedPrice08 = get(configs, 8).fixedPrice;\n', '        fixedPrice09 = get(configs, 9).fixedPrice;\n', '        fixedPrice10 = get(configs, 10).fixedPrice;\n', '        fixedPrice11 = get(configs, 11).fixedPrice;\n', '        fixedPrice12 = get(configs, 12).fixedPrice;\n', '        fixedPrice13 = get(configs, 13).fixedPrice;\n', '        fixedPrice14 = get(configs, 14).fixedPrice;\n', '        fixedPrice15 = get(configs, 15).fixedPrice;\n', '        fixedPrice16 = get(configs, 16).fixedPrice;\n', '        fixedPrice17 = get(configs, 17).fixedPrice;\n', '        fixedPrice18 = get(configs, 18).fixedPrice;\n', '        fixedPrice19 = get(configs, 19).fixedPrice;\n', '        fixedPrice20 = get(configs, 20).fixedPrice;\n', '//        fixedPrice21 = get(configs, 21).fixedPrice;\n', '//        fixedPrice22 = get(configs, 22).fixedPrice;\n', '//        fixedPrice23 = get(configs, 23).fixedPrice;\n', '//        fixedPrice24 = get(configs, 24).fixedPrice;\n', '//        fixedPrice25 = get(configs, 25).fixedPrice;\n', '//        fixedPrice26 = get(configs, 26).fixedPrice;\n', '//        fixedPrice27 = get(configs, 27).fixedPrice;\n', '//        fixedPrice28 = get(configs, 28).fixedPrice;\n', '//        fixedPrice29 = get(configs, 29).fixedPrice;\n', '\n', '        uniswapMarket00 = get(configs, 0).uniswapMarket;\n', '        uniswapMarket01 = get(configs, 1).uniswapMarket;\n', '        uniswapMarket02 = get(configs, 2).uniswapMarket;\n', '        uniswapMarket03 = get(configs, 3).uniswapMarket;\n', '        uniswapMarket04 = get(configs, 4).uniswapMarket;\n', '        uniswapMarket05 = get(configs, 5).uniswapMarket;\n', '        uniswapMarket06 = get(configs, 6).uniswapMarket;\n', '        uniswapMarket07 = get(configs, 7).uniswapMarket;\n', '        uniswapMarket08 = get(configs, 8).uniswapMarket;\n', '        uniswapMarket09 = get(configs, 9).uniswapMarket;\n', '        uniswapMarket10 = get(configs, 10).uniswapMarket;\n', '        uniswapMarket11 = get(configs, 11).uniswapMarket;\n', '        uniswapMarket12 = get(configs, 12).uniswapMarket;\n', '        uniswapMarket13 = get(configs, 13).uniswapMarket;\n', '        uniswapMarket14 = get(configs, 14).uniswapMarket;\n', '        uniswapMarket15 = get(configs, 15).uniswapMarket;\n', '        uniswapMarket16 = get(configs, 16).uniswapMarket;\n', '        uniswapMarket17 = get(configs, 17).uniswapMarket;\n', '        uniswapMarket18 = get(configs, 18).uniswapMarket;\n', '        uniswapMarket19 = get(configs, 19).uniswapMarket;\n', '        uniswapMarket20 = get(configs, 20).uniswapMarket;\n', '//        uniswapMarket21 = get(configs, 21).uniswapMarket;\n', '//        uniswapMarket22 = get(configs, 22).uniswapMarket;\n', '//        uniswapMarket23 = get(configs, 23).uniswapMarket;\n', '//        uniswapMarket24 = get(configs, 24).uniswapMarket;\n', '//        uniswapMarket25 = get(configs, 25).uniswapMarket;\n', '//        uniswapMarket26 = get(configs, 26).uniswapMarket;\n', '//        uniswapMarket27 = get(configs, 27).uniswapMarket;\n', '//        uniswapMarket28 = get(configs, 28).uniswapMarket;\n', '//        uniswapMarket29 = get(configs, 29).uniswapMarket;\n', '\n', '        isUniswapReversed00 = get(configs, 0).isUniswapReversed;\n', '        isUniswapReversed01 = get(configs, 1).isUniswapReversed;\n', '        isUniswapReversed02 = get(configs, 2).isUniswapReversed;\n', '        isUniswapReversed03 = get(configs, 3).isUniswapReversed;\n', '        isUniswapReversed04 = get(configs, 4).isUniswapReversed;\n', '        isUniswapReversed05 = get(configs, 5).isUniswapReversed;\n', '        isUniswapReversed06 = get(configs, 6).isUniswapReversed;\n', '        isUniswapReversed07 = get(configs, 7).isUniswapReversed;\n', '        isUniswapReversed08 = get(configs, 8).isUniswapReversed;\n', '        isUniswapReversed09 = get(configs, 9).isUniswapReversed;\n', '        isUniswapReversed10 = get(configs, 10).isUniswapReversed;\n', '        isUniswapReversed11 = get(configs, 11).isUniswapReversed;\n', '        isUniswapReversed12 = get(configs, 12).isUniswapReversed;\n', '        isUniswapReversed13 = get(configs, 13).isUniswapReversed;\n', '        isUniswapReversed14 = get(configs, 14).isUniswapReversed;\n', '        isUniswapReversed15 = get(configs, 15).isUniswapReversed;\n', '        isUniswapReversed16 = get(configs, 16).isUniswapReversed;\n', '        isUniswapReversed17 = get(configs, 17).isUniswapReversed;\n', '        isUniswapReversed18 = get(configs, 18).isUniswapReversed;\n', '        isUniswapReversed19 = get(configs, 19).isUniswapReversed;\n', '        isUniswapReversed20 = get(configs, 20).isUniswapReversed;\n', '//        isUniswapReversed21 = get(configs, 21).isUniswapReversed;\n', '//        isUniswapReversed22 = get(configs, 22).isUniswapReversed;\n', '//        isUniswapReversed23 = get(configs, 23).isUniswapReversed;\n', '//        isUniswapReversed24 = get(configs, 24).isUniswapReversed;\n', '//        isUniswapReversed25 = get(configs, 25).isUniswapReversed;\n', '//        isUniswapReversed26 = get(configs, 26).isUniswapReversed;\n', '//        isUniswapReversed27 = get(configs, 27).isUniswapReversed;\n', '//        isUniswapReversed28 = get(configs, 28).isUniswapReversed;\n', '//        isUniswapReversed29 = get(configs, 29).isUniswapReversed;\n', '    }\n', '\n', '    function get(TokenConfig[] memory configs, uint i) internal pure returns (TokenConfig memory) {\n', '        if (i < configs.length)\n', '            return configs[i];\n', '        return TokenConfig({\n', '            cToken: address(0),\n', '            underlying: address(0),\n', '            symbolHash: bytes32(0),\n', '            baseUnit: uint256(0),\n', '            priceSource: PriceSource(0),\n', '            fixedPrice: uint256(0),\n', '            uniswapMarket: address(0),\n', '            isUniswapReversed: false\n', '        });\n', '    }\n', '\n', '    function getCTokenIndex(address cToken) internal view returns (uint) {\n', '        if (cToken == cToken00) return 0;\n', '        if (cToken == cToken01) return 1;\n', '        if (cToken == cToken02) return 2;\n', '        if (cToken == cToken03) return 3;\n', '        if (cToken == cToken04) return 4;\n', '        if (cToken == cToken05) return 5;\n', '        if (cToken == cToken06) return 6;\n', '        if (cToken == cToken07) return 7;\n', '        if (cToken == cToken08) return 8;\n', '        if (cToken == cToken09) return 9;\n', '        if (cToken == cToken10) return 10;\n', '        if (cToken == cToken11) return 11;\n', '        if (cToken == cToken12) return 12;\n', '        if (cToken == cToken13) return 13;\n', '        if (cToken == cToken14) return 14;\n', '        if (cToken == cToken15) return 15;\n', '        if (cToken == cToken16) return 16;\n', '        if (cToken == cToken17) return 17;\n', '        if (cToken == cToken18) return 18;\n', '        if (cToken == cToken19) return 19;\n', '        if (cToken == cToken20) return 20;\n', '//        if (cToken == cToken21) return 21;\n', '//        if (cToken == cToken22) return 22;\n', '//        if (cToken == cToken23) return 23;\n', '//        if (cToken == cToken24) return 24;\n', '//        if (cToken == cToken25) return 25;\n', '//        if (cToken == cToken26) return 26;\n', '//        if (cToken == cToken27) return 27;\n', '//        if (cToken == cToken28) return 28;\n', '//        if (cToken == cToken29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n', '        if (underlying == underlying00) return 0;\n', '        if (underlying == underlying01) return 1;\n', '        if (underlying == underlying02) return 2;\n', '        if (underlying == underlying03) return 3;\n', '        if (underlying == underlying04) return 4;\n', '        if (underlying == underlying05) return 5;\n', '        if (underlying == underlying06) return 6;\n', '        if (underlying == underlying07) return 7;\n', '        if (underlying == underlying08) return 8;\n', '        if (underlying == underlying09) return 9;\n', '        if (underlying == underlying10) return 10;\n', '        if (underlying == underlying11) return 11;\n', '        if (underlying == underlying12) return 12;\n', '        if (underlying == underlying13) return 13;\n', '        if (underlying == underlying14) return 14;\n', '        if (underlying == underlying15) return 15;\n', '        if (underlying == underlying16) return 16;\n', '        if (underlying == underlying17) return 17;\n', '        if (underlying == underlying18) return 18;\n', '        if (underlying == underlying19) return 19;\n', '        if (underlying == underlying20) return 20;\n', '//        if (underlying == underlying21) return 21;\n', '//        if (underlying == underlying22) return 22;\n', '//        if (underlying == underlying23) return 23;\n', '//        if (underlying == underlying24) return 24;\n', '//        if (underlying == underlying25) return 25;\n', '//        if (underlying == underlying26) return 26;\n', '//        if (underlying == underlying27) return 27;\n', '//        if (underlying == underlying28) return 28;\n', '//        if (underlying == underlying29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n', '        if (symbolHash == symbolHash00) return 0;\n', '        if (symbolHash == symbolHash01) return 1;\n', '        if (symbolHash == symbolHash02) return 2;\n', '        if (symbolHash == symbolHash03) return 3;\n', '        if (symbolHash == symbolHash04) return 4;\n', '        if (symbolHash == symbolHash05) return 5;\n', '        if (symbolHash == symbolHash06) return 6;\n', '        if (symbolHash == symbolHash07) return 7;\n', '        if (symbolHash == symbolHash08) return 8;\n', '        if (symbolHash == symbolHash09) return 9;\n', '        if (symbolHash == symbolHash10) return 10;\n', '        if (symbolHash == symbolHash11) return 11;\n', '        if (symbolHash == symbolHash12) return 12;\n', '        if (symbolHash == symbolHash13) return 13;\n', '        if (symbolHash == symbolHash14) return 14;\n', '        if (symbolHash == symbolHash15) return 15;\n', '        if (symbolHash == symbolHash16) return 16;\n', '        if (symbolHash == symbolHash17) return 17;\n', '        if (symbolHash == symbolHash18) return 18;\n', '        if (symbolHash == symbolHash19) return 19;\n', '        if (symbolHash == symbolHash20) return 20;\n', '//        if (symbolHash == symbolHash21) return 21;\n', '//        if (symbolHash == symbolHash22) return 22;\n', '//        if (symbolHash == symbolHash23) return 23;\n', '//        if (symbolHash == symbolHash24) return 24;\n', '//        if (symbolHash == symbolHash25) return 25;\n', '//        if (symbolHash == symbolHash26) return 26;\n', '//        if (symbolHash == symbolHash27) return 27;\n', '//        if (symbolHash == symbolHash28) return 28;\n', '//        if (symbolHash == symbolHash29) return 29;\n', '\n', '        return uint(-1);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the i-th config, according to the order they were passed in originally\n', '     * @param i The index of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n', '        require(i < numTokens, "TOKEN_NOT_FOUND");\n', '\n', '        if (i == 0) return TokenConfig({cToken: cToken00, underlying: underlying00, symbolHash: symbolHash00, baseUnit: baseUnit00, priceSource: priceSource00, fixedPrice: fixedPrice00, uniswapMarket: uniswapMarket00, isUniswapReversed: isUniswapReversed00});\n', '        if (i == 1) return TokenConfig({cToken: cToken01, underlying: underlying01, symbolHash: symbolHash01, baseUnit: baseUnit01, priceSource: priceSource01, fixedPrice: fixedPrice01, uniswapMarket: uniswapMarket01, isUniswapReversed: isUniswapReversed01});\n', '        if (i == 2) return TokenConfig({cToken: cToken02, underlying: underlying02, symbolHash: symbolHash02, baseUnit: baseUnit02, priceSource: priceSource02, fixedPrice: fixedPrice02, uniswapMarket: uniswapMarket02, isUniswapReversed: isUniswapReversed02});\n', '        if (i == 3) return TokenConfig({cToken: cToken03, underlying: underlying03, symbolHash: symbolHash03, baseUnit: baseUnit03, priceSource: priceSource03, fixedPrice: fixedPrice03, uniswapMarket: uniswapMarket03, isUniswapReversed: isUniswapReversed03});\n', '        if (i == 4) return TokenConfig({cToken: cToken04, underlying: underlying04, symbolHash: symbolHash04, baseUnit: baseUnit04, priceSource: priceSource04, fixedPrice: fixedPrice04, uniswapMarket: uniswapMarket04, isUniswapReversed: isUniswapReversed04});\n', '        if (i == 5) return TokenConfig({cToken: cToken05, underlying: underlying05, symbolHash: symbolHash05, baseUnit: baseUnit05, priceSource: priceSource05, fixedPrice: fixedPrice05, uniswapMarket: uniswapMarket05, isUniswapReversed: isUniswapReversed05});\n', '        if (i == 6) return TokenConfig({cToken: cToken06, underlying: underlying06, symbolHash: symbolHash06, baseUnit: baseUnit06, priceSource: priceSource06, fixedPrice: fixedPrice06, uniswapMarket: uniswapMarket06, isUniswapReversed: isUniswapReversed06});\n', '        if (i == 7) return TokenConfig({cToken: cToken07, underlying: underlying07, symbolHash: symbolHash07, baseUnit: baseUnit07, priceSource: priceSource07, fixedPrice: fixedPrice07, uniswapMarket: uniswapMarket07, isUniswapReversed: isUniswapReversed07});\n', '        if (i == 8) return TokenConfig({cToken: cToken08, underlying: underlying08, symbolHash: symbolHash08, baseUnit: baseUnit08, priceSource: priceSource08, fixedPrice: fixedPrice08, uniswapMarket: uniswapMarket08, isUniswapReversed: isUniswapReversed08});\n', '        if (i == 9) return TokenConfig({cToken: cToken09, underlying: underlying09, symbolHash: symbolHash09, baseUnit: baseUnit09, priceSource: priceSource09, fixedPrice: fixedPrice09, uniswapMarket: uniswapMarket09, isUniswapReversed: isUniswapReversed09});\n', '\n', '        if (i == 10) return TokenConfig({cToken: cToken10, underlying: underlying10, symbolHash: symbolHash10, baseUnit: baseUnit10, priceSource: priceSource10, fixedPrice: fixedPrice10, uniswapMarket: uniswapMarket10, isUniswapReversed: isUniswapReversed10});\n', '        if (i == 11) return TokenConfig({cToken: cToken11, underlying: underlying11, symbolHash: symbolHash11, baseUnit: baseUnit11, priceSource: priceSource11, fixedPrice: fixedPrice11, uniswapMarket: uniswapMarket11, isUniswapReversed: isUniswapReversed11});\n', '        if (i == 12) return TokenConfig({cToken: cToken12, underlying: underlying12, symbolHash: symbolHash12, baseUnit: baseUnit12, priceSource: priceSource12, fixedPrice: fixedPrice12, uniswapMarket: uniswapMarket12, isUniswapReversed: isUniswapReversed12});\n', '        if (i == 13) return TokenConfig({cToken: cToken13, underlying: underlying13, symbolHash: symbolHash13, baseUnit: baseUnit13, priceSource: priceSource13, fixedPrice: fixedPrice13, uniswapMarket: uniswapMarket13, isUniswapReversed: isUniswapReversed13});\n', '        if (i == 14) return TokenConfig({cToken: cToken14, underlying: underlying14, symbolHash: symbolHash14, baseUnit: baseUnit14, priceSource: priceSource14, fixedPrice: fixedPrice14, uniswapMarket: uniswapMarket14, isUniswapReversed: isUniswapReversed14});\n', '        if (i == 15) return TokenConfig({cToken: cToken15, underlying: underlying15, symbolHash: symbolHash15, baseUnit: baseUnit15, priceSource: priceSource15, fixedPrice: fixedPrice15, uniswapMarket: uniswapMarket15, isUniswapReversed: isUniswapReversed15});\n', '        if (i == 16) return TokenConfig({cToken: cToken16, underlying: underlying16, symbolHash: symbolHash16, baseUnit: baseUnit16, priceSource: priceSource16, fixedPrice: fixedPrice16, uniswapMarket: uniswapMarket16, isUniswapReversed: isUniswapReversed16});\n', '        if (i == 17) return TokenConfig({cToken: cToken17, underlying: underlying17, symbolHash: symbolHash17, baseUnit: baseUnit17, priceSource: priceSource17, fixedPrice: fixedPrice17, uniswapMarket: uniswapMarket17, isUniswapReversed: isUniswapReversed17});\n', '        if (i == 18) return TokenConfig({cToken: cToken18, underlying: underlying18, symbolHash: symbolHash18, baseUnit: baseUnit18, priceSource: priceSource18, fixedPrice: fixedPrice18, uniswapMarket: uniswapMarket18, isUniswapReversed: isUniswapReversed18});\n', '        if (i == 19) return TokenConfig({cToken: cToken19, underlying: underlying19, symbolHash: symbolHash19, baseUnit: baseUnit19, priceSource: priceSource19, fixedPrice: fixedPrice19, uniswapMarket: uniswapMarket19, isUniswapReversed: isUniswapReversed19});\n', '\n', '        if (i == 20) return TokenConfig({cToken: cToken20, underlying: underlying20, symbolHash: symbolHash20, baseUnit: baseUnit20, priceSource: priceSource20, fixedPrice: fixedPrice20, uniswapMarket: uniswapMarket20, isUniswapReversed: isUniswapReversed20});\n', '//        if (i == 21) return TokenConfig({cToken: cToken21, underlying: underlying21, symbolHash: symbolHash21, baseUnit: baseUnit21, priceSource: priceSource21, fixedPrice: fixedPrice21, uniswapMarket: uniswapMarket21, isUniswapReversed: isUniswapReversed21});\n', '//        if (i == 22) return TokenConfig({cToken: cToken22, underlying: underlying22, symbolHash: symbolHash22, baseUnit: baseUnit22, priceSource: priceSource22, fixedPrice: fixedPrice22, uniswapMarket: uniswapMarket22, isUniswapReversed: isUniswapReversed22});\n', '//        if (i == 23) return TokenConfig({cToken: cToken23, underlying: underlying23, symbolHash: symbolHash23, baseUnit: baseUnit23, priceSource: priceSource23, fixedPrice: fixedPrice23, uniswapMarket: uniswapMarket23, isUniswapReversed: isUniswapReversed23});\n', '//        if (i == 24) return TokenConfig({cToken: cToken24, underlying: underlying24, symbolHash: symbolHash24, baseUnit: baseUnit24, priceSource: priceSource24, fixedPrice: fixedPrice24, uniswapMarket: uniswapMarket24, isUniswapReversed: isUniswapReversed24});\n', '//        if (i == 25) return TokenConfig({cToken: cToken25, underlying: underlying25, symbolHash: symbolHash25, baseUnit: baseUnit25, priceSource: priceSource25, fixedPrice: fixedPrice25, uniswapMarket: uniswapMarket25, isUniswapReversed: isUniswapReversed25});\n', '//        if (i == 26) return TokenConfig({cToken: cToken26, underlying: underlying26, symbolHash: symbolHash26, baseUnit: baseUnit26, priceSource: priceSource26, fixedPrice: fixedPrice26, uniswapMarket: uniswapMarket26, isUniswapReversed: isUniswapReversed26});\n', '//        if (i == 27) return TokenConfig({cToken: cToken27, underlying: underlying27, symbolHash: symbolHash27, baseUnit: baseUnit27, priceSource: priceSource27, fixedPrice: fixedPrice27, uniswapMarket: uniswapMarket27, isUniswapReversed: isUniswapReversed27});\n', '//        if (i == 28) return TokenConfig({cToken: cToken28, underlying: underlying28, symbolHash: symbolHash28, baseUnit: baseUnit28, priceSource: priceSource28, fixedPrice: fixedPrice28, uniswapMarket: uniswapMarket28, isUniswapReversed: isUniswapReversed28});\n', '//        if (i == 29) return TokenConfig({cToken: cToken29, underlying: underlying29, symbolHash: symbolHash29, baseUnit: baseUnit29, priceSource: priceSource29, fixedPrice: fixedPrice29, uniswapMarket: uniswapMarket29, isUniswapReversed: isUniswapReversed29});\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for symbol\n', '     * @param symbol The symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n', '        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the symbolHash\n', '     * @param symbolHash The keccack256 of the symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n', '        uint index = getSymbolHashIndex(symbolHash);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        revert("TOKEN_NOT_FOUND");\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the cToken\n', '     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n', '     * @param cToken The address of the cToken of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n', '        uint index = getCTokenIndex(cToken);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for an underlying asset\n', '     * @param underlying The address of the underlying asset of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n', '        uint index = getUnderlyingIndex(underlying);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '      revert("TOKEN_NOT_FOUND");\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IUniswapV2Pair {\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  function name() external pure returns (string memory);\n', '\n', '  function symbol() external pure returns (string memory);\n', '\n', '  function decimals() external pure returns (uint8);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function balanceOf(address owner) external view returns (uint256);\n', '\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  ) external returns (bool);\n', '\n', '  function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '  function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '  function nonces(address owner) external view returns (uint256);\n', '\n', '  function permit(\n', '    address owner,\n', '    address spender,\n', '    uint256 value,\n', '    uint256 deadline,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) external;\n', '\n', '  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '  event Swap(\n', '    address indexed sender,\n', '    uint256 amount0In,\n', '    uint256 amount1In,\n', '    uint256 amount0Out,\n', '    uint256 amount1Out,\n', '    address indexed to\n', '  );\n', '  event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '  function factory() external view returns (address);\n', '\n', '  function token0() external view returns (address);\n', '\n', '  function token1() external view returns (address);\n', '\n', '  function getReserves()\n', '    external\n', '    view\n', '    returns (\n', '      uint112 reserve0,\n', '      uint112 reserve1,\n', '      uint32 blockTimestampLast\n', '    );\n', '\n', '  function price0CumulativeLast() external view returns (uint256);\n', '\n', '  function price1CumulativeLast() external view returns (uint256);\n', '\n', '  function kLast() external view returns (uint256);\n', '\n', '  function mint(address to) external returns (uint256 liquidity);\n', '\n', '  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '\n', '  function swap(\n', '    uint256 amount0Out,\n', '    uint256 amount1Out,\n', '    address to,\n', '    bytes calldata data\n', '  ) external;\n', '\n', '  function skim(address to) external;\n', '\n', '  function sync() external;\n', '\n', '  function initialize(address, address) external;\n', '}\n', '\n', '// File: contracts/Uniswap/UniswapLib.sol\n', '\n', '\n', 'pragma solidity ^0.6.10;\n', '\n', '// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).div(denominator)\n', '    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '        require(denominator > 0, "DIV_BY_ZERO");\n', '        return uq112x112((uint224(numerator) << 112) / denominator);\n', '    }\n', '\n', '    // decode a uq112x112 into a uint with 18 decimals of precision\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n', '        // instead, get close to:\n', '        //  (x * 1e18) >> 112\n', '        // without risk of overflowing, e.g.:\n', '        //  (x) / 2 ** (112 - lg(1e18))\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '}\n', '\n', '// library with helper methods for oracles that are concerned with computing average prices\n', 'library UniswapV2OracleLibrary {\n', '    using FixedPoint for *;\n', '\n', '    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n', '    function currentBlockTimestamp() internal view returns (uint32) {\n', '        return uint32(block.timestamp % 2 ** 32);\n', '    }\n', '\n', '    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n', '    function currentCumulativePrices(\n', '        address pair\n', '    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n', '        blockTimestamp = currentBlockTimestamp();\n', '        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '\n', '        // if time has elapsed since the last update on the pair, mock the accumulated price values\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n', '        if (blockTimestampLast != blockTimestamp) {\n', '            // subtraction overflow is desired\n', '            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n', '            // addition overflow is desired\n', '            // counterfactual\n', '            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n', '            // counterfactual\n', '            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/UniswapTWAPProvider.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', 'abstract contract UniswapTWAPProvider is PowerOracleStorageV1, UniswapConfig {\n', '  using FixedPoint for *;\n', '  using SafeMath for uint256;\n', '\n', '  /// @notice The number of wei in 1 ETH\n', '  uint public constant ethBaseUnit = 1e18;\n', '\n', '  /// @notice A common scaling factor to maintain precision\n', '  uint public constant expScale = 1e18;\n', '\n', '  bytes32 internal constant cvpHash = keccak256(abi.encodePacked("CVP"));\n', '  bytes32 internal constant ethHash = keccak256(abi.encodePacked("ETH"));\n', '  bytes32 internal constant rotateHash = keccak256(abi.encodePacked("rotate"));\n', '\n', '  /// @notice The event emitted when anchor price is updated\n', '  event AnchorPriceUpdated(string symbol, bytes32 indexed symbolHash, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\n', '\n', '  /// @notice The event emitted when the uniswap window changes\n', '  event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n', '\n', '  /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n', '  uint public immutable anchorPeriod;\n', '\n', '  constructor(\n', '    uint anchorPeriod_,\n', '    TokenConfig[] memory configs\n', '  ) public {\n', '    anchorPeriod = anchorPeriod_;\n', '\n', '    for (uint i = 0; i < configs.length; i++) {\n', '      TokenConfig memory config = configs[i];\n', '      require(config.baseUnit > 0, "BASE_UNIT_IS_NULL");\n', '      address uniswapMarket = config.uniswapMarket;\n', '      if (config.priceSource == PriceSource.REPORTER) {\n', '        require(uniswapMarket != address(0), "MARKET_IS_NULL");\n', '        bytes32 symbolHash = config.symbolHash;\n', '        uint cumulativePrice = currentCumulativePrice(config);\n', '        oldObservations[symbolHash].timestamp = block.timestamp;\n', '        newObservations[symbolHash].timestamp = block.timestamp;\n', '        oldObservations[symbolHash].acc = cumulativePrice;\n', '        newObservations[symbolHash].acc = cumulativePrice;\n', '        emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n', '      } else {\n', '        require(uniswapMarket == address(0), "MARKET_IS_NOT_NULL");\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '    * @dev Fetches the current token/eth price accumulator from uniswap.\n', '    */\n', '  function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n', '    (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n', '    if (config.isUniswapReversed) {\n', '      return cumulativePrice1;\n', '    } else {\n', '      return cumulativePrice0;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\n', '   *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n', '   */\n', '  function fetchEthPrice() internal returns (uint) {\n', '    return fetchAnchorPrice("ETH", getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n', '  }\n', '\n', '  function fetchCvpPrice(uint256 ethPrice) internal returns (uint) {\n', '    return fetchAnchorPrice("CVP", getTokenConfigBySymbolHash(cvpHash), ethPrice);\n', '  }\n', '\n', '  /**\n', '   * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n', '   * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n', '   */\n', '  function fetchAnchorPrice(string memory symbol, TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n', '    (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n', '\n', '    // This should be impossible, but better safe than sorry\n', '    require(block.timestamp > oldTimestamp, "TOO_EARLY");\n', '    uint timeElapsed = block.timestamp - oldTimestamp;\n', '\n', '    // Calculate uniswap time-weighted average price\n', '    // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n', '    FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n', '    uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n', '    uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\n', '    uint anchorPrice;\n', '\n', '    // Adjust rawUniswapPrice according to the units of the non-ETH asset\n', '    // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n', '    if (config.isUniswapReversed) {\n', '      // unscaledPriceMantissa * ethBaseUnit / config.baseUnit / expScale, but we simplify bc ethBaseUnit == expScale\n', '      anchorPrice = unscaledPriceMantissa / config.baseUnit;\n', '    } else {\n', '      anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\n', '    }\n', '\n', '    emit AnchorPriceUpdated(symbol, keccak256(abi.encodePacked(symbol)), anchorPrice, oldTimestamp, block.timestamp);\n', '\n', '    return anchorPrice;\n', '  }\n', '\n', '  /**\n', '   * @dev Get time-weighted average prices for a token at the current timestamp.\n', '   *  Update new and old observations of lagging window if period elapsed.\n', '   */\n', '  function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n', '    bytes32 symbolHash = config.symbolHash;\n', '    uint cumulativePrice = currentCumulativePrice(config);\n', '\n', '    Observation memory newObservation = newObservations[symbolHash];\n', '\n', '    // Update new and old observations if elapsed time is greater than or equal to anchor period\n', '    uint timeElapsed = block.timestamp - newObservation.timestamp;\n', '    if (timeElapsed >= anchorPeriod) {\n', '      oldObservations[symbolHash].timestamp = newObservation.timestamp;\n', '      oldObservations[symbolHash].acc = newObservation.acc;\n', '\n', '      newObservations[symbolHash].timestamp = block.timestamp;\n', '      newObservations[symbolHash].acc = cumulativePrice;\n', '      emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n', '    }\n', '    return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n', '  }\n', '\n', '  /// @dev Overflow proof multiplication\n', '  function mul(uint a, uint b) internal pure returns (uint) {\n', '    if (a == 0) return 0;\n', '    uint c = a * b;\n', '    require(c / a == b, "MUL_OVERFLOW");\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/utils/PowerPausable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/Pausable.sol\n', '// with no GSN Context support and no construct\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract PowerPausable {\n', '  /**\n', '   * @dev Emitted when the pause is triggered by `account`.\n', '   */\n', '  event Paused(address account);\n', '\n', '  /**\n', '   * @dev Emitted when the pause is lifted by `account`.\n', '   */\n', '  event Unpaused(address account);\n', '\n', '  bool private _paused;\n', '\n', '  /**\n', '   * @dev Returns true if the contract is paused, and false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "NOT_PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Triggers stopped state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  function _pause() internal virtual whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns to normal state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  function _unpause() internal virtual whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', '// File: contracts/utils/PowerOwnable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/access/Ownable.sol\n', '// with no GSN Context support and _transferOwnership internal method\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract PowerOwnable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev Initializes the contract setting the deployer as the initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(_owner == msg.sender, "NOT_THE_OWNER");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Leaves the contract without owner. It will not be possible to call\n', '   * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '   *\n', '   * NOTE: Renouncing ownership will leave the contract without an owner,\n', '   * thereby removing any functionality that is only available to the owner.\n', '   */\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/Math.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Router02.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IUniswapV2Router02 {\n', '  function swapExactTokensForETH(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '}\n', '\n', '// File: contracts/interfaces/IEACAggregatorProxy.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IEACAggregatorProxy {\n', '  function latestAnswer() external view returns (int256);\n', '}\n', '\n', '// File: contracts/interfaces/IPowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPowerPokeStaking {\n', '  enum UserStatus { UNAUTHORIZED, HDH, MEMBER }\n', '\n', '  /*** User Interface ***/\n', '  function createDeposit(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeDeposit(uint256 userId_) external;\n', '\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external;\n', '\n', '  function createUser(\n', '    address adminKey_,\n', '    address reporterKey_,\n', '    uint256 depositAmount\n', '  ) external;\n', '\n', '  function updateUser(\n', '    uint256 userId,\n', '    address adminKey_,\n', '    address reporterKey_\n', '  ) external;\n', '\n', '  /*** Owner Interface ***/\n', '  function setSlasher(address slasher) external;\n', '\n', '  function setSlashingPct(uint256 slasherRewardPct, uint256 reservoirRewardPct) external;\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** PowerOracle Contract Interface ***/\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external;\n', '\n', '  /*** Permissionless Interface ***/\n', '  function setHDH(uint256 candidateId_) external;\n', '\n', '  /*** Viewers ***/\n', '  function getHDHID() external view returns (uint256);\n', '\n', '  function getHighestDeposit() external view returns (uint256);\n', '\n', '  function getDepositOf(uint256 userId) external view returns (uint256);\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    external\n', '    view\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    );\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view returns (UserStatus);\n', '\n', '  function authorizeHDH(uint256 userId_, address reporterKey_) external view;\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view;\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view;\n', '\n', '  function getLastDepositChange(uint256 userId_) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/PowerPokeStakingStorageV1.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'contract PowerPokeStakingStorageV1 {\n', '  struct User {\n', '    address adminKey;\n', '    address pokerKey;\n', '    uint256 deposit;\n', '    uint256 pendingDeposit;\n', '    uint256 pendingDepositTimeout;\n', '    uint256 pendingWithdrawal;\n', '    uint256 pendingWithdrawalTimeout;\n', '  }\n', '\n', '  /// @notice The deposit timeout in seconds\n', '  uint256 public depositTimeout;\n', '\n', '  /// @notice The withdrawal timeout in seconds\n', '  uint256 public withdrawalTimeout;\n', '\n', '  /// @notice The reservoir which holds CVP tokens\n', '  address public reservoir;\n', '\n', '  /// @notice The slasher address (PowerPoke)\n', '  address public slasher;\n', '\n', '  /// @notice The total amount of all deposits\n', '  uint256 public totalDeposit;\n', '\n', '  /// @notice The share of a slasher in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public slasherSlashingRewardPct;\n', '\n', '  /// @notice The share of the protocol(reservoir) in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public protocolSlashingRewardPct;\n', '\n', '  /// @notice The incremented user ID counter. Is updated only within createUser function call\n', '  uint256 public userIdCounter;\n', '\n', '  /// @dev The highest deposit. Usually of the current reporterId. Is safe to be outdated.\n', '  uint256 internal _highestDeposit;\n', '\n', '  /// @dev The current highest deposit holder ID.\n', '  uint256 internal _hdhId;\n', '\n', "  /// @notice User details by it's ID\n", '  mapping(uint256 => User) public users;\n', '\n', '  /// @dev Last deposit change timestamp by user ID\n', '  mapping(uint256 => uint256) internal _lastDepositChange;\n', '}\n', '\n', '// File: contracts/PowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerPokeStaking is IPowerPokeStaking, PowerOwnable, Initializable, PowerPausable, PowerPokeStakingStorageV1 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public constant HUNDRED_PCT = 100 ether;\n', '\n', '  /// @notice The event emitted when a new user is created\n', '  event CreateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey, uint256 initialDeposit);\n', '\n', '  /// @notice The event emitted when an existing user is updated\n', '  event UpdateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateDeposit(\n', '    uint256 indexed userId,\n', '    address indexed depositor,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingDepositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when the user transfers his deposit from pending to the active\n', '  event ExecuteDeposit(uint256 indexed userId, uint256 pendingTimeout, uint256 amount, uint256 depositAfter);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateWithdrawal(\n', '    uint256 indexed userId,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingWithdrawalAfter,\n', '    uint256 depositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when a valid admin key withdraws funds from\n', '  event ExecuteWithdrawal(uint256 indexed userId, address indexed to, uint256 pendingTimeout, uint256 amount);\n', '\n', '  /// @notice The event emitted when the owner sets new slashing percent values, where 1ether == 1%\n', '  event SetSlashingPct(uint256 slasherSlashingRewardPct, uint256 protocolSlashingRewardPct);\n', '\n', '  /// @notice The event emitted when the owner sets new deposit and withdrawal timeouts\n', '  event SetTimeouts(uint256 depositTimeout, uint256 withdrawalTimeout);\n', '\n', '  /// @notice The event emitted when the owner sets a new PowerOracle linked contract\n', '  event SetSlasher(address powerOracle);\n', '\n', '  /// @notice The event emitted when an arbitrary user fixes an outdated reporter userId record\n', '  event SetReporter(uint256 indexed reporterId, address indexed msgSender);\n', '\n', '  /// @notice The event emitted when the PowerOracle contract requests to slash a user with the given ID\n', '  event Slash(uint256 indexed slasherId, uint256 indexed reporterId, uint256 slasherReward, uint256 reservoirReward);\n', '\n', '  /// @notice The event emitted when the existing reporter is replaced with a new one due some reason\n', '  event ReporterChange(\n', '    uint256 indexed prevId,\n', '    uint256 indexed nextId,\n', '    uint256 highestDepositPrev,\n', '    uint256 actualDepositPrev,\n', '    uint256 actualDepositNext\n', '  );\n', '\n', '  /// @notice CVP token address\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  constructor(address cvpToken_) public {\n', '    require(cvpToken_ != address(0), "CVP_ADDR_IS_0");\n', '\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '  }\n', '\n', '  function initialize(\n', '    address owner_,\n', '    address reservoir_,\n', '    address slasher_,\n', '    uint256 slasherSlashingRewardPct_,\n', '    uint256 reservoirSlashingRewardPct_,\n', '    uint256 depositTimeout_,\n', '    uint256 withdrawTimeout_\n', '  ) external initializer {\n', '    require(depositTimeout_ > 0, "DEPOSIT_TIMEOUT_IS_0");\n', '    require(withdrawTimeout_ > 0, "WITHDRAW_TIMEOUT_IS_0");\n', '\n', '    _transferOwnership(owner_);\n', '    reservoir = reservoir_;\n', '    slasher = slasher_;\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = reservoirSlashingRewardPct_;\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawTimeout_;\n', '  }\n', '\n', '  /*** User Interface ***/\n', '\n', '  /**\n', '   * @notice An arbitrary user deposits CVP stake to the contract for the given user ID\n', '   * @param userId_ The user ID to make deposit for\n', '   * @param amount_ The amount in CVP tokens to deposit\n', '   */\n', '  function createDeposit(uint256 userId_, uint256 amount_) external override whenNotPaused {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    require(user.adminKey != address(0), "INVALID_USER");\n', '\n', '    _createDeposit(userId_, amount_);\n', '  }\n', '\n', '  function _createDeposit(uint256 userId_, uint256 amount_) internal {\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingDepositAfter = user.pendingDeposit.add(amount_);\n', '    uint256 timeout = block.timestamp.add(depositTimeout);\n', '\n', '    user.pendingDeposit = pendingDepositAfter;\n', '    user.pendingDepositTimeout = timeout;\n', '\n', '    emit CreateDeposit(userId_, msg.sender, timeout, amount_, pendingDepositAfter);\n', '    CVP_TOKEN.transferFrom(msg.sender, address(this), amount_);\n', '  }\n', '\n', '  function executeDeposit(uint256 userId_) external override {\n', '    User storage user = users[userId_];\n', '    uint256 amount = user.pendingDeposit;\n', '    uint256 pendingDepositTimeout = user.pendingDepositTimeout;\n', '\n', '    // check\n', '    require(user.adminKey == msg.sender, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_DEPOSIT");\n', '    require(block.timestamp >= pendingDepositTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    // increment deposit\n', '    uint256 depositAfter = user.deposit.add(amount);\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.add(amount);\n', '\n', '    // reset pending deposit\n', '    user.pendingDeposit = 0;\n', '    user.pendingDepositTimeout = 0;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    _trySetHighestDepositHolder(userId_, depositAfter);\n', '\n', '    emit ExecuteDeposit(userId_, pendingDepositTimeout, amount, depositAfter);\n', '  }\n', '\n', '  function _trySetHighestDepositHolder(uint256 candidateId_, uint256 candidateDepositAfter_) internal {\n', '    uint256 prevHdhID = _hdhId;\n', '    uint256 prevDeposit = users[prevHdhID].deposit;\n', '\n', '    if (candidateDepositAfter_ > prevDeposit && prevHdhID != candidateId_) {\n', '      emit ReporterChange(prevHdhID, candidateId_, _highestDeposit, users[prevHdhID].deposit, candidateDepositAfter_);\n', '\n', '      _highestDeposit = candidateDepositAfter_;\n', '      _hdhId = candidateId_;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice A valid users admin key withdraws the deposited stake form the contract\n', '   * @param userId_ The user ID to withdraw deposit from\n', '   * @param amount_ The amount in CVP tokens to withdraw\n', '   */\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external override {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    // decrement deposit\n', '    uint256 depositBefore = user.deposit;\n', '    require(amount_ <= depositBefore, "AMOUNT_EXCEEDS_DEPOSIT");\n', '\n', '    uint256 depositAfter = depositBefore - amount_;\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.sub(amount_);\n', '\n', '    // increment pending withdrawal\n', '    uint256 pendingWithdrawalAfter = user.pendingWithdrawal.add(amount_);\n', '    uint256 timeout = block.timestamp.add(withdrawalTimeout);\n', '    user.pendingWithdrawal = pendingWithdrawalAfter;\n', '    user.pendingWithdrawalTimeout = timeout;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    emit CreateWithdrawal(userId_, timeout, amount_, pendingWithdrawalAfter, depositAfter);\n', '  }\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external override {\n', '    require(to_ != address(0), "CANT_WITHDRAW_TO_0");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingWithdrawalTimeout = user.pendingWithdrawalTimeout;\n', '    uint256 amount = user.pendingWithdrawal;\n', '\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_WITHDRAWAL");\n', '    require(block.timestamp >= pendingWithdrawalTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    user.pendingWithdrawal = 0;\n', '    user.pendingWithdrawalTimeout = 0;\n', '\n', '    emit ExecuteWithdrawal(userId_, to_, pendingWithdrawalTimeout, amount);\n', '    CVP_TOKEN.transfer(to_, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new user ID and stores the given keys\n', '   * @param adminKey_ The admin key for the new user\n', '   * @param pokerKey_ The poker key for the new user\n', '   * @param initialDeposit_ The initial deposit to be transferred to this contract\n', '   */\n', '  function createUser(\n', '    address adminKey_,\n', '    address pokerKey_,\n', '    uint256 initialDeposit_\n', '  ) external override whenNotPaused {\n', '    uint256 userId = ++userIdCounter;\n', '\n', '    users[userId] = User(adminKey_, pokerKey_, 0, 0, 0, 0, 0);\n', '\n', '    emit CreateUser(userId, adminKey_, pokerKey_, initialDeposit_);\n', '\n', '    if (initialDeposit_ > 0) {\n', '      _createDeposit(userId, initialDeposit_);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Updates an existing user, only the current adminKey is eligible calling this method.\n', '   * @param adminKey_ The new admin key for the user\n', '   * @param pokerKey_ The new poker key for the user\n', '   */\n', '  function updateUser(\n', '    uint256 userId_,\n', '    address adminKey_,\n', '    address pokerKey_\n', '  ) external override {\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    if (adminKey_ != user.adminKey) {\n', '      user.adminKey = adminKey_;\n', '    }\n', '    if (pokerKey_ != user.pokerKey) {\n', '      user.pokerKey = pokerKey_;\n', '    }\n', '\n', '    emit UpdateUser(userId_, adminKey_, pokerKey_);\n', '  }\n', '\n', '  /*** SLASHER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Slashes the current reporter if it did not make poke() call during the given report interval\n', '   * @param slasherId_ The slasher ID\n', '   * @param times_ The multiplier for a single slashing percent\n', '   */\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external virtual override {\n', '    require(msg.sender == slasher, "ONLY_SLASHER_ALLOWED");\n', '\n', '    uint256 hdhId = _hdhId;\n', '    uint256 hdhDeposit = users[hdhId].deposit;\n', '\n', '    (uint256 slasherReward, uint256 reservoirReward, ) = getSlashAmount(hdhId, times_);\n', '\n', '    uint256 amount = slasherReward.add(reservoirReward);\n', '    require(hdhDeposit >= amount, "INSUFFICIENT_HDH_DEPOSIT");\n', '\n', '    // users[reporterId].deposit = reporterDeposit - slasherReward - reservoirReward;\n', '    users[hdhId].deposit = hdhDeposit.sub(amount);\n', '\n', '    // totalDeposit = totalDeposit - reservoirReward; (slasherReward is kept on the contract)\n', '    totalDeposit = totalDeposit.sub(reservoirReward);\n', '\n', '    if (slasherReward > 0) {\n', '      // uint256 slasherDepositAfter = users[slasherId_].deposit + slasherReward\n', '      uint256 slasherDepositAfter = users[slasherId_].deposit.add(slasherReward);\n', '      users[slasherId_].deposit = slasherDepositAfter;\n', '      _trySetHighestDepositHolder(slasherId_, slasherDepositAfter);\n', '    }\n', '\n', '    if (reservoirReward > 0) {\n', '      CVP_TOKEN.transfer(reservoir, reservoirReward);\n', '    }\n', '\n', '    emit Slash(slasherId_, hdhId, slasherReward, reservoirReward);\n', '  }\n', '\n', '  /*** OWNER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice The owner sets a new slasher address\n', '   * @param slasher_ The slasher address to set\n', '   */\n', '  function setSlasher(address slasher_) external override onlyOwner {\n', '    slasher = slasher_;\n', '    emit SetSlasher(slasher_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner sets the new slashing percent values\n', "   * @param slasherSlashingRewardPct_ The slasher share will be accrued on the slasher's deposit\n", '   * @param protocolSlashingRewardPct_ The protocol share will immediately be transferred to reservoir\n', '   */\n', '  function setSlashingPct(uint256 slasherSlashingRewardPct_, uint256 protocolSlashingRewardPct_)\n', '    external\n', '    override\n', '    onlyOwner\n', '  {\n', '    require(slasherSlashingRewardPct_.add(protocolSlashingRewardPct_) <= HUNDRED_PCT, "INVALID_SUM");\n', '\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = protocolSlashingRewardPct_;\n', '    emit SetSlashingPct(slasherSlashingRewardPct_, protocolSlashingRewardPct_);\n', '  }\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external override onlyOwner {\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawalTimeout_;\n', '    emit SetTimeouts(depositTimeout_, withdrawalTimeout_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses poke*-operations\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses poke*-operations\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** PERMISSIONLESS INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Set a given address as a reporter if his deposit is higher than the current highestDeposit\n', '   * @param candidateId_ Te candidate address to try\n', '   */\n', '  function setHDH(uint256 candidateId_) external override {\n', '    uint256 candidateDeposit = users[candidateId_].deposit;\n', '    uint256 prevHdhId = _hdhId;\n', '    uint256 currentReporterDeposit = users[prevHdhId].deposit;\n', '\n', '    require(candidateDeposit > currentReporterDeposit, "INSUFFICIENT_CANDIDATE_DEPOSIT");\n', '\n', '    emit ReporterChange(prevHdhId, candidateId_, _highestDeposit, currentReporterDeposit, candidateDeposit);\n', '    emit SetReporter(candidateId_, msg.sender);\n', '\n', '    _highestDeposit = candidateDeposit;\n', '    _hdhId = candidateId_;\n', '  }\n', '\n', '  /*** VIEWERS ***/\n', '\n', '  function getHDHID() external view override returns (uint256) {\n', '    return _hdhId;\n', '  }\n', '\n', '  function getHighestDeposit() external view override returns (uint256) {\n', '    return _highestDeposit;\n', '  }\n', '\n', '  function getDepositOf(uint256 userId_) external view override returns (uint256) {\n', '    return users[userId_].deposit;\n', '  }\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingDeposit, users[userId_].pendingDepositTimeout);\n', '  }\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingWithdrawal, users[userId_].pendingWithdrawalTimeout);\n', '  }\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    public\n', '    view\n', '    override\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    )\n', '  {\n', '    uint256 product = times_.mul(users[slasheeId_].deposit);\n', '    // slasherReward = times_ * reporterDeposit * slasherRewardPct / HUNDRED_PCT;\n', '    slasherReward = product.mul(slasherSlashingRewardPct) / HUNDRED_PCT;\n', '    // reservoirReward = times_ * reporterDeposit * reservoirSlashingRewardPct / HUNDRED_PCT;\n', '    reservoirReward = product.mul(protocolSlashingRewardPct) / HUNDRED_PCT;\n', '    // totalSlash = slasherReward + reservoirReward\n', '    totalSlash = slasherReward.add(reservoirReward);\n', '  }\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override returns (UserStatus) {\n', '    if (userId_ == _hdhId && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.HDH;\n', '    }\n', '    if (users[userId_].deposit >= minDeposit_ && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.MEMBER;\n', '    }\n', '    return UserStatus.UNAUTHORIZED;\n', '  }\n', '\n', '  function authorizeHDH(uint256 userId_, address pokerKey_) external view override {\n', '    require(userId_ == _hdhId, "NOT_HDH");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override {\n', '    require(userId_ != _hdhId, "IS_HDH");\n', '    authorizeMember(userId_, pokerKey_, minDeposit_);\n', '  }\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) public view override {\n', '    require(users[userId_].deposit >= minDeposit_, "INSUFFICIENT_DEPOSIT");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view override {\n', '    require(users[userId_].adminKey == adminKey_, "INVALID_AMIN_KEY");\n', '  }\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view override {\n', '    require(\n', '      users[userId_].adminKey == adminOrPokerKey_ || users[userId_].pokerKey == adminOrPokerKey_,\n', '      "INVALID_AMIN_OR_POKER_KEY"\n', '    );\n', '  }\n', '\n', '  function getLastDepositChange(uint256 userId_) external view override returns (uint256) {\n', '    return _lastDepositChange[userId_];\n', '  }\n', '}\n', '\n', '// File: contracts/PowerPokeStorageV1.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', 'contract PowerPokeStorageV1 {\n', '  struct Client {\n', '    bool active;\n', '    bool canSlash;\n', '    bool allowPokerWithdrawingRewards;\n', '    address owner;\n', '    uint256 credit;\n', '    uint256 minReportInterval;\n', '    uint256 maxReportInterval;\n', '    uint256 slasherHeartbeat;\n', '    uint256 gasPriceLimit;\n', '    uint256 defaultMinDeposit;\n', '    uint256 fixedCompensationCVP;\n', '    uint256 fixedCompensationETH;\n', '  }\n', '\n', '  struct BonusPlan {\n', '    bool active;\n', '    uint64 bonusNumerator;\n', '    uint64 bonusDenominator;\n', '    uint64 perGas;\n', '  }\n', '\n', '  IPowerOracle public oracle;\n', '\n', '  uint256 public totalCredits;\n', '\n', '  mapping(uint256 => uint256) public rewards;\n', '\n', '  mapping(uint256 => bool) public pokerKeyRewardWithdrawAllowance;\n', '\n', '  mapping(address => Client) public clients;\n', '\n', '  mapping(address => mapping(uint256 => BonusPlan)) public bonusPlans;\n', '}\n', '\n', '// File: contracts/PowerPoke.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerPoke is IPowerPoke, PowerOwnable, Initializable, PowerPausable, ReentrancyGuard, PowerPokeStorageV1 {\n', '  using SafeMath for uint256;\n', '\n', '  event RewardUser(\n', '    address indexed client,\n', '    uint256 indexed userId,\n', '    uint256 indexed bonusPlan,\n', '    bool compensateInETH,\n', '    uint256 gasUsed,\n', '    uint256 gasPrice,\n', '    uint256 userDeposit,\n', '    uint256 ethPrice,\n', '    uint256 cvpPrice,\n', '    uint256 compensationEvaluationCVP,\n', '    uint256 bonusCVP,\n', '    uint256 earnedCVP,\n', '    uint256 earnedETH\n', '  );\n', '\n', '  event TransferClientOwnership(address indexed client, address indexed from, address indexed to);\n', '\n', '  event SetReportIntervals(address indexed client, uint256 minReportInterval, uint256 maxReportInterval);\n', '\n', '  event SetGasPriceLimit(address indexed client, uint256 gasPriceLimit);\n', '\n', '  event SetSlasherHeartbeat(address indexed client, uint256 slasherHeartbeat);\n', '\n', '  event SetBonusPlan(\n', '    address indexed client,\n', '    uint256 indexed planId,\n', '    bool indexed active,\n', '    uint64 bonusNominator,\n', '    uint64 bonsuDenominator,\n', '    uint128 perGas\n', '  );\n', '\n', '  event SetFixedCompensations(address indexed client, uint256 fixedCompensationETH, uint256 fixedCompensationCVP);\n', '\n', '  event SetDefaultMinDeposit(address indexed client, uint256 defaultMinDeposit);\n', '\n', '  event WithdrawRewards(uint256 indexed userId, address indexed to, uint256 amount);\n', '\n', '  event AddCredit(address indexed client, uint256 amount);\n', '\n', '  event WithdrawCredit(address indexed client, address indexed to, uint256 amount);\n', '\n', '  event SetOracle(address indexed oracle);\n', '\n', '  event AddClient(\n', '    address indexed client,\n', '    address indexed owner,\n', '    bool canSlash,\n', '    uint256 gasPriceLimit,\n', '    uint256 minReportInterval,\n', '    uint256 maxReportInterval,\n', '    uint256 slasherHeartbeat\n', '  );\n', '\n', '  event SetClientActiveFlag(address indexed client, bool indexed active);\n', '\n', '  event SetCanSlashFlag(address indexed client, bool indexed canSlash);\n', '\n', '  event SetPokerKeyRewardWithdrawAllowance(uint256 indexed userId, bool allow);\n', '\n', '  struct PokeRewardOptions {\n', '    address to;\n', '    bool compensateInETH;\n', '  }\n', '\n', '  struct RewardHelperStruct {\n', '    uint256 gasPrice;\n', '    uint256 ethPrice;\n', '    uint256 cvpPrice;\n', '    uint256 totalInCVP;\n', '    uint256 compensationCVP;\n', '    uint256 bonusCVP;\n', '    uint256 earnedCVP;\n', '    uint256 earnedETH;\n', '  }\n', '\n', '  address public immutable WETH_TOKEN;\n', '\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  IEACAggregatorProxy public immutable FAST_GAS_ORACLE;\n', '\n', '  PowerPokeStaking public immutable POWER_POKE_STAKING;\n', '\n', '  IUniswapV2Router02 public immutable UNISWAP_ROUTER;\n', '\n', '  modifier onlyClientOwner(address client_) {\n', '    require(clients[client_].owner == msg.sender, "ONLY_CLIENT_OWNER");\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address cvpToken_,\n', '    address wethToken_,\n', '    address fastGasOracle_,\n', '    address uniswapRouter_,\n', '    address powerPokeStaking_\n', '  ) public {\n', '    require(cvpToken_ != address(0), "CVP_ADDR_IS_0");\n', '    require(wethToken_ != address(0), "WETH_ADDR_IS_0");\n', '    require(fastGasOracle_ != address(0), "FAST_GAS_ORACLE_IS_0");\n', '    require(uniswapRouter_ != address(0), "UNISWAP_ROUTER_IS_0");\n', '    require(powerPokeStaking_ != address(0), "POWER_POKE_STAKING_ADDR_IS_0");\n', '\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '    WETH_TOKEN = wethToken_;\n', '    FAST_GAS_ORACLE = IEACAggregatorProxy(fastGasOracle_);\n', '    POWER_POKE_STAKING = PowerPokeStaking(powerPokeStaking_);\n', '    UNISWAP_ROUTER = IUniswapV2Router02(uniswapRouter_);\n', '  }\n', '\n', '  function initialize(address owner_, address oracle_) external initializer {\n', '    _transferOwnership(owner_);\n', '    oracle = IPowerOracle(oracle_);\n', '  }\n', '\n', "  /*** CLIENT'S CONTRACT INTERFACE ***/\n", '  function authorizeReporter(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeHDH(userId_, pokerKey_);\n', '  }\n', '\n', '  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeNonHDH(userId_, pokerKey_, clients[msg.sender].defaultMinDeposit);\n', '  }\n', '\n', '  function authorizeNonReporterWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinDeposit_\n', '  ) external view override {\n', '    POWER_POKE_STAKING.authorizeNonHDH(userId_, pokerKey_, overrideMinDeposit_);\n', '  }\n', '\n', '  function authorizePoker(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeMember(userId_, pokerKey_, clients[msg.sender].defaultMinDeposit);\n', '  }\n', '\n', '  function authorizePokerWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinStake_\n', '  ) external view override {\n', '    POWER_POKE_STAKING.authorizeMember(userId_, pokerKey_, overrideMinStake_);\n', '  }\n', '\n', '  function slashReporter(uint256 slasherId_, uint256 times_) external override nonReentrant {\n', '    require(clients[msg.sender].active, "INVALID_CLIENT");\n', '    require(clients[msg.sender].canSlash, "CANT_SLASH");\n', '    if (times_ == 0) {\n', '      return;\n', '    }\n', '\n', '    POWER_POKE_STAKING.slashHDH(slasherId_, times_);\n', '  }\n', '\n', '  function reward(\n', '    uint256 userId_,\n', '    uint256 gasUsed_,\n', '    uint256 compensationPlan_,\n', '    bytes calldata pokeOptions_\n', '  ) external override nonReentrant whenNotPaused {\n', '    RewardHelperStruct memory helper;\n', '    require(clients[msg.sender].active, "INVALID_CLIENT");\n', '\n', '    PokeRewardOptions memory opts = abi.decode(pokeOptions_, (PokeRewardOptions));\n', '    if (opts.compensateInETH) {\n', '      gasUsed_ = gasUsed_.add(clients[msg.sender].fixedCompensationETH);\n', '    } else {\n', '      gasUsed_ = gasUsed_.add(clients[msg.sender].fixedCompensationCVP);\n', '    }\n', '\n', '    if (gasUsed_ == 0) {\n', '      return;\n', '    }\n', '\n', '    helper.ethPrice = oracle.getPriceByAsset(WETH_TOKEN);\n', '    helper.cvpPrice = oracle.getPriceByAsset(address(CVP_TOKEN));\n', '\n', '    helper.gasPrice = getGasPriceFor(msg.sender);\n', '    helper.compensationCVP = helper.gasPrice.mul(gasUsed_).mul(helper.ethPrice) / helper.cvpPrice;\n', '    uint256 userDeposit = POWER_POKE_STAKING.getDepositOf(userId_);\n', '\n', '    if (userDeposit != 0) {\n', '      helper.bonusCVP = getPokerBonus(msg.sender, compensationPlan_, gasUsed_, userDeposit);\n', '    }\n', '\n', '    helper.totalInCVP = helper.compensationCVP.add(helper.bonusCVP);\n', '    require(clients[msg.sender].credit >= helper.totalInCVP, "NOT_ENOUGH_CREDITS");\n', '    clients[msg.sender].credit = clients[msg.sender].credit.sub(helper.totalInCVP);\n', '\n', '    if (opts.compensateInETH) {\n', '      helper.earnedCVP = helper.bonusCVP;\n', '      rewards[userId_] = rewards[userId_].add(helper.bonusCVP);\n', '      helper.earnedETH = _payoutCompensationInETH(opts.to, helper.compensationCVP);\n', '    } else {\n', '      helper.earnedCVP = helper.compensationCVP.add(helper.bonusCVP);\n', '      rewards[userId_] = rewards[userId_].add(helper.earnedCVP);\n', '    }\n', '\n', '    emit RewardUser(\n', '      msg.sender,\n', '      userId_,\n', '      compensationPlan_,\n', '      opts.compensateInETH,\n', '      gasUsed_,\n', '      helper.gasPrice,\n', '      userDeposit,\n', '      helper.ethPrice,\n', '      helper.cvpPrice,\n', '      helper.compensationCVP,\n', '      helper.bonusCVP,\n', '      helper.earnedCVP,\n', '      helper.earnedETH\n', '    );\n', '  }\n', '\n', '  /*** CLIENT OWNER INTERFACE ***/\n', '  function transferClientOwnership(address client_, address to_) external override onlyClientOwner(client_) {\n', '    clients[client_].owner = to_;\n', '    emit TransferClientOwnership(client_, msg.sender, to_);\n', '  }\n', '\n', '  function addCredit(address client_, uint256 amount_) external override {\n', '    Client storage client = clients[client_];\n', '\n', '    require(client.active, "ONLY_ACTIVE_CLIENT");\n', '\n', '    CVP_TOKEN.transferFrom(msg.sender, address(this), amount_);\n', '    client.credit = client.credit.add(amount_);\n', '    totalCredits = totalCredits.add(amount_);\n', '\n', '    emit AddCredit(client_, amount_);\n', '  }\n', '\n', '  function withdrawCredit(\n', '    address client_,\n', '    address to_,\n', '    uint256 amount_\n', '  ) external override onlyClientOwner(client_) {\n', '    Client storage client = clients[client_];\n', '\n', '    client.credit = client.credit.sub(amount_);\n', '    totalCredits = totalCredits.sub(amount_);\n', '\n', '    CVP_TOKEN.transfer(to_, amount_);\n', '\n', '    emit WithdrawCredit(client_, to_, amount_);\n', '  }\n', '\n', '  function setReportIntervals(\n', '    address client_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external override onlyClientOwner(client_) {\n', '    require(maxReportInterval_ > minReportInterval_ && minReportInterval_ > 0, "INVALID_REPORT_INTERVALS");\n', '    clients[client_].minReportInterval = minReportInterval_;\n', '    clients[client_].maxReportInterval = maxReportInterval_;\n', '    emit SetReportIntervals(client_, minReportInterval_, maxReportInterval_);\n', '  }\n', '\n', '  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external override onlyClientOwner(client_) {\n', '    clients[client_].slasherHeartbeat = slasherHeartbeat_;\n', '    emit SetSlasherHeartbeat(client_, slasherHeartbeat_);\n', '  }\n', '\n', '  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external override onlyClientOwner(client_) {\n', '    clients[client_].gasPriceLimit = gasPriceLimit_;\n', '    emit SetGasPriceLimit(client_, gasPriceLimit_);\n', '  }\n', '\n', '  function setFixedCompensations(\n', '    address client_,\n', '    uint256 eth_,\n', '    uint256 cvp_\n', '  ) external override onlyClientOwner(client_) {\n', '    clients[client_].fixedCompensationETH = eth_;\n', '    clients[client_].fixedCompensationCVP = cvp_;\n', '    emit SetFixedCompensations(client_, eth_, cvp_);\n', '  }\n', '\n', '  function setBonusPlan(\n', '    address client_,\n', '    uint256 planId_,\n', '    bool active_,\n', '    uint64 bonusNominator_,\n', '    uint64 bonusDenominator_,\n', '    uint64 perGas_\n', '  ) external override onlyClientOwner(client_) {\n', '    bonusPlans[client_][planId_] = BonusPlan(active_, bonusNominator_, bonusDenominator_, perGas_);\n', '    emit SetBonusPlan(client_, planId_, active_, bonusNominator_, bonusDenominator_, perGas_);\n', '  }\n', '\n', '  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external override onlyClientOwner(client_) {\n', '    clients[client_].defaultMinDeposit = defaultMinDeposit_;\n', '    emit SetDefaultMinDeposit(client_, defaultMinDeposit_);\n', '  }\n', '\n', '  /*** POKER INTERFACE ***/\n', '  function withdrawRewards(uint256 userId_, address to_) external override {\n', '    if (pokerKeyRewardWithdrawAllowance[userId_] == true) {\n', '      POWER_POKE_STAKING.requireValidAdminOrPokerKey(userId_, msg.sender);\n', '    } else {\n', '      POWER_POKE_STAKING.requireValidAdminKey(userId_, msg.sender);\n', '    }\n', '    require(to_ != address(0), "0_ADDRESS");\n', '    uint256 rewardAmount = rewards[userId_];\n', '    require(rewardAmount > 0, "NOTHING_TO_WITHDRAW");\n', '    rewards[userId_] = 0;\n', '\n', '    CVP_TOKEN.transfer(to_, rewardAmount);\n', '\n', '    emit WithdrawRewards(userId_, to_, rewardAmount);\n', '  }\n', '\n', '  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external override {\n', '    POWER_POKE_STAKING.requireValidAdminKey(userId_, msg.sender);\n', '    pokerKeyRewardWithdrawAllowance[userId_] = allow_;\n', '    emit SetPokerKeyRewardWithdrawAllowance(userId_, allow_);\n', '  }\n', '\n', '  /*** OWNER INTERFACE ***/\n', '  function addClient(\n', '    address client_,\n', '    address owner_,\n', '    bool canSlash_,\n', '    uint256 gasPriceLimit_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external override onlyOwner {\n', '    require(maxReportInterval_ > minReportInterval_ && minReportInterval_ > 0, "INVALID_REPORT_INTERVALS");\n', '\n', '    Client storage c = clients[client_];\n', '    c.active = true;\n', '    c.canSlash = canSlash_;\n', '    c.owner = owner_;\n', '    c.gasPriceLimit = gasPriceLimit_;\n', '    c.minReportInterval = minReportInterval_;\n', '    c.maxReportInterval = maxReportInterval_;\n', '    c.slasherHeartbeat = uint256(-1);\n', '\n', '    emit AddClient(client_, owner_, canSlash_, gasPriceLimit_, minReportInterval_, maxReportInterval_, uint256(-1));\n', '  }\n', '\n', '  function setClientActiveFlag(address client_, bool active_) external override onlyOwner {\n', '    clients[client_].active = active_;\n', '    emit SetClientActiveFlag(client_, active_);\n', '  }\n', '\n', '  function setCanSlashFlag(address client_, bool canSlash) external override onlyOwner {\n', '    clients[client_].active = canSlash;\n', '    emit SetCanSlashFlag(client_, canSlash);\n', '  }\n', '\n', '  function setOracle(address oracle_) external override onlyOwner {\n', '    oracle = IPowerOracle(oracle_);\n', '    emit SetOracle(oracle_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses reward-operation\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses reward-operation\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** INTERNAL HELPERS ***/\n', '  function _payoutCompensationInETH(address _to, uint256 _cvpAmount) internal returns (uint256) {\n', '    CVP_TOKEN.approve(address(UNISWAP_ROUTER), _cvpAmount);\n', '\n', '    address[] memory path = new address[](2);\n', '    path[0] = address(CVP_TOKEN);\n', '    path[1] = address(WETH_TOKEN);\n', '\n', '    uint256[] memory amounts = UNISWAP_ROUTER.swapExactTokensForETH(_cvpAmount, uint256(0), path, _to, now.add(1800));\n', '    return amounts[1];\n', '  }\n', '\n', '  function _latestFastGas() internal view returns (uint256) {\n', '    return uint256(FAST_GAS_ORACLE.latestAnswer());\n', '  }\n', '\n', '  /*** GETTERS ***/\n', '  function creditOf(address client_) external view override returns (uint256) {\n', '    return clients[client_].credit;\n', '  }\n', '\n', '  function ownerOf(address client_) external view override returns (address) {\n', '    return clients[client_].owner;\n', '  }\n', '\n', '  function getMinMaxReportIntervals(address client_) external view override returns (uint256 min, uint256 max) {\n', '    return (clients[client_].minReportInterval, clients[client_].maxReportInterval);\n', '  }\n', '\n', '  function getSlasherHeartbeat(address client_) external view override returns (uint256) {\n', '    return clients[client_].slasherHeartbeat;\n', '  }\n', '\n', '  function getGasPriceLimit(address client_) external view override returns (uint256) {\n', '    return clients[client_].gasPriceLimit;\n', '  }\n', '\n', '  function getPokerBonus(\n', '    address client_,\n', '    uint256 bonusPlanId_,\n', '    uint256 gasUsed_,\n', '    uint256 userDeposit_\n', '  ) public view override returns (uint256) {\n', '    BonusPlan memory plan = bonusPlans[client_][bonusPlanId_];\n', '    require(plan.active, "INACTIVE_BONUS_PLAN");\n', '\n', '    // gasUsed_ * userDeposit_ * plan.bonusNumerator / bonusDenominator / plan.perGas\n', '    return gasUsed_.mul(userDeposit_).mul(plan.bonusNumerator) / plan.bonusDenominator / plan.perGas;\n', '  }\n', '\n', '  function getGasPriceFor(address client_) public view override returns (uint256) {\n', '    return Math.min(tx.gasprice, Math.min(_latestFastGas(), clients[client_].gasPriceLimit));\n', '  }\n', '}\n', '\n', '// File: contracts/PowerOracle.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerOracle is IPowerOracle, PowerOwnable, Initializable, PowerPausable, UniswapTWAPProvider {\n', '  using SafeMath for uint256;\n', '  using SafeCast for uint256;\n', '\n', '  uint256 internal constant COMPENSATION_PLAN_1_ID = 1;\n', '  uint256 internal constant COMPENSATION_PLAN_2_ID = 2;\n', '  uint256 public constant HUNDRED_PCT = 100 ether;\n', '\n', '  /// @notice The event emitted when a reporter calls a poke operation\n', '  event PokeFromReporter(uint256 indexed reporterId, uint256 tokenCount, uint256 rewardCount);\n', '\n', '  /// @notice The event emitted when a slasher executes poke and slashes the current reporter\n', '  event PokeFromSlasher(uint256 indexed slasherId, uint256 tokenCount, uint256 overdueCount);\n', '\n', '  /// @notice The event emitted when an arbitrary user calls poke operation\n', '  event Poke(address indexed poker, uint256 tokenCount);\n', '\n', '  /// @notice The event emitted when the owner updates the powerOracleStaking address\n', '  event SetPowerPoke(address powerPoke);\n', '\n', '  /// @notice The event emitted when the slasher timestamps are updated\n', '  event SlasherHeartbeat(uint256 indexed slasherId, uint256 prevSlasherTimestamp, uint256 newSlasherTimestamp);\n', '\n', '  /// @notice CVP token address\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  modifier onlyReporter(uint256 reporterId_, bytes calldata rewardOpts) {\n', '    uint256 gasStart = gasleft();\n', '    powerPoke.authorizeReporter(reporterId_, msg.sender);\n', '    _;\n', '    uint256 gasUsed = gasStart.sub(gasleft());\n', '    powerPoke.reward(reporterId_, gasUsed, COMPENSATION_PLAN_1_ID, rewardOpts);\n', '  }\n', '\n', '  modifier denyContract() {\n', '    require(msg.sender == tx.origin, "CONTRACT_CALL");\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address cvpToken_,\n', '    uint256 anchorPeriod_,\n', '    TokenConfig[] memory configs\n', '  ) public UniswapTWAPProvider(anchorPeriod_, configs) UniswapConfig(configs) {\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '  }\n', '\n', '  function initialize(address owner_, address powerPoke_) external initializer {\n', '    _transferOwnership(owner_);\n', '    powerPoke = IPowerPoke(powerPoke_);\n', '  }\n', '\n', '  /*** Current Poke Interface ***/\n', '\n', '  function _fetchEthPrice() internal returns (uint256) {\n', '    bytes32 symbolHash = keccak256(abi.encodePacked("ETH"));\n', '    if (getIntervalStatus(symbolHash) == ReportInterval.LESS_THAN_MIN) {\n', '      return uint256(prices[symbolHash].value);\n', '    }\n', '    uint256 ethPrice = fetchEthPrice();\n', '    _savePrice(symbolHash, ethPrice);\n', '    return ethPrice;\n', '  }\n', '\n', '  function _fetchCvpPrice(uint256 ethPrice_) internal returns (uint256) {\n', '    bytes32 symbolHash = keccak256(abi.encodePacked("CVP"));\n', '    if (getIntervalStatus(symbolHash) == ReportInterval.LESS_THAN_MIN) {\n', '      return uint256(prices[symbolHash].value);\n', '    }\n', '    uint256 cvpPrice = fetchCvpPrice(ethPrice_);\n', '    _savePrice(symbolHash, cvpPrice);\n', '    return cvpPrice;\n', '  }\n', '\n', '  function _fetchAndSavePrice(\n', '    string memory symbol_,\n', '    uint256 ethPrice_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) internal returns (ReportInterval) {\n', '    TokenConfig memory config = getTokenConfigBySymbol(symbol_);\n', '    require(config.priceSource == PriceSource.REPORTER, "NOT_REPORTER");\n', '    bytes32 symbolHash = keccak256(abi.encodePacked(symbol_));\n', '\n', '    ReportInterval intervalStatus = getIntervalStatusForIntervals(symbolHash, minReportInterval_, maxReportInterval_);\n', '    if (intervalStatus == ReportInterval.LESS_THAN_MIN) {\n', '      return intervalStatus;\n', '    }\n', '\n', '    uint256 price;\n', '    if (symbolHash == ethHash) {\n', '      price = ethPrice_;\n', '    } else {\n', '      price = fetchAnchorPrice(symbol_, config, ethPrice_);\n', '    }\n', '\n', '    _savePrice(symbolHash, price);\n', '\n', '    return intervalStatus;\n', '  }\n', '\n', '  function _savePrice(bytes32 _symbolHash, uint256 price_) internal {\n', '    prices[_symbolHash] = Price(block.timestamp.toUint128(), price_.toUint128());\n', '  }\n', '\n', '  function priceInternal(TokenConfig memory config_) internal view returns (uint256) {\n', '    if (config_.priceSource == PriceSource.REPORTER) return prices[config_.symbolHash].value;\n', '    if (config_.priceSource == PriceSource.FIXED_USD) return config_.fixedPrice;\n', '    if (config_.priceSource == PriceSource.FIXED_ETH) {\n', '      uint256 usdPerEth = prices[ethHash].value;\n', '      require(usdPerEth > 0, "ETH_PRICE_NOT_SET");\n', '      return mul(usdPerEth, config_.fixedPrice) / ethBaseUnit;\n', '    }\n', '    revert("UNSUPPORTED_PRICE_CASE");\n', '  }\n', '\n', '  /*** Pokers ***/\n', '\n', '  /**\n', '   * @notice A reporter pokes symbols with incentive to be rewarded\n', "   * @param reporterId_ The valid reporter's user ID\n", '   * @param symbols_ Asset symbols to poke\n', '   */\n', '  function pokeFromReporter(\n', '    uint256 reporterId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external override onlyReporter(reporterId_, rewardOpts) whenNotPaused denyContract {\n', '    uint256 len = symbols_.length;\n', '    require(len > 0, "MISSING_SYMBOLS");\n', '\n', '    uint256 ethPrice = _fetchEthPrice();\n', '    _fetchCvpPrice(ethPrice);\n', '    uint256 rewardCount = 0;\n', '    (uint256 minReportInterval, uint256 maxReportInterval) = _getMinMaxReportInterval();\n', '\n', '    for (uint256 i = 0; i < len; i++) {\n', '      if (\n', '        _fetchAndSavePrice(symbols_[i], ethPrice, minReportInterval, maxReportInterval) != ReportInterval.LESS_THAN_MIN\n', '      ) {\n', '        rewardCount++;\n', '      }\n', '    }\n', '\n', '    require(rewardCount > 0, "NOTHING_UPDATED");\n', '\n', '    emit PokeFromReporter(reporterId_, len, rewardCount);\n', '  }\n', '\n', '  /**\n', '   * @notice A slasher pokes symbols with incentive to be rewarded\n', "   * @param slasherId_ The slasher's user ID\n", '   * @param symbols_ Asset symbols to poke\n', '   */\n', '  function pokeFromSlasher(\n', '    uint256 slasherId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external override whenNotPaused denyContract {\n', '    uint256 gasStart = gasleft();\n', '    powerPoke.authorizeNonReporter(slasherId_, msg.sender);\n', '    uint256 len = symbols_.length;\n', '    require(len > 0, "MISSING_SYMBOLS");\n', '\n', '    uint256 ethPrice = _fetchEthPrice();\n', '    _fetchCvpPrice(ethPrice);\n', '    uint256 overdueCount = 0;\n', '    (uint256 minReportInterval, uint256 maxReportInterval) = _getMinMaxReportInterval();\n', '\n', '    for (uint256 i = 0; i < len; i++) {\n', '      if (\n', '        _fetchAndSavePrice(symbols_[i], ethPrice, minReportInterval, maxReportInterval) ==\n', '        ReportInterval.GREATER_THAN_MAX\n', '      ) {\n', '        overdueCount++;\n', '      }\n', '    }\n', '\n', '    // update with no constraints, compensate & reward\n', '    if (overdueCount > 0) {\n', '      _updateSlasherTimestamp(slasherId_, false);\n', '      powerPoke.slashReporter(slasherId_, overdueCount);\n', '\n', '      uint256 gasUsed = gasStart.sub(gasleft());\n', '      powerPoke.reward(slasherId_, gasUsed, COMPENSATION_PLAN_1_ID, rewardOpts);\n', '    } else {\n', '      // treat it as a slasherHeartbeat call, do neither compensate nor reward\n', '      _updateSlasherTimestamp(slasherId_, true);\n', '    }\n', '\n', '    emit PokeFromSlasher(slasherId_, len, overdueCount);\n', '  }\n', '\n', '  function slasherHeartbeat(uint256 slasherId_) external override whenNotPaused denyContract {\n', '    uint256 gasStart = gasleft();\n', '    powerPoke.authorizeNonReporter(slasherId_, msg.sender);\n', '\n', '    _updateSlasherTimestamp(slasherId_, true);\n', '\n', '    PowerPoke.PokeRewardOptions memory opts = PowerPoke.PokeRewardOptions(msg.sender, false);\n', '    bytes memory rewardConfig = abi.encode(opts);\n', '    // reward in CVP\n', '    powerPoke.reward(slasherId_, gasStart.sub(gasleft()), COMPENSATION_PLAN_2_ID, rewardConfig);\n', '  }\n', '\n', '  function _updateSlasherTimestamp(uint256 _slasherId, bool assertOnTimeDelta) internal {\n', '    uint256 prevSlasherUpdate = lastSlasherUpdates[_slasherId];\n', '\n', '    if (assertOnTimeDelta) {\n', '      uint256 delta = block.timestamp.sub(prevSlasherUpdate);\n', '      require(delta >= powerPoke.getSlasherHeartbeat(address(this)), "BELOW_HEARTBEAT_INTERVAL");\n', '    }\n', '\n', '    lastSlasherUpdates[_slasherId] = block.timestamp;\n', '    emit SlasherHeartbeat(_slasherId, prevSlasherUpdate, block.timestamp);\n', '  }\n', '\n', '  /**\n', '   * @notice Arbitrary user pokes symbols without being rewarded\n', '   * @param symbols_ Asset symbols to poke\n', '   */\n', '  function poke(string[] memory symbols_) external override whenNotPaused {\n', '    uint256 len = symbols_.length;\n', '    require(len > 0, "MISSING_SYMBOLS");\n', '\n', '    uint256 ethPrice = _fetchEthPrice();\n', '    (uint256 minReportInterval, uint256 maxReportInterval) = _getMinMaxReportInterval();\n', '\n', '    for (uint256 i = 0; i < len; i++) {\n', '      _fetchAndSavePrice(symbols_[i], ethPrice, minReportInterval, maxReportInterval);\n', '    }\n', '\n', '    emit Poke(msg.sender, len);\n', '  }\n', '\n', '  /*** Owner Interface ***/\n', '\n', '  /**\n', '   * @notice The owner sets a new powerPoke contract\n', '   * @param powerPoke_ The powerPoke contract address\n', '   */\n', '  function setPowerPoke(address powerPoke_) external override onlyOwner {\n', '    powerPoke = PowerPoke(powerPoke_);\n', '    emit SetPowerPoke(powerPoke_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses poke*-operations\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses poke*-operations\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** Viewers ***/\n', '\n', '  function _getMinMaxReportInterval() internal view returns (uint256 min, uint256 max) {\n', '    return powerPoke.getMinMaxReportIntervals(address(this));\n', '  }\n', '\n', '  function getIntervalStatus(bytes32 _symbolHash) public view returns (ReportInterval) {\n', '    (uint256 minReportInterval, uint256 maxReportInterval) = _getMinMaxReportInterval();\n', '\n', '    return getIntervalStatusForIntervals(_symbolHash, minReportInterval, maxReportInterval);\n', '  }\n', '\n', '  function getIntervalStatusForIntervals(\n', '    bytes32 symbolHash_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) public view returns (ReportInterval) {\n', '    uint256 delta = block.timestamp.sub(prices[symbolHash_].timestamp);\n', '\n', '    if (delta < minReportInterval_) {\n', '      return ReportInterval.LESS_THAN_MIN;\n', '    }\n', '\n', '    if (delta < maxReportInterval_) {\n', '      return ReportInterval.OK;\n', '    }\n', '\n', '    return ReportInterval.GREATER_THAN_MAX;\n', '  }\n', '\n', '  /**\n', '   * @notice Get the underlying price of a token\n', '   * @param token_ The token address for price retrieval\n', '   * @return Price denominated in USD, with 6 decimals, for the given asset address\n', '   */\n', '  function getPriceByAsset(address token_) external view override returns (uint256) {\n', '    TokenConfig memory config = getTokenConfigByUnderlying(token_);\n', '    return priceInternal(config);\n', '  }\n', '\n', '  /**\n', '   * @notice Get the official price for a symbol, like "COMP"\n', '   * @param symbol_ The symbol for price retrieval\n', '   * @return Price denominated in USD, with 6 decimals\n', '   */\n', '  function getPriceBySymbol(string calldata symbol_) external view override returns (uint256) {\n', '    TokenConfig memory config = getTokenConfigBySymbol(symbol_);\n', '    return priceInternal(config);\n', '  }\n', '\n', '  /**\n', '   * @notice Get price by a token symbol hash,\n', '   *    like "0xd6aca1be9729c13d677335161321649cccae6a591554772516700f986f942eaa" for USDC\n', '   * @param symbolHash_ The symbol hash for price retrieval\n', '   * @return Price denominated in USD, with 6 decimals, for the given asset address\n', '   */\n', '  function getPriceBySymbolHash(bytes32 symbolHash_) external view override returns (uint256) {\n', '    TokenConfig memory config = getTokenConfigBySymbolHash(symbolHash_);\n', '    return priceInternal(config);\n', '  }\n', '\n', '  /**\n', '   * @notice Get the underlying price of a cToken\n', '   * @dev Implements the PriceOracle interface for Compound v2.\n', '   * @param cToken_ The cToken address for price retrieval\n', '   * @return Price denominated in USD, with 18 decimals, for the given cToken address\n', '   */\n', '  function getUnderlyingPrice(address cToken_) external view override returns (uint256) {\n', '    TokenConfig memory config = getTokenConfigByCToken(cToken_);\n', '    // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n', '    // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\n', '    return mul(1e30, priceInternal(config)) / config.baseUnit;\n', '  }\n', '\n', '  /**\n', '   * @notice Get the price by underlying address\n', '   * @dev Implements the old PriceOracle interface for Compound v2.\n', '   * @param token_ The underlying address for price retrieval\n', '   * @return Price denominated in USD, with 18 decimals, for the given underlying address\n', '   */\n', '  function assetPrices(address token_) external view override returns (uint256) {\n', '    TokenConfig memory config = getTokenConfigByUnderlying(token_);\n', '    // Return price in the same format as getUnderlyingPrice, but by token address\n', '    return mul(1e30, priceInternal(config)) / config.baseUnit;\n', '  }\n', '}']