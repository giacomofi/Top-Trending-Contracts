['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.7.0 <0.8.0;\n', '\n', "import './IERC20.sol';\n", "import './PreparedPayinV5.sol';\n", '\n', 'contract ChangeNowMasterPayinV5 {\n', '    address public owner;\n', '    address public successor = address(0);\n', '    uint256 public payins = 0;\n', '\n', '    bytes constant payinBytecode = type(PreparedPayinV5).creationCode;\n', '    bytes32 constant payinBytecodeHash = keccak256(payinBytecode);\n', '\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Checks that caller is owner.\n', '     */\n', '    modifier isOwner() {\n', '        require(msg.sender == owner, "Caller is not owner");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Checks that caller is successor.\n', '     */\n', '    modifier isSuccessor() {\n', '        require(msg.sender == successor, "Caller is not successor");\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Sets new successor (only owner).\n', '     */\n', '    function setSuccessor(address newSuccessor) external isOwner {\n', '        successor = newSuccessor;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Takes ownership (only successor).\n', '     */\n', '    function takeOwnership() external isSuccessor {\n', '        owner = successor;\n', '        successor = address(0);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Converts payin index into subcontract address. Indexing starts from 0.\n', '     *\n', '     * @param {uint256} index - the payin index.\n', '     *\n', '     * @return {address} the corresponding payin subcontract address.\n', '     */\n', '    function payinAddress(uint256 index)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return address(uint256(keccak256(abi.encodePacked(\n', "            hex'ff',\n", '            address(this),\n', '            bytes32(index),\n', '            payinBytecodeHash\n', '        ))));\n', '    }\n', '\n', '    /**\n', '     * @notice Helper function to call payin contract in non-standard way\n', '     * (place selector and following args after token address)\n', '     *\n', '     */\n', '    function _payin_withdrawERC20(address token, address payin, address toAddress, uint256 amount)\n', '        internal\n', '    {\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(0x40, add(ptr, 0x80))\n', '\n', '            mstore(ptr, shl(224, 0xa9059cbb)) // "transfer(address,uint256)" [ERC20 method]\n', '            mstore(add(ptr, 0x4), toAddress)  // 1st arg\n', '            mstore(add(ptr, 0x24), amount)    // 2nd arg\n', '            mstore(add(ptr, 0x44), token)     // (token address)\n', '\n', '            let result := call(gas(), payin, 0, ptr, 0x64, 0, 0)\n', '\n', '            if iszero(result) { revert(0, 0) }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Generates next batch of payin subcontracts, up to maxCount\n', '     * (as much as enough gas left), but not less than minCount (be sure you\n', '     * have enough gas to covert the minimum).\n', '     *\n', '     * @param {uint256} minCount - the minimum payins count to generate.\n', '     * @param {uint256} maxCount - the maximum payins count to generate.\n', '     *\n', '     * @return {uint256,uint256} - the tuple (fromIndex, count) of:\n', '     * lowest payin index of generated batch and the batch size.\n', '     *\n', '     * NOTE: the function is not restricted by the isOwner modifier\n', '     *       since there is nothing to protect: the subcontracts are owned\n', '     *       by the factory (this contract) and this one is owned by the\n', '     *       owner, anyone can spend gas to help us to generate the pool.\n', '     */\n', '    function generateNextBatch(uint256 minCount, uint256 maxCount)\n', '        external\n', '        returns (uint256, uint256)\n', '    {\n', "        require(minCount > 0, 'assert: minCount > 0');\n", "        require(maxCount >= minCount, 'assert: maxCount > minCount');\n", '\n', '        uint256 fromIndex = payins;\n', '        uint256 calcSinceIndex = fromIndex + minCount;\n', '        uint256 toIndex = fromIndex + maxCount;\n', '        uint256 totalGasUsed = 0;\n', '\n', '        uint256 index = fromIndex;\n', '\n', '        bytes memory bytecode = payinBytecode;\n', '\n', '        while (index < toIndex) {\n', '            if (index >= calcSinceIndex) {\n', '                uint256 avgGas = (totalGasUsed / (index - fromIndex));\n', '\n', '                // is there enough gas left (with extra 5k) to generate next?\n', '                if (gasleft() < (avgGas + 5000)) {\n', '                    break;\n', '                }\n', '            }\n', '\n', '            uint256 gasBefore = gasleft();\n', '\n', '            // create payin subcontract\n', '            bytes32 salt = bytes32(index);\n', '            address payin;\n', '            assembly {\n', '                payin := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '            }\n', '\n', '            totalGasUsed += gasBefore - gasleft();\n', '            index++;\n', '        }\n', '\n', '        // save new generated payins count\n', '        payins = index;\n', '\n', '        // return (idx, count)\n', '        return (fromIndex, index - fromIndex);\n', '    }\n', '\n', '    /**\n', '     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\n', '     *\n', '     * @param {address} token - the ERC20 token address to harvest for.\n', '     * @param {uint256} fromIndex - the lowest index of payin of batch to harvest from.\n', '     * @param {uint256} count - the count of payins (batch size) to harvest from.\n', '     * @param {address} toAddress - the destination address to send harvested tokens to.\n', '     *\n', '     * @return {uint256} totalAmount - the total harvested amount.\n', '     */\n', '    function harvestERC20Batch(address token, uint256 fromIndex, uint256 count, address toAddress)\n', '        external\n', '        isOwner\n', '        returns (uint256)\n', '    {\n', "        require(toAddress != address(this), 'toAddress is this');\n", "        require(toAddress != address(0), 'toAddress is zero');\n", '\n', '        uint256 toIndex = fromIndex + count;\n', '        uint256 totalAmount = 0;\n', '\n', "        require(toIndex <= payins, 'not enough payins');\n", '\n', '        // send from payins (batch)\n', '        while (fromIndex < toIndex) {\n', '            address payin = payinAddress(fromIndex);\n', '            uint256 amount = IERC20(token).balanceOf(payin);\n', '\n', '            if (amount > 0) {\n', '                _payin_withdrawERC20(token, payin, toAddress, amount);\n', '                totalAmount += amount;\n', '            }\n', '\n', '            fromIndex++;\n', '        }\n', '\n', '        return totalAmount;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Harvests (withdraw whole balance) ERC20 tokens from batch of payins.\n', '     *\n', '     * @param {address} token - the ERC20 token address to harvest for.\n', '     * @param {address[]} batch - the batch of addresses to harvest from.\n', '     * @param {address} toAddress - the destination address to send harvested tokens to.\n', '     *\n', '     * @return {uint256} totalAmount - the total harvested amount.\n', '     */\n', '    function harvestERC20BatchFor(address token, address[] calldata batch, address toAddress)\n', '    external isOwner returns (uint256)\n', '    {\n', "        require(toAddress != address(this), 'toAddress is this');\n", "        require(toAddress != address(0), 'toAddress is zero');\n", '\n', '        uint256 totalAmount = 0;\n', '\n', '        // send from given payins (batch)\n', '        for (uint256 i = 0; i < batch.length; i++) {\n', '            address payin = batch[i];\n', '            uint256 amount = IERC20(token).balanceOf(payin);\n', '\n', '            if (amount > 0) {\n', '                _payin_withdrawERC20(token, payin, toAddress, amount);\n', '                totalAmount += amount;\n', '            }\n', '        }\n', '\n', '        return totalAmount;\n', '    }\n', '}']