['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity =0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', "import './CentaurLPToken.sol';\n", "import './libraries/Initializable.sol';\n", "import './libraries/SafeMath.sol';\n", "import './libraries/CentaurMath.sol';\n", "import './interfaces/IERC20.sol';\n", "import './interfaces/ICentaurFactory.sol';\n", "import './interfaces/ICentaurPool.sol';\n", "import './interfaces/ICentaurSettlement.sol';\n", "import './interfaces/IOracle.sol';\n", '\n', 'contract CentaurPool is Initializable, CentaurLPToken {\n', '    using SafeMath for uint;\n', '\n', "    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '    address public factory;\n', '    address public baseToken;\n', '    uint public baseTokenDecimals;\n', '    address public oracle;\n', '    uint public oracleDecimals;\n', '\n', '    uint public baseTokenTargetAmount;\n', '    uint public baseTokenBalance;\n', '\n', '    uint public liquidityParameter;\n', '\n', '    bool public tradeEnabled;\n', '    bool public depositEnabled;\n', '    bool public withdrawEnabled;\n', '\n', '    uint private unlocked;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'CentaurSwap: LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    modifier tradeAllowed() {\n', '        require(tradeEnabled, "CentaurSwap: TRADE_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier depositAllowed() {\n', '        require(depositEnabled, "CentaurSwap: DEPOSIT_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier withdrawAllowed() {\n', '        require(withdrawEnabled, "CentaurSwap: WITHDRAW_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyRouter() {\n', "        require(msg.sender == ICentaurFactory(factory).router(), 'CentaurSwap: ONLY_ROUTER_ALLOWED');\n", '        _;\n', '    }\n', '\n', '    modifier onlyFactory() {\n', "        require(msg.sender == factory, 'CentaurSwap: ONLY_FACTORY_ALLOWED');\n", '        _;\n', '    }\n', '\n', '    event Mint(address indexed sender, uint amount);\n', '    event Burn(address indexed sender, uint amount, address indexed to);\n', '    event AmountIn(address indexed sender, uint amount);\n', '    event AmountOut(address indexed sender, uint amount, address indexed to);\n', '    event EmergencyWithdraw(uint256 _timestamp, address indexed _token, uint256 _amount, address indexed _to);\n', '\n', '    function init(address _factory, address _baseToken, address _oracle, uint _liquidityParameter) external initializer {\n', '        factory = _factory;\n', '        baseToken = _baseToken;\n', '        baseTokenDecimals = IERC20(baseToken).decimals();\n', '        oracle = _oracle;\n', '        oracleDecimals = IOracle(oracle).decimals();\n', '\n', '        tradeEnabled = false;\n', '        depositEnabled = false;\n', '        withdrawEnabled = false;\n', '\n', '        liquidityParameter = _liquidityParameter;\n', '\n', '        symbol = string(abi.encodePacked("CS-", IERC20(baseToken).symbol()));\n', '        decimals = baseTokenDecimals;\n', '\n', '        unlocked = 1;\n', '    }\n', '\n', '    function _safeTransfer(address token, address to, uint value) private {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'CentaurSwap: TRANSFER_FAILED');\n", '    }\n', '\n', '    function mint(address to) external lock onlyRouter depositAllowed returns (uint liquidity) {\n', '        uint balance = IERC20(baseToken).balanceOf(address(this));\n', '        uint amount = balance.sub(baseTokenBalance);\n', '\n', '        if (totalSupply == 0) {\n', '            liquidity = amount.add(baseTokenTargetAmount);\n', '        } else {\n', '            liquidity = amount.mul(totalSupply).div(baseTokenTargetAmount);\n', '        }\n', '\n', "        require(liquidity > 0, 'CentaurSwap: INSUFFICIENT_LIQUIDITY_MINTED');\n", '        _mint(to, liquidity);\n', '\n', '        baseTokenBalance = baseTokenBalance.add(amount);\n', '        baseTokenTargetAmount = baseTokenTargetAmount.add(amount);\n', '\n', '        emit Mint(msg.sender, amount);\n', '    }\n', '\n', '    function burn(address to) external lock onlyRouter withdrawAllowed returns (uint amount) {\n', '        uint liquidity = balanceOf[address(this)];\n', '\n', '        amount = liquidity.mul(baseTokenTargetAmount).div(totalSupply);\n', '\n', "        require(amount > 0, 'CentaurSwap: INSUFFICIENT_LIQUIDITY_BURNED');\n", '\n', "        require(baseTokenBalance >= amount, 'CentaurSwap: INSUFFICIENT_LIQUIDITY');\n", '\n', '        _burn(address(this), liquidity);\n', '        _safeTransfer(baseToken, to, amount);\n', '\n', '        baseTokenBalance = baseTokenBalance.sub(amount);\n', '        baseTokenTargetAmount = baseTokenTargetAmount.sub(amount);\n', '\n', '        emit Burn(msg.sender, amount, to);\n', '    }\n', '\n', '    function swapTo(address _sender, address _fromToken, uint _amountIn, uint _value, address _receiver) external lock onlyRouter tradeAllowed returns (uint maxAmount) {\n', "        require(_fromToken != baseToken, 'CentaurSwap: INVALID_POOL');\n", '\n', '        address pool = ICentaurFactory(factory).getPool(_fromToken);\n', "        require(pool != address(0), 'CentaurSwap: POOL_NOT_FOUND');\n", '\n', '        // Check if has pendingSettlement\n', '        address settlement = ICentaurFactory(factory).settlement();\n', "        require(!ICentaurSettlement(settlement).hasPendingSettlement(_sender, address(this)), 'CentaurSwap: PENDING_SETTLEMENT');\n", '        \n', '        // maxAmount because amount might be lesser during settlement. (If amount is more, excess is given back to pool)\n', '        maxAmount = getAmountOutFromValue(_value);\n', '\n', '        ICentaurSettlement.Settlement memory pendingSettlement = ICentaurSettlement.Settlement(\n', '                pool,\n', '                _amountIn,\n', '                ICentaurPool(pool).baseTokenTargetAmount(),\n', '                (ICentaurPool(pool).baseTokenBalance()).sub(_amountIn),\n', '                ICentaurPool(pool).liquidityParameter(),\n', '                address(this), \n', '                maxAmount,\n', '                baseTokenTargetAmount,\n', '                baseTokenBalance,\n', '                liquidityParameter,\n', '                _receiver,\n', '                block.timestamp.add(ICentaurSettlement(settlement).settlementDuration())\n', '            );\n', '\n', '        // Subtract maxAmount from baseTokenBalance first, difference (if any) will be added back during settlement\n', '        baseTokenBalance = baseTokenBalance.sub(maxAmount);\n', '\n', '        // Add to pending settlement\n', '        ICentaurSettlement(settlement).addSettlement(_sender, pendingSettlement);\n', '\n', '        // Transfer amount to settlement for escrow\n', '        _safeTransfer(baseToken, settlement, maxAmount);\n', '\n', '        return maxAmount;\n', '    }\n', '\n', '    function swapFrom(address _sender) external lock onlyRouter tradeAllowed returns (uint amount, uint value) {\n', '        uint balance = IERC20(baseToken).balanceOf(address(this));\n', '\n', "        require(balance > baseTokenBalance, 'CentaurSwap: INSUFFICIENT_SWAP_AMOUNT');\n", '\n', '        // Check if has pendingSettlement\n', '        address settlement = ICentaurFactory(factory).settlement();\n', "        require(!ICentaurSettlement(settlement).hasPendingSettlement(_sender, address(this)), 'CentaurSwap: PENDING_SETTLEMENT');\n", '\n', '        amount = balance.sub(baseTokenBalance);\n', '        value = getValueFromAmountIn(amount);\n', '\n', '        baseTokenBalance = balance;\n', '\n', '        emit AmountIn(_sender, amount);\n', '\n', '        return (amount, value);\n', '    }\n', '\n', '    function swapSettle(address _sender) external lock returns (uint, address) {\n', '        address settlement = ICentaurFactory(factory).settlement();\n', '        ICentaurSettlement.Settlement memory pendingSettlement = ICentaurSettlement(settlement).getPendingSettlement(_sender, address(this));\n', '\n', "        require (pendingSettlement.settlementTimestamp != 0, 'CentaurSwap: NO_PENDING_SETTLEMENT');\n", "        require (pendingSettlement.tPool == address(this), 'CentaurSwap: WRONG_POOL_SETTLEMENT');\n", "        require (block.timestamp >= pendingSettlement.settlementTimestamp, 'CentaurSwap: SETTLEMENT_STILL_PENDING');\n", '\n', '        uint newfPoolOraclePrice = ICentaurPool(pendingSettlement.fPool).getOraclePrice();\n', '        uint newtPoolOraclePrice = getOraclePrice();\n', '\n', '        uint newValue = CentaurMath.getValueFromAmountIn(pendingSettlement.amountIn, newfPoolOraclePrice, ICentaurPool(pendingSettlement.fPool).baseTokenDecimals(), pendingSettlement.fPoolBaseTokenTargetAmount, pendingSettlement.fPoolBaseTokenBalance, pendingSettlement.fPoolLiquidityParameter);\n', '        uint newAmount = CentaurMath.getAmountOutFromValue(newValue, newtPoolOraclePrice, baseTokenDecimals, pendingSettlement.tPoolBaseTokenTargetAmount, pendingSettlement.tPoolBaseTokenBalance, pendingSettlement.tPoolLiquidityParameter);\n', '\n', '        uint poolFee = ICentaurFactory(factory).poolFee();\n', '        address router = ICentaurFactory(factory).router();\n', '\n', '        // Remove settlement and receive escrowed amount\n', '        ICentaurSettlement(settlement).removeSettlement(_sender, pendingSettlement.fPool, pendingSettlement.tPool);\n', '\n', '        if (newAmount > pendingSettlement.maxAmountOut) {\n', '\n', '            uint fee = (pendingSettlement.maxAmountOut).mul(poolFee).div(100 ether);\n', '            uint amountOut = pendingSettlement.maxAmountOut.sub(fee);\n', '\n', '            if (msg.sender == router) {\n', '                _safeTransfer(baseToken, router, amountOut);\n', '            } else {\n', '                _safeTransfer(baseToken, pendingSettlement.receiver, amountOut);\n', '            }\n', '            emit AmountOut(_sender, amountOut, pendingSettlement.receiver);\n', '\n', '            baseTokenBalance = baseTokenBalance.add(fee);\n', '            baseTokenTargetAmount = baseTokenTargetAmount.add(fee);\n', '\n', '            return (amountOut, pendingSettlement.receiver);\n', '        } else {\n', '            uint fee = (newAmount).mul(poolFee).div(100 ether);\n', '            uint amountOut = newAmount.sub(fee);\n', '\n', '            if (msg.sender == router) {\n', '                _safeTransfer(baseToken, router, amountOut);\n', '            } else {\n', '                _safeTransfer(baseToken, pendingSettlement.receiver, amountOut);\n', '            }\n', '            emit AmountOut(_sender, amountOut, pendingSettlement.receiver);\n', '\n', '            // Difference added back to baseTokenBalance\n', '            uint difference = (pendingSettlement.maxAmountOut).sub(amountOut);\n', '            baseTokenBalance = baseTokenBalance.add(difference);\n', '\n', '            // TX fee goes back into pool for liquidity providers\n', '            baseTokenTargetAmount = baseTokenTargetAmount.add(difference);\n', '\n', '            return (amountOut, pendingSettlement.receiver);\n', '        }\n', '    }\n', '\n', '    function getOraclePrice() public view returns (uint price) {\n', '        (, int answer,,,) = IOracle(oracle).latestRoundData();\n', '\n', '        // Returns price in 18 decimals\n', '        price = uint(answer).mul(10 ** uint(18).sub(oracleDecimals));\n', '    }\n', '\n', '    // Swap Exact Tokens For Tokens (getAmountOut)\n', '    function getAmountOutFromValue(uint _value) public view returns (uint amount) {\n', '        amount = CentaurMath.getAmountOutFromValue(_value, getOraclePrice(), baseTokenDecimals,  baseTokenTargetAmount, baseTokenBalance, liquidityParameter);\n', '    \n', '        require(baseTokenBalance > amount, "CentaurSwap: INSUFFICIENT_LIQUIDITY");\n', '    }\n', '\n', '    function getValueFromAmountIn(uint _amount) public view returns (uint value) {\n', '        value = CentaurMath.getValueFromAmountIn(_amount, getOraclePrice(), baseTokenDecimals, baseTokenTargetAmount, baseTokenBalance, liquidityParameter);\n', '    }\n', '\n', '    // Swap Tokens For Exact Tokens (getAmountIn)\n', '    function getAmountInFromValue(uint _value) public view returns (uint amount) {\n', '        amount = CentaurMath.getAmountInFromValue(_value, getOraclePrice(), baseTokenDecimals,  baseTokenTargetAmount, baseTokenBalance, liquidityParameter);\n', '    }\n', '\n', '    function getValueFromAmountOut(uint _amount) public view returns (uint value) {\n', '        require(baseTokenBalance > _amount, "CentaurSwap: INSUFFICIENT_LIQUIDITY");\n', '\n', '        value = CentaurMath.getValueFromAmountOut(_amount, getOraclePrice(), baseTokenDecimals, baseTokenTargetAmount, baseTokenBalance, liquidityParameter);\n', '    }\n', '\n', '    // Helper functions\n', '    function setFactory(address _factory) external onlyFactory {\n', '        factory = _factory;\n', '    }\n', '\n', '    function setTradeEnabled(bool _tradeEnabled) external onlyFactory {\n', '        tradeEnabled = _tradeEnabled;\n', '    }\n', '\n', '    function setDepositEnabled(bool _depositEnabled) external onlyFactory {\n', '        depositEnabled = _depositEnabled;\n', '    }\n', '\n', '    function setWithdrawEnabled(bool _withdrawEnabled) external onlyFactory {\n', '        withdrawEnabled = _withdrawEnabled;\n', '    }\n', '\n', '    function setLiquidityParameter(uint _liquidityParameter) external onlyFactory {\n', '        liquidityParameter = _liquidityParameter;\n', '    }\n', '\n', '    function emergencyWithdraw(address _token, uint _amount, address _to) external onlyFactory {\n', '        _safeTransfer(_token, _to, _amount);\n', '\n', '        emit EmergencyWithdraw(block.timestamp, _token, _amount, _to);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity =0.6.12;\n', '\n', "import './libraries/SafeMath.sol';\n", '\n', 'contract CentaurLPToken {\n', '    using SafeMath for uint;\n', '\n', "    string public constant name = 'CentaurSwap LP Token';\n", '    string public symbol;\n', '    uint256 public decimals = 18;\n', '    uint  public totalSupply;\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping(address => uint)) public allowance;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function _mint(address to, uint value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint value) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint value) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value) external returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint value) external returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value) external returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity >=0.4.24 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' * \n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' * \n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function _isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { cs := extcodesize(self) }\n', '        return cs == 0;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'import { SafeMath } from "./SafeMath.sol";\n', "import { ABDKMathQuad } from './ABDKMathQuad.sol';\n", '\n', 'library CentaurMath {\n', '    using SafeMath for uint256;\n', '\n', '    bytes16 constant ONE_ETHER_QUAD = 0x403ABC16D674EC800000000000000000;\n', '\n', '    // Helper Functions\n', '    function getAmountOutFromValue(uint _value, uint _P, uint _tokenDecimals, uint _baseTokenTargetAmount, uint _baseTokenBalance, uint _liquidityParameter) external pure returns (uint amount) {\n', '        bytes16 DECIMAL_QUAD = ABDKMathQuad.fromUInt(10 ** _tokenDecimals);\n', '\n', '        bytes16 value_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_value), ONE_ETHER_QUAD);\n', '        bytes16 P_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_P), ONE_ETHER_QUAD);\n', '        bytes16 baseTokenTargetAmount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenTargetAmount), DECIMAL_QUAD);\n', '        bytes16 baseTokenBalance_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenBalance), DECIMAL_QUAD);\n', '        bytes16 k_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_liquidityParameter), DECIMAL_QUAD);\n', '\n', '        bytes16 X2 = ABDKMathQuad.sub(baseTokenBalance_quad, baseTokenTargetAmount_quad);\n', '        bytes16 X1 = _solveEquationForAmountOut(\n', '            value_quad,\n', '            X2,\n', '            k_quad,\n', '            P_quad\n', '        );\n', '\n', '        bytes16 amountOut = ABDKMathQuad.sub(X2, X1);\n', '        amount = ABDKMathQuad.toUInt(ABDKMathQuad.mul(amountOut, DECIMAL_QUAD));\n', '    }\n', '\n', '    function getValueFromAmountIn(uint _amount, uint _P, uint _tokenDecimals, uint _baseTokenTargetAmount, uint _baseTokenBalance, uint _liquidityParameter) external pure returns (uint value) {\n', '        bytes16 DECIMAL_QUAD = ABDKMathQuad.fromUInt(10 ** _tokenDecimals);\n', '\n', '        bytes16 amount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_amount), DECIMAL_QUAD);\n', '        bytes16 P_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_P), ONE_ETHER_QUAD);\n', '        bytes16 baseTokenTargetAmount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenTargetAmount), DECIMAL_QUAD);\n', '        bytes16 baseTokenBalance_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenBalance), DECIMAL_QUAD);\n', '        bytes16 k_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_liquidityParameter), DECIMAL_QUAD);\n', '\n', '        bytes16 X1 = ABDKMathQuad.sub(baseTokenBalance_quad, baseTokenTargetAmount_quad);\n', '        bytes16 X2 = ABDKMathQuad.add(X1, amount_quad);\n', '\n', '        value = _solveForIntegral(\n', '            X1,\n', '            X2,\n', '            k_quad,\n', '            P_quad\n', '        );\n', '    }\n', '\n', '    function getAmountInFromValue(uint _value, uint _P, uint _tokenDecimals, uint _baseTokenTargetAmount, uint _baseTokenBalance, uint _liquidityParameter) external pure returns (uint amount) {\n', '        bytes16 DECIMAL_QUAD = ABDKMathQuad.fromUInt(10 ** _tokenDecimals);\n', '\n', '        bytes16 value_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_value), ONE_ETHER_QUAD);\n', '        bytes16 P_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_P), ONE_ETHER_QUAD);\n', '        bytes16 baseTokenTargetAmount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenTargetAmount), DECIMAL_QUAD);\n', '        bytes16 baseTokenBalance_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenBalance), DECIMAL_QUAD);\n', '        bytes16 k_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_liquidityParameter), DECIMAL_QUAD);\n', '\n', '        bytes16 X1 = ABDKMathQuad.sub(baseTokenBalance_quad, baseTokenTargetAmount_quad);\n', '        bytes16 X2 = _solveEquationForAmountIn(\n', '            value_quad,\n', '            X1,\n', '            k_quad,\n', '            P_quad\n', '        );\n', '\n', '        bytes16 amountOut = ABDKMathQuad.sub(X2, X1);\n', '        amount = ABDKMathQuad.toUInt(ABDKMathQuad.mul(amountOut, DECIMAL_QUAD));\n', '    }\n', '\n', '    function getValueFromAmountOut(uint _amount, uint _P, uint _tokenDecimals, uint _baseTokenTargetAmount, uint _baseTokenBalance, uint _liquidityParameter) external pure returns (uint value) {\n', '        bytes16 DECIMAL_QUAD = ABDKMathQuad.fromUInt(10 ** _tokenDecimals);\n', '\n', '        bytes16 amount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_amount), DECIMAL_QUAD);\n', '        bytes16 P_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_P), ONE_ETHER_QUAD);\n', '        bytes16 baseTokenTargetAmount_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenTargetAmount), DECIMAL_QUAD);\n', '        bytes16 baseTokenBalance_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_baseTokenBalance), DECIMAL_QUAD);\n', '        bytes16 k_quad = ABDKMathQuad.div(ABDKMathQuad.fromUInt(_liquidityParameter), DECIMAL_QUAD);\n', '\n', '        bytes16 X2 = ABDKMathQuad.sub(baseTokenBalance_quad, baseTokenTargetAmount_quad);\n', '        bytes16 X1 = ABDKMathQuad.sub(X2, amount_quad);\n', '\n', '        value = _solveForIntegral(\n', '            X1,\n', '            X2,\n', '            k_quad,\n', '            P_quad\n', '        );\n', '    }\n', '    // Core Functions\n', '    \n', '    // Solve for Delta\n', '    function _solveForIntegral (\n', '        bytes16 X1, \n', '        bytes16 X2, \n', '        bytes16 k,\n', '        bytes16 P\n', '    ) internal pure returns (uint256) {\n', '        bytes16 multiplier = ABDKMathQuad.mul(k, P);\n', '\n', '        bytes16 NLog_X2 = ABDKMathQuad.ln(ABDKMathQuad.add(X2, k));\n', '        bytes16 NLog_X1 = ABDKMathQuad.ln(ABDKMathQuad.add(X1, k));\n', '\n', '        bytes16 delta = ABDKMathQuad.mul(multiplier, ABDKMathQuad.sub(NLog_X2, NLog_X1));\n', '\n', '        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(delta, ONE_ETHER_QUAD));\n', '    }\n', '\n', '    // Solve for amountOut\n', '    // Given X2, solve for X1\n', '    function _solveEquationForAmountOut (\n', '        bytes16 delta,\n', '        bytes16 X2,\n', '        bytes16 k,\n', '        bytes16 P\n', '    ) internal pure returns (bytes16 X1) {\n', '        bytes16 NLog_X2 = ABDKMathQuad.ln(ABDKMathQuad.add(X2, k));\n', '        bytes16 deltaOverTotal = ABDKMathQuad.div(delta, ABDKMathQuad.mul(k, P));\n', '\n', '        bytes16 ePower = ABDKMathQuad.exp(ABDKMathQuad.sub(NLog_X2, deltaOverTotal));\n', '\n', '        X1 = ABDKMathQuad.sub(ePower, k);\n', '    }\n', '\n', '    // Solve for amountOut\n', '    // Given X1, solve for X2\n', '    function _solveEquationForAmountIn (\n', '        bytes16 delta,\n', '        bytes16 X1,\n', '        bytes16 k,\n', '        bytes16 P\n', '    ) internal pure returns (bytes16 X2) {\n', '        bytes16 NLog_X1 = ABDKMathQuad.ln(ABDKMathQuad.add(X1, k));\n', '        bytes16 deltaOverTotal = ABDKMathQuad.div(delta, ABDKMathQuad.mul(k, P));\n', '\n', '        bytes16 ePower = ABDKMathQuad.exp(ABDKMathQuad.add(deltaOverTotal, NLog_X1));\n', '\n', '        X2 = ABDKMathQuad.sub(ePower, k);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    function symbol() external pure returns (string memory);\n', '    /**\n', '     * @dev Returns the token decimal.\n', '     */\n', '    function decimals() external pure returns (uint8);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface ICentaurFactory {\n', '    event PoolCreated(address indexed token, address pool, uint);\n', '\n', '    function poolFee() external view returns (uint);\n', '\n', '    function poolLogic() external view returns (address);\n', '    function cloneFactory() external view returns (address);\n', '    function settlement() external view returns (address);\n', '    function router() external view returns (address payable);\n', '\n', '    function getPool(address token) external view returns (address pool);\n', '    function allPools(uint) external view returns (address pool);\n', '    function allPoolsLength() external view returns (uint);\n', '    function isValidPool(address pool) external view returns (bool);\n', '\n', '    function createPool(address token, address oracle, uint poolUtilizationPercentage) external returns (address pool);\n', '    function addPool(address pool) external;\n', '    function removePool(address pool) external;\n', '\n', '    function setPoolLiquidityParameter(address, uint) external;\n', '    function setPoolTradeEnabled(address, bool) external;\n', '    function setPoolDepositEnabled(address, bool) external;\n', '    function setPoolWithdrawEnabled(address, bool) external;\n', '    function setAllPoolsTradeEnabled(bool) external;\n', '    function setAllPoolsDepositEnabled(bool) external;\n', '    function setAllPoolsWithdrawEnabled(bool) external;\n', '    function emergencyWithdrawFromPool(address, address, uint, address) external;\n', '\n', '    function setRouterOnlyEOAEnabled(bool) external;\n', '    function setRouterContractWhitelist(address, bool) external;\n', '\n', '    function setSettlementDuration(uint) external;\n', '\n', '    function setPoolFee(uint) external;\n', '    function setPoolLogic(address) external;\n', '    function setCloneFactory(address) external;\n', '    function setSettlement(address) external;\n', '    function setRouter(address payable) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface ICentaurPool {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    event Mint(address indexed sender, uint amount);\n', '    event Burn(address indexed sender, uint amount, address indexed to);\n', '    event AmountIn(address indexed sender, uint amount);\n', '    event AmountOut(address indexed sender, uint amount, address indexed to);\n', '    event EmergencyWithdraw(uint256 _timestamp, address indexed _token, uint256 _amount, address indexed _to);\n', '\n', '    function factory() external view returns (address);\n', '    function settlement() external view returns (address);\n', '    function baseToken() external view returns (address);\n', '    function baseTokenDecimals() external view returns (uint);\n', '    function oracle() external view returns (address);\n', '    function oracleDecimals() external view returns (uint);\n', '    function baseTokenTargetAmount() external view returns (uint);\n', '    function baseTokenBalance() external view returns (uint);\n', '    function liquidityParameter() external view returns (uint);\n', '\n', '    function init(address, address, address, uint) external;\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount);\n', '\n', '    function swapTo(address _sender, address _fromToken, uint _amountIn, uint _value, address _receiver) external returns (uint maxAmount);\n', '    function swapFrom(address _sender) external returns (uint amount, uint value);\n', '    function swapSettle(address _sender) external returns (uint, address);\n', '\n', '    function getOraclePrice() external view returns (uint price);\n', '    function getAmountOutFromValue(uint _value) external view returns (uint amount);\n', '    function getValueFromAmountIn(uint _amount) external view returns (uint value);\n', '    function getAmountInFromValue(uint _value) external view returns (uint amount);\n', '    function getValueFromAmountOut(uint _amount) external view returns (uint value);\n', '\n', '    function setFactory(address) external;\n', '    function setTradeEnabled(bool) external;\n', '    function setDepositEnabled(bool) external;\n', '    function setWithdrawEnabled(bool) external;\n', '    function setLiquidityParameter(uint) external;\n', '    function emergencyWithdraw(address, uint, address) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface ICentaurSettlement {\n', '    // event SettlementAdded(address indexed sender, address indexed _fromToken, uint _amountIn, address indexed _toToken, uint _amountOut);\n', '    // event SettlementRemoved(address indexed sender, address indexed _fromToken, address indexed _toToken);\n', '    struct Settlement {\n', '        address fPool;\n', '        uint amountIn;\n', '        uint fPoolBaseTokenTargetAmount;\n', '        uint fPoolBaseTokenBalance;\n', '        uint fPoolLiquidityParameter;\n', '        address tPool;\n', '        uint maxAmountOut;\n', '        uint tPoolBaseTokenTargetAmount;\n', '        uint tPoolBaseTokenBalance;\n', '        uint tPoolLiquidityParameter;\n', '        address receiver;\n', '        uint settlementTimestamp;\n', '    }\n', '\n', '    function factory() external pure returns (address);\n', '    function settlementDuration() external pure returns (uint);\n', '\n', '    function addSettlement(\n', '        address _sender,\n', '        Settlement memory _pendingSettlement\n', '    ) external;\n', '    function removeSettlement(address _sender, address _fPool, address _tPool) external;\n', '    \n', '    function getPendingSettlement(address _sender, address _pool) external view returns (Settlement memory);\n', '    function hasPendingSettlement(address _sender, address _pool) external view returns (bool);\n', '\n', '    function setSettlementDuration(uint) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IOracle {\n', '\tfunction decimals() external view returns (uint8);\n', '\tfunction description() external view returns (string memory);\n', '\tfunction version() external view returns (uint256);\n', '\n', '\t// getRoundData and latestRoundData should both raise "No data present"\n', '\t// if they do not have data to report, instead of returning unset values\n', '\t// which could be misinterpreted as actual reported values.\n', '\tfunction getRoundData(uint80 _roundId)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (\n', '\t\t  uint80 roundId,\n', '\t\t  int256 answer,\n', '\t\t  uint256 startedAt,\n', '\t\t  uint256 updatedAt,\n', '\t\t  uint80 answeredInRound\n', '\t);\n', '\t\t\n', '\tfunction latestRoundData()\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (\n', '\t\t  uint80 roundId,\n', '\t\t  int256 answer,\n', '\t\t  uint256 startedAt,\n', '\t\t  uint256 updatedAt,\n', '\t\t  uint80 answeredInRound\n', '\t);\n', '}\n', '\n', '// SPDX-License-Identifier: BSD-4-Clause\n', '/*\n', ' * ABDK Math Quad Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <[email\xa0protected]>\n', ' */\n', 'pragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\n', '\n', '/**\n', ' * Smart contract library of mathematical functions operating with IEEE 754\n', ' * quadruple-precision binary floating-point numbers (quadruple precision\n', ' * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n', ' * represented by bytes16 type.\n', ' */\n', 'library ABDKMathQuad {\n', '  /*\n', '   * 0.\n', '   */\n', '  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n', '\n', '  /*\n', '   * -0.\n', '   */\n', '  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n', '\n', '  /*\n', '   * +Infinity.\n', '   */\n', '  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\n', '\n', '  /*\n', '   * -Infinity.\n', '   */\n', '  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\n', '\n', '  /*\n', '   * Canonical NaN value.\n', '   */\n', '  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n', '\n', '  /**\n', '   * Convert signed 256-bit integer number into quadruple precision number.\n', '   *\n', '   * @param x signed 256-bit integer number\n', '   * @return quadruple precision number\n', '   */\n', '  function fromInt (int256 x) internal pure returns (bytes16) {\n', '    if (x == 0) return bytes16 (0);\n', '    else {\n', '      // We rely on overflow behavior here\n', '      uint256 result = uint256 (x > 0 ? x : -x);\n', '\n', '      uint256 msb = msb (result);\n', '      if (msb < 112) result <<= 112 - msb;\n', '      else if (msb > 112) result >>= msb - 112;\n', '\n', '      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n', '      if (x < 0) result |= 0x80000000000000000000000000000000;\n', '\n', '      return bytes16 (uint128 (result));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into signed 256-bit integer number\n', '   * rounding towards zero.  Revert on overflow.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return signed 256-bit integer number\n', '   */\n', '  function toInt (bytes16 x) internal pure returns (int256) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    require (exponent <= 16638); // Overflow\n', '    if (exponent < 16383) return 0; // Underflow\n', '\n', '    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n', '      0x10000000000000000000000000000;\n', '\n', '    if (exponent < 16495) result >>= 16495 - exponent;\n', '    else if (exponent > 16495) result <<= exponent - 16495;\n', '\n', '    if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n', '      require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n', '      return -int256 (result); // We rely on overflow behavior here\n', '    } else {\n', '      require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '      return int256 (result);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert unsigned 256-bit integer number into quadruple precision number.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @return quadruple precision number\n', '   */\n', '  function fromUInt (uint256 x) internal pure returns (bytes16) {\n', '    if (x == 0) return bytes16 (0);\n', '    else {\n', '      uint256 result = x;\n', '\n', '      uint256 msb = msb (result);\n', '      if (msb < 112) result <<= 112 - msb;\n', '      else if (msb > 112) result >>= msb - 112;\n', '\n', '      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\n', '\n', '      return bytes16 (uint128 (result));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into unsigned 256-bit integer number\n', '   * rounding towards zero.  Revert on underflow.  Note, that negative floating\n', '   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n', '   * without error, because they are rounded to zero.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return unsigned 256-bit integer number\n', '   */\n', '  function toUInt (bytes16 x) internal pure returns (uint256) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    if (exponent < 16383) return 0; // Underflow\n', '\n', '    require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\n', '\n', '    require (exponent <= 16638); // Overflow\n', '    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n', '      0x10000000000000000000000000000;\n', '\n', '    if (exponent < 16495) result >>= 16495 - exponent;\n', '    else if (exponent > 16495) result <<= exponent - 16495;\n', '\n', '    return result;\n', '  }\n', '\n', '  /**\n', '   * Convert signed 128.128 bit fixed point number into quadruple precision\n', '   * number.\n', '   *\n', '   * @param x signed 128.128 bit fixed point number\n', '   * @return quadruple precision number\n', '   */\n', '  function from128x128 (int256 x) internal pure returns (bytes16) {\n', '    if (x == 0) return bytes16 (0);\n', '    else {\n', '      // We rely on overflow behavior here\n', '      uint256 result = uint256 (x > 0 ? x : -x);\n', '\n', '      uint256 msb = msb (result);\n', '      if (msb < 112) result <<= 112 - msb;\n', '      else if (msb > 112) result >>= msb - 112;\n', '\n', '      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\n', '      if (x < 0) result |= 0x80000000000000000000000000000000;\n', '\n', '      return bytes16 (uint128 (result));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into signed 128.128 bit fixed point\n', '   * number.  Revert on overflow.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return signed 128.128 bit fixed point number\n', '   */\n', '  function to128x128 (bytes16 x) internal pure returns (int256) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    require (exponent <= 16510); // Overflow\n', '    if (exponent < 16255) return 0; // Underflow\n', '\n', '    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n', '      0x10000000000000000000000000000;\n', '\n', '    if (exponent < 16367) result >>= 16367 - exponent;\n', '    else if (exponent > 16367) result <<= exponent - 16367;\n', '\n', '    if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n', '      require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\n', '      return -int256 (result); // We rely on overflow behavior here\n', '    } else {\n', '      require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '      return int256 (result);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert signed 64.64 bit fixed point number into quadruple precision\n', '   * number.\n', '   *\n', '   * @param x signed 64.64 bit fixed point number\n', '   * @return quadruple precision number\n', '   */\n', '  function from64x64 (int128 x) internal pure returns (bytes16) {\n', '    if (x == 0) return bytes16 (0);\n', '    else {\n', '      // We rely on overflow behavior here\n', '      uint256 result = uint128 (x > 0 ? x : -x);\n', '\n', '      uint256 msb = msb (result);\n', '      if (msb < 112) result <<= 112 - msb;\n', '      else if (msb > 112) result >>= msb - 112;\n', '\n', '      result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\n', '      if (x < 0) result |= 0x80000000000000000000000000000000;\n', '\n', '      return bytes16 (uint128 (result));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into signed 64.64 bit fixed point\n', '   * number.  Revert on overflow.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return signed 64.64 bit fixed point number\n', '   */\n', '  function to64x64 (bytes16 x) internal pure returns (int128) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    require (exponent <= 16446); // Overflow\n', '    if (exponent < 16319) return 0; // Underflow\n', '\n', '    uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\n', '      0x10000000000000000000000000000;\n', '\n', '    if (exponent < 16431) result >>= 16431 - exponent;\n', '    else if (exponent > 16431) result <<= exponent - 16431;\n', '\n', '    if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\n', '      require (result <= 0x80000000000000000000000000000000);\n', '      return -int128 (result); // We rely on overflow behavior here\n', '    } else {\n', '      require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '      return int128 (result);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Convert octuple precision number into quadruple precision number.\n', '   *\n', '   * @param x octuple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\n', '    bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\n', '\n', '    uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\n', '    uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    if (exponent == 0x7FFFF) {\n', '      if (significand > 0) return NaN;\n', '      else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '    }\n', '\n', '    if (exponent > 278526)\n', '      return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '    else if (exponent < 245649)\n', '      return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n', '    else if (exponent < 245761) {\n', '      significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\n', '      exponent = 0;\n', '    } else {\n', '      significand >>= 124;\n', '      exponent -= 245760;\n', '    }\n', '\n', '    uint128 result = uint128 (significand | exponent << 112);\n', '    if (negative) result |= 0x80000000000000000000000000000000;\n', '\n', '    return bytes16 (result);\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into octuple precision number.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return octuple precision number\n', '   */\n', '  function toOctuple (bytes16 x) internal pure returns (bytes32) {\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '\n', '    uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\n', '    else if (exponent == 0) {\n', '      if (result > 0) {\n', '        uint256 msb = msb (result);\n', '        result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        exponent = 245649 + msb;\n', '      }\n', '    } else {\n', '      result <<= 124;\n', '      exponent += 245760;\n', '    }\n', '\n', '    result |= exponent << 236;\n', '    if (uint128 (x) >= 0x80000000000000000000000000000000)\n', '      result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    return bytes32 (result);\n', '  }\n', '\n', '  /**\n', '   * Convert double precision number into quadruple precision number.\n', '   *\n', '   * @param x double precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function fromDouble (bytes8 x) internal pure returns (bytes16) {\n', '    uint256 exponent = uint64 (x) >> 52 & 0x7FF;\n', '\n', '    uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\n', '\n', '    if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\n', '    else if (exponent == 0) {\n', '      if (result > 0) {\n', '        uint256 msb = msb (result);\n', '        result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        exponent = 15309 + msb;\n', '      }\n', '    } else {\n', '      result <<= 60;\n', '      exponent += 15360;\n', '    }\n', '\n', '    result |= exponent << 112;\n', '    if (x & 0x8000000000000000 > 0)\n', '      result |= 0x80000000000000000000000000000000;\n', '\n', '    return bytes16 (uint128 (result));\n', '  }\n', '\n', '  /**\n', '   * Convert quadruple precision number into double precision number.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return double precision number\n', '   */\n', '  function toDouble (bytes16 x) internal pure returns (bytes8) {\n', '    bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\n', '\n', '    uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    if (exponent == 0x7FFF) {\n', '      if (significand > 0) return 0x7FF8000000000000; // NaN\n', '      else return negative ?\n', '          bytes8 (0xFFF0000000000000) : // -Infinity\n', '          bytes8 (0x7FF0000000000000); // Infinity\n', '    }\n', '\n', '    if (exponent > 17406)\n', '      return negative ?\n', '          bytes8 (0xFFF0000000000000) : // -Infinity\n', '          bytes8 (0x7FF0000000000000); // Infinity\n', '    else if (exponent < 15309)\n', '      return negative ?\n', '          bytes8 (0x8000000000000000) : // -0\n', '          bytes8 (0x0000000000000000); // 0\n', '    else if (exponent < 15361) {\n', '      significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\n', '      exponent = 0;\n', '    } else {\n', '      significand >>= 60;\n', '      exponent -= 15360;\n', '    }\n', '\n', '    uint64 result = uint64 (significand | exponent << 52);\n', '    if (negative) result |= 0x8000000000000000;\n', '\n', '    return bytes8 (result);\n', '  }\n', '\n', '  /**\n', '   * Test whether given quadruple precision number is NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return true if x is NaN, false otherwise\n', '   */\n', '  function isNaN (bytes16 x) internal pure returns (bool) {\n', '    return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\n', '      0x7FFF0000000000000000000000000000;\n', '  }\n', '\n', '  /**\n', '   * Test whether given quadruple precision number is positive or negative\n', '   * infinity.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return true if x is positive or negative infinity, false otherwise\n', '   */\n', '  function isInfinity (bytes16 x) internal pure returns (bool) {\n', '    return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\n', '      0x7FFF0000000000000000000000000000;\n', '  }\n', '\n', '  /**\n', '   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n', '   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \n', '   *\n', '   * @param x quadruple precision number\n', '   * @return sign of x\n', '   */\n', '  function sign (bytes16 x) internal pure returns (int8) {\n', '    uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n', '\n', '    if (absoluteX == 0) return 0;\n', '    else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\n', '    else return 1;\n', '  }\n', '\n', '  /**\n', '   * Calculate sign (x - y).  Revert if either argument is NaN, or both\n', '   * arguments are infinities of the same sign. \n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return sign (x - y)\n', '   */\n', '  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\n', '    uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n', '\n', '    uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\n', '\n', '    // Not infinities of the same sign\n', '    require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\n', '\n', '    if (x == y) return 0;\n', '    else {\n', '      bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\n', '      bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\n', '\n', '      if (negativeX) {\n', '        if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\n', '        else return -1; \n', '      } else {\n', '        if (negativeY) return 1;\n', '        else return absoluteX > absoluteY ? int8 (1) : -1;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n', '   * anything. \n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return true if x equals to y, false otherwise\n', '   */\n', '  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\n', '    if (x == y) {\n', '      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\n', '        0x7FFF0000000000000000000000000000;\n', '    } else return false;\n', '  }\n', '\n', '  /**\n', '   * Calculate x + y.  Special values behave in the following way:\n', '   *\n', '   * NaN + x = NaN for any x.\n', '   * Infinity + x = Infinity for any finite x.\n', '   * -Infinity + x = -Infinity for any finite x.\n', '   * Infinity + Infinity = Infinity.\n', '   * -Infinity + -Infinity = -Infinity.\n', '   * Infinity + -Infinity = -Infinity + Infinity = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) { \n', '        if (x == y) return x;\n', '        else return NaN;\n', '      } else return x; \n', '    } else if (yExponent == 0x7FFF) return y;\n', '    else {\n', '      bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n', '      else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n', '      else {\n', '        int256 delta = int256 (xExponent) - int256 (yExponent);\n', '  \n', '        if (xSign == ySign) {\n', '          if (delta > 112) return x;\n', '          else if (delta > 0) ySignifier >>= uint256 (delta);\n', '          else if (delta < -112) return y;\n', '          else if (delta < 0) {\n', '            xSignifier >>= uint256 (-delta);\n', '            xExponent = yExponent;\n', '          }\n', '  \n', '          xSignifier += ySignifier;\n', '  \n', '          if (xSignifier >= 0x20000000000000000000000000000) {\n', '            xSignifier >>= 1;\n', '            xExponent += 1;\n', '          }\n', '  \n', '          if (xExponent == 0x7FFF)\n', '            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '          else {\n', '            if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n', '            else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '  \n', '            return bytes16 (uint128 (\n', '                (xSign ? 0x80000000000000000000000000000000 : 0) |\n', '                (xExponent << 112) |\n', '                xSignifier)); \n', '          }\n', '        } else {\n', '          if (delta > 0) {\n', '            xSignifier <<= 1;\n', '            xExponent -= 1;\n', '          } else if (delta < 0) {\n', '            ySignifier <<= 1;\n', '            xExponent = yExponent - 1;\n', '          }\n', '\n', '          if (delta > 112) ySignifier = 1;\n', '          else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\n', '          else if (delta < -112) xSignifier = 1;\n', '          else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\n', '\n', '          if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n', '          else {\n', '            xSignifier = ySignifier - xSignifier;\n', '            xSign = ySign;\n', '          }\n', '\n', '          if (xSignifier == 0)\n', '            return POSITIVE_ZERO;\n', '\n', '          uint256 msb = msb (xSignifier);\n', '\n', '          if (msb == 113) {\n', '            xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '            xExponent += 1;\n', '          } else if (msb < 112) {\n', '            uint256 shift = 112 - msb;\n', '            if (xExponent > shift) {\n', '              xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '              xExponent -= shift;\n', '            } else {\n', '              xSignifier <<= xExponent - 1;\n', '              xExponent = 0;\n', '            }\n', '          } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '          if (xExponent == 0x7FFF)\n', '            return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n', '          else return bytes16 (uint128 (\n', '              (xSign ? 0x80000000000000000000000000000000 : 0) |\n', '              (xExponent << 112) |\n', '              xSignifier));\n', '        }\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x - y.  Special values behave in the following way:\n', '   *\n', '   * NaN - x = NaN for any x.\n', '   * Infinity - x = Infinity for any finite x.\n', '   * -Infinity - x = -Infinity for any finite x.\n', '   * Infinity - -Infinity = Infinity.\n', '   * -Infinity - Infinity = -Infinity.\n', '   * Infinity - Infinity = -Infinity - -Infinity = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    return add (x, y ^ 0x80000000000000000000000000000000);\n', '  }\n', '\n', '  /**\n', '   * Calculate x * y.  Special values behave in the following way:\n', '   *\n', '   * NaN * x = NaN for any x.\n', '   * Infinity * x = Infinity for any finite positive x.\n', '   * Infinity * x = -Infinity for any finite negative x.\n', '   * -Infinity * x = -Infinity for any finite positive x.\n', '   * -Infinity * x = Infinity for any finite negative x.\n', '   * Infinity * 0 = NaN.\n', '   * -Infinity * 0 = NaN.\n', '   * Infinity * Infinity = Infinity.\n', '   * Infinity * -Infinity = -Infinity.\n', '   * -Infinity * Infinity = -Infinity.\n', '   * -Infinity * -Infinity = Infinity.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) {\n', '        if (x == y) return x ^ y & 0x80000000000000000000000000000000;\n', '        else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n', '        else return NaN;\n', '      } else {\n', '        if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '        else return x ^ y & 0x80000000000000000000000000000000;\n', '      }\n', '    } else if (yExponent == 0x7FFF) {\n', '        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '        else return y ^ x & 0x80000000000000000000000000000000;\n', '    } else {\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      xSignifier *= ySignifier;\n', '      if (xSignifier == 0)\n', '        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n', '            NEGATIVE_ZERO : POSITIVE_ZERO;\n', '\n', '      xExponent += yExponent;\n', '\n', '      uint256 msb =\n', '        xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\n', '        xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\n', '        msb (xSignifier);\n', '\n', '      if (xExponent + msb < 16496) { // Underflow\n', '        xExponent = 0;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb < 16608) { // Subnormal\n', '        if (xExponent < 16496)\n', '          xSignifier >>= 16496 - xExponent;\n', '        else if (xExponent > 16496)\n', '          xSignifier <<= xExponent - 16496;\n', '        xExponent = 0;\n', '      } else if (xExponent + msb > 49373) {\n', '        xExponent = 0x7FFF;\n', '        xSignifier = 0;\n', '      } else {\n', '        if (msb > 112)\n', '          xSignifier >>= msb - 112;\n', '        else if (msb < 112)\n', '          xSignifier <<= 112 - msb;\n', '\n', '        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '        xExponent = xExponent + msb - 16607;\n', '      }\n', '\n', '      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n', '          xExponent << 112 | xSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y.  Special values behave in the following way:\n', '   *\n', '   * NaN / x = NaN for any x.\n', '   * x / NaN = NaN for any x.\n', '   * Infinity / x = Infinity for any finite non-negative x.\n', '   * Infinity / x = -Infinity for any finite negative x including -0.\n', '   * -Infinity / x = -Infinity for any finite non-negative x.\n', '   * -Infinity / x = Infinity for any finite negative x including -0.\n', '   * x / Infinity = 0 for any finite non-negative x.\n', '   * x / -Infinity = -0 for any finite non-negative x.\n', '   * x / Infinity = -0 for any finite non-negative x including -0.\n', '   * x / -Infinity = 0 for any finite non-negative x including -0.\n', '   * \n', '   * Infinity / Infinity = NaN.\n', '   * Infinity / -Infinity = -NaN.\n', '   * -Infinity / Infinity = -NaN.\n', '   * -Infinity / -Infinity = NaN.\n', '   *\n', '   * Division by zero behaves in the following way:\n', '   *\n', '   * x / 0 = Infinity for any finite positive x.\n', '   * x / -0 = -Infinity for any finite positive x.\n', '   * x / 0 = -Infinity for any finite negative x.\n', '   * x / -0 = Infinity for any finite negative x.\n', '   * 0 / 0 = NaN.\n', '   * 0 / -0 = NaN.\n', '   * -0 / 0 = NaN.\n', '   * -0 / -0 = NaN.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @param y quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\n', '\n', '    if (xExponent == 0x7FFF) {\n', '      if (yExponent == 0x7FFF) return NaN;\n', '      else return x ^ y & 0x80000000000000000000000000000000;\n', '    } else if (yExponent == 0x7FFF) {\n', '      if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n', '      else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\n', '    } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n', '      if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n', '      else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\n', '    } else {\n', '      uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (yExponent == 0) yExponent = 1;\n', '      else ySignifier |= 0x10000000000000000000000000000;\n', '\n', '      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xExponent == 0) {\n', '        if (xSignifier != 0) {\n', '          uint shift = 226 - msb (xSignifier);\n', '\n', '          xSignifier <<= shift;\n', '\n', '          xExponent = 1;\n', '          yExponent += shift - 114;\n', '        }\n', '      }\n', '      else {\n', '        xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n', '      }\n', '\n', '      xSignifier = xSignifier / ySignifier;\n', '      if (xSignifier == 0)\n', '        return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\n', '            NEGATIVE_ZERO : POSITIVE_ZERO;\n', '\n', '      assert (xSignifier >= 0x1000000000000000000000000000);\n', '\n', '      uint256 msb =\n', '        xSignifier >= 0x80000000000000000000000000000 ? msb (xSignifier) :\n', '        xSignifier >= 0x40000000000000000000000000000 ? 114 :\n', '        xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\n', '\n', '      if (xExponent + msb > yExponent + 16497) { // Overflow\n', '        xExponent = 0x7FFF;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb + 16380  < yExponent) { // Underflow\n', '        xExponent = 0;\n', '        xSignifier = 0;\n', '      } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\n', '        if (xExponent + 16380 > yExponent)\n', '          xSignifier <<= xExponent + 16380 - yExponent;\n', '        else if (xExponent + 16380 < yExponent)\n', '          xSignifier >>= yExponent - xExponent - 16380;\n', '\n', '        xExponent = 0;\n', '      } else { // Normal\n', '        if (msb > 112)\n', '          xSignifier >>= msb - 112;\n', '\n', '        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '        xExponent = xExponent + msb + 16269 - yExponent;\n', '      }\n', '\n', '      return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\n', '          xExponent << 112 | xSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate -x.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function neg (bytes16 x) internal pure returns (bytes16) {\n', '    return x ^ 0x80000000000000000000000000000000;\n', '  }\n', '\n', '  /**\n', '   * Calculate |x|.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function abs (bytes16 x) internal pure returns (bytes16) {\n', '    return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '  }\n', '\n', '  /**\n', '   * Calculate square root of x.  Return NaN on negative x excluding -0.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function sqrt (bytes16 x) internal pure returns (bytes16) {\n', '    if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\n', '    else {\n', '      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '      if (xExponent == 0x7FFF) return x;\n', '      else {\n', '        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        if (xExponent == 0) xExponent = 1;\n', '        else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '        if (xSignifier == 0) return POSITIVE_ZERO;\n', '\n', '        bool oddExponent = xExponent & 0x1 == 0;\n', '        xExponent = xExponent + 16383 >> 1;\n', '\n', '        if (oddExponent) {\n', '          if (xSignifier >= 0x10000000000000000000000000000)\n', '            xSignifier <<= 113;\n', '          else {\n', '            uint256 msb = msb (xSignifier);\n', '            uint256 shift = (226 - msb) & 0xFE;\n', '            xSignifier <<= shift;\n', '            xExponent -= shift - 112 >> 1;\n', '          }\n', '        } else {\n', '          if (xSignifier >= 0x10000000000000000000000000000)\n', '            xSignifier <<= 112;\n', '          else {\n', '            uint256 msb = msb (xSignifier);\n', '            uint256 shift = (225 - msb) & 0xFE;\n', '            xSignifier <<= shift;\n', '            xExponent -= shift - 112 >> 1;\n', '          }\n', '        }\n', '\n', '        uint256 r = 0x10000000000000000000000000000;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1;\n', '        r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n', '        uint256 r1 = xSignifier / r;\n', '        if (r1 < r) r = r1;\n', '\n', '        return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function log_2 (bytes16 x) internal pure returns (bytes16) {\n', '    if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\n', '    else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \n', '    else {\n', '      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '      if (xExponent == 0x7FFF) return x;\n', '      else {\n', '        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        if (xExponent == 0) xExponent = 1;\n', '        else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '        if (xSignifier == 0) return NEGATIVE_INFINITY;\n', '\n', '        bool resultNegative;\n', '        uint256 resultExponent = 16495;\n', '        uint256 resultSignifier;\n', '\n', '        if (xExponent >= 0x3FFF) {\n', '          resultNegative = false;\n', '          resultSignifier = xExponent - 0x3FFF;\n', '          xSignifier <<= 15;\n', '        } else {\n', '          resultNegative = true;\n', '          if (xSignifier >= 0x10000000000000000000000000000) {\n', '            resultSignifier = 0x3FFE - xExponent;\n', '            xSignifier <<= 15;\n', '          } else {\n', '            uint256 msb = msb (xSignifier);\n', '            resultSignifier = 16493 - msb;\n', '            xSignifier <<= 127 - msb;\n', '          }\n', '        }\n', '\n', '        if (xSignifier == 0x80000000000000000000000000000000) {\n', '          if (resultNegative) resultSignifier += 1;\n', '          uint256 shift = 112 - msb (resultSignifier);\n', '          resultSignifier <<= shift;\n', '          resultExponent -= shift;\n', '        } else {\n', '          uint256 bb = resultNegative ? 1 : 0;\n', '          while (resultSignifier < 0x10000000000000000000000000000) {\n', '            resultSignifier <<= 1;\n', '            resultExponent -= 1;\n', '  \n', '            xSignifier *= xSignifier;\n', '            uint256 b = xSignifier >> 255;\n', '            resultSignifier += b ^ bb;\n', '            xSignifier >>= 127 + b;\n', '          }\n', '        }\n', '\n', '        return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\n', '            resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function ln (bytes16 x) internal pure returns (bytes16) {\n', '    return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n', '  }\n', '\n', '  /**\n', '   * Calculate 2^x.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function pow_2 (bytes16 x) internal pure returns (bytes16) {\n', '    bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\n', '    uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\n', '    uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '    if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n', '    else if (xExponent > 16397)\n', '      return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n', '    else if (xExponent < 16255)\n', '      return 0x3FFF0000000000000000000000000000;\n', '    else {\n', '      if (xExponent == 0) xExponent = 1;\n', '      else xSignifier |= 0x10000000000000000000000000000;\n', '\n', '      if (xExponent > 16367)\n', '        xSignifier <<= xExponent - 16367;\n', '      else if (xExponent < 16367)\n', '        xSignifier >>= 16367 - xExponent;\n', '\n', '      if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\n', '        return POSITIVE_ZERO;\n', '\n', '      if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '        return POSITIVE_INFINITY;\n', '\n', '      uint256 resultExponent = xSignifier >> 128;\n', '      xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '      if (xNegative && xSignifier != 0) {\n', '        xSignifier = ~xSignifier;\n', '        resultExponent += 1;\n', '      }\n', '\n', '      uint256 resultSignifier = 0x80000000000000000000000000000000;\n', '      if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n', '      if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n', '      if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n', '      if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n', '      if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n', '      if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n', '      if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n', '      if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n', '      if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n', '      if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n', '      if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n', '      if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n', '      if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n', '      if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n', '      if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n', '      if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n', '      if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n', '      if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n', '      if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n', '      if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n', '      if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n', '      if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n', '      if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n', '      if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\n', '      if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\n', '      if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\n', '      if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n', '      if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n', '      if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n', '      if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n', '      if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n', '      if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n', '      if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\n', '      if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n', '      if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n', '      if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\n', '      if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n', '      if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\n', '      if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n', '      if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n', '      if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\n', '      if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n', '      if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n', '      if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n', '      if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\n', '      if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\n', '      if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\n', '      if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\n', '      if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\n', '      if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\n', '      if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\n', '      if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\n', '      if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\n', '      if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\n', '      if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\n', '      if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\n', '      if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\n', '      if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\n', '      if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\n', '      if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\n', '      if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\n', '      if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\n', '      if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\n', '      if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\n', '      if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\n', '      if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\n', '      if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\n', '      if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\n', '      if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\n', '      if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\n', '      if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\n', '      if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\n', '      if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\n', '      if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\n', '      if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\n', '      if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\n', '      if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\n', '      if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\n', '      if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\n', '      if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\n', '      if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\n', '      if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\n', '      if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\n', '      if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\n', '      if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\n', '      if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\n', '      if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\n', '      if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\n', '      if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\n', '      if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\n', '      if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\n', '      if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\n', '      if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\n', '      if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\n', '      if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\n', '      if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\n', '      if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\n', '      if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\n', '      if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\n', '      if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\n', '      if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\n', '      if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\n', '      if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\n', '      if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\n', '      if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\n', '      if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\n', '      if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\n', '      if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\n', '\n', '      if (!xNegative) {\n', '        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        resultExponent += 0x3FFF;\n', '      } else if (resultExponent <= 0x3FFE) {\n', '        resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        resultExponent = 0x3FFF - resultExponent;\n', '      } else {\n', '        resultSignifier = resultSignifier >> resultExponent - 16367;\n', '        resultExponent = 0;\n', '      }\n', '\n', '      return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate e^x.\n', '   *\n', '   * @param x quadruple precision number\n', '   * @return quadruple precision number\n', '   */\n', '  function exp (bytes16 x) internal pure returns (bytes16) {\n', '    return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n', '  }\n', '\n', '  /**\n', '   * Get index of the most significant non-zero bit in binary representation of\n', '   * x.  Reverts if x is zero.\n', '   *\n', '   * @return index of the most significant non-zero bit in binary representation\n', '   *         of x\n', '   */\n', '  function msb (uint256 x) private pure returns (uint256) {\n', '    require (x > 0);\n', '\n', '    uint256 result = 0;\n', '\n', '    if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\n', '    if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\n', '    if (x >= 0x100000000) { x >>= 32; result += 32; }\n', '    if (x >= 0x10000) { x >>= 16; result += 16; }\n', '    if (x >= 0x100) { x >>= 8; result += 8; }\n', '    if (x >= 0x10) { x >>= 4; result += 4; }\n', '    if (x >= 0x4) { x >>= 2; result += 2; }\n', '    if (x >= 0x2) result += 1; // No need to shift x anymore\n', '\n', '    return result;\n', '  }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {\n', '    "contracts/libraries/CentaurMath.sol": {\n', '      "CentaurMath": "0xfe40675976c6dbecad7b98b07c29f1cd90e70129"\n', '    }\n', '  }\n', '}']