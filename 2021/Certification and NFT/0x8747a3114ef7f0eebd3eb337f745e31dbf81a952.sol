['/**\n', '* SPDX-License-Identifier: LicenseRef-Aktionariat\n', '*\n', '* MIT License with Automated License Fee Payments\n', '*\n', '* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n', '*\n', '* Permission is hereby granted to any person obtaining a copy of this software\n', '* and associated documentation files (the "Software"), to deal in the Software\n', '* without restriction, including without limitation the rights to use, copy,\n', '* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n', '* Software, and to permit persons to whom the Software is furnished to do so,\n', '* subject to the following conditions:\n', '*\n', '* - The above copyright notice and this permission notice shall be included in\n', '*   all copies or substantial portions of the Software.\n', '* - All automated license fee payments integrated into this and related Software\n', '*   are preserved.\n', '*\n', '* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '* SOFTWARE.\n', '*/\n', 'pragma solidity >=0.8;\n', '\n', 'import "./DraggableShares.sol";\n', 'import "./ERC20Draggable.sol";\n', '\n', '/**\n', ' * @title Draggable CompanyName AG Shares\n', ' * @author Luzius Meisser, [email\xa0protected]\n', ' *\n', ' * This is an ERC-20 token representing shares of CompanyName AG that are bound to\n', " * a shareholder agreement that can be found at the URL defined in the constant 'terms'.\n", ' * The shareholder agreement is partially enforced through this smart contract. The agreement\n', ' * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\n', ' * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\n', ' * the acquirer to offer the same conditions to everyone when acquiring the company, and to\n', ' * facilitate an update of the shareholder agreement even if a minority of the shareholders that\n', ' * are bound to this agreement disagree. The name "draggable" stems from the convention of calling\n', ' * the right to drag a minority along with a sale of the company "drag-along" rights. The name is\n', ' * chosen to ensure that token holders are aware that they are bound to such an agreement.\n', ' *\n', ' * The percentage of token holders that must agree with an update of the terms is defined by the\n', ' * constant UPDATE_QUORUM. The percentage of yes-votes that is needed to successfully complete an\n', ' * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\n', ' * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\n', ' * number of votes cast during the voting period, not taking into account those who did not bother\n', ' * to vote.\n', ' */\n', '\n', 'contract DraggableSharesWithPredecessor is DraggableShares {\n', '\n', '    address immutable newBaseToken;\n', '\n', '    constructor(address newBaseToken_, string memory _terms, address predecessor, uint256 quorum, uint256 votePeriod)\n', '        DraggableShares(_terms, predecessor, quorum, votePeriod) {\n', '        newBaseToken = newBaseToken_;\n', '    }\n', '\n', '    // custom built convert function for old DSHS contract\n', '    function convert() public {\n', '        address oldBase = getOldBase();\n', '        fetchTokens();\n', '        swtichBase(oldBase);\n', '    }\n', '\n', '    function fetchTokens() internal {\n', '        require(address(wrapped) != newBaseToken);\n', '        IDSHS predecessor = IDSHS(address(wrapped));\n', '        uint256 supply = predecessor.totalSupply();\n', '        uint256 present = totalSupply();\n', '        uint256 missing = supply - present;\n', "        //_mint(address(predecessor), supply); that's what the newer version expects\n", '        _mint(address(this), missing);\n', '        _approve(address(this), address(predecessor), missing);\n', '        predecessor.migrate();\n', '    }\n', '\n', '    function getOldBase() internal view returns (address) {\n', '        return IDSHS(address(wrapped)).getWrappedContract();\n', '    }\n', '\n', '    function swtichBase(address oldWrapped) internal {\n', '        IERC20 oldBase = IERC20(oldWrapped);\n', '        oldBase.approve(newBaseToken, oldBase.balanceOf(address(this)));\n', '        IBaseToken(newBaseToken).convertOldShares();\n', '        wrapped = IERC20(newBaseToken);\n', '        disableRecovery();\n', '        require(totalSupply() == wrapped.balanceOf(address(this)));\n', '    }\n', '}\n', '\n', 'abstract contract IBaseToken {\n', '    function convertOldShares() virtual public;\n', '}\n', '\n', 'abstract contract IDSHS {\n', '    function migrate() virtual public;\n', '    function getWrappedContract() virtual view public returns (address);\n', '    function totalSupply() virtual public returns (uint256);\n', '}']