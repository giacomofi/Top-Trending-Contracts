['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '}\n', '\n', 'interface IAggregator {\n', '    function latestAnswer() external view returns (int256 answer);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '}\n', '\n', '/// @title LPChainlinkOracleV1\n', '/// @author BoringCrypto\n', '/// @notice Oracle used for getting the price of an LP token paired with ETH based on an token-ETH chainlink oracle with 18 decimals\n', '/// @dev Optimized version based on https://blog.alphafinance.io/fair-lp-token-pricing/\n', 'contract LPETHChainlinkOracleV1 is IAggregator {\n', '    using BoringMath for uint256;\n', '\n', '    IUniswapV2Pair public immutable pair;\n', '    IAggregator public immutable tokenOracle;\n', '\n', '    constructor(IUniswapV2Pair pair_, IAggregator tokenOracle_) public {\n', '        pair = pair_;\n', '        tokenOracle = tokenOracle_;\n', '    }\n', '\n', '    // credit for this implementation goes to\n', '    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\n', '    function sqrt(uint256 x) internal pure returns (uint128) {\n', '        if (x == 0) return 0;\n', '        uint256 xx = x;\n', '        uint256 r = 1;\n', '        if (xx >= 0x100000000000000000000000000000000) {\n', '            xx >>= 128;\n', '            r <<= 64;\n', '        }\n', '        if (xx >= 0x10000000000000000) {\n', '            xx >>= 64;\n', '            r <<= 32;\n', '        }\n', '        if (xx >= 0x100000000) {\n', '            xx >>= 32;\n', '            r <<= 16;\n', '        }\n', '        if (xx >= 0x10000) {\n', '            xx >>= 16;\n', '            r <<= 8;\n', '        }\n', '        if (xx >= 0x100) {\n', '            xx >>= 8;\n', '            r <<= 4;\n', '        }\n', '        if (xx >= 0x10) {\n', '            xx >>= 4;\n', '            r <<= 2;\n', '        }\n', '        if (xx >= 0x8) {\n', '            r <<= 1;\n', '        }\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1; // Seven iterations should be enough\n', '        uint256 r1 = x / r;\n', '        return uint128(r < r1 ? r : r1);\n', '    }\n', '\n', '    // Calculates the lastest exchange rate\n', '    function latestAnswer() external view override returns (int256) {\n', '        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\n', '        uint256 totalSupply = pair.totalSupply();\n', '        uint256 k = reserve0.mul(reserve1);\n', '        uint256 ethValue = sqrt((k / 1e18).mul(uint256(tokenOracle.latestAnswer())));\n', '        uint256 totalValue = ethValue.mul(2);\n', '        return int256(totalValue.mul(1e18) / totalSupply);\n', '    }\n', '}']