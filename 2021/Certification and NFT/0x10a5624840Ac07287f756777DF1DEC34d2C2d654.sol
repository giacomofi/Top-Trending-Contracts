['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IDerivativePriceFeed.sol";\n', '\n', '/// @title IDerivativePriceFeed Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', 'interface IAggregatedDerivativePriceFeed is IDerivativePriceFeed {\n', '    function getPriceFeedForDerivative(address) external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title IDerivativePriceFeed Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Simple interface for derivative price source oracle implementations\n', 'interface IDerivativePriceFeed {\n', '    function calcUnderlyingValues(address, uint256)\n', '        external\n', '        returns (address[] memory, uint256[] memory);\n', '\n', '    function isSupportedAsset(address) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title IPrimitivePriceFeed Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Interface for primitive price feeds\n', 'interface IPrimitivePriceFeed {\n', '    function calcCanonicalValue(\n', '        address,\n', '        uint256,\n', '        address\n', '    ) external view returns (uint256, bool);\n', '\n', '    function calcLiveValue(\n', '        address,\n', '        uint256,\n', '        address\n', '    ) external view returns (uint256, bool);\n', '\n', '    function isSupportedAsset(address) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title IValueInterpreter interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Interface for ValueInterpreter\n', 'interface IValueInterpreter {\n', '    function calcCanonicalAssetValue(\n', '        address,\n', '        uint256,\n', '        address\n', '    ) external returns (uint256, bool);\n', '\n', '    function calcCanonicalAssetsTotalValue(\n', '        address[] calldata,\n', '        uint256[] calldata,\n', '        address\n', '    ) external returns (uint256, bool);\n', '\n', '    function calcLiveAssetValue(\n', '        address,\n', '        uint256,\n', '        address\n', '    ) external returns (uint256, bool);\n', '\n', '    function calcLiveAssetsTotalValue(\n', '        address[] calldata,\n', '        uint256[] calldata,\n', '        address\n', '    ) external returns (uint256, bool);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "../price-feeds/derivatives/IAggregatedDerivativePriceFeed.sol";\n', 'import "../price-feeds/derivatives/IDerivativePriceFeed.sol";\n', 'import "../price-feeds/primitives/IPrimitivePriceFeed.sol";\n', 'import "./IValueInterpreter.sol";\n', '\n', '/// @title ValueInterpreter Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Interprets price feeds to provide covert value between asset pairs\n', '/// @dev This contract contains several "live" value calculations, which for this release are simply\n', '/// aliases to their "canonical" value counterparts since the only primitive price feed (Chainlink)\n', '/// is immutable in this contract and only has one type of value. Including the "live" versions of\n', '/// functions only serves as a placeholder for infrastructural components and plugins (e.g., policies)\n', '/// to explicitly define the types of values that they should (and will) be using in a future release.\n', 'contract ValueInterpreter is IValueInterpreter {\n', '    using SafeMath for uint256;\n', '\n', '    address private immutable AGGREGATED_DERIVATIVE_PRICE_FEED;\n', '    address private immutable PRIMITIVE_PRICE_FEED;\n', '\n', '    constructor(address _primitivePriceFeed, address _aggregatedDerivativePriceFeed) public {\n', '        AGGREGATED_DERIVATIVE_PRICE_FEED = _aggregatedDerivativePriceFeed;\n', '        PRIMITIVE_PRICE_FEED = _primitivePriceFeed;\n', '    }\n', '\n', '    // EXTERNAL FUNCTIONS\n', '\n', '    /// @notice An alias of calcCanonicalAssetsTotalValue\n', '    function calcLiveAssetsTotalValue(\n', '        address[] calldata _baseAssets,\n', '        uint256[] calldata _amounts,\n', '        address _quoteAsset\n', '    ) external override returns (uint256 value_, bool isValid_) {\n', '        return calcCanonicalAssetsTotalValue(_baseAssets, _amounts, _quoteAsset);\n', '    }\n', '\n', '    /// @notice An alias of calcCanonicalAssetValue\n', '    function calcLiveAssetValue(\n', '        address _baseAsset,\n', '        uint256 _amount,\n', '        address _quoteAsset\n', '    ) external override returns (uint256 value_, bool isValid_) {\n', '        return calcCanonicalAssetValue(_baseAsset, _amount, _quoteAsset);\n', '    }\n', '\n', '    // PUBLIC FUNCTIONS\n', '\n', '    /// @notice Calculates the total value of given amounts of assets in a single quote asset\n', '    /// @param _baseAssets The assets to convert\n', '    /// @param _amounts The amounts of the _baseAssets to convert\n', '    /// @param _quoteAsset The asset to which to convert\n', '    /// @return value_ The sum value of _baseAssets, denominated in the _quoteAsset\n', '    /// @return isValid_ True if the price feed rates used to derive value are all valid\n', '    /// @dev Does not alter protocol state,\n', '    /// but not a view because calls to price feeds can potentially update third party state\n', '    function calcCanonicalAssetsTotalValue(\n', '        address[] memory _baseAssets,\n', '        uint256[] memory _amounts,\n', '        address _quoteAsset\n', '    ) public override returns (uint256 value_, bool isValid_) {\n', '        require(\n', '            _baseAssets.length == _amounts.length,\n', '            "calcCanonicalAssetsTotalValue: Arrays unequal lengths"\n', '        );\n', '        require(\n', '            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\n', '            "calcCanonicalAssetsTotalValue: Unsupported _quoteAsset"\n', '        );\n', '\n', '        isValid_ = true;\n', '        for (uint256 i; i < _baseAssets.length; i++) {\n', '            (uint256 assetValue, bool assetValueIsValid) = __calcAssetValue(\n', '                _baseAssets[i],\n', '                _amounts[i],\n', '                _quoteAsset\n', '            );\n', '            value_ = value_.add(assetValue);\n', '            if (!assetValueIsValid) {\n', '                isValid_ = false;\n', '            }\n', '        }\n', '\n', '        return (value_, isValid_);\n', '    }\n', '\n', '    /// @notice Calculates the value of a given amount of one asset in terms of another asset\n', '    /// @param _baseAsset The asset from which to convert\n', '    /// @param _amount The amount of the _baseAsset to convert\n', '    /// @param _quoteAsset The asset to which to convert\n', '    /// @return value_ The equivalent quantity in the _quoteAsset\n', '    /// @return isValid_ True if the price feed rates used to derive value are all valid\n', '    /// @dev Does not alter protocol state,\n', '    /// but not a view because calls to price feeds can potentially update third party state\n', '    function calcCanonicalAssetValue(\n', '        address _baseAsset,\n', '        uint256 _amount,\n', '        address _quoteAsset\n', '    ) public override returns (uint256 value_, bool isValid_) {\n', '        if (_baseAsset == _quoteAsset || _amount == 0) {\n', '            return (_amount, true);\n', '        }\n', '\n', '        require(\n', '            IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_quoteAsset),\n', '            "calcCanonicalAssetValue: Unsupported _quoteAsset"\n', '        );\n', '\n', '        return __calcAssetValue(_baseAsset, _amount, _quoteAsset);\n', '    }\n', '\n', '    // PRIVATE FUNCTIONS\n', '\n', '    /// @dev Helper to differentially calculate an asset value\n', '    /// based on if it is a primitive or derivative asset.\n', '    function __calcAssetValue(\n', '        address _baseAsset,\n', '        uint256 _amount,\n', '        address _quoteAsset\n', '    ) private returns (uint256 value_, bool isValid_) {\n', '        if (_baseAsset == _quoteAsset || _amount == 0) {\n', '            return (_amount, true);\n', '        }\n', '\n', '        // Handle case that asset is a primitive\n', '        if (IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).isSupportedAsset(_baseAsset)) {\n', '            return\n', '                IPrimitivePriceFeed(PRIMITIVE_PRICE_FEED).calcCanonicalValue(\n', '                    _baseAsset,\n', '                    _amount,\n', '                    _quoteAsset\n', '                );\n', '        }\n', '\n', '        // Handle case that asset is a derivative\n', '        address derivativePriceFeed = IAggregatedDerivativePriceFeed(\n', '            AGGREGATED_DERIVATIVE_PRICE_FEED\n', '        )\n', '            .getPriceFeedForDerivative(_baseAsset);\n', '        if (derivativePriceFeed != address(0)) {\n', '            return __calcDerivativeValue(derivativePriceFeed, _baseAsset, _amount, _quoteAsset);\n', '        }\n', '\n', '        revert("__calcAssetValue: Unsupported _baseAsset");\n', '    }\n', '\n', '    /// @dev Helper to calculate the value of a derivative in an arbitrary asset.\n', '    /// Handles multiple underlying assets (e.g., Uniswap and Balancer pool tokens).\n', '    /// Handles underlying assets that are also derivatives (e.g., a cDAI-ETH LP)\n', '    function __calcDerivativeValue(\n', '        address _derivativePriceFeed,\n', '        address _derivative,\n', '        uint256 _amount,\n', '        address _quoteAsset\n', '    ) private returns (uint256 value_, bool isValid_) {\n', '        (address[] memory underlyings, uint256[] memory underlyingAmounts) = IDerivativePriceFeed(\n', '            _derivativePriceFeed\n', '        )\n', '            .calcUnderlyingValues(_derivative, _amount);\n', '\n', '        require(underlyings.length > 0, "__calcDerivativeValue: No underlyings");\n', '        require(\n', '            underlyings.length == underlyingAmounts.length,\n', '            "__calcDerivativeValue: Arrays unequal lengths"\n', '        );\n', '\n', '        // Let validity be negated if any of the underlying value calculations are invalid\n', '        isValid_ = true;\n', '        for (uint256 i = 0; i < underlyings.length; i++) {\n', '            (uint256 underlyingValue, bool underlyingValueIsValid) = __calcAssetValue(\n', '                underlyings[i],\n', '                underlyingAmounts[i],\n', '                _quoteAsset\n', '            );\n', '\n', '            if (!underlyingValueIsValid) {\n', '                isValid_ = false;\n', '            }\n', '            value_ = value_.add(underlyingValue);\n', '        }\n', '    }\n', '\n', '    ///////////////////\n', '    // STATE GETTERS //\n', '    ///////////////////\n', '\n', '    /// @notice Gets the `AGGREGATED_DERIVATIVE_PRICE_FEED` variable\n', '    /// @return aggregatedDerivativePriceFeed_ The `AGGREGATED_DERIVATIVE_PRICE_FEED` variable value\n', '    function getAggregatedDerivativePriceFeed()\n', '        external\n', '        view\n', '        returns (address aggregatedDerivativePriceFeed_)\n', '    {\n', '        return AGGREGATED_DERIVATIVE_PRICE_FEED;\n', '    }\n', '\n', '    /// @notice Gets the `PRIMITIVE_PRICE_FEED` variable\n', '    /// @return primitivePriceFeed_ The `PRIMITIVE_PRICE_FEED` variable value\n', '    function getPrimitivePriceFeed() external view returns (address primitivePriceFeed_) {\n', '        return PRIMITIVE_PRICE_FEED;\n', '    }\n', '}\n', '\n', '{\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "ipfs",\n', '    "useLiteralContent": true\n', '  },\n', '  "optimizer": {\n', '    "details": {\n', '      "constantOptimizer": true,\n', '      "cse": true,\n', '      "deduplicate": true,\n', '      "jumpdestRemover": true,\n', '      "orderLiterals": true,\n', '      "peephole": true,\n', '      "yul": false\n', '    },\n', '    "runs": 200\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']