['pragma solidity ^0.5.16;\n', '\n', 'import "./GTokenInterfaces.sol";\n', '\n', '/**\n', ' * @title GErc20Delegator Contract\n', ' * @notice GTokens which wrap an EIP-20 underlying and delegate to an implementation\n', ' */\n', 'contract GErc20Delegator is GTokenInterface, GErc20Interface, GDelegatorInterface {\n', '    /**\n', '     * @notice Construct a new money market\n', '     * @param underlying_ The address of the underlying asset\n', '     * @param comptroller_ The address of the Comptroller\n', '     * @param interestRateModel_ The address of the interest rate model\n', '     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n', '     * @param name_ ERC-20 name of this token\n', '     * @param symbol_ ERC-20 symbol of this token\n', '     * @param decimals_ ERC-20 decimal precision of this token\n', '     * @param admin_ Address of the administrator of this token\n', '     * @param implementation_ The address of the implementation the contract delegates to\n', '     * @param becomeImplementationData The encoded args for becomeImplementation\n', '     */\n', '    constructor(address underlying_,\n', '                ComptrollerInterface comptroller_,\n', '                InterestRateModel interestRateModel_,\n', '                uint initialExchangeRateMantissa_,\n', '                string memory name_,\n', '                string memory symbol_,\n', '                uint8 decimals_,\n', '                address payable admin_,\n', '                address implementation_,\n', '                bytes memory becomeImplementationData) public {\n', '        // Creator of the contract is admin during initialization\n', '        admin = msg.sender;\n', '\n', '        // First delegate gets to initialize the delegator (i.e. storage contract)\n', '        delegateTo(implementation_, abi.encodeWithSignature("initialize(address,address,address,uint256,string,string,uint8)",\n', '                                                            underlying_,\n', '                                                            comptroller_,\n', '                                                            interestRateModel_,\n', '                                                            initialExchangeRateMantissa_,\n', '                                                            name_,\n', '                                                            symbol_,\n', '                                                            decimals_));\n', '\n', '        // New implementations always get set via the settor (post-initialize)\n', '        _setImplementation(implementation_, false, becomeImplementationData);\n', '\n', '        // Set the proper admin now that initialization is done\n', '        admin = admin_;\n', '    }\n', '\n', '    /**\n', '     * @notice Called by the admin to update the implementation of the delegator\n', '     * @param implementation_ The address of the new implementation for delegation\n', '     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n', '     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n', '     */\n', '    function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) public {\n', '        require(msg.sender == admin, "CErc20Delegator::_setImplementation: Caller must be admin");\n', '\n', '        if (allowResign) {\n', '            delegateToImplementation(abi.encodeWithSignature("_resignImplementation()"));\n', '        }\n', '\n', '        address oldImplementation = implementation;\n', '        implementation = implementation_;\n', '\n', '        delegateToImplementation(abi.encodeWithSignature("_becomeImplementation(bytes)", becomeImplementationData));\n', '\n', '        emit NewImplementation(oldImplementation, implementation);\n', '    }\n', '\n', '    /**\n', '     * @notice Sender supplies assets into the market and receives gTokens in exchange\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param mintAmount The amount of the underlying asset to supply\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function mint(uint mintAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("mint(uint256)", mintAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Sender redeems gTokens in exchange for the underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param redeemTokens The number of gTokens to redeem into underlying\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeem(uint redeemTokens) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("redeem(uint256)", redeemTokens));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Sender redeems gTokens in exchange for a specified amount of underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param redeemAmount The amount of underlying to redeem\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("redeemUnderlying(uint256)", redeemAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '      * @notice Sender borrows assets from the protocol to their own address\n', '      * @param borrowAmount The amount of the underlying asset to borrow\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function borrow(uint borrowAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("borrow(uint256)", borrowAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Sender repays their own borrow\n', '     * @param repayAmount The amount to repay\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function repayBorrow(uint repayAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("repayBorrow(uint256)", repayAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Sender repays a borrow belonging to borrower\n', '     * @param borrower the account with the debt being payed off\n', '     * @param repayAmount The amount to repay\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("repayBorrowBehalf(address,uint256)", borrower, repayAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice The sender liquidates the borrowers collateral.\n', '     *  The collateral seized is transferred to the liquidator.\n', '     * @param borrower The borrower of this gToken to be liquidated\n', '     * @param gTokenCollateral The market in which to seize collateral from the borrower\n', '     * @param repayAmount The amount of the underlying borrowed asset to repay\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function liquidateBorrow(address borrower, uint repayAmount, GTokenInterface gTokenCollateral) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("liquidateBorrow(address,uint256,address)", borrower, repayAmount, gTokenCollateral));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n', '     * @param dst The address of the destination account\n', '     * @param amount The number of tokens to transfer\n', '     * @return Whether or not the transfer succeeded\n', '     */\n', '    function transfer(address dst, uint amount) external returns (bool) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("transfer(address,uint256)", dst, amount));\n', '        return abi.decode(data, (bool));\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer `amount` tokens from `src` to `dst`\n', '     * @param src The address of the source account\n', '     * @param dst The address of the destination account\n', '     * @param amount The number of tokens to transfer\n', '     * @return Whether or not the transfer succeeded\n', '     */\n', '    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("transferFrom(address,address,uint256)", src, dst, amount));\n', '        return abi.decode(data, (bool));\n', '    }\n', '\n', '    /**\n', '     * @notice Approve `spender` to transfer up to `amount` from `src`\n', '     * @dev This will overwrite the approval amount for `spender`\n', '     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n', '     * @param spender The address of the account which may transfer tokens\n', '     * @param amount The number of tokens that are approved (-1 means infinite)\n', '     * @return Whether or not the approval succeeded\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("approve(address,uint256)", spender, amount));\n', '        return abi.decode(data, (bool));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the current allowance from `owner` for `spender`\n', '     * @param owner The address of the account which owns the tokens to be spent\n', '     * @param spender The address of the account which may transfer tokens\n', '     * @return The number of tokens allowed to be spent (-1 means infinite)\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("allowance(address,address)", owner, spender));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token balance of the `owner`\n', '     * @param owner The address of the account to query\n', '     * @return The number of tokens owned by `owner`\n', '     */\n', '    function balanceOf(address owner) external view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("balanceOf(address)", owner));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying balance of the `owner`\n', '     * @dev This also accrues interest in a transaction\n', '     * @param owner The address of the account to query\n', '     * @return The amount of underlying owned by `owner`\n', '     */\n', '    function balanceOfUnderlying(address owner) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("balanceOfUnderlying(address)", owner));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', "     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n", '     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n', '     * @param account Address of the account to snapshot\n', '     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n', '     */\n', '    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("getAccountSnapshot(address)", account));\n', '        return abi.decode(data, (uint, uint, uint, uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the current per-block borrow interest rate for this gToken\n', '     * @return The borrow interest rate per block, scaled by 1e18\n', '     */\n', '    function borrowRatePerBlock() external view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("borrowRatePerBlock()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the current per-block supply interest rate for this gToken\n', '     * @return The supply interest rate per block, scaled by 1e18\n', '     */\n', '    function supplyRatePerBlock() external view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("supplyRatePerBlock()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the current total borrows plus accrued interest\n', '     * @return The total borrows with interest\n', '     */\n', '    function totalBorrowsCurrent() external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("totalBorrowsCurrent()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', "     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n", '     * @param account The address whose balance should be calculated after updating borrowIndex\n', '     * @return The calculated balance\n', '     */\n', '    function borrowBalanceCurrent(address account) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("borrowBalanceCurrent(address)", account));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Return the borrow balance of account based on stored data\n', '     * @param account The address whose balance should be calculated\n', '     * @return The calculated balance\n', '     */\n', '    function borrowBalanceStored(address account) public view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("borrowBalanceStored(address)", account));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '   /**\n', '     * @notice Accrue interest then return the up-to-date exchange rate\n', '     * @return Calculated exchange rate scaled by 1e18\n', '     */\n', '    function exchangeRateCurrent() public returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("exchangeRateCurrent()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates the exchange rate from the underlying to the GToken\n', '     * @dev This function does not accrue interest before calculating the exchange rate\n', '     * @return Calculated exchange rate scaled by 1e18\n', '     */\n', '    function exchangeRateStored() public view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("exchangeRateStored()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Get cash balance of this gToken in the underlying asset\n', '     * @return The quantity of underlying asset owned by this contract\n', '     */\n', '    function getCash() external view returns (uint) {\n', '        bytes memory data = delegateToViewImplementation(abi.encodeWithSignature("getCash()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '      * @notice Applies accrued interest to total borrows and reserves.\n', '      * @dev This calculates interest accrued from the last checkpointed block\n', '      *      up to the current block and writes new checkpoint to storage.\n', '      */\n', '    function accrueInterest() public returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("accrueInterest()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Transfers collateral tokens (this market) to the liquidator.\n', '     * @dev Will fail unless called by another gToken during the process of liquidation.\n', '     *  Its absolutely critical to use msg.sender as the borrowed gToken and not a parameter.\n', '     * @param liquidator The account receiving seized collateral\n', '     * @param borrower The account having collateral seized\n', '     * @param seizeTokens The number of gTokens to seize\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("seize(address,address,uint256)", liquidator, borrower, seizeTokens));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /*** Admin Functions ***/\n', '\n', '    /**\n', '      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '      * @param newPendingAdmin New pending admin.\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setPendingAdmin(address)", newPendingAdmin));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '      * @notice Sets a new comptroller for the market\n', '      * @dev Admin function to set a new comptroller\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setComptroller(address)", newComptroller));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '      * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n', '      * @dev Admin function to accrue interest and set a new reserve factor\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setReserveFactor(uint newReserveFactorMantissa) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setReserveFactor(uint256)", newReserveFactorMantissa));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n', '      * @dev Admin function for pending admin to accept role and update admin\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _acceptAdmin() external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_acceptAdmin()"));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Accrues interest and adds reserves by transferring from admin\n', '     * @param addAmount Amount of reserves to add\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _addReserves(uint addAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_addReserves(uint256)", addAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Accrues interest and reduces reserves by transferring to admin\n', '     * @param reduceAmount Amount of reduction to reserves\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _reduceReserves(uint reduceAmount) external returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_reduceReserves(uint256)", reduceAmount));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n', '     * @dev Admin function to accrue interest and update the interest rate model\n', '     * @param newInterestRateModel the new interest rate model to use\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n', '        bytes memory data = delegateToImplementation(abi.encodeWithSignature("_setInterestRateModel(address)", newInterestRateModel));\n', '        return abi.decode(data, (uint));\n', '    }\n', '\n', '    /**\n', '     * @notice Internal method to delegate execution to another contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     * @param callee The contract to delegatecall\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = callee.delegatecall(data);\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return returnData;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to the implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n', '        return delegateTo(implementation, data);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to an implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", data));\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return abi.decode(returnData, (bytes));\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to an implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     */\n', '    function () external payable {\n', '        require(msg.value == 0,"CErc20Delegator:fallback: cannot send value to fallback");\n', '\n', '        // delegate all other functions to current implementation\n', '        (bool success, ) = implementation.delegatecall(msg.data);\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(free_mem_ptr, returndatasize) }\n', '        }\n', '    }\n', '}']