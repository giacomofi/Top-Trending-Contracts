['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-15\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-2.0-or-later\n', '/*\n', ' â–„â–„â–„â–„â–„â–„   â–„â–ˆâ–ˆâ–ˆâ–„      â–„   â–ˆ  â–ˆâ–€ â–ˆâ–ˆâ–ˆâ–ˆâ–„ \n', 'â–€   â–„â–„â–€   â–ˆâ–€   â–€      â–ˆ  â–ˆâ–„â–ˆ   â–ˆ   â–ˆ \n', ' â–„â–€â–€   â–„â–€ â–ˆâ–ˆâ–„â–„    â–ˆâ–ˆ   â–ˆ â–ˆâ–€â–„   â–ˆ   â–ˆ \n', ' â–€â–€â–€â–€â–€â–€   â–ˆâ–„   â–„â–€ â–ˆ â–ˆ  â–ˆ â–ˆ  â–ˆ  â–€â–ˆâ–ˆâ–ˆâ–ˆ \n', '          â–€â–ˆâ–ˆâ–ˆâ–€   â–ˆ  â–ˆ â–ˆ   â–ˆ         \n', '                  â–ˆ   â–ˆâ–ˆ  â–€       */\n', '/// ðŸ¦ŠðŸŒ¾ Special thanks to Keno / Boring / Gonpachi / Karbon for review and continued inspiration.\n', 'pragma solidity 0.8.6;\n', '\n', 'interface IERC20 {} interface IBentoHelper {\n', '    function toAmount(\n', '        IERC20 token,\n', '        uint256 share,\n', '        bool roundUp\n', '    ) external view returns (uint256 amount);\n', '\n', '    function toShare(\n', '        IERC20 token,\n', '        uint256 amount,\n', '        bool roundUp\n', '    ) external view returns (uint256 share);\n', '}\n', '\n', 'interface ICompoundHelper {\n', '    function getCash() external view returns (uint256);\n', '    function totalBorrows() external view returns (uint256);\n', '    function totalReserves() external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', 'interface IKashiHelper {\n', '    function asset() external view returns (IERC20);\n', '    function totalAsset() external view returns (Rebase memory);\n', '    function totalBorrow() external view returns (Rebase memory);\n', '    struct Rebase {\n', '        uint128 elastic;\n', '        uint128 base;\n', '    }\n', '}\n', '\n', '/// @notice Helper for Inari SushiZap calculations.\n', 'contract Zenko {\n', '    IBentoHelper constant bento = IBentoHelper(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966); // BENTO vault contract (multinet)\n', '    \n', '    // **** BENTO \n', '    function toBento(IERC20 token, uint256 amount) external view returns (uint256 share) {\n', '        share = bento.toShare(token, amount, false);\n', '    }\n', '    \n', '    function fromBento(IERC20 token, uint256 share) external view returns (uint256 amount) {\n', '        amount = bento.toAmount(token, share, false);\n', '    }\n', '    \n', '    // **** COMPOUND/CREAM\n', '    function toCtoken(ICompoundHelper cToken, uint256 underlyingAmount) public view returns (uint256 cTokenAmount) {\n', '        cTokenAmount = divScalarByExpTruncate(underlyingAmount, Exp({mantissa: exchangeRateStoredInternal(cToken)}));\n', '    }\n', '    \n', '    function fromCtoken(ICompoundHelper cToken, uint256 cTokenAmount) public view returns (uint256 underlyingAmount) {\n', '        underlyingAmount = mulScalarTruncate(Exp({mantissa: exchangeRateStoredInternal(cToken)}), cTokenAmount);\n', '    }\n', '\n', '    // **** KASHI - ASSET\n', '    function toKashi(IKashiHelper kmToken, uint256 underlyingAmount) external view returns (uint256 fraction) {\n', '        IERC20 token = kmToken.asset();\n', '        uint256 share = bento.toShare(token, underlyingAmount, false);\n', '        uint256 allShare = kmToken.totalAsset().elastic + bento.toShare(token, kmToken.totalBorrow().elastic, true);\n', '        fraction = allShare == 0 ? share : share * kmToken.totalAsset().base / allShare;\n', '    }\n', '    \n', '    function fromKashi(IKashiHelper kmToken, uint256 kmAmount) external view returns (uint256 share) {\n', '        uint256 allShare = kmToken.totalAsset().elastic + bento.toShare(kmToken.asset(), kmToken.totalBorrow().elastic, true);\n', '        share = kmAmount * allShare / kmToken.totalAsset().base;\n', '    }\n', '    \n', '    // **************\n', '    // CTOKEN HELPERS\n', '    // **************\n', '    struct Exp {\n', '        uint256 mantissa;\n', '    }\n', '    function addUInt(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a + b;\n', '    }\n', '    function subUInt(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a - b;\n', '    }\n', '    function addThenSubUInt(uint256 a, uint256 b, uint256 c) internal pure returns (uint256) {\n', '        uint256 sum = addUInt(a, b);\n', '        return subUInt(sum, c);\n', '    }\n', '    function mulUInt(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a * b;\n', '    }\n', '    function divUInt(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '    function getExp(uint256 num, uint256 denom) pure internal returns (Exp memory) {\n', '        uint256 scaledNumerator = mulUInt(num, 1e18);\n', '        uint256 rational = divUInt(scaledNumerator, denom);\n', '        return Exp({mantissa: rational});\n', '    }\n', '    function truncate(Exp memory exp) pure internal returns (uint256) {\n', '        return exp.mantissa / 1e18;\n', '    }\n', '    function divScalarByExp(uint256 scalar, Exp memory divisor) pure internal returns (Exp memory) {\n', '        uint256 numerator = mulUInt(1e18, scalar);\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) pure internal returns (uint256) {\n', '        Exp memory fraction = divScalarByExp(scalar, divisor);\n', '        return truncate(fraction);\n', '    }\n', '    function mulScalar(Exp memory a, uint256 scalar) pure internal returns (Exp memory) {\n', '        uint256 scaledMantissa = mulUInt(a.mantissa, scalar);\n', '        return Exp({mantissa: scaledMantissa});\n', '    }\n', '    function mulScalarTruncate(Exp memory a, uint256 scalar) pure internal returns (uint256) {\n', '        Exp memory product = mulScalar(a, scalar);\n', '        return truncate(product);\n', '    }\n', '    function exchangeRateStoredInternal(ICompoundHelper cToken) public view returns (uint256) {\n', '        uint256 _totalSupply = cToken.totalSupply();\n', '        /*\n', '         *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n', '         */\n', '        uint256 totalCash = cToken.getCash();\n', '        uint256 cashPlusBorrowsMinusReserves;\n', '        Exp memory exchangeRate;\n', '        cashPlusBorrowsMinusReserves = addThenSubUInt(totalCash, cToken.totalBorrows(), cToken.totalReserves());\n', '        exchangeRate = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n', '        return exchangeRate.mantissa;\n', '    }\n', '}']