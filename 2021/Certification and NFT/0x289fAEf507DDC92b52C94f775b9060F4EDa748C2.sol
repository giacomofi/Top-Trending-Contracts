['pragma solidity ^0.6.6;\n', '\n', 'import "./Address.sol";\n', 'import "./IACOToken.sol";\n', '\n', '/**\n', ' * @title ACOFactory\n', ' * @dev The contract is the implementation for the ACOProxy.\n', ' */\n', 'contract ACOFactory {\n', '    \n', '    /**\n', '     * @dev Emitted when the factory admin address has been changed.\n', '     * @param previousFactoryAdmin Address of the previous factory admin.\n', '     * @param newFactoryAdmin Address of the new factory admin.\n', '     */\n', '    event SetFactoryAdmin(address indexed previousFactoryAdmin, address indexed newFactoryAdmin);\n', '    \n', '    /**\n', '     * @dev Emitted when the ACO token implementation has been changed.\n', '     * @param previousAcoTokenImplementation Address of the previous ACO token implementation.\n', '     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n', '     */\n', '    event SetAcoTokenImplementation(address indexed previousAcoTokenImplementation, address indexed newAcoTokenImplementation);\n', '    \n', '    /**\n', '     * @dev Emitted when the ACO fee has been changed.\n', '     * @param previousAcoFee Value of the previous ACO fee.\n', '     * @param newAcoFee Value of the new ACO fee.\n', '     */\n', '    event SetAcoFee(uint256 indexed previousAcoFee, uint256 indexed newAcoFee);\n', '    \n', '    /**\n', '     * @dev Emitted when the ACO fee destination address has been changed.\n', '     * @param previousAcoFeeDestination Address of the previous ACO fee destination.\n', '     * @param newAcoFeeDestination Address of the new ACO fee destination.\n', '     */\n', '    event SetAcoFeeDestination(address indexed previousAcoFeeDestination, address indexed newAcoFeeDestination);\n', '    \n', '    /**\n', '     * @dev Emitted when a new ACO token has been created.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall True if the type is CALL, false for PUT.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param acoToken Address of the new ACO token created.\n', '     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n', '     */\n', '    event NewAcoToken(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation);\n', '    \n', '    /**\n', '     * @dev The ACO fee value. \n', '     * It is a percentage value (100000 is 100%).\n', '     */\n', '    uint256 public acoFee;\n', '    \n', '    /**\n', '     * @dev The factory admin address.\n', '     */\n', '    address public factoryAdmin;\n', '    \n', '    /**\n', '     * @dev The ACO token implementation address.\n', '     */\n', '    address public acoTokenImplementation;\n', '    \n', '    /**\n', '     * @dev The ACO fee destination address.\n', '     */\n', '    address public acoFeeDestination;\n', '    \n', '    /**\n', '     * @dev Modifier to check if the `msg.sender` is the factory admin.\n', '     * Only factory admin address can execute.\n', '     */\n', '    modifier onlyFactoryAdmin() {\n', '        require(msg.sender == factoryAdmin, "ACOFactory::onlyFactoryAdmin");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to initialize the contract.\n', '     * It should be called through the `data` argument when creating the proxy.\n', '     * It must be called only once. The `assert` is to guarantee that behavior.\n', '     * @param _factoryAdmin Address of the factory admin.\n', '     * @param _acoTokenImplementation Address of the ACO token implementation.\n', '     * @param _acoFee Value of the ACO fee.\n', '     * @param _acoFeeDestination Address of the ACO fee destination.\n', '     */\n', '    function init(address _factoryAdmin, address _acoTokenImplementation, uint256 _acoFee, address _acoFeeDestination) public {\n', '        require(factoryAdmin == address(0) && acoTokenImplementation == address(0), "ACOFactory::init: Contract already initialized.");\n', '        \n', '        _setFactoryAdmin(_factoryAdmin);\n', '        _setAcoTokenImplementation(_acoTokenImplementation);\n', '        _setAcoFee(_acoFee);\n', '        _setAcoFeeDestination(_acoFeeDestination);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to guarantee that the contract will not receive ether.\n', '     */\n', '    receive() external payable virtual {\n', '        revert();\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     */\n', '    function createAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) onlyFactoryAdmin external virtual returns(address) {\n', '        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\n', '        return acoToken;\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to set the factory admin address.\n', '     * Only can be called by the factory admin.\n', '     * @param newFactoryAdmin Address of the new factory admin.\n', '     */\n', '    function setFactoryAdmin(address newFactoryAdmin) onlyFactoryAdmin external virtual {\n', '        _setFactoryAdmin(newFactoryAdmin);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to set the ACO token implementation address.\n', '     * Only can be called by the factory admin.\n', '     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n', '     */\n', '    function setAcoTokenImplementation(address newAcoTokenImplementation) onlyFactoryAdmin external virtual {\n', '        _setAcoTokenImplementation(newAcoTokenImplementation);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to set the ACO fee.\n', '     * Only can be called by the factory admin.\n', '     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n', '     */\n', '    function setAcoFee(uint256 newAcoFee) onlyFactoryAdmin external virtual {\n', '        _setAcoFee(newAcoFee);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to set the ACO destination address.\n', '     * Only can be called by the factory admin.\n', '     * @param newAcoFeeDestination Address of the new ACO destination.\n', '     */\n', '    function setAcoFeeDestination(address newAcoFeeDestination) onlyFactoryAdmin external virtual {\n', '        _setAcoFeeDestination(newAcoFeeDestination);\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to set the factory admin address.\n', '     * @param newFactoryAdmin Address of the new factory admin.\n', '     */\n', '    function _setFactoryAdmin(address newFactoryAdmin) internal virtual {\n', '        require(newFactoryAdmin != address(0), "ACOFactory::_setFactoryAdmin: Invalid factory admin");\n', '        emit SetFactoryAdmin(factoryAdmin, newFactoryAdmin);\n', '        factoryAdmin = newFactoryAdmin;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to set the ACO token implementation address.\n', '     * @param newAcoTokenImplementation Address of the new ACO token implementation.\n', '     */\n', '    function _setAcoTokenImplementation(address newAcoTokenImplementation) internal virtual {\n', '        require(Address.isContract(newAcoTokenImplementation), "ACOFactory::_setAcoTokenImplementation: Invalid ACO token implementation");\n', '        emit SetAcoTokenImplementation(acoTokenImplementation, newAcoTokenImplementation);\n', '        acoTokenImplementation = newAcoTokenImplementation;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to set the ACO fee.\n', '     * @param newAcoFee Value of the new ACO fee. It is a percentage value (100000 is 100%).\n', '     */\n', '    function _setAcoFee(uint256 newAcoFee) internal virtual {\n', '        emit SetAcoFee(acoFee, newAcoFee);\n', '        acoFee = newAcoFee;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to set the ACO destination address.\n', '     * @param newAcoFeeDestination Address of the new ACO destination.\n', '     */\n', '    function _setAcoFeeDestination(address newAcoFeeDestination) internal virtual {\n', '        require(newAcoFeeDestination != address(0), "ACOFactory::_setAcoFeeDestination: Invalid ACO fee destination");\n', '        emit SetAcoFeeDestination(acoFeeDestination, newAcoFeeDestination);\n', '        acoFeeDestination = newAcoFeeDestination;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to deploy a minimal proxy using ACO token implementation.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall True if the type is CALL, false for PUT.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     * @return Address of the new minimal proxy deployed for the ACO token.\n', '     */\n', '    function _deployAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) internal virtual returns(address) {\n', '        bytes20 implentationBytes = bytes20(acoTokenImplementation);\n', '        address proxy;\n', '        assembly {\n', '            let clone := mload(0x40)\n', '            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(clone, 0x14), implentationBytes)\n', '            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            proxy := create(0, clone, 0x37)\n', '        }\n', '        IACOToken(proxy).init(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoFee, payable(acoFeeDestination), maxExercisedAccounts);\n', '        return proxy;\n', '    }\n', '}\n', '\n', 'contract ACOFactoryV2 is ACOFactory {\n', '\t\n', '\t/**\n', '     * @dev Struct to store the ACO Token basic data.\n', '     */\n', '    struct ACOTokenData {\n', '        /**\n', '         * @dev Address of the underlying asset (0x0 for Ethereum).\n', '         */\n', '        address underlying;\n', '        \n', '        /**\n', '         * @dev Address of the strike asset (0x0 for Ethereum).\n', '         */\n', '        address strikeAsset;\n', '        \n', '        /**\n', '         * @dev True if the type is CALL, false for PUT.\n', '         */\n', '        bool isCall;\n', '        \n', '        /**\n', '         * @dev The strike price with the strike asset precision.\n', '         */\n', '        uint256 strikePrice;\n', '        \n', '        /**\n', '         * @dev The UNIX time for the ACO token expiration.\n', '         */\n', '        uint256 expiryTime;\n', '    }\n', '\t\n', '    /**\n', '     * @dev The ACO token basic data.\n', '     */\n', '    mapping(address => ACOTokenData) public acoTokenData;\n', '\n', '    /**\n', '     * @dev Function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     * @return The created ACO token address.\n', '     */\n', '    function createAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) onlyFactoryAdmin external override virtual returns(address) {\n', '        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\n', '        emit NewAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation);\n', '        return acoToken;\n', '    }\n', '}\n', '\n', 'contract ACOFactoryV3 is ACOFactoryV2 {\n', '\n', '    /**\n', '     * @dev Emitted when the operator address permission has been changed.\n', '     * @param operator Address of the operator.\n', '     * @param previousPermission Whether the operator was authorized.\n', '     * @param newPermission Whether the operator will be authorized.\n', '     */\n', '    event SetOperator(address indexed operator, bool indexed previousPermission, bool indexed newPermission);\n', '\n', '    /**\n', '     * @dev Emitted when a new ACO token has been created.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall True if the type is CALL, false for PUT.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param acoToken Address of the new ACO token created.\n', '     * @param acoTokenImplementation Address of the ACO token implementation used on creation.\n', '     * @param creator Address of the ACO creator.\n', '     */\n', '    event NewAcoTokenData(address indexed underlying, address indexed strikeAsset, bool indexed isCall, uint256 strikePrice, uint256 expiryTime, address acoToken, address acoTokenImplementation, address creator);\n', '    \n', '    /**\n', '     * @dev A map to register the ACO Factory operators permissions.\n', '     */\n', '    mapping(address => bool) public operators;\n', '    \n', '    /**\n', '     * @dev A map to register the ACO creator.\n', '     */\n', '    mapping(address => address) public creators;\n', '\n', '    /**\n', '     * @dev Function to set the operator permission.\n', '     * @param operator Address of the operator.\n', '     * @param newPermission Whether the operator will be authorized.\n', '     */\n', '    function setOperator(address operator, bool newPermission) onlyFactoryAdmin external virtual {\n', '        _setOperator(operator, newPermission);\n', '    }\n', '\n', '\t/**\n', '     * @dev Function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     * @return The created ACO token address.\n', '     */\n', '    function createAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) external override virtual returns(address) {\n', '        require(operators[msg.sender], "ACOFactory::createAcoToken: Only authorized operators");\n', '        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\n', '        creators[acoToken] = msg.sender;\n', '        emit NewAcoTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation, msg.sender);\n', '        return acoToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the operator permission.\n', '     * @param operator Address of the operator.\n', '     * @param newPermission Whether the operator will be authorized.\n', '     */\n', '    function _setOperator(address operator, bool newPermission) internal virtual {\n', '        emit SetOperator(operator, operators[operator], newPermission);\n', '        operators[operator] = newPermission;\n', '    }\n', '}\n', '\n', 'contract ACOFactoryV4 is ACOFactoryV3 {\n', '\n', '    uint256 public constant MAX_EXPIRATION = 157852800;\n', '    uint256 public constant DEFAULT_MAX_EXERCISED_ACCOUNTS = 100;\n', '    uint256 public constant DEFAULT_MAX_SIGNIFICANT_DIGITS = 3;\n', '\n', '    struct AssetData {\n', '        /*\n', '         * The maximum significant digits on the strike to ACO creation.\n', '         */\n', '        uint256 maxSignificantDigits;\n', '        \n', '        /*\n', '         * The maximum number of accounts that can be exercised by transaction.\n', '         */\n', '        uint256 maxExercisedAccounts;\n', '    }\n', '\n', '    /**\n', '     * @dev Emitted when the strike asset address permission has been changed.\n', '     * @param strikeAsset Address of the strike asset.\n', '     * @param previousPermission Whether the strike asset was authorized.\n', '     * @param newPermission Whether the strike asset will be authorized.\n', '     */\n', '    event SetStrikeAssetPermission(address indexed strikeAsset, bool indexed previousPermission, bool indexed newPermission);\n', '\n', '    /**\n', '     * @dev Emitted when the asset specific data has been changed.\n', '     * @param asset Address of the asset.\n', '     * @param previousMaxSignificantDigits Previous value of the maximum significant digits on the strike to ACO creation.\n', '     * @param previousMaxExercisedAccounts Previous value of the maximum number of accounts that can be exercised by transaction.\n', '     * @param newMaxSignificantDigits New value of the maximum significant digits on the strike to ACO creation.\n', '     * @param newMaxExercisedAccounts New value of the maximum number of accounts that can be exercised by transaction.\n', '     */\n', '    event SetAssetSpecificData(address indexed asset, uint256 previousMaxSignificantDigits, uint256 previousMaxExercisedAccounts, uint256 newMaxSignificantDigits, uint256 newMaxExercisedAccounts);\n', '    \n', '    /**\n', '     * @dev A map to register the strike assets permissions.\n', '     */\n', '    mapping(address => bool) public strikeAssets;\n', '    \n', '    /**\n', '     * @dev A map to register the ACOs by their hash.\n', '     */\n', '    mapping(bytes32 => address) public acoHashes;\n', '    \n', '    /**\n', '     * @dev A map to register the assets specific data.\n', '     */\n', '    mapping(address => AssetData) public assetsSpecificData;\n', '\n', '    /**\n', '     * @dev Function to set the strike asset permission.\n', '     * @param strikeAsset Address of the strike asset.\n', '     * @param newPermission Whether the strike asset will be authorized.\n', '     */\n', '    function setStrikeAssetPermission(address strikeAsset, bool newPermission) onlyFactoryAdmin external virtual {\n', '        _setStrikeAssetPermission(strikeAsset, newPermission);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to set the asset specific data.\n', '     * @param asset Address of the asset.\n', '     * @param maxSignificantDigits The maximum significant digits on the strike to create an ACO.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     */\n', '    function setAssetSpecificData(\n', '        address asset, \n', '        uint256 maxSignificantDigits,\n', '        uint256 maxExercisedAccounts\n', '    ) onlyFactoryAdmin external virtual {\n', '        _setAssetSpecificData(asset, maxSignificantDigits, maxExercisedAccounts);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to get the ACO token by the parameters.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @return The ACO address or 0x0 if it does not exist.\n', '     */\n', '    function getAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime\n', '    ) external virtual view returns(address) {\n', '        bytes32 acoHash = _getAcoHash(underlying, strikeAsset, isCall, strikePrice, expiryTime);\n', '        return acoHashes[acoHash];\n', '    }\n', '\n', '\t/**\n', '     * @dev Function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     * @return The created ACO token address.\n', '     */\n', '    function createAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) external override virtual returns(address) {\n', '        require(operators[msg.sender], "ACOFactory::createAcoToken: Only authorized operators");\n', '        return _createAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '    }\n', '    \n', '    /**\n', '     * @dev Function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @return The created ACO token address.\n', '     */\n', '    function newAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime\n', '    ) external virtual returns(address) {\n', '        require(strikeAssets[strikeAsset], "ACOFactory::newAcoToken: Invalid strike asset");\n', '        require(_isValidTime(expiryTime), "ACOFactory::newAcoToken: Invalid expiry time");\n', '        \n', '        AssetData storage strikeAssetData = assetsSpecificData[strikeAsset];\n', '        uint256 maxSignificantDigits = _getMaxSignificantDigits(strikeAssetData);\n', '        require(_isValidStrikePrice(strikePrice, maxSignificantDigits), "ACOFactory::newAcoToken: Invalid strike price");\n', '        \n', '        uint256 maxExercisedAccounts = _getMaxExercisedAccounts(underlying, isCall, strikeAssetData);\n', '        return _createAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to create a new ACO token.\n', '     * It deploys a minimal proxy for the ACO token implementation address. \n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     * @return The created ACO token address.\n', '     */\n', '    function _createAcoToken(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime,\n', '        uint256 maxExercisedAccounts\n', '    ) internal virtual returns(address) {\n', '        require(expiryTime <= (block.timestamp + MAX_EXPIRATION), "ACOFactory::_createAcoToken: Invalid expiry time");\n', '        \n', '        bytes32 acoHash = _getAcoHash(underlying, strikeAsset, isCall, strikePrice, expiryTime);\n', '        require(acoHashes[acoHash] == address(0), "ACOFactory::_createAcoToken: ACO already exists");\n', '        \n', '        address acoToken = _deployAcoToken(underlying, strikeAsset, isCall, strikePrice, expiryTime, maxExercisedAccounts);\n', '        acoTokenData[acoToken] = ACOTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime);\n', '        creators[acoToken] = msg.sender;\n', '        acoHashes[acoHash] = acoToken;\n', '        emit NewAcoTokenData(underlying, strikeAsset, isCall, strikePrice, expiryTime, acoToken, acoTokenImplementation, msg.sender);\n', '        return acoToken;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to get the ACO hash.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param strikeAsset Address of the strike asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @return The ACO hash.\n', '     */\n', '    function _getAcoHash(\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall,\n', '        uint256 strikePrice, \n', '        uint256 expiryTime\n', '    ) internal pure virtual returns(bytes32) {\n', '        return keccak256(abi.encodePacked(underlying, strikeAsset, isCall, strikePrice, expiryTime));\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to get the maximum number of accounts that can be exercised by transaction for an ACO creation.\n', '     * @param underlying Address of the underlying asset (0x0 for Ethereum).\n', '     * @param isCall Whether the ACO token is the Call type.\n', '     * @param strikeAssetData The strike asset specific data.\n', '     * @return The maximum number of accounts that can be exercised by transaction for an ACO creation.\n', '     */\n', '    function _getMaxExercisedAccounts(\n', '        address underlying, \n', '        bool isCall,\n', '        AssetData storage strikeAssetData\n', '    ) internal view virtual returns(uint256) {\n', '        if (isCall) {\n', '            AssetData storage underlyingData = assetsSpecificData[underlying];\n', '            if (underlyingData.maxExercisedAccounts > 0) {\n', '                return underlyingData.maxExercisedAccounts;\n', '            }\n', '        } else if (strikeAssetData.maxExercisedAccounts > 0) {\n', '            return strikeAssetData.maxExercisedAccounts;\n', '        }\n', '        return DEFAULT_MAX_EXERCISED_ACCOUNTS;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to get the maximum significant digits on the strike to ACO creation.\n', '     * @param strikeAssetData The strike asset specific data.\n', '     * @return The maximum significant digits on the strike to ACO creation.\n', '     */\n', '    function _getMaxSignificantDigits(AssetData storage strikeAssetData) internal view virtual returns(uint256) {\n', '        if (strikeAssetData.maxSignificantDigits > 0) {\n', '            return strikeAssetData.maxSignificantDigits;\n', '        }\n', '        return DEFAULT_MAX_SIGNIFICANT_DIGITS;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to check if the expiry time is 8:00 AM.\n', '     * @param expiryTime The UNIX time for the ACO token expiration.\n', '     * @return TRUE if it is 8:00 AM else FALSE.\n', '     */\n', '    function _isValidTime(uint256 expiryTime) internal pure virtual returns(bool) {\n', '        return ((expiryTime % 60) == 0 && ((expiryTime % 3600) / 60) == 0 && ((expiryTime % 86400) / 3600) == 8);\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to check if the strike price respect the maximum significant digits allowed.\n', '     * @param strikePrice The strike price with the strike asset precision.\n', '     * @param maxSignificantDigits The maximum significant digits on the strike to ACO creation.\n', '     * @return TRUE if it is valid else FALSE.\n', '     */\n', '    function _isValidStrikePrice(uint256 strikePrice, uint256 maxSignificantDigits) internal pure virtual returns(bool) {\n', '        uint256 i = strikePrice;\n', '        uint256 len;\n', '        while (i != 0) {\n', '            len++;\n', '            i /= 10;\n', '        }\n', '        if (len <= maxSignificantDigits) {\n', '            return true;\n', '        }\n', '        uint256 diff = len - maxSignificantDigits;\n', '        if (diff < 78) {\n', '            uint256 nonSignificant = 10 ** diff;\n', '            return ((strikePrice / nonSignificant) * nonSignificant) == strikePrice;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the strike asset permission.\n', '     * @param strikeAsset Address of the strike asset.\n', '     * @param newPermission Whether the strike asset will be authorized.\n', '     */\n', '    function _setStrikeAssetPermission(address strikeAsset, bool newPermission) internal virtual {\n', '        emit SetStrikeAssetPermission(strikeAsset, strikeAssets[strikeAsset], newPermission);\n', '        strikeAssets[strikeAsset] = newPermission;\n', '    }\n', '    \n', '    /**\n', '     * @dev Internal function to set the asset specific data.\n', '     * @param asset Address of the asset.\n', '     * @param maxSignificantDigits The maximum significant digits on the strike to ACO creation.\n', '     * @param maxExercisedAccounts The maximum number of accounts that can be exercised by transaction.\n', '     */\n', '    function _setAssetSpecificData(\n', '        address asset, \n', '        uint256 maxSignificantDigits,\n', '        uint256 maxExercisedAccounts\n', '    ) internal virtual {\n', '        AssetData storage previousData = assetsSpecificData[asset];\n', '        emit SetAssetSpecificData(asset, previousData.maxSignificantDigits, previousData.maxExercisedAccounts, maxSignificantDigits, maxExercisedAccounts);\n', '        assetsSpecificData[asset] = AssetData(maxSignificantDigits, maxExercisedAccounts);\n', '    }\n', '}']