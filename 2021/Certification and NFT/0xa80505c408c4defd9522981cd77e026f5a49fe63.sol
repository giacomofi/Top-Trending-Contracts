['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-09\n', '*/\n', '\n', 'pragma solidity >=0.7.0 <=0.8.4;\n', '// PoC Proof of Contribution\n', '// SPDX-License-Identifier: Unlicensed\n', 'contract Neuy {\n', '    string public name = "NEUY";\n', '    string public symbol = "NEUY";\n', '    string public standard = "NEUY Token v1.0";\n', '    uint256 public totalSupply = 72000000 * 10 ** 18;\n', '    uint public decimals = 18;\n', '    address payable public owner;\n', '    address payable public buOwner;\n', '    address payable public airdropOwner;\n', '    uint256 public minContributorBalance = 0;\n', '    string private rewardKeyId;\n', '    bool public pullEnabled = false;\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner || msg.sender == buOwner);\n', '        _;\n', '    }\n', '    \n', '    modifier allOwners() {\n', '        require(msg.sender == owner || msg.sender == buOwner || msg.sender == airdropOwner);\n', '        _;\n', '    }\n', '    \n', '    event Transfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _value\n', '    );\n', '    \n', '    // event for EVM logging\n', '    event OwnerSet(\n', '        address indexed oldOwner, \n', '        address indexed newOwner\n', '    );\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => string) private claimedRewards;\n', '    mapping(address => bool) private contributors;\n', '    mapping(address => string) private contributorsAddresses;\n', '    \n', '    constructor(address _buOwner) {\n', '        balanceOf[msg.sender] = 36000000 * 10 ** 18;\n', '        balanceOf[_buOwner] = 36000000 * 10 ** 18;\n', '        buOwner = payable(_buOwner);\n', '        owner = payable(msg.sender);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        // Prevent transfer to 0x0 address. Use burn() instead\n', '        require(_to != address(0x0));\n', '        \n', '        // Check for sufficent funds\n', "        require(balanceOf[msg.sender] >= _value, 'insufficent tokens');\n", '        \n', '        // Check for overflows\n', '        require(balanceOf[_to] + _value >= balanceOf[_to]);\n', '        \n', '        // Transfer\n', '        balanceOf[msg.sender] -= _value;\n', '        balanceOf[_to] += _value;\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowance[msg.sender][_spender] = _value;\n', '\n', '        emit Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        \n', '        // Sufficent funds\n', '        require(_value <= balanceOf[_from]);\n', '        \n', '        // Sufficent allowance\n', '        require(_value <= allowance[_from][msg.sender]);\n', '\n', '        // Transfer\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '\n', '        allowance[_from][msg.sender] -= _value;\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '    \n', '    // Change owner\n', '    function changeOwner(address newOwner) public onlyOwner {\n', '        emit OwnerSet(owner, newOwner);\n', '        owner = payable(newOwner);\n', '    }\n', '    \n', '    // Change backup owner\n', '    function changeBUOwner(address _buOwner) public onlyOwner {\n', '        require(_buOwner != address(0x0));\n', '        buOwner = payable(_buOwner);\n', '    }\n', '    \n', '    // Change airdrop owner\n', '    function changeAirDropOwner(address _airdropOwner) public onlyOwner {\n', '        require(_airdropOwner != address(0x0));\n', '        airdropOwner = payable(_airdropOwner);\n', '    }\n', '    \n', '    // Owner destories contract\n', '    function finalize() public onlyOwner payable {\n', '        selfdestruct(owner);\n', '    }\n', '    \n', '    // Add contributors\n', '    function addContributor(address _add, string memory _addS) public onlyOwner {\n', '        contributors[_add] = true;\n', '        contributorsAddresses[_add] = _addS;\n', '    }\n', '    \n', '    // Remove contributors\n', '    function removeContributor(address _add) public onlyOwner {\n', '        contributors[_add] = false;\n', '    }\n', '    \n', '    // Change minimum balance required by contributors\n', '    function changeMinBalance(uint256 _newMin) public onlyOwner {\n', '        minContributorBalance = _newMin * 10 ** 18;\n', '    }\n', '    \n', '    // Airdropping to contributors\n', '    function contributionAirDrop(address[] memory _to_list, uint[] memory _values) public allOwners payable {\n', '        require(_to_list.length < 100);\n', '        require(_to_list.length == _values.length); \n', '        \n', '        //Validate reward limit of 2000 * 100\n', '        uint totalReward = 0;\n', '        for (uint i = 0; i < _to_list.length; i++) {\n', '            totalReward += _values[i];\n', '        }\n', '        require(totalReward < 200001);\n', '        \n', '        for (uint i = 0; i < _to_list.length; i++) {\n', '            if (balanceOf[_to_list[i]] >= minContributorBalance) {\n', '                mintToken(_to_list[i], _values[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    // Private method shared by `contributionAirDrop()`.\n', '    function mintToken(address _to, uint _value) private {\n', '        require(_value < 66800); // No single contributor should be able to get more than\n', '        balanceOf[_to] += _value * 10 ** 16;\n', '        totalSupply += _value * 10 ** 16;\n', '        require(totalSupply < 144000000 * 10 ** 18);\n', '        require(balanceOf[_to] >= _value && totalSupply >= _value); // overflow checks\n', '        emit Transfer(address(0), _to, _value);\n', '    }\n', '    \n', '    // Set reward key and enable pull\n', '    function setRewardKey(string memory _rewardId) public onlyOwner {\n', '        pullEnabled = true;\n', '        rewardKeyId = _rewardId;\n', '    }\n', '    \n', '    // Change status of pull\n', '    function setPullStatus(bool _pullStatus) public onlyOwner {\n', '        pullEnabled = _pullStatus;\n', '    }\n', '\n', '    // Pull contribution reward\n', '    function claimContributionReward(bytes32 _rewardHash, uint _value) public payable {\n', '        \n', '        // Pull reward system must be pullEnabled\n', '        require(pullEnabled == true);\n', '        \n', '        // Verify not already claimed\n', '        string memory previousRewardId = claimedRewards[msg.sender];\n', '        string memory presentRewardId = rewardKeyId;\n', '        require(sha256(abi.encodePacked(previousRewardId)) != sha256(abi.encodePacked(rewardKeyId)));\n', '        \n', '        // Contributor hash validation\n', '        require(_rewardHash == keccak256(abi.encodePacked(rewardKeyId,uintToString(_value),contributorsAddresses[address(msg.sender)])));\n', '        \n', '        // Verify authorized contributor\n', '        require(contributors[msg.sender] == true);    \n', '\n', '        // Min contributor balance\n', '        require(balanceOf[msg.sender] >= minContributorBalance); \n', '        mintToken(msg.sender, _value);\n', '        claimedRewards[msg.sender] = presentRewardId;\n', '    }\n', '    \n', '    // Helper method to convert uint To string\n', '    function uintToString(uint _v) internal pure returns (string memory) {\n', '        uint maxlength = 100;\n', '        bytes memory reversed = new bytes(maxlength);\n', '        uint i = 0;\n', '        while (_v != 0) {\n', '            uint remainder = _v % 10;\n', '            _v = _v / 10;\n', '            reversed[i++] = bytes1(uint8(48 + remainder));\n', '        }\n', '        bytes memory s = new bytes(i); // i + 1 is inefficient\n', '        for (uint j = 0; j < i; j++) {\n', '            s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\n', '        }\n', "        string memory str = string(s);  // memory isn't implicitly convertible to storage\n", '        return str;\n', '    }\n', '}']