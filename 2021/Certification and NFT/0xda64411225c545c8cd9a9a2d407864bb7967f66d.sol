['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-12\n', '*/\n', '\n', '/// SPDX-License-Identifier: MIT\n', '/*\n', '▄▄█    ▄   ██   █▄▄▄▄ ▄█ \n', '██     █  █ █  █  ▄▀ ██ \n', '██ ██   █ █▄▄█ █▀▀▌  ██ \n', '▐█ █ █  █ █  █ █  █  ▐█ \n', ' ▐ █  █ █    █   █    ▐ \n', '   █   ██   █   ▀   \n', '           ▀          */\n', '/// Special thanks to Keno and Boring for reviewing early bridge patterns.\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '/// License-Identifier: MIT\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '/// @notice Interface for SushiSwap.\n', 'interface ISushiSwap {\n', '    function deposit() external payable; // wETH deposit\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '/// License-Identifier: MIT\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '/// License-Identifier: MIT\n', '\n', 'library BoringERC20 {\n', '    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n', '    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n', '    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n', '    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n', '    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n', '\n', '    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param from Transfer tokens from.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '/// @notice Contract that batches SUSHI staking and DeFi strategies.\n', 'contract Inari {\n', '    using BoringMath for uint256;\n', '    using BoringERC20 for IERC20;\n', '    \n', '    address constant wETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address constant sushiSwapFactory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac; // SushiSwap factory contract\n', '    ISushiSwap constant sushiSwapSushiWethPair = ISushiSwap(0x795065dCc9f64b5614C407a6EFDC400DA6221FB0); // \n', '    \n', '    function swap1() external payable {\n', '        (uint256 reserve0, uint256 reserve1, ) = sushiSwapSushiWethPair.getReserves();\n', '        uint256 amountInWithFee = msg.value.mul(997);\n', '        uint256 amountOut =\n', '            amountInWithFee.mul(reserve1) /\n', '            reserve0.mul(1000).add(amountInWithFee);\n', '        ISushiSwap(wETH).deposit{value: msg.value}();\n', '        IERC20(wETH).approve(address(sushiSwapSushiWethPair), msg.value);\n', '        IERC20(wETH).safeTransfer(address(sushiSwapSushiWethPair), msg.value);\n', '        sushiSwapSushiWethPair.swap(0, amountOut, msg.sender, "");\n', '    }\n', '    \n', '    function swap2() external payable {\n', '        (uint256 reserve0, uint256 reserve1, ) = sushiSwapSushiWethPair.getReserves();\n', '        uint256 amountInWithFee = msg.value.mul(997);\n', '        uint256 amountOut =\n', '            amountInWithFee.mul(reserve0) /\n', '            reserve1.mul(1000).add(amountInWithFee);\n', '        ISushiSwap(wETH).deposit{value: msg.value}();\n', '        IERC20(wETH).approve(address(sushiSwapSushiWethPair), msg.value);\n', '        IERC20(wETH).safeTransfer(address(sushiSwapSushiWethPair), msg.value);\n', '        sushiSwapSushiWethPair.swap(amountOut, 0, msg.sender, "");\n', '    }\n', '}']