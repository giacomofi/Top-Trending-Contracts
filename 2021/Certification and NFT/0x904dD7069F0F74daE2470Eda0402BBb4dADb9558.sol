['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', 'import "./StrongPoolInterface.sol";\n', 'import "./ServiceInterface.sol";\n', 'import "./rewards.sol";\n', '\n', 'contract VoteV3 {\n', '  event Voted(address indexed voter, address indexed service, address indexed entity, uint256 amount);\n', '  event RecalledVote(address indexed voter, address indexed service, address indexed entity, uint256 amount);\n', '  event Claimed(address indexed claimer, uint256 amount);\n', '  event VotesAdded(address indexed miner, uint256 amount);\n', '  event VotesSubtracted(address indexed miner, uint256 amount);\n', '  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n', '\n', '  using SafeMath for uint256;\n', '\n', '  StrongPoolInterface public strongPool;\n', '  IERC20 public strongToken;\n', '\n', '  bool public initDone;\n', '  address public admin;\n', '  address public pendingAdmin;\n', '  address public superAdmin;\n', '  address public pendingSuperAdmin;\n', '  address public parameterAdmin;\n', '\n', '  uint256 public rewardBalance;\n', '\n', '  uint256 public voterRewardPerBlockNumerator;\n', '  uint256 public voterRewardPerBlockDenominator;\n', '  uint256 public entityRewardPerBlockNumerator;\n', '  uint256 public entityRewardPerBlockDenominator;\n', '\n', '  mapping(address => uint96) public balances;\n', '  mapping(address => address) public delegates;\n', '\n', '  mapping(address => mapping(uint32 => uint32)) public checkpointsFromBlock;\n', '  mapping(address => mapping(uint32 => uint96)) public checkpointsVotes;\n', '  mapping(address => uint32) public numCheckpoints;\n', '\n', '  mapping(address => uint256) public voterVotesOut;\n', '  uint256 public totalVotesOut;\n', '\n', '  mapping(address => uint256) public serviceVotes;\n', '  mapping(address => mapping(address => uint256)) public serviceEntityVotes;\n', '  mapping(address => mapping(address => mapping(address => uint256))) public voterServiceEntityVotes;\n', '\n', '  mapping(address => address[]) public voterServices;\n', '  mapping(address => mapping(address => uint256)) public voterServiceIndex;\n', '\n', '  mapping(address => mapping(address => address[])) public voterServiceEntities;\n', '  mapping(address => mapping(address => mapping(address => uint256))) public voterServiceEntityIndex;\n', '\n', '  mapping(address => uint256) public voterBlockLastClaimedOn;\n', '  mapping(address => mapping(address => uint256)) public serviceEntityBlockLastClaimedOn;\n', '\n', '  address[] public serviceContracts;\n', '  mapping(address => uint256) public serviceContractIndex;\n', '  mapping(address => bool) public serviceContractActive;\n', '\n', '  uint256 public voterRewardPerBlockNumeratorNew;\n', '  uint256 public voterRewardPerBlockDenominatorNew;\n', '  uint256 public entityRewardPerBlockNumeratorNew;\n', '  uint256 public entityRewardPerBlockDenominatorNew;\n', '  uint256 public rewardPerBlockNewEffectiveBlock;\n', '\n', '  function init(\n', '    address strongTokenAddress,\n', '    address strongPoolAddress,\n', '    address adminAddress,\n', '    address superAdminAddress,\n', '    uint256 voterRewardPerBlockNumeratorValue,\n', '    uint256 voterRewardPerBlockDenominatorValue,\n', '    uint256 entityRewardPerBlockNumeratorValue,\n', '    uint256 entityRewardPerBlockDenominatorValue\n', '  ) public {\n', '    require(!initDone, "init done");\n', '    strongToken = IERC20(strongTokenAddress);\n', '    strongPool = StrongPoolInterface(strongPoolAddress);\n', '    admin = adminAddress;\n', '    superAdmin = superAdminAddress;\n', '    voterRewardPerBlockNumerator = voterRewardPerBlockNumeratorValue;\n', '    voterRewardPerBlockDenominator = voterRewardPerBlockDenominatorValue;\n', '    entityRewardPerBlockNumerator = entityRewardPerBlockNumeratorValue;\n', '    entityRewardPerBlockDenominator = entityRewardPerBlockDenominatorValue;\n', '    initDone = true;\n', '  }\n', '\n', '  // ADMIN\n', '  // *************************************************************************************\n', '  function updateParameterAdmin(address newParameterAdmin) public {\n', '    require(newParameterAdmin != address(0), "zero");\n', '    require(msg.sender == superAdmin);\n', '    parameterAdmin = newParameterAdmin;\n', '  }\n', '\n', '  function setPendingAdmin(address newPendingAdmin) public {\n', '    require(newPendingAdmin != address(0), "zero");\n', '    require(msg.sender == admin, "not admin");\n', '    pendingAdmin = newPendingAdmin;\n', '  }\n', '\n', '  function acceptAdmin() public {\n', '    require(msg.sender == pendingAdmin && msg.sender != address(0), "not pendingAdmin");\n', '    admin = pendingAdmin;\n', '    pendingAdmin = address(0);\n', '  }\n', '\n', '  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\n', '    require(newPendingSuperAdmin != address(0), "zero");\n', '    require(msg.sender == superAdmin, "not superAdmin");\n', '    pendingSuperAdmin = newPendingSuperAdmin;\n', '  }\n', '\n', '  function acceptSuperAdmin() public {\n', '    require(msg.sender == pendingSuperAdmin && msg.sender != address(0), "not pendingSuperAdmin");\n', '    superAdmin = pendingSuperAdmin;\n', '    pendingSuperAdmin = address(0);\n', '  }\n', '\n', '  // SERVICE CONTRACTS\n', '  // *************************************************************************************\n', '  function addServiceContract(address contr) public {\n', '    require(contr != address(0), "zero");\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, "not an admin");\n', '    if (serviceContracts.length != 0) {\n', '      uint256 index = serviceContractIndex[contr];\n', '      require(serviceContracts[index] != contr, "exists");\n', '    }\n', '    uint256 len = serviceContracts.length;\n', '    serviceContractIndex[contr] = len;\n', '    serviceContractActive[contr] = true;\n', '    serviceContracts.push(contr);\n', '  }\n', '\n', '  function updateServiceContractActiveStatus(address contr, bool activeStatus) public {\n', '    require(contr != address(0), "zero");\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, "not an admin");\n', '    require(serviceContracts.length > 0, "zero");\n', '    uint256 index = serviceContractIndex[contr];\n', '    require(serviceContracts[index] == contr, "not exists");\n', '    serviceContractActive[contr] = activeStatus;\n', '  }\n', '\n', '  function getServiceContracts() public view returns (address[] memory) {\n', '    return serviceContracts;\n', '  }\n', '\n', '  // REWARD\n', '  // *************************************************************************************\n', '  function updateVoterRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, "not an admin");\n', '    require(denominator != 0, "invalid value");\n', '    voterRewardPerBlockNumerator = numerator;\n', '    voterRewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function updateEntityRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, "not an admin");\n', '    require(denominator != 0, "invalid value");\n', '    entityRewardPerBlockNumerator = numerator;\n', '    entityRewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function deposit(uint256 amount) public {\n', '    require(msg.sender == superAdmin, "not an admin");\n', '    require(amount > 0, "zero");\n', '    strongToken.transferFrom(msg.sender, address(this), amount);\n', '    rewardBalance = rewardBalance.add(amount);\n', '  }\n', '\n', '  function withdraw(address destination, uint256 amount) public {\n', '    require(msg.sender == superAdmin, "not an admin");\n', '    require(amount > 0, "zero");\n', '    require(rewardBalance >= amount, "not enough");\n', '    strongToken.transfer(destination, amount);\n', '    rewardBalance = rewardBalance.sub(amount);\n', '  }\n', '\n', '  // CORE\n', '  // *************************************************************************************\n', '  function getVoterServices(address voter) public view returns (address[] memory) {\n', '    return voterServices[voter];\n', '  }\n', '\n', '  function getVoterServiceEntities(address voter, address service) public view returns (address[] memory) {\n', '    return voterServiceEntities[voter][service];\n', '  }\n', '\n', '  function getVoterReward(address voter) public view returns (uint256) {\n', '    uint256 blockLastClaimedOn = voterBlockLastClaimedOn[voter];\n', '\n', '    if (totalVotesOut == 0) return 0;\n', '    if (blockLastClaimedOn == 0) return 0;\n', '\n', '    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, block.number);\n', '    uint256 rewardOld = voterRewardPerBlockNumerator > 0 ? rewardBlocks[0].mul(voterRewardPerBlockNumerator).div(voterRewardPerBlockDenominator) : 0;\n', '    uint256 rewardNew = voterRewardPerBlockNumeratorNew > 0 ? rewardBlocks[1].mul(voterRewardPerBlockNumeratorNew).div(voterRewardPerBlockDenominatorNew) : 0;\n', '\n', '    return rewardOld.add(rewardNew).mul(voterVotesOut[voter]).div(totalVotesOut);\n', '  }\n', '\n', '  function getEntityReward(address service, address entity) public view returns (uint256) {\n', '    uint256 blockLastClaimedOn = serviceEntityBlockLastClaimedOn[service][entity];\n', '\n', '    if (serviceVotes[service] == 0) return 0;\n', '    if (blockLastClaimedOn == 0) return 0;\n', '\n', '    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, block.number);\n', '    uint256 rewardOld = entityRewardPerBlockNumerator > 0 ? rewardBlocks[0].mul(entityRewardPerBlockNumerator).div(entityRewardPerBlockDenominator) : 0;\n', '    uint256 rewardNew = entityRewardPerBlockNumeratorNew > 0 ? rewardBlocks[1].mul(entityRewardPerBlockNumeratorNew).div(entityRewardPerBlockDenominatorNew) : 0;\n', '\n', '    return rewardOld.add(rewardNew).mul(serviceEntityVotes[service][entity]).div(serviceVotes[service]);\n', '  }\n', '\n', '  function vote(\n', '    address service,\n', '    address entity,\n', '    uint256 amount\n', '  ) public {\n', '    require(amount > 0, "zero");\n', '    require(uint256(_getAvailableServiceEntityVotes(msg.sender)) >= amount, "not enough");\n', '    require(serviceContractActive[service], "service not active");\n', '    require(ServiceInterface(service).isEntityActive(entity), "entity not active");\n', '\n', '    uint256 serviceIndex = voterServiceIndex[msg.sender][service];\n', '    if (voterServices[msg.sender].length == 0 || voterServices[msg.sender][serviceIndex] != service) {\n', '      uint256 len = voterServices[msg.sender].length;\n', '      voterServiceIndex[msg.sender][service] = len;\n', '      voterServices[msg.sender].push(service);\n', '    }\n', '\n', '    uint256 entityIndex = voterServiceEntityIndex[msg.sender][service][entity];\n', '    if (\n', '      voterServiceEntities[msg.sender][service].length == 0 ||\n', '      voterServiceEntities[msg.sender][service][entityIndex] != entity\n', '    ) {\n', '      uint256 len = voterServiceEntities[msg.sender][service].length;\n', '      voterServiceEntityIndex[msg.sender][service][entity] = len;\n', '      voterServiceEntities[msg.sender][service].push(entity);\n', '    }\n', '\n', '    if (block.number > voterBlockLastClaimedOn[msg.sender]) {\n', '      uint256 reward = getVoterReward(msg.sender);\n', '      if (reward > 0) {\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        strongToken.approve(address(strongPool), reward);\n', '        strongPool.mineFor(msg.sender, reward);\n', '        voterBlockLastClaimedOn[msg.sender] = block.number;\n', '      }\n', '    }\n', '\n', '    if (block.number > serviceEntityBlockLastClaimedOn[service][entity]) {\n', '      uint256 reward = getEntityReward(service, entity);\n', '      if (reward > 0) {\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        strongToken.approve(address(strongPool), reward);\n', '        strongPool.mineFor(entity, reward);\n', '        serviceEntityBlockLastClaimedOn[service][entity] = block.number;\n', '      }\n', '    }\n', '\n', '    serviceVotes[service] = serviceVotes[service].add(amount);\n', '    serviceEntityVotes[service][entity] = serviceEntityVotes[service][entity].add(amount);\n', '    voterServiceEntityVotes[msg.sender][service][entity] = voterServiceEntityVotes[msg.sender][service][entity].add(\n', '      amount\n', '    );\n', '\n', '    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].add(amount);\n', '    totalVotesOut = totalVotesOut.add(amount);\n', '\n', '    if (voterBlockLastClaimedOn[msg.sender] == 0) {\n', '      voterBlockLastClaimedOn[msg.sender] = block.number;\n', '    }\n', '\n', '    if (serviceEntityBlockLastClaimedOn[service][entity] == 0) {\n', '      serviceEntityBlockLastClaimedOn[service][entity] = block.number;\n', '    }\n', '\n', '    emit Voted(msg.sender, service, entity, amount);\n', '  }\n', '\n', '  function recallVote(\n', '    address service,\n', '    address entity,\n', '    uint256 amount\n', '  ) public {\n', '    require(amount > 0, "zero");\n', '    require(voterServiceEntityVotes[msg.sender][service][entity] >= amount, "not enough");\n', '\n', '    if (block.number > voterBlockLastClaimedOn[msg.sender]) {\n', '      uint256 reward = getVoterReward(msg.sender);\n', '      if (reward > 0) {\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        strongToken.approve(address(strongPool), reward);\n', '        strongPool.mineFor(msg.sender, reward);\n', '        voterBlockLastClaimedOn[msg.sender] = block.number;\n', '      }\n', '    }\n', '\n', '    if (block.number > serviceEntityBlockLastClaimedOn[service][entity]) {\n', '      uint256 reward = getEntityReward(service, entity);\n', '      if (reward > 0) {\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        strongToken.approve(address(strongPool), reward);\n', '        strongPool.mineFor(entity, reward);\n', '        serviceEntityBlockLastClaimedOn[service][entity] = block.number;\n', '      }\n', '    }\n', '\n', '    serviceVotes[service] = serviceVotes[service].sub(amount);\n', '    serviceEntityVotes[service][entity] = serviceEntityVotes[service][entity].sub(amount);\n', '    voterServiceEntityVotes[msg.sender][service][entity] = voterServiceEntityVotes[msg.sender][service][entity].sub(\n', '      amount\n', '    );\n', '\n', '    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].sub(amount);\n', '    totalVotesOut = totalVotesOut.sub(amount);\n', '\n', '    if (voterVotesOut[msg.sender] == 0) {\n', '      voterBlockLastClaimedOn[msg.sender] = 0;\n', '    }\n', '\n', '    if (serviceEntityVotes[service][entity] == 0) {\n', '      serviceEntityBlockLastClaimedOn[service][entity] = 0;\n', '    }\n', '    emit RecalledVote(msg.sender, service, entity, amount);\n', '  }\n', '\n', '  function voterClaim() public {\n', '    require(voterBlockLastClaimedOn[msg.sender] != 0, "error");\n', '    require(block.number > voterBlockLastClaimedOn[msg.sender], "too soon");\n', '    uint256 reward = getVoterReward(msg.sender);\n', '    require(reward > 0, "no reward");\n', '    rewardBalance = rewardBalance.sub(reward);\n', '    strongToken.approve(address(strongPool), reward);\n', '    strongPool.mineFor(msg.sender, reward);\n', '    voterBlockLastClaimedOn[msg.sender] = block.number;\n', '    emit Claimed(msg.sender, reward);\n', '  }\n', '\n', '  function entityClaim(address service) public {\n', '    require(serviceEntityBlockLastClaimedOn[service][msg.sender] != 0, "error");\n', '    require(block.number > serviceEntityBlockLastClaimedOn[service][msg.sender], "too soon");\n', '    require(ServiceInterface(service).isEntityActive(msg.sender), "not active");\n', '    uint256 reward = getEntityReward(service, msg.sender);\n', '    require(reward > 0, "no reward");\n', '    rewardBalance = rewardBalance.sub(reward);\n', '    strongToken.approve(address(strongPool), reward);\n', '    strongPool.mineFor(msg.sender, reward);\n', '    serviceEntityBlockLastClaimedOn[service][msg.sender] = block.number;\n', '    emit Claimed(msg.sender, reward);\n', '  }\n', '\n', '  function updateVotes(\n', '    address voter,\n', '    uint256 rawAmount,\n', '    bool adding\n', '  ) public {\n', '    require(msg.sender == address(strongPool), "not strongPool");\n', '    uint96 amount = _safe96(rawAmount, "amount exceeds 96 bits");\n', '    if (adding) {\n', '      _addVotes(voter, amount);\n', '    } else {\n', '      require(_getAvailableServiceEntityVotes(voter) >= amount, "recall votes");\n', '      _subVotes(voter, amount);\n', '    }\n', '  }\n', '\n', '  function getCurrentProposalVotes(address account) external view returns (uint96) {\n', '    return _getCurrentProposalVotes(account);\n', '  }\n', '\n', '  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96) {\n', '    require(blockNumber < block.number, "not yet determined");\n', '    uint32 nCheckpoints = numCheckpoints[account];\n', '    if (nCheckpoints == 0) {\n', '      return 0;\n', '    }\n', '    if (checkpointsFromBlock[account][nCheckpoints - 1] <= blockNumber) {\n', '      return checkpointsVotes[account][nCheckpoints - 1];\n', '    }\n', '    if (checkpointsFromBlock[account][0] > blockNumber) {\n', '      return 0;\n', '    }\n', '    uint32 lower = 0;\n', '    uint32 upper = nCheckpoints - 1;\n', '    while (upper > lower) {\n', '      uint32 center = upper - (upper - lower) / 2;\n', '      uint32 fromBlock = checkpointsFromBlock[account][center];\n', '      uint96 votes = checkpointsVotes[account][center];\n', '      if (fromBlock == blockNumber) {\n', '        return votes;\n', '      } else if (fromBlock < blockNumber) {\n', '        lower = center;\n', '      } else {\n', '        upper = center - 1;\n', '      }\n', '    }\n', '    return checkpointsVotes[account][lower];\n', '  }\n', '\n', '  function getAvailableServiceEntityVotes(address account) public view returns (uint96) {\n', '    return _getAvailableServiceEntityVotes(account);\n', '  }\n', '\n', '  // SUPPORT\n', '  // *************************************************************************************\n', '  function _addVotes(address voter, uint96 amount) internal {\n', '    require(voter != address(0), "zero address");\n', '    balances[voter] = _add96(balances[voter], amount, "vote amount overflows");\n', '    _addDelegates(voter, amount);\n', '    emit VotesAdded(voter, amount);\n', '  }\n', '\n', '  function _subVotes(address voter, uint96 amount) internal {\n', '    balances[voter] = _sub96(balances[voter], amount, "vote amount exceeds balance");\n', '    _subtractDelegates(voter, amount);\n', '    emit VotesSubtracted(voter, amount);\n', '  }\n', '\n', '  function _addDelegates(address miner, uint96 amount) internal {\n', '    if (delegates[miner] == address(0)) {\n', '      delegates[miner] = miner;\n', '    }\n', '    address currentDelegate = delegates[miner];\n', '    _moveDelegates(address(0), currentDelegate, amount);\n', '  }\n', '\n', '  function _subtractDelegates(address miner, uint96 amount) internal {\n', '    address currentDelegate = delegates[miner];\n', '    _moveDelegates(currentDelegate, address(0), amount);\n', '  }\n', '\n', '  function _moveDelegates(\n', '    address srcRep,\n', '    address dstRep,\n', '    uint96 amount\n', '  ) internal {\n', '    if (srcRep != dstRep && amount > 0) {\n', '      if (srcRep != address(0)) {\n', '        uint32 srcRepNum = numCheckpoints[srcRep];\n', '        uint96 srcRepOld = srcRepNum > 0 ? checkpointsVotes[srcRep][srcRepNum - 1] : 0;\n', '        uint96 srcRepNew = _sub96(srcRepOld, amount, "vote amount underflows");\n', '        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n', '      }\n', '      if (dstRep != address(0)) {\n', '        uint32 dstRepNum = numCheckpoints[dstRep];\n', '        uint96 dstRepOld = dstRepNum > 0 ? checkpointsVotes[dstRep][dstRepNum - 1] : 0;\n', '        uint96 dstRepNew = _add96(dstRepOld, amount, "vote amount overflows");\n', '        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n', '      }\n', '    }\n', '  }\n', '\n', '  function _writeCheckpoint(\n', '    address delegatee,\n', '    uint32 nCheckpoints,\n', '    uint96 oldVotes,\n', '    uint96 newVotes\n', '  ) internal {\n', '    uint32 blockNumber = _safe32(block.number, "block number exceeds 32 bits");\n', '    if (nCheckpoints > 0 && checkpointsFromBlock[delegatee][nCheckpoints - 1] == blockNumber) {\n', '      checkpointsVotes[delegatee][nCheckpoints - 1] = newVotes;\n', '    } else {\n', '      checkpointsFromBlock[delegatee][nCheckpoints] = blockNumber;\n', '      checkpointsVotes[delegatee][nCheckpoints] = newVotes;\n', '      numCheckpoints[delegatee] = nCheckpoints + 1;\n', '    }\n', '\n', '    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n', '  }\n', '\n', '  function _safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n', '    require(n < 2**32, errorMessage);\n', '    return uint32(n);\n', '  }\n', '\n', '  function _safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n', '    require(n < 2**96, errorMessage);\n', '    return uint96(n);\n', '  }\n', '\n', '  function _add96(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    uint96 c = a + b;\n', '    require(c >= a, errorMessage);\n', '    return c;\n', '  }\n', '\n', '  function _sub96(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    require(b <= a, errorMessage);\n', '    return a - b;\n', '  }\n', '\n', '  function _getCurrentProposalVotes(address account) internal view returns (uint96) {\n', '    uint32 nCheckpoints = numCheckpoints[account];\n', '    return nCheckpoints > 0 ? checkpointsVotes[account][nCheckpoints - 1] : 0;\n', '  }\n', '\n', '  function _getAvailableServiceEntityVotes(address account) internal view returns (uint96) {\n', '    uint96 proposalVotes = _getCurrentProposalVotes(account);\n', '    return proposalVotes == 0 ? 0 : proposalVotes - _safe96(voterVotesOut[account], "voterVotesOut exceeds 96 bits");\n', '  }\n', '\n', '  function updateRewardPerBlockNew(\n', '    uint256 numeratorVoter,\n', '    uint256 denominatorVoter,\n', '    uint256 numeratorEntity,\n', '    uint256 denominatorEntity,\n', '    uint256 effectiveBlock\n', '  ) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    voterRewardPerBlockNumeratorNew = numeratorVoter;\n', '    voterRewardPerBlockDenominatorNew = denominatorVoter;\n', '    entityRewardPerBlockNumeratorNew = numeratorEntity;\n', '    entityRewardPerBlockDenominatorNew = denominatorEntity;\n', '    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\n', '  }\n', '}']