['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-02\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.6;\n', '\n', 'library Math {\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function decimals() external view returns (uint256);\n', '    function symbol() external view returns (string memory);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface Oracle {\n', '    struct ReferenceData {\n', '        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n', '        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n', '        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n', '    }\n', '    \n', '    function getReferenceData(string memory _base, string memory _quote)\n', '        external\n', '        view\n', '        returns (ReferenceData memory);\n', '}\n', '\n', 'interface cToken {\n', '    function underlying() external view returns (address);\n', '}\n', '\n', 'interface comptroller {\n', '    function getAllMarkets() external view returns (address[] memory);\n', '    function markets(address _market) external view returns (bool isListed, uint256 collateralFactorMantissa, bool isComped);\n', '}\n', '\n', 'interface ibtroller {\n', '    function getAllMarkets() external view returns (address[] memory);\n', '    function markets(address _market) external view returns (bool isListed, uint256 collateralFactorMantissa);\n', '}\n', '\n', 'interface aavecore {\n', '    struct ReserveConfigurationMap {\n', '        //bit 0-15: LTV\n', '        //bit 16-31: Liq. threshold\n', '        //bit 32-47: Liq. bonus\n', '        //bit 48-55: Decimals\n', '        //bit 56: Reserve is active\n', '        //bit 57: reserve is frozen\n', '        //bit 58: borrowing is enabled\n', '        //bit 59: stable rate borrowing enabled\n', '        //bit 60-63: reserved\n', '        //bit 64-79: reserve factor\n', '        uint256 data;\n', '    }\n', '    function getReserveConfiguration(address _market) external view returns (uint, uint, uint, bool);\n', '    function getConfiguration(address _market) external view returns (ReserveConfigurationMap memory);\n', '}\n', '\n', 'interface vaultparams {\n', '    function initialCollateralRatio(address _token) external view returns (uint);\n', '}\n', '\n', 'interface SushiswapV2Router02 {\n', '    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'contract FixedUSD {\n', '    string public constant name = "Fixed USD";\n', '    string public constant symbol = "USDF";\n', '    uint8 public constant decimals = 18;\n', '    \n', '    address constant _oracle = 0xDA7a001b254CD22e46d3eAB04d937489c93174C3;\n', '    address constant _stable = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    address constant _router = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n', '    string constant _quote = "USD";\n', '    \n', '    uint constant _BASE = 100;\n', '    uint constant _LIQUIDITY_THRESHOLD = 5;\n', '    uint constant _LIQUIDATION_VALUE = 90;\n', '    uint constant _CACHE = 1 days;\n', '    uint constant _minLiquidity = 500000e18;\n', '    \n', '    /// @notice Total number of tokens in circulation\n', '    uint public totalSupply = 0;\n', '    \n', '    mapping(address => mapping (address => uint)) internal allowances;\n', '    mapping(address => uint) internal balances;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event Approval(address indexed owner, address indexed spender, uint amount);\n', '    \n', '    mapping(address => mapping(address => uint)) public credit;\n', '    mapping(address => mapping(address => uint)) public collateral;\n', '    \n', '    mapping(address => uint) public credits;\n', '    mapping(address => uint) public collaterals;\n', '    \n', '    mapping(address => uint) public ltvs;\n', '    mapping(address => uint) _ltvCaches;\n', '    \n', '    mapping(address => uint) public liquidities;\n', '    mapping(address => uint) _liquidityCaches;\n', '    \n', '    mapping(address => uint) public fallbackQuote;\n', '    \n', '    uint public arb;\n', '    \n', '    event Mint(address indexed from, address indexed asset, address indexed to, uint amount);\n', '    event Burn(address indexed from, address indexed asset, address indexed to, uint amount);\n', '    event Liquidate(address indexed from, address indexed asset, address indexed to, uint amount);\n', '    \n', '    \n', '    function validateLTV(uint __ltv) public pure returns (bool) {\n', '        if ((__ltv == 60) || (__ltv == 65) || (__ltv == 70) || (__ltv == 75)) {\n', '            return true;\n', '        } else if ((__ltv == 80) || (__ltv == 85) || __ltv >= 90) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function gentleRepaymentCalculator(uint __ltv, uint debt, uint value) public pure returns (uint repayment) {\n', '        if (__ltv == 60) {\n', '            return Math.min((debt - value) * 310 / _BASE, debt);\n', '        } else if (__ltv == 65) {\n', '            return Math.min((debt - value) * 370 / _BASE, debt);\n', '        } else if (__ltv == 70) {\n', '            return Math.min((debt - value) * 460 / _BASE, debt);\n', '        } else if (__ltv == 75) {\n', '            return Math.min((debt - value) * 610 / _BASE, debt);\n', '        } else if (__ltv == 80) {\n', '            return Math.min((debt - value) * 910 / _BASE, debt);\n', '        } else if (__ltv == 85) {\n', '            return Math.min((debt - value) * 1810 / _BASE, debt);\n', '        } else if (__ltv >= 90) {\n', '            return debt;\n', '        }\n', '    }\n', '    \n', '    function _lookup(address quoted, uint amount) internal returns (uint) {\n', '        uint _quoted = Oracle(_oracle).getReferenceData(IERC20(quoted).symbol(), _quote).rate;\n', '        if (_quoted == 0 && fallbackQuote[quoted] != 0) {\n', '            _quoted = fallbackQuote[quoted];\n', '        } else {\n', '            fallbackQuote[quoted] = _quoted;\n', '        }\n', '        return  _quoted * (amount * _ltv(quoted) / _BASE) / 10 ** IERC20(quoted).decimals();\n', '    }\n', '    \n', '    function lookup(address quoted, uint amount) public view returns (uint) {\n', '        uint _quoted = Oracle(_oracle).getReferenceData(IERC20(quoted).symbol(), _quote).rate;\n', '        if (_quoted == 0 && fallbackQuote[quoted] != 0) {\n', '            _quoted = fallbackQuote[quoted];\n', '        }\n', '        return _quoted * (amount * ltvs[quoted] / _BASE) / 10 ** IERC20(quoted).decimals();\n', '    }\n', '    \n', '    function lookup(address quoted) external view returns (uint) {\n', '        return Oracle(_oracle).getReferenceData(IERC20(quoted).symbol(), _quote).rate;\n', '    }\n', '    \n', '    function lookupLiq(address quoted, uint amount) public view returns (uint) {\n', '        return Oracle(_oracle).getReferenceData(IERC20(quoted).symbol(), _quote).rate * (amount * _LIQUIDATION_VALUE / _BASE) / 10 ** IERC20(quoted).decimals();\n', '    }\n', '    \n', '    function mintArb(uint amount) external {\n', '        _mintArb(amount, msg.sender);\n', '    }\n', '    \n', '    function mintArb(uint amount, address recipient) external {\n', '        _mintArb(amount, recipient);\n', '    }\n', '    \n', '    function _mintArb(uint amount, address recipient) internal {\n', '        _safeTransferFrom(_stable, msg.sender, address(this), amount);\n', '        _mint(recipient, amount);\n', '        arb += amount;\n', '        emit Mint(msg.sender, _stable, recipient, amount);\n', '    }\n', '    \n', '    function burnArb(uint amount) external {\n', '        _burnArb(amount, msg.sender);\n', '    }\n', '    \n', '    function burnArb(uint amount, address recipient) external {\n', '        _burnArb(amount, recipient);\n', '    }\n', '    \n', '    function _burnArb(uint amount, address recipient) internal {\n', '        _burn(msg.sender, amount);\n', '        _safeTransfer(_stable, recipient, amount);\n', '        arb -= amount;\n', '        emit Burn(msg.sender, _stable, recipient, amount);\n', '    }\n', '    \n', '    function mint(address asset, uint amount, uint minted) external {\n', '        _mint(asset, amount, minted, msg.sender);\n', '    }\n', '    \n', '    function mint(address asset, uint amount, uint minted, address recipient) external {\n', '        _mint(asset, amount, minted, recipient);\n', '    }\n', '    \n', '    function _mint(address asset, uint amount, uint minted, address recipient) internal {\n', '        if (amount > 0) {\n', '            _safeTransferFrom(asset, msg.sender, address(this), amount);\n', '        }\n', '        \n', '        collateral[msg.sender][asset] += amount;\n', '        collaterals[asset] += amount;\n', '        \n', '        credit[msg.sender][asset] += minted;\n', '        credits[asset] += minted;\n', '        \n', '        require(_liquidity(asset, collaterals[asset]) >= credits[asset]);\n', '        require(_lookup(asset, collateral[msg.sender][asset]) >= credit[msg.sender][asset]);\n', '        _mint(recipient, minted);\n', '        emit Mint(msg.sender, asset, recipient, amount);\n', '    }\n', '    \n', '    function burn(address asset, uint amount, uint burned) external {\n', '        _burn(asset, amount, burned, msg.sender);\n', '    }\n', '    \n', '    function burn(address asset, uint amount, uint burned, address recipient) external {\n', '        _burn(asset, amount, burned, recipient);\n', '    }\n', '    \n', '    function _burn(address asset, uint amount, uint burned, address recipient) internal {\n', '        _burn(msg.sender, burned);\n', '        \n', '        credit[msg.sender][asset] -= burned;\n', '        credits[asset] -= burned;\n', '        collateral[msg.sender][asset] -= amount;\n', '        collaterals[asset] -= amount;\n', '        \n', '        require(lookup(asset, collateral[msg.sender][asset]) >= credit[msg.sender][asset]);\n', '        \n', '        if (amount > 0) {\n', '            _safeTransfer(asset, recipient, amount);\n', '        }\n', '        emit Burn(msg.sender, asset, recipient, amount);\n', '    }\n', '    \n', '    function repaymentCalculator(address owner, address asset) external view returns (uint) {\n', '        uint _nominal = collateral[owner][asset];\n', '        \n', '        uint _backed = lookup(asset, _nominal);\n', '        uint _debt = credit[owner][asset];\n', '        if (_backed < _debt) {\n', '            return gentleRepaymentCalculator(ltvs[asset], _debt, _backed);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function paymentCalculator(address owner, address asset) external view returns (uint) {\n', '        uint _nominal = collateral[owner][asset];\n', '        \n', '        uint _backed = lookup(asset, _nominal);\n', '        uint _debt = credit[owner][asset];\n', '        if (_backed < _debt) {\n', '            uint _repayment = gentleRepaymentCalculator(ltvs[asset], _debt, _backed);\n', '            return Math.min(_nominal * _repayment / lookupLiq(asset, _nominal), _nominal);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function liquidate(address owner, address asset, uint max) external {\n', '        uint _nominal = collateral[owner][asset];\n', '        \n', '        uint _backed = _lookup(asset, _nominal);\n', '        uint _debt = credit[owner][asset];\n', '        require(_backed < _debt);\n', '        \n', '        uint _repayment = gentleRepaymentCalculator(_ltv(asset), _debt, _backed);\n', '        require(_repayment <= max);\n', '        uint _payment = Math.min(_nominal * _repayment / lookupLiq(asset, _nominal), _nominal);\n', '        \n', '        _burn(msg.sender, _repayment);\n', '        \n', '        credit[owner][asset] -= _repayment;\n', '        credits[asset] -= _repayment;\n', '        collateral[owner][asset] -= _payment;\n', '        collaterals[asset] -= _payment;\n', '        \n', '        require(_lookup(asset, collateral[owner][asset]) >= credit[owner][asset]);\n', '        \n', '        _safeTransfer(asset, msg.sender, _payment);\n', '        emit Liquidate(msg.sender, asset, owner, _repayment);\n', '    }\n', '    \n', '    function _mint(address dst, uint amount) internal {\n', '        // mint the amount\n', '        totalSupply += amount;\n', '        // transfer the amount to the recipient\n', '        balances[dst] += amount;\n', '        emit Transfer(address(0), dst, amount);\n', '    }\n', '    \n', '    function _burn(address dst, uint amount) internal {\n', '        // burn the amount\n', '        totalSupply -= amount;\n', '        // transfer the amount from the recipient\n', '        balances[dst] -= amount;\n', '        emit Transfer(dst, address(0), amount);\n', '    }\n', '    \n', '    function allowance(address account, address spender) external view returns (uint) {\n', '        return allowances[account][spender];\n', '    }\n', '\n', '    function approve(address spender, uint amount) external returns (bool) {\n', '        allowances[msg.sender][spender] = amount;\n', '\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address account) external view returns (uint) {\n', '        return balances[account];\n', '    }\n', '\n', '    function transfer(address dst, uint amount) external returns (bool) {\n', '        _transferTokens(msg.sender, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n', '        address spender = msg.sender;\n', '        uint spenderAllowance = allowances[src][spender];\n', '\n', '        if (spender != src && spenderAllowance != type(uint).max) {\n', '            uint newAllowance = spenderAllowance - amount;\n', '            allowances[src][spender] = newAllowance;\n', '\n', '            emit Approval(src, spender, newAllowance);\n', '        }\n', '\n', '        _transferTokens(src, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    function _transferTokens(address src, address dst, uint amount) internal {\n', '        balances[src] -= amount;\n', '        balances[dst] += amount;\n', '        \n', '        emit Transfer(src, dst, amount);\n', '    }\n', '    \n', '    function _safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))));\n', '    }\n', '    \n', '    function _safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))));\n', '    }\n', '    \n', '    address constant _aavev2 = address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n', '    address constant _ib = address(0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB);\n', '    address constant _unit = address(0x203153522B9EAef4aE17c6e99851EE7b2F7D312E);\n', '    address constant _weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    \n', '    uint256 constant _LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000;\n', '    \n', '    function _getParamsMemory(aavecore.ReserveConfigurationMap memory self) internal pure returns (uint256) { \n', '        return (self.data & ~_LTV_MASK);\n', '    }\n', '    \n', '    function _lookupMarket(address _core, address _token) internal view returns (address) {\n', '        address[] memory _list = comptroller(_core).getAllMarkets();\n', '        for (uint i = 0; i < _list.length; i++) {\n', '            if (_list[i] != address(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) && _list[i] != address(0xD06527D5e56A3495252A528C4987003b712860eE)) {\n', '                if (cToken(_list[i]).underlying() == _token) {\n', '                    return _list[i];\n', '                }\n', '            }\n', '        }\n', '        return address(0x0);\n', '    }\n', '    \n', '    function _liquidityV(address token, uint amount) internal view returns (uint, bool) {\n', '        if (block.timestamp > _liquidityCaches[token]) {\n', '            if (token == _weth) {\n', '                return (_liquidityVWETH(amount), true);\n', '            } else {\n', '                address[] memory _path = new address[](3);\n', '                _path[0] = token;\n', '                _path[1] = _weth;\n', '                _path[2] = _stable;\n', '                uint _liq = SushiswapV2Router02(_router).getAmountsOut(amount, _path)[2];\n', '                uint _liquid = liquidities[token];\n', '                if (_liq > _liquid) {\n', '                    _liquid += _liquid * _LIQUIDITY_THRESHOLD / _BASE;\n', '                    _liq = Math.min(_liq, _liquid);\n', '                    _liq = _liq < _minLiquidity ? _minLiquidity : _liq;\n', '                }\n', '                return (_liq, true);\n', '            }\n', '        } else {\n', '            return (liquidities[token], false);\n', '        }\n', '    }\n', '    \n', '    function _liquidityVWETH(uint amount) internal view returns (uint) {\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = _weth;\n', '        _path[1] = _stable;\n', '        uint _liq = SushiswapV2Router02(_router).getAmountsOut(amount, _path)[1];\n', '        uint _liquid = liquidities[_weth];\n', '        if (_liq > _liquid) {\n', '            _liquid += _liquid * _LIQUIDITY_THRESHOLD / _BASE;\n', '            _liq = Math.min(_liq, _liquid);\n', '            _liq = _liq < _minLiquidity ? _minLiquidity : _liq;\n', '        }\n', '        return _liq;\n', '    }\n', '    \n', '    function _liquidity(address token, uint amount) internal returns (uint) {\n', '        if (_liquidityCaches[token] == 0) {\n', '            liquidities[token] = _minLiquidity;\n', '        }\n', '        (uint _val, bool _updated) = _liquidityV(token, amount);\n', '        if (_updated) {\n', '            _liquidityCaches[token] = block.timestamp + _CACHE;\n', '            liquidities[token] = _val;\n', '        }\n', '        return _val;\n', '    }\n', '    \n', '    function liquidity(address token, uint amount) external view returns (uint val) {\n', '        (val,) = _liquidityV(token, amount);\n', '    }\n', '    \n', '    function _getLTVIB(address token) internal view returns (uint ib) {\n', '        (,ib) = ibtroller(_ib).markets(_lookupMarket(_ib, token));\n', '        ib = ib / 1e16;\n', '    }\n', '    \n', '    function _getLTVUnit(address _token) internal view returns (uint unit) {\n', '        unit = vaultparams(_unit).initialCollateralRatio(_token);\n', '    }\n', '    \n', '    function _getLTVAaveV2(address token) internal view returns (uint aavev2) {\n', '        (aavev2) = _getParamsMemory(aavecore(_aavev2).getConfiguration(token));\n', '        aavev2 = aavev2 / 1e2;\n', '    }\n', '    \n', '    function _ltv(address token) internal returns (uint) {\n', '        (uint _val, bool _updated) = _ltvV(token);\n', '        if (_updated) {\n', '            _ltvCaches[token] = block.timestamp + _CACHE;\n', '            ltvs[token] = _val;\n', '        }\n', '        return _val;\n', '    }\n', '    \n', '    function ltv(address token) external view returns (uint val) {\n', '        (val,) = _ltvV(token);\n', '    }\n', '    \n', '    function _ltvV(address token) internal view returns (uint, bool) {\n', '        if (block.timestamp > _ltvCaches[token]) {\n', '            uint _max = 0;\n', '            uint _tmp =  _getLTVIB(token);\n', '            if (_tmp > _max) {\n', '                _max = _tmp;\n', '            }\n', '            _tmp = _getLTVAaveV2(token);\n', '            if (_tmp > _max) {\n', '                _max = _tmp;\n', '            }\n', '            _tmp = _getLTVUnit(token);\n', '            if (_tmp > _max) {\n', '                _max = _tmp;\n', '            }\n', '            _max = _max / 5 * 5;\n', '            if (_max < 60) {\n', '                _max = 0;\n', '            }\n', '            return (_max, true);\n', '        } else {\n', '            return (ltvs[token], false);\n', '        }\n', '    }\n', '}']