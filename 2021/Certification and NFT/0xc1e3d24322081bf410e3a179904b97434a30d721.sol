['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// File: contracts\\modules\\SafeInt256.sol\n', '\n', 'pragma solidity =0.5.16;\n', 'library SafeInt256 {\n', '    function add(int256 x, int256 y) internal pure returns (int256 z) {\n', "        require(((z = x + y) >= x) == (y >= 0), 'SafeInt256: addition overflow');\n", '    }\n', '\n', '    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n', "        require(((z = x - y) <= x) == (y >= 0), 'SafeInt256: substraction underflow');\n", '    }\n', '\n', '    function mul(int256 x, int256 y) internal pure returns (int256 z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'SafeInt256: multiplication overflow');\n", '    }\n', '}\n', '\n', '// File: contracts\\modules\\SafeMath.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'SafeMath: addition overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'SafeMath: substraction underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'SafeMath: multiplication overflow');\n", '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\IERC20.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\AddressWhiteList.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a whitelist filters a eligible address.\n', '     */\n', 'contract AddressWhiteList is Halt {\n', '\n', '    using whiteListAddress for address[];\n', '    uint256 constant internal allPermission = 0xffffffff;\n', '    uint256 constant internal allowBuyOptions = 1;\n', '    uint256 constant internal allowSellOptions = 1<<1;\n', '    uint256 constant internal allowExerciseOptions = 1<<2;\n', '    uint256 constant internal allowAddCollateral = 1<<3;\n', '    uint256 constant internal allowRedeemCollateral = 1<<4;\n', '    // The eligible adress list\n', '    address[] internal whiteList;\n', '    mapping(address => uint256) internal addressPermission;\n', '    /**\n', '     * @dev Implementation of add an eligible address into the whitelist.\n', '     * @param addAddress new eligible address.\n', '     */\n', '    function addWhiteList(address addAddress)public onlyOwner{\n', '        whiteList.addWhiteListAddress(addAddress);\n', '        addressPermission[addAddress] = allPermission;\n', '    }\n', '    function modifyPermission(address addAddress,uint256 permission)public onlyOwner{\n', '        addressPermission[addAddress] = permission;\n', '    }\n', '    /**\n', '     * @dev Implementation of revoke an invalid address from the whitelist.\n', '     * @param removeAddress revoked address.\n', '     */\n', '    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\n', '        addressPermission[removeAddress] = 0;\n', '        return whiteList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of getting the eligible whitelist.\n', '     */\n', '    function getWhiteList()public view returns (address[] memory){\n', '        return whiteList;\n', '    }\n', '    /**\n', '     * @dev Implementation of testing whether the input address is eligible.\n', '     * @param tmpAddress input address for testing.\n', '     */    \n', '    function isEligibleAddress(address tmpAddress) public view returns (bool){\n', '        return whiteList.isEligibleAddress(tmpAddress);\n', '    }\n', '    function checkAddressPermission(address tmpAddress,uint256 state) public view returns (bool){\n', '        return  (addressPermission[tmpAddress]&state) == state;\n', '    }\n', '    modifier addressPermissionAllowed(address tmpAddress,uint256 state){\n', '        require(checkAddressPermission(tmpAddress,state) , "Input address is not allowed");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts\\OptionsPool\\IOptionsPool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IOptionsPool {\n', '//    function getOptionBalances(address user) external view returns(uint256[]);\n', '\n', '    function getExpirationList()external view returns (uint32[] memory);\n', '    function createOptions(address from,address settlement,uint256 type_ly_expiration,\n', '        uint128 strikePrice,uint128 underlyingPrice,uint128 amount,uint128 settlePrice) external returns(uint256);\n', '    function setSharedState(uint256 newFirstOption,int256[] calldata latestNetWorth,address[] calldata whiteList) external;\n', '    function getAllTotalOccupiedCollateral() external view returns (uint256,uint256);\n', '    function getCallTotalOccupiedCollateral() external view returns (uint256);\n', '    function getPutTotalOccupiedCollateral() external view returns (uint256);\n', '    function getTotalOccupiedCollateral() external view returns (uint256);\n', '//    function buyOptionCheck(uint32 expiration,uint32 underlying)external view;\n', '    function burnOptions(address from,uint256 id,uint256 amount,uint256 optionPrice)external;\n', '    function getOptionsById(uint256 optionsId)external view returns(uint256,address,uint8,uint32,uint256,uint256,uint256);\n', '    function getExerciseWorth(uint256 optionsId,uint256 amount)external view returns(uint256);\n', '    function calculatePhaseOptionsFall(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList) external view returns(int256[] memory);\n', '    function getOptionInfoLength()external view returns (uint256);\n', '    function getNetWrothCalInfo(address[] calldata whiteList)external view returns(uint256,int256[] memory);\n', '    function calRangeSharedPayment(uint256 lastOption,uint256 begin,uint256 end,address[] calldata whiteList)external view returns(int256[] memory,uint256[] memory,uint256);\n', '    function getNetWrothLatestWorth(address settlement)external view returns(int256);\n', '    function getBurnedFullPay(uint256 optionID,uint256 amount) external view returns(address,uint256);\n', '\n', '}\n', 'contract ImportOptionsPool is Ownable{\n', '    IOptionsPool internal _optionsPool;\n', '    function getOptionsPoolAddress() public view returns(address){\n', '        return address(_optionsPool);\n', '    }\n', '    function setOptionsPoolAddress(address optionsPool)public onlyOwner{\n', '        _optionsPool = IOptionsPool(optionsPool);\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Operator.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * each operator can be granted exclusive access to specific functions.\n', ' *\n', ' */\n', 'contract Operator is Ownable {\n', '    using whiteListAddress for address[];\n', '    address[] private _operatorList;\n', '    /**\n', '     * @dev modifier, every operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperator() {\n', '        require(_operatorList.isEligibleAddress(msg.sender),"Managerable: caller is not the Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperatorIndex(uint256 index) {\n', '        require(_operatorList.length>index && _operatorList[index] == msg.sender,"Operator: caller is not the eligible Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev add a new operator by owner. \n', '     *\n', '     */\n', '    function addOperator(address addAddress)public onlyOwner{\n', '        _operatorList.addWhiteListAddress(addAddress);\n', '    }\n', '    /**\n', '     * @dev modify indexed operator by owner. \n', '     *\n', '     */\n', '    function setOperator(uint256 index,address addAddress)public onlyOwner{\n', '        _operatorList[index] = addAddress;\n', '    }\n', '    /**\n', '     * @dev remove operator by owner. \n', '     *\n', '     */\n', '    function removeOperator(address removeAddress)public onlyOwner returns (bool){\n', '        return _operatorList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev get all operators. \n', '     *\n', '     */\n', '    function getOperator()public view returns (address[] memory) {\n', '        return _operatorList;\n', '    }\n', '    /**\n', '     * @dev set all operators by owner. \n', '     *\n', '     */\n', '    function setOperators(address[] memory operators)public onlyOwner {\n', '        _operatorList = operators;\n', '    }\n', '}\n', '\n', '// File: contracts\\CollateralPool\\CollateralData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title collateral pool contract with coin and necessary storage data.\n', " * @dev A smart-contract which stores user's deposited collateral.\n", ' *\n', ' */\n', 'contract CollateralData is AddressWhiteList,Managerable,Operator,ImportOptionsPool{\n', '        // The total fees accumulated in the contract\n', '    mapping (address => uint256) \tinternal feeBalances;\n', '    uint32[] internal FeeRates;\n', '     /**\n', '     * @dev Returns the rate of trasaction fee.\n', '     */   \n', '    uint256 constant internal buyFee = 0;\n', '    uint256 constant internal sellFee = 1;\n', '    uint256 constant internal exerciseFee = 2;\n', '    uint256 constant internal addColFee = 3;\n', '    uint256 constant internal redeemColFee = 4;\n', '    event RedeemFee(address indexed recieptor,address indexed settlement,uint256 payback);\n', '    event AddFee(address indexed settlement,uint256 payback);\n', '    event TransferPayback(address indexed recieptor,address indexed settlement,uint256 payback);\n', '\n', '    //token net worth balance\n', '    mapping (address => int256) internal netWorthBalances;\n', '    //total user deposited collateral balance\n', '    // map from collateral address to amount\n', '    mapping (address => uint256) internal collateralBalances;\n', '    //user total paying for collateral, priced in usd;\n', '    mapping (address => uint256) internal userCollateralPaying;\n', '    //user original deposited collateral.\n', '    //map account -> collateral -> amount\n', '    mapping (address => mapping (address => uint256)) internal userInputCollateral;\n', '}\n', '\n', '// File: contracts\\modules\\Address.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call.value(value )(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\safeErc20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\CollateralPool\\TransactionFee.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a transaction fee manager.\n', '     */\n', 'contract TransactionFee is CollateralData {\n', '    using SafeMath for uint256;\n', '    constructor() internal{\n', '        initialize();\n', '    }\n', '    function initialize() onlyOwner public{\n', '        FeeRates.push(50);\n', '        FeeRates.push(0);\n', '        FeeRates.push(50);\n', '        FeeRates.push(0);\n', '        FeeRates.push(0);\n', '    }\n', '    function getFeeRateAll()public view returns (uint32[] memory){\n', '        return FeeRates;\n', '    }\n', '    function getFeeRate(uint256 feeType)public view returns (uint32){\n', '        return FeeRates[feeType];\n', '    }\n', '    /**\n', '     * @dev set the rate of trasaction fee.\n', '     * @param feeType the transaction fee type\n', '     * @param thousandth the numerator of transaction fee .\n', '     * transaction fee = thousandth/1000;\n', '     */   \n', '    function setTransactionFee(uint256 feeType,uint32 thousandth)public onlyOwner{\n', '        FeeRates[feeType] = thousandth;\n', '    }\n', '\n', '    function getFeeBalance(address settlement)public view returns(uint256){\n', '        return feeBalances[settlement];\n', '    }\n', '    function getAllFeeBalances()public view returns(address[] memory,uint256[] memory){\n', '        uint256[] memory balances = new uint256[](whiteList.length);\n', '        for (uint256 i=0;i<whiteList.length;i++){\n', '            balances[i] = feeBalances[whiteList[i]];\n', '        }\n', '        return (whiteList,balances);\n', '    }\n', '    function redeem(address currency)public onlyOwner{\n', '        uint256 fee = feeBalances[currency];\n', '        require (fee > 0, "It\'s empty balance");\n', '        feeBalances[currency] = 0;\n', '         if (currency == address(0)){\n', '            msg.sender.transfer(fee);\n', '        }else{\n', '            IERC20 currencyToken = IERC20(currency);\n', '            uint256 preBalance = currencyToken.balanceOf(address(this));\n', '            SafeERC20.safeTransfer(currencyToken,msg.sender,fee);\n', '//            currencyToken.transfer(msg.sender,fee);\n', '            uint256 afterBalance = currencyToken.balanceOf(address(this));\n', '            require(preBalance - afterBalance == fee,"settlement token transfer error!");\n', '        }\n', '        emit RedeemFee(msg.sender,currency,fee);\n', '    }\n', '    function redeemAll()public onlyOwner{\n', '        for (uint256 i=0;i<whiteList.length;i++){\n', '            redeem(whiteList[i]);\n', '        }\n', '    }\n', '    function _addTransactionFee(address settlement,uint256 amount) internal {\n', '        if (amount > 0){\n', '            feeBalances[settlement] = feeBalances[settlement]+amount;\n', '            emit AddFee(settlement,amount);\n', '        }\n', '    }\n', '    function calculateFee(uint256 feeType,uint256 amount)public view returns (uint256){\n', '        return FeeRates[feeType]*amount/1000;\n', '    }\n', '    /**\n', '      * @dev  transfer settlement payback amount;\n', '      * @param recieptor payback recieptor\n', '      * @param settlement settlement address\n', '      * @param payback amount of settlement will payback \n', '      */\n', '    function _transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,uint256 feeType)internal{\n', '        if (payback == 0){\n', '            return;\n', '        }\n', '        uint256 fee = FeeRates[feeType]*payback/1000;\n', '        _transferPayback(recieptor,settlement,payback-fee);\n', '        _addTransactionFee(settlement,fee);\n', '    }\n', '    /**\n', '      * @dev  transfer settlement payback amount;\n', '      * @param recieptor payback recieptor\n', '      * @param settlement settlement address\n', '      * @param payback amount of settlement will payback \n', '      */\n', '    function _transferPayback(address payable recieptor,address settlement,uint256 payback)internal{\n', '        if (payback == 0){\n', '            return;\n', '        }\n', '        if (settlement == address(0)){\n', '            recieptor.transfer(payback);\n', '        }else{\n', '            IERC20 collateralToken = IERC20(settlement);\n', '            uint256 preBalance = collateralToken.balanceOf(address(this));\n', '            SafeERC20.safeTransfer(collateralToken,recieptor,payback);\n', '            //collateralToken.transfer(recieptor,payback);\n', '            uint256 afterBalance = collateralToken.balanceOf(address(this));\n', '            require(preBalance - afterBalance == payback,"settlement token transfer error!");\n', '        }\n', '        emit TransferPayback(recieptor,settlement,payback);\n', '    }\n', '}\n', '\n', '// File: contracts\\CollateralPool\\CollateralPool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @title collateral pool contract with coin and necessary storage data.\n', " * @dev A smart-contract which stores user's deposited collateral.\n", ' *\n', ' */\n', 'contract CollateralPool is TransactionFee{\n', '    using SafeMath for uint256;\n', '    using SafeInt256 for int256;\n', '    constructor(address optionsPool)public{\n', '        _optionsPool = IOptionsPool(optionsPool);\n', '    }\n', '    /**\n', '     * @dev Transfer colleteral from manager contract to this contract.\n', '     *  Only manager contract can invoke this function.\n', '     */\n', '    function () external payable onlyManager{\n', '\n', '    }\n', '    function initialize() onlyOwner public {\n', '        TransactionFee.initialize();\n', '    }\n', '    function update() onlyOwner public{\n', '    }\n', '    /**\n', '     * @dev An interface for add transaction fee.\n', '     *  Only manager contract can invoke this function.\n', '     * @param collateral collateral address, also is the coin for fee.\n', '     * @param amount total transaction amount.\n', '     * @param feeType transaction fee type. see TransactionFee contract\n', '     */\n', '    function addTransactionFee(address collateral,uint256 amount,uint256 feeType)public onlyManager returns (uint256) {\n', '        uint256 fee = FeeRates[feeType]*amount/1000;\n', '        _addTransactionFee(collateral,fee);\n', '        return fee;\n', '    }\n', '    /**\n', "     * @dev Retrieve user's cost of collateral, priced in USD.\n", '     * @param user input retrieved account \n', '     */\n', '    function getUserPayingUsd(address user)public view returns (uint256){\n', '        return userCollateralPaying[user];\n', '    }\n', '    /**\n', "     * @dev Retrieve user's amount of the specified collateral.\n", '     * @param user input retrieved account \n', '     * @param collateral input retrieved collateral coin address \n', '     */\n', '    function getUserInputCollateral(address user,address collateral)public view returns (uint256){\n', '        return userInputCollateral[user][collateral];\n', '    }\n', '\n', '    /**\n', '     * @dev Retrieve collateral balance data.\n', '     * @param collateral input retrieved collateral coin address \n', '     */\n', '    function getCollateralBalance(address collateral)public view returns (uint256){\n', '        return collateralBalances[collateral];\n', '    }\n', '    /**\n', '     * @dev Opterator user paying data, priced in USD. Only manager contract can modify database.\n', '     * @param user input user account which need add paying amount.\n', '     * @param amount the input paying amount.\n', '     */\n', '    function addUserPayingUsd(address user,uint256 amount)public onlyManager{\n', '        userCollateralPaying[user] = userCollateralPaying[user].add(amount);\n', '    }\n', '    /**\n', '     * @dev Opterator user input collateral data. Only manager contract can modify database.\n', '     * @param user input user account which need add input collateral.\n', '     * @param collateral the collateral address.\n', '     * @param amount the input collateral amount.\n', '     */\n', '    function addUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\n', '        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].add(amount);\n', '        collateralBalances[collateral] = collateralBalances[collateral].add(amount);\n', '        netWorthBalances[collateral] = netWorthBalances[collateral].add(int256(amount));\n', '    }\n', '    /**\n', '     * @dev Opterator net worth balance data. Only manager contract can modify database.\n', '     * @param whiteList available colleteral address list.\n', '     * @param newNetworth collateral net worth list.\n', '     */\n', '    function addNetWorthBalances(address[] memory whiteList,int256[] memory newNetworth)internal{\n', '        for (uint i=0;i<newNetworth.length;i++){\n', '            netWorthBalances[whiteList[i]] = netWorthBalances[whiteList[i]].add(newNetworth[i]);\n', '        }\n', '    }\n', '    /**\n', '     * @dev Opterator net worth balance data. Only manager contract can modify database.\n', '     * @param collateral available colleteral address.\n', '     * @param amount collateral net worth increase amount.\n', '     */\n', '    function addNetWorthBalance(address collateral,int256 amount)public onlyManager{\n', '        netWorthBalances[collateral] = netWorthBalances[collateral].add(amount);\n', '    }\n', '    /**\n', '     * @dev Opterator collateral balance data. Only manager contract can modify database.\n', '     * @param collateral available colleteral address.\n', '     * @param amount collateral colleteral increase amount.\n', '     */\n', '    function addCollateralBalance(address collateral,uint256 amount)public onlyManager{\n', '        collateralBalances[collateral] = collateralBalances[collateral].add(amount);\n', '    }\n', '    /**\n', '     * @dev Substract user paying data,priced in USD. Only manager contract can modify database.\n', "     * @param user user's account.\n", "     * @param amount user's decrease amount.\n", '     */\n', '    function subUserPayingUsd(address user,uint256 amount)public onlyManager{\n', '        userCollateralPaying[user] = userCollateralPaying[user].sub(amount);\n', '    }\n', '    /**\n', "     * @dev Substract user's collateral balance. Only manager contract can modify database.\n", "     * @param user user's account.\n", '     * @param collateral collateral address.\n', "     * @param amount user's decrease amount.\n", '     */\n', '    function subUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\n', '        userInputCollateral[user][collateral] = userInputCollateral[user][collateral].sub(amount);\n', '    }\n', '    /**\n', '     * @dev Substract net worth balance. Only manager contract can modify database.\n', '     * @param collateral collateral address.\n', '     * @param amount the decrease amount.\n', '     */\n', '    function subNetWorthBalance(address collateral,int256 amount)public onlyManager{\n', '        netWorthBalances[collateral] = netWorthBalances[collateral].sub(amount);\n', '    }\n', '    /**\n', '     * @dev Substract collateral balance. Only manager contract can modify database.\n', '     * @param collateral collateral address.\n', '     * @param amount the decrease amount.\n', '     */\n', '    function subCollateralBalance(address collateral,uint256 amount)public onlyManager{\n', '        collateralBalances[collateral] = collateralBalances[collateral].sub(amount);\n', '    }\n', '    /**\n', '     * @dev set user paying data,priced in USD. Only manager contract can modify database.\n', "     * @param user user's account.\n", "     * @param amount user's new amount.\n", '     */\n', '    function setUserPayingUsd(address user,uint256 amount)public onlyManager{\n', '        userCollateralPaying[user] = amount;\n', '    }\n', '    /**\n', "     * @dev set user's collateral balance. Only manager contract can modify database.\n", "     * @param user user's account.\n", '     * @param collateral collateral address.\n', "     * @param amount user's new amount.\n", '     */\n', '    function setUserInputCollateral(address user,address collateral,uint256 amount)public onlyManager{\n', '        userInputCollateral[user][collateral] = amount;\n', '    }\n', '    /**\n', '     * @dev set net worth balance. Only manager contract can modify database.\n', '     * @param collateral collateral address.\n', '     * @param amount the new amount.\n', '     */\n', '    function setNetWorthBalance(address collateral,int256 amount)public onlyManager{\n', '        netWorthBalances[collateral] = amount;\n', '    }\n', '    /**\n', '     * @dev set collateral balance. Only manager contract can modify database.\n', '     * @param collateral collateral address.\n', '     * @param amount the new amount.\n', '     */\n', '    function setCollateralBalance(address collateral,uint256 amount)public onlyManager{\n', '        collateralBalances[collateral] = amount;\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback and deduct transaction fee. Only manager contract can invoke this function.\n", '     * @param recieptor the recieptor account.\n', '     * @param settlement the settlement coin address.\n', '     * @param payback the payback amount\n', '     * @param feeType the transaction fee type. see transactionFee contract\n', '     */\n', '    function transferPaybackAndFee(address payable recieptor,address settlement,uint256 payback,\n', '            uint256 feeType)public onlyManager{\n', '        _transferPaybackAndFee(recieptor,settlement,payback,feeType);\n', '        netWorthBalances[settlement] = netWorthBalances[settlement].sub(int256(payback));\n', '    }\n', '        /**\n', "     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\n", '     * @param recieptor the recieptor account.\n', '     * @param allPay the payback amount\n', '     */\n', '    function buyOptionsPayfor(address payable recieptor,address settlement,uint256 settlementAmount,uint256 allPay)public onlyManager{\n', '        uint256 fee = addTransactionFee(settlement,allPay,0);\n', '        require(settlementAmount>=allPay+fee,"settlement asset is insufficient!");\n', '        settlementAmount = settlementAmount-(allPay+fee);\n', '        if (settlementAmount > 0){\n', '            _transferPayback(recieptor,settlement,settlementAmount);\n', '        }\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback. Only manager contract can invoke this function.\n", '     * @param recieptor the recieptor account.\n', '     * @param settlement the settlement coin address.\n', '     * @param payback the payback amount\n', '     */\n', '    function transferPayback(address payable recieptor,address settlement,uint256 payback)public onlyManager{\n', '        _transferPayback(recieptor,settlement,payback);\n', '    }\n', '    /**\n', "     * @dev Operation for transfer user's payback and deduct transaction fee for multiple settlement Coin.\n", '     *       Specially used for redeem collateral.Only manager contract can invoke this function.\n', '     * @param account the recieptor account.\n', '     * @param redeemWorth the redeem worth, priced in USD.\n', '     * @param tmpWhiteList the settlement coin white list\n', "     * @param colBalances the Collateral balance based for user's input collateral.\n", "     * @param PremiumBalances the premium collateral balance if redeem worth is exceeded user's input collateral.\n", '     * @param prices the collateral prices list.\n', '     */\n', '    function transferPaybackBalances(address payable account,uint256 redeemWorth,address[] memory tmpWhiteList,uint256[] memory colBalances,\n', '        uint256[] memory PremiumBalances,uint256[] memory prices)public onlyManager {\n', '        uint256 ln = tmpWhiteList.length;\n', '        uint256[] memory PaybackBalances = new uint256[](ln);\n', '        uint256 i=0;\n', '        uint256 amount;\n', '        for(; i<ln && redeemWorth>0;i++){\n', '            //address addr = tmpWhiteList[i];\n', '            if (colBalances[i] > 0){\n', '                amount = redeemWorth/prices[i];\n', '                if (amount < colBalances[i]){\n', '                    redeemWorth = 0;\n', '                }else{\n', '                    amount = colBalances[i];\n', '                    redeemWorth = redeemWorth - colBalances[i]*prices[i];\n', '                }\n', '                PaybackBalances[i] = amount;\n', '                amount = amount * userInputCollateral[account][tmpWhiteList[i]]/colBalances[i];\n', '                userInputCollateral[account][tmpWhiteList[i]] =userInputCollateral[account][tmpWhiteList[i]].sub(amount);\n', '                collateralBalances[tmpWhiteList[i]] = collateralBalances[tmpWhiteList[i]].sub(amount);\n', '\n', '            }\n', '        }\n', '        if (redeemWorth>0) {\n', '           amount = 0;\n', '            for (i=0; i<ln;i++){\n', '                amount = amount.add(PremiumBalances[i]*prices[i]);\n', '            }\n', '//            require(amount >= redeemWorth ,"redeem collateral is insufficient");\n', '            if (amount<redeemWorth){\n', '                amount = redeemWorth;\n', '            }\n', '            for (i=0; i<ln;i++){\n', '                PaybackBalances[i] = PaybackBalances[i].add(PremiumBalances[i].mul(redeemWorth)/amount);\n', '            }\n', '        }\n', '        for (i=0;i<ln;i++){ \n', '            transferPaybackAndFee(account,tmpWhiteList[i],PaybackBalances[i],redeemColFee);\n', '        } \n', '    }\n', '    /**\n', "     * @dev calculate user's input collateral balance and premium collateral balance.\n", "     *      Specially used for user's redeem collateral.\n", '     * @param account the recieptor account.\n', "     * @param userTotalWorth the user's total FPTCoin worth, priced in USD.\n", '     * @param tmpWhiteList the settlement coin white list\n', '     * @param _RealBalances the real Collateral balance.\n', '     * @param prices the collateral prices list.\n', '     */\n', '    function getCollateralAndPremiumBalances(address account,uint256 userTotalWorth,address[] memory tmpWhiteList,\n', '        uint256[] memory _RealBalances,uint256[] memory prices) public view returns(uint256[] memory,uint256[] memory){\n', '//        uint256 ln = tmpWhiteList.length;\n', '        uint256[] memory colBalances = new uint256[](tmpWhiteList.length);\n', '        uint256[] memory PremiumBalances = new uint256[](tmpWhiteList.length);\n', '        uint256 totalWorth = 0;\n', '        uint256 PremiumWorth = 0;\n', '        uint256 i=0;\n', '        for(; i<tmpWhiteList.length;i++){\n', '            (colBalances[i],PremiumBalances[i]) = calUserNetWorthBalanceRate(tmpWhiteList[i],account,_RealBalances[i]);\n', '            totalWorth = totalWorth.add(prices[i]*colBalances[i]);\n', '            PremiumWorth = PremiumWorth.add(prices[i]*PremiumBalances[i]);\n', '        }\n', '        if (totalWorth >= userTotalWorth){\n', '            for (i=0; i<tmpWhiteList.length;i++){\n', '                colBalances[i] = colBalances[i].mul(userTotalWorth)/totalWorth;\n', '            }\n', '        }else if (PremiumWorth>0){\n', '            userTotalWorth = userTotalWorth - totalWorth;\n', '            for (i=0; i<tmpWhiteList.length;i++){\n', '                PremiumBalances[i] = PremiumBalances[i].mul(userTotalWorth)/PremiumWorth;\n', '            }\n', '        }\n', '        return (colBalances,PremiumBalances);\n', '    } \n', '    /**\n', "     * @dev calculate user's input collateral balance.\n", "     *      Specially used for user's redeem collateral.\n", '     * @param settlement the settlement coin address.\n', '     * @param user the recieptor account.\n', '     * @param netWorthBalance the settlement coin real balance\n', '     */\n', '    function calUserNetWorthBalanceRate(address settlement,address user,uint256 netWorthBalance)internal view returns(uint256,uint256){\n', '        uint256 collateralBalance = collateralBalances[settlement];\n', '        uint256 amount = userInputCollateral[user][settlement];\n', '        if (collateralBalance > 0){\n', '            uint256 curAmount = netWorthBalance.mul(amount)/collateralBalance;\n', '            return (curAmount,netWorthBalance.sub(curAmount));\n', '        }else{\n', '            return (0,netWorthBalance);\n', '        }\n', '    }\n', '    function getAllRealBalance(address[] memory whiteList)public view returns(int256[] memory){\n', '        uint256 len = whiteList.length;\n', '        int256[] memory realBalances = new int256[](len); \n', '        for (uint i = 0;i<len;i++){\n', '            int256 latestWorth = _optionsPool.getNetWrothLatestWorth(whiteList[i]);\n', '            realBalances[i] = netWorthBalances[whiteList[i]].add(latestWorth);\n', '        }\n', '        return realBalances;\n', '    }\n', '        /**\n', '     * @dev Retrieve the balance of collateral, the auxiliary function for the total collateral calculation. \n', '     */\n', '    function getRealBalance(address settlement)public view returns(int256){\n', '        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\n', '        return netWorthBalances[settlement].add(latestWorth);\n', '    }\n', '    function getNetWorthBalance(address settlement)public view returns(uint256){\n', '        int256 latestWorth = _optionsPool.getNetWrothLatestWorth(settlement);\n', '        int256 netWorth = netWorthBalances[settlement].add(latestWorth);\n', '        if (netWorth>0){\n', '            return uint256(netWorth);\n', '        }\n', '        return 0;\n', '    }\n', '        /**\n', '     * @dev  The foundation operator want to add some coin to netbalance, which can increase the FPTCoin net worth.\n', '     * @param settlement the settlement coin address which the foundation operator want to transfer in this contract address.\n', '     * @param amount the amount of the settlement coin which the foundation operator want to transfer in this contract address.\n', '     */\n', '    function addNetBalance(address settlement,uint256 amount) public payable {\n', '        amount = getPayableAmount(settlement,amount);\n', '        netWorthBalances[settlement] = netWorthBalances[settlement].add(int256(amount));\n', '    }\n', '        /**\n', "     * @dev the auxiliary function for getting user's transer\n", '     */\n', '    function getPayableAmount(address settlement,uint256 settlementAmount) internal returns (uint256) {\n', '        if (settlement == address(0)){\n', '            settlementAmount = msg.value;\n', '        }else if (settlementAmount > 0){\n', '            IERC20 oToken = IERC20(settlement);\n', '            uint256 preBalance = oToken.balanceOf(address(this));\n', '            oToken.transferFrom(msg.sender, address(this), settlementAmount);\n', '            uint256 afterBalance = oToken.balanceOf(address(this));\n', '            require(afterBalance-preBalance==settlementAmount,"settlement token transfer error!");\n', '        }\n', '        return settlementAmount;\n', '    }\n', '        /**\n', '     * @dev Calculate the collateral pool shared worth.\n', '     * The foundation operator will invoke this function frequently\n', '     */\n', '    function calSharedPayment(address[] memory _whiteList) public onlyOperatorIndex(0) {\n', '        (uint256 firstOption,int256[] memory latestShared) = _optionsPool.getNetWrothCalInfo(_whiteList);\n', '        uint256 lastOption = _optionsPool.getOptionInfoLength();\n', '        (int256[] memory newNetworth,uint256[] memory sharedBalance,uint256 newFirst) =\n', '                     _optionsPool.calRangeSharedPayment(lastOption,firstOption,lastOption,_whiteList);\n', '        int256[] memory fallBalance = _optionsPool.calculatePhaseOptionsFall(lastOption,newFirst,lastOption,_whiteList);\n', '        for (uint256 i= 0;i<fallBalance.length;i++){\n', '            fallBalance[i] = int256(sharedBalance[i]).sub(latestShared[i]).add(fallBalance[i]);\n', '        }\n', '        setSharedPayment(_whiteList,newNetworth,fallBalance,newFirst);\n', '    }\n', '    /**\n', '     * @dev Set the calculation results of the collateral pool shared worth.\n', '     * The foundation operator will invoke this function frequently\n', "     * @param newNetworth Current expired options' net worth \n", "     * @param sharedBalances All unexpired options' shared balance distributed by time.\n", "     * @param firstOption The new first unexpired option's index.\n", '     */\n', '    function setSharedPayment(address[] memory _whiteList,int256[] memory newNetworth,int256[] memory sharedBalances,uint256 firstOption) public onlyOperatorIndex(0){\n', '        _optionsPool.setSharedState(firstOption,sharedBalances,_whiteList);\n', '        addNetWorthBalances(_whiteList,newNetworth);\n', '    }\n', '}']