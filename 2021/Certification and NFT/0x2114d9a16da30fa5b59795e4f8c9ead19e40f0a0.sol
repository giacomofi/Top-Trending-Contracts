['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.6;\n', '\n', 'interface IV2Strategy {\n', '    function name() external view returns (string memory);\n', '\n', '    function apiVersion() external view returns (string memory);\n', '\n', '    function strategist() external view returns (address);\n', '\n', '    function rewards() external view returns (address);\n', '\n', '    function vault() external view returns (address);\n', '\n', '    function keeper() external view returns (address);\n', '\n', '    function want() external view returns (address);\n', '\n', '    function emergencyExit() external view returns (bool);\n', '\n', '    function isActive() external view returns (bool);\n', '\n', '    function delegatedAssets() external view returns (uint256);\n', '\n', '    function estimatedTotalAssets() external view returns (uint256);\n', '    \n', '    function doHealthCheck() external view returns (bool);\n', '    \n', '    function healthCheck() external view returns (address);\n', '}\n', '\n', 'interface IAddressesGenerator {\n', '    function assetsAddresses() external view returns (address[] memory);\n', '}\n', '\n', 'interface IV2Vault {\n', '    function withdrawalQueue(uint256 arg0) external view returns (address);\n', '}\n', '\n', 'interface IAddressMergeHelper {\n', '    function mergeAddresses(address[][] memory addressesSets)\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '    \n', '    function symbol() external view returns (string memory);\n', '}\n', '\n', 'interface IOracle {\n', '    function getNormalizedValueUsdc(\n', '        address tokenAddress,\n', '        uint256 amount,\n', '        uint256 priceUsdc\n', '    ) external view returns (uint256);\n', '    \n', '    function getPriceUsdcRecommended(\n', '        address tokenAddress\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'contract StrategiesHelper {\n', '    address public addressesGeneratorAddress;\n', '    address public addressesMergeHelperAddress;\n', '    address public oracleAddress;\n', '    address public ownerAddress;\n', '\n', '    struct StrategyMetadata {\n', '        string name;\n', '        address id;\n', '        string apiVersion;\n', '        address strategist;\n', '        address rewards;\n', '        address vault;\n', '        address keeper;\n', '        address want;\n', '        uint256 wantPriceUsdc;\n', '        uint8 wantDecimals;\n', '        string wantSymbol;\n', '        bool emergencyExit;\n', '        bool isActive;\n', '        uint256 delegatedAssets;\n', '        uint256 estimatedTotalAssets;\n', '        uint256 estimatedTotalAssetsUsdc;\n', '        bool doHealthCheck;\n', '        address healthCheckAddress;\n', '    }\n', '\n', '    constructor(address _addressesGeneratorAddress, address _addressesMergeHelperAddress, address _oracleAddress) {\n', '        addressesGeneratorAddress = _addressesGeneratorAddress;\n', '        addressesMergeHelperAddress = _addressesMergeHelperAddress;\n', '        oracleAddress = _oracleAddress;\n', '        ownerAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Fetch the number of strategies for a vault\n', '     */\n', '    function assetStrategiesLength(address assetAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 strategyIdx;\n', '        while (true) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            if (strategyAddress == address(0)) {\n', '                break;\n', '            }\n', '            strategyIdx++;\n', '        }\n', '        return strategyIdx;\n', '    }\n', '\n', '    /**\n', '     * Fetch the total number of strategies for all vaults\n', '     */\n', '    function assetsStrategiesLength() public view returns (uint256) {\n', '        return assetsStrategiesAddresses().length;\n', '    }\n', '\n', '    /**\n', '     * Fetch strategy addresses given a vault address\n', '     */\n', '    function assetStrategiesAddresses(address assetAddress)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n', '        address[] memory _strategiesAddresses =\n', '            new address[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            _strategiesAddresses[strategyIdx] = strategyAddress;\n', '        }\n', '        return _strategiesAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch all strategy addresses for all vaults\n', '     */\n', '     function assetsStrategiesAddresses() public view returns (address[] memory) {\n', '        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n', '        return assetsStrategiesAddresses(_assetsAddresses);\n', '     }\n', '     \n', '    /**\n', '     * Convert an ASCII string to a number given a string and a base\n', '     */\n', '    function atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n', '        require(base == 2 || base == 8 || base == 10 || base == 16);\n', '        bytes memory buf = bytes(a);\n', '        for (uint256 p = 0; p < buf.length; p++) {\n', '            uint8 digit = uint8(buf[p]) - 0x30;\n', '            if (digit > 10) {\n', '                digit -= 7;\n', '            }\n', '            require(digit < base);\n', '            i *= base;\n', '            i += digit;\n', '        }\n', '        return i;\n', '    }\n', '    \n', '    /**\n', '     * Check to see if two strings are exactly equal\n', '     */\n', '    function stringsEqual(string memory input1, string memory input2) internal pure returns (bool) {\n', '        bytes32 input1Bytes32;\n', '        bytes32 input2Bytes32;\n', '        assembly {\n', '            input1Bytes32 := mload(add(input1, 32))\n', '            input2Bytes32 := mload(add(input2, 32))\n', '        }\n', '        return input1Bytes32 == input2Bytes32;\n', '    }\n', '\n', '    /**\n', '     * Fetch strategy addresses by filter\n', '     */\n', '     function assetsStrategiesAddressesByFilter(string[][] memory filter) public view returns (address[] memory) {\n', '        address[] memory _assetsStrategiesAddresses =\n', '            assetsStrategiesAddresses();\n', '        return assetsStrategiesAddressesByFilter(_assetsStrategiesAddresses, filter);\n', '    }\n', '    \n', '    /**\n', '     * Fetch strategy addresses by filter\n', '     */\n', '    function assetsStrategiesAddressesByFilter(address[] memory _strategiesAddresses, string[][] memory filter) public view returns (address[] memory) {\n', '        uint256 numberOfStrategies = _strategiesAddresses.length;\n', '        uint256 numberOfFilteredStrategies;\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = _strategiesAddresses[strategyIdx];\n', '            if (strategyPassesFilter(strategyAddress, filter)) {\n', '                _strategiesAddresses[numberOfFilteredStrategies] = strategyAddress;\n', '                numberOfFilteredStrategies++;\n', '            }\n', '        }\n', '        bytes memory encodedAddresses = abi.encode(_strategiesAddresses);\n', '        assembly {\n', '            mstore(add(encodedAddresses, 0x40), numberOfFilteredStrategies)\n', '        }\n', '        address[] memory filteredAddresses =\n', '            abi.decode(encodedAddresses, (address[]));\n', '        return filteredAddresses;\n', '     }\n', '\n', '    /**\n', '     * Fetch all strategy addresses given an array of vaults\n', '     */\n', '    function assetsStrategiesAddresses(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        address[][] memory _strategiesForAssets =\n', '            new address[][](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            address[] memory _assetStrategiessAddresses =\n', '                assetStrategiesAddresses(assetAddress);\n', '            _strategiesForAssets[assetIdx] = _assetStrategiessAddresses;\n', '        }\n', '        address[] memory mergedAddresses =\n', '            IAddressMergeHelper(addressesMergeHelperAddress).mergeAddresses(_strategiesForAssets);\n', '        return mergedAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch total delegated balance for all strategies\n', '     */\n', '    function assetsStrategiesDelegatedBalance()\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        uint256 assetsDelegatedBalance;\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            uint256 assetDelegatedBalance =\n', '                assetStrategiesDelegatedBalance(assetAddress);\n', '            assetsDelegatedBalance += assetDelegatedBalance;\n', '        }\n', '        return assetsDelegatedBalance;\n', '    }\n', '\n', '    /**\n', "     * Fetch delegated balance for all of a vault's strategies\n", '     */\n', '    function assetStrategiesDelegatedBalance(address assetAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address[] memory _assetStrategiesAddresses =\n', '            assetStrategiesAddresses(assetAddress);\n', '        uint256 numberOfStrategies = _assetStrategiesAddresses.length;\n', '        uint256 strategiesDelegatedBalance;\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = _assetStrategiesAddresses[strategyIdx];\n', '            IV2Strategy _strategy = IV2Strategy(strategyAddress);\n', '            uint256 strategyDelegatedBalance = _strategy.delegatedAssets();\n', '            strategiesDelegatedBalance += strategyDelegatedBalance;\n', '        }\n', '        return strategiesDelegatedBalance;\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for all strategies scoped to a vault\n', '     */\n', '    function assetStrategies(address assetAddress)\n', '        external\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n', '        StrategyMetadata[] memory _strategies =\n', '            new StrategyMetadata[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            StrategyMetadata memory _strategy = strategy(strategyAddress);\n', '            _strategies[strategyIdx] = _strategy;\n', '        }\n', '        return _strategies;\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for all strategies\n', '     */\n', '    function assetsStrategies()\n', '        external\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        address[] memory _assetsStrategiesAddresses =\n', '            assetsStrategiesAddresses();\n', '        return strategies(_assetsStrategiesAddresses);\n', '    }\n', '    \n', '    /**\n', '     * Fetch metadata for all strategies\n', '     */\n', '    function assetsStrategiesByFilter(string[][] memory _filter)\n', '        external\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        address[] memory _assetsStrategiesAddresses =\n', '            assetsStrategiesAddressesByFilter(_filter);\n', '        return strategies(_assetsStrategiesAddresses);\n', '    }\n', '    \n', '    /**\n', '     * Fetch metadata for strategies given an array of vault addresses\n', '     */\n', '    function assetsStrategies(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        return strategies(assetsStrategiesAddresses(_assetsAddresses));\n', '    }\n', '    \n', '    /**\n', '     * Fetch metadata for strategies given an array of vault addresses and a filter\n', '     */\n', '    function assetsStrategiesByFilter(address[] memory _assetsAddresses, string[][] memory _filter)\n', '        public\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        return strategies(assetsStrategiesAddressesByFilter(_assetsAddresses, _filter));\n', '    }\n', '    \n', '    /**\n', '     * Fetch metadata for a strategy given a strategy address\n', '     */\n', '    function strategy(address strategyAddress)\n', '        public\n', '        view\n', '        returns (StrategyMetadata memory)\n', '    {\n', '        IV2Strategy _strategy = IV2Strategy(strategyAddress);\n', '        IOracle _oracle = IOracle(oracleAddress);\n', '        bool _doHealthCheck;\n', '        address _healthCheckAddress;\n', '        address _wantAddress = _strategy.want();\n', '        IERC20 _want = IERC20(_wantAddress);\n', '        uint256 _wantPriceUsdc = _oracle.getPriceUsdcRecommended(_wantAddress);\n', '        uint256 _estimatedTotalAssets = _strategy.estimatedTotalAssets();\n', '        try _strategy.doHealthCheck() {\n', '            _doHealthCheck = _strategy.doHealthCheck();\n', '        } catch {}\n', '        try _strategy.healthCheck() {\n', '             _healthCheckAddress = _strategy.healthCheck();\n', '        } catch {}\n', '        return\n', '            StrategyMetadata({\n', '                name: _strategy.name(),\n', '                id: strategyAddress,\n', '                apiVersion: _strategy.apiVersion(),\n', '                strategist: _strategy.strategist(),\n', '                rewards: _strategy.rewards(),\n', '                vault: _strategy.vault(),\n', '                keeper: _strategy.keeper(),\n', '                want: _wantAddress,\n', '                wantPriceUsdc: _wantPriceUsdc,\n', '                wantDecimals: _want.decimals(),\n', '                wantSymbol: _want.symbol(),\n', '                emergencyExit: _strategy.emergencyExit(),\n', '                isActive: _strategy.isActive(),\n', '                delegatedAssets: _strategy.delegatedAssets(),\n', '                estimatedTotalAssets: _estimatedTotalAssets,\n', '                estimatedTotalAssetsUsdc: _oracle.getNormalizedValueUsdc(_wantAddress, _estimatedTotalAssets, _wantPriceUsdc),\n', '                doHealthCheck: _doHealthCheck,\n', '                healthCheckAddress: _healthCheckAddress\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for strategies given an array of strategy addresses\n', '     */\n', '    function strategies(address[] memory _strategiesAddresses)\n', '        public\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        uint256 numberOfStrategies = _strategiesAddresses.length;\n', '        StrategyMetadata[] memory _strategies =\n', '            new StrategyMetadata[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = _strategiesAddresses[strategyIdx];\n', '            StrategyMetadata memory _strategy = strategy(strategyAddress);\n', '            _strategies[strategyIdx] = _strategy;\n', '        }\n', '        return _strategies;\n', '    }\n', '    \n', '    /**\n', '     * Filter a strategy using a reverse polish notation (RPM) query language\n', '     *\n', '     * Each instruction is a tuple of either two or three strings.\n', '     *\n', '     * Argument 0 - Operand type\n', '     * -------------------------\n', '     * KEY      - Denotes a value should be fetched using a function sighash derived from argument 1\n', '     * VALUE    - A value to be added directly to the stack\n', '     * OPERATOR - The name of the instruction to execute\n', '     *\n', '     * Argument 1 - Key/Value or operator\n', '     * ----------------------------------\n', '     * Data     - If KEY or VALUE are specified in argument 0, argument 1 represents either the key\n', '     *            to fetch data with or the value to be added to the stack\n', '     * Operator - If OPERATOR is specified in argument 0, argument 1 represents the operator to execute.\n', '     *            Valid operators are: EQ, GT, GTE, LT, LTE, OR, AND, NE and LIKE\n', '     *\n', '     * Argument 2 - Value type\n', '     * -----------------------\n', '     * For key/value operands argument 2 describes how to parse a value to be placed on the stack.\n', '     * Valid options are: STRING, HEX, DECIMAL\n', '     *\n', '     * Note: The stack size is 32 bytes. Any values beyond this will be truncated.\n', '     *\n', '     * Example Filter\n', '     * ==============\n', '     * Description: Find all strategies whose apiVersion is like 0.3.5 or 0.3.3\n', '     *              where strategist address is C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0\n', '     * filter = [\n', '     *     ["KEY",        "apiVersion", "STRING"],\n', '     *     ["VALUE",      "0.3.5", "STRING"],\n', '     *     ["OPERATOR",   "LIKE"],\n', '     *     ["KEY",        "apiVersion", "STRING"],\n', '     *     ["VALUE",      "0.3.3", "STRING"],\n', '     *     ["OPERATOR",   "LIKE"],\n', '     *     ["OPERATOR",   "OR"],\n', '     *     ["KEY",        "strategist", "HEX"],\n', '     *     ["VALUE",      "C3D6880fD95E06C816cB030fAc45b3ffe3651Cb0", "HEX"],\n', '     *     ["OPERATOR",   "EQ"],\n', '     *     ["OPERATOR",   "AND"]\n', '     * ];\n', '     */\n', '    function strategyPassesFilter(address strategyAddress, string[][] memory instructions) public view returns (bool) {\n', '        bytes32[] memory stack = new bytes32[](instructions.length * 3);\n', '        uint256 stackLength;\n', '        for (uint256 instructionsIdx; instructionsIdx < instructions.length; instructionsIdx++) {\n', '            string[] memory instruction = instructions[instructionsIdx];\n', '            string memory instructionPart1 = instruction[1];\n', '            bool operandIsOperator = stringsEqual(instruction[0], "OPERATOR");\n', '            if (operandIsOperator) {\n', '                bool result;\n', '                bytes32 operandTwo = stack[stackLength - 1];\n', '                bytes32 operandOne = stack[stackLength - 2];\n', '                if (stringsEqual(instruction[1], "EQ")) {\n', '                    result = uint256(operandTwo) == uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "NE")) {\n', '                    result = uint256(operandTwo) != uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "GT")) {\n', '                    result = uint256(operandTwo) > uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "GTE")) {\n', '                    result = uint256(operandTwo) >= uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "LT")) {\n', '                    result = uint256(operandTwo) < uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "LTE")) {\n', '                    result = uint256(operandTwo) <= uint256(operandOne);\n', '                }\n', '                if (stringsEqual(instruction[1], "AND")) {\n', '                    result = uint256(operandTwo & operandOne) == 1;\n', '                }\n', '                if (stringsEqual(instruction[1], "OR")) {\n', '                    result = uint256(operandTwo | operandOne) == 1;\n', '                }\n', '                if (stringsEqual(instruction[1], "LIKE")) {\n', '                    string memory haystack = String.bytes32ToString(operandOne);\n', '                    string memory needle = String.bytes32ToString(operandTwo);\n', '                    result = String.contains(haystack, needle);\n', '                }\n', '                if (result) {\n', '                    stack[stackLength - 2] = bytes32(uint256(1));\n', '                } else {\n', '                    stack[stackLength - 2] = bytes32(uint256(0));\n', '                }\n', '                stackLength--;\n', '            } else {\n', '                bytes32 stackItem;\n', '                bool operandIsKey = stringsEqual(instruction[0], "KEY");\n', '                bytes memory data;\n', '                if (operandIsKey) {\n', '                    (, bytes memory matchBytes) =\n', '                        address(strategyAddress).staticcall(abi.encodeWithSignature(string(abi.encodePacked(instruction[1], "()"))));\n', '                    data = matchBytes;\n', '                }\n', '                if (stringsEqual(instruction[2], "HEX")) {\n', '                    if (operandIsKey == true) {\n', '                        assembly {\n', '                            stackItem := mload(add(data, 0x20))\n', '                        }\n', '                    } else {\n', '                        stackItem = bytes32(atoi(String.uppercase(instruction[1]), 16));\n', '                    }\n', '                } else if (stringsEqual(instruction[2], "STRING")) {\n', '                    if (operandIsKey == true) {\n', '                        assembly {\n', '                            stackItem := mload(add(data, 0x60))\n', '                        }\n', '                    } else {\n', '                        assembly {\n', '                            stackItem := mload(add(instructionPart1, 0x20))\n', '                        }                        \n', '                    }\n', '                } else if (stringsEqual(instruction[2], "DECIMAL")) {\n', '                    if (operandIsKey == true) {\n', '                        assembly {\n', '                            stackItem := mload(add(data, 0x20))\n', '                        }\n', '                    } else {\n', '                        stackItem = bytes32(atoi(instruction[1], 10));\n', '                    }\n', '                }\n', '                stack[stackLength] = stackItem;\n', '                stackLength++;\n', '            }\n', '        }\n', '        if (uint256(stack[0]) == 1) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    /**\n', '     * Allow storage slots to be manually updated\n', '     */\n', '    function updateSlot(bytes32 slot, bytes32 value) external {\n', '        require(msg.sender == ownerAddress, "Caller is not the owner");\n', '        assembly {\n', '            sstore(slot, value)\n', '        }\n', '    }\n', '}\n', '\n', 'library String {\n', '    /**\n', '     * Convert a string to lowercase\n', '     */\n', '    function lowercase(string memory input) internal pure returns (string memory) {\n', '        bytes memory _input = bytes(input);\n', '        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\n', '            uint8 character = uint8(_input[inputIdx]);\n', '            if (character >= 65 && character <= 90) {\n', '                character += 0x20;\n', '                _input[inputIdx] = bytes1(character);\n', '            }\n', '        }\n', '        return string(_input);\n', '    }\n', '\n', '    /**\n', '     * Convert a string to uppercase\n', '     */\n', '    function uppercase(string memory input) internal pure returns (string memory) {\n', '        bytes memory _input = bytes(input);\n', '        for (uint inputIdx = 0; inputIdx < _input.length; inputIdx++) {\n', '            uint8 character = uint8(_input[inputIdx]);\n', '            if (character >= 97 && character <= 122) {\n', '                character -= 0x20;\n', '                _input[inputIdx] = bytes1(character);\n', '            }\n', '        }\n', '        return string(_input);\n', '    }\n', '\n', '    /**\n', '     * Search for a needle in a haystack\n', '     */\n', '    function contains(string memory haystack, string memory needle) internal pure returns (bool) {\n', '        return indexOf(needle, haystack) >= 0;\n', '    }\n', '    \n', '    /**\n', '     * Convert bytes32 to string and remove padding\n', '     */\n', '    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n', '        uint8 i = 0;\n', '        while(i < 32 && _bytes32[i] != 0) {\n', '            i++;\n', '        }\n', '        bytes memory bytesArray = new bytes(i);\n', '        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n', '            bytesArray[i] = _bytes32[i];\n', '        }\n', '        return string(bytesArray);\n', '    }\n', '\n', '    /**\n', '     * Case insensitive string search\n', '     *\n', '     * @param needle The string to search for\n', '     * @param haystack The string to search in\n', '     * @return Returns -1 if no match is found, otherwise returns the index of the match \n', '     */\n', '    function indexOf(string memory needle, string memory haystack) internal pure returns (int256) {\n', '        bytes memory _needle = bytes(lowercase(needle));\n', '        bytes memory _haystack = bytes(lowercase(haystack));\n', '        if (_haystack.length < _needle.length) {\n', '            return -1;\n', '        }\n', '        bool _match;\n', '        for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\n', '            for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\n', '                uint8 needleChar = uint8(_needle[needleIdx]);\n', '                if (haystackIdx + needleIdx >= _haystack.length) {\n', '                    return -1;\n', '                }\n', '                uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\n', '                if (needleChar == haystackChar) {\n', '                    _match = true;\n', '                    if (needleIdx == _needle.length - 1) {\n', '                        return int(haystackIdx);\n', '                    }\n', '                } else {\n', '                    _match = false;\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        return -1;\n', '    }\n', '}']