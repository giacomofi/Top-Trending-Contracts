['pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../SErc20.sol";\n', 'import "../SToken.sol";\n', 'import "../PriceOracle.sol";\n', 'import "../EIP20Interface.sol";\n', 'import "../GovernorAlpha.sol";\n', 'import "../STRK.sol";\n', '\n', 'interface ComptrollerLensInterface {\n', '    function markets(address) external view returns (bool, uint);\n', '    function oracle() external view returns (PriceOracle);\n', '    function getAccountLiquidity(address) external view returns (uint, uint, uint);\n', '    function getAssetsIn(address) external view returns (SToken[] memory);\n', '    function claimStrike(address) external;\n', '    function strikeAccrued(address) external view returns (uint);\n', '}\n', '\n', 'contract StrikeLens {\n', '    struct STokenMetadata {\n', '        address sToken;\n', '        uint exchangeRateCurrent;\n', '        uint supplyRatePerBlock;\n', '        uint borrowRatePerBlock;\n', '        uint reserveFactorMantissa;\n', '        uint totalBorrows;\n', '        uint totalReserves;\n', '        uint totalSupply;\n', '        uint totalCash;\n', '        bool isListed;\n', '        uint collateralFactorMantissa;\n', '        address underlyingAssetAddress;\n', '        uint sTokenDecimals;\n', '        uint underlyingDecimals;\n', '    }\n', '\n', '    function sTokenMetadata(SToken sToken) public returns (STokenMetadata memory) {\n', '        uint exchangeRateCurrent = sToken.exchangeRateCurrent();\n', '        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(sToken.comptroller()));\n', '        (bool isListed, uint collateralFactorMantissa) = comptroller.markets(address(sToken));\n', '        address underlyingAssetAddress;\n', '        uint underlyingDecimals;\n', '\n', '        if (compareStrings(sToken.symbol(), "sETH")) {\n', '            underlyingAssetAddress = address(0);\n', '            underlyingDecimals = 18;\n', '        } else {\n', '            SErc20 sErc20 = SErc20(address(sToken));\n', '            underlyingAssetAddress = sErc20.underlying();\n', '            underlyingDecimals = EIP20Interface(sErc20.underlying()).decimals();\n', '        }\n', '\n', '        return STokenMetadata({\n', '            sToken: address(sToken),\n', '            exchangeRateCurrent: exchangeRateCurrent,\n', '            supplyRatePerBlock: sToken.supplyRatePerBlock(),\n', '            borrowRatePerBlock: sToken.borrowRatePerBlock(),\n', '            reserveFactorMantissa: sToken.reserveFactorMantissa(),\n', '            totalBorrows: sToken.totalBorrows(),\n', '            totalReserves: sToken.totalReserves(),\n', '            totalSupply: sToken.totalSupply(),\n', '            totalCash: sToken.getCash(),\n', '            isListed: isListed,\n', '            collateralFactorMantissa: collateralFactorMantissa,\n', '            underlyingAssetAddress: underlyingAssetAddress,\n', '            sTokenDecimals: sToken.decimals(),\n', '            underlyingDecimals: underlyingDecimals\n', '        });\n', '    }\n', '\n', '    function sTokenMetadataAll(SToken[] calldata sTokens) external returns (STokenMetadata[] memory) {\n', '        uint sTokenCount = sTokens.length;\n', '        STokenMetadata[] memory res = new STokenMetadata[](sTokenCount);\n', '        for (uint i = 0; i < sTokenCount; i++) {\n', '            res[i] = sTokenMetadata(sTokens[i]);\n', '        }\n', '        return res;\n', '    }\n', '\n', '    struct STokenBalances {\n', '        address sToken;\n', '        uint balanceOf;\n', '        uint borrowBalanceCurrent;\n', '        uint balanceOfUnderlying;\n', '        uint tokenBalance;\n', '        uint tokenAllowance;\n', '    }\n', '\n', '    function sTokenBalances(SToken sToken, address payable account) public returns (STokenBalances memory) {\n', '        uint balanceOf = sToken.balanceOf(account);\n', '        uint borrowBalanceCurrent = sToken.borrowBalanceCurrent(account);\n', '        uint balanceOfUnderlying = sToken.balanceOfUnderlying(account);\n', '        uint tokenBalance;\n', '        uint tokenAllowance;\n', '\n', '        if (compareStrings(sToken.symbol(), "sETH")) {\n', '            tokenBalance = account.balance;\n', '            tokenAllowance = account.balance;\n', '        } else {\n', '            SErc20 sErc20 = SErc20(address(sToken));\n', '            EIP20Interface underlying = EIP20Interface(sErc20.underlying());\n', '            tokenBalance = underlying.balanceOf(account);\n', '            tokenAllowance = underlying.allowance(account, address(sToken));\n', '        }\n', '\n', '        return STokenBalances({\n', '            sToken: address(sToken),\n', '            balanceOf: balanceOf,\n', '            borrowBalanceCurrent: borrowBalanceCurrent,\n', '            balanceOfUnderlying: balanceOfUnderlying,\n', '            tokenBalance: tokenBalance,\n', '            tokenAllowance: tokenAllowance\n', '        });\n', '    }\n', '\n', '    function sTokenBalancesAll(SToken[] calldata sTokens, address payable account) external returns (STokenBalances[] memory) {\n', '        uint sTokenCount = sTokens.length;\n', '        STokenBalances[] memory res = new STokenBalances[](sTokenCount);\n', '        for (uint i = 0; i < sTokenCount; i++) {\n', '            res[i] = sTokenBalances(sTokens[i], account);\n', '        }\n', '        return res;\n', '    }\n', '\n', '    struct STokenUnderlyingPrice {\n', '        address sToken;\n', '        uint underlyingPrice;\n', '    }\n', '\n', '    function sTokenUnderlyingPrice(SToken sToken) public returns (STokenUnderlyingPrice memory) {\n', '        ComptrollerLensInterface comptroller = ComptrollerLensInterface(address(sToken.comptroller()));\n', '        PriceOracle priceOracle = comptroller.oracle();\n', '\n', '        return STokenUnderlyingPrice({\n', '            sToken: address(sToken),\n', '            underlyingPrice: priceOracle.getUnderlyingPrice(sToken)\n', '        });\n', '    }\n', '\n', '    function sTokenUnderlyingPriceAll(SToken[] calldata sTokens) external returns (STokenUnderlyingPrice[] memory) {\n', '        uint sTokenCount = sTokens.length;\n', '        STokenUnderlyingPrice[] memory res = new STokenUnderlyingPrice[](sTokenCount);\n', '        for (uint i = 0; i < sTokenCount; i++) {\n', '            res[i] = sTokenUnderlyingPrice(sTokens[i]);\n', '        }\n', '        return res;\n', '    }\n', '\n', '    struct AccountLimits {\n', '        SToken[] markets;\n', '        uint liquidity;\n', '        uint shortfall;\n', '    }\n', '\n', '    function getAccountLimits(ComptrollerLensInterface comptroller, address account) public returns (AccountLimits memory) {\n', '        (uint errorCode, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(account);\n', '        require(errorCode == 0);\n', '\n', '        return AccountLimits({\n', '            markets: comptroller.getAssetsIn(account),\n', '            liquidity: liquidity,\n', '            shortfall: shortfall\n', '        });\n', '    }\n', '\n', '    struct GovReceipt {\n', '        uint proposalId;\n', '        bool hasVoted;\n', '        bool support;\n', '        uint96 votes;\n', '    }\n', '\n', '    function getGovReceipts(GovernorAlpha governor, address voter, uint[] memory proposalIds) public view returns (GovReceipt[] memory) {\n', '        uint proposalCount = proposalIds.length;\n', '        GovReceipt[] memory res = new GovReceipt[](proposalCount);\n', '        for (uint i = 0; i < proposalCount; i++) {\n', '            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n', '            res[i] = GovReceipt({\n', '                proposalId: proposalIds[i],\n', '                hasVoted: receipt.hasVoted,\n', '                support: receipt.support,\n', '                votes: receipt.votes\n', '            });\n', '        }\n', '        return res;\n', '    }\n', '\n', '    struct GovProposal {\n', '        uint proposalId;\n', '        address proposer;\n', '        uint eta;\n', '        address[] targets;\n', '        uint[] values;\n', '        string[] signatures;\n', '        bytes[] calldatas;\n', '        uint startBlock;\n', '        uint endBlock;\n', '        uint forVotes;\n', '        uint againstVotes;\n', '        bool canceled;\n', '        bool executed;\n', '    }\n', '\n', '    function setProposal(GovProposal memory res, GovernorAlpha governor, uint proposalId) internal view {\n', '        (\n', '            ,\n', '            address proposer,\n', '            uint eta,\n', '            uint startBlock,\n', '            uint endBlock,\n', '            uint forVotes,\n', '            uint againstVotes,\n', '            bool canceled,\n', '            bool executed\n', '        ) = governor.proposals(proposalId);\n', '        res.proposalId = proposalId;\n', '        res.proposer = proposer;\n', '        res.eta = eta;\n', '        res.startBlock = startBlock;\n', '        res.endBlock = endBlock;\n', '        res.forVotes = forVotes;\n', '        res.againstVotes = againstVotes;\n', '        res.canceled = canceled;\n', '        res.executed = executed;\n', '    }\n', '\n', '    function getGovProposals(GovernorAlpha governor, uint[] calldata proposalIds) external view returns (GovProposal[] memory) {\n', '        GovProposal[] memory res = new GovProposal[](proposalIds.length);\n', '        for (uint i = 0; i < proposalIds.length; i++) {\n', '            (\n', '                address[] memory targets,\n', '                uint[] memory values,\n', '                string[] memory signatures,\n', '                bytes[] memory calldatas\n', '            ) = governor.getActions(proposalIds[i]);\n', '            res[i] = GovProposal({\n', '                proposalId: 0,\n', '                proposer: address(0),\n', '                eta: 0,\n', '                targets: targets,\n', '                values: values,\n', '                signatures: signatures,\n', '                calldatas: calldatas,\n', '                startBlock: 0,\n', '                endBlock: 0,\n', '                forVotes: 0,\n', '                againstVotes: 0,\n', '                canceled: false,\n', '                executed: false\n', '            });\n', '            setProposal(res[i], governor, proposalIds[i]);\n', '        }\n', '        return res;\n', '    }\n', '\n', '    struct StrikeBalanceMetadata {\n', '        uint balance;\n', '        uint votes;\n', '        address delegate;\n', '    }\n', '\n', '    function getStrikeBalanceMetadata(STRK strk, address account) external view returns (StrikeBalanceMetadata memory) {\n', '        return StrikeBalanceMetadata({\n', '            balance: strk.balanceOf(account),\n', '            votes: uint256(strk.getCurrentVotes(account)),\n', '            delegate: strk.delegates(account)\n', '        });\n', '    }\n', '\n', '    struct StrikeBalanceMetadataExt {\n', '        uint balance;\n', '        uint votes;\n', '        address delegate;\n', '        uint allocated;\n', '    }\n', '\n', '    function getStrikeBalanceMetadataExt(STRK strk, ComptrollerLensInterface comptroller, address account) external returns (StrikeBalanceMetadataExt memory) {\n', '        uint balance = strk.balanceOf(account);\n', '        comptroller.claimStrike(account);\n', '        uint newBalance = strk.balanceOf(account);\n', '        uint accrued = comptroller.strikeAccrued(account);\n', '        uint total = add(accrued, newBalance, "sum strk total");\n', '        uint allocated = sub(total, balance, "sub allocated");\n', '\n', '        return StrikeBalanceMetadataExt({\n', '            balance: balance,\n', '            votes: uint256(strk.getCurrentVotes(account)),\n', '            delegate: strk.delegates(account),\n', '            allocated: allocated\n', '        });\n', '    }\n', '\n', '    struct StrikeVotes {\n', '        uint blockNumber;\n', '        uint votes;\n', '    }\n', '\n', '    function getStrikeVotes(STRK strk, address account, uint32[] calldata blockNumbers) external view returns (StrikeVotes[] memory) {\n', '        StrikeVotes[] memory res = new StrikeVotes[](blockNumbers.length);\n', '        for (uint i = 0; i < blockNumbers.length; i++) {\n', '            res[i] = StrikeVotes({\n', '                blockNumber: uint256(blockNumbers[i]),\n', '                votes: uint256(strk.getPriorVotes(account, blockNumbers[i]))\n', '            });\n', '        }\n', '        return res;\n', '    }\n', '\n', '    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n', '        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n', '    }\n', '\n', '    function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '        return c;\n', '    }\n', '}']