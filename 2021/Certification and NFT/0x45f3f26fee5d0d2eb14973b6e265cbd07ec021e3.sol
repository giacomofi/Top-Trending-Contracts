['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-20\n', '*/\n', '\n', '// Sources flattened with hardhat v2.0.11 https://hardhat.org\n', '\n', '// File contracts/interfaces/IStrategy.sol\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IStrategy {\n', '    /// @notice Send the assets to the Strategy and call skim to invest them.\n', '    /// @param amount The amount of tokens to invest.\n', '    function skim(uint256 amount) external;\n', '\n', '    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\n', '    /// @param balance The amount of tokens the caller thinks it has invested.\n', '    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\n', '    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n', '    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n', '\n', '    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n', '    /// @dev The `actualAmount` should be very close to the amount.\n', "    /// The difference should NOT be used to report a loss. That's what harvest is for.\n", '    /// @param amount The requested amount the caller wants to withdraw.\n', '    /// @return actualAmount The real amount that is withdrawn.\n', '    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n', '\n', "    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    /// @param balance The amount of tokens the caller thinks it has invested.\n', '    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n', '    function exit(uint256 balance) external returns (int256 amountAdded);\n', '}\n', '\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// Audit on 5-Jan-2021 by Keno and BoringCrypto\n', '// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n', '// Edited by BoringCrypto\n', '\n', 'contract BoringOwnableData {\n', '    address public owner;\n', '    address public pendingOwner;\n', '}\n', '\n', 'contract BoringOwnable is BoringOwnableData {\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice `owner` defaults to msg.sender on construction.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n', '    /// Can only be invoked by the current `owner`.\n', '    /// @param newOwner Address of the new owner.\n', '    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n', '    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) public onlyOwner {\n', '        if (direct) {\n', '            // Checks\n', '            require(newOwner != address(0) || renounce, "Ownable: zero address");\n', '\n', '            // Effects\n', '            emit OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '            pendingOwner = address(0);\n', '        } else {\n', '            // Effects\n', '            pendingOwner = newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n', '    function claimOwnership() public {\n', '        address _pendingOwner = pendingOwner;\n', '\n', '        // Checks\n', '        require(msg.sender == _pendingOwner, "Ownable: caller != pending owner");\n', '\n', '        // Effects\n', '        emit OwnershipTransferred(owner, _pendingOwner);\n', '        owner = _pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /// @notice Only allows the `owner` to execute the function.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\n', 'library BoringMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\n', 'library BoringMath64 {\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\n', 'library BoringMath32 {\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// solhint-disable avoid-low-level-calls\n', '\n', 'library BoringERC20 {\n', '    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n', '    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n', '    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n', '    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n', '    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n', '\n', '    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n', '        if (data.length >= 64) {\n', '            return abi.decode(data, (string));\n', '        } else if (data.length == 32) {\n', '            uint8 i = 0;\n', '            while(i < 32 && data[i] != 0) {\n', '                i++;\n', '            }\n', '            bytes memory bytesArray = new bytes(i);\n', '            for (i = 0; i < 32 && data[i] != 0; i++) {\n', '                bytesArray[i] = data[i];\n', '            }\n', '            return string(bytesArray);\n', '        } else {\n', '            return "???";\n', '        }\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token symbol.\n', '    function safeSymbol(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token name.\n', '    function safeName(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (uint8) Token decimals.\n', '    function safeDecimals(IERC20 token) internal view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param from Transfer tokens from.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '\n', '// File contracts/strategies/CompoundStrategy.sol\n', '\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '// solhint-disable avoid-low-level-calls\n', '// solhint-disable not-rely-on-time\n', '// solhint-disable no-empty-blocks\n', '// solhint-disable avoid-tx-origin\n', '\n', 'interface IFactory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface IPair {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', 'interface IcToken is IERC20 {\n', '    function mint(uint256 mintAmount) external returns (uint256);\n', '\n', '    function redeem(uint256 redeemTokens) external returns (uint256);\n', '\n', '    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n', '\n', '    function balanceOfUnderlying(address account) external returns (uint256);\n', '}\n', '\n', 'contract CompoundStrategy is IStrategy, BoringOwnable {\n', '    using BoringMath for uint256;\n', '    using BoringERC20 for IERC20;\n', '    using BoringERC20 for IcToken;\n', '\n', '    address public immutable bentobox;\n', '    IERC20 public immutable token;\n', '    IcToken public immutable cToken;\n', '    IERC20 public immutable compToken;\n', '    IERC20 public immutable weth;\n', '    IFactory public immutable factory;\n', '    bool public exited;\n', '\n', '    constructor(\n', '        address bentobox_,\n', '        IFactory factory_,\n', '        IERC20 token_,\n', '        IcToken cToken_,\n', '        IERC20 compToken_,\n', '        IERC20 weth_\n', '    ) public {\n', '        bentobox = bentobox_;\n', '        factory = factory_;\n', '        token = token_;\n', '        cToken = cToken_;\n', '        compToken = compToken_;\n', '        weth = weth_;\n', '\n', '        token_.approve(address(cToken_), type(uint256).max);\n', '    }\n', '\n', '    modifier onlyBentobox {\n', '        // Only the bentobox can call harvest on this strategy\n', '        require(msg.sender == bentobox, "CompoundStrategy: only bento");\n', '        require(!exited, "CompoundStrategy: exited");\n', '        _;\n', '    }\n', '\n', '    function _swapAll(\n', '        IERC20 fromToken,\n', '        IERC20 toToken,\n', '        address to\n', '    ) internal returns (uint256 amountOut) {\n', '        IPair pair = IPair(factory.getPair(address(fromToken), address(toToken)));\n', '        require(address(pair) != address(0), "CompoundStrategy: Cannot convert");\n', '\n', '        uint256 amountIn = fromToken.balanceOf(address(this));\n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '        uint256 amountInWithFee = amountIn.mul(997);\n', '        IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '        if (fromToken < toToken) {\n', '            amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);\n', '            pair.swap(0, amountOut, to, new bytes(0));\n', '        } else {\n', '            amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);\n', '            pair.swap(amountOut, 0, to, new bytes(0));\n', '        }\n', '    }\n', '\n', '    // Send the assets to the Strategy and call skim to invest them\n', '    /// @inheritdoc IStrategy\n', '    function skim(uint256 amount) external override onlyBentobox {\n', '        require(cToken.mint(amount) == 0, "CompoundStrategy: mint error");\n', '    }\n', '\n', '    // Harvest any profits made converted to the asset and pass them to the caller\n', '    /// @inheritdoc IStrategy\n', '    function harvest(uint256 balance, address sender) external override onlyBentobox returns (int256 amountAdded) {\n', "        // To prevent anyone from using flash loans to 'steal' part of the profits, only EOA is allowed to call harvest\n", '        require(sender == tx.origin, "CompoundStrategy: EOA only");\n', '        // Get the amount of tokens that the cTokens currently represent\n', '        uint256 tokenBalance = cToken.balanceOfUnderlying(address(this));\n', '        // Convert enough cToken to take out the profit\n', '        // If the amount is negative due to rounding (near impossible), just revert. Should be positive soon enough.\n', '        require(cToken.redeemUnderlying(tokenBalance.sub(balance)) == 0, "CompoundStrategy: profit fail");\n', '\n', '        // Find out how much has been added (+ sitting on the contract from harvestCOMP)\n', '        uint256 amountAdded_ = token.balanceOf(address(this));\n', '        // Transfer the profit to the bentobox, the amountAdded at this point matches the amount transferred\n', '        token.safeTransfer(bentobox, amountAdded_);\n', '\n', '        return int256(amountAdded_);\n', '    }\n', '\n', '    function harvestCOMP(uint256 minAmount) public onlyOwner {\n', "        // To prevent flash loan sandwich attacks to 'steal' the profit, only the owner can harvest the COMP\n", '        // Swap all COMP to WETH\n', '        _swapAll(compToken, weth, address(this));\n', '        // Swap all WETH to token and leave it on the contract to be swept up in the next harvest\n', '        require(_swapAll(weth, token, address(this)) >= minAmount, "CompoundStrategy: not enough");\n', '    }\n', '\n', '    // Withdraw assets.\n', '    /// @inheritdoc IStrategy\n', '    function withdraw(uint256 amount) external override onlyBentobox returns (uint256 actualAmount) {\n', "        // Convert enough cToken to take out 'amount' tokens\n", '        require(cToken.redeemUnderlying(amount) == 0, "CompoundStrategy: redeem fail");\n', '\n', '        // Make sure we send and report the exact same amount of tokens by using balanceOf\n', '        actualAmount = token.balanceOf(address(this));\n', '        token.safeTransfer(bentobox, actualAmount);\n', '    }\n', '\n', "    // Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    /// @inheritdoc IStrategy\n', '    function exit(uint256 balance) external override onlyBentobox returns (int256 amountAdded) {\n', '        // Get the amount of tokens that the cTokens currently represent\n', '        uint256 tokenBalance = cToken.balanceOfUnderlying(address(this));\n', '        // Get the actual token balance of the cToken contract\n', '        uint256 available = token.balanceOf(address(cToken));\n', '\n', '        // Check that the cToken contract has enough balance to pay out in full\n', '        if (tokenBalance <= available) {\n', '            // If there are more tokens available than our full position, take all based on cToken balance (continue if unsuccesful)\n', '            try cToken.redeem(cToken.balanceOf(address(this))) {} catch {}\n', '        } else {\n', '            // Otherwise redeem all available and take a loss on the missing amount (continue if unsuccesful)\n', '            try cToken.redeemUnderlying(available) {} catch {}\n', '        }\n', '\n', '        // Check balance of token on the contract\n', '        uint256 amount = token.balanceOf(address(this));\n', '        // Calculate tokens added (or lost)\n', '        amountAdded = int256(amount) - int256(balance);\n', '        // Transfer all tokens to bentobox\n', '        token.safeTransfer(bentobox, amount);\n', '        // Flag as exited, allowing the owner to manually deal with any amounts available later\n', '        exited = true;\n', '    }\n', '\n', '    function afterExit(\n', '        address to,\n', '        uint256 value,\n', '        bytes memory data\n', '    ) public onlyOwner returns (bool success) {\n', "        // After exited, the owner can perform ANY call. This is to rescue any funds that didn't get released during exit or\n", '        // got earned afterwards due to vesting or airdrops, etc.\n', '        require(exited, "CompoundStrategy: Not exited");\n', '        (success, ) = to.call{value: value}(data);\n', '    }\n', '}']