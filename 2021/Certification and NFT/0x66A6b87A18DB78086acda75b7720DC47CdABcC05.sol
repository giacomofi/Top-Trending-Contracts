['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../interfaces/IUniswapV2Pair.sol";\n', 'import "../interfaces/IUniswapV2Factory.sol";\n', 'import "../interfaces/IPriceOracle.sol";\n', 'import "../interfaces/IExtendedAggregator.sol";\n', 'import "../misc/SafeMath.sol";\n', 'import "../misc/Math.sol";\n', '\n', '/** @title UniswapV2PriceProvider\n', ' * @notice Price provider for a Uniswap V2 pair token\n', " * It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the weighted arithmetic mean formula.\n", ' * If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with the constant invariant K.\n', ' */\n', '\n', 'contract UniswapV2PriceProvider is IExtendedAggregator {\n', '    using SafeMath for uint256;\n', '\n', '    IUniswapV2Pair public immutable pair;\n', '    address[] public tokens;\n', '    bool[] public isPeggedToEth;\n', '    uint8[] public decimals;\n', '    IPriceOracle immutable priceOracle;\n', '    uint256 public immutable maxPriceDeviation;\n', '\n', '    /**\n', '     * UniswapV2PriceProvider constructor.\n', '     * @param _pair Uniswap V2 pair address.\n', '     * @param _isPeggedToEth For each token, true if it is pegged to ETH.\n', '     * @param _decimals Number of decimals for each token.\n', '     * @param _priceOracle Aave price oracle.\n', '     * @param _maxPriceDeviation Threshold of spot prices deviation: 10Ë†16 represents a 1% deviation.\n', '     */\n', '    constructor(\n', '        IUniswapV2Pair _pair,\n', '        bool[] memory _isPeggedToEth,\n', '        uint8[] memory _decimals,\n', '        IPriceOracle _priceOracle,\n', '        uint256 _maxPriceDeviation\n', '    ) public {\n', '        require(_isPeggedToEth.length == 2, "ERR_INVALID_PEGGED_LENGTH");\n', '        require(_decimals.length == 2, "ERR_INVALID_DECIMALS_LENGTH");\n', '        require(\n', '            _decimals[0] <= 18 && _decimals[1] <= 18,\n', '            "ERR_INVALID_DECIMALS"\n', '        );\n', '        require(\n', '            address(_priceOracle) != address(0),\n', '            "ERR_INVALID_PRICE_PROVIDER"\n', '        );\n', '        require(_maxPriceDeviation < Math.BONE, "ERR_INVALID_PRICE_DEVIATION");\n', '\n', '        pair = _pair;\n', '        //Get tokens\n', '        tokens.push(_pair.token0());\n', '        tokens.push(_pair.token1());\n', '        isPeggedToEth = _isPeggedToEth;\n', '        decimals = _decimals;\n', '        priceOracle = _priceOracle;\n', '        maxPriceDeviation = _maxPriceDeviation;\n', '    }\n', '\n', '    /**\n', '     * Returns the token balance in ethers by multiplying its reserves with its price in ethers.\n', '     * @param index Token index.\n', '     * @param reserve Token reserves.\n', '     */\n', '    function getEthBalanceByToken(uint256 index, uint112 reserve)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 pi =\n', '            isPeggedToEth[index]\n', '                ? Math.BONE\n', '                : uint256(priceOracle.getAssetPrice(tokens[index]));\n', '        require(pi > 0, "ERR_NO_ORACLE_PRICE");\n', '        uint256 missingDecimals = uint256(18).sub(decimals[index]);\n', '        uint256 bi = uint256(reserve).mul(10**(missingDecimals));\n', '        return Math.bmul(bi, pi);\n', '    }\n', '\n', '    /**\n', '     * Returns true if there is a price deviation.\n', '     * @param ethTotal_0 Total eth for token 0.\n', '     * @param ethTotal_1 Total eth for token 1.\n', '     */\n', '    function hasDeviation(uint256 ethTotal_0, uint256 ethTotal_1)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        //Check for a price deviation\n', '        uint256 price_deviation = Math.bdiv(ethTotal_0, ethTotal_1);\n', '        if (\n', '            price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\n', '            price_deviation < (Math.BONE.sub(maxPriceDeviation))\n', '        ) {\n', '            return true;\n', '        }\n', '        price_deviation = Math.bdiv(ethTotal_1, ethTotal_0);\n', '        if (\n', '            price_deviation > (Math.BONE.add(maxPriceDeviation)) ||\n', '            price_deviation < (Math.BONE.sub(maxPriceDeviation))\n', '        ) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Calculates the price of the pair token using the formula of arithmetic mean.\n', '     * @param ethTotal_0 Total eth for token 0.\n', '     * @param ethTotal_1 Total eth for token 1.\n', '     */\n', '    function getArithmeticMean(uint256 ethTotal_0, uint256 ethTotal_1)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalEth = ethTotal_0 + ethTotal_1;\n', '        return Math.bdiv(totalEth, getTotalSupplyAtWithdrawal());\n', '    }\n', '\n', '    /**\n', '     * Calculates the price of the pair token using the formula of weighted geometric mean.\n', '     * @param ethTotal_0 Total eth for token 0.\n', '     * @param ethTotal_1 Total eth for token 1.\n', '     */\n', '    function getWeightedGeometricMean(uint256 ethTotal_0, uint256 ethTotal_1)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 square = Math.bsqrt(Math.bmul(ethTotal_0, ethTotal_1), true);\n', '        return\n', '            Math.bdiv(\n', '                Math.bmul(Math.TWO_BONES, square),\n', '                getTotalSupplyAtWithdrawal()\n', '            );\n', '    }\n', '\n', '    /**\n', '     * Returns Uniswap V2 pair total supply at the time of withdrawal.\n', '     */\n', '    function getTotalSupplyAtWithdrawal()\n', '        private\n', '        view\n', '        returns (uint256 totalSupply)\n', '    {\n', '        totalSupply = pair.totalSupply();\n', '        address feeTo =\n', '            IUniswapV2Factory(IUniswapV2Pair(pair).factory()).feeTo();\n', '        bool feeOn = feeTo != address(0);\n', '        if (feeOn) {\n', '            uint256 kLast = IUniswapV2Pair(pair).kLast();\n', '            if (kLast != 0) {\n', '                (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\n', '                uint256 rootK =\n', '                    Math.bsqrt(uint256(reserve_0).mul(reserve_1), false);\n', '                uint256 rootKLast = Math.bsqrt(kLast, false);\n', '                if (rootK > rootKLast) {\n', '                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n', '                    uint256 denominator = rootK.mul(5).add(rootKLast);\n', '                    uint256 liquidity = numerator / denominator;\n', '                    totalSupply = totalSupply.add(liquidity);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns Uniswap V2 pair address.\n', '     */\n', '    function getPair() external view returns (IUniswapV2Pair) {\n', '        return pair;\n', '    }\n', '\n', '    /**\n', '     * Returns all tokens.\n', '     */\n', '    function getTokens() external view returns (address[] memory) {\n', '        return tokens;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the LP shares token\n', '     * @return address of the LP shares token\n', '     */\n', '    function getToken() external view override returns (address) {\n', '        return address(pair);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns token type for categorization\n', '     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\n', '     */\n', '    function getTokenType()\n', '        external\n', '        pure\n', '        override\n', '        returns (IExtendedAggregator.TokenType)\n', '    {\n', '        return IExtendedAggregator.TokenType.Complex;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of tokens that composes the LP shares\n', '     * @return address[] memory of token addresses\n', '     */\n', '    function getSubTokens() external view override returns (address[] memory) {\n', '        return tokens;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the platform id to categorize the price aggregator\n', '     * @return uint256 1 = Uniswap, 2 = Balancer\n', '     */\n', '    function getPlatformId()\n', '        external\n', '        pure\n', '        override\n', '        returns (IExtendedAggregator.PlatformId)\n', '    {\n', '        return IExtendedAggregator.PlatformId.Uniswap;\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the pair's token price.\n", "     *   It calculates the price using Chainlink as an external price source and the pair's tokens reserves using the arithmetic mean formula.\n", '     *   If there is a price deviation, instead of the reserves, it uses a weighted geometric mean with constant invariant K.\n', '     * @return int256 price\n', '     */\n', '    function latestAnswer() external view override returns (int256) {\n', '        //Get token reserves in ethers\n', '        (uint112 reserve_0, uint112 reserve_1, ) = pair.getReserves();\n', '        uint256 ethTotal_0 = getEthBalanceByToken(0, reserve_0);\n', '        uint256 ethTotal_1 = getEthBalanceByToken(1, reserve_1);\n', '\n', '        if (hasDeviation(ethTotal_0, ethTotal_1)) {\n', '            //Calculate the weighted geometric mean\n', '            return int256(getWeightedGeometricMean(ethTotal_0, ethTotal_1));\n', '        } else {\n', '            //Calculate the arithmetic mean\n', '            return int256(getArithmeticMean(ethTotal_0, ethTotal_1));\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IUniswapV2Pair {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function token0() external view returns (address);\n', '\n', '  function token1() external view returns (address);\n', '\n', '  function getReserves()\n', '    external\n', '    view\n', '    returns (\n', '      uint112 reserve0,\n', '      uint112 reserve1,\n', '      uint32 blockTimestampLast\n', '    );\n', '\n', '  function kLast() external view returns (uint256);\n', '\n', '  function factory() external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IUniswapV2Factory {\n', '  function feeTo() external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', '/************\n', '@title IPriceOracle interface\n', '@notice Interface for the Aave price oracle.*/\n', 'interface IPriceOracle {\n', '  /***********\n', '    @dev returns the asset price in ETH\n', '     */\n', '  function getAssetPrice(address _asset) external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IExtendedAggregator {\n', '    enum TokenType {Invalid, Simple, Complex}\n', '\n', '    enum PlatformId {Invalid, Simple, Uniswap, Balancer}\n', '\n', '    /**\n', '     * @dev Returns the LP shares token\n', '     * @return address of the LP shares token\n', '     */\n', '    function getToken() external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns token type for categorization\n', '     * @return uint256 1 = Simple (Native or plain ERC20 tokens like DAI), 2 = Complex (LP Tokens, Staked tokens)\n', '     */\n', '    function getTokenType() external pure returns (TokenType);\n', '\n', '    /**\n', '     * @dev Returns the number of tokens that composes the LP shares\n', '     * @return address[] memory of token addresses\n', '     */\n', '    function getSubTokens() external view returns (address[] memory);\n', '\n', '    /**\n', '     * @dev Returns the platform id to categorize the price aggregator\n', '     * @return uint256 1 = Uniswap, 2 = Balancer\n', '     */\n', '    function getPlatformId() external pure returns (PlatformId);\n', '\n', '    /**\n', '     * @dev Returns the latest price\n', '     * @return int256 price\n', '     */\n', '    function latestAnswer() external view returns (int256);\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "    require((z = x + y) >= x, 'ds-math-add-overflow');\n", '  }\n', '\n', '  function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "    require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '  }\n', '\n', '  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "    require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '  }\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', '// a library for performing various math operations\n', '\n', 'library Math {\n', '  uint256 public constant BONE = 10**18;\n', '  uint256 public constant TWO_BONES = 2 * 10**18;\n', '\n', '  /**\n', '   * @notice Returns the square root of an uint256 x using the Babylonian method\n', '   * @param y The number to calculate the sqrt from\n', '   * @param bone True when y has 18 decimals\n', '   */\n', '  function bsqrt(uint256 y, bool bone) internal pure returns (uint256 z) {\n', '    if (y > 3) {\n', '      z = y;\n', '      uint256 x = y / 2 + 1;\n', '      while (x < z) {\n', '        z = x;\n', '        if (bone) {\n', '          x = (bdiv(y, x) + x) / 2;\n', '        } else {\n', '          x = (y / x + x) / 2;\n', '        }\n', '      }\n', '    } else if (y != 0) {\n', '      z = 1;\n', '    }\n', '  }\n', '\n', '  function bmul(\n', '    uint256 a,\n', '    uint256 b //Bone mul\n', '  ) internal pure returns (uint256) {\n', '    uint256 c0 = a * b;\n', "    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\n", '    uint256 c1 = c0 + (BONE / 2);\n', "    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\n", '    uint256 c2 = c1 / BONE;\n', '    return c2;\n', '  }\n', '\n', '  function bdiv(\n', '    uint256 a,\n', '    uint256 b //Bone div\n', '  ) internal pure returns (uint256) {\n', "    require(b != 0, 'ERR_DIV_ZERO');\n", '    uint256 c0 = a * BONE;\n', "    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\n", '    uint256 c1 = c0 + (b / 2);\n', "    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\n", '    uint256 c2 = c1 / b;\n', '    return c2;\n', '  }\n', '}']