['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '// File: contracts/lib/ERC20.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/MathUint.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', 'library MathUint\n', '{\n', '    using MathUint for uint;\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function add64(\n', '        uint64 a,\n', '        uint64 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint64 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// File: contracts/core/iface/IAgentRegistry.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'interface IAgent{}\n', '\n', 'abstract contract IAgentRegistry\n', '{\n', '    /// @dev Returns whether an agent address is an agent of an account owner\n', '    /// @param owner The account owner.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address owner,\n', '        address agent\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is an agent of all account owners\n', '    /// @param owners The account owners.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address[] calldata owners,\n', '        address            agent\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is a universal agent.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is a universal agent, else false\n', '    function isUniversalAgent(address agent)\n', '        public\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Claimable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/core/iface/IBlockVerifier.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IBlockVerifier\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'abstract contract IBlockVerifier is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event CircuitRegistered(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    event CircuitDisabled(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    // -- Public functions --\n', '\n', '    /// @dev Sets the verifying key for the specified circuit.\n', '    ///      Every block permutation needs its own circuit and thus its own set of\n', '    ///      verification keys. Only a limited number of block sizes per block\n', '    ///      type are supported.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param vk The verification key\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Disables the use of the specified circuit.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Verifies blocks with the given public data and proofs.\n', '    ///      Verifying a block makes sure all requests handled in the block\n', '    ///      are correctly handled by the operator.\n', '    /// @param blockType The type of block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param publicInputs The hash of all the public data of the blocks\n', '    /// @param proofs The ZK proofs proving that the blocks are correct\n', '    /// @return True if the block is valid, false otherwise\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit with the specified parameters is registered.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is registered, false otherwise\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit can still be used to commit new blocks.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is enabled, false otherwise\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/core/iface/IDepositContract.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/core/iface/ILoopringV3.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ILoopringV3\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'abstract contract ILoopringV3 is Claimable\n', '{\n', '    // == Events ==\n', '    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\n', '    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\n', '    event ExchangeStakeBurned(address exchangeAddr, uint amount);\n', '    event SettingsUpdated(uint time);\n', '\n', '    // == Public Variables ==\n', '    mapping (address => uint) internal exchangeStake;\n', '\n', '    uint    public totalStake;\n', '    address public blockVerifierAddress;\n', '    uint    public forcedWithdrawalFee;\n', '    uint    public tokenRegistrationFeeLRCBase;\n', '    uint    public tokenRegistrationFeeLRCDelta;\n', '    uint8   public protocolTakerFeeBips;\n', '    uint8   public protocolMakerFeeBips;\n', '\n', '    address payable public protocolFeeVault;\n', '\n', '    // == Public Functions ==\n', '\n', '    /// @dev Returns the LRC token address\n', '    /// @return the LRC token address\n', '    function lrcAddress()\n', '        external\n', '        view\n', '        virtual\n', '        returns (address);\n', '\n', '    /// @dev Updates the global exchange settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,   // address(0) not allowed\n', '        address _blockVerifierAddress,       // address(0) not allowed\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Updates the global protocol fee settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount of staked LRC for an exchange.\n', '    /// @param exchangeAddr The address of the exchange\n', '    /// @return stakedLRC The amount of LRC\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Burns a certain amount of staked LRC for a specific exchange.\n', '    ///      This function is meant to be called only from exchange contracts.\n', '    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\n', '    ///         the staked amount, all staked LRC will be burned.\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint burnedLRC);\n', '\n', '    /// @dev Stakes more LRC for an exchange.\n', '    /// @param  exchangeAddr The address of the exchange\n', '    /// @param  amountLRC The amount of LRC to stake\n', '    /// @return stakedLRC The total amount of LRC staked for the exchange\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\n', '    ///      This function is meant to be called only from within exchange contracts.\n', '    /// @param  recipient The address to receive LRC\n', '    /// @param  requestedAmount The amount of LRC to withdraw\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Gets the protocol fee values for an exchange.\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    function getProtocolFeeValues(\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        );\n', '}\n', '\n', '// File: contracts/core/iface/ExchangeData.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeData\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ExchangeData\n', '{\n', '    // -- Enums --\n', '    enum TransactionType\n', '    {\n', '        NOOP,\n', '        DEPOSIT,\n', '        WITHDRAWAL,\n', '        TRANSFER,\n', '        SPOT_TRADE,\n', '        ACCOUNT_UPDATE,\n', '        AMM_UPDATE,\n', '        SIGNATURE_VERIFICATION\n', '    }\n', '\n', '    // -- Structs --\n', '    struct Token\n', '    {\n', '        address token;\n', '    }\n', '\n', '    struct ProtocolFeeData\n', '    {\n', '        uint32 syncedAt; // only valid before 2105 (85 years to go)\n', '        uint8  takerFeeBips;\n', '        uint8  makerFeeBips;\n', '        uint8  previousTakerFeeBips;\n', '        uint8  previousMakerFeeBips;\n', '    }\n', '\n', '    // General auxiliary data for each conditional transaction\n', '    struct AuxiliaryData\n', '    {\n', '        uint  txIndex;\n', '        bool  approved;\n', '        bytes data;\n', '    }\n', '\n', '    // This is the (virtual) block the owner  needs to submit onchain to maintain the\n', '    // per-exchange (virtual) blockchain.\n', '    struct Block\n', '    {\n', '        uint8      blockType;\n', '        uint16     blockSize;\n', '        uint8      blockVersion;\n', '        bytes      data;\n', '        uint256[8] proof;\n', '\n', '        // Whether we should store the @BlockInfo for this block on-chain.\n', '        bool storeBlockInfoOnchain;\n', '\n', '        // Block specific data that is only used to help process the block on-chain.\n', '        // It is not used as input for the circuits and it is not necessary for data-availability.\n', '        // This bytes array contains the abi encoded AuxiliaryData[] data.\n', '        bytes auxiliaryData;\n', '\n', '        // Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '        // the multihash of the IPFS file that contains the block data.\n', '        bytes offchainData;\n', '    }\n', '\n', '    struct BlockInfo\n', '    {\n', '        // The time the block was submitted on-chain.\n', '        uint32  timestamp;\n', '        // The public data hash of the block (the 28 most significant bytes).\n', '        bytes28 blockDataHash;\n', '    }\n', '\n', '    // Represents an onchain deposit request.\n', '    struct Deposit\n', '    {\n', '        uint96 amount;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    // A forced withdrawal request.\n', "    // If the actual owner of the account initiated the request (we don't know who the owner is\n", '    // at the time the request is being made) the full balance will be withdrawn.\n', '    struct ForcedWithdrawal\n', '    {\n', '        address owner;\n', '        uint64  timestamp;\n', '    }\n', '\n', '    struct Constants\n', '    {\n', '        uint SNARK_SCALAR_FIELD;\n', '        uint MAX_OPEN_FORCED_REQUESTS;\n', '        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\n', '        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\n', '        uint MAX_NUM_ACCOUNTS;\n', '        uint MAX_NUM_TOKENS;\n', '        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\n', '        uint MIN_TIME_IN_SHUTDOWN;\n', '        uint TX_DATA_AVAILABILITY_SIZE;\n', '        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\n', '    }\n', '\n', '    // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\n', '    uint public constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '\n', '    uint public constant MAX_OPEN_FORCED_REQUESTS = 4096;\n', '    uint public constant MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE = 15 days;\n', '    uint public constant TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS = 7 days;\n', '    uint public constant MAX_NUM_ACCOUNTS = 2 ** 32;\n', '    uint public constant MAX_NUM_TOKENS = 2 ** 16;\n', '    uint public constant MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED = 7 days;\n', '    uint public constant MIN_TIME_IN_SHUTDOWN = 30 days;\n', '    // The amount of bytes each rollup transaction uses in the block data for data-availability.\n', '    // This is the maximum amount of bytes of all different transaction types.\n', '    uint32 public constant MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND = 15 days;\n', '    uint32 public constant ACCOUNTID_PROTOCOLFEE = 0;\n', '\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE = 68;\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE_PART_1 = 29;\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE_PART_2 = 39;\n', '\n', '    struct AccountLeaf\n', '    {\n', '        uint32   accountID;\n', '        address  owner;\n', '        uint     pubKeyX;\n', '        uint     pubKeyY;\n', '        uint32   nonce;\n', '        uint     feeBipsAMM;\n', '    }\n', '\n', '    struct BalanceLeaf\n', '    {\n', '        uint16   tokenID;\n', '        uint96   balance;\n', '        uint96   weightAMM;\n', '        uint     storageRoot;\n', '    }\n', '\n', '    struct MerkleProof\n', '    {\n', '        ExchangeData.AccountLeaf accountLeaf;\n', '        ExchangeData.BalanceLeaf balanceLeaf;\n', '        uint[48]                 accountMerkleProof;\n', '        uint[24]                 balanceMerkleProof;\n', '    }\n', '\n', '    struct BlockContext\n', '    {\n', '        bytes32 DOMAIN_SEPARATOR;\n', '        uint32  timestamp;\n', '    }\n', '\n', '    // Represents the entire exchange state except the owner of the exchange.\n', '    struct State\n', '    {\n', '        uint32  maxAgeDepositUntilWithdrawable;\n', '        bytes32 DOMAIN_SEPARATOR;\n', '\n', '        ILoopringV3      loopring;\n', '        IBlockVerifier   blockVerifier;\n', '        IAgentRegistry   agentRegistry;\n', '        IDepositContract depositContract;\n', '\n', '\n', '        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\n', '        // stores balances for users using an account model.\n', '        bytes32 merkleRoot;\n', '\n', '        // List of all blocks\n', '        mapping(uint => BlockInfo) blocks;\n', '        uint  numBlocks;\n', '\n', '        // List of all tokens\n', '        Token[] tokens;\n', '\n', '        // A map from a token to its tokenID + 1\n', '        mapping (address => uint16) tokenToTokenId;\n', '\n', '        // A map from an accountID to a tokenID to if the balance is withdrawn\n', '        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\n', '\n', '        // A map from an account to a token to the amount withdrawable for that account.\n', '        // This is only used when the automatic distribution of the withdrawal failed.\n', '        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\n', '\n', '        // A map from an account to a token to the forced withdrawal (always full balance)\n', '        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\n', '\n', '        // A map from an address to a token to a deposit\n', '        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\n', '\n', '        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\n', '        mapping (address => mapping (bytes32 => bool)) approvedTx;\n', '\n', '        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\n', '        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\n', '\n', '\n', '        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\n', '        uint32 numPendingForcedTransactions;\n', '\n', '        // Cached data for the protocol fee\n', '        ProtocolFeeData protocolFeeData;\n', '\n', '        // Time when the exchange was shutdown\n', '        uint shutdownModeStartTime;\n', '\n', '        // Time when the exchange has entered withdrawal mode\n', '        uint withdrawalModeStartTime;\n', '\n', '        // Last time the protocol fee was withdrawn for a specific token\n', '        mapping (address => uint) protocolFeeLastWithdrawnTime;\n', '    }\n', '}\n', '\n', '// File: contracts/core/iface/IExchangeV3.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '/// @title IExchangeV3\n', '/// @dev Note that Claimable and RentrancyGuard are inherited here to\n', '///      ensure all data members are declared on IExchangeV3 to make it\n', '///      easy to support upgradability through proxies.\n', '///\n', '///      Subclasses of this contract must NOT define constructor to\n', '///      initialize data.\n', '///\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'abstract contract IExchangeV3 is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event ExchangeCloned(\n', '        address exchangeAddress,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '    );\n', '\n', '    event TokenRegistered(\n', '        address token,\n', '        uint16  tokenId\n', '    );\n', '\n', '    event Shutdown(\n', '        uint timestamp\n', '    );\n', '\n', '    event WithdrawalModeActivated(\n', '        uint timestamp\n', '    );\n', '\n', '    event BlockSubmitted(\n', '        uint    indexed blockIdx,\n', '        bytes32         merkleRoot,\n', '        bytes32         publicDataHash\n', '    );\n', '\n', '    event DepositRequested(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint16  tokenId,\n', '        uint96  amount\n', '    );\n', '\n', '    event ForcedWithdrawalRequested(\n', '        address owner,\n', '        address token,\n', '        uint32  accountID\n', '    );\n', '\n', '    event WithdrawalCompleted(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event WithdrawalFailed(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event ProtocolFeesUpdated(\n', '        uint8 takerFeeBips,\n', '        uint8 makerFeeBips,\n', '        uint8 previousTakerFeeBips,\n', '        uint8 previousMakerFeeBips\n', '    );\n', '\n', '    event TransactionApproved(\n', '        address owner,\n', '        bytes32 transactionHash\n', '    );\n', '\n', '\n', '    // -- Initialization --\n', '    /// @dev Initializes this exchange. This method can only be called once.\n', '    /// @param  loopring The LoopringV3 contract address.\n', '    /// @param  owner The owner of this exchange.\n', '    /// @param  genesisMerkleRoot The initial Merkle tree state.\n', '    function initialize(\n', '        address loopring,\n', '        address owner,\n', '        bytes32 genesisMerkleRoot\n', '        )\n', '        virtual\n', '        external;\n', '\n', '    /// @dev Initialized the agent registry contract used by the exchange.\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param agentRegistry The agent registry contract to be used\n', '    function setAgentRegistry(address agentRegistry)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the agent registry contract used by the exchange.\n', '    /// @return the agent registry contract\n', '    function getAgentRegistry()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IAgentRegistry);\n', '\n', '    ///      Can only be called by the exchange owner once.\n', '    /// @param depositContract The deposit contract to be used\n', '    function setDepositContract(address depositContract)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev refresh the blockVerifier contract which maybe changed in loopringV3 contract.\n', '    function refreshBlockVerifier()\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the deposit contract used by the exchange.\n', '    /// @return the deposit contract\n', '    function getDepositContract()\n', '        external\n', '        virtual\n', '        view\n', '        returns (IDepositContract);\n', '\n', '    // @dev Exchange owner withdraws fees from the exchange.\n', '    // @param token Fee token address\n', '    // @param feeRecipient Fee recipient address\n', '    function withdrawExchangeFees(\n', '        address token,\n', '        address feeRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    // -- Constants --\n', '    /// @dev Returns a list of constants used by the exchange.\n', '    /// @return constants The list of constants.\n', '    function getConstants()\n', '        external\n', '        virtual\n', '        pure\n', '        returns(ExchangeData.Constants memory);\n', '\n', '    // -- Mode --\n', '    /// @dev Returns hether the exchange is in withdrawal mode.\n', '    /// @return Returns true if the exchange is in withdrawal mode, else false.\n', '    function isInWithdrawalMode()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether the exchange is shutdown.\n', '    /// @return Returns true if the exchange is shutdown, else false.\n', '    function isShutdown()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Tokens --\n', '    /// @dev Registers an ERC20 token for a token id. Note that different exchanges may have\n', '    ///      different ids for the same ERC20 token.\n', '    ///\n', '    ///      Please note that 1 is reserved for Ether (ETH), 2 is reserved for Wrapped Ether (ETH),\n', '    ///      and 3 is reserved for Loopring Token (LRC).\n', '    ///\n', '    ///      This function is only callable by the exchange owner.\n', '    ///\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function registerToken(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the id of a registered token.\n', "    /// @param  tokenAddress The token's address\n", "    /// @return tokenID The token's ID in this exchanges.\n", '    function getTokenID(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint16 tokenID);\n', '\n', '    /// @dev Returns the address of a registered token.\n', "    /// @param  tokenID The token's ID in this exchanges.\n", "    /// @return tokenAddress The token's address\n", '    function getTokenAddress(\n', '        uint16 tokenID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address tokenAddress);\n', '\n', '    // -- Stakes --\n', '    /// @dev Gets the amount of LRC the owner has staked onchain for this exchange.\n', '    ///      The stake will be burned if the exchange does not fulfill its duty by\n', '    ///      processing user requests in time. Please note that order matching may potentially\n', "    ///      performed by another party and is not part of the exchange's duty.\n", '    ///\n', '    /// @return The amount of LRC staked\n', '    function getExchangeStake()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Withdraws the amount staked for this exchange.\n', '    ///      This can only be done if the exchange has been correctly shutdown:\n', '    ///      - The exchange owner has shutdown the exchange\n', '    ///      - All deposit requests are processed\n', '    ///      - All funds are returned to the users (merkle root is reset to initial state)\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Can by called by anyone to burn the stake of the exchange when certain\n', '    ///      conditions are fulfilled.\n', '    ///\n', '    ///      Currently this will only burn the stake of the exchange if\n', '    ///      the exchange is in withdrawal mode.\n', '    function burnExchangeStake()\n', '        external\n', '        virtual;\n', '\n', '    // -- Blocks --\n', '\n', "    /// @dev Gets the current Merkle root of this exchange's virtual blockchain.\n", '    /// @return The current Merkle root.\n', '    function getMerkleRoot()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '\n', "    /// @dev Gets the height of this exchange's virtual blockchain. The block height for a\n", '    ///      new exchange is 1.\n', '    /// @return The virtual blockchain height which is the index of the last block.\n', '    function getBlockHeight()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', "    /// @dev Gets some minimal info of a previously submitted block that's kept onchain.\n", '    ///      A DEX can use this function to implement a payment receipt verification\n', '    ///      contract with a challange-response scheme.\n', '    /// @param blockIdx The block index.\n', '    function getBlockInfo(uint blockIdx)\n', '        external\n', '        virtual\n', '        view\n', '        returns (ExchangeData.BlockInfo memory);\n', '\n', '    /// @dev Sumbits new blocks to the rollup blockchain.\n', '    ///\n', '    ///      This function can only be called by the exchange operator.\n', '    ///\n', '    /// @param blocks The blocks being submitted\n', '    ///      - blockType: The type of the new block\n', '    ///      - blockSize: The number of onchain or offchain requests/settlements\n', '    ///        that have been processed in this block\n', '    ///      - blockVersion: The circuit version to use for verifying the block\n', '    ///      - storeBlockInfoOnchain: If the block info for this block needs to be stored on-chain\n', '    ///      - data: The data for this block\n', '    ///      - offchainData: Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '    ///        the multihash of the IPFS file that contains the block data.\n', '    function submitBlocks(ExchangeData.Block[] calldata blocks)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the number of available forced request slots.\n', '    /// @return The number of available slots.\n', '    function getNumAvailableForcedSlots()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    // -- Deposits --\n', '\n', '    /// @dev Deposits Ether or ERC20 tokens to the specified account.\n', '    ///\n', "    ///      This function is only callable by an agent of 'from'.\n", '    ///\n', '    ///      A fee to the owner is paid in ETH to process the deposit.\n', '    ///      The operator is not forced to do the deposit and the user can send\n', '    ///      any fee amount.\n', '    ///\n', '    /// @param from The address that deposits the funds to the exchange\n', "    /// @param to The account owner's address receiving the funds\n", '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param amount The amount of tokens to deposit\n', '    /// @param auxiliaryData Optional extra data used by the deposit contract\n', '    function deposit(\n', '        address from,\n', '        address to,\n', '        address tokenAddress,\n', '        uint96  amount,\n', '        bytes   calldata auxiliaryData\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', "    /// @dev Gets the amount of tokens that may be added to the owner's account.\n", '    /// @param owner The destination address for the amount deposited.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The amount of tokens pending.\n', '    function getPendingDepositAmount(\n', '        address owner,\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint96);\n', '\n', '    // -- Withdrawals --\n', '    /// @dev Submits an onchain request to force withdraw Ether or ERC20 tokens.\n', '    ///      This request always withdraws the full balance.\n', '    ///\n', '    ///      This function is only callable by an agent of the account.\n', '    ///\n', "    ///      The total fee in ETH that the user needs to pay is 'withdrawalFee'.\n", '    ///      If the user sends too much ETH the surplus is sent back immediately.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param owner The expected owner of the account\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @param accountID The address the account in the Merkle tree.\n', '    function forceWithdraw(\n', '        address owner,\n', '        address tokenAddress,\n', '        uint32  accountID\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Checks if a forced withdrawal is pending for an account balance.\n', '    /// @param  accountID The accountID of the account to check.\n', '    /// @param  token The token address\n', '    /// @return True if a request is pending, false otherwise\n', '    function isForcedWithdrawalPending(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Submits an onchain request to withdraw Ether or ERC20 tokens from the\n', '    ///      protocol fees account. The complete balance is always withdrawn.\n', '    ///\n', '    ///      Anyone can request a withdrawal of the protocol fees.\n', '    ///\n', '    ///      Note that after such an operation, it will take the owner some\n', '    ///      time (no more than MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE) to process the request\n', '    ///      and create the deposit to the offchain account.\n', '    ///\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    function withdrawProtocolFees(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        payable;\n', '\n', '    /// @dev Gets the time the protocol fee for a token was last withdrawn.\n', '    /// @param tokenAddress The address of the token, use `0x0` for Ether.\n', '    /// @return The time the protocol fee was last withdrawn.\n', '    function getProtocolFeeLastWithdrawnTime(\n', '        address tokenAddress\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Allows anyone to withdraw funds for a specified user using the balances stored\n', '    ///      in the Merkle tree. The funds will be sent to the owner of the acount.\n', '    ///\n', '    ///      Can only be used in withdrawal mode (i.e. when the owner has stopped\n', '    ///      committing blocks and is not able to commit any more blocks).\n', '    ///\n', '    ///      This will NOT modify the onchain merkle root! The merkle root stored\n', '    ///      onchain will remain the same after the withdrawal. We store if the user\n', '    ///      has withdrawn the balance in State.withdrawnInWithdrawMode.\n', '    ///\n', '    /// @param  merkleProof The Merkle inclusion proof\n', '    function withdrawFromMerkleTree(\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Checks if the balance for the account was withdrawn with `withdrawFromMerkleTree`.\n', '    /// @param  accountID The accountID of the balance to check.\n', '    /// @param  token The token address\n', '    /// @return True if it was already withdrawn, false otherwise\n', '    function isWithdrawnInWithdrawalMode(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Allows withdrawing funds deposited to the contract in a deposit request when\n', '    ///      it was never processed by the owner within the maximum time allowed.\n', '    ///\n', '    ///      Can be called by anyone. The deposited tokens will be sent back to\n', '    ///      the owner of the account they were deposited in.\n', '    ///\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    function withdrawFromDepositRequest(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows withdrawing funds after a withdrawal request (either onchain\n', '    ///      or offchain) was submitted in a block by the operator.\n', '    ///\n', '    ///      Can be called by anyone. The withdrawn tokens will be sent to\n', '    ///      the owner of the account they were withdrawn out.\n', '    ///\n', '    ///      Normally it is should not be needed for users to call this manually.\n', '    ///      Funds from withdrawal requests will be sent to the account owner\n', '    ///      immediately by the owner when the block is submitted.\n', '    ///      The user will however need to call this manually if the transfer failed.\n', '    ///\n', '    ///      Tokens and owners must have the same size.\n', '    ///\n', '    /// @param  owners The addresses of the account the withdrawal was done for.\n', '    /// @param  tokens The token addresses\n', '    function withdrawFromApprovedWithdrawals(\n', '        address[] calldata owners,\n', '        address[] calldata tokens\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount that can be withdrawn immediately with `withdrawFromApprovedWithdrawals`.\n', '    /// @param  owner The address of the account the withdrawal was done for.\n', '    /// @param  token The token address\n', '    /// @return The amount withdrawable\n', '    function getAmountWithdrawable(\n', '        address owner,\n', '        address token\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    /// @dev Notifies the exchange that the owner did not process a forced request.\n', '    ///      If this is indeed the case, the exchange will enter withdrawal mode.\n', '    ///\n', '    ///      Can be called by anyone.\n', '    ///\n', '    /// @param  accountID The accountID the forced request was made for\n', '    /// @param  token The token address of the the forced request\n', '    function notifyForcedRequestTooOld(\n', '        uint32  accountID,\n', '        address token\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows a withdrawal to be done to an adddresss that is different\n', '    ///      than initialy specified in the withdrawal request. This can be used to\n', '    ///      implement functionality like fast withdrawals.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    /// @param newRecipient The new recipient address of the withdrawal.\n', '    function setWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID,\n', '        address newRecipient\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the withdrawal recipient.\n', '    ///\n', '    /// @param from The address of the account that does the withdrawal.\n', "    /// @param to The address to which 'amount' tokens were going to be withdrawn.\n", "    /// @param token The address of the token that is withdrawn ('0x0' for ETH).\n", '    /// @param amount The amount of tokens that are going to be withdrawn.\n', '    /// @param storageID The storageID of the withdrawal request.\n', '    function getWithdrawalRecipient(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint96  amount,\n', '        uint32  storageID\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (address);\n', '\n', '    /// @dev Allows an agent to transfer ERC-20 tokens for a user using the allowance\n', '    ///      the user has set for the exchange. This way the user only needs to approve a single exchange contract\n', '    ///      for all exchange/agent features, which allows for a more seamless user experience.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function onchainTransferFrom(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve a rollup tx.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owner The owner of the account\n', '    /// @param txHash The hash of the transaction\n', '    function approveTransaction(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Allows an agent to approve multiple rollup txs.\n', '    ///\n', '    ///      This function can only be called by an agent.\n', '    ///\n', '    /// @param owners The account owners\n', '    /// @param txHashes The hashes of the transactions\n', '    function approveTransactions(\n', '        address[] calldata owners,\n', '        bytes32[] calldata txHashes\n', '        )\n', '        external\n', '        virtual;\n', '\n', "    /// @dev Checks if a rollup tx is approved using the tx's hash.\n", '    ///\n', '    /// @param owner The owner of the account that needs to authorize the tx\n', '    /// @param txHash The hash of the transaction\n', '    /// @return True if the tx is approved, else false\n', '    function isTransactionApproved(\n', '        address owner,\n', '        bytes32 txHash\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    // -- Admins --\n', '    /// @dev Sets the max time deposits have to wait before becoming withdrawable.\n', '    /// @param newValue The new value.\n', '    /// @return  The old value.\n', '    function setMaxAgeDepositUntilWithdrawable(\n', '        uint32 newValue\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint32);\n', '\n', '    /// @dev Returns the max time deposits have to wait before becoming withdrawable.\n', '    /// @return The value.\n', '    function getMaxAgeDepositUntilWithdrawable()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint32);\n', '\n', '    /// @dev Shuts down the exchange.\n', '    ///      Once the exchange is shutdown all onchain requests are permanently disabled.\n', '    ///      When all requirements are fulfilled the exchange owner can withdraw\n', '    ///      the exchange stake with withdrawStake.\n', '    ///\n', '    ///      Note that the exchange can still enter the withdrawal mode after this function\n', '    ///      has been invoked successfully. To prevent entering the withdrawal mode before the\n', '    ///      the echange stake can be withdrawn, all withdrawal requests still need to be handled\n', '    ///      for at least MIN_TIME_IN_SHUTDOWN seconds.\n', '    ///\n', '    ///      Can only be called by the exchange owner.\n', '    ///\n', '    /// @return success True if the exchange is shutdown, else False\n', '    function shutdown()\n', '        external\n', '        virtual\n', '        returns (bool success);\n', '\n', '    /// @dev Gets the protocol fees for this exchange.\n', '    /// @return syncedAt The timestamp the protocol fees were last updated\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    /// @return previousTakerFeeBips The previous protocol taker fee\n', '    /// @return previousMakerFeeBips The previous protocol maker fee\n', '    function getProtocolFeeValues()\n', '        external\n', '        virtual\n', '        view\n', '        returns (\n', '            uint32 syncedAt,\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips,\n', '            uint8 previousTakerFeeBips,\n', '            uint8 previousMakerFeeBips\n', '        );\n', '\n', '    /// @dev Gets the domain separator used in this exchange.\n', '    function getDomainSeparator()\n', '        external\n', '        virtual\n', '        view\n', '        returns (bytes32);\n', '\n', '    /// @dev set amm pool feeBips value.\n', '    function setAmmFeeBips(uint8 _feeBips)\n', '        external\n', '        virtual;\n', '\n', '    /// @dev get amm pool feeBips value.\n', '    function getAmmFeeBips()\n', '        external\n', '        virtual\n', '        view\n', '        returns (uint8);\n', '}\n', '\n', '// File: contracts/amm/libamm/IAmmSharedConfig.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'interface IAmmSharedConfig\n', '{\n', '    function maxForcedExitAge() external view returns (uint);\n', '    function maxForcedExitCount() external view returns (uint);\n', '    function forcedExitFee() external view returns (uint);\n', '}\n', '\n', '// File: contracts/amm/libamm/AmmData.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmData\n', 'library AmmData\n', '{\n', '    uint public constant POOL_TOKEN_BASE = 100 * (10 ** 8);\n', '    uint public constant POOL_TOKEN_MINTED_SUPPLY = uint96(-1);\n', '\n', '    enum PoolTxType\n', '    {\n', '        NOOP,\n', '        JOIN,\n', '        EXIT\n', '    }\n', '\n', '    struct PoolConfig\n', '    {\n', '        address   sharedConfig;\n', '        address   exchange;\n', '        string    poolName;\n', '        uint32    accountID;\n', '        address[] tokens;\n', '        uint96[]  weights;\n', '        uint8     feeBips;\n', '        string    tokenSymbol;\n', '    }\n', '\n', '    struct PoolJoin\n', '    {\n', '        address   owner;\n', '        uint96[]  joinAmounts;\n', '        uint32[]  joinStorageIDs;\n', '        uint96    mintMinAmount;\n', '        uint96    fee;\n', '        uint32    validUntil;\n', '    }\n', '\n', '    struct PoolExit\n', '    {\n', '        address   owner;\n', '        uint96    burnAmount;\n', '        uint32    burnStorageID; // for pool token withdrawal from user to the pool\n', '        uint96[]  exitMinAmounts; // the amount to receive BEFORE paying the fee.\n', '        uint96    fee;\n', '        uint32    validUntil;\n', '    }\n', '\n', '    struct PoolTx\n', '    {\n', '        PoolTxType txType;\n', '        bytes      data;\n', '        bytes      signature;\n', '    }\n', '\n', '    struct Token\n', '    {\n', '        address addr;\n', '        uint96  weight;\n', '        uint16  tokenID;\n', '    }\n', '\n', '    struct Context\n', '    {\n', '        // functional parameters\n', '        uint txIdx;\n', '\n', '        // AMM pool state variables\n', '        bytes32 domainSeparator;\n', '        uint32  accountID;\n', '\n', '        uint16  poolTokenID;\n', '        uint8   feeBips;\n', '        uint    totalSupply;\n', '\n', '        Token[]  tokens;\n', '        uint96[] tokenBalancesL2;\n', '    }\n', '\n', '    struct State {\n', '        // Pool token state variables\n', '        string poolName;\n', '        string symbol;\n', '        uint   _totalSupply;\n', '\n', '        mapping(address => uint) balanceOf;\n', '        mapping(address => mapping(address => uint)) allowance;\n', '        mapping(address => uint) nonces;\n', '\n', '        // AMM pool state variables\n', '        IAmmSharedConfig sharedConfig;\n', '\n', '        Token[]     tokens;\n', '\n', '        // The order of the following variables important to minimize loads\n', '        bytes32     exchangeDomainSeparator;\n', '        bytes32     domainSeparator;\n', '        IExchangeV3 exchange;\n', '        uint32      accountID;\n', '        uint16      poolTokenID;\n', '        uint8       feeBips;\n', '\n', '        address     exchangeOwner;\n', '\n', '        uint64      shutdownTimestamp;\n', '        uint16      forcedExitCount;\n', '\n', '        // A map from a user to the forced exit.\n', '        mapping (address => PoolExit) forcedExit;\n', '        mapping (bytes32 => bool) approvedTx;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/EIP712.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', 'library EIP712\n', '{\n', '    struct Domain {\n', '        string  name;\n', '        string  version;\n', '        address verifyingContract;\n', '    }\n', '\n', '    bytes32 constant internal EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '    );\n', '\n', '    string constant internal EIP191_HEADER = "\\x19\\x01";\n', '\n', '    function hash(Domain memory domain)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        uint _chainid;\n', '        assembly { _chainid := chainid() }\n', '\n', '        return keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(domain.name)),\n', '                keccak256(bytes(domain.version)),\n', '                _chainid,\n', '                domain.verifyingContract\n', '            )\n', '        );\n', '    }\n', '\n', '    function hashPacked(\n', '        bytes32 domainHash,\n', '        bytes32 dataHash\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(\n', '            abi.encodePacked(\n', '                EIP191_HEADER,\n', '                domainHash,\n', '                dataHash\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/lib/MathUint96.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', 'library MathUint96\n', '{\n', '    function add(\n', '        uint96 a,\n', '        uint96 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint96 a,\n', '        uint96 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96 c)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '}\n', '\n', '// File: contracts/thirdparty/BytesUtil.sol\n', '\n', '//Mainly taken from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n', '\n', 'library BytesUtil {\n', '\n', '    function concat(\n', '        bytes memory _preBytes,\n', '        bytes memory _postBytes\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint _start,\n', '        uint _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_bytes.length >= (_start + _length));\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n', '        require(_bytes.length >= (_start + 20));\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n', '        require(_bytes.length >= (_start + 1));\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n', '        require(_bytes.length >= (_start + 2));\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint24(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\n', '        require(_bytes.length >= (_start + 3));\n', '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n', '        require(_bytes.length >= (_start + 4));\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n', '        require(_bytes.length >= (_start + 8));\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n', '        require(_bytes.length >= (_start + 12));\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n', '        require(_bytes.length >= (_start + 16));\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n', '        require(_bytes.length >= (_start + 32));\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes4(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\n', '        require(_bytes.length >= (_start + 4));\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes20(bytes memory _bytes, uint _start) internal  pure returns (bytes20) {\n', '        require(_bytes.length >= (_start + 20));\n', '        bytes20 tempBytes20;\n', '\n', '        assembly {\n', '            tempBytes20 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes20;\n', '    }\n', '\n', '    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n', '        require(_bytes.length >= (_start + 32));\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '\n', '    function toAddressUnsafe(bytes memory _bytes, uint _start) internal  pure returns (address) {\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint24Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint24) {\n', '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128Unsafe(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUintUnsafe(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes4Unsafe(bytes memory _bytes, uint _start) internal  pure returns (bytes4) {\n', '        bytes4 tempBytes4;\n', '\n', '        assembly {\n', '            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes4;\n', '    }\n', '\n', '    function toBytes20Unsafe(bytes memory _bytes, uint _start) internal  pure returns (bytes20) {\n', '        bytes20 tempBytes20;\n', '\n', '        assembly {\n', '            tempBytes20 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes20;\n', '    }\n', '\n', '    function toBytes32Unsafe(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '\n', '    function fastSHA256(\n', '        bytes memory data\n', '        )\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        bytes32[] memory result = new bytes32[](1);\n', '        bool success;\n', '        assembly {\n', '             let ptr := add(data, 32)\n', '             success := staticcall(sub(gas(), 2000), 2, ptr, mload(data), add(result, 32), 32)\n', '        }\n', '        require(success, "SHA256_FAILED");\n', '        return result[0];\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success, ) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ERC1271.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'abstract contract ERC1271 {\n', '    // bytes4(keccak256("isValidSignature(bytes32,bytes)")\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function isValidSignature(\n', '        bytes32      _hash,\n', '        bytes memory _signature)\n', '        public\n', '        view\n', '        virtual\n', '        returns (bytes4 magicValueB32);\n', '\n', '}\n', '\n', '// File: contracts/lib/SignatureUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title SignatureUtil\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', "/// @dev This method supports multihash standard. Each signature's last byte indicates\n", "///      the signature's type.\n", 'library SignatureUtil\n', '{\n', '    using BytesUtil     for bytes;\n', '    using MathUint      for uint;\n', '    using AddressUtil   for address;\n', '\n', '    enum SignatureType {\n', '        ILLEGAL,\n', '        INVALID,\n', '        EIP_712,\n', '        ETH_SIGN,\n', '        WALLET   // deprecated\n', '    }\n', '\n', '    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n', '\n', '    function verifySignatures(\n', '        bytes32          signHash,\n', '        address[] memory signers,\n', '        bytes[]   memory signatures\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(signers.length == signatures.length, "BAD_SIGNATURE_DATA");\n', '        address lastSigner;\n', '        for (uint i = 0; i < signers.length; i++) {\n', '            require(signers[i] > lastSigner, "INVALID_SIGNERS_ORDER");\n', '            lastSigner = signers[i];\n', '            if (!verifySignature(signHash, signers[i], signatures[i])) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function verifySignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        return signer.isContract()?\n', '            verifyERC1271Signature(signHash, signer, signature):\n', '            verifyEOASignature(signHash, signer, signature);\n', '    }\n', '\n', '    function recoverECDSASigner(\n', '        bytes32      signHash,\n', '        bytes memory signature\n', '        )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        if (signature.length != 65) {\n', '            return address(0);\n', '        }\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8   v;\n', '        // we jump 32 (0x20) as the first slot of bytes contains the length\n', '        // we jump 65 (0x41) per signature\n', '        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := and(mload(add(signature, 0x41)), 0xff)\n', '        }\n', '        // See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            return address(0);\n', '        }\n', '        if (v == 27 || v == 28) {\n', '            return ecrecover(signHash, v, r, s);\n', '        } else {\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    function verifyEOASignature(\n', '        bytes32        signHash,\n', '        address        signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        pure\n', '        returns (bool success)\n', '    {\n', '        if (signer == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint signatureTypeOffset = signature.length.sub(1);\n', '        SignatureType signatureType = SignatureType(signature.toUint8(signatureTypeOffset));\n', '\n', '        // Strip off the last byte of the signature by updating the length\n', '        assembly {\n', '            mstore(signature, signatureTypeOffset)\n', '        }\n', '\n', '        if (signatureType == SignatureType.EIP_712) {\n', '            success = (signer == recoverECDSASigner(signHash, signature));\n', '        } else if (signatureType == SignatureType.ETH_SIGN) {\n', '            bytes32 hash = keccak256(\n', '                abi.encodePacked("\\x19Ethereum Signed Message:\\n32", signHash)\n', '            );\n', '            success = (signer == recoverECDSASigner(hash, signature));\n', '        } else {\n', '            success = false;\n', '        }\n', '\n', '        // Restore the signature length\n', '        assembly {\n', '            mstore(signature, add(signatureTypeOffset, 1))\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function verifyERC1271Signature(\n', '        bytes32 signHash,\n', '        address signer,\n', '        bytes   memory signature\n', '        )\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            ERC1271.isValidSignature.selector,\n', '            signHash,\n', '            signature\n', '        );\n', '        (bool success, bytes memory result) = signer.staticcall(callData);\n', '        return (\n', '            success &&\n', '            result.length == 32 &&\n', '            result.toBytes4(0) == ERC1271_MAGICVALUE\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/amm/libamm/AmmPoolToken.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmPoolToken\n', 'library AmmPoolToken\n', '{\n', '    using MathUint      for uint;\n', '    using MathUint96    for uint96;\n', '    using SignatureUtil for bytes32;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from,  address indexed to,      uint value);\n', '\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\n', '    function totalSupply(\n', '        AmmData.State storage S\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return S._totalSupply;\n', '    }\n', '\n', '    function approve(\n', '        AmmData.State storage S,\n', '        address               spender,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        _approve(S, msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(\n', '        AmmData.State storage S,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        _transfer(S, msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        AmmData.State storage S,\n', '        address               from,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (msg.sender != address(this) &&\n', '            S.allowance[from][msg.sender] != uint(-1)) {\n', '            S.allowance[from][msg.sender] = S.allowance[from][msg.sender].sub(value);\n', '        }\n', '         _transfer(S, from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function permit(\n', '        AmmData.State storage S,\n', '        address               owner,\n', '        address               spender,\n', '        uint256               value,\n', '        uint256               deadline,\n', '        bytes        calldata signature\n', '        )\n', '        internal\n', '    {\n', "        require(deadline >= block.timestamp, 'EXPIRED');\n", '\n', '        bytes32 hash = EIP712.hashPacked(\n', '            S.domainSeparator,\n', '            keccak256(\n', '                abi.encode(\n', '                    PERMIT_TYPEHASH,\n', '                    owner,\n', '                    spender,\n', '                    value,\n', '                    S.nonces[owner]++,\n', '                    deadline\n', '                )\n', '            )\n', '        );\n', '\n', "        require(hash.verifySignature(owner, signature), 'INVALID_SIGNATURE');\n", '        _approve(S, owner, spender, value);\n', '    }\n', '\n', '    function _approve(\n', '        AmmData.State storage S,\n', '        address               owner,\n', '        address               spender,\n', '        uint                  value\n', '        )\n', '        private\n', '    {\n', '        if (spender != address(this)) {\n', '            S.allowance[owner][spender] = value;\n', '            emit Approval(owner, spender, value);\n', '        }\n', '    }\n', '\n', '    function _transfer(\n', '        AmmData.State storage S,\n', '        address               from,\n', '        address               to,\n', '        uint                  value\n', '        )\n', '        private\n', '    {\n', '        S.balanceOf[from] = S.balanceOf[from].sub(value);\n', '        S.balanceOf[to] = S.balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '}\n', '\n', '// File: contracts/amm/libamm/AmmStatus.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmStatus\n', 'library AmmStatus\n', '{\n', '    using AmmPoolToken      for AmmData.State;\n', '    using MathUint          for uint;\n', '    using MathUint96        for uint96;\n', '    using SignatureUtil     for bytes32;\n', '\n', '    event Shutdown(uint timestamp);\n', '\n', '    function isOnline(AmmData.State storage S)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return S.shutdownTimestamp == 0;\n', '    }\n', '\n', '    function setupPool(\n', '        AmmData.State      storage  S,\n', '        AmmData.PoolConfig calldata config\n', '        )\n', '        public\n', '    {\n', '        require(\n', '            bytes(config.poolName).length > 0 && bytes(config.tokenSymbol).length > 0,\n', '            "INVALID_NAME_OR_SYMBOL"\n', '        );\n', '        require(config.sharedConfig != address(0), "INVALID_SHARED_CONFIG");\n', '        require(config.tokens.length == config.weights.length, "INVALID_DATA");\n', '        require(config.tokens.length >= 2, "INVALID_DATA");\n', '        require(config.exchange != address(0), "INVALID_EXCHANGE");\n', '        require(config.accountID != 0, "INVALID_ACCOUNT_ID");\n', '        require(S.tokens.length == 0, "ALREADY_INITIALIZED");\n', '\n', '        S.sharedConfig = IAmmSharedConfig(config.sharedConfig);\n', '        IExchangeV3 exchange = IExchangeV3(config.exchange);\n', '        S.exchange = exchange;\n', '        S.exchangeOwner = exchange.owner();\n', '        S.exchangeDomainSeparator = exchange.getDomainSeparator();\n', '        S.accountID = config.accountID;\n', '        S.poolTokenID = exchange.getTokenID(address(this));\n', '        S.feeBips = config.feeBips;\n', '        S.domainSeparator = EIP712.hash(EIP712.Domain(config.poolName, "1.0.0", address(this)));\n', '\n', '        S.poolName = config.poolName;\n', '        S.symbol = config.tokenSymbol;\n', '\n', '        for (uint i = 0; i < config.tokens.length; i++) {\n', '            require(config.weights[i] > 0, "INVALID_TOKEN_WEIGHT");\n', '\n', '            address token = config.tokens[i];\n', '            S.tokens.push(AmmData.Token({\n', '                addr: token,\n', '                tokenID: exchange.getTokenID(token),\n', '                weight: config.weights[i]\n', '            }));\n', '        }\n', '\n', '        // Mint all liquidity tokens to the pool account on L2\n', '        S.balanceOf[address(this)] = AmmData.POOL_TOKEN_MINTED_SUPPLY;\n', '        S.allowance[address(this)][address(exchange.getDepositContract())] = uint(-1);\n', '        exchange.deposit(\n', '            address(this), // from\n', '            address(this), // to\n', '            address(this), // token\n', '            uint96(AmmData.POOL_TOKEN_MINTED_SUPPLY),\n', '            new bytes(0)\n', '        );\n', '    }\n', '\n', "    // Anyone is able to shut down the pool when requests aren't being processed any more.\n", '    function shutdown(\n', '        AmmData.State storage S,\n', '        address               exitOwner\n', '        )\n', '        public\n', '    {\n', '        // If the exchange is in withdrawal mode allow the pool to be shutdown immediately\n', '        if (!S.exchange.isInWithdrawalMode()) {\n', '            uint64 validUntil = S.forcedExit[exitOwner].validUntil;\n', '            require(validUntil > 0 && validUntil < block.timestamp, "INVALID_CHALLENGE");\n', '\n', '            uint size = S.tokens.length;\n', '\n', '            for (uint i = 0; i < size; i++) {\n', '                S.exchange.forceWithdraw{value: msg.value / size}(\n', '                    address(this),\n', '                    S.tokens[i].addr,\n', '                    S.accountID\n', '                );\n', '            }\n', '        }\n', '        S.shutdownTimestamp = uint64(block.timestamp);\n', '        emit Shutdown(block.timestamp);\n', '    }\n', '\n', '    // Anyone is able to update the cached exchange owner to the current owner.\n', '    function updateExchangeOwnerAndFeeBips(AmmData.State storage S)\n', '        public\n', '    {\n', '        S.exchangeOwner = S.exchange.owner();\n', '        S.feeBips = S.exchange.getAmmFeeBips();\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/BlockReader.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title BlockReader\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Utility library to read block data.\n', 'library BlockReader {\n', '    using BlockReader       for ExchangeData.Block;\n', '    using BytesUtil         for bytes;\n', '\n', '    uint public constant OFFSET_TO_TRANSACTIONS = 20 + 32 + 32 + 4 + 1 + 1 + 4 + 4;\n', '\n', '    struct BlockHeader\n', '    {\n', '        address exchange;\n', '        bytes32 merkleRootBefore;\n', '        bytes32 merkleRootAfter;\n', '        uint32  timestamp;\n', '        uint8   protocolTakerFeeBips;\n', '        uint8   protocolMakerFeeBips;\n', '        uint32  numConditionalTransactions;\n', '        uint32  operatorAccountID;\n', '    }\n', '\n', '    function readHeader(\n', '        bytes memory _blockData\n', '        )\n', '        internal\n', '        pure\n', '        returns (BlockHeader memory header)\n', '    {\n', '        uint offset = 0;\n', '        header.exchange = _blockData.toAddress(offset);\n', '        offset += 20;\n', '        header.merkleRootBefore = _blockData.toBytes32(offset);\n', '        offset += 32;\n', '        header.merkleRootAfter = _blockData.toBytes32(offset);\n', '        offset += 32;\n', '        header.timestamp = _blockData.toUint32(offset);\n', '        offset += 4;\n', '        header.protocolTakerFeeBips = _blockData.toUint8(offset);\n', '        offset += 1;\n', '        header.protocolMakerFeeBips = _blockData.toUint8(offset);\n', '        offset += 1;\n', '        header.numConditionalTransactions = _blockData.toUint32(offset);\n', '        offset += 4;\n', '        header.operatorAccountID = _blockData.toUint32(offset);\n', '        offset += 4;\n', '        assert(offset == OFFSET_TO_TRANSACTIONS);\n', '    }\n', '\n', '    function readTransactionData(\n', '        bytes memory data,\n', '        uint txIdx,\n', '        uint blockSize,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        require(txIdx < blockSize, "INVALID_TX_IDX");\n', '\n', '        // The transaction was transformed to make it easier to compress.\n', '        // Transform it back here.\n', '        // Part 1\n', '        uint txDataOffset = OFFSET_TO_TRANSACTIONS +\n', '            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1;\n', '        assembly {\n', '            mstore(add(txData, 32), mload(add(data, add(txDataOffset, 32))))\n', '        }\n', '        // Part 2\n', '        txDataOffset = OFFSET_TO_TRANSACTIONS +\n', '            blockSize * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_1 +\n', '            txIdx * ExchangeData.TX_DATA_AVAILABILITY_SIZE_PART_2;\n', '        assembly {\n', '            mstore(add(txData, 61 /*32 + 29*/), mload(add(data, add(txDataOffset, 32))))\n', '            mstore(add(txData, 68            ), mload(add(data, add(txDataOffset, 39))))\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeSignatures.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '/// @title ExchangeSignatures.\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'library ExchangeSignatures\n', '{\n', '    using SignatureUtil for bytes32;\n', '\n', '    function requireAuthorizedTx(\n', '        ExchangeData.State storage S,\n', '        address signer,\n', '        bytes memory signature,\n', '        bytes32 txHash\n', '        )\n', '        internal // inline call\n', '    {\n', '        require(signer != address(0), "INVALID_SIGNER");\n', '        // Verify the signature if one is provided, otherwise fall back to an approved tx\n', '        if (signature.length > 0) {\n', '            require(txHash.verifySignature(signer, signature), "INVALID_SIGNATURE");\n', '        } else {\n', '            require(S.approvedTx[signer][txHash], "TX_NOT_APPROVED");\n', '            delete S.approvedTx[signer][txHash];\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/AmmUpdateTransaction.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmUpdateTransaction\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library AmmUpdateTransaction\n', '{\n', '    using BytesUtil            for bytes;\n', '    using MathUint             for uint;\n', '    using ExchangeSignatures   for ExchangeData.State;\n', '\n', '    bytes32 constant public AMMUPDATE_TYPEHASH = keccak256(\n', '        "AmmUpdate(address owner,uint32 accountID,uint16 tokenID,uint8 feeBips,uint96 tokenWeight,uint32 validUntil,uint32 nonce)"\n', '    );\n', '\n', '    struct AmmUpdate\n', '    {\n', '        address owner;\n', '        uint32  accountID;\n', '        uint16  tokenID;\n', '        uint8   feeBips;\n', '        uint96  tokenWeight;\n', '        uint32  validUntil;\n', '        uint32  nonce;\n', '        uint96  balance;\n', '    }\n', '\n', '    // Auxiliary data for each AMM update\n', '    struct AmmUpdateAuxiliaryData\n', '    {\n', '        bytes  signature;\n', '        uint32 validUntil;\n', '    }\n', '\n', '    function process(\n', '        ExchangeData.State        storage S,\n', '        ExchangeData.BlockContext memory  ctx,\n', '        bytes                     memory  data,\n', '        uint                              offset,\n', '        bytes                     memory  auxiliaryData\n', '        )\n', '        internal\n', '    {\n', '        // Read in the AMM update\n', '        AmmUpdate memory update;\n', '        readTx(data, offset, update);\n', '        AmmUpdateAuxiliaryData memory auxData = abi.decode(auxiliaryData, (AmmUpdateAuxiliaryData));\n', '\n', '        // Check validUntil\n', '        require(ctx.timestamp < auxData.validUntil, "AMM_UPDATE_EXPIRED");\n', '        update.validUntil = auxData.validUntil;\n', '\n', '        // Calculate the tx hash\n', '        bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, update);\n', '\n', '        // Check the on-chain authorization\n', '        S.requireAuthorizedTx(update.owner, auxData.signature, txHash);\n', '    }\n', '\n', '    function readTx(\n', '        bytes memory data,\n', '        uint         offset,\n', '        AmmUpdate memory update\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint _offset = offset;\n', '\n', '        require(data.toUint8Unsafe(_offset) == uint8(ExchangeData.TransactionType.AMM_UPDATE), "INVALID_TX_TYPE");\n', '        _offset += 1;\n', '\n', "        // We don't use abi.decode for this because of the large amount of zero-padding\n", '        // bytes the circuit would also have to hash.\n', '        update.owner = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '        update.accountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        update.tokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        update.feeBips = data.toUint8Unsafe(_offset);\n', '        _offset += 1;\n', '        update.tokenWeight = data.toUint96Unsafe(_offset);\n', '        _offset += 12;\n', '        update.nonce = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        update.balance = data.toUint96Unsafe(_offset);\n', '        _offset += 12;\n', '    }\n', '\n', '    function hashTx(\n', '        bytes32 DOMAIN_SEPARATOR,\n', '        AmmUpdate memory update\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return EIP712.hashPacked(\n', '            DOMAIN_SEPARATOR,\n', '            keccak256(\n', '                abi.encode(\n', '                    AMMUPDATE_TYPEHASH,\n', '                    update.owner,\n', '                    update.accountID,\n', '                    update.tokenID,\n', '                    update.feeBips,\n', '                    update.tokenWeight,\n', '                    update.validUntil,\n', '                    update.nonce\n', '                )\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/DepositTransaction.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title DepositTransaction\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library DepositTransaction\n', '{\n', '    using BytesUtil   for bytes;\n', '    using MathUint96  for uint96;\n', '\n', '    struct Deposit\n', '    {\n', '        address to;\n', '        uint32  toAccountID;\n', '        uint16  tokenID;\n', '        uint96  amount;\n', '    }\n', '\n', '    function process(\n', '        ExchangeData.State        storage S,\n', '        ExchangeData.BlockContext memory  /*ctx*/,\n', '        bytes                     memory  data,\n', '        uint                              offset,\n', '        bytes                     memory  /*auxiliaryData*/\n', '        )\n', '        internal\n', '    {\n', '        // Read in the deposit\n', '        Deposit memory deposit;\n', '        readTx(data, offset, deposit);\n', '        if (deposit.amount == 0) {\n', '            return;\n', '        }\n', '\n', '        // Process the deposit\n', '        ExchangeData.Deposit memory pendingDeposit = S.pendingDeposits[deposit.to][deposit.tokenID];\n', '        // Make sure the deposit was actually done\n', '        require(pendingDeposit.timestamp > 0, "DEPOSIT_DOESNT_EXIST");\n', '\n', '        // Processing partial amounts of the deposited amount is allowed.\n', '        // This is done to ensure the user can do multiple deposits after each other\n', '        // without invalidating work done by the exchange owner for previous deposit amounts.\n', '\n', '        require(pendingDeposit.amount >= deposit.amount, "INVALID_AMOUNT");\n', '        pendingDeposit.amount = pendingDeposit.amount.sub(deposit.amount);\n', '\n', '        // If the deposit was fully consumed, reset it so the storage is freed up\n', '        // and the owner receives a gas refund.\n', '        if (pendingDeposit.amount == 0) {\n', '            delete S.pendingDeposits[deposit.to][deposit.tokenID];\n', '        } else {\n', '            S.pendingDeposits[deposit.to][deposit.tokenID] = pendingDeposit;\n', '        }\n', '    }\n', '\n', '    function readTx(\n', '        bytes   memory data,\n', '        uint           offset,\n', '        Deposit memory deposit\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint _offset = offset;\n', '\n', '        require(data.toUint8Unsafe(_offset) == uint8(ExchangeData.TransactionType.DEPOSIT), "INVALID_TX_TYPE");\n', '        _offset += 1;\n', '\n', "        // We don't use abi.decode for this because of the large amount of zero-padding\n", '        // bytes the circuit would also have to hash.\n', '        deposit.to = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '        deposit.toAccountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        deposit.tokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        deposit.amount = data.toUint96Unsafe(_offset);\n', '        _offset += 12;\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/SignatureVerificationTransaction.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title SignatureVerificationTransaction\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library SignatureVerificationTransaction\n', '{\n', '    using BytesUtil            for bytes;\n', '    using MathUint             for uint;\n', '\n', '    struct SignatureVerification\n', '    {\n', '        address owner;\n', '        uint32  accountID;\n', '        uint256 data;\n', '    }\n', '\n', '    function readTx(\n', '        bytes memory data,\n', '        uint         offset,\n', '        SignatureVerification memory verification\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint _offset = offset;\n', '\n', '        require(data.toUint8Unsafe(_offset) == uint8(ExchangeData.TransactionType.SIGNATURE_VERIFICATION), "INVALID_TX_TYPE");\n', '        _offset += 1;\n', '\n', "        // We don't use abi.decode for this because of the large amount of zero-padding\n", '        // bytes the circuit would also have to hash.\n', '        verification.owner = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '        verification.accountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        verification.data = data.toUintUnsafe(_offset);\n', '        _offset += 32;\n', '    }\n', '}\n', '\n', '// File: contracts/thirdparty/SafeCast.sol\n', '\n', '// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/SafeCast.sol\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint96 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint96).\n', '     *\n', "     * Counterpart to Solidity's `uint96` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 96 bits\n', '     */\n', '    function toUint96(uint256 value) internal pure returns (uint96) {\n', '        require(value < 2**96, "SafeCast: value doesn\\\'t fit in 96 bits");\n', '        return uint96(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint40 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint40).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 40 bits\n', '     */\n', '    function toUint40(uint256 value) internal pure returns (uint40) {\n', '        require(value < 2**40, "SafeCast: value doesn\\\'t fit in 40 bits");\n', '        return uint40(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FloatUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '/// @title Utility Functions for floats\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library FloatUtil\n', '{\n', '    using MathUint for uint;\n', '    using SafeCast for uint;\n', '\n', '    // Decodes a decimal float value that is encoded like `exponent | mantissa`.\n', '    // Both exponent and mantissa are in base 10.\n', '    // Decoding to an integer is as simple as `mantissa * (10 ** exponent)`\n', '    // Will throw when the decoded value overflows an uint96\n', '    /// @param f The float value with 5 bits for the exponent\n', '    /// @param numBits The total number of bits (numBitsMantissa := numBits - numBitsExponent)\n', '    /// @return value The decoded integer value.\n', '    function decodeFloat(\n', '        uint f,\n', '        uint numBits\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96 value)\n', '    {\n', '        if (f == 0) {\n', '            return 0;\n', '        }\n', '        uint numBitsMantissa = numBits.sub(5);\n', '        uint exponent = f >> numBitsMantissa;\n', '        // log2(10**77) = 255.79 < 256\n', '        require(exponent <= 77, "EXPONENT_TOO_LARGE");\n', '        uint mantissa = f & ((1 << numBitsMantissa) - 1);\n', '        value = mantissa.mul(10 ** exponent).toUint96();\n', '    }\n', '\n', '    // Decodes a decimal float value that is encoded like `exponent | mantissa`.\n', '    // Both exponent and mantissa are in base 10.\n', '    // Decoding to an integer is as simple as `mantissa * (10 ** exponent)`\n', '    // Will throw when the decoded value overflows an uint96\n', '    /// @param f The float value with 5 bits exponent, 11 bits mantissa\n', '    /// @return value The decoded integer value.\n', '    function decodeFloat16(\n', '        uint16 f\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96)\n', '    {\n', '        uint value = ((uint(f) & 2047) * (10 ** (uint(f) >> 11)));\n', '        require(value < 2**96, "SafeCast: value doesn\\\'t fit in 96 bits");\n', '        return uint96(value);\n', '    }\n', '\n', '    // Decodes a decimal float value that is encoded like `exponent | mantissa`.\n', '    // Both exponent and mantissa are in base 10.\n', '    // Decoding to an integer is as simple as `mantissa * (10 ** exponent)`\n', '    // Will throw when the decoded value overflows an uint96\n', '    /// @param f The float value with 5 bits exponent, 19 bits mantissa\n', '    /// @return value The decoded integer value.\n', '    function decodeFloat24(\n', '        uint24 f\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint96)\n', '    {\n', '        uint value = ((uint(f) & 524287) * (10 ** (uint(f) >> 19)));\n', '        require(value < 2**96, "SafeCast: value doesn\\\'t fit in 96 bits");\n', '        return uint96(value);\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/TransferTransaction.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title TransferTransaction\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library TransferTransaction\n', '{\n', '    using BytesUtil            for bytes;\n', '    using FloatUtil            for uint24;\n', '    using FloatUtil            for uint16;\n', '    using MathUint             for uint;\n', '    using ExchangeSignatures   for ExchangeData.State;\n', '\n', '    bytes32 constant public TRANSFER_TYPEHASH = keccak256(\n', '        "Transfer(address from,address to,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,uint32 validUntil,uint32 storageID)"\n', '    );\n', '\n', '    struct Transfer\n', '    {\n', '        uint32  fromAccountID;\n', '        uint32  toAccountID;\n', '        address from;\n', '        address to;\n', '        uint16  tokenID;\n', '        uint96  amount;\n', '        uint16  feeTokenID;\n', '        uint96  maxFee;\n', '        uint96  fee;\n', '        uint32  validUntil;\n', '        uint32  storageID;\n', '    }\n', '\n', '    // Auxiliary data for each transfer\n', '    struct TransferAuxiliaryData\n', '    {\n', '        bytes  signature;\n', '        uint96 maxFee;\n', '        uint32 validUntil;\n', '    }\n', '\n', '    function process(\n', '        ExchangeData.State        storage S,\n', '        ExchangeData.BlockContext memory  ctx,\n', '        bytes                     memory  data,\n', '        uint                              offset,\n', '        bytes                     memory  auxiliaryData\n', '        )\n', '        internal\n', '    {\n', '        // Read the transfer\n', '        Transfer memory transfer;\n', '        readTx(data, offset, transfer);\n', '        TransferAuxiliaryData memory auxData = abi.decode(auxiliaryData, (TransferAuxiliaryData));\n', '\n', '        // Fill in withdrawal data missing from DA\n', '        transfer.validUntil = auxData.validUntil;\n', '        transfer.maxFee = auxData.maxFee == 0 ? transfer.fee : auxData.maxFee;\n', '        // Validate\n', '        require(ctx.timestamp < transfer.validUntil, "TRANSFER_EXPIRED");\n', '        require(transfer.fee <= transfer.maxFee, "TRANSFER_FEE_TOO_HIGH");\n', '\n', '        // Calculate the tx hash\n', '        bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, transfer);\n', '\n', '        // Check the on-chain authorization\n', '        S.requireAuthorizedTx(transfer.from, auxData.signature, txHash);\n', '    }\n', '\n', '    function readTx(\n', '        bytes memory data,\n', '        uint         offset,\n', '        Transfer memory transfer\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint _offset = offset;\n', '\n', '        require(data.toUint8Unsafe(_offset) == uint8(ExchangeData.TransactionType.TRANSFER), "INVALID_TX_TYPE");\n', '        _offset += 1;\n', '\n', '        // Check that this is a conditional transfer\n', '        require(data.toUint8Unsafe(_offset) == 1, "INVALID_AUXILIARYDATA_DATA");\n', '        _offset += 1;\n', '\n', '        // Extract the transfer data\n', "        // We don't use abi.decode for this because of the large amount of zero-padding\n", '        // bytes the circuit would also have to hash.\n', '        transfer.fromAccountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        transfer.toAccountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        transfer.tokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        transfer.amount = data.toUint24Unsafe(_offset).decodeFloat24();\n', '        _offset += 3;\n', '        transfer.feeTokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        transfer.fee = data.toUint16Unsafe(_offset).decodeFloat16();\n', '        _offset += 2;\n', '        transfer.storageID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        transfer.to = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '        transfer.from = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '    }\n', '\n', '    function hashTx(\n', '        bytes32 DOMAIN_SEPARATOR,\n', '        Transfer memory transfer\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return EIP712.hashPacked(\n', '            DOMAIN_SEPARATOR,\n', '            keccak256(\n', '                abi.encode(\n', '                    TRANSFER_TYPEHASH,\n', '                    transfer.from,\n', '                    transfer.to,\n', '                    transfer.tokenID,\n', '                    transfer.amount,\n', '                    transfer.feeTokenID,\n', '                    transfer.maxFee,\n', '                    transfer.validUntil,\n', '                    transfer.storageID\n', '                )\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeMode.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '/// @title ExchangeMode.\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'library ExchangeMode\n', '{\n', '    using MathUint  for uint;\n', '\n', '    function isInWithdrawalMode(\n', '        ExchangeData.State storage S\n', '        )\n', '        internal // inline call\n', '        view\n', '        returns (bool result)\n', '    {\n', '        result = S.withdrawalModeStartTime > 0;\n', '    }\n', '\n', '    function isShutdown(\n', '        ExchangeData.State storage S\n', '        )\n', '        internal // inline call\n', '        view\n', '        returns (bool)\n', '    {\n', '        return S.shutdownModeStartTime > 0;\n', '    }\n', '\n', '    function getNumAvailableForcedSlots(\n', '        ExchangeData.State storage S\n', '        )\n', '        internal\n', '        view\n', '        returns (uint)\n', '    {\n', '        return ExchangeData.MAX_OPEN_FORCED_REQUESTS - S.numPendingForcedTransactions;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Poseidon.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Poseidon hash function\n', '///        See: https://eprint.iacr.org/2019/458.pdf\n', '///        Code auto-generated by generate_poseidon_EVM_code.py\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library Poseidon\n', '{\n', '    //\n', '    // hash_t5f6p52\n', '    //\n', '\n', '    struct HashInputs5\n', '    {\n', '        uint t0;\n', '        uint t1;\n', '        uint t2;\n', '        uint t3;\n', '        uint t4;\n', '    }\n', '\n', '    function hash_t5f6p52_internal(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3,\n', '        uint t4,\n', '        uint q\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        assembly {\n', '            function mix(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := mulmod(_t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, _q)\n', '                nt0 := addmod(nt0, mulmod(_t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, _q), _q)\n', '                nt1 := mulmod(_t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, _q)\n', '                nt1 := addmod(nt1, mulmod(_t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, _q), _q)\n', '                nt2 := mulmod(_t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, _q)\n', '                nt2 := addmod(nt2, mulmod(_t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, _q), _q)\n', '                nt3 := mulmod(_t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, _q)\n', '                nt3 := addmod(nt3, mulmod(_t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, _q), _q)\n', '                nt4 := mulmod(_t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, _q)\n', '                nt4 := addmod(nt4, mulmod(_t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, _q), _q)\n', '            }\n', '\n', '            function ark(_t0, _t1, _t2, _t3, _t4, _q, c) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := addmod(_t0, c, _q)\n', '                nt1 := addmod(_t1, c, _q)\n', '                nt2 := addmod(_t2, c, _q)\n', '                nt3 := addmod(_t3, c, _q)\n', '                nt4 := addmod(_t4, c, _q)\n', '            }\n', '\n', '            function sbox_full(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := mulmod(_t0, _t0, _q)\n', '                nt0 := mulmod(nt0, nt0, _q)\n', '                nt0 := mulmod(_t0, nt0, _q)\n', '                nt1 := mulmod(_t1, _t1, _q)\n', '                nt1 := mulmod(nt1, nt1, _q)\n', '                nt1 := mulmod(_t1, nt1, _q)\n', '                nt2 := mulmod(_t2, _t2, _q)\n', '                nt2 := mulmod(nt2, nt2, _q)\n', '                nt2 := mulmod(_t2, nt2, _q)\n', '                nt3 := mulmod(_t3, _t3, _q)\n', '                nt3 := mulmod(nt3, nt3, _q)\n', '                nt3 := mulmod(_t3, nt3, _q)\n', '                nt4 := mulmod(_t4, _t4, _q)\n', '                nt4 := mulmod(nt4, nt4, _q)\n', '                nt4 := mulmod(_t4, nt4, _q)\n', '            }\n', '\n', '            function sbox_partial(_t, _q) -> nt {\n', '                nt := mulmod(_t, _t, _q)\n', '                nt := mulmod(nt, nt, _q)\n', '                nt := mulmod(_t, nt, _q)\n', '            }\n', '\n', '            // round 0\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 1\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 2\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 3\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 4\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 5\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 6\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 7\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 8\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 9\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 10\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 11\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 12\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 13\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 14\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 15\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 16\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 17\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 18\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 19\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 20\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 21\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 22\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 23\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 24\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 25\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 26\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 27\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 28\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 29\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 30\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 31\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 32\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 33\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 34\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 35\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 36\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 37\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 38\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 39\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 40\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 41\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 42\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 43\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 44\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 45\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 46\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 47\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 48\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 49\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 50\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 51\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 52\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 53\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 54\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 55\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 56\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 57\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '        }\n', '        return t0;\n', '    }\n', '\n', '    function hash_t5f6p52(HashInputs5 memory i, uint q) internal pure returns (uint)\n', '    {\n', '        // validate inputs\n', '        require(i.t0 < q, "INVALID_INPUT");\n', '        require(i.t1 < q, "INVALID_INPUT");\n', '        require(i.t2 < q, "INVALID_INPUT");\n', '        require(i.t3 < q, "INVALID_INPUT");\n', '        require(i.t4 < q, "INVALID_INPUT");\n', '\n', '        return hash_t5f6p52_internal(i.t0, i.t1, i.t2, i.t3, i.t4, q);\n', '    }\n', '\n', '\n', '    //\n', '    // hash_t7f6p52\n', '    //\n', '\n', '    struct HashInputs7\n', '    {\n', '        uint t0;\n', '        uint t1;\n', '        uint t2;\n', '        uint t3;\n', '        uint t4;\n', '        uint t5;\n', '        uint t6;\n', '    }\n', '\n', '    function mix(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t1, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t2, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t3, 12968540216479938138647596899147650021419273189336843725176422194136033835172, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t4, 3636162562566338420490575570584278737093584021456168183289112789616069756675, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t5, 8949952361235797771659501126471156178804092479420606597426318793013844305422, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t6, 13586657904816433080148729258697725609063090799921401830545410130405357110367, q), q);\n', '        o.t1 = mulmod(i.t0, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t1, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t2, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t3, 10468644849657689537028565510142839489302836569811003546969773105463051947124, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t4, 3328913364598498171733622353010907641674136720305714432354138807013088636408, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t5, 8642889650254799419576843603477253661899356105675006557919250564400804756641, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t6, 14300697791556510113764686242794463641010174685800128469053974698256194076125, q), q);\n', '        o.t2 = mulmod(i.t0, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t1, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t2, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t3, 17049854690034965250221386317058877242629221002521630573756355118745574274967, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t4, 4964394613021008685803675656098849539153699842663541444414978877928878266244, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t5, 15474947305445649466370538888925567099067120578851553103424183520405650587995, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t6, 1016119095639665978105768933448186152078842964810837543326777554729232767846, q), q);\n', '        o.t3 = mulmod(i.t0, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t1, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t2, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t3, 6905514380186323693285869145872115273350947784558995755916362330070690839131, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t4, 4783343257810358393326889022942241108539824540285247795235499223017138301952, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t5, 1420772902128122367335354247676760257656541121773854204774788519230732373317, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t6, 14172871439045259377975734198064051992755748777535789572469924335100006948373, q), q);\n', '        o.t4 = mulmod(i.t0, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t1, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t2, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t3, 13001155522144542028910638547179410124467185319212645031214919884423841839406, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t4, 16037892369576300958623292723740289861626299352695838577330319504984091062115, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t5, 19189494548480259335554606182055502469831573298885662881571444557262020106898, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t6, 19032687447778391106390582750185144485341165205399984747451318330476859342654, q), q);\n', '        o.t5 = mulmod(i.t0, 13272957914179340594010910867091459756043436017766464331915862093201960540910, q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t1, 9416416589114508529880440146952102328470363729880726115521103179442988482948, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t2, 8035240799672199706102747147502951589635001418759394863664434079699838251138, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t3, 21642389080762222565487157652540372010968704000567605990102641816691459811717, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t4, 20261355950827657195644012399234591122288573679402601053407151083849785332516, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t5, 14514189384576734449268559374569145463190040567900950075547616936149781403109, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t6, 19038036134886073991945204537416211699632292792787812530208911676638479944765, q), q);\n', '        o.t6 = mulmod(i.t0, 15627836782263662543041758927100784213807648787083018234961118439434298020664, q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t1, 5655785191024506056588710805596292231240948371113351452712848652644610823632, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t2, 8265264721707292643644260517162050867559314081394556886644673791575065394002, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t3, 17151144681903609082202835646026478898625761142991787335302962548605510241586, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t4, 18731644709777529787185361516475509623264209648904603914668024590231177708831, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t5, 20697789991623248954020701081488146717484139720322034504511115160686216223641, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t6, 6200020095464686209289974437830528853749866001482481427982839122465470640886, q), q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function ark(HashInputs7 memory i, uint q, uint c) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = addmod(i.t0, c, q);\n', '        o.t1 = addmod(i.t1, c, q);\n', '        o.t2 = addmod(i.t2, c, q);\n', '        o.t3 = addmod(i.t3, c, q);\n', '        o.t4 = addmod(i.t4, c, q);\n', '        o.t5 = addmod(i.t5, c, q);\n', '        o.t6 = addmod(i.t6, c, q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function sbox_full(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, i.t0, q);\n', '        o.t0 = mulmod(o.t0, o.t0, q);\n', '        o.t0 = mulmod(i.t0, o.t0, q);\n', '        o.t1 = mulmod(i.t1, i.t1, q);\n', '        o.t1 = mulmod(o.t1, o.t1, q);\n', '        o.t1 = mulmod(i.t1, o.t1, q);\n', '        o.t2 = mulmod(i.t2, i.t2, q);\n', '        o.t2 = mulmod(o.t2, o.t2, q);\n', '        o.t2 = mulmod(i.t2, o.t2, q);\n', '        o.t3 = mulmod(i.t3, i.t3, q);\n', '        o.t3 = mulmod(o.t3, o.t3, q);\n', '        o.t3 = mulmod(i.t3, o.t3, q);\n', '        o.t4 = mulmod(i.t4, i.t4, q);\n', '        o.t4 = mulmod(o.t4, o.t4, q);\n', '        o.t4 = mulmod(i.t4, o.t4, q);\n', '        o.t5 = mulmod(i.t5, i.t5, q);\n', '        o.t5 = mulmod(o.t5, o.t5, q);\n', '        o.t5 = mulmod(i.t5, o.t5, q);\n', '        o.t6 = mulmod(i.t6, i.t6, q);\n', '        o.t6 = mulmod(o.t6, o.t6, q);\n', '        o.t6 = mulmod(i.t6, o.t6, q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function sbox_partial(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, i.t0, q);\n', '        o.t0 = mulmod(o.t0, o.t0, q);\n', '        o.t0 = mulmod(i.t0, o.t0, q);\n', '        i.t0 = o.t0;\n', '    }\n', '\n', '    function hash_t7f6p52(HashInputs7 memory i, uint q) internal pure returns (uint)\n', '    {\n', '        // validate inputs\n', '        require(i.t0 < q, "INVALID_INPUT");\n', '        require(i.t1 < q, "INVALID_INPUT");\n', '        require(i.t2 < q, "INVALID_INPUT");\n', '        require(i.t3 < q, "INVALID_INPUT");\n', '        require(i.t4 < q, "INVALID_INPUT");\n', '        require(i.t5 < q, "INVALID_INPUT");\n', '        require(i.t6 < q, "INVALID_INPUT");\n', '\n', '        // round 0\n', '        ark(i, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 1\n', '        ark(i, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 2\n', '        ark(i, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 3\n', '        ark(i, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 4\n', '        ark(i, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 5\n', '        ark(i, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 6\n', '        ark(i, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 7\n', '        ark(i, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 8\n', '        ark(i, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 9\n', '        ark(i, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 10\n', '        ark(i, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 11\n', '        ark(i, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 12\n', '        ark(i, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 13\n', '        ark(i, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 14\n', '        ark(i, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 15\n', '        ark(i, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 16\n', '        ark(i, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 17\n', '        ark(i, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 18\n', '        ark(i, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 19\n', '        ark(i, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 20\n', '        ark(i, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 21\n', '        ark(i, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 22\n', '        ark(i, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 23\n', '        ark(i, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 24\n', '        ark(i, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 25\n', '        ark(i, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 26\n', '        ark(i, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 27\n', '        ark(i, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 28\n', '        ark(i, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 29\n', '        ark(i, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 30\n', '        ark(i, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 31\n', '        ark(i, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 32\n', '        ark(i, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 33\n', '        ark(i, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 34\n', '        ark(i, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 35\n', '        ark(i, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 36\n', '        ark(i, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 37\n', '        ark(i, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 38\n', '        ark(i, q, 71447649211767888770311304010816315780740050029903404046389165015534756512);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 39\n', '        ark(i, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 40\n', '        ark(i, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 41\n', '        ark(i, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 42\n', '        ark(i, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 43\n', '        ark(i, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 44\n', '        ark(i, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 45\n', '        ark(i, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 46\n', '        ark(i, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 47\n', '        ark(i, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 48\n', '        ark(i, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 49\n', '        ark(i, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 50\n', '        ark(i, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 51\n', '        ark(i, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 52\n', '        ark(i, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 53\n', '        ark(i, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 54\n', '        ark(i, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 55\n', '        ark(i, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 56\n', '        ark(i, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 57\n', '        ark(i, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '\n', '        return i.t0;\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeBalances.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeBalances.\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ExchangeBalances\n', '{\n', '    using MathUint  for uint;\n', '\n', '    function verifyAccountBalance(\n', '        uint                              merkleRoot,\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        public\n', '        pure\n', '    {\n', '        require(\n', '            isAccountBalanceCorrect(merkleRoot, merkleProof),\n', '            "INVALID_MERKLE_TREE_DATA"\n', '        );\n', '    }\n', '\n', '    function isAccountBalanceCorrect(\n', '        uint                            merkleRoot,\n', '        ExchangeData.MerkleProof memory merkleProof\n', '        )\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // Calculate the Merkle root using the Merkle paths provided\n', '        uint calculatedRoot = getBalancesRoot(\n', '            merkleProof.balanceLeaf.tokenID,\n', '            merkleProof.balanceLeaf.balance,\n', '            merkleProof.balanceLeaf.weightAMM,\n', '            merkleProof.balanceLeaf.storageRoot,\n', '            merkleProof.balanceMerkleProof\n', '        );\n', '        calculatedRoot = getAccountInternalsRoot(\n', '            merkleProof.accountLeaf.accountID,\n', '            merkleProof.accountLeaf.owner,\n', '            merkleProof.accountLeaf.pubKeyX,\n', '            merkleProof.accountLeaf.pubKeyY,\n', '            merkleProof.accountLeaf.nonce,\n', '            merkleProof.accountLeaf.feeBipsAMM,\n', '            calculatedRoot,\n', '            merkleProof.accountMerkleProof\n', '        );\n', '        // Check against the expected Merkle root\n', '        return (calculatedRoot == merkleRoot);\n', '    }\n', '\n', '    function getBalancesRoot(\n', '        uint16   tokenID,\n', '        uint     balance,\n', '        uint     weightAMM,\n', '        uint     storageRoot,\n', '        uint[24] memory balanceMerkleProof\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        // Hash the balance leaf\n', '        uint balanceItem = hashImpl(balance, weightAMM, storageRoot, 0);\n', '        // Calculate the Merkle root of the balance quad Merkle tree\n', '        uint _id = tokenID;\n', '        for (uint depth = 0; depth < 8; depth++) {\n', '            uint base = depth * 3;\n', '            if (_id & 3 == 0) {\n', '                balanceItem = hashImpl(\n', '                    balanceItem,\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 1) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceItem,\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 2) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceItem,\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 3) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2],\n', '                    balanceItem\n', '                );\n', '            }\n', '            _id = _id >> 2;\n', '        }\n', '        return balanceItem;\n', '    }\n', '\n', '    function getAccountInternalsRoot(\n', '        uint32   accountID,\n', '        address  owner,\n', '        uint     pubKeyX,\n', '        uint     pubKeyY,\n', '        uint     nonce,\n', '        uint     feeBipsAMM,\n', '        uint     balancesRoot,\n', '        uint[48] memory accountMerkleProof\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        // Hash the account leaf\n', '        uint accountItem = hashAccountLeaf(uint(owner), pubKeyX, pubKeyY, nonce, feeBipsAMM, balancesRoot);\n', '        // Calculate the Merkle root of the account quad Merkle tree\n', '        uint _id = accountID;\n', '        for (uint depth = 0; depth < 16; depth++) {\n', '            uint base = depth * 3;\n', '            if (_id & 3 == 0) {\n', '                accountItem = hashImpl(\n', '                    accountItem,\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 1) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountItem,\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 2) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountItem,\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 3) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2],\n', '                    accountItem\n', '                );\n', '            }\n', '            _id = _id >> 2;\n', '        }\n', '        return accountItem;\n', '    }\n', '\n', '    function hashAccountLeaf(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3,\n', '        uint t4,\n', '        uint t5\n', '        )\n', '        public\n', '        pure\n', '        returns (uint)\n', '    {\n', '        Poseidon.HashInputs7 memory inputs = Poseidon.HashInputs7(t0, t1, t2, t3, t4, t5, 0);\n', '        return Poseidon.hash_t7f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD);\n', '    }\n', '\n', '    function hashImpl(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        Poseidon.HashInputs5 memory inputs = Poseidon.HashInputs5(t0, t1, t2, t3, 0);\n', '        return Poseidon.hash_t5f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ERC20SafeTransfer.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ERC20SafeTransfer\n', '{\n', '    function safeTransferAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferWithGasLimitAndVerify(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferWithGasLimit(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimitAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            safeTransferWithGasLimit(token, to, value, gasLimit),\n', '            "TRANSFER_FAILURE"\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimit(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFromAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferFromWithGasLimitAndVerify(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFromWithGasLimitAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        bool result = safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasLimit\n', '        );\n', '        require(result, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    function safeTransferFromWithGasLimit(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeTokens.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeTokens.\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ExchangeTokens\n', '{\n', '    using MathUint          for uint;\n', '    using ERC20SafeTransfer for address;\n', '    using ExchangeMode      for ExchangeData.State;\n', '\n', '    event TokenRegistered(\n', '        address token,\n', '        uint16  tokenId\n', '    );\n', '\n', '    function getTokenAddress(\n', '        ExchangeData.State storage S,\n', '        uint16 tokenID\n', '        )\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        require(tokenID < S.tokens.length, "INVALID_TOKEN_ID");\n', '        return S.tokens[tokenID].token;\n', '    }\n', '\n', '    function registerToken(\n', '        ExchangeData.State storage S,\n', '        address tokenAddress\n', '        )\n', '        public\n', '        returns (uint16 tokenID)\n', '    {\n', '        require(!S.isInWithdrawalMode(), "INVALID_MODE");\n', '        require(S.tokenToTokenId[tokenAddress] == 0, "TOKEN_ALREADY_EXIST");\n', '        require(S.tokens.length < ExchangeData.MAX_NUM_TOKENS, "TOKEN_REGISTRY_FULL");\n', '\n', '        // Check if the deposit contract supports the new token\n', '        if (S.depositContract != IDepositContract(0)) {\n', '            require(\n', '                S.depositContract.isTokenSupported(tokenAddress),\n', '                "UNSUPPORTED_TOKEN"\n', '            );\n', '        }\n', '\n', '        // Assign a tokenID and store the token\n', '        ExchangeData.Token memory token = ExchangeData.Token(\n', '            tokenAddress\n', '        );\n', '        tokenID = uint16(S.tokens.length);\n', '        S.tokens.push(token);\n', '        S.tokenToTokenId[tokenAddress] = tokenID + 1;\n', '\n', '        emit TokenRegistered(tokenAddress, tokenID);\n', '    }\n', '\n', '    function getTokenID(\n', '        ExchangeData.State storage S,\n', '        address tokenAddress\n', '        )\n', '        internal  // inline call\n', '        view\n', '        returns (uint16 tokenID)\n', '    {\n', '        tokenID = S.tokenToTokenId[tokenAddress];\n', '        require(tokenID != 0, "TOKEN_NOT_FOUND");\n', '        tokenID = tokenID - 1;\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeWithdrawals.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeWithdrawals.\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'library ExchangeWithdrawals\n', '{\n', '    enum WithdrawalCategory\n', '    {\n', '        DISTRIBUTION,\n', '        FROM_MERKLE_TREE,\n', '        FROM_DEPOSIT_REQUEST,\n', '        FROM_APPROVED_WITHDRAWAL\n', '    }\n', '\n', '    using AddressUtil       for address;\n', '    using AddressUtil       for address payable;\n', '    using BytesUtil         for bytes;\n', '    using MathUint          for uint;\n', '    using ExchangeBalances  for ExchangeData.State;\n', '    using ExchangeMode      for ExchangeData.State;\n', '    using ExchangeTokens    for ExchangeData.State;\n', '\n', '    event ForcedWithdrawalRequested(\n', '        address owner,\n', '        address token,\n', '        uint32  accountID\n', '    );\n', '\n', '    event WithdrawalCompleted(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    event WithdrawalFailed(\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    function forceWithdraw(\n', '        ExchangeData.State storage S,\n', '        address owner,\n', '        address token,\n', '        uint32  accountID\n', '        )\n', '        public\n', '    {\n', '        require(!S.isInWithdrawalMode(), "INVALID_MODE");\n', '        // Limit the amount of pending forced withdrawals so that the owner cannot be overwhelmed.\n', '        require(S.getNumAvailableForcedSlots() > 0, "TOO_MANY_REQUESTS_OPEN");\n', '        require(accountID < ExchangeData.MAX_NUM_ACCOUNTS, "INVALID_ACCOUNTID");\n', '\n', '        uint16 tokenID = S.getTokenID(token);\n', '\n', '        // A user needs to pay a fixed ETH withdrawal fee, set by the protocol.\n', '        uint withdrawalFeeETH = S.loopring.forcedWithdrawalFee();\n', '\n', '        // Check ETH value sent, can be larger than the expected withdraw fee\n', '        require(msg.value >= withdrawalFeeETH, "INSUFFICIENT_FEE");\n', '\n', '        // Send surplus of ETH back to the sender\n', '        uint feeSurplus = msg.value.sub(withdrawalFeeETH);\n', '        if (feeSurplus > 0) {\n', '            msg.sender.sendETHAndVerify(feeSurplus, gasleft());\n', '        }\n', '\n', '        // There can only be a single forced withdrawal per (account, token) pair.\n', '        require(\n', '            S.pendingForcedWithdrawals[accountID][tokenID].timestamp == 0,\n', '            "WITHDRAWAL_ALREADY_PENDING"\n', '        );\n', '\n', '        // Store the forced withdrawal request data\n', '        S.pendingForcedWithdrawals[accountID][tokenID] = ExchangeData.ForcedWithdrawal({\n', '            owner: owner,\n', '            timestamp: uint64(block.timestamp)\n', '        });\n', '\n', '        // Increment the number of pending forced transactions so we can keep count.\n', '        S.numPendingForcedTransactions++;\n', '\n', '        emit ForcedWithdrawalRequested(\n', '            owner,\n', '            token,\n', '            accountID\n', '        );\n', '    }\n', '\n', '    // We alow anyone to withdraw these funds for the account owner\n', '    function withdrawFromMerkleTree(\n', '        ExchangeData.State       storage S,\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        public\n', '    {\n', '        require(S.isInWithdrawalMode(), "NOT_IN_WITHDRAW_MODE");\n', '\n', '        address owner = merkleProof.accountLeaf.owner;\n', '        uint32 accountID = merkleProof.accountLeaf.accountID;\n', '        uint16 tokenID = merkleProof.balanceLeaf.tokenID;\n', '        uint96 balance = merkleProof.balanceLeaf.balance;\n', '\n', "        // Make sure the funds aren't withdrawn already.\n", '        require(S.withdrawnInWithdrawMode[accountID][tokenID] == false, "WITHDRAWN_ALREADY");\n', '\n', '        // Verify that the provided Merkle tree data is valid by using the Merkle proof.\n', '        ExchangeBalances.verifyAccountBalance(\n', '            uint(S.merkleRoot),\n', '            merkleProof\n', '        );\n', '\n', '        // Make sure the balance can only be withdrawn once\n', '        S.withdrawnInWithdrawMode[accountID][tokenID] = true;\n', '\n', '        // Transfer the tokens to the account owner\n', '        transferTokens(\n', '            S,\n', '            uint8(WithdrawalCategory.FROM_MERKLE_TREE),\n', '            owner,\n', '            owner,\n', '            tokenID,\n', '            balance,\n', '            new bytes(0),\n', '            gasleft(),\n', '            false\n', '        );\n', '    }\n', '\n', '    function withdrawFromDepositRequest(\n', '        ExchangeData.State storage S,\n', '        address owner,\n', '        address token\n', '        )\n', '        public\n', '    {\n', '        uint16 tokenID = S.getTokenID(token);\n', '        ExchangeData.Deposit storage deposit = S.pendingDeposits[owner][tokenID];\n', '        require(deposit.timestamp != 0, "DEPOSIT_NOT_WITHDRAWABLE_YET");\n', '\n', '        // Check if the deposit has indeed exceeded the time limit of if the exchange is in withdrawal mode\n', '        require(\n', '            block.timestamp >= deposit.timestamp + S.maxAgeDepositUntilWithdrawable ||\n', '            S.isInWithdrawalMode(),\n', '            "DEPOSIT_NOT_WITHDRAWABLE_YET"\n', '        );\n', '\n', '        uint amount = deposit.amount;\n', '\n', '        // Reset the deposit request\n', '        delete S.pendingDeposits[owner][tokenID];\n', '\n', '        // Transfer the tokens\n', '        transferTokens(\n', '            S,\n', '            uint8(WithdrawalCategory.FROM_DEPOSIT_REQUEST),\n', '            owner,\n', '            owner,\n', '            tokenID,\n', '            amount,\n', '            new bytes(0),\n', '            gasleft(),\n', '            false\n', '        );\n', '    }\n', '\n', '    function withdrawFromApprovedWithdrawals(\n', '        ExchangeData.State storage S,\n', '        address[] memory owners,\n', '        address[] memory tokens\n', '        )\n', '        public\n', '    {\n', '        require(owners.length == tokens.length, "INVALID_INPUT_DATA");\n', '        for (uint i = 0; i < owners.length; i++) {\n', '            address owner = owners[i];\n', '            uint16 tokenID = S.getTokenID(tokens[i]);\n', '            uint amount = S.amountWithdrawable[owner][tokenID];\n', '\n', "            // Make sure this amount can't be withdrawn again\n", '            delete S.amountWithdrawable[owner][tokenID];\n', '\n', '            // Transfer the tokens to the owner\n', '            transferTokens(\n', '                S,\n', '                uint8(WithdrawalCategory.FROM_APPROVED_WITHDRAWAL),\n', '                owner,\n', '                owner,\n', '                tokenID,\n', '                amount,\n', '                new bytes(0),\n', '                gasleft(),\n', '                false\n', '            );\n', '        }\n', '    }\n', '\n', '    function distributeWithdrawal(\n', '        ExchangeData.State storage S,\n', '        address from,\n', '        address to,\n', '        uint16  tokenID,\n', '        uint    amount,\n', '        bytes   memory extraData,\n', '        uint    gasLimit\n', '        )\n', '        public\n', '    {\n', '        // Try to transfer the tokens\n', '        bool success = transferTokens(\n', '            S,\n', '            uint8(WithdrawalCategory.DISTRIBUTION),\n', '            from,\n', '            to,\n', '            tokenID,\n', '            amount,\n', '            extraData,\n', '            gasLimit,\n', '            true\n', '        );\n', "        // If the transfer was successful there's nothing left to do.\n", '        // However, if the transfer failed the tokens are still in the contract and can be\n', '        // withdrawn later to `to` by anyone by using `withdrawFromApprovedWithdrawal.\n', '        if (!success) {\n', '            S.amountWithdrawable[to][tokenID] = S.amountWithdrawable[to][tokenID].add(amount);\n', '        }\n', '    }\n', '\n', '    // == Internal and Private Functions ==\n', '\n', '    // If allowFailure is true the transfer can fail because of a transfer error or\n', '    // because the transfer uses more than `gasLimit` gas. The function\n', '    // will return true when successful, false otherwise.\n', '    // If allowFailure is false the transfer is guaranteed to succeed using\n', '    // as much gas as needed, otherwise it throws. The function always returns true.\n', '    function transferTokens(\n', '        ExchangeData.State storage S,\n', '        uint8   category,\n', '        address from,\n', '        address to,\n', '        uint16  tokenID,\n', '        uint    amount,\n', '        bytes   memory extraData,\n', '        uint    gasLimit,\n', '        bool    allowFailure\n', '        )\n', '        private\n', '        returns (bool success)\n', '    {\n', '        // Redirect withdrawals to address(0) to the protocol fee vault\n', '        if (to == address(0)) {\n', '            to = S.loopring.protocolFeeVault();\n', '        }\n', '        address token = S.getTokenAddress(tokenID);\n', '\n', '        // Transfer the tokens from the deposit contract to the owner\n', '        if (gasLimit > 0) {\n', '            try S.depositContract.withdraw{gas: gasLimit}(from, to, token, amount, extraData) {\n', '                success = true;\n', '            } catch {\n', '                success = false;\n', '            }\n', '        } else {\n', '            success = false;\n', '        }\n', '\n', '        require(allowFailure || success, "TRANSFER_FAILURE");\n', '\n', '        if (success) {\n', '            emit WithdrawalCompleted(category, from, to, token, amount);\n', '\n', '            // Keep track of when the protocol fees were last withdrawn\n', '            // (only done to make this data easier available).\n', '            if (from == address(0)) {\n', '                S.protocolFeeLastWithdrawnTime[token] = block.timestamp;\n', '            }\n', '        } else {\n', '            emit WithdrawalFailed(category, from, to, token, amount);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libtransactions/WithdrawTransaction.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title WithdrawTransaction\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev The following 4 types of withdrawals are supported:\n', '///      - withdrawType = 0: offchain withdrawals with EdDSA signatures\n', '///      - withdrawType = 1: offchain withdrawals with ECDSA signatures or onchain appprovals\n', '///      - withdrawType = 2: onchain valid forced withdrawals (owner and accountID match), or\n', '///                          offchain operator-initiated withdrawals for protocol fees or for\n', '///                          users in shutdown mode\n', '///      - withdrawType = 3: onchain invalid forced withdrawals (owner and accountID mismatch)\n', 'library WithdrawTransaction\n', '{\n', '    using BytesUtil            for bytes;\n', '    using FloatUtil            for uint16;\n', '    using MathUint             for uint;\n', '    using ExchangeMode         for ExchangeData.State;\n', '    using ExchangeSignatures   for ExchangeData.State;\n', '    using ExchangeWithdrawals  for ExchangeData.State;\n', '\n', '    bytes32 constant public WITHDRAWAL_TYPEHASH = keccak256(\n', '        "Withdrawal(address owner,uint32 accountID,uint16 tokenID,uint96 amount,uint16 feeTokenID,uint96 maxFee,address to,bytes extraData,uint256 minGas,uint32 validUntil,uint32 storageID)"\n', '    );\n', '\n', '    struct Withdrawal\n', '    {\n', '        uint    withdrawalType;\n', '        address from;\n', '        uint32  fromAccountID;\n', '        uint16  tokenID;\n', '        uint96  amount;\n', '        uint16  feeTokenID;\n', '        uint96  maxFee;\n', '        uint96  fee;\n', '        address to;\n', '        bytes   extraData;\n', '        uint    minGas;\n', '        uint32  validUntil;\n', '        uint32  storageID;\n', '        bytes20 onchainDataHash;\n', '    }\n', '\n', '    // Auxiliary data for each withdrawal\n', '    struct WithdrawalAuxiliaryData\n', '    {\n', '        bool  storeRecipient;\n', '        uint  gasLimit;\n', '        bytes signature;\n', '\n', '        uint    minGas;\n', '        address to;\n', '        bytes   extraData;\n', '        uint96  maxFee;\n', '        uint32  validUntil;\n', '    }\n', '\n', '    function process(\n', '        ExchangeData.State        storage S,\n', '        ExchangeData.BlockContext memory  ctx,\n', '        bytes                     memory  data,\n', '        uint                              offset,\n', '        bytes                     memory  auxiliaryData\n', '        )\n', '        internal\n', '    {\n', '        Withdrawal memory withdrawal;\n', '        readTx(data, offset, withdrawal);\n', '        WithdrawalAuxiliaryData memory auxData = abi.decode(auxiliaryData, (WithdrawalAuxiliaryData));\n', '\n', '        // Validate the withdrawal data not directly part of the DA\n', '        bytes20 onchainDataHash = hashOnchainData(\n', '            auxData.minGas,\n', '            auxData.to,\n', '            auxData.extraData\n', '        );\n', '        // Only the 20 MSB are used, which is still 80-bit of security, which is more\n', '        // than enough, especially when combined with validUntil.\n', '        require(withdrawal.onchainDataHash == onchainDataHash, "INVALID_WITHDRAWAL_DATA");\n', '\n', '        // Fill in withdrawal data missing from DA\n', '        withdrawal.to = auxData.to;\n', '        withdrawal.minGas = auxData.minGas;\n', '        withdrawal.extraData = auxData.extraData;\n', '        withdrawal.maxFee = auxData.maxFee == 0 ? withdrawal.fee : auxData.maxFee;\n', '        withdrawal.validUntil = auxData.validUntil;\n', '\n', "        // If the account has an owner, don't allow withdrawing to the zero address\n", '        // (which will be the protocol fee vault contract).\n', '        require(withdrawal.from == address(0) || withdrawal.to != address(0), "INVALID_WITHDRAWAL_RECIPIENT");\n', '\n', '        if (withdrawal.withdrawalType == 0) {\n', '            // Signature checked offchain, nothing to do\n', '        } else if (withdrawal.withdrawalType == 1) {\n', '            // Validate\n', '            require(ctx.timestamp < withdrawal.validUntil, "WITHDRAWAL_EXPIRED");\n', '            require(withdrawal.fee <= withdrawal.maxFee, "WITHDRAWAL_FEE_TOO_HIGH");\n', '\n', '            // Check appproval onchain\n', '            // Calculate the tx hash\n', '            bytes32 txHash = hashTx(ctx.DOMAIN_SEPARATOR, withdrawal);\n', '            // Check onchain authorization\n', '            S.requireAuthorizedTx(withdrawal.from, auxData.signature, txHash);\n', '        } else if (withdrawal.withdrawalType == 2 || withdrawal.withdrawalType == 3) {\n', '            // Forced withdrawals cannot make use of certain features because the\n', '            // necessary data is not authorized by the account owner.\n', '            // For protocol fee withdrawals, `owner` and `to` are both address(0).\n', '            require(withdrawal.from == withdrawal.to, "INVALID_WITHDRAWAL_ADDRESS");\n', '\n', '            // Forced withdrawal fees are charged when the request is submitted.\n', '            require(withdrawal.fee == 0, "FEE_NOT_ZERO");\n', '\n', '            require(withdrawal.extraData.length == 0, "AUXILIARY_DATA_NOT_ALLOWED");\n', '\n', '            ExchangeData.ForcedWithdrawal memory forcedWithdrawal =\n', '                S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];\n', '\n', '            if (forcedWithdrawal.timestamp != 0) {\n', '                if (withdrawal.withdrawalType == 2) {\n', '                    require(withdrawal.from == forcedWithdrawal.owner, "INCONSISENT_OWNER");\n', '                } else { //withdrawal.withdrawalType == 3\n', '                    require(withdrawal.from != forcedWithdrawal.owner, "INCONSISENT_OWNER");\n', '                    require(withdrawal.amount == 0, "UNAUTHORIZED_WITHDRAWAL");\n', '                }\n', '\n', '                // delete the withdrawal request and free a slot\n', '                delete S.pendingForcedWithdrawals[withdrawal.fromAccountID][withdrawal.tokenID];\n', '                S.numPendingForcedTransactions--;\n', '            } else {\n', '                // Allow the owner to submit full withdrawals without authorization\n', '                // - when in shutdown mode\n', '                // - to withdraw protocol fees\n', '                require(\n', '                    withdrawal.fromAccountID == ExchangeData.ACCOUNTID_PROTOCOLFEE ||\n', '                    S.isShutdown(),\n', '                    "FULL_WITHDRAWAL_UNAUTHORIZED"\n', '                );\n', '            }\n', '        } else {\n', '            revert("INVALID_WITHDRAWAL_TYPE");\n', '        }\n', '\n', '        // Check if there is a withdrawal recipient\n', '        address recipient = S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];\n', '        if (recipient != address(0)) {\n', '            // Auxiliary data is not supported\n', '            require (withdrawal.extraData.length == 0, "AUXILIARY_DATA_NOT_ALLOWED");\n', '\n', '            // Set the new recipient address\n', '            withdrawal.to = recipient;\n', '            // Allow any amount of gas to be used on this withdrawal (which allows the transfer to be skipped)\n', '            withdrawal.minGas = 0;\n', '\n', '            // Do NOT delete the recipient to prevent replay attack\n', '            // delete S.withdrawalRecipient[withdrawal.owner][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID];\n', '        } else if (auxData.storeRecipient) {\n', '            // Store the destination address to mark the withdrawal as done\n', '            require(withdrawal.to != address(0), "INVALID_DESTINATION_ADDRESS");\n', '            S.withdrawalRecipient[withdrawal.from][withdrawal.to][withdrawal.tokenID][withdrawal.amount][withdrawal.storageID] = withdrawal.to;\n', '        }\n', '\n', '        // Validate gas provided\n', '        require(auxData.gasLimit >= withdrawal.minGas, "OUT_OF_GAS_FOR_WITHDRAWAL");\n', '\n', '        // Try to transfer the tokens with the provided gas limit\n', '        S.distributeWithdrawal(\n', '            withdrawal.from,\n', '            withdrawal.to,\n', '            withdrawal.tokenID,\n', '            withdrawal.amount,\n', '            withdrawal.extraData,\n', '            auxData.gasLimit\n', '        );\n', '    }\n', '\n', '    function readTx(\n', '        bytes      memory data,\n', '        uint              offset,\n', '        Withdrawal memory withdrawal\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        uint _offset = offset;\n', '\n', '        require(data.toUint8Unsafe(_offset) == uint8(ExchangeData.TransactionType.WITHDRAWAL), "INVALID_TX_TYPE");\n', '        _offset += 1;\n', '\n', '        // Extract the transfer data\n', "        // We don't use abi.decode for this because of the large amount of zero-padding\n", '        // bytes the circuit would also have to hash.\n', '        withdrawal.withdrawalType = data.toUint8Unsafe(_offset);\n', '        _offset += 1;\n', '        withdrawal.from = data.toAddressUnsafe(_offset);\n', '        _offset += 20;\n', '        withdrawal.fromAccountID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        withdrawal.tokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        withdrawal.amount = data.toUint96Unsafe(_offset);\n', '        _offset += 12;\n', '        withdrawal.feeTokenID = data.toUint16Unsafe(_offset);\n', '        _offset += 2;\n', '        withdrawal.fee = data.toUint16Unsafe(_offset).decodeFloat16();\n', '        _offset += 2;\n', '        withdrawal.storageID = data.toUint32Unsafe(_offset);\n', '        _offset += 4;\n', '        withdrawal.onchainDataHash = data.toBytes20Unsafe(_offset);\n', '        _offset += 20;\n', '    }\n', '\n', '    function hashTx(\n', '        bytes32 DOMAIN_SEPARATOR,\n', '        Withdrawal memory withdrawal\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return EIP712.hashPacked(\n', '            DOMAIN_SEPARATOR,\n', '            keccak256(\n', '                abi.encode(\n', '                    WITHDRAWAL_TYPEHASH,\n', '                    withdrawal.from,\n', '                    withdrawal.fromAccountID,\n', '                    withdrawal.tokenID,\n', '                    withdrawal.amount,\n', '                    withdrawal.feeTokenID,\n', '                    withdrawal.maxFee,\n', '                    withdrawal.to,\n', '                    keccak256(withdrawal.extraData),\n', '                    withdrawal.minGas,\n', '                    withdrawal.validUntil,\n', '                    withdrawal.storageID\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    function hashOnchainData(\n', '        uint    minGas,\n', '        address to,\n', '        bytes   memory extraData\n', '        )\n', '        internal\n', '        pure\n', '        returns (bytes20)\n', '    {\n', '        // Only the 20 MSB are used, which is still 80-bit of security, which is more\n', '        // than enough, especially when combined with validUntil.\n', '        return bytes20(keccak256(\n', '            abi.encodePacked(\n', '                minGas,\n', '                to,\n', '                extraData\n', '            )\n', '        ));\n', '    }\n', '}\n', '\n', '// File: contracts/aux/transactions/TransactionReader.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title TransactionReader\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Utility library to read transactions.\n', 'library TransactionReader {\n', '    using BlockReader       for bytes;\n', '    using TransactionReader for ExchangeData.Block;\n', '    using BytesUtil         for bytes;\n', '\n', '    function readDeposit(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '        returns (DepositTransaction.Deposit memory deposit)\n', '    {\n', '        _block.readTx(txIdx, txData);\n', '        DepositTransaction.readTx(txData, 0, deposit);\n', '    }\n', '\n', '    function readWithdrawal(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '        returns (WithdrawTransaction.Withdrawal memory withdrawal)\n', '    {\n', '        _block.readTx(txIdx, txData);\n', '        WithdrawTransaction.readTx(txData, 0, withdrawal);\n', '    }\n', '\n', '    function readAmmUpdate(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '        returns (AmmUpdateTransaction.AmmUpdate memory ammUpdate)\n', '    {\n', '        _block.readTx(txIdx, txData);\n', '        AmmUpdateTransaction.readTx(txData, 0, ammUpdate);\n', '    }\n', '\n', '    function readTransfer(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '        returns (TransferTransaction.Transfer memory transfer)\n', '    {\n', '        _block.readTx(txIdx, txData);\n', '        TransferTransaction.readTx(txData, 0, transfer);\n', '    }\n', '\n', '    function readSignatureVerification(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '        returns (SignatureVerificationTransaction.SignatureVerification memory verification)\n', '    {\n', '        _block.readTx(txIdx, txData);\n', '        SignatureVerificationTransaction.readTx(txData, 0, verification);\n', '    }\n', '\n', '    function readTx(\n', '        ExchangeData.Block memory _block,\n', '        uint txIdx,\n', '        bytes memory txData\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        _block.data.readTransactionData(txIdx, _block.blockSize, txData);\n', '    }\n', '\n', '    function readTxs(\n', '        ExchangeData.Block memory _block,\n', '        uint                      txIdx,\n', '        uint16                    numTransactions,\n', '        bytes              memory txsData\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        bytes memory txData = txsData;\n', '        uint TX_DATA_AVAILABILITY_SIZE = ExchangeData.TX_DATA_AVAILABILITY_SIZE;\n', '        for (uint i = 0; i < numTransactions; i++) {\n', '            _block.data.readTransactionData(txIdx + i, _block.blockSize, txData);\n', '            assembly {\n', '                txData := add(txData, TX_DATA_AVAILABILITY_SIZE)\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/amm/libamm/AmmUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmUtil\n', 'library AmmUtil\n', '{\n', '    using AddressUtil       for address;\n', '    using BytesUtil         for bytes;\n', '    using ERC20SafeTransfer for address;\n', '    using MathUint          for uint;\n', '    using TransactionReader for ExchangeData.Block;\n', '\n', '    uint8 public constant L2_SIGNATURE_TYPE = 16;\n', '\n', '    function verifySignatureL2(\n', '        AmmData.Context     memory  ctx,\n', '        bytes               memory  txsData,\n', '        address                     owner,\n', '        bytes32                     txHash,\n', '        bytes               memory  signature\n', '        )\n', '        internal\n', '        pure\n', '    {\n', '        // Check the signature type\n', '        require(signature.toUint8Unsafe(0) == L2_SIGNATURE_TYPE, "INVALID_SIGNATURE_TYPE");\n', '\n', '        // Read the signature verification transaction\n', '        SignatureVerificationTransaction.SignatureVerification memory verification;\n', '        SignatureVerificationTransaction.readTx(txsData, ctx.txIdx++ * ExchangeData.TX_DATA_AVAILABILITY_SIZE, verification);\n', '\n', '        // Verify that the hash was signed on L2\n', '        require(\n', '            verification.owner == owner &&\n', '            verification.data == uint(txHash) >> 3,\n', '            "INVALID_OFFCHAIN_L2_APPROVAL"\n', '        );\n', '    }\n', '\n', '    function isAlmostEqualAmount(\n', '        uint96 amount,\n', '        uint96 targetAmount\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if (targetAmount == 0) {\n', '            return amount == 0;\n', '        } else {\n', '            // Max rounding error for a float24 is 2/100000\n', '            // But relayer may use float rounding multiple times\n', '            // so the range is expanded to [100000 - 8, 100000 + 8]\n', '            uint ratio = (uint(amount) * 100000) / uint(targetAmount);\n', '            return (100000 - 8) <= ratio && ratio <= (100000 + 8);\n', '        }\n', '    }\n', '\n', '    function isAlmostEqualFee(\n', '        uint96 amount,\n', '        uint96 targetAmount\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', '        if (targetAmount == 0) {\n', '            return amount == 0;\n', '        } else {\n', '            // Max rounding error for a float16 is 5/1000\n', '            uint ratio = (uint(amount) * 1000) / uint(targetAmount);\n', '            return (1000 - 5) <= ratio && ratio <= (1000 + 5);\n', '        }\n', '    }\n', '\n', '    function transferIn(\n', '        address token,\n', '        uint    amount\n', '        )\n', '        internal\n', '    {\n', '        if (token == address(0)) {\n', '            require(msg.value == amount, "INVALID_ETH_VALUE");\n', '        } else if (amount > 0) {\n', '            token.safeTransferFromAndVerify(msg.sender, address(this), amount);\n', '        }\n', '    }\n', '\n', '    function transferOut(\n', '        address token,\n', '        uint    amount,\n', '        address to\n', '        )\n', '        internal\n', '    {\n', '        if (token == address(0)) {\n', '            to.sendETHAndVerify(amount, gasleft());\n', '        } else {\n', '            token.safeTransferAndVerify(to, amount);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/amm/libamm/AmmWithdrawal.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title AmmWithdrawal\n', 'library AmmWithdrawal\n', '{\n', '    using AmmPoolToken      for AmmData.State;\n', '    using AmmStatus         for AmmData.State;\n', '    using MathUint          for uint;\n', '\n', '    function withdrawWhenOffline(\n', '        AmmData.State storage S\n', '        )\n', '        public\n', '    {\n', '        _checkWithdrawalConditionInShutdown(S);\n', '\n', '        // Burn the full balance\n', '        uint poolAmount = S.balanceOf[msg.sender];\n', '        if (poolAmount > 0) {\n', '            S.transfer(address(this), poolAmount);\n', '        }\n', '\n', '        // Burn any additional pool tokens stuck in forced exits\n', '        AmmData.PoolExit storage exit = S.forcedExit[msg.sender];\n', '        if (exit.burnAmount > 0) {\n', '            poolAmount = poolAmount.add(exit.burnAmount);\n', '            delete S.forcedExit[msg.sender];\n', '        }\n', '\n', '        require(poolAmount > 0, "ZERO_POOL_AMOUNT");\n', '\n', '        // Withdraw the part owned of the pool\n', '        uint totalSupply = S.totalSupply();\n', '        for (uint i = 0; i < S.tokens.length; i++) {\n', '            address token = S.tokens[i].addr;\n', '            uint balance = token == address(0) ?\n', '                address(this).balance :\n', '                ERC20(token).balanceOf(address(this));\n', '\n', '            uint amount = balance.mul(poolAmount) / totalSupply;\n', '            AmmUtil.transferOut(token, amount, msg.sender);\n', '        }\n', '\n', '        S._totalSupply = S._totalSupply.sub(poolAmount);\n', '    }\n', '\n', '    function _checkWithdrawalConditionInShutdown(\n', '        AmmData.State storage S\n', '        )\n', '        private\n', '        view\n', '    {\n', '        IExchangeV3 exchange = S.exchange;\n', '        bool withdrawalMode = exchange.isInWithdrawalMode();\n', '\n', '        for (uint i = 0; i < S.tokens.length; i++) {\n', '            address token = S.tokens[i].addr;\n', '\n', '            require(\n', '                withdrawalMode && exchange.isWithdrawnInWithdrawalMode(S.accountID, token) ||\n', '                !withdrawalMode && !exchange.isForcedWithdrawalPending(S.accountID, token),\n', '                "PENDING_WITHDRAWAL"\n', '            );\n', '\n', '            // Check that nothing is withdrawable anymore.\n', '            require(\n', '                exchange.getAmountWithdrawable(address(this), token) == 0,\n', '                "MORE_TO_WITHDRAW"\n', '            );\n', '        }\n', '    }\n', '}']