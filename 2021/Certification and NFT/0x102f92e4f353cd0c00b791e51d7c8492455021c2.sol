['pragma solidity ^0.7.5;\n', '\n', 'import "./IERC20.sol";\n', '\n', 'contract BouncyCoinRefund {\n', '\n', '    event Refunded(address addr, uint256 tokenAmount, uint256 ethAmount);\n', '\n', '    uint256 public constant MIN_EXCHANGE_RATE = 100000000;\n', '\n', '    address payable public owner;\n', '\n', '    uint256 public exchangeRate;\n', '\n', '    uint256 public totalRefunded;\n', '\n', '    IERC20 public bouncyCoinToken; \n', '\n', '    State public state;\n', '\n', '    enum State {\n', '        Active,\n', '        Inactive\n', '    }\n', '\n', '    /* Modifiers */\n', '\n', '    modifier atState(State _state) {\n', '        require(state == _state);\n', '        _;\n', '    }\n', '\n', '    modifier isOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /* Constructor */\n', '\n', '    constructor(address _bouncyCoinToken, uint256 _exchangeRate)\n', '        public\n', '        payable {\n', '        require(_bouncyCoinToken != address(0));\n', '        require(_exchangeRate >= MIN_EXCHANGE_RATE);\n', '\n', '        owner = msg.sender;\n', '        bouncyCoinToken = IERC20(_bouncyCoinToken);\n', '        exchangeRate = _exchangeRate;\n', '        state = State.Inactive;\n', '    }\n', '\n', '    /* Public functions */\n', '\n', '    fallback() external payable {\n', '        // no-op, just accept ETH        \n', '    }\n', '\n', '    function refund(uint256 _tokenAmount)\n', '        public\n', '        atState(State.Active) {\n', '\n', '        uint256 toRefund = _tokenAmount / exchangeRate;\n', '        uint256 bal = address(this).balance;\n', '\n', '        uint256 tokensToBurn;\n', '        if (toRefund > bal) {\n', '            // not enough ETH in contract, refund all\n', '            tokensToBurn = bal * exchangeRate;\n', '            toRefund = bal;\n', '        } else {\n', "            // we're good\n", '            tokensToBurn = _tokenAmount;\n', '        }\n', '\n', '        assert(bouncyCoinToken.transferFrom(msg.sender, address(1), tokensToBurn));\n', '        msg.sender.transfer(toRefund);\n', '        totalRefunded += toRefund;\n', '\n', '        emit Refunded(msg.sender, tokensToBurn, toRefund);\n', '    }\n', '\n', '    function setExchangeRate(uint256 _exchangeRate)\n', '        public\n', '        isOwner {\n', '        require(_exchangeRate > MIN_EXCHANGE_RATE);\n', '\n', '        exchangeRate = _exchangeRate;\n', '    }\n', '\n', '    function start()\n', '        public\n', '        isOwner {\n', '        state = State.Active;\n', '    }\n', '\n', '    function stop()\n', '        public\n', '        isOwner {\n', '        state = State.Inactive;\n', '    }\n', '\n', '    // In case of accidental ether lock on contract\n', '    function withdraw()\n', '        public\n', '        isOwner {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '    // In case of accidental token transfer to this address, owner can transfer it elsewhere\n', '    function transferERC20Token(address _tokenAddress, address _to, uint256 _value)\n', '        public\n', '        isOwner {\n', '        IERC20 token = IERC20(_tokenAddress);\n', '        assert(token.transfer(_to, _value));\n', '    }\n', '\n', '}']