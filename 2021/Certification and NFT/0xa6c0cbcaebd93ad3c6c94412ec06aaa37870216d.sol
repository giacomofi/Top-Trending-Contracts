['// SPDX-License-Identifier: MIT\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./ABDKMath64x64.sol";\n', '\n', 'import "./Orchestrator.sol";\n', '\n', 'import "./ProportionalLiquidity.sol";\n', '\n', 'import "./Swaps.sol";\n', '\n', 'import "./ViewLiquidity.sol";\n', '\n', 'import "./Storage.sol";\n', '\n', 'import "./MerkleProver.sol";\n', '\n', 'import "./IFreeFromUpTo.sol";\n', '\n', 'library Curves {\n', '    using ABDKMath64x64 for int128;\n', '\n', '    event Approval(address indexed _owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function add(\n', '        uint256 x,\n', '        uint256 y,\n', '        string memory errorMessage\n', '    ) private pure returns (uint256 z) {\n', '        require((z = x + y) >= x, errorMessage);\n', '    }\n', '\n', '    function sub(\n', '        uint256 x,\n', '        uint256 y,\n', '        string memory errorMessage\n', '    ) private pure returns (uint256 z) {\n', '        require((z = x - y) <= x, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(\n', '        Storage.Curve storage curve,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool) {\n', '        _transfer(curve, msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(\n', '        Storage.Curve storage curve,\n', '        address spender,\n', '        uint256 amount\n', '    ) external returns (bool) {\n', '        _approve(curve, msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`\n', '     */\n', '    function transferFrom(\n', '        Storage.Curve storage curve,\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool) {\n', '        _transfer(curve, sender, recipient, amount);\n', '        _approve(\n', '            curve,\n', '            sender,\n', '            msg.sender,\n', '            sub(curve.allowances[sender][msg.sender], amount, "Curve/insufficient-allowance")\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(\n', '        Storage.Curve storage curve,\n', '        address spender,\n', '        uint256 addedValue\n', '    ) external returns (bool) {\n', '        _approve(\n', '            curve,\n', '            msg.sender,\n', '            spender,\n', '            add(curve.allowances[msg.sender][spender], addedValue, "Curve/approval-overflow")\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(\n', '        Storage.Curve storage curve,\n', '        address spender,\n', '        uint256 subtractedValue\n', '    ) external returns (bool) {\n', '        _approve(\n', '            curve,\n', '            msg.sender,\n', '            spender,\n', '            sub(curve.allowances[msg.sender][spender], subtractedValue, "Curve/allowance-decrease-underflow")\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is public function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(\n', '        Storage.Curve storage curve,\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) private {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        curve.balances[sender] = sub(curve.balances[sender], amount, "Curve/insufficient-balance");\n', '        curve.balances[recipient] = add(curve.balances[recipient], amount, "Curve/transfer-overflow");\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\n', '     *\n', '     * This is public function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `_owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(\n', '        Storage.Curve storage curve,\n', '        address _owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) private {\n', '        require(_owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        curve.allowances[_owner][spender] = amount;\n', '        emit Approval(_owner, spender, amount);\n', '    }\n', '}\n', '\n', 'contract Curve is Storage, MerkleProver {\n', '    using SafeMath for uint256;\n', '\n', '    event Approval(address indexed _owner, address indexed spender, uint256 value);\n', '\n', '    event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\n', '\n', '    event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\n', '\n', '    event AssimilatorIncluded(\n', '        address indexed derivative,\n', '        address indexed numeraire,\n', '        address indexed reserve,\n', '        address assimilator\n', '    );\n', '\n', '    event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\n', '\n', '    event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event FrozenSet(bool isFrozen);\n', '\n', '    event EmergencyAlarm(bool isEmergency);\n', '\n', '    event WhitelistingStopped();\n', '\n', '    event Trade(\n', '        address indexed trader,\n', '        address indexed origin,\n', '        address indexed target,\n', '        uint256 originAmount,\n', '        uint256 targetAmount\n', '    );\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Curve/caller-is-not-owner");\n', '        _;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        require(notEntered, "Curve/re-entered");\n', '        notEntered = false;\n', '        _;\n', '        notEntered = true;\n', '    }\n', '\n', '    modifier transactable() {\n', '        require(!frozen, "Curve/frozen-only-allowing-proportional-withdraw");\n', '        _;\n', '    }\n', '\n', '    modifier isEmergency() {\n', '        require(emergency, "Curve/emergency-only-allowing-emergency-proportional-withdraw");\n', '        _;\n', '    }\n', '\n', '    modifier deadline(uint256 _deadline) {\n', '        require(block.timestamp < _deadline, "Curve/tx-deadline-passed");\n', '        _;\n', '    }\n', '\n', '    modifier inWhitelistingStage() {\n', '        require(whitelistingStage, "Curve/whitelist-stage-on-going");\n', '        _;\n', '    }\n', '\n', '    modifier notInWhitelistingStage() {\n', '        require(!whitelistingStage, "Curve/whitelist-stage-stopped");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        address[] memory _assets,\n', '        uint256[] memory _assetWeights\n', '    ) {\n', '        owner = msg.sender;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        emit OwnershipTransfered(address(0), msg.sender);\n', '\n', '        Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\n', '    }\n', '\n', '    /// @notice sets the parameters for the pool\n', '    /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n', '    /// @param _beta the value for beta must be less than alpha and greater than 0\n', '    /// @param _feeAtHalt the maximum value for the fee at the halt point\n', '    /// @param _epsilon the base fee for the pool\n', '    /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n', '    function setParams(\n', '        uint256 _alpha,\n', '        uint256 _beta,\n', '        uint256 _feeAtHalt,\n', '        uint256 _epsilon,\n', '        uint256 _lambda\n', '    ) external onlyOwner {\n', '        Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n', '    }\n', '\n', '    /// @notice excludes an assimilator from the curve\n', '    /// @param _derivative the address of the assimilator to exclude\n', '    function excludeDerivative(address _derivative) external onlyOwner {\n', '        for (uint256 i = 0; i < numeraires.length; i++) {\n', '            if (_derivative == numeraires[i]) revert("Curve/cannot-delete-numeraire");\n', '            if (_derivative == reserves[i]) revert("Curve/cannot-delete-reserve");\n', '        }\n', '\n', '        delete curve.assimilators[_derivative];\n', '    }\n', '\n', '    /// @notice view the current parameters of the curve\n', '    /// @return alpha_ the current alpha value\n', '    ///  beta_ the current beta value\n', '    ///  delta_ the current delta value\n', '    ///  epsilon_ the current epsilon value\n', '    ///  lambda_ the current lambda value\n', '    ///  omega_ the current omega value\n', '    function viewCurve()\n', '        external\n', '        view\n', '        returns (\n', '            uint256 alpha_,\n', '            uint256 beta_,\n', '            uint256 delta_,\n', '            uint256 epsilon_,\n', '            uint256 lambda_\n', '        )\n', '    {\n', '        return Orchestrator.viewCurve(curve);\n', '    }\n', '\n', '    function turnOffWhitelisting() external onlyOwner {\n', '        emit WhitelistingStopped();\n', '\n', '        whitelistingStage = false;\n', '    }\n', '\n', '    function setEmergency(bool _emergency) external onlyOwner {\n', '        emit EmergencyAlarm(_emergency);\n', '\n', '        emergency = _emergency;\n', '    }\n', '\n', '    function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\n', '        emit FrozenSet(_toFreezeOrNotToFreeze);\n', '\n', '        frozen = _toFreezeOrNotToFreeze;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) external onlyOwner {\n', '        require(_newOwner != address(0), "Curve/new-owner-cannot-be-zeroth-address");\n', '\n', '        emit OwnershipTransfered(owner, _newOwner);\n', '\n', '        owner = _newOwner;\n', '    }\n', '\n', '    /// @notice swap a dynamic origin amount for a fixed target amount\n', '    /// @param _origin the address of the origin\n', '    /// @param _target the address of the target\n', '    /// @param _originAmount the origin amount\n', '    /// @param _minTargetAmount the minimum target amount\n', '    /// @param _deadline deadline in block number after which the trade will not execute\n', '    /// @return targetAmount_ the amount of target that has been swapped for the origin amount\n', '    function originSwap(\n', '        address _origin,\n', '        address _target,\n', '        uint256 _originAmount,\n', '        uint256 _minTargetAmount,\n', '        uint256 _deadline\n', '    ) external deadline(_deadline) transactable nonReentrant returns (uint256 targetAmount_) {\n', '        targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender);\n', '\n', '        require(targetAmount_ >= _minTargetAmount, "Curve/below-min-target-amount");\n', '    }\n', '\n', '    /// @notice view how much target amount a fixed origin amount will swap for\n', '    /// @param _origin the address of the origin\n', '    /// @param _target the address of the target\n', '    /// @param _originAmount the origin amount\n', '    /// @return targetAmount_ the target amount that would have been swapped for the origin amount\n', '    function viewOriginSwap(\n', '        address _origin,\n', '        address _target,\n', '        uint256 _originAmount\n', '    ) external view transactable returns (uint256 targetAmount_) {\n', '        targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\n', '    }\n', '\n', '    /// @notice swap a dynamic origin amount for a fixed target amount\n', '    /// @param _origin the address of the origin\n', '    /// @param _target the address of the target\n', '    /// @param _maxOriginAmount the maximum origin amount\n', '    /// @param _targetAmount the target amount\n', '    /// @param _deadline deadline in block number after which the trade will not execute\n', '    /// @return originAmount_ the amount of origin that has been swapped for the target\n', '    function targetSwap(\n', '        address _origin,\n', '        address _target,\n', '        uint256 _maxOriginAmount,\n', '        uint256 _targetAmount,\n', '        uint256 _deadline\n', '    ) external deadline(_deadline) transactable nonReentrant returns (uint256 originAmount_) {\n', '        originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender);\n', '\n', '        require(originAmount_ <= _maxOriginAmount, "Curve/above-max-origin-amount");\n', '    }\n', '\n', '    /// @notice view how much of the origin currency the target currency will take\n', '    /// @param _origin the address of the origin\n', '    /// @param _target the address of the target\n', '    /// @param _targetAmount the target amount\n', '    /// @return originAmount_ the amount of target that has been swapped for the origin\n', '    function viewTargetSwap(\n', '        address _origin,\n', '        address _target,\n', '        uint256 _targetAmount\n', '    ) external view transactable returns (uint256 originAmount_) {\n', '        originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\n', '    }\n', '\n', '    /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n', '    /// @param  index Index corresponding to the merkleProof\n', '    /// @param  account Address coorresponding to the merkleProof\n', '    /// @param  amount Amount coorresponding to the merkleProof, should always be 1\n', '    /// @param  merkleProof Merkle proof\n', '    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n', '    ///                  the numeraire assets of the pool\n', '    /// @return (the amount of curves you receive in return for your deposit,\n', '    ///          the amount deposited for each numeraire)\n', '    function depositWithWhitelist(\n', '        uint256 index,\n', '        address account,\n', '        uint256 amount,\n', '        bytes32[] calldata merkleProof,\n', '        uint256 _deposit,\n', '        uint256 _deadline\n', '    ) external deadline(_deadline) transactable nonReentrant inWhitelistingStage returns (uint256, uint256[] memory) {\n', '        require(isWhitelisted(index, account, amount, merkleProof), "Curve/not-whitelisted");\n', '        require(msg.sender == account, "Curve/not-approved-user");\n', '\n', '        (uint256 curvesMinted_, uint256[] memory deposits_) =\n', '            ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n', '\n', '        whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\n', '\n', '        // 10k max deposit\n', '        if (whitelistedDeposited[msg.sender] > 10000e18) {\n', '            revert("Curve/exceed-whitelist-maximum-deposit");\n', '        }\n', '\n', '        return (curvesMinted_, deposits_);\n', '    }\n', '\n', '    /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n', '    /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n', '    ///                  the numeraire assets of the pool\n', '    /// @return (the amount of curves you receive in return for your deposit,\n', '    ///          the amount deposited for each numeraire)\n', '    function deposit(uint256 _deposit, uint256 _deadline)\n', '        external\n', '        deadline(_deadline)\n', '        transactable\n', '        nonReentrant\n', '        notInWhitelistingStage\n', '        returns (uint256, uint256[] memory)\n', '    {\n', '        // (curvesMinted_,  deposits_)\n', '        return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n', '    }\n', '\n', '    /// @notice view deposits and curves minted a given deposit would return\n', '    /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\n', '    ///                 prevailing proportions of the numeraire assets of the pool\n', '    /// @return (the amount of curves you receive in return for your deposit,\n', '    ///          the amount deposited for each numeraire)\n', '    function viewDeposit(uint256 _deposit) external view transactable returns (uint256, uint256[] memory) {\n', '        // curvesToMint_, depositsToMake_\n', '        return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\n', '    }\n', '\n', '    /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\n', '    ///          and no one is able to withdraw due to the invariant check\n', '    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n', '    ///                        numeraire assets of the pool\n', '    /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n', '    function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\n', '        external\n', '        isEmergency\n', '        deadline(_deadline)\n', '        nonReentrant\n', '        returns (uint256[] memory withdrawals_)\n', '    {\n', '        return ProportionalLiquidity.emergencyProportionalWithdraw(curve, _curvesToBurn);\n', '    }\n', '\n', '    /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\n', '    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n', '    ///                        numeraire assets of the pool\n', '    /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n', '    function withdraw(uint256 _curvesToBurn, uint256 _deadline)\n', '        external\n', '        deadline(_deadline)\n', '        nonReentrant\n', '        returns (uint256[] memory withdrawals_)\n', '    {\n', '        if (whitelistingStage) {\n', '            whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\n', '        }\n', '\n', '        return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n', '    }\n', '\n', '    /// @notice  views the withdrawal information from the pool\n', '    /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n', '    ///                        numeraire assets of the pool\n', '    /// @return the amonnts of numeraire assets withdrawn from the pool\n', '    function viewWithdraw(uint256 _curvesToBurn) external view transactable returns (uint256[] memory) {\n', '        return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\n', '        supports_ =\n', '            this.supportsInterface.selector == _interface || // erc165\n', '            bytes4(0x7f5828d0) == _interface || // eip173\n', '            bytes4(0x36372b07) == _interface; // erc20\n', '    }\n', '\n', '    /// @notice transfers curve tokens\n', '    /// @param _recipient the address of where to send the curve tokens\n', '    /// @param _amount the amount of curve tokens to send\n', '    /// @return success_ the success bool of the call\n', '    function transfer(address _recipient, uint256 _amount) public nonReentrant returns (bool success_) {\n', '        success_ = Curves.transfer(curve, _recipient, _amount);\n', '    }\n', '\n', '    /// @notice transfers curve tokens from one address to another address\n', '    /// @param _sender the account from which the curve tokens will be sent\n', '    /// @param _recipient the account to which the curve tokens will be sent\n', '    /// @param _amount the amount of curve tokens to transfer\n', '    /// @return success_ the success bool of the call\n', '    function transferFrom(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _amount\n', '    ) public nonReentrant returns (bool success_) {\n', '        success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\n', '    }\n', '\n', '    /// @notice approves a user to spend curve tokens on their behalf\n', '    /// @param _spender the account to allow to spend from msg.sender\n', '    /// @param _amount the amount to specify the spender can spend\n', '    /// @return success_ the success bool of this call\n', '    function approve(address _spender, uint256 _amount) public nonReentrant returns (bool success_) {\n', '        success_ = Curves.approve(curve, _spender, _amount);\n', '    }\n', '\n', '    /// @notice view the curve token balance of a given account\n', '    /// @param _account the account to view the balance of\n', '    /// @return balance_ the curve token ballance of the given account\n', '    function balanceOf(address _account) public view returns (uint256 balance_) {\n', '        balance_ = curve.balances[_account];\n', '    }\n', '\n', '    /// @notice views the total curve supply of the pool\n', '    /// @return totalSupply_ the total supply of curve tokens\n', '    function totalSupply() public view returns (uint256 totalSupply_) {\n', '        totalSupply_ = curve.totalSupply;\n', '    }\n', '\n', '    /// @notice views the total allowance one address has to spend from another address\n', '    /// @param _owner the address of the owner\n', '    /// @param _spender the address of the spender\n', '    /// @return allowance_ the amount the owner has allotted the spender\n', '    function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\n', '        allowance_ = curve.allowances[_owner][_spender];\n', '    }\n', '\n', '    /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\n', '    /// @return total_ the total value in the curve\n', '    /// @return individual_ the individual values in the curve\n', '    function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\n', '        return ViewLiquidity.viewLiquidity(curve);\n', '    }\n', '\n', '    /// @notice view the assimilator address for a derivative\n', '    /// @return assimilator_ the assimilator address\n', '    function assimilator(address _derivative) public view returns (address assimilator_) {\n', '        assimilator_ = curve.assimilators[_derivative].addr;\n', '    }\n', '}']