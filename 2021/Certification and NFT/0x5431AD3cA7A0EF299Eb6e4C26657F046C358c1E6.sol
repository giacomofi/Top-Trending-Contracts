['// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'import "./CollateralSplitParent.sol";\n', '\n', 'contract x5Split is CollateralSplitParent {\n', '    function symbol() external pure override returns (string memory) {\n', '        return "x5";\n', '    }\n', '\n', '    function splitNominalValue(int256 _normalizedValue)\n', '        public\n', '        pure\n', '        override\n', '        returns (int256)\n', '    {\n', '        if (_normalizedValue <= -(FRACTION_MULTIPLIER / 5)) {\n', '            return 0;\n', '        } else if (\n', '            _normalizedValue > -(FRACTION_MULTIPLIER / 5) &&\n', '            _normalizedValue < FRACTION_MULTIPLIER / 5\n', '        ) {\n', '            return (FRACTION_MULTIPLIER + _normalizedValue * 5) / 2;\n', '        } else {\n', '            return FRACTION_MULTIPLIER;\n', '        }\n', '    }\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'import "@openzeppelin/contracts/math/SignedSafeMath.sol";\n', 'import "./ICollateralSplit.sol";\n', 'import "../oracleIterators/IOracleIterator.sol";\n', '\n', 'abstract contract CollateralSplitParent is ICollateralSplit {\n', '    using SignedSafeMath for int256;\n', '\n', '    int256 public constant FRACTION_MULTIPLIER = 10**12;\n', '    int256 public constant NEGATIVE_INFINITY = type(int256).min;\n', '\n', '    function isCollateralSplit() external pure override returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    function split(\n', '        address[] calldata _oracles,\n', '        address[] calldata _oracleIterators,\n', '        int256[] calldata _underlyingStarts,\n', '        uint256 _settleTime,\n', '        uint256[] calldata _underlyingEndRoundHints\n', '    )\n', '        external\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256 _split, int256[] memory _underlyingEnds)\n', '    {\n', '        require(_oracles.length == 1, "More than one oracle");\n', '        require(_oracles[0] != address(0), "Oracle is empty");\n', '        require(_oracleIterators[0] != address(0), "Oracle iterator is empty");\n', '\n', '        _underlyingEnds = new int256[](1);\n', '\n', '        IOracleIterator iterator = IOracleIterator(_oracleIterators[0]);\n', '        require(iterator.isOracleIterator(), "Not oracle iterator");\n', '\n', '        _underlyingEnds[0] = iterator.getUnderlyingValue(\n', '            _oracles[0],\n', '            _settleTime,\n', '            _underlyingEndRoundHints\n', '        );\n', '\n', '        _split = range(\n', '            splitNominalValue(\n', '                normalize(_underlyingStarts[0], _underlyingEnds[0])\n', '            )\n', '        );\n', '    }\n', '\n', '    function splitNominalValue(int256 _normalizedValue)\n', '        public\n', '        pure\n', '        virtual\n', '        returns (int256);\n', '\n', '    function normalize(int256 _u_0, int256 _u_T)\n', '        public\n', '        pure\n', '        virtual\n', '        returns (int256)\n', '    {\n', '        require(_u_0 != NEGATIVE_INFINITY, "u_0 is absent");\n', '        require(_u_T != NEGATIVE_INFINITY, "u_T is absent");\n', '        require(_u_0 > 0, "u_0 is less or equal zero");\n', '\n', '        if (_u_T < 0) {\n', '            _u_T = 0;\n', '        }\n', '\n', '        return _u_T.sub(_u_0).mul(FRACTION_MULTIPLIER).div(_u_0);\n', '    }\n', '\n', '    function range(int256 _split) public pure returns (uint256) {\n', '        if (_split >= FRACTION_MULTIPLIER) {\n', '            return uint256(FRACTION_MULTIPLIER);\n', '        }\n', '        if (_split <= 0) {\n', '            return 0;\n', '        }\n', '        return uint256(_split);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title SignedSafeMath\n', ' * @dev Signed math operations with safety checks that revert on error.\n', ' */\n', 'library SignedSafeMath {\n', '    int256 constant private _INT256_MIN = -2**255;\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b, "SignedSafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two signed integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "SignedSafeMath: division by zero");\n', '        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '/// @title Collateral Split interface\n', '/// @notice Contains mathematical functions used to calculate relative claim\n', '/// on collateral of primary and complement assets after settlement.\n', '/// @dev Created independently from specification and published to the CollateralSplitRegistry\n', 'interface ICollateralSplit {\n', '    /// @notice Proof of collateral split contract\n', '    /// @dev Verifies that contract is a collateral split contract\n', '    /// @return true if contract is a collateral split contract\n', '    function isCollateralSplit() external pure returns (bool);\n', '\n', '    /// @notice Symbol of the collateral split\n', '    /// @dev Should be resolved through CollateralSplitRegistry contract\n', '    /// @return collateral split specification symbol\n', '    function symbol() external pure returns (string memory);\n', '\n', "    /// @notice Calcs primary asset class' share of collateral at settlement.\n", '    /// @dev Returns ranged value between 0 and 1 multiplied by 10 ^ 12\n', '    /// @param _underlyingStarts underlying values in the start of Live period\n', '    /// @param _underlyingEndRoundHints specify for each oracle round of the end of Live period\n', "    /// @return _split primary asset class' share of collateral at settlement\n", '    /// @return _underlyingEnds underlying values in the end of Live period\n', '    function split(\n', '        address[] calldata _oracles,\n', '        address[] calldata _oracleIterators,\n', '        int256[] calldata _underlyingStarts,\n', '        uint256 _settleTime,\n', '        uint256[] calldata _underlyingEndRoundHints\n', '    ) external view returns (uint256 _split, int256[] memory _underlyingEnds);\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface IOracleIterator {\n', '    /// @notice Proof of oracle iterator contract\n', '    /// @dev Verifies that contract is a oracle iterator contract\n', '    /// @return true if contract is a oracle iterator contract\n', '    function isOracleIterator() external pure returns (bool);\n', '\n', '    /// @notice Symbol of the oracle iterator\n', '    /// @dev Should be resolved through OracleIteratorRegistry contract\n', '    /// @return oracle iterator symbol\n', '    function symbol() external pure returns (string memory);\n', '\n', '    /// @notice Algorithm that, for the type of oracle used by the derivative,\n', '    //  finds the value closest to a given timestamp\n', '    /// @param _oracle iteratable oracle through\n', '    /// @param _timestamp a given timestamp\n', '    /// @param _roundHints specified rounds for a given timestamp\n', '    /// @return the value closest to a given timestamp\n', '    function getUnderlyingValue(\n', '        address _oracle,\n', '        uint256 _timestamp,\n', '        uint256[] calldata _roundHints\n', '    ) external view returns (int256);\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 1000000\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']