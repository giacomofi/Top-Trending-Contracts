['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-09\n', '*/\n', '\n', '// File: contracts/interface/farm/IFarmPool.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface IFarmPool {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function stake(uint256 amount) external;\n', '    function withdraw(uint256 amount) external;\n', '    function getReward() external;\n', '    function exit() external;\n', '}\n', '\n', '// File: contracts/interface/farm/IFarmVault.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface IFarmVault {\n', '    function underlyingBalanceInVault() external view returns (uint256);\n', '    function underlyingBalanceWithInvestment() external view returns (uint256);\n', '    function underlying() external view returns (address);\n', '    function underlyingUnit() external view returns(uint256);\n', '    function deposit(uint256 amountWei) external;\n', '    function withdraw(uint256 numberOfShares) external;\n', '    function getPricePerFullShare() external view returns (uint256);\n', '    function underlyingBalanceWithInvestmentForHolder(address holder) view external returns (uint256);\n', '\n', '}\n', '\n', '// File: contracts/interface/gof/IController.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface IController {\n', '    function vaults(address) external view returns (address);\n', '    function rewards() external view returns (address);\n', '}\n', '\n', '// File: contracts/interface/gof/GOFStrategy.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface GOFStrategy {\n', '    function want() external view returns (address);\n', '    function deposit() external;\n', '    function withdraw(address) external;\n', '    function withdraw(uint) external;\n', '    function withdrawAll() external returns (uint);\n', '    function balanceOf() external view returns (uint);\n', '}\n', '\n', '// File: contracts/interface/uniswap/IUniswapRouter.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'interface IUniswapRouter {\n', '    function swapExactTokensForTokens(uint, uint, address[] calldata, address, uint) external;\n', '}\n', '\n', '// File: contracts/V2/StrategyFarm.sol\n', '\n', 'pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function decimals() external view returns (uint);\n', '    function name() external view returns (string memory);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract StrategyFarm is GOFStrategy {\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    using SafeMath for uint256;\n', '    \n', '    address public want ;\n', '    address constant public output = address(0xa0246c9032bC3A600820415aE600c6388619A14D);\n', '    address constant public unirouter = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    address constant public weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); \n', '    address constant public gof = address(0x488E0369f9BC5C40C002eA7c1fe4fd01A198801c);\n', '\n', '    address public farmVault;\n', '    address public farmPool;\n', '\n', '    \n', '    uint public burnfee = 400;\n', '    uint public fee = 100;\n', '    uint public foundationfee = 400;\n', '    uint public callfee = 100;\n', '    uint public max = 1000;\n', '\n', '    uint public reservesRate = 100;\n', '    uint constant public cashMax = 1000;\n', '\n', '    uint public withdrawalFee = 0;\n', '    uint constant public withdrawalMax = 10000;\n', '    \n', '    address public governance;\n', '    address public strategyDev;\n', '    address public controller;\n', '    address public foundationAddress = 0x1250E38187Ff89d05f99F3fa0E324241bbE2120C;\n', '    address public burnAddress;\n', '\n', '    string public getName;\n', '\n', '    address[] public swap2GOFRouting;\n', '    address[] public swap2TokenRouting;\n', '    \n', '    struct StrategyBalance {\n', '        uint256 lpAmount;\n', '        uint256 pricePerFullShare;\n', '    }\n', '\n', '    StrategyBalance public balancePrior;\n', '    uint public reserves = 0;\n', '    bool public splitGof = true;\n', '\n', '    event UpdateBalance(uint256 _oldReserves, uint256 _newReserves, StrategyBalance _oldBalance, StrategyBalance _newBalance);\n', '    event ClaimReserves(uint256 _amount);\n', '    \n', '    constructor(\n', '        address _controller, \n', '        address _want,\n', '        address _farmVault,\n', '        address _farmPool,\n', '        address _burnAddress\n', '        ) public {\n', '        governance = msg.sender;\n', '        strategyDev = tx.origin;\n', '        controller = _controller;\n', '        burnAddress = _burnAddress;\n', '\n', '        want = _want;\n', '        farmVault = _farmVault;\n', '        farmPool = _farmPool;\n', '\n', '        getName = string(abi.encodePacked("golff:Strategy:", IERC20(want).name()));\n', '\n', '        balancePrior = currentStrategyBalance();\n', '\n', '        swap2TokenRouting = [output,weth,want];\n', '        swap2GOFRouting = [want,weth,gof];\n', '        doApprove();\n', '        \n', '    }\n', '\n', '    function doApprove () public{\n', '        IERC20(output).safeApprove(unirouter, 0);\n', '        IERC20(output).safeApprove(unirouter, uint(-1));\n', '\n', '        IERC20(want).safeApprove(unirouter, 0);\n', '        IERC20(want).safeApprove(unirouter, uint(-1));\n', '    }\n', '    \n', '    modifier onlyGovernance() {\n', '        require(msg.sender == governance, "Golff:!governance");\n', '        _;\n', '    }\n', '    \n', '    function updateReserves() internal {\n', '        uint _oldReserves = reserves;\n', '        StrategyBalance memory _oldBalance = balancePrior;\n', '\n', '        StrategyBalance memory current = currentStrategyBalance();\n', '        reserves = reserves.add(calcReserve(current.pricePerFullShare));\n', '        balancePrior = current;\n', '        \n', '        emit UpdateBalance(_oldReserves, reserves, _oldBalance, balancePrior);\n', '    }\n', '\n', '    function calcReserve(uint pricePerFullShare) internal view returns(uint) {\n', '        return balancePrior.lpAmount.mul(pricePerFullShare.sub(balancePrior.pricePerFullShare)).div(IFarmVault(farmVault).underlyingUnit());\n', '    }\n', '\n', '    function lpTokens() internal view returns (uint256) {\n', '        return IERC20(farmVault).balanceOf(address(this)).add(IFarmPool(farmPool).balanceOf(address(this)));\n', '    }\n', '\n', '    function currentStrategyBalance() internal view returns (StrategyBalance memory bal) {\n', '        bal = StrategyBalance({\n', '            lpAmount: lpTokens(),\n', '            pricePerFullShare: IFarmVault(farmVault).getPricePerFullShare()\n', '        });\n', '    }\n', '\n', '    function claimReserves(uint _r) public checkStrategist {\n', '        require(_r <= reserves, "Strategy:INSUFFICIENT_UNCLAIM");\n', '        reserves = reserves.sub(_r);\n', '        uint _balance = IERC20(want).balanceOf(address(this));\n', '\n', '        if (_balance < _r) {\n', '            _r = _withdrawSome(_r.sub(_balance));\n', '            _r = _r.add(_balance);\n', '            updateReserves();\n', '        }\n', '        \n', '        dosplit(_r);\n', '\n', '        emit ClaimReserves(_r);\n', '    }\n', '\n', '    function claimReservesAll() external checkStrategist {\n', '        claimReserves(reserves);\n', '    }\n', '\n', '    function deposit() public {\n', '        doDeposit();\n', '        updateReserves();\n', '    }\n', '\n', '    function doDeposit() internal {\n', '        uint _want = IERC20(want).balanceOf(address(this));\n', '        if (_want > 0) {\n', '            IERC20(want).safeApprove(farmVault, 0);\n', '            IERC20(want).safeApprove(farmVault, _want);\n', '            IFarmVault(farmVault).deposit(_want);\n', '        }\n', '        \n', '        _depositMine();\n', '    }\n', '\n', '    function _depositMine() internal {\n', '        uint _balance = IERC20(farmVault).balanceOf(address(this));\n', '        if (_balance > 0) {\n', '            IERC20(farmVault).safeApprove(farmPool, 0);\n', '            IERC20(farmVault).safeApprove(farmPool, _balance);\n', '            IFarmPool(farmPool).stake(_balance);\n', '        }\n', '    }\n', '    \n', '    // Controller only function for creating additional rewards from dust\n', '    function withdraw(address _asset) external {\n', '        require(msg.sender == controller, "Golff:!controller");\n', '        require(want != _asset, "Golff:want");\n', '        require(gof != _asset, "Golff:gof");\n', '        require(output != _asset, "Golff:output");\n', '        require(farmVault != _asset, "Golff:farmVault");\n', '        \n', '        uint256 balance = IERC20(_asset).balanceOf(address(this));\n', '        IERC20(_asset).safeTransfer(controller, balance);\n', '    }\n', '    \n', '    // Withdraw partial funds, normally used with a vault withdrawal\n', '    function withdraw(uint _amount) external {\n', '        require(msg.sender == controller || msg.sender == governance, "Golff:!controller");\n', '        if ( _amount > 0) {\n', '            uint _balance = IERC20(want).balanceOf(address(this));\n', '            if (_balance < _amount) {\n', '                _amount = _withdrawSome(_amount.sub(_balance));\n', '                _amount = _amount.add(_balance);\n', '            }\n', '\n', '            updateReserves();\n', '            \n', '            uint _fee = 0;\n', '            if (withdrawalFee>0){\n', '                _fee = _amount.mul(withdrawalFee).div(withdrawalMax);        \n', '                IERC20(want).safeTransfer(IController(controller).rewards(), _fee);\n', '            }\n', '            \n', '            address _vault = IController(controller).vaults(address(want));\n', '            require(_vault != address(0), "Golff:!vault"); // additional protection so we don\'t burn the funds\n', '            IERC20(want).safeTransfer(_vault, _amount.sub(_fee));\n', '        }\n', '    }\n', '\n', '    function _withdrawSome(uint256 _amount) internal returns (uint) {\n', '        uint256 _share = _amount.mul(IFarmVault(farmVault).underlyingUnit()).div(IFarmVault(farmVault).getPricePerFullShare());\n', '        uint _balance = IERC20(farmVault).balanceOf(address(this));\n', '        if (_balance < _share) {\n', '            IFarmPool(farmPool).withdraw(_share.sub(_balance));\n', '            _balance = IERC20(farmVault).balanceOf(address(this));\n', '        }\n', '\n', '        if (_share > _balance) {\n', '            _share = _balance;\n', '        }\n', '\n', '        uint256 _wantBal = IERC20(want).balanceOf(address(this));\n', '        IFarmVault(farmVault).withdraw(_share);\n', '        _wantBal = IERC20(want).balanceOf(address(this)).sub(_wantBal);\n', '        return _wantBal;\n', '    }\n', '    \n', '    // Withdraw all funds, normally used when migrating strategies\n', '    function withdrawAll() external returns (uint balance) {\n', '        require(msg.sender == controller || msg.sender == governance,"Golff:!governance");\n', '        _withdrawAll();\n', '\n', '        updateReserves();\n', '        \n', '        balance = IERC20(want).balanceOf(address(this));\n', '        \n', '        address _vault = IController(controller).vaults(address(want));\n', '        require(_vault != address(0), "Golff:!vault"); // additional protection so we don\'t burn the funds\n', '        if (balance > reserves) {\n', '            IERC20(want).safeTransfer(_vault, balance.sub(reserves));\n', '        }\n', '    }\n', '    \n', '    function _withdrawAll() internal {\n', '        uint256 _poolBal = IFarmPool(farmPool).balanceOf(address(this));\n', '        if (_poolBal > 0) {\n', '            IFarmPool(farmPool).exit();\n', '        }\n', '\n', '        uint _balance = IERC20(farmVault).balanceOf(address(this));\n', '        if (_balance > 0) {\n', '            IFarmVault(farmVault).withdraw(_balance);\n', '        }\n', '    }\n', '\n', '    modifier checkStrategist(){\n', '        require(msg.sender == strategyDev || msg.sender == governance,"Golff:!strategyDev");\n', '        _;\n', '    }\n', '    \n', '    function harvest() external checkStrategist {\n', '        uint _before = IERC20(want).balanceOf(address(this));\n', '        IFarmPool(farmPool).getReward();\n', '        doswap();\n', '        uint _a = IERC20(want).balanceOf(address(this)).sub(_before);\n', '        uint _sb = _a.mul(reservesRate).div(cashMax);\n', '        dosplit(_sb);\n', '        doDeposit();\n', '        updateReserves();\n', '    }\n', '\n', '    function doswap() internal {\n', '        uint256 _balance = IERC20(output).balanceOf(address(this));\n', '        if(_balance > 0 && output != want){\n', '            IUniswapRouter(unirouter).swapExactTokensForTokens(_balance, 0, swap2TokenRouting, address(this), now.add(1800));\n', '        }\n', '\n', '    }\n', '\n', '    function dosplit(uint _b) internal{\n', '        if (_b > 0) {\n', '            if (splitGof) {\n', '                IUniswapRouter(unirouter).swapExactTokensForTokens(_b, 0, swap2GOFRouting, address(this), now.add(1800));\n', '                _b = IERC20(gof).balanceOf(address(this));\n', '                split(IERC20(gof), _b);\n', '            } else {\n', '                split(IERC20(want), _b);\n', '            }\n', '        }\n', '    }\n', '\n', '    function split(IERC20 token, uint b) internal{\n', '        if (b > 0) {\n', '            uint _fee = b.mul(fee).div(max);\n', '            uint _foundationfee = b.mul(foundationfee).div(max);\n', '            uint _burnfee = b.mul(burnfee).div(max); \n', '            uint _callfee = b.sub(_burnfee).sub(_foundationfee).sub(_fee);\n', '            if (_fee > 0){\n', '                token.safeTransfer(IController(controller).rewards(), _fee); \n', '            }\n', '            if (_callfee > 0) {\n', '                token.safeTransfer(msg.sender, _callfee); \n', '            }\n', '            if (_foundationfee > 0) {\n', '                token.safeTransfer(foundationAddress, _foundationfee); \n', '            }\n', '            if (_burnfee >0){\n', '                token.safeTransfer(burnAddress, _burnfee);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function balanceOfWant() public view returns (uint) {\n', '        return IERC20(want).balanceOf(address(this));\n', '    }\n', '\n', '    function balanceOfPool() public view returns (uint) {\n', '        return lpTokens().mul(IFarmVault(farmVault).getPricePerFullShare()).div(IFarmVault(farmVault).underlyingUnit());\n', '    }\n', '    \n', '    function balanceAll() public view returns (uint) {\n', '        return balanceOfWant()\n', '               .add(balanceOfPool());\n', '    }\n', '\n', '    function balanceOf() external view returns (uint) {\n', '        uint _all = balanceAll();\n', '        uint _cReserve = reserves.add(calcReserve(IFarmVault(farmVault).getPricePerFullShare()));\n', '        if (_all < _cReserve) {\n', '            return 0;\n', '        } else {\n', '            return _all.sub(_cReserve);\n', '        }\n', '    }\n', '    \n', '    function setGovernance(address _governance) external onlyGovernance {\n', '        governance = _governance;\n', '    }\n', '    \n', '    function setController(address _controller) external onlyGovernance {\n', '        controller = _controller;\n', '    }\n', '\n', '    function setFees(uint256 _fee, uint256 _callfee, uint256 _burnfee, uint256 _foundationfee) external onlyGovernance{\n', '\n', '        fee = _fee;\n', '        callfee = _callfee;\n', '        burnfee = _burnfee;\n', '        foundationfee = _foundationfee;\n', '\n', '        max = fee.add(callfee).add(burnfee).add(foundationfee);\n', '    }\n', '\n', '    function setReservesRate(uint256 _reservesRate) external onlyGovernance {\n', '        require(_reservesRate < cashMax, "reservesRate >= 1000");\n', '        reservesRate = _reservesRate;\n', '    }\n', '\n', '    function setFoundationAddress(address _foundationAddress) external onlyGovernance{\n', '        foundationAddress = _foundationAddress;\n', '    }\n', '\n', '    function setWithdrawalFee(uint _withdrawalFee) external onlyGovernance {\n', '        require(_withdrawalFee <=100,"fee > 1%"); //max:1%\n', '        withdrawalFee = _withdrawalFee;\n', '    }\n', '\n', '    function setBurnAddress(address _burnAddress) external onlyGovernance {\n', '        burnAddress = _burnAddress;\n', '    }\n', '\n', '    function setStrategyDev(address _strategyDev) external onlyGovernance {\n', '        strategyDev = _strategyDev;\n', '    }\n', '\n', '    function setSwap2GOF(address[] calldata _path) external onlyGovernance{\n', '        swap2GOFRouting = _path;\n', '    }\n', '    function setSwap2Token(address[] calldata _path) external onlyGovernance{\n', '        swap2TokenRouting = _path;\n', '    }\n', '\n', '    function emergencyWithdrawPool() external onlyGovernance {\n', '        IFarmPool(farmPool).withdraw(IFarmPool(farmPool).balanceOf(address(this)));\n', '    }\n', '\n', '    function donateReserves(uint256 _amount) external onlyGovernance {\n', '        require(_amount <= reserves, "Strategy:Insufficient reserves");\n', '        reserves = reserves.sub(_amount);\n', '    }\n', '}']