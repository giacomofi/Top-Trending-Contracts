['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./Ownable.sol";\n', "import './ERC1155.sol';\n", "import './ERC1155MintBurn.sol';\n", "import './IERC1155Metadata.sol';\n", 'import "./StringsUtil.sol";\n', '\n', 'contract ArtTokenERC1155 is IERC1155Metadata, ERC1155, ERC1155MintBurn, Ownable {\n', '  using StringsUtil for string;\n', '\n', '  uint256 private _currentTokenID = 0;\n', '  mapping (uint256 => uint256) public tokenSupply;\n', '\n', '  string internal baseMetadataURI;\n', '  mapping (uint256 => string) internal _tokenURIs;\n', '\n', '\n', '  /*\n', '   * @notice Will emit default URI log event for corresponding token _id\n', '   * @param _tokenIDs Array of IDs of tokens to log default URI\n', '   */\n', '  //  function _logURIs(uint256[] memory _tokenIDs) internal {\n', '  //    string memory baseURL = baseMetadataURI;\n', '  //    string memory tokenURI;\n', '  //\n', '  //    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '  //      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), ".json"));\n', '  //      emit URI(tokenURI, _tokenIDs[i]);\n', '  //    }\n', '  //  }\n', '\n', '  // Contract name\n', '  string public name;\n', '  // Contract symbol\n', '  string public symbol;\n', '\n', '  mapping (uint256 => address) public creators;\n', '\n', '  mapping(bytes32 => bool) private _uniqTitleSet;\n', '\n', '  constructor() {\n', '    name = "Portion Art Token";\n', '    symbol = "PAT";\n', '  }\n', '\n', '  /**\n', "   * @dev Will update the base URL of token's URI\n", "   * @param _newBaseMetadataURI New base URL of token's URI\n", '   */\n', '  function setBaseMetadataURI(\n', '    string memory _newBaseMetadataURI\n', '  ) public onlyOwner {\n', '    _setBaseMetadataURI(_newBaseMetadataURI);\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new token type and assigns _quantity to an creator (i.e. the message sender)\n', '    * @param _title unique art title\n', "    * @param _quantity art's quantity\n", "    * @param _uri token's type metadata uri\n", '    * @param _data Data to pass if receiver is contract\n', '    * @return The newly created token ID\n', '    */\n', '  function createArt(\n', '    bytes32 _title,\n', '    uint256 _quantity,\n', '    string calldata _uri,\n', '    bytes calldata _data\n', '  ) external returns (uint) {\n', '    bytes32 hash = keccak256(abi.encodePacked(_title));\n', '    require(!_uniqTitleSet[hash], "ArtTokenERC1155#createArt: TITLE_NOT_UNIQUE");\n', '    _uniqTitleSet[hash] = true;\n', '\n', '    _currentTokenID += 1;\n', '    uint256 _id = _currentTokenID;\n', '\n', '    creators[_id] = msg.sender;\n', '\n', '    if (bytes(_uri).length > 0) {\n', '      _tokenURIs[_id] = _uri;\n', '      emit URI(_uri, _id);\n', '    } else {\n', '      require(bytes(baseMetadataURI).length > 0, "ArtTokenERC1155#createArt: NO_DEFAULT_URI");\n', '    }\n', '\n', '    _mint(_msgSender(), _id, _quantity, _data);\n', '    tokenSupply[_id] = _quantity;\n', '    return _id;\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev Returns the total quantity for a token ID\n', '    * @param _id uint256 ID of the token to query\n', '    * @return amount of token in existence\n', '    */\n', '  function totalSupply(\n', '    uint256 _id\n', '  ) public view returns (uint256) {\n', '    return tokenSupply[_id];\n', '  }\n', '\n', '\n', '  function uri(\n', '    uint256 _id\n', '  ) public override view returns (string memory) {\n', '    require(_exists(_id), "ERC721Tradable#uri: NONEXISTENT_TOKEN");\n', '\n', '    string memory _tokenURI = _tokenURIs[_id];\n', '\n', '    if (bytes(baseMetadataURI).length == 0) {\n', '      return _tokenURI;\n', '    }\n', '\n', '    return StringsUtil.strConcat(baseMetadataURI, StringsUtil.uint2str(_id), ".json");\n', '  }\n', '\n', '  /**\n', "   * @notice Will update the base URL of token's URI\n", "   * @param _newBaseMetadataURI New base URL of token's URI\n", '   */\n', '  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n', '    baseMetadataURI = _newBaseMetadataURI;\n', '  }\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceID  The interface identifier, as specified in ERC-165\n', '   * @return `true` if the contract implements `_interfaceID` and\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n', '    if (_interfaceID == type(IERC1155Metadata).interfaceId) {\n', '      return true;\n', '    }\n', '    return super.supportsInterface(_interfaceID);\n', '  }\n', '\n', '  /**\n', '    * @dev Returns whether the specified token exists by checking to see if it has a creator\n', '    * @param _id uint256 ID of the token to query the existence of\n', '    * @return bool whether the token exists\n', '    */\n', '  function _exists(\n', '    uint256 _id\n', '  ) internal view returns (bool) {\n', '    return creators[_id] != address(0);\n', '  }\n', '}']