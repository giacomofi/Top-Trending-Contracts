['// SPDX-License-Identifier: J-J-J-JENGA!!!\n', 'pragma solidity ^0.7.4;\n', '\n', '/* ROOTKIT:\n', 'A floor calculator (to use with ERC31337) for RootKit uniswap pairs\n', 'Ensures 100% of accessible funds are backed at all times\n', '*/\n', '\n', 'import "./IFloorCalculator.sol";\n', 'import "./RootKit.sol";\n', 'import "./SafeMath.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./EnumerableSet.sol";\n', '\n', 'contract RootKitTwoPoolCalculator is IFloorCalculator, TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '    IERC20 immutable rootKit;\n', '    IERC20 immutable keth;\n', '    IERC20 immutable weth;\n', '    address public immutable wethPair;\n', '    address public immutable kethPair;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    EnumerableSet.AddressSet ignoredAddresses;\n', '\n', '    constructor(IERC20 _rootKit, IERC20 _keth, IERC20 _weth, IUniswapV2Factory _uniswapV2Factory, IUniswapV2Router02 _uniswapV2Router)\n', '    {\n', '        rootKit = _rootKit;\n', '        keth = _keth;\n', '        weth = _weth;\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '        uniswapV2Router = _uniswapV2Router;\n', '\n', '        kethPair = _uniswapV2Factory.getPair(address(_keth), address(_rootKit));\n', '        wethPair = _uniswapV2Factory.getPair(address(_weth), address(_rootKit));\n', '    }    \n', '\n', '    function setIgnoredAddress(address ignoredAddress, bool add) public ownerOnly()\n', '    {\n', '        if (add) \n', '        { \n', '            ignoredAddresses.add(ignoredAddress); \n', '        } \n', '        else \n', '        { \n', '            ignoredAddresses.remove(ignoredAddress); \n', '        }\n', '    }\n', '\n', '    function isIgnoredAddress(address ignoredAddress) public view returns (bool)\n', '    {\n', '        return ignoredAddresses.contains(ignoredAddress);\n', '    }\n', '\n', '    function ignoredAddressCount() public view returns (uint256)\n', '    {\n', '        return ignoredAddresses.length();\n', '    }\n', '\n', '    function ignoredAddressAt(uint256 index) public view returns (address)\n', '    {\n', '        return ignoredAddresses.at(index);\n', '    }\n', '\n', '    function ignoredAddressesTotalBalance() public view returns (uint256)\n', '    {\n', '        uint256 total = 0;\n', '        for (uint i = 0; i < ignoredAddresses.length(); i++) {\n', '            total = total.add(rootKit.balanceOf(ignoredAddresses.at(i)));\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '        // returns the amount currently available to be swept\n', '    function calculateSubFloor(IERC20 wrappedToken, IERC20 backingToken) public override view returns (uint256) // backing token = keth\n', '    {\n', '        uint256 totalRootInPairs = rootKit.balanceOf(kethPair).add(rootKit.balanceOf(wethPair));\n', '        uint256 totalBaseAndEliteInPairs = backingToken.balanceOf(kethPair).add(wrappedToken.balanceOf(wethPair));\n', '        uint256 rootKitCirculatingSupply = rootKit.totalSupply().sub(totalRootInPairs).sub(ignoredAddressesTotalBalance());\n', '\n', '        uint256 amountUntilFloor = uniswapV2Router.getAmountOut(rootKitCirculatingSupply, totalRootInPairs, totalBaseAndEliteInPairs) * 100 / 94; //includes burn\n', '        uint256 totalExcessInPools = totalBaseAndEliteInPairs.sub(amountUntilFloor);\n', '        uint256 previouslySwept = backingToken.totalSupply().sub(wrappedToken.balanceOf(address(backingToken)));\n', '\n', '        if (previouslySwept >= totalExcessInPools) { return 0; }\n', '\n', '        return totalExcessInPools.sub(previouslySwept);\n', '    }\n', '\n', '\n', '    function getAbsoluteFloorPrice() public view returns (uint256)\n', '    {\n', '        uint256 totalRootInPairs = rootKit.balanceOf(kethPair).add(rootKit.balanceOf(wethPair));\n', '        uint256 totalBaseAndEliteInPairs = keth.balanceOf(kethPair).add(weth.balanceOf(wethPair));\n', '        uint256 rootKitCirculatingSupply = rootKit.totalSupply().sub(totalRootInPairs).sub(ignoredAddressesTotalBalance());\n', '\n', '        uint256 amountUntilFloor = uniswapV2Router.getAmountOut(rootKitCirculatingSupply, totalRootInPairs, totalBaseAndEliteInPairs) * 100 / 94;\n', '        uint256 totalExcessInPools = totalBaseAndEliteInPairs.sub(amountUntilFloor);\n', '        uint256 newTotalRootInPairs = totalRootInPairs + rootKitCirculatingSupply * 100 / 94;\n', '\n', '        uint256 priceForOneRootIfZeroHolders = uniswapV2Router.getAmountIn(1e18, totalExcessInPools, newTotalRootInPairs);\n', '\n', '        return priceForOneRootIfZeroHolders;\n', '    }\n', '}']