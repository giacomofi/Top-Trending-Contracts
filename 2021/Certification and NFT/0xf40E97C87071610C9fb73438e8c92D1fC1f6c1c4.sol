['// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";\n', '\n', 'import "./IVault.sol";\n', 'import "./tokens/IERC20Metadata.sol";\n', '\n', 'contract VaultView {\n', '\n', '    struct Vault {\n', '        address self;\n', '        uint256 liveTime;\n', '        uint256 settleTime;\n', '        int256 underlyingStart;\n', '        int256 underlyingEnd;\n', '        uint256 primaryConversion;\n', '        uint256 complementConversion;\n', '        uint256 protocolFee;\n', '        uint256 authorFeeLimit;\n', '        uint256 state;\n', '        address oracle;\n', '        uint oracleDecimals;\n', '        address oracleIterator;\n', '        address collateralSplit;\n', '    }\n', '\n', '    struct Token {\n', '        address self;\n', '        string name;\n', '        string symbol;\n', '        uint8 decimals;\n', '        uint userBalance;\n', '    }\n', '\n', '    struct DerivativeSpecification {\n', '        address self;\n', '        string name;\n', '        string symbol;\n', '        uint denomination;\n', '        uint authorFee;\n', '        uint primaryNominalValue;\n', '        uint complementNominalValue;\n', '        bytes32[] oracleSymbols;\n', '    }\n', '\n', '    function getVaultInfo(address _vault)\n', '    external view\n', '    returns (\n', '        Vault memory vaultData,\n', '        DerivativeSpecification memory derivativeSpecificationData,\n', '        Token memory collateralData,\n', '        uint lockedCollateralAmount,\n', '        Token memory primaryData,\n', '        Token memory complementData\n', '    )\n', '    {\n', '        IVault vault = IVault(_vault);\n', '\n', '        int256 underlyingStarts = 0;\n', '        if(uint256(vault.state()) > 0) {\n', '            underlyingStarts = vault.underlyingStarts(0);\n', '        }\n', '\n', '        int256 underlyingEnds = 0;\n', '        if(vault.primaryConversion() > 0 || vault.complementConversion() > 0) {\n', '            underlyingEnds = vault.underlyingEnds(0);\n', '        }\n', '\n', '        vaultData = Vault(\n', '            address(_vault),\n', '            vault.liveTime(),\n', '            vault.settleTime(),\n', '            underlyingStarts,\n', '            underlyingEnds,\n', '            vault.primaryConversion(),\n', '            vault.complementConversion(),\n', '            vault.protocolFee(),\n', '            vault.authorFeeLimit(),\n', '            uint256(vault.state()),\n', '            vault.oracles(0),\n', '            AggregatorV3Interface(vault.oracles(0)).decimals(),\n', '            vault.oracleIterators(0),\n', '            vault.collateralSplit()\n', '        );\n', '\n', '        IDerivativeSpecification specification = vault.derivativeSpecification();\n', '        derivativeSpecificationData = DerivativeSpecification(\n', '            address(specification),\n', '            specification.name(),\n', '            specification.symbol(),\n', '            specification.primaryNominalValue() + specification.complementNominalValue(),\n', '            specification.authorFee(),\n', '            specification.primaryNominalValue(),\n', '            specification.complementNominalValue(),\n', '            specification.oracleSymbols()\n', '        );\n', '\n', '        IERC20Metadata collateral = IERC20Metadata(vault.collateralToken());\n', '        IERC20 collateralToken = IERC20(address(collateral));\n', '        collateralData = Token(\n', '            address(collateral),\n', '            collateral.name(),\n', '            collateral.symbol(),\n', '            collateral.decimals(),\n', '            collateralToken.balanceOf(msg.sender)\n', '        );\n', '        lockedCollateralAmount = collateralToken.balanceOf(address(vault));\n', '\n', '        IERC20Metadata primary = IERC20Metadata(vault.primaryToken());\n', '        primaryData = Token(\n', '            address(primary),\n', '            primary.name(),\n', '            primary.symbol(),\n', '            primary.decimals(),\n', '            IERC20(address(primary)).balanceOf(msg.sender)\n', '        );\n', '\n', '        IERC20Metadata complement = IERC20Metadata(vault.complementToken());\n', '        complementData = Token(\n', '            address(complement),\n', '            complement.name(),\n', '            complement.symbol(),\n', '            complement.decimals(),\n', '            IERC20(address(complement)).balanceOf(msg.sender)\n', '        );\n', '    }\n', '\n', '    function getVaultTokenBalancesByOwner(\n', '        address _owner,\n', '        address[] calldata _vaults\n', '    )\n', '        external\n', '        view\n', '        returns (uint256[] memory primaries, uint256[] memory complements)\n', '    {\n', '        primaries = new uint256[](_vaults.length);\n', '        complements = new uint256[](_vaults.length);\n', '\n', '        IVault vault;\n', '        for (uint256 i = 0; i < _vaults.length; i++) {\n', '            vault = IVault(_vaults[i]);\n', '            primaries[i] = IERC20(vault.primaryToken()).balanceOf(_owner);\n', '            complements[i] = IERC20(vault.complementToken()).balanceOf(_owner);\n', '        }\n', '    }\n', '\n', '    function getERC20BalancesByOwner(address _owner, address[] calldata _tokens)\n', '        external\n', '        view\n', '        returns (uint256[] memory balances)\n', '    {\n', '        balances = new uint256[](_tokens.length);\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            balances[i] = IERC20(_tokens[i]).balanceOf(_owner);\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0;\n', '\n', 'interface AggregatorV3Interface {\n', '\n', '  function decimals() external view returns (uint8);\n', '  function description() external view returns (string memory);\n', '  function version() external view returns (uint256);\n', '\n', '  // getRoundData and latestRoundData should both raise "No data present"\n', '  // if they do not have data to report, instead of returning unset values\n', '  // which could be misinterpreted as actual reported values.\n', '  function getRoundData(uint80 _roundId)\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '  function latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'import "./IDerivativeSpecification.sol";\n', '\n', '/// @title Derivative implementation Vault\n', '/// @notice A smart contract that references derivative specification and enables users to mint and redeem the derivative\n', 'interface IVault {\n', '    enum State { Created, Live, Settled }\n', '\n', '    /// @notice start of live period\n', '    function liveTime() external view returns (uint256);\n', '\n', '    /// @notice end of live period\n', '    function settleTime() external view returns (uint256);\n', '\n', '    /// @notice redeem function can only be called after the end of the Live period + delay\n', '    function settlementDelay() external view returns (uint256);\n', '\n', '    /// @notice underlying value at the start of live period\n', '    function underlyingStarts(uint256 index) external view returns (int256);\n', '\n', '    /// @notice underlying value at the end of live period\n', '    function underlyingEnds(uint256 index) external view returns (int256);\n', '\n', '    /// @notice primary token conversion rate multiplied by 10 ^ 12\n', '    function primaryConversion() external view returns (uint256);\n', '\n', '    /// @notice complement token conversion rate multiplied by 10 ^ 12\n', '    function complementConversion() external view returns (uint256);\n', '\n', '    /// @notice protocol fee multiplied by 10 ^ 12\n', '    function protocolFee() external view returns (uint256);\n', '\n', '    /// @notice limit on author fee multiplied by 10 ^ 12\n', '    function authorFeeLimit() external view returns (uint256);\n', '\n', "    // @notice protocol's fee receiving wallet\n", '    function feeWallet() external view returns (address);\n', '\n', '    // @notice current state of the vault\n', '    function state() external view returns (State);\n', '\n', '    // @notice derivative specification address\n', '    function derivativeSpecification()\n', '        external\n', '        view\n', '        returns (IDerivativeSpecification);\n', '\n', '    // @notice collateral token address\n', '    function collateralToken() external view returns (address);\n', '\n', '    // @notice oracle address\n', '    function oracles(uint256 index) external view returns (address);\n', '\n', '    function oracleIterators(uint256 index) external view returns (address);\n', '\n', '    // @notice collateral split address\n', '    function collateralSplit() external view returns (address);\n', '\n', "    // @notice derivative's token builder strategy address\n", '    function tokenBuilder() external view returns (address);\n', '\n', '    function feeLogger() external view returns (address);\n', '\n', '    // @notice primary token address\n', '    function primaryToken() external view returns (address);\n', '\n', '    // @notice complement token address\n', '    function complementToken() external view returns (address);\n', '\n', '    /// @notice Switch to Settled state if appropriate time threshold is passed and\n', '    /// set underlyingStarts value and set underlyingEnds value,\n', '    /// calculate primaryConversion and complementConversion params\n', '    /// @dev Reverts if underlyingStart or underlyingEnd are not available\n', '    /// Vault cannot settle when it paused\n', '    function settle(uint256[] calldata _underlyingEndRoundHints) external;\n', '\n', '    function mintTo(address _recipient, uint256 _collateralAmount) external;\n', '\n', '    /// @notice Mints primary and complement derivative tokens\n', '    /// @dev Checks and switches to the right state and does nothing if vault is not in Live state\n', '    function mint(uint256 _collateralAmount) external;\n', '\n', '    /// @notice Refund equal amounts of derivative tokens for collateral at any time\n', '    function refund(uint256 _tokenAmount) external;\n', '\n', '    function refundTo(address _recipient, uint256 _tokenAmount) external;\n', '\n', '    function redeemTo(\n', '        address _recipient,\n', '        uint256 _primaryTokenAmount,\n', '        uint256 _complementTokenAmount,\n', '        uint256[] calldata _underlyingEndRoundHints\n', '    ) external;\n', '\n', '    /// @notice Redeems unequal amounts previously calculated conversions if the vault is in Settled state\n', '    function redeem(\n', '        uint256 _primaryTokenAmount,\n', '        uint256 _complementTokenAmount,\n', '        uint256[] calldata _underlyingEndRoundHints\n', '    ) external;\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface IERC20Metadata {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '/// @title Derivative Specification interface\n', '/// @notice Immutable collection of derivative attributes\n', "/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\n", 'interface IDerivativeSpecification {\n', '    /// @notice Proof of a derivative specification\n', '    /// @dev Verifies that contract is a derivative specification\n', '    /// @return true if contract is a derivative specification\n', '    function isDerivativeSpecification() external pure returns (bool);\n', '\n', '    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\n', '    /// between the start and the end of the Live period\n', '    /// @dev Should be resolved through OracleRegistry contract\n', '    /// @return oracle symbols\n', '    function oracleSymbols() external view returns (bytes32[] memory);\n', '\n', '    /// @notice Algorithm that, for the type of oracle used by the derivative,\n', '    /// finds the value closest to a given timestamp\n', '    /// @dev Should be resolved through OracleIteratorRegistry contract\n', '    /// @return oracle iterator symbols\n', '    function oracleIteratorSymbols() external view returns (bytes32[] memory);\n', '\n', '    /// @notice Type of collateral that users submit to mint the derivative\n', '    /// @dev Should be resolved through CollateralTokenRegistry contract\n', '    /// @return collateral token symbol\n', '    function collateralTokenSymbol() external view returns (bytes32);\n', '\n', '    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\n', '    /// and the initial collateral split to the final collateral split\n', '    /// @dev Should be resolved through CollateralSplitRegistry contract\n', '    /// @return collateral split symbol\n', '    function collateralSplitSymbol() external view returns (bytes32);\n', '\n', "    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\n", '    /// @dev Set in seconds\n', '    /// @return live period value\n', '    function livePeriod() external view returns (uint256);\n', '\n', '    /// @notice Parameter that determines starting nominal value of primary asset\n', '    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\n', '    /// @return primary nominal value\n', '    function primaryNominalValue() external view returns (uint256);\n', '\n', '    /// @notice Parameter that determines starting nominal value of complement asset\n', '    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\n', '    /// @return complement nominal value\n', '    function complementNominalValue() external view returns (uint256);\n', '\n', '    /// @notice Minting fee rate due to the author of the derivative specification.\n', '    /// @dev Percentage fee multiplied by 10 ^ 12\n', '    /// @return author fee\n', '    function authorFee() external view returns (uint256);\n', '\n', '    /// @notice Symbol of the derivative\n', '    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\n', '    /// @return derivative specification symbol\n', '    function symbol() external view returns (string memory);\n', '\n', '    /// @notice Return optional long name of the derivative\n', "    /// @dev Isn't used directly in the protocol\n", '    /// @return long name\n', '    function name() external view returns (string memory);\n', '\n', '    /// @notice Optional URI to the derivative specs\n', "    /// @dev Isn't used directly in the protocol\n", '    /// @return URI to the derivative specs\n', '    function baseURI() external view returns (string memory);\n', '\n', '    /// @notice Derivative spec author\n', "    /// @dev Used to set and receive author's fee\n", '    /// @return address of the author\n', '    function author() external view returns (address);\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 1000000\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']