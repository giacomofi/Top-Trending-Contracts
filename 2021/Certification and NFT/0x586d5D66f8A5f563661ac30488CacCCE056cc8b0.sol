['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-05\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-01-01\n', '*/\n', '\n', 'pragma solidity ^0.4.26;\n', '\n', '// This is the ETH/ERC20 multisig contract for Ownbit.\n', '//\n', '// For 2-of-3 multisig, to authorize a spend, two signtures must be provided by 2 of the 3 owners.\n', '// To generate the message to be signed, provide the destination address and\n', '// spend amount (in wei) to the generateMessageToSign method.\n', '// The signatures must be provided as the (v, r, s) hex-encoded coordinates.\n', '// The S coordinate must be 0x00 or 0x01 corresponding to 0x1b and 0x1c, respectively.\n', '//\n', '// WARNING: The generated message is only valid until the next spend is executed.\n', '//          after that, a new message will need to be calculated.\n', '//\n', '//\n', '// INFO: This contract is ERC20 compatible.\n', '// This contract can both receive ETH and ERC20 tokens.\n', '// Notice that NFT (ERC721/ERC1155) is not supported. But can be transferred out throught spendAny.\n', '// Last update time: 2020-12-21.\n', '// copyright @ ownbit.io\n', '//\n', '// Accident Protection MultiSig, rules:\n', '//\n', '// Participants must keep themselves active by submitting transactions. \n', '// Not submitting any transaction within 3,000,000 ETH blocks (roughly 416 days) will be treated as wallet lost (i.e. accident happened), \n', '// other participants can still spend the assets as along as: valid signing count >= Min(mininual required count, active owners).\n', '//\n', '\n', 'interface Erc20 {\n', '  function approve(address, uint256) public;\n', '\n', '  function transfer(address, uint256) public;\n', '    \n', '  //function balanceOf(address) view public returns (uint256);\n', '}\n', '\n', 'contract OwnbitMultiSig {\n', '    \n', '  uint constant public MAX_OWNER_COUNT = 9;\n', '  //uint constant public MAX_INACTIVE_BLOCKNUMBER = 300; //300 ETH blocks, roughly 1 hour, for testing.\n', '  uint constant public MAX_INACTIVE_BLOCKNUMBER = 3000000; //3,000,000 ETH blocks, roughly 416 days.\n', '\n', '  // The N addresses which control the funds in this contract. The\n', '  // owners of M of these addresses will need to both sign a message\n', '  // allowing the funds in this contract to be spent.\n', '  mapping(address => uint256) private ownerBlockMap; //uint256 is the active blockNumber of this owner\n', '  address[] private owners;\n', '  uint private required;\n', '\n', '  // The contract nonce is not accessible to the contract so we\n', '  // implement a nonce-like variable for replay protection.\n', '  uint256 private spendNonce = 0;\n', '  \n', '  // An event sent when funds are received.\n', '  event Funded(address from, uint value);\n', '  \n', '  // An event sent when a spend is triggered to the given address.\n', '  event Spent(address to, uint transfer);\n', '  \n', '  // An event sent when a spendERC20 is triggered to the given address.\n', '  event SpentERC20(address erc20contract, address to, uint transfer);\n', '  \n', '  // An event sent when an spendAny is executed.\n', '  event SpentAny(address to, uint transfer);\n', '\n', '  modifier validRequirement(uint ownerCount, uint _required) {\n', '    require (ownerCount <= MAX_OWNER_COUNT\n', '            && _required <= ownerCount\n', '            && _required >= 1);\n', '    _;\n', '  }\n', '  \n', '  /// @dev Contract constructor sets initial owners and required number of confirmations.\n', '  /// @param _owners List of initial owners.\n', '  /// @param _required Number of required confirmations.\n', '  constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) {\n', '    for (uint i = 0; i < _owners.length; i++) {\n', '        //onwer should be distinct, and non-zero\n', '        if (ownerBlockMap[_owners[i]] > 0 || _owners[i] == address(0x0)) {\n', '            revert();\n', '        }\n', '        ownerBlockMap[_owners[i]] = block.number;\n', '    }\n', '    owners = _owners;\n', '    required = _required;\n', '  }\n', '\n', '\n', '  // The fallback function for this contract.\n', '  function() public payable {\n', '    if (msg.value > 0) {\n', '        emit Funded(msg.sender, msg.value);\n', '    }\n', '  }\n', '  \n', '  // @dev Returns list of owners.\n', '  // @return List of owner addresses.\n', '  function getOwners() public view returns (address[]) {\n', '    return owners;\n', '  }\n', '    \n', '  function getSpendNonce() public view returns (uint256) {\n', '    return spendNonce;\n', '  }\n', '    \n', '  function getRequired() public view returns (uint) {\n', '    return required;\n', '  }\n', '  \n', '  //return the active block number of this owner\n', '  function getOwnerBlock(address addr) public view returns (uint) {\n', '    return ownerBlockMap[addr];\n', '  }\n', '\n', '  // Generates the message to sign given the output destination address and amount.\n', "  // includes this contract's address and a nonce for replay protection.\n", '  // One option to independently verify: https://leventozturk.com/engineering/sha3/ and select keccak\n', '  function generateMessageToSign(address erc20Contract, address destination, uint256 value) private view returns (bytes32) {\n', '    //the sequence should match generateMultiSigV2 in JS\n', '    bytes32 message = keccak256(abi.encodePacked(address(this), erc20Contract, destination, value, spendNonce));\n', '    return message;\n', '  }\n', '  \n', '  function _messageToRecover(address erc20Contract, address destination, uint256 value) private view returns (bytes32) {\n', '    bytes32 hashedUnsignedMessage = generateMessageToSign(erc20Contract, destination, value);\n', '    bytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '    return keccak256(abi.encodePacked(prefix, hashedUnsignedMessage));\n', '  }\n', '  \n', '  // @destination: the ether receiver address.\n', '  // @value: the ether value, in wei.\n', '  // @vs, rs, ss: the signatures\n', '  function spend(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) external {\n', '    require(destination != address(this), "Not allow sending to yourself");\n', '    require(address(this).balance >= value && value > 0, "balance or spend value invalid");\n', '    require(_validSignature(address(0x0), destination, value, vs, rs, ss), "invalid signatures");\n', '    spendNonce = spendNonce + 1;\n', '    //transfer will throw if fails\n', '    destination.transfer(value);\n', '    emit Spent(destination, value);\n', '  }\n', '  \n', '  // @erc20contract: the erc20 contract address.\n', '  // @destination: the token receiver address.\n', '  // @value: the token value, in token minimum unit.\n', '  // @vs, rs, ss: the signatures\n', '  function spendERC20(address destination, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) external {\n', '    require(destination != address(this), "Not allow sending to yourself");\n', '    //transfer erc20 token\n', '    //uint256 tokenValue = Erc20(erc20contract).balanceOf(address(this));\n', '    require(value > 0, "Erc20 spend value invalid");\n', '    require(_validSignature(erc20contract, destination, value, vs, rs, ss), "invalid signatures");\n', '    spendNonce = spendNonce + 1;\n', '    // transfer tokens from this contract to the destination address\n', '    Erc20(erc20contract).transfer(destination, value);\n', '    emit SpentERC20(erc20contract, destination, value);\n', '  }\n', '  \n', '  //0x9 is used for spendAny\n', '  //be careful with any action, data is not included into signature computation. So any data can be included in spendAny.\n', '  //This is usually for some emergent recovery, for example, recovery of NTFs, etc.\n', '  //Owners should not generate 0x9 based signatures in normal cases.\n', '  function spendAny(address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss, bytes data) external {\n', '    require(destination != address(this), "Not allow sending to yourself");\n', '    require(_validSignature(address(0x9), destination, value, vs, rs, ss), "invalid signatures");\n', '    spendNonce = spendNonce + 1;\n', '    //transfer tokens from this contract to the destination address\n', '    if (destination.call.value(value)(data)) {\n', '        emit SpentAny(destination, value);\n', '    }\n', '  }\n', '  \n', '  //send a tx from the owner address to active the owner\n', '  //Allow the owner to transfer some ETH, although this is not necessary.\n', '  function active() external payable {\n', '    require(ownerBlockMap[msg.sender] > 0, "Not an owner");\n', '    ownerBlockMap[msg.sender] = block.number;\n', '  }\n', '  \n', '  function getRequiredWithoutInactive() public view returns (uint) {\n', '    uint activeOwner = 0;  \n', '    for (uint i = 0; i < owners.length; i++) {\n', '        //if the owner is active\n', '        if (ownerBlockMap[owners[i]] + MAX_INACTIVE_BLOCKNUMBER >= block.number) {\n', '            activeOwner++;\n', '        }\n', '    }\n', '    //active owners still equal or greater then required\n', '    if (activeOwner >= required) {\n', '        return required;\n', '    }\n', '    //active less than required, all active must sign\n', '    if (activeOwner >= 1) {\n', '        return activeOwner;\n', '    }\n', '    //at least needs one signature.\n', '    return 1;\n', '  }\n', '\n', '  // Confirm that the signature triplets (v1, r1, s1) (v2, r2, s2) ...\n', "  // authorize a spend of this contract's funds to the given destination address.\n", '  function _validSignature(address erc20Contract, address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) private returns (bool) {\n', '    require(vs.length == rs.length);\n', '    require(rs.length == ss.length);\n', '    require(vs.length <= owners.length);\n', '    require(vs.length >= getRequiredWithoutInactive());\n', '    bytes32 message = _messageToRecover(erc20Contract, destination, value);\n', '    address[] memory addrs = new address[](vs.length);\n', '    for (uint i = 0; i < vs.length; i++) {\n', '        //recover the address associated with the public key from elliptic curve signature or return zero on error \n', '        addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]);\n', '    }\n', '    require(_distinctOwners(addrs));\n', "    _updateActiveBlockNumber(addrs); //update addrs' active block number\n", '    \n', '    //check again, this is important to prevent inactive owners from stealing the money.\n', '    require(vs.length >= getRequiredWithoutInactive(), "Active owners updated after the call, please call active() before calling spend.");\n', '    \n', '    return true;\n', '  }\n', '  \n', '  // Confirm the addresses as distinct owners of this contract.\n', '  function _distinctOwners(address[] addrs) private view returns (bool) {\n', '    if (addrs.length > owners.length) {\n', '        return false;\n', '    }\n', '    for (uint i = 0; i < addrs.length; i++) {\n', '        //> 0 means one of the owner\n', '        if (ownerBlockMap[addrs[i]] == 0) {\n', '            return false;\n', '        }\n', '        //address should be distinct\n', '        for (uint j = 0; j < i; j++) {\n', '            if (addrs[i] == addrs[j]) {\n', '                return false;\n', '            }\n', '        }\n', '    }\n', '    return true;\n', '  }\n', '  \n', '  //update the active block number for those owners\n', '  function _updateActiveBlockNumber(address[] addrs) private {\n', '    for (uint i = 0; i < addrs.length; i++) {\n', '        //only update block number for owners\n', '        if (ownerBlockMap[addrs[i]] > 0) {\n', '            ownerBlockMap[addrs[i]] = block.number;\n', '        }\n', '    }\n', '  }\n', '  \n', '}']