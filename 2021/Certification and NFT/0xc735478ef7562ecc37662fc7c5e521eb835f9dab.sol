['pragma solidity ^0.6.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', '\n', 'contract Peggy {\n', '\tusing SafeMath for uint256;\n', '\tusing SafeERC20 for IERC20;\n', '\n', '\t// These are updated often\n', '\tbytes32 public state_lastValsetCheckpoint;\n', '\tmapping(address => uint256) public state_lastBatchNonces;\n', '\tuint256 public state_lastValsetNonce = 0;\n', '\tuint256 public state_lastEventNonce = 0;\n', '\n', '\t// These are set once at initialization\n', '\tbytes32 public state_peggyId;\n', '\tuint256 public state_powerThreshold;\n', '\n', '\tbool public halted = false;\n', '\tbool public depositsStopped = false;\n', '\taddress public guardian;\n', '\n', '\tevent TransactionBatchExecutedEvent(\n', '\t\tuint256 indexed _batchNonce,\n', '\t\taddress indexed _token,\n', '\t\taddress indexed _sender,\n', '\t\tuint256 _eventNonce\n', '\t);\n', '\tevent SendToHubEvent(\n', '\t\taddress indexed _tokenContract,\n', '\t\taddress indexed _sender,\n', '\t\tbytes32 indexed _destination,\n', '\t\tuint256 _amount,\n', '\t\tuint256 _eventNonce\n', '\t);\n', '\tevent SendToMinterEvent(\n', '\t\taddress indexed _tokenContract,\n', '\t\taddress indexed _sender,\n', '\t\tbytes32 indexed _destination,\n', '\t\tuint256 _amount,\n', '\t\tuint256 _eventNonce\n', '\t);\n', '\tevent ValsetUpdatedEvent(\n', '\t\tuint256 indexed _newValsetNonce,\n', '\t\taddress[] _validators,\n', '\t\tuint256[] _powers\n', '\t);\n', '\n', '\tfunction lastBatchNonce(address _erc20Address) public view returns (uint256) {\n', '\t\treturn state_lastBatchNonces[_erc20Address];\n', '\t}\n', '\n', '\t// Utility function to verify geth style signatures\n', '\tfunction verifySig(\n', '\t\taddress _signer,\n', '\t\tbytes32 _theHash,\n', '\t\tuint8 _v,\n', '\t\tbytes32 _r,\n', '\t\tbytes32 _s\n', '\t) private pure returns (bool) {\n', '\t\tbytes32 messageDigest = keccak256(\n', '\t\t\tabi.encodePacked("\\x19Ethereum Signed Message:\\n32", _theHash)\n', '\t\t);\n', '\t\treturn _signer == ecrecover(messageDigest, _v, _r, _s);\n', '\t}\n', '\n', '\t// Make a new checkpoint from the supplied validator set\n', '\t// A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\n', '\t// instead of storing the information directly. This saves on storage and gas.\n', '\t// The format of the checkpoint is:\n', '\t// h(peggyId, "checkpoint", valsetNonce, validators[], powers[])\n', '\t// Where h is the keccak256 hash function.\n', '\t// The validator powers must be decreasing or equal. This is important for checking the signatures on the\n', '\t// next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\n', '\tfunction makeCheckpoint(\n', '\t\taddress[] memory _validators,\n', '\t\tuint256[] memory _powers,\n', '\t\tuint256 _valsetNonce,\n', '\t\tbytes32 _peggyId\n', '\t) private pure returns (bytes32) {\n', '\t\t// bytes32 encoding of the string "checkpoint"\n', '\t\tbytes32 methodName = 0x636865636b706f696e7400000000000000000000000000000000000000000000;\n', '\n', '\t\tbytes32 checkpoint = keccak256(\n', '\t\t\tabi.encode(_peggyId, methodName, _valsetNonce, _validators, _powers)\n', '\t\t);\n', '\n', '\t\treturn checkpoint;\n', '\t}\n', '\n', '\tfunction checkValidatorSignatures(\n', '\t\t// The current validator set and their powers\n', '\t\taddress[] memory _currentValidators,\n', '\t\tuint256[] memory _currentPowers,\n', "\t\t// The current validator's signatures\n", '\t\tuint8[] memory _v,\n', '\t\tbytes32[] memory _r,\n', '\t\tbytes32[] memory _s,\n', '\t\t// This is what we are checking they have signed\n', '\t\tbytes32 _theHash,\n', '\t\tuint256 _powerThreshold\n', '\t) private pure {\n', '\t\tuint256 cumulativePower = 0;\n', '\n', '\t\tfor (uint256 i = 0; i < _currentValidators.length; i++) {\n', '\t\t\t// If v is set to 0, this signifies that it was not possible to get a signature from this validator and we skip evaluation\n', '\t\t\t// (In a valid signature, it is either 27 or 28)\n', '\t\t\tif (_v[i] != 0) {\n', '\t\t\t\t// Check that the current validator has signed off on the hash\n', '\t\t\t\trequire(\n', '\t\t\t\t\tverifySig(_currentValidators[i], _theHash, _v[i], _r[i], _s[i]),\n', '\t\t\t\t\t"Validator signature does not match."\n', '\t\t\t\t);\n', '\n', '\t\t\t\t// Sum up cumulative power\n', '\t\t\t\tcumulativePower = cumulativePower + _currentPowers[i];\n', '\n', '\t\t\t\t// Break early to avoid wasting gas\n', '\t\t\t\tif (cumulativePower > _powerThreshold) {\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// Check that there was enough power\n', '\t\trequire(\n', '\t\t\tcumulativePower > _powerThreshold,\n', '\t\t\t"Submitted validator set signatures do not have enough power."\n', '\t\t);\n', '\t\t// Success\n', '\t}\n', '\n', '\t// This updates the valset by checking that the validators in the current valset have signed off on the\n', '\t// new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\n', '\t// generated from the new valset.\n', '\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n', '\t// the new valset.\n', '\tfunction updateValset(\n', '\t\t// The new version of the validator set\n', '\t\taddress[] memory _newValidators,\n', '\t\tuint256[] memory _newPowers,\n', '\t\tuint256 _newValsetNonce,\n', '\t\t// The current validators that approve the change\n', '\t\taddress[] memory _currentValidators,\n', '\t\tuint256[] memory _currentPowers,\n', '\t\tuint256 _currentValsetNonce,\n', "\t\t// These are arrays of the parts of the current validator's signatures\n", '\t\tuint8[] memory _v,\n', '\t\tbytes32[] memory _r,\n', '\t\tbytes32[] memory _s\n', '\t) public {\n', '\t\t// CHECKS\n', '\n', '\t\trequire(!halted, "contract halted");\n', '\n', '\t\t// Check that the valset nonce is greater than the old one\n', '\t\trequire(\n', '\t\t\t_newValsetNonce > _currentValsetNonce,\n', '\t\t\t"New valset nonce must be greater than the current nonce"\n', '\t\t);\n', '\n', '\t\t// Check that new validators and powers set is well-formed\n', '\t\trequire(_newValidators.length == _newPowers.length, "Malformed new validator set");\n', '\n', '\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n', '\t\trequire(\n', '\t\t\t_currentValidators.length == _currentPowers.length &&\n', '\t\t\t\t_currentValidators.length == _v.length &&\n', '\t\t\t\t_currentValidators.length == _r.length &&\n', '\t\t\t\t_currentValidators.length == _s.length,\n', '\t\t\t"Malformed current validator set"\n', '\t\t);\n', '\n', '\t\t// Check that the supplied current validator set matches the saved checkpoint\n', '\t\trequire(\n', '\t\t\tmakeCheckpoint(\n', '\t\t\t\t_currentValidators,\n', '\t\t\t\t_currentPowers,\n', '\t\t\t\t_currentValsetNonce,\n', '\t\t\t\tstate_peggyId\n', '\t\t\t) == state_lastValsetCheckpoint,\n', '\t\t\t"Supplied current validators and powers do not match checkpoint."\n', '\t\t);\n', '\n', '\t\t// Check that enough current validators have signed off on the new validator set\n', '\t\tbytes32 newCheckpoint = makeCheckpoint(\n', '\t\t\t_newValidators,\n', '\t\t\t_newPowers,\n', '\t\t\t_newValsetNonce,\n', '\t\t\tstate_peggyId\n', '\t\t);\n', '\n', '\t\tcheckValidatorSignatures(\n', '\t\t\t_currentValidators,\n', '\t\t\t_currentPowers,\n', '\t\t\t_v,\n', '\t\t\t_r,\n', '\t\t\t_s,\n', '\t\t\tnewCheckpoint,\n', '\t\t\tstate_powerThreshold\n', '\t\t);\n', '\n', '\t\t// ACTIONS\n', '\n', '\t\t// Stored to be used next time to validate that the valset\n', '\t\t// supplied by the caller is correct.\n', '\t\tstate_lastValsetCheckpoint = newCheckpoint;\n', '\n', '\t\t// Store new nonce\n', '\t\tstate_lastValsetNonce = _newValsetNonce;\n', '\n', '\t\t// LOGS\n', '\n', '\t\temit ValsetUpdatedEvent(_newValsetNonce, _newValidators, _newPowers);\n', '\t}\n', '\n', '\t// submitBatch processes a batch of Hub -> Ethereum transactions by sending the tokens in the transactions\n', '\t// to the destination addresses. It is approved by the current Hub validator set.\n', '\t// Anyone can call this function, but they must supply valid signatures of state_powerThreshold of the current valset over\n', '\t// the batch.\n', '\tfunction submitBatch(\n', '\t\t// The validators that approve the batch\n', '\t\taddress[] memory _currentValidators,\n', '\t\tuint256[] memory _currentPowers,\n', '\t\tuint256 _currentValsetNonce,\n', '\t\t// These are arrays of the parts of the validators signatures\n', '\t\tuint8[] memory _v,\n', '\t\tbytes32[] memory _r,\n', '\t\tbytes32[] memory _s,\n', '\t\t// The batch of transactions\n', '\t\tuint256[] memory _amounts,\n', '\t\taddress[] memory _destinations,\n', '\t\tuint256 _batchNonce,\n', '\t\taddress _tokenContract\n', '\t) public {\n', '\t\t// CHECKS scoped to reduce stack depth\n', '\t\t{\n', '\t\t\trequire(!halted, "contract halted");\n', '\n', '\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n', '\t\t\trequire(\n', '\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n', '\t\t\t\t"New batch nonce must be greater than the current nonce"\n', '\t\t\t);\n', '\n', '\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n', '\t\t\trequire(\n', '\t\t\t\t_currentValidators.length == _currentPowers.length &&\n', '\t\t\t\t\t_currentValidators.length == _v.length &&\n', '\t\t\t\t\t_currentValidators.length == _r.length &&\n', '\t\t\t\t\t_currentValidators.length == _s.length,\n', '\t\t\t\t"Malformed current validator set"\n', '\t\t\t);\n', '\n', '\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n', '\t\t\trequire(\n', '\t\t\t\tmakeCheckpoint(\n', '\t\t\t\t\t_currentValidators,\n', '\t\t\t\t\t_currentPowers,\n', '\t\t\t\t\t_currentValsetNonce,\n', '\t\t\t\t\tstate_peggyId\n', '\t\t\t\t) == state_lastValsetCheckpoint,\n', '\t\t\t\t"Supplied current validators and powers do not match checkpoint."\n', '\t\t\t);\n', '\n', '\t\t\t// Check that the transaction batch is well-formed\n', '\t\t\trequire(\n', '\t\t\t\t_amounts.length == _destinations.length,\n', '\t\t\t\t"Malformed batch of transactions"\n', '\t\t\t);\n', '\n', '\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n', '\t\t\tcheckValidatorSignatures(\n', '\t\t\t\t_currentValidators,\n', '\t\t\t\t_currentPowers,\n', '\t\t\t\t_v,\n', '\t\t\t\t_r,\n', '\t\t\t\t_s,\n', '\t\t\t\t// Get hash of the transaction batch and checkpoint\n', '\t\t\t\tkeccak256(\n', '\t\t\t\t\tabi.encode(\n', '\t\t\t\t\t\tstate_peggyId,\n', '\t\t\t\t\t\t// bytes32 encoding of "transactionBatch"\n', '\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n', '\t\t\t\t\t\t_amounts,\n', '\t\t\t\t\t\t_destinations,\n', '\t\t\t\t\t\t_batchNonce,\n', '\t\t\t\t\t\t_tokenContract\n', '\t\t\t\t\t)\n', '\t\t\t\t),\n', '\t\t\t\tstate_powerThreshold\n', '\t\t\t);\n', '\n', '\t\t\t// ACTIONS\n', '\n', '\t\t\t// Store batch nonce\n', '\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n', '\n', '\t\t\t{\n', '\t\t\t\t// Send transaction amounts to destinations\n', '\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n', '\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t// LOGS scoped to reduce stack depth\n', '\t\t{\n', '\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n', '\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, msg.sender, state_lastEventNonce);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendToHub(\n', '\t\taddress _tokenContract,\n', '\t\tbytes32 _destination,\n', '\t\tuint256 _amount\n', '\t) public {\n', '\t\trequire(!halted, "contract halted");\n', '\t\trequire(!depositsStopped, "deposits stopped");\n', '\n', '\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n', '\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n', '\t\temit SendToHubEvent(\n', '\t\t\t_tokenContract,\n', '\t\t\tmsg.sender,\n', '\t\t\t_destination,\n', '\t\t\t_amount,\n', '\t\t\tstate_lastEventNonce\n', '\t\t);\n', '\t}\n', '\n', '\tfunction sendToMinter(\n', '\t\taddress _tokenContract,\n', '\t\tbytes32 _destination,\n', '\t\tuint256 _amount\n', '\t) public {\n', '\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n', '\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n', '\t\temit SendToMinterEvent(\n', '\t\t\t_tokenContract,\n', '\t\t\tmsg.sender,\n', '\t\t\t_destination,\n', '\t\t\t_amount,\n', '\t\t\tstate_lastEventNonce\n', '\t\t);\n', '\t}\n', '\n', '\tfunction toggleHalt() public {\n', '\t\trequire(msg.sender == guardian, "permission denied");\n', '\n', '\t\thalted = !halted;\n', '\t}\n', '\n', '\tfunction toggleDeposits() public {\n', '\t\trequire(msg.sender == guardian, "permission denied");\n', '\n', '\t\tdepositsStopped = !depositsStopped;\n', '\t}\n', '\n', '\tfunction changeGuardian(address _guardian) public {\n', '\t\trequire(msg.sender == guardian, "permission denied");\n', '\n', '\t\tguardian = _guardian;\n', '\t}\n', '\n', '\tfunction panicHalt(address[] memory _tokenContracts, address _safeAddress) public {\n', '\t\trequire(msg.sender == guardian, "permission denied");\n', '\n', '\t\thalted = true;\n', '\t\tdepositsStopped = true;\n', '\n', '\t\tfor (uint256 i = 0; i < _tokenContracts.length; i++) {\n', '\t\t\tIERC20 token = IERC20(_tokenContracts[i]);\n', '\t\t\ttoken.safeTransfer(_safeAddress, token.balanceOf(address(this)));\n', '\t\t}\n', '\t}\n', '\n', '\tconstructor(\n', '\t\t// A unique identifier for this peggy instance to use in signatures\n', '\t\tbytes32 _peggyId,\n', '\t\t// How much voting power is needed to approve operations\n', '\t\tuint256 _powerThreshold,\n', '\t\t// The validator set\n', '\t\taddress[] memory _validators,\n', '\t\tuint256[] memory _powers,\n', '\t\taddress _guardian\n', '\t) public {\n', '\t\t// CHECKS\n', '\n', '\t\t// Check that validators, powers, and signatures (v,r,s) set is well-formed\n', '\t\trequire(_validators.length == _powers.length, "Malformed current validator set");\n', '\n', '\t\t// Check cumulative power to ensure the contract has sufficient power to actually\n', '\t\t// pass a vote\n', '\t\tuint256 cumulativePower = 0;\n', '\t\tfor (uint256 i = 0; i < _powers.length; i++) {\n', '\t\t\tcumulativePower = cumulativePower + _powers[i];\n', '\t\t\tif (cumulativePower > _powerThreshold) {\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\trequire(\n', '\t\t\tcumulativePower > _powerThreshold,\n', '\t\t\t"Submitted validator set signatures do not have enough power."\n', '\t\t);\n', '\n', '\t\tbytes32 newCheckpoint = makeCheckpoint(_validators, _powers, 0, _peggyId);\n', '\n', '\t\t// ACTIONS\n', '\n', '\t\tstate_peggyId = _peggyId;\n', '\t\tstate_powerThreshold = _powerThreshold;\n', '\t\tstate_lastValsetCheckpoint = newCheckpoint;\n', '\n', '\t\tguardian = _guardian;\n', '\n', '\t\t// LOGS\n', '\n', '\t\temit ValsetUpdatedEvent(0, _validators, _powers);\n', '\t}\n', '}']