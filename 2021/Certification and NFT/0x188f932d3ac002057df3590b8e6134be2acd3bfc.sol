['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', 'pragma solidity 0.5.12;\n', '\n', 'contract ICErc20 {\n', '    address public underlying;\n', '    function mint(uint256 mintAmount) external returns (uint);\n', '    function redeemUnderlying(uint256 redeemAmount) external returns (uint);\n', '    function balanceOfUnderlying(address owner) external returns (uint);\n', '    function getCash() external view returns (uint);\n', '    function supplyRatePerBlock() external view returns (uint);\n', '}\n', '\n', '\n', 'contract GemLike {\n', '    function allowance(address, address) public returns (uint);\n', '    function approve(address, uint) public;\n', '    function transfer(address, uint) public returns (bool);\n', '    function transferFrom(address, address, uint) public returns (bool);\n', '}\n', '\n', 'contract ValueLike {\n', '    function peek() public returns (uint, bool);\n', '}\n', '\n', 'contract SaiTubLike {\n', '    function skr() public view returns (GemLike);\n', '    function gem() public view returns (GemLike);\n', '    function gov() public view returns (GemLike);\n', '    function sai() public view returns (GemLike);\n', '    function pep() public view returns (ValueLike);\n', '    function vox() public view returns (VoxLike);\n', '    function bid(uint) public view returns (uint);\n', '    function ink(bytes32) public view returns (uint);\n', '    function tag() public view returns (uint);\n', '    function tab(bytes32) public returns (uint);\n', '    function rap(bytes32) public returns (uint);\n', '    function draw(bytes32, uint) public;\n', '    function shut(bytes32) public;\n', '    function exit(uint) public;\n', '    function give(bytes32, address) public;\n', '}\n', '\n', 'contract VoxLike {\n', '    function par() public returns (uint);\n', '}\n', '\n', 'contract JoinLike {\n', '    function ilk() public returns (bytes32);\n', '    function gem() public returns (GemLike);\n', '    function dai() public returns (GemLike);\n', '    function join(address, uint) public;\n', '    function exit(address, uint) public;\n', '}\n', 'contract VatLike {\n', '    function ilks(bytes32) public view returns (uint, uint, uint, uint, uint);\n', '    function hope(address) public;\n', '    function frob(bytes32, address, address, address, int, int) public;\n', '}\n', '\n', 'contract ManagerLike {\n', '    function vat() public view returns (address);\n', '    function urns(uint) public view returns (address);\n', '    function open(bytes32, address) public returns (uint);\n', '    function frob(uint, int, int) public;\n', '    function give(uint, address) public;\n', '    function move(uint, address, uint) public;\n', '}\n', '\n', 'contract OtcLike {\n', '    function getPayAmount(address, address, uint) public view returns (uint);\n', '    function buyAllAmount(address, uint, address, uint) public;\n', '}\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the global ERC1820 Registry, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n', ' * implementers for interfaces in this registry, as well as query support.\n', ' *\n', ' * Implementers may be shared by multiple accounts, and can also implement more\n', ' * than a single interface for each account. Contracts can implement interfaces\n', ' * for themselves, but externally-owned accounts (EOA) must delegate this to a\n', ' * contract.\n', ' *\n', ' * {IERC165} interfaces can also be queried via the registry.\n', ' *\n', ' * For an in-depth explanation and source code analysis, see the EIP text.\n', ' */\n', 'interface IERC1820Registry {\n', '    /**\n', '     * @dev Sets `newManager` as the manager for `account`. A manager of an\n', '     * account is able to set interface implementers for it.\n', '     *\n', '     * By default, each account is its own manager. Passing a value of `0x0` in\n', '     * `newManager` will reset the manager to this initial state.\n', '     *\n', '     * Emits a {ManagerChanged} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     */\n', '    function setManager(address account, address newManager) external;\n', '\n', '    /**\n', '     * @dev Returns the manager for `account`.\n', '     *\n', '     * See {setManager}.\n', '     */\n', '    function getManager(address account) external view returns (address);\n', '\n', '    /**\n', "     * @dev Sets the `implementer` contract as `account`'s implementer for\n", '     * `interfaceHash`.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     * The zero address can also be used in `implementer` to remove an old one.\n', '     *\n', '     * See {interfaceHash} to learn how these are created.\n', '     *\n', '     * Emits an {InterfaceImplementerSet} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n', '     * end in 28 zeroes).\n', '     * - `implementer` must implement {IERC1820Implementer} and return true when\n', '     * queried for support, unless `implementer` is the caller. See\n', '     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n', '     */\n', '    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n', '\n', '    /**\n', '     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n', '     * implementer is registered, returns the zero address.\n', '     *\n', '     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n', '     * zeroes), `account` will be queried for support of it.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     */\n', '    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n', '     * corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n', '     */\n', '    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n', '\n', '    /**\n', '     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n', '     *  @param account Address of the contract for which to update the cache.\n', '     *  @param interfaceId ERC165 interface for which to update the cache.\n', '     */\n', '    function updateERC165Cache(address account, bytes4 interfaceId) external;\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not.\n', '     *  If the result is not cached a direct lookup on the contract address is performed.\n', '     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n', '     *  {updateERC165Cache} with the contract address.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n', '\n', '    event ManagerChanged(address indexed account, address indexed newManager);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(address) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard is Initializable {\n', '    // counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    function initialize() public initializer {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '/**\n', ' * @author Brendan Asselstine\n', ' * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\n', ' * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\n', ' */\n', 'library UniformRandomNumber {\n', '  /// @notice Select a random number without modulo bias using a random seed and upper bound\n', '  /// @param _entropy The seed for randomness\n', '  /// @param _upperBound The upper bound of the desired number\n', '  /// @return A random number less than the _upperBound\n', '  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\n', '    require(_upperBound > 0, "UniformRand/min-bound");\n', '    uint256 min = -_upperBound % _upperBound;\n', '    uint256 random = _entropy;\n', '    while (true) {\n', '      if (random >= min) {\n', '        break;\n', '      }\n', '      random = uint256(keccak256(abi.encodePacked(random)));\n', '    }\n', '    return random % _upperBound;\n', '  }\n', '}\n', '/**\n', ' *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\n', ' *  @auditors: []\n', ' *  @bounties: [<14 days 10 ETH max payout>]\n', ' *  @deployments: []\n', ' */\n', '\n', '\n', '\n', '/**\n', ' *  @title SortitionSumTreeFactory\n', ' *  @author Enrique Piqueras - <[email\xa0protected]>\n', ' *  @dev A factory of trees that keep track of staked values for sortition.\n', ' */\n', 'library SortitionSumTreeFactory {\n', '    /* Structs */\n', '\n', '    struct SortitionSumTree {\n', '        uint K; // The maximum number of childs per node.\n', '        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\n', '        uint[] stack;\n', '        uint[] nodes;\n', '        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\n', '        mapping(bytes32 => uint) IDsToNodeIndexes;\n', '        mapping(uint => bytes32) nodeIndexesToIDs;\n', '    }\n', '\n', '    /* Storage */\n', '\n', '    struct SortitionSumTrees {\n', '        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\n', '    }\n', '\n', '    /* internal */\n', '\n', '    /**\n', '     *  @dev Create a sortition sum tree at the specified key.\n', '     *  @param _key The key of the new tree.\n', '     *  @param _K The number of children each node in the tree should have.\n', '     */\n', '    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '        require(tree.K == 0, "Tree already exists.");\n', '        require(_K > 1, "K must be greater than one.");\n', '        tree.K = _K;\n', '        tree.stack.length = 0;\n', '        tree.nodes.length = 0;\n', '        tree.nodes.push(0);\n', '    }\n', '\n', '    /**\n', '     *  @dev Set a value of a tree.\n', '     *  @param _key The key of the tree.\n', '     *  @param _value The new value.\n', '     *  @param _ID The ID of the value.\n', '     *  `O(log_k(n))` where\n', '     *  `k` is the maximum number of childs per node in the tree,\n', '     *   and `n` is the maximum number of nodes ever appended.\n', '     */\n', '    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '        uint treeIndex = tree.IDsToNodeIndexes[_ID];\n', '\n', '        if (treeIndex == 0) { // No existing node.\n', '            if (_value != 0) { // Non zero value.\n', '                // Append.\n', '                // Add node.\n', '                if (tree.stack.length == 0) { // No vacant spots.\n', '                    // Get the index and append the value.\n', '                    treeIndex = tree.nodes.length;\n', '                    tree.nodes.push(_value);\n', '\n', '                    // Potentially append a new node and make the parent a sum node.\n', '                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\n', '                        uint parentIndex = treeIndex / tree.K;\n', '                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\n', '                        uint newIndex = treeIndex + 1;\n', '                        tree.nodes.push(tree.nodes[parentIndex]);\n', '                        delete tree.nodeIndexesToIDs[parentIndex];\n', '                        tree.IDsToNodeIndexes[parentID] = newIndex;\n', '                        tree.nodeIndexesToIDs[newIndex] = parentID;\n', '                    }\n', '                } else { // Some vacant spot.\n', '                    // Pop the stack and append the value.\n', '                    treeIndex = tree.stack[tree.stack.length - 1];\n', '                    tree.stack.length--;\n', '                    tree.nodes[treeIndex] = _value;\n', '                }\n', '\n', '                // Add label.\n', '                tree.IDsToNodeIndexes[_ID] = treeIndex;\n', '                tree.nodeIndexesToIDs[treeIndex] = _ID;\n', '\n', '                updateParents(self, _key, treeIndex, true, _value);\n', '            }\n', '        } else { // Existing node.\n', '            if (_value == 0) { // Zero value.\n', '                // Remove.\n', '                // Remember value and set to 0.\n', '                uint value = tree.nodes[treeIndex];\n', '                tree.nodes[treeIndex] = 0;\n', '\n', '                // Push to stack.\n', '                tree.stack.push(treeIndex);\n', '\n', '                // Clear label.\n', '                delete tree.IDsToNodeIndexes[_ID];\n', '                delete tree.nodeIndexesToIDs[treeIndex];\n', '\n', '                updateParents(self, _key, treeIndex, false, value);\n', '            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\n', '                // Set.\n', '                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\n', '                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\n', '                tree.nodes[treeIndex] = _value;\n', '\n', '                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\n', '            }\n', '        }\n', '    }\n', '\n', '    /* internal Views */\n', '\n', '    /**\n', '     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\n', '     *  @param _key The key of the tree to get the leaves from.\n', '     *  @param _cursor The pagination cursor.\n', '     *  @param _count The number of items to return.\n', '     *  @return The index at which leaves start, the values of the returned leaves, and whether there are more for pagination.\n', '     *  `O(n)` where\n', '     *  `n` is the maximum number of nodes ever appended.\n', '     */\n', '    function queryLeafs(\n', '        SortitionSumTrees storage self,\n', '        bytes32 _key,\n', '        uint _cursor,\n', '        uint _count\n', '    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '\n', '        // Find the start index.\n', '        for (uint i = 0; i < tree.nodes.length; i++) {\n', '            if ((tree.K * i) + 1 >= tree.nodes.length) {\n', '                startIndex = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Get the values.\n', '        uint loopStartIndex = startIndex + _cursor;\n', '        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\n', '        uint valuesIndex = 0;\n', '        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\n', '            if (valuesIndex < _count) {\n', '                values[valuesIndex] = tree.nodes[j];\n', '                valuesIndex++;\n', '            } else {\n', '                hasMore = true;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\n', '     *  @param _key The key of the tree.\n', '     *  @param _drawnNumber The drawn number.\n', '     *  @return The drawn ID.\n', '     *  `O(k * log_k(n))` where\n', '     *  `k` is the maximum number of childs per node in the tree,\n', '     *   and `n` is the maximum number of nodes ever appended.\n', '     */\n', '    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '        uint treeIndex = 0;\n', '        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\n', '\n', '        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\n', '            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\n', '                uint nodeIndex = (tree.K * treeIndex) + i;\n', '                uint nodeValue = tree.nodes[nodeIndex];\n', '\n', '                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\n', '                else { // Pick this child.\n', '                    treeIndex = nodeIndex;\n', '                    break;\n', '                }\n', '            }\n', '        \n', '        ID = tree.nodeIndexesToIDs[treeIndex];\n', '    }\n', '\n', "    /** @dev Gets a specified ID's associated value.\n", '     *  @param _key The key of the tree.\n', '     *  @param _ID The ID of the value.\n', '     *  @return The associated value.\n', '     */\n', '    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '        uint treeIndex = tree.IDsToNodeIndexes[_ID];\n', '\n', '        if (treeIndex == 0) value = 0;\n', '        else value = tree.nodes[treeIndex];\n', '    }\n', '\n', '   function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\n', '       SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '       if (tree.nodes.length == 0) {\n', '           return 0;\n', '       } else {\n', '           return tree.nodes[0];\n', '       }\n', '   }\n', '\n', '    /* Private */\n', '\n', '    /**\n', '     *  @dev Update all the parents of a node.\n', '     *  @param _key The key of the tree to update.\n', '     *  @param _treeIndex The index of the node to start from.\n', '     *  @param _plusOrMinus Wether to add (true) or substract (false).\n', '     *  @param _value The value to add or substract.\n', '     *  `O(log_k(n))` where\n', '     *  `k` is the maximum number of childs per node in the tree,\n', '     *   and `n` is the maximum number of nodes ever appended.\n', '     */\n', '    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\n', '        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\n', '\n', '        uint parentIndex = _treeIndex;\n', '        while (parentIndex != 0) {\n', '            parentIndex = (parentIndex - 1) / tree.K;\n', '            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @author Brendan Asselstine\n', ' * @notice Tracks committed and open balances for addresses.  Affords selection of an address by indexing all committed balances.\n', ' *\n', ' * Balances are tracked in Draws.  There is always one open Draw.  Deposits are always added to the open Draw.\n', ' * When a new draw is opened, the previous opened draw is committed.\n', ' *\n', ' * The committed balance for an address is the total of their balances for committed Draws.\n', " * An address's open balance is their balance in the open Draw.\n", ' */\n', 'library DrawManager {\n', '    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * The ID to use for the selection tree.\n', '     */\n', '    bytes32 public constant TREE_OF_DRAWS = "TreeOfDraws";\n', '\n', '    uint8 public constant MAX_BRANCHES_PER_NODE = 10;\n', '\n', '    /**\n', '     * Stores information for all draws.\n', '     */\n', '    struct State {\n', '        /**\n', "         * Each Draw stores it's address balances in a sortitionSumTree.  Draw trees are indexed using the Draw index.\n", '         * There is one root sortitionSumTree that stores all of the draw totals.  The root tree is indexed using the constant TREE_OF_DRAWS.\n', '         */\n', '        SortitionSumTreeFactory.SortitionSumTrees sortitionSumTrees;\n', '\n', '        /**\n', '         * Stores the consolidated draw index that an address deposited to.\n', '         */\n', '        mapping(address => uint256) consolidatedDrawIndices;\n', '\n', '        /**\n', '         * Stores the last Draw index that an address deposited to.\n', '         */\n', '        mapping(address => uint256) latestDrawIndices;\n', '\n', '        /**\n', '         * Stores a mapping of Draw index => Draw total\n', '         */\n', '        mapping(uint256 => uint256) __deprecated__drawTotals;\n', '\n', '        /**\n', '         * The current open Draw index\n', '         */\n', '        uint256 openDrawIndex;\n', '\n', '        /**\n', '         * The total of committed balances\n', '         */\n', '        uint256 __deprecated__committedSupply;\n', '    }\n', '\n', '    /**\n', '     * @notice Opens the next Draw and commits the previous open Draw (if any).\n', '     * @param self The drawState this library is attached to\n', '     * @return The index of the new open Draw\n', '     */\n', '    function openNextDraw(State storage self) public returns (uint256) {\n', '        if (self.openDrawIndex == 0) {\n', '            // If there is no previous draw, we must initialize\n', '            self.sortitionSumTrees.createTree(TREE_OF_DRAWS, MAX_BRANCHES_PER_NODE);\n', '        } else {\n', '            // else add current draw to sortition sum trees\n', '            bytes32 drawId = bytes32(self.openDrawIndex);\n', '            uint256 drawTotal = openSupply(self);\n', '            self.sortitionSumTrees.set(TREE_OF_DRAWS, drawTotal, drawId);\n', '        }\n', '        // now create a new draw\n', '        uint256 drawIndex = self.openDrawIndex.add(1);\n', '        self.sortitionSumTrees.createTree(bytes32(drawIndex), MAX_BRANCHES_PER_NODE);\n', '        self.openDrawIndex = drawIndex;\n', '\n', '        return drawIndex;\n', '    }\n', '\n', '    /**\n', '     * @notice Deposits the given amount into the current open draw by the given user.\n', '     * @param self The DrawManager state\n', '     * @param _addr The address to deposit for\n', '     * @param _amount The amount to deposit\n', '     */\n', '    function deposit(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\n', '        bytes32 userId = bytes32(uint256(_addr));\n', '        uint256 openDrawIndex = self.openDrawIndex;\n', '\n', '        // update the current draw\n', '        uint256 currentAmount = self.sortitionSumTrees.stakeOf(bytes32(openDrawIndex), userId);\n', '        currentAmount = currentAmount.add(_amount);\n', '        drawSet(self, openDrawIndex, currentAmount, _addr);\n', '\n', '        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\n', '        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\n', '\n', "        // if this is the user's first draw, set it\n", '        if (consolidatedDrawIndex == 0) {\n', '            self.consolidatedDrawIndices[_addr] = openDrawIndex;\n', '        // otherwise, if the consolidated draw is not this draw\n', '        } else if (consolidatedDrawIndex != openDrawIndex) {\n', '            // if a second draw does not exist\n', '            if (latestDrawIndex == 0) {\n', '                // set the second draw to the current draw\n', '                self.latestDrawIndices[_addr] = openDrawIndex;\n', '            // otherwise if a second draw exists but is not the current one\n', '            } else if (latestDrawIndex != openDrawIndex) {\n', '                // merge it into the first draw, and update the second draw index to this one\n', '                uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\n', '                uint256 latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\n', '                drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(latestAmount), _addr);\n', '                drawSet(self, latestDrawIndex, 0, _addr);\n', '                self.latestDrawIndices[_addr] = openDrawIndex;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Deposits into a user's committed balance, thereby bypassing the open draw.\n", '     * @param self The DrawManager state\n', '     * @param _addr The address of the user for whom to deposit\n', '     * @param _amount The amount to deposit\n', '     */\n', '    function depositCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\n', '        bytes32 userId = bytes32(uint256(_addr));\n', '        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\n', '\n', '        // if they have a committed balance\n', '        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\n', '            uint256 consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\n', '            drawSet(self, consolidatedDrawIndex, consolidatedAmount.add(_amount), _addr);\n', '        } else { // they must not have any committed balance\n', '            self.latestDrawIndices[_addr] = consolidatedDrawIndex;\n', '            self.consolidatedDrawIndices[_addr] = self.openDrawIndex.sub(1);\n', '            drawSet(self, self.consolidatedDrawIndices[_addr], _amount, _addr);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Withdraws a user's committed and open draws.\n", '     * @param self The DrawManager state\n', '     * @param _addr The address whose balance to withdraw\n', '     */\n', '    function withdraw(State storage self, address _addr) public requireOpenDraw(self) onlyNonZero(_addr) {\n', '        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\n', '        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\n', '\n', '        if (consolidatedDrawIndex != 0) {\n', '            drawSet(self, consolidatedDrawIndex, 0, _addr);\n', '            delete self.consolidatedDrawIndices[_addr];\n', '        }\n', '\n', '        if (latestDrawIndex != 0) {\n', '            drawSet(self, latestDrawIndex, 0, _addr);\n', '            delete self.latestDrawIndices[_addr];\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Withdraw's from a user's open balance\n", '     * @param self The DrawManager state\n', '     * @param _addr The user to withdrawn from\n', '     * @param _amount The amount to withdraw\n', '     */\n', '    function withdrawOpen(State storage self, address _addr, uint256 _amount) public requireOpenDraw(self) onlyNonZero(_addr) {\n', '        bytes32 userId = bytes32(uint256(_addr));\n', '        uint256 openTotal = self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), userId);\n', '\n', '        require(_amount <= openTotal, "DrawMan/exceeds-open");\n', '\n', '        uint256 remaining = openTotal.sub(_amount);\n', '\n', '        drawSet(self, self.openDrawIndex, remaining, _addr);\n', '    }\n', '\n', '    /**\n', "     * @notice Withdraw's from a user's committed balance.  Fails if the user attempts to take more than available.\n", '     * @param self The DrawManager state\n', '     * @param _addr The user to withdraw from\n', '     * @param _amount The amount to withdraw.\n', '     */\n', '    function withdrawCommitted(State storage self, address _addr, uint256 _amount) public requireCommittedDraw(self) onlyNonZero(_addr) {\n', '        bytes32 userId = bytes32(uint256(_addr));\n', '        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\n', '        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\n', '\n', '        uint256 consolidatedAmount = 0;\n', '        uint256 latestAmount = 0;\n', '        uint256 total = 0;\n', '\n', '        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\n', '            latestAmount = self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), userId);\n', '            total = total.add(latestAmount);\n', '        }\n', '\n', '        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\n', '            consolidatedAmount = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), userId);\n', '            total = total.add(consolidatedAmount);\n', '        }\n', '\n', '        // If the total is greater than zero, then consolidated *must* have the committed balance\n', '        // However, if the total is zero then the consolidated balance may be the open balance\n', '        if (total == 0) {\n', '            return;\n', '        }\n', '\n', '        require(_amount <= total, "Pool/exceed");\n', '\n', '        uint256 remaining = total.sub(_amount);\n', '\n', '        // if there was a second amount that needs to be updated\n', '        if (remaining > consolidatedAmount) {\n', '            uint256 secondRemaining = remaining.sub(consolidatedAmount);\n', '            drawSet(self, latestDrawIndex, secondRemaining, _addr);\n', '        } else if (latestAmount > 0) { // else delete the second amount if it exists\n', '            delete self.latestDrawIndices[_addr];\n', '            drawSet(self, latestDrawIndex, 0, _addr);\n', '        }\n', '\n', '        // if the consolidated amount needs to be destroyed\n', '        if (remaining == 0) {\n', '            delete self.consolidatedDrawIndices[_addr];\n', '            drawSet(self, consolidatedDrawIndex, 0, _addr);\n', '        } else if (remaining < consolidatedAmount) {\n', '            drawSet(self, consolidatedDrawIndex, remaining, _addr);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the total balance for an address, including committed balances and the open balance.\n', '     */\n', '    function balanceOf(State storage drawState, address _addr) public view returns (uint256) {\n', '        return committedBalanceOf(drawState, _addr).add(openBalanceOf(drawState, _addr));\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the total committed balance for an address.\n', '     * @param self The DrawManager state\n', '     * @param _addr The address whose committed balance should be returned\n', '     * @return The total committed balance\n', '     */\n', '    function committedBalanceOf(State storage self, address _addr) public view returns (uint256) {\n', '        uint256 balance = 0;\n', '\n', '        uint256 consolidatedDrawIndex = self.consolidatedDrawIndices[_addr];\n', '        uint256 latestDrawIndex = self.latestDrawIndices[_addr];\n', '\n', '        if (consolidatedDrawIndex != 0 && consolidatedDrawIndex != self.openDrawIndex) {\n', '            balance = self.sortitionSumTrees.stakeOf(bytes32(consolidatedDrawIndex), bytes32(uint256(_addr)));\n', '        }\n', '\n', '        if (latestDrawIndex != 0 && latestDrawIndex != self.openDrawIndex) {\n', '            balance = balance.add(self.sortitionSumTrees.stakeOf(bytes32(latestDrawIndex), bytes32(uint256(_addr))));\n', '        }\n', '\n', '        return balance;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the open balance for an address\n', '     * @param self The DrawManager state\n', '     * @param _addr The address whose open balance should be returned\n', '     * @return The open balance\n', '     */\n', '    function openBalanceOf(State storage self, address _addr) public view returns (uint256) {\n', '        if (self.openDrawIndex == 0) {\n', '            return 0;\n', '        } else {\n', '            return self.sortitionSumTrees.stakeOf(bytes32(self.openDrawIndex), bytes32(uint256(_addr)));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the open Draw balance for the DrawManager\n', '     * @param self The DrawManager state\n', '     * @return The open draw total balance\n', '     */\n', '    function openSupply(State storage self) public view returns (uint256) {\n', '        return self.sortitionSumTrees.total(bytes32(self.openDrawIndex));\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the committed balance for the DrawManager\n', '     * @param self The DrawManager state\n', '     * @return The total committed balance\n', '     */\n', '    function committedSupply(State storage self) public view returns (uint256) {\n', '        return self.sortitionSumTrees.total(TREE_OF_DRAWS);\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the Draw balance for an address.\n', '     * @param self The DrawManager state\n', '     * @param _drawIndex The Draw index\n', '     * @param _amount The new balance\n', '     * @param _addr The address whose balance should be updated\n', '     */\n', '    function drawSet(State storage self, uint256 _drawIndex, uint256 _amount, address _addr) internal {\n', '        bytes32 drawId = bytes32(_drawIndex);\n', '        bytes32 userId = bytes32(uint256(_addr));\n', '        uint256 oldAmount = self.sortitionSumTrees.stakeOf(drawId, userId);\n', '\n', '        if (oldAmount != _amount) {\n', '            // If the amount has changed\n', '\n', "            // Update the Draw's balance for that address\n", '            self.sortitionSumTrees.set(drawId, _amount, userId);\n', '\n', '            // if the draw is committed\n', '            if (_drawIndex != self.openDrawIndex) {\n', '                // Get the new draw total\n', '                uint256 newDrawTotal = self.sortitionSumTrees.total(drawId);\n', '\n', '                // update the draw in the committed tree\n', '                self.sortitionSumTrees.set(TREE_OF_DRAWS, newDrawTotal, drawId);\n', '            }\n', '        }\n', '    }\n', '\n', '   /**\n', '     * @notice Selects an address by indexing into the committed tokens using the passed token.\n', '     * If there is no committed supply, the zero address is returned.\n', '     * @param self The DrawManager state\n', '     * @param _token The token index to select\n', '     * @return The selected address\n', '     */\n', '    function draw(State storage self, uint256 _token) public view returns (address) {\n', '        // If there is no one to select, just return the zero address\n', '        if (committedSupply(self) == 0) {\n', '            return address(0);\n', '        }\n', '        require(_token < committedSupply(self), "Pool/ineligible");\n', '        bytes32 drawIndex = self.sortitionSumTrees.draw(TREE_OF_DRAWS, _token);\n', '        uint256 drawSupply = self.sortitionSumTrees.total(drawIndex);\n', '        uint256 drawToken = _token % drawSupply;\n', '        return address(uint256(self.sortitionSumTrees.draw(drawIndex, drawToken)));\n', '    }\n', '\n', '    /**\n', '     * @notice Selects an address using the entropy as an index into the committed tokens\n', '     * The entropy is passed into the UniformRandomNumber library to remove modulo bias.\n', '     * @param self The DrawManager state\n', '     * @param _entropy The random entropy to use\n', '     * @return The selected address\n', '     */\n', '    function drawWithEntropy(State storage self, bytes32 _entropy) public view returns (address) {\n', '        uint256 bound = committedSupply(self);\n', '        address selected;\n', '        if (bound == 0) {\n', '            selected = address(0);\n', '        } else {\n', '            selected = draw(self, UniformRandomNumber.uniform(uint256(_entropy), bound));\n', '        }\n', '        return selected;\n', '    }\n', '\n', '    modifier requireOpenDraw(State storage self) {\n', '        require(self.openDrawIndex > 0, "Pool/no-open");\n', '        _;\n', '    }\n', '\n', '    modifier requireCommittedDraw(State storage self) {\n', '        require(self.openDrawIndex > 1, "Pool/no-commit");\n', '        _;\n', '    }\n', '\n', '    modifier onlyNonZero(address _addr) {\n', '        require(_addr != address(0), "Pool/not-zero");\n', '        _;\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @title FixidityLib\n', ' * @author Gadi Guy, Alberto Cuesta Canada\n', ' * @notice This library provides fixed point arithmetic with protection against\n', ' * overflow. \n', ' * All operations are done with int256 and the operands must have been created \n', ' * with any of the newFrom* functions, which shift the comma digits() to the \n', ' * right and check for limits.\n', ' * When using this library be sure of using maxNewFixed() as the upper limit for\n', ' * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\n', " * maxFixedAdd() if you want to be certain that those operations don't \n", ' * overflow.\n', ' */\n', 'library FixidityLib {\n', '\n', '    /**\n', '     * @notice Number of positions that the comma is shifted to the right.\n', '     */\n', '    function digits() public pure returns(uint8) {\n', '        return 24;\n', '    }\n', '    \n', '    /**\n', '     * @notice This is 1 in the fixed point units used in this library.\n', '     * @dev Test fixed1() equals 10^digits()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function fixed1() public pure returns(int256) {\n', '        return 1000000000000000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice The amount of decimals lost on each multiplication operand.\n', '     * @dev Test mulPrecision() equals sqrt(fixed1)\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function mulPrecision() public pure returns(int256) {\n', '        return 1000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be represented in an int256\n', '     * @dev Test maxInt256() equals 2^255 -1\n', '     */\n', '    function maxInt256() public pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n', '    }\n', '\n', '    /**\n', '     * @notice Minimum value that can be represented in an int256\n', '     * @dev Test minInt256 equals (2^255) * (-1)\n', '     */\n', '    function minInt256() public pure returns(int256) {\n', '        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be converted to fixed point. Optimize for\n', '     * @dev deployment. \n', '     * Test maxNewFixed() equals maxInt256() / fixed1()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxNewFixed() public pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Minimum value that can be converted to fixed point. Optimize for\n', '     * deployment. \n', '     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function minNewFixed() public pure returns(int256) {\n', '        return -57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as an addition operator.\n', '     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\n', '     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\n', '     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \n', '     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\n', '     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \n', '     */\n', '    function maxFixedAdd() public pure returns(int256) {\n', '        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum negative value that can be safely in a subtraction.\n', '     * @dev Test maxFixedSub() equals minInt256() / 2\n', '     */\n', '    function maxFixedSub() public pure returns(int256) {\n', '        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a multiplication operator.\n', '     * @dev Calculated as sqrt(maxInt256()*fixed1()). \n', "     * Be careful with your sqrt() implementation. I couldn't find a calculator\n", '     * that would give the exact square root of maxInt256*fixed1 so this number\n', '     * is below the real number by no more than 3*10**28. It is safe to use as\n', '     * a limit for your multiplications, although powers of two of numbers over\n', '     * this value might still work.\n', '     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\n', '     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \n', '     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\n', '     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedMul() public pure returns(int256) {\n', '        return 240615969168004498257251713877715648331380787511296;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a dividend.\n', '     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\n', '     * Test maxFixedDiv() equals maxInt256()/fixed1()\n', '     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\n', '     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedDiv() public pure returns(int256) {\n', '        return 57896044618658097711785492504343953926634992332820282;\n', '    }\n', '\n', '    /**\n', '     * @notice Maximum value that can be safely used as a divisor.\n', '     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\n', '     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\n', '     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\n', '     * Hardcoded to 24 digits.\n', '     */\n', '    function maxFixedDivisor() public pure returns(int256) {\n', '        return 1000000000000000000000000000000000000000000000000;\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 to fixed point units, equivalent to multiplying\n', '     * by 10^digits().\n', '     * @dev Test newFixed(0) returns 0\n', '     * Test newFixed(1) returns fixed1()\n', '     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\n', '     * Test newFixed(maxNewFixed()+1) fails\n', '     */\n', '    function newFixed(int256 x)\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        require(x <= maxNewFixed());\n', '        require(x >= minNewFixed());\n', '        return x * fixed1();\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 in the fixed point representation of this \n', '     * library to a non decimal. All decimal digits will be truncated.\n', '     */\n', '    function fromFixed(int256 x)\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return x / fixed1();\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 which is already in some fixed point \n', '     * representation to a different fixed precision representation.\n', '     * Both the origin and destination precisions must be 38 or less digits.\n', '     * Origin values with a precision higher than the destination precision\n', '     * will be truncated accordingly.\n', '     * @dev \n', '     * Test convertFixed(1,0,0) returns 1;\n', '     * Test convertFixed(1,1,1) returns 1;\n', '     * Test convertFixed(1,1,0) returns 0;\n', '     * Test convertFixed(1,0,1) returns 10;\n', '     * Test convertFixed(10,1,0) returns 1;\n', '     * Test convertFixed(10,0,1) returns 100;\n', '     * Test convertFixed(100,1,0) returns 10;\n', '     * Test convertFixed(100,0,1) returns 1000;\n', '     * Test convertFixed(1000,2,0) returns 10;\n', '     * Test convertFixed(1000,0,2) returns 100000;\n', '     * Test convertFixed(1000,2,1) returns 100;\n', '     * Test convertFixed(1000,1,2) returns 10000;\n', '     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\n', '     * Test convertFixed(maxInt256,0,1) throws\n', '     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\n', '     * Test convertFixed(1,0,38) returns 10**38;\n', '     * Test convertFixed(maxInt256,39,0) throws\n', '     * Test convertFixed(1,0,39) throws\n', '     */\n', '    function convertFixed(int256 x, uint8 _originDigits, uint8 _destinationDigits)\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        require(_originDigits <= 38 && _destinationDigits <= 38);\n', '        \n', '        uint8 decimalDifference;\n', '        if ( _originDigits > _destinationDigits ){\n', '            decimalDifference = _originDigits - _destinationDigits;\n', '            return x/(uint128(10)**uint128(decimalDifference));\n', '        }\n', '        else if ( _originDigits < _destinationDigits ){\n', '            decimalDifference = _destinationDigits - _originDigits;\n', '            // Cast uint8 -> uint128 is safe\n', '            // Exponentiation is safe:\n', '            //     _originDigits and _destinationDigits limited to 38 or less\n', '            //     decimalDifference = abs(_destinationDigits - _originDigits)\n', '            //     decimalDifference < 38\n', '            //     10**38 < 2**128-1\n', '            require(x <= maxInt256()/uint128(10)**uint128(decimalDifference));\n', '            require(x >= minInt256()/uint128(10)**uint128(decimalDifference));\n', '            return x*(uint128(10)**uint128(decimalDifference));\n', '        }\n', '        // _originDigits == digits()) \n', '        return x;\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 which is already in some fixed point \n', '     * representation to that of this library. The _originDigits parameter is the\n', '     * precision of x. Values with a precision higher than FixidityLib.digits()\n', '     * will be truncated accordingly.\n', '     */\n', '    function newFixed(int256 x, uint8 _originDigits)\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return convertFixed(x, _originDigits, digits());\n', '    }\n', '\n', '    /**\n', '     * @notice Converts an int256 in the fixed point representation of this \n', '     * library to a different representation. The _destinationDigits parameter is the\n', '     * precision of the output x. Values with a precision below than \n', '     * FixidityLib.digits() will be truncated accordingly.\n', '     */\n', '    function fromFixed(int256 x, uint8 _destinationDigits)\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        return convertFixed(x, digits(), _destinationDigits);\n', '    }\n', '\n', '    /**\n', '     * @notice Converts two int256 representing a fraction to fixed point units,\n', '     * equivalent to multiplying dividend and divisor by 10^digits().\n', '     * @dev \n', '     * Test newFixedFraction(maxFixedDiv()+1,1) fails\n', '     * Test newFixedFraction(1,maxFixedDiv()+1) fails\n', '     * Test newFixedFraction(1,0) fails     \n', '     * Test newFixedFraction(0,1) returns 0\n', '     * Test newFixedFraction(1,1) returns fixed1()\n', '     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\n', '     * Test newFixedFraction(1,fixed1()) returns 1\n', '     * Test newFixedFraction(1,fixed1()-1) returns 0\n', '     */\n', '    function newFixedFraction(\n', '        int256 numerator, \n', '        int256 denominator\n', '        )\n', '        public\n', '        pure\n', '        returns (int256)\n', '    {\n', '        require(numerator <= maxNewFixed());\n', '        require(denominator <= maxNewFixed());\n', '        require(denominator != 0);\n', '        int256 convertedNumerator = newFixed(numerator);\n', '        int256 convertedDenominator = newFixed(denominator);\n', '        return divide(convertedNumerator, convertedDenominator);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the integer part of a fixed point number.\n', '     * @dev \n', '     * Test integer(0) returns 0\n', '     * Test integer(fixed1()) returns fixed1()\n', '     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\n', '     * Test integer(-fixed1()) returns -fixed1()\n', '     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\n', '     */\n', '    function integer(int256 x) public pure returns (int256) {\n', "        return (x / fixed1()) * fixed1(); // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice Returns the fractional part of a fixed point number. \n', '     * In the case of a negative number the fractional is also negative.\n', '     * @dev \n', '     * Test fractional(0) returns 0\n', '     * Test fractional(fixed1()) returns 0\n', '     * Test fractional(fixed1()-1) returns 10^24-1\n', '     * Test fractional(-fixed1()) returns 0\n', '     * Test fractional(-fixed1()+1) returns -10^24-1\n', '     */\n', '    function fractional(int256 x) public pure returns (int256) {\n', "        return x - (x / fixed1()) * fixed1(); // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice Converts to positive if negative.\n', '     * Due to int256 having one more negative number than positive numbers \n', '     * abs(minInt256) reverts.\n', '     * @dev \n', '     * Test abs(0) returns 0\n', '     * Test abs(fixed1()) returns -fixed1()\n', '     * Test abs(-fixed1()) returns fixed1()\n', '     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\n', '     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\n', '     */\n', '    function abs(int256 x) public pure returns (int256) {\n', '        if (x >= 0) {\n', '            return x;\n', '        } else {\n', '            int256 result = -x;\n', '            assert (result > 0);\n', '            return result;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice x+y. If any operator is higher than maxFixedAdd() it \n', '     * might overflow.\n', '     * In solidity maxInt256 + 1 = minInt256 and viceversa.\n', '     * @dev \n', '     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\n', '     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\n', '     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\n', '     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\n', '     * Test add(maxInt256(),maxInt256()) fails\n', '     * Test add(minInt256(),minInt256()) fails\n', '     */\n', '    function add(int256 x, int256 y) public pure returns (int256) {\n', '        int256 z = x + y;\n', '        if (x > 0 && y > 0) assert(z > x && z > y);\n', '        if (x < 0 && y < 0) assert(z < x && z < y);\n', '        return z;\n', '    }\n', '\n', '    /**\n', '     * @notice x-y. You can use add(x,-y) instead. \n', '     * @dev Tests covered by add(x,y)\n', '     */\n', '    function subtract(int256 x, int256 y) public pure returns (int256) {\n', '        return add(x,-y);\n', '    }\n', '\n', '    /**\n', '     * @notice x*y. If any of the operators is higher than maxFixedMul() it \n', '     * might overflow.\n', '     * @dev \n', '     * Test multiply(0,0) returns 0\n', '     * Test multiply(maxFixedMul(),0) returns 0\n', '     * Test multiply(0,maxFixedMul()) returns 0\n', '     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\n', '     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\n', '     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\n', '     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\n', '     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\n', '     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\n', '     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\n', '     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\n', '     */\n', '    function multiply(int256 x, int256 y) public pure returns (int256) {\n', '        if (x == 0 || y == 0) return 0;\n', '        if (y == fixed1()) return x;\n', '        if (x == fixed1()) return y;\n', '\n', '        // Separate into integer and fractional parts\n', '        // x = x1 + x2, y = y1 + y2\n', '        int256 x1 = integer(x) / fixed1();\n', '        int256 x2 = fractional(x);\n', '        int256 y1 = integer(y) / fixed1();\n', '        int256 y2 = fractional(y);\n', '        \n', '        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\n', '        int256 x1y1 = x1 * y1;\n', '        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\n', '        \n', '        // x1y1 needs to be multiplied back by fixed1\n', '        // solium-disable-next-line mixedcase\n', '        int256 fixed_x1y1 = x1y1 * fixed1();\n', '        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\n', '        x1y1 = fixed_x1y1;\n', '\n', '        int256 x2y1 = x2 * y1;\n', '        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\n', '\n', '        int256 x1y2 = x1 * y2;\n', '        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\n', '\n', '        x2 = x2 / mulPrecision();\n', '        y2 = y2 / mulPrecision();\n', '        int256 x2y2 = x2 * y2;\n', '        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\n', '\n', '        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\n', '        int256 result = x1y1;\n', '        result = add(result, x2y1); // Add checks for overflow\n', '        result = add(result, x1y2); // Add checks for overflow\n', '        result = add(result, x2y2); // Add checks for overflow\n', '        return result;\n', '    }\n', '    \n', '    /**\n', '     * @notice 1/x\n', '     * @dev \n', '     * Test reciprocal(0) fails\n', '     * Test reciprocal(fixed1()) returns fixed1()\n', '     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\n', '     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\n', '     */\n', '    function reciprocal(int256 x) public pure returns (int256) {\n', '        require(x != 0);\n', "        return (fixed1()*fixed1()) / x; // Can't overflow\n", '    }\n', '\n', '    /**\n', '     * @notice x/y. If the dividend is higher than maxFixedDiv() it \n', '     * might overflow. You can use multiply(x,reciprocal(y)) instead.\n', '     * There is a loss of precision on division for the lower mulPrecision() decimals.\n', '     * @dev \n', '     * Test divide(fixed1(),0) fails\n', '     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\n', '     * Test divide(maxFixedDiv()+1,1) throws\n', '     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\n', '     */\n', '    function divide(int256 x, int256 y) public pure returns (int256) {\n', '        if (y == fixed1()) return x;\n', '        require(y != 0);\n', '        require(y <= maxFixedDivisor());\n', '        return multiply(x, reciprocal(y));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Blocklock\n', ' * @author Brendan Asselstine\n', ' * @notice A time lock with a cooldown period.  When locked, the contract will remain locked until it is unlocked manually\n', ' * or the lock duration expires.  After the contract is unlocked, it cannot be locked until the cooldown duration expires.\n', ' */\n', 'library Blocklock {\n', '  using SafeMath for uint256;\n', '\n', '  struct State {\n', '    uint256 lockedAt;\n', '    uint256 unlockedAt;\n', '    uint256 lockDuration;\n', '    uint256 cooldownDuration;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the duration of the lock.  This how long the lock lasts before it expires and automatically unlocks.\n', '   * @param self The Blocklock state\n', '   * @param lockDuration The duration, in blocks, that the lock should last.\n', '   */\n', '  function setLockDuration(State storage self, uint256 lockDuration) public {\n', '    require(lockDuration > 0, "Blocklock/lock-min");\n', '    self.lockDuration = lockDuration;\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the cooldown duration in blocks.  This is the number of blocks that must pass before being able to\n', '   * lock again.  The cooldown duration begins when the lock duration expires, or when it is unlocked manually.\n', '   * @param self The Blocklock state\n', '   * @param cooldownDuration The duration of the cooldown, in blocks.\n', '   */\n', '  function setCooldownDuration(State storage self, uint256 cooldownDuration) public {\n', '    require(cooldownDuration > 0, "Blocklock/cool-min");\n', '    self.cooldownDuration = cooldownDuration;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns whether the state is locked at the given block number.\n', '   * @param self The Blocklock state\n', '   * @param blockNumber The current block number.\n', '   */\n', '  function isLocked(State storage self, uint256 blockNumber) public view returns (bool) {\n', '    uint256 endAt = lockEndAt(self);\n', '    return (\n', '      self.lockedAt != 0 &&\n', '      blockNumber >= self.lockedAt &&\n', '      blockNumber < endAt\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the state at the given block number.\n', '   * @param self The Blocklock state\n', '   * @param blockNumber The block number to use as the lock start time\n', '   */\n', '  function lock(State storage self, uint256 blockNumber) public {\n', '    require(canLock(self, blockNumber), "Blocklock/no-lock");\n', '    self.lockedAt = blockNumber;\n', '  }\n', '\n', '  /**\n', '   * @notice Manually unlocks the lock.\n', '   * @param self The Blocklock state\n', '   * @param blockNumber The block number at which the lock is being unlocked.\n', '   */\n', '  function unlock(State storage self, uint256 blockNumber) public {\n', '    self.unlockedAt = blockNumber;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns whether the Blocklock can be locked at the given block number\n', '   * @param self The Blocklock state\n', '   * @param blockNumber The block number to check against\n', '   * @return True if we can lock at the given block number, false otherwise.\n', '   */\n', '  function canLock(State storage self, uint256 blockNumber) public view returns (bool) {\n', '    uint256 endAt = lockEndAt(self);\n', '    return (\n', '      self.lockedAt == 0 ||\n', '      blockNumber >= endAt.add(self.cooldownDuration)\n', '    );\n', '  }\n', '\n', '  function cooldownEndAt(State storage self) internal view returns (uint256) {\n', '    return lockEndAt(self).add(self.cooldownDuration);\n', '  }\n', '\n', '  function lockEndAt(State storage self) internal view returns (uint256) {\n', '    uint256 endAt = self.lockedAt.add(self.lockDuration);\n', '    // if we unlocked early\n', '    if (self.unlockedAt >= self.lockedAt && self.unlockedAt < endAt) {\n', '      endAt = self.unlockedAt;\n', '    }\n', '    return endAt;\n', '  }\n', '}\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC777Token standard as defined in the EIP.\n', ' *\n', ' * This contract uses the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n', ' * token holders and recipients react to token movements by using setting implementers\n', ' * for the associated interfaces in said registry. See {IERC1820Registry} and\n', ' * {ERC1820Implementer}.\n', ' */\n', 'interface IERC777 {\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the smallest part of the token that is not divisible. This\n', '     * means all token operations (creation, movement and destruction) must have\n', '     * amounts that are a multiple of this number.\n', '     *\n', '     * For most token contracts, this value will equal 1.\n', '     */\n', '    function granularity() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by an account (`owner`).\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * If send or receive hooks are registered for the caller and `recipient`,\n', '     * the corresponding functions will be called with `data` and empty\n', '     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n', '     *\n', '     * Emits a {Sent} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - the caller must have at least `amount` tokens.\n', '     * - `recipient` cannot be the zero address.\n', '     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n', '     * interface.\n', '     */\n', '    function send(address recipient, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', "     * @dev Destroys `amount` tokens from the caller's account, reducing the\n", '     * total supply.\n', '     *\n', '     * If a send hook is registered for the caller, the corresponding function\n', '     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n', '     *\n', '     * Emits a {Burned} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - the caller must have at least `amount` tokens.\n', '     */\n', '    function burn(uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev Returns true if an account is an operator of `tokenHolder`.\n', '     * Operators can send and burn tokens on behalf of their owners. All\n', '     * accounts are their own operator.\n', '     *\n', '     * See {operatorSend} and {operatorBurn}.\n', '     */\n', '    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Make an account an operator of the caller.\n', '     *\n', '     * See {isOperatorFor}.\n', '     *\n', '     * Emits an {AuthorizedOperator} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `operator` cannot be calling address.\n', '     */\n', '    function authorizeOperator(address operator) external;\n', '\n', '    /**\n', '     * @dev Make an account an operator of the caller.\n', '     *\n', '     * See {isOperatorFor} and {defaultOperators}.\n', '     *\n', '     * Emits a {RevokedOperator} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `operator` cannot be calling address.\n', '     */\n', '    function revokeOperator(address operator) external;\n', '\n', '    /**\n', '     * @dev Returns the list of default operators. These accounts are operators\n', '     * for all token holders, even if {authorizeOperator} was never called on\n', '     * them.\n', '     *\n', '     * This list is immutable, but individual holders may revoke these via\n', '     * {revokeOperator}, in which case {isOperatorFor} will return false.\n', '     */\n', '    function defaultOperators() external view returns (address[] memory);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n', '     * be an operator of `sender`.\n', '     *\n', '     * If send or receive hooks are registered for `sender` and `recipient`,\n', '     * the corresponding functions will be called with `data` and\n', '     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n', '     *\n', '     * Emits a {Sent} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `sender` must have at least `amount` tokens.\n', '     * - the caller must be an operator for `sender`.\n', '     * - `recipient` cannot be the zero address.\n', '     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n', '     * interface.\n', '     */\n', '    function operatorSend(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount,\n', '        bytes calldata data,\n', '        bytes calldata operatorData\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n', '     * The caller must be an operator of `account`.\n', '     *\n', '     * If a send hook is registered for `account`, the corresponding function\n', '     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n', '     *\n', '     * Emits a {Burned} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     * - the caller must be an operator for `account`.\n', '     */\n', '    function operatorBurn(\n', '        address account,\n', '        uint256 amount,\n', '        bytes calldata data,\n', '        bytes calldata operatorData\n', '    ) external;\n', '\n', '    event Sent(\n', '        address indexed operator,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        bytes data,\n', '        bytes operatorData\n', '    );\n', '\n', '    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n', '\n', '    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n', '\n', '    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n', '\n', '    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n', ' *\n', ' * {IERC777} Token holders can be notified of operations performed on their\n', ' * tokens by having a contract implement this interface (contract holders can be\n', ' *  their own implementer) and registering it on the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n', ' *\n', ' * See {IERC1820Registry} and {ERC1820Implementer}.\n', ' */\n', 'interface IERC777Sender {\n', '    /**\n', "     * @dev Called by an {IERC777} token contract whenever a registered holder's\n", '     * (`from`) tokens are about to be moved or destroyed. The type of operation\n', '     * is conveyed by `to` being the zero address or not.\n', '     *\n', "     * This call occurs _before_ the token contract's state is updated, so\n", '     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n', '     *\n', '     * This function may revert to prevent the operation from being executed.\n', '     */\n', '    function tokensToSend(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes calldata userData,\n', '        bytes calldata operatorData\n', '    ) external;\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * IMPORTANT: It is unsafe to assume that an address for which this\n', '     * function returns false is an externally-owned account (EOA) and not a\n', '     * contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC777} interface.\n', ' *\n', ' * Largely taken from the OpenZeppelin ERC777 contract.\n', ' *\n', ' * Support for ERC20 is included in this contract, as specified by the EIP: both\n', ' * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n', ' * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n', ' * movements.\n', ' *\n', ' * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n', ' * are no special restrictions in the amount of tokens that created, moved, or\n', ' * destroyed. This makes integration with ERC20 applications seamless.\n', ' *\n', ' * It is important to note that no Mint events are emitted.  Tokens are minted in batches\n', ' * by a state change in a tree data structure, so emitting a Mint event for each user\n', ' * is not possible.\n', ' *\n', ' */\n', 'contract PoolToken is Initializable, IERC20, IERC777 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  /**\n', '   * Event emitted when a user or operator redeems tokens\n', '   */\n', '  event Redeemed(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n', '\n', '  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '\n', "  // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n", '  // See https://github.com/ethereum/solidity/issues/4024.\n', '\n', '  // keccak256("ERC777TokensSender")\n', '  bytes32 constant internal TOKENS_SENDER_INTERFACE_HASH =\n', '      0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n', '\n', '  // keccak256("ERC777TokensRecipient")\n', '  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n', '      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n', '\n', '  // keccak256("ERC777Token")\n', '  bytes32 constant internal TOKENS_INTERFACE_HASH =\n', '      0xac7fbab5f54a3ca8194167523c6753bfeb96a445279294b6125b68cce2177054;\n', '\n', '  // keccak256("ERC20Token")\n', '  bytes32 constant internal ERC20_TOKENS_INTERFACE_HASH =\n', '      0xaea199e31a596269b42cdafd93407f14436db6e4cad65417994c2eb37381e05a;\n', '\n', '  string internal _name;\n', '  string internal _symbol;\n', '\n', "  // This isn't ever read from - it's only used to respond to the defaultOperators query.\n", '  address[] internal _defaultOperatorsArray;\n', '\n', '  // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n', '  mapping(address => bool) internal _defaultOperators;\n', '\n', '  // For each account, a mapping of its operators and revoked default operators.\n', '  mapping(address => mapping(address => bool)) internal _operators;\n', '  mapping(address => mapping(address => bool)) internal _revokedDefaultOperators;\n', '\n', '  // ERC20-allowances\n', '  mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '  // The Pool that is bound to this token\n', '  BasePool internal _pool;\n', '\n', '  /**\n', '   * @notice Initializes the PoolToken.\n', '   * @param name The name of the token\n', '   * @param symbol The token symbol\n', '   * @param defaultOperators The default operators who are allowed to move tokens\n', '   */\n', '  function init (\n', '    string memory name,\n', '    string memory symbol,\n', '    address[] memory defaultOperators,\n', '    BasePool pool\n', '  ) public initializer {\n', '      require(bytes(name).length != 0, "PoolToken/name");\n', '      require(bytes(symbol).length != 0, "PoolToken/symbol");\n', '      require(address(pool) != address(0), "PoolToken/pool-zero");\n', '\n', '      _name = name;\n', '      _symbol = symbol;\n', '      _pool = pool;\n', '\n', '      _defaultOperatorsArray = defaultOperators;\n', '      for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n', '          _defaultOperators[_defaultOperatorsArray[i]] = true;\n', '      }\n', '\n', '      // register interfaces\n', '      ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_INTERFACE_HASH, address(this));\n', '      ERC1820_REGISTRY.setInterfaceImplementer(address(this), ERC20_TOKENS_INTERFACE_HASH, address(this));\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address of the Pool contract\n', '   * @return The address of the pool contract\n', '   */\n', '  function pool() public view returns (BasePool) {\n', '      return _pool;\n', '  }\n', '\n', '  /**\n', '   * @notice Calls the ERC777 transfer hook, and emits Redeemed and Transfer.  Can only be called by the Pool contract.\n', '   * @param from The address from which to redeem tokens\n', '   * @param amount The amount of tokens to redeem\n', '   */\n', '  function poolRedeem(address from, uint256 amount) external onlyPool {\n', "      _callTokensToSend(from, from, address(0), amount, '', '');\n", '\n', "      emit Redeemed(from, from, amount, '', '');\n", '      emit Transfer(from, address(0), amount);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-name}.\n', '    */\n', '  function name() public view returns (string memory) {\n', '      return _name;\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-symbol}.\n', '    */\n', '  function symbol() public view returns (string memory) {\n', '      return _symbol;\n', '  }\n', '\n', '  /**\n', '    * @dev See {ERC20Detailed-decimals}.\n', '    *\n', '    * Always returns 18, as per the\n', '    * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n', '    */\n', '  function decimals() public view returns (uint8) {\n', '      return 18;\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-granularity}.\n', '    *\n', '    * This implementation always returns `1`.\n', '    */\n', '  function granularity() public view returns (uint256) {\n', '      return 1;\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-totalSupply}.\n', '    */\n', '  function totalSupply() public view returns (uint256) {\n', '      return _pool.committedSupply();\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC20-balanceOf}.\n', '    */\n', '  function balanceOf(address _addr) external view returns (uint256) {\n', '      return _pool.committedBalanceOf(_addr);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-send}.\n', '    *\n', '    * Also emits a {Transfer} event for ERC20 compatibility.\n', '    */\n', '  function send(address recipient, uint256 amount, bytes calldata data) external {\n', '      _send(msg.sender, msg.sender, recipient, amount, data, "");\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC20-transfer}.\n', '    *\n', '    * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n', '    * interface if it is a contract.\n', '    *\n', '    * Also emits a {Sent} event.\n', '    */\n', '  function transfer(address recipient, uint256 amount) external returns (bool) {\n', '      require(recipient != address(0), "PoolToken/transfer-zero");\n', '\n', '      address from = msg.sender;\n', '\n', '      _callTokensToSend(from, from, recipient, amount, "", "");\n', '\n', '      _move(from, from, recipient, amount, "", "");\n', '\n', '      _callTokensReceived(from, from, recipient, amount, "", "", false);\n', '\n', '      return true;\n', '  }\n', '\n', '  /**\n', '    * @dev Allows a user to withdraw their tokens as the underlying asset.\n', '    *\n', '    * Also emits a {Transfer} event for ERC20 compatibility.\n', '    */\n', '  function redeem(uint256 amount, bytes calldata data) external {\n', '      _redeem(msg.sender, msg.sender, amount, data, "");\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-burn}.  Not currently implemented.\n', '    *\n', '    * Also emits a {Transfer} event for ERC20 compatibility.\n', '    */\n', '  function burn(uint256, bytes calldata) external {\n', '      revert("PoolToken/no-support");\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-isOperatorFor}.\n', '    */\n', '  function isOperatorFor(\n', '      address operator,\n', '      address tokenHolder\n', '  ) public view returns (bool) {\n', '      return operator == tokenHolder ||\n', '          (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n', '          _operators[tokenHolder][operator];\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-authorizeOperator}.\n', '    */\n', '  function authorizeOperator(address operator) external {\n', '      require(msg.sender != operator, "PoolToken/auth-self");\n', '\n', '      if (_defaultOperators[operator]) {\n', '          delete _revokedDefaultOperators[msg.sender][operator];\n', '      } else {\n', '          _operators[msg.sender][operator] = true;\n', '      }\n', '\n', '      emit AuthorizedOperator(operator, msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-revokeOperator}.\n', '    */\n', '  function revokeOperator(address operator) external {\n', '      require(operator != msg.sender, "PoolToken/revoke-self");\n', '\n', '      if (_defaultOperators[operator]) {\n', '          _revokedDefaultOperators[msg.sender][operator] = true;\n', '      } else {\n', '          delete _operators[msg.sender][operator];\n', '      }\n', '\n', '      emit RevokedOperator(operator, msg.sender);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-defaultOperators}.\n', '    */\n', '  function defaultOperators() public view returns (address[] memory) {\n', '      return _defaultOperatorsArray;\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-operatorSend}.\n', '    *\n', '    * Emits {Sent} and {Transfer} events.\n', '    */\n', '  function operatorSend(\n', '      address sender,\n', '      address recipient,\n', '      uint256 amount,\n', '      bytes calldata data,\n', '      bytes calldata operatorData\n', '  )\n', '  external\n', '  {\n', '      require(isOperatorFor(msg.sender, sender), "PoolToken/not-operator");\n', '      _send(msg.sender, sender, recipient, amount, data, operatorData);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC777-operatorBurn}.\n', '    *\n', '    * Currently not supported\n', '    */\n', '  function operatorBurn(address, uint256, bytes calldata, bytes calldata) external {\n', '      revert("PoolToken/no-support");\n', '  }\n', '\n', '  /**\n', '    * @dev Allows an operator to redeem tokens for the underlying asset on behalf of a user.\n', '    *\n', '    * Emits {Redeemed} and {Transfer} events.\n', '    */\n', '  function operatorRedeem(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n', '      require(isOperatorFor(msg.sender, account), "PoolToken/not-operator");\n', '      _redeem(msg.sender, account, amount, data, operatorData);\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC20-allowance}.\n', '    *\n', '    * Note that operator and allowance concepts are orthogonal: operators may\n', '    * not have allowance, and accounts with allowance may not be operators\n', '    * themselves.\n', '    */\n', '  function allowance(address holder, address spender) public view returns (uint256) {\n', '      return _allowances[holder][spender];\n', '  }\n', '\n', '  /**\n', '    * @dev See {IERC20-approve}.\n', '    *\n', '    * Note that accounts cannot have allowance issued by their operators.\n', '    */\n', '  function approve(address spender, uint256 value) external returns (bool) {\n', '      address holder = msg.sender;\n', '      _approve(holder, spender, value);\n', '      return true;\n', '  }\n', '\n', '  /**\n', '    * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '    *\n', '    * This is an alternative to {approve} that can be used as a mitigation for\n', '    * problems described in {IERC20-approve}.\n', '    *\n', '    * Emits an {Approval} event indicating the updated allowance.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `spender` cannot be the zero address.\n', '    */\n', '  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '      _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '      return true;\n', '  }\n', '\n', '  /**\n', '    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '    *\n', '    * This is an alternative to {approve} that can be used as a mitigation for\n', '    * problems described in {IERC20-approve}.\n', '    *\n', '    * Emits an {Approval} event indicating the updated allowance.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `spender` cannot be the zero address.\n', '    * - `spender` must have allowance for the caller of at least\n', '    * `subtractedValue`.\n', '    */\n', '  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '      _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "PoolToken/negative"));\n', '      return true;\n', '  }\n', '\n', '  /**\n', '  * @dev See {IERC20-transferFrom}.\n', '  *\n', '  * Note that operator and allowance concepts are orthogonal: operators cannot\n', '  * call `transferFrom` (unless they have allowance), and accounts with\n', '  * allowance cannot call `operatorSend` (unless they are operators).\n', '  *\n', '  * Emits {Sent}, {Transfer} and {Approval} events.\n', '  */\n', '  function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\n', '      require(recipient != address(0), "PoolToken/to-zero");\n', '      require(holder != address(0), "PoolToken/from-zero");\n', '\n', '      address spender = msg.sender;\n', '\n', '      _callTokensToSend(spender, holder, recipient, amount, "", "");\n', '\n', '      _move(spender, holder, recipient, amount, "", "");\n', '      _approve(holder, spender, _allowances[holder][spender].sub(amount, "PoolToken/exceed-allow"));\n', '\n', '      _callTokensReceived(spender, holder, recipient, amount, "", "", false);\n', '\n', '      return true;\n', '  }\n', '\n', '  /**\n', '   * Called by the associated Pool to emit `Mint` events.\n', '   * @param amount The amount that was minted\n', '   */\n', '  function poolMint(uint256 amount) external onlyPool {\n', "    _mintEvents(address(_pool), address(_pool), amount, '', '');\n", '  }\n', '\n', '  /**\n', '    * Emits {Minted} and {IERC20-Transfer} events.\n', '    */\n', '  function _mintEvents(\n', '      address operator,\n', '      address account,\n', '      uint256 amount,\n', '      bytes memory userData,\n', '      bytes memory operatorData\n', '  )\n', '  internal\n', '  {\n', '      emit Minted(operator, account, amount, userData, operatorData);\n', '      emit Transfer(address(0), account, amount);\n', '  }\n', '\n', '  /**\n', '    * @dev Send tokens\n', '    * @param operator address operator requesting the transfer\n', '    * @param from address token holder address\n', '    * @param to address recipient address\n', '    * @param amount uint256 amount of tokens to transfer\n', '    * @param userData bytes extra information provided by the token holder (if any)\n', '    * @param operatorData bytes extra information provided by the operator (if any)\n', '    */\n', '  function _send(\n', '      address operator,\n', '      address from,\n', '      address to,\n', '      uint256 amount,\n', '      bytes memory userData,\n', '      bytes memory operatorData\n', '  )\n', '      private\n', '  {\n', '      require(from != address(0), "PoolToken/from-zero");\n', '      require(to != address(0), "PoolToken/to-zero");\n', '\n', '      _callTokensToSend(operator, from, to, amount, userData, operatorData);\n', '\n', '      _move(operator, from, to, amount, userData, operatorData);\n', '\n', '      _callTokensReceived(operator, from, to, amount, userData, operatorData, false);\n', '  }\n', '\n', '  /**\n', '    * @dev Redeems tokens for the underlying asset.\n', '    * @param operator address operator requesting the operation\n', '    * @param from address token holder address\n', '    * @param amount uint256 amount of tokens to redeem\n', '    * @param data bytes extra information provided by the token holder\n', '    * @param operatorData bytes extra information provided by the operator (if any)\n', '    */\n', '  function _redeem(\n', '      address operator,\n', '      address from,\n', '      uint256 amount,\n', '      bytes memory data,\n', '      bytes memory operatorData\n', '  )\n', '      private\n', '  {\n', '      require(from != address(0), "PoolToken/from-zero");\n', '\n', '      _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n', '\n', '      _pool.withdrawCommittedDepositFrom(from, amount);\n', '\n', '      emit Redeemed(operator, from, amount, data, operatorData);\n', '      emit Transfer(from, address(0), amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Moves tokens from one user to another.  Emits Sent and Transfer events.\n', '   */\n', '  function _move(\n', '      address operator,\n', '      address from,\n', '      address to,\n', '      uint256 amount,\n', '      bytes memory userData,\n', '      bytes memory operatorData\n', '  )\n', '      private\n', '  {\n', '      _pool.moveCommitted(from, to, amount);\n', '\n', '      emit Sent(operator, from, to, amount, userData, operatorData);\n', '      emit Transfer(from, to, amount);\n', '  }\n', '\n', '  /**\n', '   * Approves of a token spend by a spender for a holder.\n', '   * @param holder The address from which the tokens are spent\n', '   * @param spender The address that is spending the tokens\n', '   * @param value The amount of tokens to spend\n', '   */\n', '  function _approve(address holder, address spender, uint256 value) private {\n', '      require(spender != address(0), "PoolToken/from-zero");\n', '\n', '      _allowances[holder][spender] = value;\n', '      emit Approval(holder, spender, value);\n', '  }\n', '\n', '  /**\n', '    * @dev Call from.tokensToSend() if the interface is registered\n', '    * @param operator address operator requesting the transfer\n', '    * @param from address token holder address\n', '    * @param to address recipient address\n', '    * @param amount uint256 amount of tokens to transfer\n', '    * @param userData bytes extra information provided by the token holder (if any)\n', '    * @param operatorData bytes extra information provided by the operator (if any)\n', '    */\n', '  function _callTokensToSend(\n', '      address operator,\n', '      address from,\n', '      address to,\n', '      uint256 amount,\n', '      bytes memory userData,\n', '      bytes memory operatorData\n', '  )\n', '      internal notLocked\n', '  {\n', '      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n', '      if (implementer != address(0)) {\n', '          IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n', '      }\n', '  }\n', '\n', '  /**\n', '    * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n', '    * tokensReceived() was not registered for the recipient\n', '    * @param operator address operator requesting the transfer\n', '    * @param from address token holder address\n', '    * @param to address recipient address\n', '    * @param amount uint256 amount of tokens to transfer\n', '    * @param userData bytes extra information provided by the token holder (if any)\n', '    * @param operatorData bytes extra information provided by the operator (if any)\n', '    * @param requireReceptionAck whether to require that, if the recipient is a contract, it has registered a IERC777Recipient\n', '    */\n', '  function _callTokensReceived(\n', '      address operator,\n', '      address from,\n', '      address to,\n', '      uint256 amount,\n', '      bytes memory userData,\n', '      bytes memory operatorData,\n', '      bool requireReceptionAck\n', '  )\n', '      private\n', '  {\n', '      address implementer = ERC1820_REGISTRY.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n', '      if (implementer != address(0)) {\n', '          IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n', '      } else if (requireReceptionAck) {\n', '          require(!to.isContract(), "PoolToken/no-recip-inter");\n', '      }\n', '  }\n', '\n', '  /**\n', '   * @notice Requires the sender to be the pool contract\n', '   */\n', '  modifier onlyPool() {\n', '    require(msg.sender == address(_pool), "PoolToken/only-pool");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Requires the contract to be unlocked\n', '   */\n', '  modifier notLocked() {\n', '    require(!_pool.isLocked(), "PoolToken/is-locked");\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title The Pool contract\n', ' * @author Brendan Asselstine\n', ' * @notice This contract allows users to pool deposits into Compound and win the accrued interest in periodic draws.\n', ' * Funds are immediately deposited and withdrawn from the Compound cToken contract.\n', ' * Draws go through three stages: open, committed and rewarded in that order.\n', " * Only one draw is ever in the open stage.  Users deposits are always added to the open draw.  Funds in the open Draw are that user's open balance.\n", " * When a Draw is committed, the funds in it are moved to a user's committed total and the total committed balance of all users is updated.\n", ' * When a Draw is rewarded, the gross winnings are the accrued interest since the last reward (if any).  A winner is selected with their chances being\n', ' * proportional to their committed balance vs the total committed balance of all users.\n', ' *\n', ' *\n', ' * With the above in mind, there is always an open draw and possibly a committed draw.  The progression is:\n', ' *\n', ' * Step 1: Draw 1 Open\n', ' * Step 2: Draw 2 Open | Draw 1 Committed\n', ' * Step 3: Draw 3 Open | Draw 2 Committed | Draw 1 Rewarded\n', ' * Step 4: Draw 4 Open | Draw 3 Committed | Draw 2 Rewarded\n', ' * Step 5: Draw 5 Open | Draw 4 Committed | Draw 3 Rewarded\n', ' * Step X: ...\n', ' */\n', 'contract BasePool is Initializable, ReentrancyGuard {\n', '  using DrawManager for DrawManager.State;\n', '  using SafeMath for uint256;\n', '  using Roles for Roles.Role;\n', '  using Blocklock for Blocklock.State;\n', '\n', '  bytes32 internal constant ROLLED_OVER_ENTROPY_MAGIC_NUMBER = bytes32(uint256(1));\n', '\n', '  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '\n', "  // We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n", '  // See https://github.com/ethereum/solidity/issues/4024.\n', '\n', '  // keccak256("PoolTogetherRewardListener")\n', '  bytes32 constant internal REWARD_LISTENER_INTERFACE_HASH =\n', '      0x68f03b0b1a978ee238a70b362091d993343460bc1a2830ab3f708936d9f564a4;\n', '\n', '  /**\n', '   * Emitted when a user deposits into the Pool.\n', '   * @param sender The purchaser of the tickets\n', '   * @param amount The size of the deposit\n', '   */\n', '  event Deposited(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when a user deposits into the Pool and the deposit is immediately committed\n', '   * @param sender The purchaser of the tickets\n', '   * @param amount The size of the deposit\n', '   */\n', '  event DepositedAndCommitted(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when Sponsors have deposited into the Pool\n', '   * @param sender The purchaser of the tickets\n', '   * @param amount The size of the deposit\n', '   */\n', '  event SponsorshipDeposited(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when an admin has been added to the Pool.\n', '   * @param admin The admin that was added\n', '   */\n', '  event AdminAdded(address indexed admin);\n', '\n', '  /**\n', '   * Emitted when an admin has been removed from the Pool.\n', '   * @param admin The admin that was removed\n', '   */\n', '  event AdminRemoved(address indexed admin);\n', '\n', '  /**\n', '   * Emitted when a user withdraws from the pool.\n', '   * @param sender The user that is withdrawing from the pool\n', '   * @param amount The amount that the user withdrew\n', '   */\n', '  event Withdrawn(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when a user withdraws their sponsorship and fees from the pool.\n', '   * @param sender The user that is withdrawing\n', '   * @param amount The amount they are withdrawing\n', '   */\n', '  event SponsorshipAndFeesWithdrawn(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when a user withdraws from their open deposit.\n', '   * @param sender The user that is withdrawing\n', '   * @param amount The amount they are withdrawing\n', '   */\n', '  event OpenDepositWithdrawn(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when a user withdraws from their committed deposit.\n', '   * @param sender The user that is withdrawing\n', '   * @param amount The amount they are withdrawing\n', '   */\n', '  event CommittedDepositWithdrawn(address indexed sender, uint256 amount);\n', '\n', '  /**\n', '   * Emitted when an address collects a fee\n', '   * @param sender The address collecting the fee\n', '   * @param amount The fee amount\n', '   * @param drawId The draw from which the fee was awarded\n', '   */\n', '  event FeeCollected(address indexed sender, uint256 amount, uint256 drawId);\n', '\n', '  /**\n', '   * Emitted when a new draw is opened for deposit.\n', '   * @param drawId The draw id\n', '   * @param feeBeneficiary The fee beneficiary for this draw\n', '   * @param secretHash The committed secret hash\n', '   * @param feeFraction The fee fraction of the winnings to be given to the beneficiary\n', '   */\n', '  event Opened(\n', '    uint256 indexed drawId,\n', '    address indexed feeBeneficiary,\n', '    bytes32 secretHash,\n', '    uint256 feeFraction\n', '  );\n', '\n', '  /**\n', '   * Emitted when a draw is committed.\n', '   * @param drawId The draw id\n', '   */\n', '  event Committed(\n', '    uint256 indexed drawId\n', '  );\n', '\n', '  /**\n', '   * Emitted when a draw is rewarded.\n', '   * @param drawId The draw id\n', '   * @param winner The address of the winner\n', '   * @param entropy The entropy used to select the winner\n', '   * @param winnings The net winnings given to the winner\n', '   * @param fee The fee being given to the draw beneficiary\n', '   */\n', '  event Rewarded(\n', '    uint256 indexed drawId,\n', '    address indexed winner,\n', '    bytes32 entropy,\n', '    uint256 winnings,\n', '    uint256 fee\n', '  );\n', '\n', '  /**\n', '   * Emitted when a RewardListener call fails\n', '   * @param drawId The draw id\n', '   * @param winner The address that one the draw\n', '   * @param impl The implementation address of the RewardListener\n', '   */\n', '  event RewardListenerFailed(\n', '    uint256 indexed drawId,\n', '    address indexed winner,\n', '    address indexed impl\n', '  );\n', '\n', '  /**\n', '   * Emitted when the fee fraction is changed.  Takes effect on the next draw.\n', '   * @param feeFraction The next fee fraction encoded as a fixed point 18 decimal\n', '   */\n', '  event NextFeeFractionChanged(uint256 feeFraction);\n', '\n', '  /**\n', '   * Emitted when the next fee beneficiary changes.  Takes effect on the next draw.\n', '   * @param feeBeneficiary The next fee beneficiary\n', '   */\n', '  event NextFeeBeneficiaryChanged(address indexed feeBeneficiary);\n', '\n', '  /**\n', '   * Emitted when an admin pauses the contract\n', '   */\n', '  event DepositsPaused(address indexed sender);\n', '\n', '  /**\n', '   * Emitted when an admin unpauses the contract\n', '   */\n', '  event DepositsUnpaused(address indexed sender);\n', '\n', '  /**\n', '   * Emitted when the draw is rolled over in the event that the secret is forgotten.\n', '   */\n', '  event RolledOver(uint256 indexed drawId);\n', '\n', '  struct Draw {\n', '    uint256 feeFraction; //fixed point 18\n', '    address feeBeneficiary;\n', '    uint256 openedBlock;\n', '    bytes32 secretHash;\n', '    bytes32 entropy;\n', '    address winner;\n', '    uint256 netWinnings;\n', '    uint256 fee;\n', '  }\n', '\n', '  /**\n', '   * The Compound cToken that this Pool is bound to.\n', '   */\n', '  ICErc20 public cToken;\n', '\n', '  /**\n', '   * The fee beneficiary to use for subsequent Draws.\n', '   */\n', '  address public nextFeeBeneficiary;\n', '\n', '  /**\n', '   * The fee fraction to use for subsequent Draws.\n', '   */\n', '  uint256 public nextFeeFraction;\n', '\n', '  /**\n', '   * The total of all balances\n', '   */\n', '  uint256 public accountedBalance;\n', '\n', '  /**\n', '   * The total deposits and winnings for each user.\n', '   */\n', '  mapping (address => uint256) internal balances;\n', '\n', '  /**\n', '   * A mapping of draw ids to Draw structures\n', '   */\n', '  mapping(uint256 => Draw) internal draws;\n', '\n', '  /**\n', "   * A structure that is used to manage the user's odds of winning.\n", '   */\n', '  DrawManager.State internal drawState;\n', '\n', '  /**\n', '   * A structure containing the administrators\n', '   */\n', '  Roles.Role internal admins;\n', '\n', '  /**\n', '   * Whether the contract is paused\n', '   */\n', '  bool public paused;\n', '\n', '  Blocklock.State internal blocklock;\n', '\n', '  PoolToken public poolToken;\n', '\n', '  /**\n', '   * @notice Initializes a new Pool contract.\n', '   * @param _owner The owner of the Pool.  They are able to change settings and are set as the owner of new lotteries.\n', '   * @param _cToken The Compound Finance MoneyMarket contract to supply and withdraw tokens.\n', '   * @param _feeFraction The fraction of the gross winnings that should be transferred to the owner as the fee.  Is a fixed point 18 number.\n', '   * @param _feeBeneficiary The address that will receive the fee fraction\n', '   */\n', '  function init (\n', '    address _owner,\n', '    address _cToken,\n', '    uint256 _feeFraction,\n', '    address _feeBeneficiary,\n', '    uint256 _lockDuration,\n', '    uint256 _cooldownDuration\n', '  ) public initializer {\n', '    require(_owner != address(0), "Pool/owner-zero");\n', '    require(_cToken != address(0), "Pool/ctoken-zero");\n', '    cToken = ICErc20(_cToken);\n', '    _addAdmin(_owner);\n', '    _setNextFeeFraction(_feeFraction);\n', '    _setNextFeeBeneficiary(_feeBeneficiary);\n', '    initBlocklock(_lockDuration, _cooldownDuration);\n', '  }\n', '\n', '  function setPoolToken(PoolToken _poolToken) external onlyAdmin {\n', '    require(address(poolToken) == address(0), "Pool/token-was-set");\n', '    require(address(_poolToken.pool()) == address(this), "Pool/token-mismatch");\n', '    poolToken = _poolToken;\n', '  }\n', '\n', '  function initBlocklock(uint256 _lockDuration, uint256 _cooldownDuration) internal {\n', '    blocklock.setLockDuration(_lockDuration);\n', '    blocklock.setCooldownDuration(_cooldownDuration);\n', '  }\n', '\n', '  /**\n', '   * @notice Opens a new Draw.\n', '   * @param _secretHash The secret hash to commit to the Draw.\n', '   */\n', '  function open(bytes32 _secretHash) internal {\n', '    drawState.openNextDraw();\n', '    draws[drawState.openDrawIndex] = Draw(\n', '      nextFeeFraction,\n', '      nextFeeBeneficiary,\n', '      block.number,\n', '      _secretHash,\n', '      bytes32(0),\n', '      address(0),\n', '      uint256(0),\n', '      uint256(0)\n', '    );\n', '    emit Opened(\n', '      drawState.openDrawIndex,\n', '      nextFeeBeneficiary,\n', '      _secretHash,\n', '      nextFeeFraction\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Emits the Committed event for the current open draw.\n', '   */\n', '  function emitCommitted() internal {\n', '    uint256 drawId = currentOpenDrawId();\n', '    emit Committed(drawId);\n', '    if (address(poolToken) != address(0)) {\n', '      poolToken.poolMint(openSupply());\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Commits the current open draw, if any, and opens the next draw using the passed hash.  Really this function is only called twice:\n', '   * the first after Pool contract creation and the second immediately after.\n', '   * Can only be called by an admin.\n', '   * May fire the Committed event, and always fires the Open event.\n', '   * @param nextSecretHash The secret hash to use to open a new Draw\n', '   */\n', '  function openNextDraw(bytes32 nextSecretHash) public onlyAdmin {\n', '    if (currentCommittedDrawId() > 0) {\n', '      require(currentCommittedDrawHasBeenRewarded(), "Pool/not-reward");\n', '    }\n', '    if (currentOpenDrawId() != 0) {\n', '      emitCommitted();\n', '    }\n', '    open(nextSecretHash);\n', '  }\n', '\n', '  /**\n', '   * @notice Ignores the current draw, and opens the next draw.\n', '   * @dev This function will be removed once the winner selection has been decentralized.\n', '   * @param nextSecretHash The hash to commit for the next draw\n', '   */\n', '  function rolloverAndOpenNextDraw(bytes32 nextSecretHash) public onlyAdmin {\n', '    rollover();\n', '    openNextDraw(nextSecretHash);\n', '  }\n', '\n', '  /**\n', '   * @notice Rewards the current committed draw using the passed secret, commits the current open draw, and opens the next draw using the passed secret hash.\n', '   * Can only be called by an admin.\n', '   * Fires the Rewarded event, the Committed event, and the Open event.\n', '   * @param nextSecretHash The secret hash to use to open a new Draw\n', '   * @param lastSecret The secret to reveal to reward the current committed Draw.\n', '   * @param _salt The salt that was used to conceal the secret\n', '   */\n', '  function rewardAndOpenNextDraw(bytes32 nextSecretHash, bytes32 lastSecret, bytes32 _salt) public onlyAdmin {\n', '    reward(lastSecret, _salt);\n', '    openNextDraw(nextSecretHash);\n', '  }\n', '\n', '  /**\n', '   * @notice Rewards the winner for the current committed Draw using the passed secret.\n', '   * The gross winnings are calculated by subtracting the accounted balance from the current underlying cToken balance.\n', '   * A winner is calculated using the revealed secret.\n', "   * If there is a winner (i.e. any eligible users) then winner's balance is updated with their net winnings.\n", "   * The draw beneficiary's balance is updated with the fee.\n", '   * The accounted balance is updated to include the fee and, if there was a winner, the net winnings.\n', '   * Fires the Rewarded event.\n', '   * @param _secret The secret to reveal for the current committed Draw\n', '   * @param _salt The salt that was used to conceal the secret\n', '   */\n', '  function reward(bytes32 _secret, bytes32 _salt) public onlyAdmin onlyLocked requireCommittedNoReward nonReentrant {\n', '    // require that there is a committed draw\n', '    // require that the committed draw has not been rewarded\n', '    uint256 drawId = currentCommittedDrawId();\n', '\n', '    Draw storage draw = draws[drawId];\n', '\n', '    require(draw.secretHash == keccak256(abi.encodePacked(_secret, _salt)), "Pool/bad-secret");\n', '\n', '    // derive entropy from the revealed secret\n', '    bytes32 entropy = keccak256(abi.encodePacked(_secret));\n', '\n', '    _reward(drawId, draw, entropy);\n', '  }\n', '\n', '  function _reward(uint256 drawId, Draw storage draw, bytes32 entropy) internal {\n', '    blocklock.unlock(block.number);\n', '    // Select the winner using the hash as entropy\n', '    address winningAddress = calculateWinner(entropy);\n', '\n', '    // Calculate the gross winnings\n', '    uint256 underlyingBalance = balance();\n', '\n', '    uint256 grossWinnings;\n', '\n', "    // It's possible when the APR is zero that the underlying balance will be slightly lower than the accountedBalance\n", '    // due to rounding errors in the Compound contract.\n', '    if (underlyingBalance > accountedBalance) {\n', '      grossWinnings = capWinnings(underlyingBalance.sub(accountedBalance));\n', '    }\n', '\n', '    // Calculate the beneficiary fee\n', '    uint256 fee = calculateFee(draw.feeFraction, grossWinnings);\n', '\n', '    // Update balance of the beneficiary\n', '    balances[draw.feeBeneficiary] = balances[draw.feeBeneficiary].add(fee);\n', '\n', '    // Calculate the net winnings\n', '    uint256 netWinnings = grossWinnings.sub(fee);\n', '\n', '    draw.winner = winningAddress;\n', '    draw.netWinnings = netWinnings;\n', '    draw.fee = fee;\n', '    draw.entropy = entropy;\n', '\n', '    // If there is a winner who is to receive non-zero winnings\n', '    if (winningAddress != address(0) && netWinnings != 0) {\n', '      // Updated the accounted total\n', '      accountedBalance = underlyingBalance;\n', '\n', '      // Update balance of the winner\n', '      balances[winningAddress] = balances[winningAddress].add(netWinnings);\n', '\n', '      // Enter their winnings into the open draw\n', '      drawState.deposit(winningAddress, netWinnings);\n', '\n', '      callRewarded(winningAddress, netWinnings, drawId);\n', '    } else {\n', '      // Only account for the fee\n', '      accountedBalance = accountedBalance.add(fee);\n', '    }\n', '\n', '    emit Rewarded(\n', '      drawId,\n', '      winningAddress,\n', '      entropy,\n', '      netWinnings,\n', '      fee\n', '    );\n', '    emit FeeCollected(draw.feeBeneficiary, fee, drawId);\n', '  }\n', '\n', '  /**\n', '   * @notice Calls the reward listener for the winner, if a listener exists.\n', '   * @dev Checks for a listener using the ERC1820 registry.  The listener is given a gas stipend of 200,000 to run the function.\n', "   * The number 200,000 was selected because it's safely above the gas requirements for PoolTogether [Pod](https://github.com/pooltogether/pods) contract.\n", '   *\n', '   * @param winner The winner.  If they have a listener registered in the ERC1820 registry it will be called.\n', '   * @param netWinnings The amount that was won.\n', '   * @param drawId The draw id that was won.\n', '   */\n', '  function callRewarded(address winner, uint256 netWinnings, uint256 drawId) internal {\n', '    address impl = ERC1820_REGISTRY.getInterfaceImplementer(winner, REWARD_LISTENER_INTERFACE_HASH);\n', '    if (impl != address(0)) {\n', '      (bool success,) = impl.call.gas(200000)(abi.encodeWithSignature("rewarded(address,uint256,uint256)", winner, netWinnings, drawId));\n', '      if (!success) {\n', '        emit RewardListenerFailed(drawId, winner, impl);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice A function that skips the reward for the committed draw id.\n', '   * @dev This function will be removed once the entropy is decentralized.\n', '   */\n', '  function rollover() public onlyAdmin requireCommittedNoReward {\n', '    uint256 drawId = currentCommittedDrawId();\n', '\n', '    Draw storage draw = draws[drawId];\n', '    draw.entropy = ROLLED_OVER_ENTROPY_MAGIC_NUMBER;\n', '\n', '    emit RolledOver(\n', '      drawId\n', '    );\n', '\n', '    emit Rewarded(\n', '      drawId,\n', '      address(0),\n', '      ROLLED_OVER_ENTROPY_MAGIC_NUMBER,\n', '      0,\n', '      0\n', '    );\n', '  }\n', '\n', '  /**\n', "   * @notice Ensures that the winnings don't overflow.  Note that we can make this integer max, because the fee\n", '   * is always less than zero (meaning the FixidityLib.multiply will always make the number smaller)\n', '   */\n', '  function capWinnings(uint256 _grossWinnings) internal pure returns (uint256) {\n', '    uint256 max = uint256(FixidityLib.maxNewFixed());\n', '    if (_grossWinnings > max) {\n', '      return max;\n', '    }\n', '    return _grossWinnings;\n', '  }\n', '\n', '  /**\n', '   * @notice Calculate the beneficiary fee using the passed fee fraction and gross winnings.\n', '   * @param _feeFraction The fee fraction, between 0 and 1, represented as a 18 point fixed number.\n', '   * @param _grossWinnings The gross winnings to take a fraction of.\n', '   */\n', '  function calculateFee(uint256 _feeFraction, uint256 _grossWinnings) internal pure returns (uint256) {\n', '    int256 grossWinningsFixed = FixidityLib.newFixed(int256(_grossWinnings));\n', '    // _feeFraction *must* be less than 1 ether, so it will never overflow\n', '    int256 feeFixed = FixidityLib.multiply(grossWinningsFixed, FixidityLib.newFixed(int256(_feeFraction), uint8(18)));\n', '    return uint256(FixidityLib.fromFixed(feeFixed));\n', '  }\n', '\n', '  /**\n', '   * @notice Allows a user to deposit a sponsorship amount.  The deposit is transferred into the cToken.\n', '   * Sponsorships allow a user to contribute to the pool without becoming eligible to win.  They can withdraw their sponsorship at any time.\n', '   * The deposit will immediately be added to Compound and the interest will contribute to the next draw.\n', '   * @param _amount The amount of the token underlying the cToken to deposit.\n', '   */\n', '  function depositSponsorship(uint256 _amount) public unlessDepositsPaused nonReentrant {\n', '    // Transfer the tokens into this contract\n', '    require(token().transferFrom(msg.sender, address(this), _amount), "Pool/t-fail");\n', '\n', '    // Deposit the sponsorship amount\n', '    _depositSponsorshipFrom(msg.sender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits the token balance for this contract as a sponsorship.\n', '   * If people erroneously transfer tokens to this contract, this function will allow us to recoup those tokens as sponsorship.\n', '   */\n', '  function transferBalanceToSponsorship() public unlessDepositsPaused {\n', '    // Deposit the sponsorship amount\n', '    _depositSponsorshipFrom(address(this), token().balanceOf(address(this)));\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits into the pool under the current open Draw.  The deposit is transferred into the cToken.\n', "   * Once the open draw is committed, the deposit will be added to the user's total committed balance and increase their chances of winning\n", '   * proportional to the total committed balance of all users.\n', '   * @param _amount The amount of the token underlying the cToken to deposit.\n', '   */\n', '  function depositPool(uint256 _amount) public requireOpenDraw unlessDepositsPaused nonReentrant notLocked {\n', '    // Transfer the tokens into this contract\n', '    require(token().transferFrom(msg.sender, address(this), _amount), "Pool/t-fail");\n', '\n', '    // Deposit the funds\n', '    _depositPoolFrom(msg.sender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits sponsorship for a user\n', '   * @param _spender The user who is sponsoring\n', '   * @param _amount The amount they are sponsoring\n', '   */\n', '  function _depositSponsorshipFrom(address _spender, uint256 _amount) internal {\n', '    // Deposit the funds\n', '    _depositFrom(_spender, _amount);\n', '\n', '    emit SponsorshipDeposited(_spender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits into the pool for a user.  The deposit will be open until the next draw is committed.\n', '   * @param _spender The user who is depositing\n', '   * @param _amount The amount the user is depositing\n', '   */\n', '  function _depositPoolFrom(address _spender, uint256 _amount) internal {\n', "    // Update the user's eligibility\n", '    drawState.deposit(_spender, _amount);\n', '\n', '    _depositFrom(_spender, _amount);\n', '\n', '    emit Deposited(_spender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits into the pool for a user.  The deposit is made part of the currently committed draw\n', '   * @param _spender The user who is depositing\n', '   * @param _amount The amount to deposit\n', '   */\n', '  function _depositPoolFromCommitted(address _spender, uint256 _amount) internal notLocked {\n', "    // Update the user's eligibility\n", '    drawState.depositCommitted(_spender, _amount);\n', '\n', '    _depositFrom(_spender, _amount);\n', '\n', '    emit DepositedAndCommitted(_spender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Deposits into the pool for a user.  Updates their balance and transfers their tokens into this contract.\n', '   * @param _spender The user who is depositing\n', '   * @param _amount The amount they are depositing\n', '   */\n', '  function _depositFrom(address _spender, uint256 _amount) internal {\n', "    // Update the user's balance\n", '    balances[_spender] = balances[_spender].add(_amount);\n', '\n', '    // Update the total of this contract\n', '    accountedBalance = accountedBalance.add(_amount);\n', '\n', '    // Deposit into Compound\n', '    require(token().approve(address(cToken), _amount), "Pool/approve");\n', '    require(cToken.mint(_amount) == 0, "Pool/supply");\n', '  }\n', '\n', '  /**\n', "   * Withdraws the given amount from the user's deposits.  It first withdraws from their sponsorship,\n", '   * then their open deposits, then their committed deposits.\n', '   *\n', '   * @param amount The amount to withdraw.\n', '   */\n', '  function withdraw(uint256 amount) public nonReentrant notLocked {\n', '    uint256 remainingAmount = amount;\n', '    // first sponsorship\n', '    uint256 sponsorshipAndFeesBalance = sponsorshipAndFeeBalanceOf(msg.sender);\n', '    if (sponsorshipAndFeesBalance < remainingAmount) {\n', '      withdrawSponsorshipAndFee(sponsorshipAndFeesBalance);\n', '      remainingAmount = remainingAmount.sub(sponsorshipAndFeesBalance);\n', '    } else {\n', '      withdrawSponsorshipAndFee(remainingAmount);\n', '      return;\n', '    }\n', '\n', '    // now pending\n', '    uint256 pendingBalance = drawState.openBalanceOf(msg.sender);\n', '    if (pendingBalance < remainingAmount) {\n', '      _withdrawOpenDeposit(msg.sender, pendingBalance);\n', '      remainingAmount = remainingAmount.sub(pendingBalance);\n', '    } else {\n', '      _withdrawOpenDeposit(msg.sender, remainingAmount);\n', '      return;\n', '    }\n', '\n', '    // now committed.  remainingAmount should not be greater than committed balance.\n', '    _withdrawCommittedDeposit(msg.sender, remainingAmount);\n', '  }\n', '\n', '  /**\n', "   * @notice Withdraw the sender's entire balance back to them.\n", '   */\n', '  function withdraw() public nonReentrant notLocked {\n', '    uint256 committedBalance = drawState.committedBalanceOf(msg.sender);\n', '\n', '    uint256 balance = balances[msg.sender];\n', '    // Update their chances of winning\n', '    drawState.withdraw(msg.sender);\n', '    _withdraw(msg.sender, balance);\n', '\n', '    if (address(poolToken) != address(0)) {\n', '      poolToken.poolRedeem(msg.sender, committedBalance);\n', '    }\n', '\n', '    emit Withdrawn(msg.sender, balance);\n', '  }\n', '\n', '  /**\n', "   * Withdraws only from the sender's sponsorship and fee balances\n", '   * @param _amount The amount to withdraw\n', '   */\n', '  function withdrawSponsorshipAndFee(uint256 _amount) public {\n', '    uint256 sponsorshipAndFees = sponsorshipAndFeeBalanceOf(msg.sender);\n', '    require(_amount <= sponsorshipAndFees, "Pool/exceeds-sfee");\n', '    _withdraw(msg.sender, _amount);\n', '\n', '    emit SponsorshipAndFeesWithdrawn(msg.sender, _amount);\n', '  }\n', '\n', '  /**\n', "   * Returns the total balance of the user's sponsorship and fees\n", '   * @param _sender The user whose balance should be returned\n', '   */\n', '  function sponsorshipAndFeeBalanceOf(address _sender) public view returns (uint256) {\n', '    return balances[_sender].sub(drawState.balanceOf(_sender));\n', '  }\n', '\n', '  /**\n', "   * Withdraws from the user's open deposits\n", '   * @param _amount The amount to withdraw\n', '   */\n', '  function withdrawOpenDeposit(uint256 _amount) public nonReentrant notLocked {\n', '    _withdrawOpenDeposit(msg.sender, _amount);\n', '  }\n', '\n', '  function _withdrawOpenDeposit(address sender, uint256 _amount) internal {\n', '    drawState.withdrawOpen(sender, _amount);\n', '    _withdraw(sender, _amount);\n', '\n', '    emit OpenDepositWithdrawn(sender, _amount);\n', '  }\n', '\n', '  /**\n', "   * Withdraws from the user's committed deposits\n", '   * @param _amount The amount to withdraw\n', '   */\n', '  function withdrawCommittedDeposit(uint256 _amount) public nonReentrant notLocked returns (bool)  {\n', '    _withdrawCommittedDeposit(msg.sender, _amount);\n', '    return true;\n', '  }\n', '\n', '  function _withdrawCommittedDeposit(address sender, uint256 _amount) internal {\n', '    _withdrawCommittedDepositAndEmit(sender, _amount);\n', '    if (address(poolToken) != address(0)) {\n', '      poolToken.poolRedeem(sender, _amount);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Allows the associated PoolToken to withdraw for a user; useful when redeeming through the token.\n', '   * @param _from The user to withdraw from\n', '   * @param _amount The amount to withdraw\n', '   */\n', '  function withdrawCommittedDepositFrom(\n', '    address _from,\n', '    uint256 _amount\n', '  ) external onlyToken notLocked returns (bool)  {\n', '    return _withdrawCommittedDepositAndEmit(_from, _amount);\n', '  }\n', '\n', '  /**\n', '   * A function that withdraws committed deposits for a user and emits the corresponding events.\n', '   * @param _from User to withdraw for\n', '   * @param _amount The amount to withdraw\n', '   */\n', '  function _withdrawCommittedDepositAndEmit(address _from, uint256 _amount) internal returns (bool) {\n', '    drawState.withdrawCommitted(_from, _amount);\n', '    _withdraw(_from, _amount);\n', '\n', '    emit CommittedDepositWithdrawn(_from, _amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Allows the associated PoolToken to move committed tokens from one user to another.\n', '   * @param _from The account to move tokens from\n', '   * @param _to The account that is receiving the tokens\n', '   * @param _amount The amount of tokens to transfer\n', '   */\n', '  function moveCommitted(\n', '    address _from,\n', '    address _to,\n', '    uint256 _amount\n', '  ) external onlyToken onlyCommittedBalanceGteq(_from, _amount) notLocked returns (bool) {\n', '    balances[_from] = balances[_from].sub(_amount, "move could not sub amount");\n', '    balances[_to] = balances[_to].add(_amount);\n', '    drawState.withdrawCommitted(_from, _amount);\n', '    drawState.depositCommitted(_to, _amount);\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers tokens from the cToken contract to the sender.  Updates the accounted balance.\n', '   */\n', '  function _withdraw(address _sender, uint256 _amount) internal {\n', '    uint256 balance = balances[_sender];\n', '\n', '    require(_amount <= balance, "Pool/no-funds");\n', '\n', "    // Update the user's balance\n", '    balances[_sender] = balance.sub(_amount);\n', '\n', '    // Update the total of this contract\n', '    accountedBalance = accountedBalance.sub(_amount);\n', '\n', '    // Withdraw from Compound and transfer\n', '    require(cToken.redeemUnderlying(_amount) == 0, "Pool/redeem");\n', '    require(token().transfer(_sender, _amount), "Pool/transfer");\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the id of the current open Draw.\n', '   * @return The current open Draw id\n', '   */\n', '  function currentOpenDrawId() public view returns (uint256) {\n', '    return drawState.openDrawIndex;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the id of the current committed Draw.\n', '   * @return The current committed Draw id\n', '   */\n', '  function currentCommittedDrawId() public view returns (uint256) {\n', '    if (drawState.openDrawIndex > 1) {\n', '      return drawState.openDrawIndex - 1;\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Returns whether the current committed draw has been rewarded\n', '   * @return True if the current committed draw has been rewarded, false otherwise\n', '   */\n', '  function currentCommittedDrawHasBeenRewarded() internal view returns (bool) {\n', '    Draw storage draw = draws[currentCommittedDrawId()];\n', '    return draw.entropy != bytes32(0);\n', '  }\n', '\n', '  /**\n', '   * @notice Gets information for a given draw.\n', '   * @param _drawId The id of the Draw to retrieve info for.\n', '   * @return Fields including:\n', '   *  feeFraction: the fee fraction\n', '   *  feeBeneficiary: the beneficiary of the fee\n', '   *  openedBlock: The block at which the draw was opened\n', '   *  secretHash: The hash of the secret committed to this draw.\n', '   *  entropy: the entropy used to select the winner\n', '   *  winner: the address of the winner\n', '   *  netWinnings: the total winnings less the fee\n', '   *  fee: the fee taken by the beneficiary\n', '   */\n', '  function getDraw(uint256 _drawId) public view returns (\n', '    uint256 feeFraction,\n', '    address feeBeneficiary,\n', '    uint256 openedBlock,\n', '    bytes32 secretHash,\n', '    bytes32 entropy,\n', '    address winner,\n', '    uint256 netWinnings,\n', '    uint256 fee\n', '  ) {\n', '    Draw storage draw = draws[_drawId];\n', '    feeFraction = draw.feeFraction;\n', '    feeBeneficiary = draw.feeBeneficiary;\n', '    openedBlock = draw.openedBlock;\n', '    secretHash = draw.secretHash;\n', '    entropy = draw.entropy;\n', '    winner = draw.winner;\n', '    netWinnings = draw.netWinnings;\n', '    fee = draw.fee;\n', '  }\n', '\n', '  /**\n', "   * @notice Returns the total of the address's balance in committed Draws.  That is, the total that contributes to their chances of winning.\n", '   * @param _addr The address of the user\n', '   * @return The total committed balance for the user\n', '   */\n', '  function committedBalanceOf(address _addr) external view returns (uint256) {\n', '    return drawState.committedBalanceOf(_addr);\n', '  }\n', '\n', '  /**\n', "   * @notice Returns the total of the address's balance in the open Draw.  That is, the total that will *eventually* contribute to their chances of winning.\n", '   * @param _addr The address of the user\n', '   * @return The total open balance for the user\n', '   */\n', '  function openBalanceOf(address _addr) external view returns (uint256) {\n', '    return drawState.openBalanceOf(_addr);\n', '  }\n', '\n', '  /**\n', "   * @notice Returns a user's total balance.  This includes their sponsorships, fees, open deposits, and committed deposits.\n", '   * @param _addr The address of the user to check.\n', "   * @return The user's current balance.\n", '   */\n', '  function totalBalanceOf(address _addr) external view returns (uint256) {\n', '    return balances[_addr];\n', '  }\n', '\n', '  /**\n', "   * @notice Returns a user's committed balance.  This is the balance of their Pool tokens.\n", '   * @param _addr The address of the user to check.\n', "   * @return The user's current balance.\n", '   */\n', '  function balanceOf(address _addr) external view returns (uint256) {\n', '    return drawState.committedBalanceOf(_addr);\n', '  }\n', '\n', '  /**\n', '   * @notice Calculates a winner using the passed entropy for the current committed balances.\n', '   * @param _entropy The entropy to use to select the winner\n', '   * @return The winning address\n', '   */\n', '  function calculateWinner(bytes32 _entropy) public view returns (address) {\n', '    return drawState.drawWithEntropy(_entropy);\n', '  }\n', '\n', '  /**\n', "   * @notice Returns the total committed balance.  Used to compute an address's chances of winning.\n", '   * @return The total committed balance.\n', '   */\n', '  function committedSupply() public view returns (uint256) {\n', '    return drawState.committedSupply();\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the total open balance.  This balance is the number of tickets purchased for the open draw.\n', '   * @return The total open balance\n', '   */\n', '  function openSupply() public view returns (uint256) {\n', '    return drawState.openSupply();\n', '  }\n', '\n', '  /**\n', '   * @notice Calculates the total estimated interest earned for the given number of blocks\n', '   * @param _blocks The number of block that interest accrued for\n', '   * @return The total estimated interest as a 18 point fixed decimal.\n', '   */\n', '  function estimatedInterestRate(uint256 _blocks) public view returns (uint256) {\n', '    return supplyRatePerBlock().mul(_blocks);\n', '  }\n', '\n', '  /**\n', '   * @notice Convenience function to return the supplyRatePerBlock value from the money market contract.\n', '   * @return The cToken supply rate per block\n', '   */\n', '  function supplyRatePerBlock() public view returns (uint256) {\n', '    return cToken.supplyRatePerBlock();\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the beneficiary fee fraction for subsequent Draws.\n', '   * Fires the NextFeeFractionChanged event.\n', '   * Can only be called by an admin.\n', '   * @param _feeFraction The fee fraction to use.\n', '   * Must be between 0 and 1 and formatted as a fixed point number with 18 decimals (as in Ether).\n', '   */\n', '  function setNextFeeFraction(uint256 _feeFraction) public onlyAdmin {\n', '    _setNextFeeFraction(_feeFraction);\n', '  }\n', '\n', '  function _setNextFeeFraction(uint256 _feeFraction) internal {\n', '    require(_feeFraction <= 1 ether, "Pool/less-1");\n', '    nextFeeFraction = _feeFraction;\n', '\n', '    emit NextFeeFractionChanged(_feeFraction);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the fee beneficiary for subsequent Draws.\n', '   * Can only be called by admins.\n', '   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\n', '   */\n', '  function setNextFeeBeneficiary(address _feeBeneficiary) public onlyAdmin {\n', '    _setNextFeeBeneficiary(_feeBeneficiary);\n', '  }\n', '\n', '  /**\n', '   * @notice Sets the fee beneficiary for subsequent Draws.\n', '   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\n', '   */\n', '  function _setNextFeeBeneficiary(address _feeBeneficiary) internal {\n', '    require(_feeBeneficiary != address(0), "Pool/not-zero");\n', '    nextFeeBeneficiary = _feeBeneficiary;\n', '\n', '    emit NextFeeBeneficiaryChanged(_feeBeneficiary);\n', '  }\n', '\n', '  /**\n', '   * @notice Adds an administrator.\n', '   * Can only be called by administrators.\n', '   * Fires the AdminAdded event.\n', '   * @param _admin The address of the admin to add\n', '   */\n', '  function addAdmin(address _admin) public onlyAdmin {\n', '    _addAdmin(_admin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether a given address is an administrator.\n', '   * @param _admin The address to check\n', '   * @return True if the address is an admin, false otherwise.\n', '   */\n', '  function isAdmin(address _admin) public view returns (bool) {\n', '    return admins.has(_admin);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether a given address is an administrator.\n', '   * @param _admin The address to check\n', '   * @return True if the address is an admin, false otherwise.\n', '   */\n', '  function _addAdmin(address _admin) internal {\n', '    admins.add(_admin);\n', '\n', '    emit AdminAdded(_admin);\n', '  }\n', '\n', '  /**\n', '   * @notice Removes an administrator\n', '   * Can only be called by an admin.\n', '   * Admins cannot remove themselves.  This ensures there is always one admin.\n', '   * @param _admin The address of the admin to remove\n', '   */\n', '  function removeAdmin(address _admin) public onlyAdmin {\n', '    require(admins.has(_admin), "Pool/no-admin");\n', '    require(_admin != msg.sender, "Pool/remove-self");\n', '    admins.remove(_admin);\n', '\n', '    emit AdminRemoved(_admin);\n', '  }\n', '\n', '  /**\n', '   * Requires that there is a committed draw that has not been rewarded.\n', '   */\n', '  modifier requireCommittedNoReward() {\n', '    require(currentCommittedDrawId() > 0, "Pool/committed");\n', '    require(!currentCommittedDrawHasBeenRewarded(), "Pool/already");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the token underlying the cToken.\n', '   * @return An ERC20 token address\n', '   */\n', '  function token() public view returns (IERC20) {\n', '    return IERC20(cToken.underlying());\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the underlying balance of this contract in the cToken.\n', '   * @return The cToken underlying balance for this contract.\n', '   */\n', '  function balance() public returns (uint256) {\n', '    return cToken.balanceOfUnderlying(address(this));\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the movement of tokens (essentially the committed deposits and winnings)\n', '   * @dev The lock only lasts for a duration of blocks.  The lock cannot be relocked until the cooldown duration completes.\n', '   */\n', '  function lockTokens() public onlyAdmin {\n', '    blocklock.lock(block.number);\n', '  }\n', '\n', '  /**\n', '   * @notice Unlocks the movement of tokens (essentially the committed deposits)\n', '   */\n', '  function unlockTokens() public onlyAdmin {\n', '    blocklock.unlock(block.number);\n', '  }\n', '\n', '  /**\n', '   * Pauses all deposits into the contract.  This was added so that we can slowly deprecate Pools.  Users can continue\n', '   * to collect rewards and withdraw, but eventually the Pool will grow smaller.\n', '   *\n', '   * emits DepositsPaused\n', '   */\n', '  function pauseDeposits() public unlessDepositsPaused onlyAdmin {\n', '    paused = true;\n', '\n', '    emit DepositsPaused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Unpauses all deposits into the contract\n', '   *\n', '   * emits DepositsUnpaused\n', '   */\n', '  function unpauseDeposits() public whenDepositsPaused onlyAdmin {\n', '    paused = false;\n', '\n', '    emit DepositsUnpaused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice Check if the contract is locked.\n', '   * @return True if the contract is locked, false otherwise\n', '   */\n', '  function isLocked() public view returns (bool) {\n', '    return blocklock.isLocked(block.number);\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the block number at which the lock expires\n', '   * @return The block number at which the lock expires\n', '   */\n', '  function lockEndAt() public view returns (uint256) {\n', '    return blocklock.lockEndAt();\n', '  }\n', '\n', '  /**\n', '   * @notice Check cooldown end block\n', '   * @return The block number at which the cooldown ends and the contract can be re-locked\n', '   */\n', '  function cooldownEndAt() public view returns (uint256) {\n', '    return blocklock.cooldownEndAt();\n', '  }\n', '\n', '  /**\n', '   * @notice Returns whether the contract can be locked\n', '   * @return True if the contract can be locked, false otherwise\n', '   */\n', '  function canLock() public view returns (bool) {\n', '    return blocklock.canLock(block.number);\n', '  }\n', '\n', '  /**\n', '   * @notice Duration of the lock\n', '   * @return Returns the duration of the lock in blocks.\n', '   */\n', '  function lockDuration() public view returns (uint256) {\n', '    return blocklock.lockDuration;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the cooldown duration.  The cooldown period starts after the Pool has been unlocked.\n', '   * The Pool cannot be locked during the cooldown period.\n', '   * @return The cooldown duration in blocks\n', '   */\n', '  function cooldownDuration() public view returns (uint256) {\n', '    return blocklock.cooldownDuration;\n', '  }\n', '\n', '  /**\n', '   * @notice requires the pool not to be locked\n', '   */\n', '  modifier notLocked() {\n', '    require(!blocklock.isLocked(block.number), "Pool/locked");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice requires the pool to be locked\n', '   */\n', '  modifier onlyLocked() {\n', '    require(blocklock.isLocked(block.number), "Pool/unlocked");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice requires the caller to be an admin\n', '   */\n', '  modifier onlyAdmin() {\n', '    require(admins.has(msg.sender), "Pool/admin");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Requires an open draw to exist\n', '   */\n', '  modifier requireOpenDraw() {\n', '    require(currentOpenDrawId() != 0, "Pool/no-open");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Requires deposits to be paused\n', '   */\n', '  modifier whenDepositsPaused() {\n', '    require(paused, "Pool/d-not-paused");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Requires deposits not to be paused\n', '   */\n', '  modifier unlessDepositsPaused() {\n', '    require(!paused, "Pool/d-paused");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @notice Requires the caller to be the pool token\n', '   */\n', '  modifier onlyToken() {\n', '    require(msg.sender == address(poolToken), "Pool/only-token");\n', '    _;\n', '  }\n', '\n', '  /**\n', "   * @notice requires the passed user's committed balance to be greater than or equal to the passed amount\n", '   * @param _from The user whose committed balance should be checked\n', '   * @param _amount The minimum amount they must have\n', '   */\n', '  modifier onlyCommittedBalanceGteq(address _from, uint256 _amount) {\n', '    uint256 committedBalance = drawState.committedBalanceOf(_from);\n', '    require(_amount <= committedBalance, "not enough funds");\n', '    _;\n', '  }\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract ScdMcdMigration {\n', '    SaiTubLike                  public tub;\n', '    VatLike                     public vat;\n', '    ManagerLike                 public cdpManager;\n', '    JoinLike                    public saiJoin;\n', '    JoinLike                    public wethJoin;\n', '    JoinLike                    public daiJoin;\n', '\n', '    constructor(\n', '        address tub_,           // SCD tub contract address\n', '        address cdpManager_,    // MCD manager contract address\n', '        address saiJoin_,       // MCD SAI collateral adapter contract address\n', '        address wethJoin_,      // MCD ETH collateral adapter contract address\n', '        address daiJoin_        // MCD DAI adapter contract address\n', '    ) public {\n', '        tub = SaiTubLike(tub_);\n', '        cdpManager = ManagerLike(cdpManager_);\n', '        vat = VatLike(cdpManager.vat());\n', '        saiJoin = JoinLike(saiJoin_);\n', '        wethJoin = JoinLike(wethJoin_);\n', '        daiJoin = JoinLike(daiJoin_);\n', '\n', '        require(wethJoin.gem() == tub.gem(), "non-matching-weth");\n', '        require(saiJoin.gem() == tub.sai(), "non-matching-sai");\n', '\n', '        tub.gov().approve(address(tub), uint(-1));\n', '        tub.skr().approve(address(tub), uint(-1));\n', '        tub.sai().approve(address(tub), uint(-1));\n', '        tub.sai().approve(address(saiJoin), uint(-1));\n', '        wethJoin.gem().approve(address(wethJoin), uint(-1));\n', '        daiJoin.dai().approve(address(daiJoin), uint(-1));\n', '        vat.hope(address(daiJoin));\n', '    }\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "add-overflow");\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "sub-underflow");\n', '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "mul-overflow");\n', '    }\n', '\n', '    function toInt(uint x) internal pure returns (int y) {\n', '        y = int(x);\n', '        require(y >= 0, "int-overflow");\n', '    }\n', '\n', '    // Function to swap SAI to DAI\n', '    // This function is to be used by users that want to get new DAI in exchange of old one (aka SAI)\n', '    // wad amount has to be <= the value pending to reach the debt ceiling (the minimum between general and ilk one)\n', '    function swapSaiToDai(\n', '        uint wad\n', '    ) external {\n', "        // Get wad amount of SAI from user's wallet:\n", '        saiJoin.gem().transferFrom(msg.sender, address(this), wad);\n', '        // Join the SAI wad amount to the `vat`:\n', '        saiJoin.join(address(this), wad);\n', '        // Lock the SAI wad amount to the CDP and generate the same wad amount of DAI\n', '        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), toInt(wad), toInt(wad));\n', "        // Send DAI wad amount as a ERC20 token to the user's wallet\n", '        daiJoin.exit(msg.sender, wad);\n', '    }\n', '\n', '    // Function to swap DAI to SAI\n', '    // This function is to be used by users that want to get SAI in exchange of DAI\n', '    // wad amount has to be <= the amount of SAI locked (and DAI generated) in the migration contract SAI CDP\n', '    function swapDaiToSai(\n', '        uint wad\n', '    ) external {\n', "        // Get wad amount of DAI from user's wallet:\n", '        daiJoin.dai().transferFrom(msg.sender, address(this), wad);\n', '        // Join the DAI wad amount to the vat:\n', '        daiJoin.join(address(this), wad);\n', '        // Payback the DAI wad amount and unlocks the same value of SAI collateral\n', '        vat.frob(saiJoin.ilk(), address(this), address(this), address(this), -toInt(wad), -toInt(wad));\n', "        // Send SAI wad amount as a ERC20 token to the user's wallet\n", '        saiJoin.exit(msg.sender, wad);\n', '    }\n', '\n', '    // Function to migrate a SCD CDP to MCD one (needs to be used via a proxy so the code can be kept simpler). Check MigrationProxyActions.sol code for usage.\n', '    // In order to use migrate function, SCD CDP debtAmt needs to be <= SAI previously deposited in the SAI CDP * (100% - Collateralization Ratio)\n', '    function migrate(\n', '        bytes32 cup\n', '    ) external returns (uint cdp) {\n', '        // Get values\n', '        uint debtAmt = tub.tab(cup);    // CDP SAI debt\n', '        uint pethAmt = tub.ink(cup);    // CDP locked collateral\n', '        uint ethAmt = tub.bid(pethAmt); // CDP locked collateral equiv in ETH\n', '\n', '        // Take SAI out from MCD SAI CDP. For this operation is necessary to have a very low collateralization ratio\n', '        // This is not actually a problem as this ilk will only be accessed by this migration contract,\n', '        // which will make sure to have the amounts balanced out at the end of the execution.\n', '        vat.frob(\n', '            bytes32(saiJoin.ilk()),\n', '            address(this),\n', '            address(this),\n', '            address(this),\n', '            -toInt(debtAmt),\n', '            0\n', '        );\n', '        saiJoin.exit(address(this), debtAmt); // SAI is exited as a token\n', '\n', '        // Shut SAI CDP and gets WETH back\n', '        tub.shut(cup);      // CDP is closed using the SAI just exited and the MKR previously sent by the user (via the proxy call)\n', '        tub.exit(pethAmt);  // Converts PETH to WETH\n', '\n', "        // Open future user's CDP in MCD\n", '        cdp = cdpManager.open(wethJoin.ilk(), address(this));\n', '\n', '        // Join WETH to Adapter\n', '        wethJoin.join(cdpManager.urns(cdp), ethAmt);\n', '\n', "        // Lock WETH in future user's CDP and generate debt to compensate the SAI used to paid the SCD CDP\n", '        (, uint rate,,,) = vat.ilks(wethJoin.ilk());\n', '        cdpManager.frob(\n', '            cdp,\n', '            toInt(ethAmt),\n', '            toInt(mul(debtAmt, 10 ** 27) / rate + 1) // To avoid rounding issues we add an extra wei of debt\n', '        );\n', '        // Move DAI generated to migration contract (to recover the used funds)\n', '        cdpManager.move(cdp, address(this), mul(debtAmt, 10 ** 27));\n', "        // Re-balance MCD SAI migration contract's CDP\n", '        vat.frob(\n', '            bytes32(saiJoin.ilk()),\n', '            address(this),\n', '            address(this),\n', '            address(this),\n', '            0,\n', '            -toInt(debtAmt)\n', '        );\n', '\n', '        // Set ownership of CDP to the user\n', '        cdpManager.give(cdp, msg.sender);\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n', ' *\n', ' * Accounts can be notified of {IERC777} tokens being sent to them by having a\n', ' * contract implement this interface (contract holders can be their own\n', ' * implementer) and registering it on the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n', ' *\n', ' * See {IERC1820Registry} and {ERC1820Implementer}.\n', ' */\n', 'interface IERC777Recipient {\n', '    /**\n', '     * @dev Called by an {IERC777} token contract whenever tokens are being\n', '     * moved or created into a registered account (`to`). The type of operation\n', '     * is conveyed by `from` being the zero address or not.\n', '     *\n', "     * This call occurs _after_ the token contract's state is updated, so\n", '     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n', '     *\n', '     * This function may revert to prevent the operation from being executed.\n', '     */\n', '    function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes calldata userData,\n', '        bytes calldata operatorData\n', '    ) external;\n', '}\n', '\n', '\n', '/**\n', ' * @title MCDAwarePool\n', ' * @author Brendan Asselstine [email\xa0protected]\n', ' * @notice This contract is a Pool that is aware of the new Multi-Collateral Dai.  It uses the ERC777Recipient interface to\n', " * detect if it's being transferred tickets from the old single collateral Dai (Sai) Pool.  If it is, it migrates the Sai to Dai\n", ' * and immediately deposits the new Dai as committed tickets for that user.  We are knowingly bypassing the committed period for\n', ' * users to encourage them to migrate to the MCD Pool.\n', ' */\n', 'contract MCDAwarePool is BasePool, IERC777Recipient {\n', '  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '\n', '  // keccak256("ERC777TokensRecipient")\n', '  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH =\n', '      0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n', '\n', '  uint256 internal constant DEFAULT_LOCK_DURATION = 40;\n', '  uint256 internal constant DEFAULT_COOLDOWN_DURATION = 80;\n', '\n', '  /**\n', '   * @notice The address of the ScdMcdMigration contract (see https://github.com/makerdao/developerguides/blob/master/mcd/upgrading-to-multi-collateral-dai/upgrading-to-multi-collateral-dai.md#direct-integration-with-smart-contracts)\n', '   */\n', '  ScdMcdMigration public scdMcdMigration;\n', '\n', '  /**\n', '   * @notice The address of the Sai Pool contract\n', '   */\n', '  MCDAwarePool public saiPool;\n', '\n', '  /**\n', '   * @notice Initializes the contract.\n', '   * @param _owner The initial administrator of the contract\n', '   * @param _cToken The Compound cToken to bind this Pool to\n', '   * @param _feeFraction The fraction of the winnings to give to the beneficiary\n', '   * @param _feeBeneficiary The beneficiary who receives the fee\n', '   */\n', '  function init (\n', '    address _owner,\n', '    address _cToken,\n', '    uint256 _feeFraction,\n', '    address _feeBeneficiary,\n', '    uint256 lockDuration,\n', '    uint256 cooldownDuration\n', '  ) public initializer {\n', '    super.init(\n', '      _owner,\n', '      _cToken,\n', '      _feeFraction,\n', '      _feeBeneficiary,\n', '      lockDuration,\n', '      cooldownDuration\n', '    );\n', '    initRegistry();\n', '    initBlocklock(lockDuration, cooldownDuration);\n', '  }\n', '\n', '  /**\n', '   * @notice Used to initialize the BasePool contract after an upgrade.  Registers the MCDAwarePool with the ERC1820 registry so that it can receive tokens, and inits the block lock.\n', '   */\n', '  function initMCDAwarePool(uint256 lockDuration, uint256 cooldownDuration) public {\n', '    initRegistry();\n', '    if (blocklock.lockDuration == 0) {\n', '      initBlocklock(lockDuration, cooldownDuration);\n', '    }\n', '  }\n', '\n', '  function initRegistry() internal {\n', '    ERC1820_REGISTRY.setInterfaceImplementer(address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n', '  }\n', '\n', '  function initMigration(ScdMcdMigration _scdMcdMigration, MCDAwarePool _saiPool) public onlyAdmin {\n', '    _initMigration(_scdMcdMigration, _saiPool);\n', '  }\n', '\n', '  function _initMigration(ScdMcdMigration _scdMcdMigration, MCDAwarePool _saiPool) internal {\n', '    require(address(scdMcdMigration) == address(0), "Pool/init");\n', '    require(address(_scdMcdMigration) != address(0), "Pool/mig-def");\n', '    scdMcdMigration = _scdMcdMigration;\n', '    saiPool = _saiPool; // may be null\n', '  }\n', '\n', '  /**\n', '   * @notice Called by an ERC777 token when tokens are sent, transferred, or minted.  If the sender is the original Sai Pool\n', '   * and this pool is bound to the Dai token then it will accept the transfer, migrate the tokens, and deposit on behalf of\n', '   * the sender.  It will reject all other tokens.\n', '   *\n', '   * If there is a committed draw this function will mint the user tickets immediately, otherwise it will place them in the\n', '   * open prize.  This is to encourage migration.\n', '   *\n', '   * @param from The sender\n', '   * @param amount The amount they are transferring\n', '   */\n', '  function tokensReceived(\n', '    address, // operator\n', '    address from,\n', "    address, // to address can't be anything but us because we don't implement ERC1820ImplementerInterface\n", '    uint256 amount,\n', '    bytes calldata,\n', '    bytes calldata\n', '  ) external unlessDepositsPaused {\n', '    require(msg.sender == address(saiPoolToken()), "Pool/sai-only");\n', '    require(address(token()) == address(daiToken()), "Pool/not-dai");\n', '\n', '    // cash out of the Pool.  This call transfers sai to this contract\n', "    saiPoolToken().redeem(amount, '');\n", '\n', '    // approve of the transfer to the migration contract\n', '    saiToken().approve(address(scdMcdMigration), amount);\n', '\n', '    // migrate the sai to dai.  The contract now has dai\n', '    scdMcdMigration.swapSaiToDai(amount);\n', '\n', '    if (currentCommittedDrawId() > 0) {\n', '      // now deposit the dai as tickets\n', '      _depositPoolFromCommitted(from, amount);\n', '    } else {\n', '      _depositPoolFrom(from, amount);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address of the PoolSai pool token contract\n', '   * @return The address of the Sai PoolToken contract\n', '   */\n', '  function saiPoolToken() internal view returns (PoolToken) {\n', '    if (address(saiPool) != address(0)) {\n', '      return saiPool.poolToken();\n', '    } else {\n', '      return PoolToken(0);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address of the Sai token\n', '   * @return The address of the sai token\n', '   */\n', '  function saiToken() public returns (GemLike) {\n', '    return scdMcdMigration.saiJoin().gem();\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address of the Dai token\n', '   * @return The address of the Dai token.\n', '   */\n', '  function daiToken() public returns (GemLike) {\n', '    return scdMcdMigration.daiJoin().dai();\n', '  }\n', '}\n', '\n', '/**\n', 'Copyright 2020 PoolTogether Inc.\n', '\n', 'This file is part of PoolTogether.\n', '\n', 'PoolTogether is free software: you can redistribute it and/or modify\n', 'it under the terms of the GNU General Public License as published by\n', 'the Free Software Foundation under version 3 of the License.\n', '\n', 'PoolTogether is distributed in the hope that it will be useful,\n', 'but WITHOUT ANY WARRANTY; without even the implied warranty of\n', 'MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', 'GNU General Public License for more details.\n', '\n', 'You should have received a copy of the GNU General Public License\n', 'along with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', 'interface IComptroller {\n', '  function claimComp(address holder, ICErc20[] calldata cTokens) external;\n', '}\n', '\n', '\n', 'contract AutonomousPool is MCDAwarePool {\n', '\n', '  event PrizePeriodSecondsUpdated(uint256 prizePeriodSeconds);\n', '\n', '  event ComptrollerUpdated(IComptroller comptroller);\n', '\n', '  event CompRecipientUpdated(address compRecipient);\n', '\n', '  event AwardStarted();\n', '\n', '  event AwardCompleted();\n', '\n', '  uint256 public lastAwardTimestamp;\n', '  uint256 public prizePeriodSeconds;\n', '  IComptroller public comptroller;\n', '  IERC20 public comp;\n', '  address public compRecipient;\n', '\n', '  event TransferredComp(\n', '    address indexed recipient,\n', '    uint256 amount\n', '  );\n', '\n', '  function initializeAutonomousPool(\n', '    uint256 _prizePeriodSeconds,\n', '    IERC20 _comp,\n', '    IComptroller _comptroller\n', '  ) external {\n', '    require(address(comp) == address(0), "AutonomousPool/already-init");\n', '    require(address(_comp) != address(0), "AutonomousPool/comp-not-defined");\n', '    require(address(_comptroller) != address(0), "AutonomousPool/comptroller-not-defined");\n', '    comp = _comp;\n', '    _setPrizePeriodSeconds(_prizePeriodSeconds);\n', '    _setComptroller(_comptroller);\n', '  }\n', '\n', '  function setPrizePeriodSeconds(uint256 _prizePeriodSeconds) external onlyAdmin {\n', '    _setPrizePeriodSeconds(_prizePeriodSeconds);\n', '  }\n', '\n', '  function _setPrizePeriodSeconds(uint256 _prizePeriodSeconds) internal {\n', '    require(_prizePeriodSeconds > 0, "AutonomousPool/pp-gt-zero");\n', '    prizePeriodSeconds = _prizePeriodSeconds;\n', '\n', '    emit PrizePeriodSecondsUpdated(prizePeriodSeconds);\n', '  }\n', '\n', '  function setComptroller(IComptroller _comptroller) external onlyAdmin {\n', '    _setComptroller(_comptroller);\n', '  }\n', '\n', '  function _setComptroller(IComptroller _comptroller) internal {\n', '    comptroller = _comptroller;\n', '\n', '    emit ComptrollerUpdated(comptroller);\n', '  }\n', '\n', '  function setCompRecipient(address _compRecipient) external onlyAdmin {\n', '    compRecipient = _compRecipient;\n', '\n', '    emit CompRecipientUpdated(compRecipient);\n', '  }\n', '\n', '  /// @notice Returns whether the prize period has ended.\n', '  function isPrizePeriodEnded() public view returns (bool) {\n', '    return remainingTime() == 0;\n', '  }\n', '\n', '  function claimAndTransferCOMP() public returns (uint256) {\n', '    if (address(comptroller) == address(0)) {\n', '      return 0;\n', '    }\n', '    ICErc20[] memory cTokens = new ICErc20[](1);\n', '    cTokens[0] = cToken;\n', '    comptroller.claimComp(address(this), cTokens);\n', '    return transferCOMP();\n', '  }\n', '\n', '  function transferCOMP() public returns (uint256) {\n', '    if (compRecipient == address(0)) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 amount = comp.balanceOf(address(this));\n', '    comp.transfer(compRecipient, amount);\n', '\n', '    emit TransferredComp(compRecipient, amount);\n', '\n', '    return amount;\n', '  }\n', '\n', '  /**\n', '   * @notice Locks the movement of tokens (essentially the committed deposits and winnings)\n', '   * @dev The lock only lasts for a duration of blocks.  The lock cannot be relocked until the cooldown duration completes.\n', '   */\n', '  function lockTokens() public requireInitialized onlyPrizePeriodEnded {\n', '    blocklock.lock(block.number);\n', '\n', '    emit AwardStarted();\n', '  }\n', '\n', '  /// @notice Starts the award process.  The prize period must have ended.\n', '  /// @dev Essentially an alias for lockTokens()\n', '  function startAward() public {\n', '    lockTokens();\n', '  }\n', '\n', '  /**\n', '   * @notice Rewards the current committed draw using the passed secret, commits the current open draw, and opens the next draw using the passed secret hash.\n', '   * Can only be called by an admin.\n', '   * Fires the Rewarded event, the Committed event, and the Open event.\n', '   */\n', '  function completeAward() external requireInitialized onlyLocked nonReentrant {\n', '    // if there is a committed draw, it can be awarded\n', '    if (currentCommittedDrawId() > 0) {\n', '      _reward();\n', '    }\n', '    if (currentOpenDrawId() != 0) {\n', '      emitCommitted();\n', '    }\n', '    _open();\n', '    lastAwardTimestamp = _currentTime();\n', '\n', '    emit AwardCompleted();\n', '  }\n', '\n', '  /**\n', '   * @notice Rewards the winner for the current committed Draw using the passed secret.\n', '   * The gross winnings are calculated by subtracting the accounted balance from the current underlying cToken balance.\n', '   * A winner is calculated using the revealed secret.\n', "   * If there is a winner (i.e. any eligible users) then winner's balance is updated with their net winnings.\n", "   * The draw beneficiary's balance is updated with the fee.\n", '   * The accounted balance is updated to include the fee and, if there was a winner, the net winnings.\n', '   * Fires the Rewarded event.\n', '   */\n', '  function _reward() internal {\n', '    // require that there is a committed draw\n', '    // require that the committed draw has not been rewarded\n', '    uint256 drawId = currentCommittedDrawId();\n', '    Draw storage draw = draws[drawId];\n', '    bytes32 entropy = blockhash(block.number - 1);\n', '    _reward(drawId, draw, entropy);\n', '  }\n', '\n', '  /**\n', '   * @notice Opens a new Draw.\n', '   */\n', '  function _open() internal {\n', '    drawState.openNextDraw();\n', '    draws[drawState.openDrawIndex] = Draw(\n', '      nextFeeFraction,\n', '      nextFeeBeneficiary,\n', '      block.number,\n', '      bytes32(0),\n', '      bytes32(0),\n', '      address(0),\n', '      uint256(0),\n', '      uint256(0)\n', '    );\n', '    emit Opened(\n', '      drawState.openDrawIndex,\n', '      nextFeeBeneficiary,\n', '      bytes32(0),\n', '      nextFeeFraction\n', '    );\n', '  }\n', '\n', '  function canStartAward() public view returns (bool) {\n', '    return _isAutonomousPoolInitialized() && isPrizePeriodEnded();\n', '  }\n', '\n', '  function canCompleteAward() public view returns (bool) {\n', '    return _isAutonomousPoolInitialized() && blocklock.isLocked(block.number);\n', '  }\n', '\n', '  function elapsedTime() public view returns (uint256) {\n', '    return _currentTime().sub(lastAwardTimestamp);\n', '  }\n', '\n', '  function remainingTime() public view returns (uint256) {\n', '    uint256 elapsed = elapsedTime();\n', '    if (elapsed > prizePeriodSeconds) {\n', '      return 0;\n', '    } else {\n', '      return prizePeriodSeconds.sub(elapsed);\n', '    }\n', '  }\n', '\n', '  function _currentTime() internal view returns (uint256) {\n', '    return block.timestamp;\n', '  }\n', '\n', '  function _isAutonomousPoolInitialized() internal view returns (bool) {\n', '    return address(comp) != address(0);\n', '  }\n', '\n', '  function openNextDraw(bytes32 nextSecretHash) public {\n', "    revert('AutonomousPool/deprecated');\n", '  }\n', '\n', '  function rolloverAndOpenNextDraw(bytes32 nextSecretHash) public {\n', "    revert('AutonomousPool/deprecated');\n", '  }\n', '\n', '  function rewardAndOpenNextDraw(bytes32 nextSecretHash, bytes32 lastSecret, bytes32 _salt) public {\n', "    revert('AutonomousPool/deprecated');\n", '  }\n', '\n', '  function reward(bytes32 _secret, bytes32 _salt) public {\n', "    revert('AutonomousPool/deprecated');\n", '  }\n', '\n', '  modifier onlyPrizePeriodEnded() {\n', '    require(isPrizePeriodEnded(), "AutonomousPool/prize-period-not-ended");\n', '    _;\n', '  }\n', '\n', '  modifier requireInitialized() {\n', '    require(address(comp) != address(0), "AutonomousPool/not-init");\n', '    _;\n', '  }\n', '}']