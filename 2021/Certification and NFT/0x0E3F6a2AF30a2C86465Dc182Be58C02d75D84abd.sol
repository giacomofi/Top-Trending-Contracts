['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', 'pragma solidity ^ 0.5.1;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    function owner() public view returns(address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns(bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC20 is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    struct ExcludeAddress {\n', '        bool isExist;\n', '    }\n', '    // Frontrans and Sniper bots will be blocked\n', '    mapping(address => ExcludeAddress) public blackList;\n', '    // only ICO contract and owner able to transfers before listing to uniswap\n', '    mapping(address => ExcludeAddress) public whiteList;\n', '    // ICO contract and Rewards wallet will be send without tax\n', '    mapping(address => ExcludeAddress) public taxFree;\n', '\n', '    // blocked transfers (exclude whiteList)\n', '    // to avoid fake listing not from the team\n', '    bool public isWhiteListOnly = true;\n', '    // the address that will receive taxes and send out rewards\n', '    address public rewardsWallet;\n', '\n', '    // Token params\n', '    string public constant name = "msgt.io";\n', '    string public constant symbol = "MSGT";\n', '    uint public constant decimals = 18;\n', '    uint constant total = 53750;\n', '    uint256 private _totalSupply;\n', '    uint lastCheck = now;\n', '    uint periodRebalance = 12 hours;\n', '    // -- Token params\n', '\n', '    //Taxes\n', '    uint public taxPercent = 6;\n', '    uint public taxPercentSell = 6;\n', '    uint public taxPercentBuy = 6;\n', '    \n', '    address public liqAddress = address(0);\n', '    // baseBalance - this is the balance of the reward wallet, to which the wallet will be rebalanced in case of exceeding +-10%\n', '    uint constant public baseBalance = 3500 * 10 ** decimals;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Rebalance(uint256 balance);\n', '    event Tax(uint256 taxedAmount);\n', '\n', '    constructor() public {\n', '        _mint(msg.sender, total * 10 ** decimals);\n', '    }\n', '\n', '    function totalSupply() public view returns(uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns(uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns(bool) {\n', '        _taxTransfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns(uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns(bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns(bool) {\n', '        _taxTransfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns(bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns(bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _taxTransfer(address _sender, address _recipient, uint256 _amount) internal returns(bool) {\n', "        require(!blackList[_sender].isExist, 'Address blocked');\n", "        require(!isWhiteListOnly || whiteList[_sender].isExist, 'White List only'); // unlock after listing\n", '\n', '        if (taxFree[_sender].isExist) {\n', '            _transfer(_sender, _recipient, _amount);\n', '        } else {\n', '            // calc tax\n', '            uint tax;\n', '            if(_sender == liqAddress) {tax = taxPercentBuy;} // buy token\n', '            else if(_recipient == liqAddress) {tax = taxPercentSell;} // sell token\n', '            else {tax = taxPercent;} // Wallet to Wallet\n', '            \n', '            uint _taxedAmount = _amount.mul(tax).div(100);\n', '            uint _transferedAmount = _amount.sub(_taxedAmount);\n', '\n', '            _transfer(_sender, rewardsWallet, _taxedAmount); // tax to rewardsWallet\n', '            _transfer(_sender, _recipient, _transferedAmount); // amount - tax to recipient\n', '            emit Tax(_taxedAmount);\n', '        }\n', '\n', '        rebalanceRW();\n', '    }\n', '\n', '    // If the balance of the reward changes from the base value by 10%, its balance is returned to the base value.\n', '    // In this case, the extra tokens are burned, and the shortage is minted.\n', '    function rebalanceRW () public {\n', '        if (isWhiteListOnly || lastCheck > now - periodRebalance) {\n', '            return;\n', '        }\n', '\n', '        lastCheck = now; // cached time of rebalance\n', '        uint balance = balanceOf(rewardsWallet);\n', '        // 10% constant\n', '        if (balance < (baseBalance.mul(90)).div(100)) { // positive\n', '            emit Rebalance(balance);\n', '            _balances[rewardsWallet] = baseBalance;\n', '            _totalSupply = _totalSupply.add(baseBalance - balance);\n', '        } else if (balance > (baseBalance.mul(110)).div(100)) { // negative\n', '            emit Rebalance(balance);\n', '            _balances[rewardsWallet] = baseBalance;\n', '            _totalSupply = _totalSupply.sub(balance - baseBalance);\n', '        }\n', '    }\n', '\n', '    // OWNER utils\n', '    function toggleWhiteList(address addr) public onlyOwner {\n', '        whiteList[addr].isExist = !whiteList[addr].isExist;\n', '    }\n', '    function toggleTaxFeeList(address addr) public onlyOwner {\n', '        taxFree[addr].isExist = !taxFree[addr].isExist;\n', '    }\n', '\n', '    function toggleBlackList(address addr) public onlyOwner {\n', '        blackList[addr].isExist = !blackList[addr].isExist;\n', '    }\n', '    function toggleIsWhiteListOnly() public onlyOwner {\n', '        isWhiteListOnly = !isWhiteListOnly;\n', '    }\n', '\n', '    function changePercentOfTax(uint percent) public onlyOwner {\n', '        taxPercent = percent;\n', '    }\n', '    function changePercentOfTaxSell(uint percent) public onlyOwner {\n', '        taxPercentSell = percent;\n', '    }\n', '    function changePercentOfTaxBuy(uint percent) public onlyOwner {\n', '        taxPercentBuy = percent;\n', '    }\n', '\n', '    // When change the reward wallet, tokens are sent from the old wallet to the new one.\n', '    // Thus, an extra balance is not possible when changing wallets.\n', '    function changeRewardsWallet(address addr) public onlyOwner {\n', '        if(rewardsWallet != address(0)){\n', '            _transfer(rewardsWallet, addr, _balances[rewardsWallet]);   \n', '        }\n', '        taxFree[rewardsWallet].isExist = false;\n', '        taxFree[addr].isExist = true;\n', '        rewardsWallet = addr;\n', '    }\n', '\n', '    // need after listing only\n', '    function blockSell(address _liqAddress) public onlyOwner {\n', '        changeLiqAddress(_liqAddress);\n', '        isWhiteListOnly = true;\n', '    }\n', '    function changeLiqAddress(address _liqAddress) public onlyOwner {\n', '        liqAddress = _liqAddress;\n', '        whiteList[liqAddress].isExist = true;\n', '    }\n', '    // Tokens of adresess which was blocked send to reward wallet\n', '    function sendBlockedTokensToRw(address addr) public onlyOwner {\n', "        require(blackList[addr].isExist, 'Address is not blocked');\n", '        _transfer(addr, rewardsWallet, _balances[addr]);\n', '    }\n', '}\n', '\n', 'contract Crowdsale {\n', '    using SafeMath for uint256;\n', '    address payable owner;\n', '    address me = address(this);\n', '    uint sat = 1e18;\n', '    struct IsExist {bool isExist;}\n', '    mapping(address => IsExist) public whiteList;\n', '    // \n', '    // *** Config ***\n', '    uint startIco = 1621260000;\n', '    // uint startIco = now;\n', '    uint stopIco = startIco + 48 hours;\n', '\n', '    uint countBy1EthIfWL = 25; // 1ETH -> 25 MSGT\n', '    uint countBy1EthIfNotWL = 24; // 1 ETH -> 24 MSGT\n', '    uint amountWL = 10500 * sat; // amount for WL users\n', '    uint amountNotWL = 10500 * sat; // amount for not WL users\n', '    uint maxTokensToOnceHandWl = 75 * sat;\n', '    uint maxTokensToOnceHandNoWl = 360 * sat;\n', '    // --- Config ---\n', '    ERC20 token = new ERC20();\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '\n', '        token.toggleWhiteList(address(this));\n', '        token.toggleTaxFeeList(address(this));\n', '\n', '        token.toggleWhiteList(owner);\n', '        token.toggleTaxFeeList(owner);\n', '\n', '        token.transfer(owner, token.totalSupply() - (amountWL + amountNotWL));\n', '        token.transferOwnership(owner);\n', '    }\n', '\n', '    function () external payable {\n', '        require(startIco < now && now < stopIco, "Period error");\n', '        uint amount = msg.value.mul(getPrice());\n', '        bool userIsWl = whiteList[msg.sender].isExist;\n', '        require(token.balanceOf(msg.sender) + amount <= (userIsWl ? maxTokensToOnceHandWl : maxTokensToOnceHandNoWl), "The purchase limit of tokens has been exceeded");\n', '        require(amount <= token.balanceOf(address(this)), "Infucient token balance in ICO");\n', '        uint leftTokens = userIsWl ? amountWL : amountNotWL;\n', '        require(amount <= leftTokens, "Infucient token balance in ICO for group");\n', '        token.transfer(msg.sender, amount);\n', '        if(userIsWl){ amountWL -= amount; } \n', '        else { amountNotWL -= amount; }\n', '    }\n', '\n', '    \n', '    modifier onlyOw() {\n', '        require(msg.sender == owner, "You is not owner");\n', '        _;\n', '    }\n', '    // OWNER ONLY\n', '    \n', '    function pushWhiteList(address[] memory addressess) public onlyOw {\n', '        for (uint i = 0; i < addressess.length; i++) {\n', '            whiteList[addressess[i]].isExist = true;\n', '        }\n', '    }\n', '    \n', '    function manualGetETH () public payable onlyOw {\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '    function getLeftTokens () public onlyOw {\n', '        token.transfer(owner, token.balanceOf(address(this)));\n', '    }\n', '    // run after 1h \n', '    function sendAmountWlToNoWL () public onlyOw {\n', '        amountNotWL += amountWL;\n', '        amountWL = 0;\n', '    }\n', '    \n', '\n', '    //--- end OWNER ONLY\n', '    \n', '\n', '    function getPrice() public view returns(uint) {\n', '        return (whiteList[msg.sender].isExist ? countBy1EthIfWL : countBy1EthIfNotWL);\n', '    }\n', '\n', '    // Utils\n', '    function getStartICO() public view returns(uint) {\n', '        return (startIco - now) / 60;\n', '    }\n', '    function getOwner() public view returns(address) {\n', '        return owner;\n', '    }\n', '    function getStopIco() public view returns(uint) {\n', '        return (stopIco - now) / 60;\n', '    }\n', '    function tokenAddress() public view returns(address) {\n', '        return address(token);\n', '    }\n', '    function IcoDeposit() public view returns(uint) {\n', '        return token.balanceOf(address(this)) / sat;\n', '    }\n', '    function myBalancex10() public view returns(uint) {\n', '        return token.balanceOf(msg.sender) / 1e17;\n', '    }\n', '    function myBalancex1000() public view returns(uint) {\n', '        return token.balanceOf(msg.sender) / 1e15;\n', '    }\n', '    function leftAmountForWL () public view returns(uint) {\n', '        return amountWL;\n', '    }\n', '    function leftAmountForNotWL () public view returns(uint) {\n', '        return amountNotWL;\n', '    }\n', '}']