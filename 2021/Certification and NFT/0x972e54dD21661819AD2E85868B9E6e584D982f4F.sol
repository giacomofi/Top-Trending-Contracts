['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Ownable: Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address transferOwner) public onlyOwner {\n', '        require(transferOwner != newOwner);\n', '        newOwner = transferOwner;\n', '    }\n', '\n', '    function acceptOwnership() virtual public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface INimbusStakingPool {\n', '    function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'interface INimbusReferralProgram {\n', '    function userSponsorByAddress(address user) external view returns (uint);\n', '    function userIdByAddress(address user) external view returns (uint);\n', '}\n', '\n', 'interface INimbusRouter {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'contract NBUInfluencerBonusPart is Ownable {\n', '    using SafeMath for uint;\n', '    \n', '    IERC20 public NBU;\n', '    \n', '    uint public nbuBonusAmount;\n', '    INimbusReferralProgram public referralProgram;\n', '    INimbusStakingPool[] public stakingPools;\n', '    \n', '    INimbusRouter public swapRouter;                \n', '    address public swapToken;                       \n', '    uint public swapTokenAmountForBonusThreshold;  \n', '    \n', '    mapping (address => bool) public influencers;\n', '    mapping (address => mapping (address => bool)) public processedUsers;\n', '\n', '    event ProcessInfluencerBonus(address influencer, address user, uint userAmount, uint influencerBonus);\n', '    event Rescue(address to, uint amount);\n', '    event RescueToken(address token, address to, uint amount); \n', '\n', '    constructor(address nbu, address router, address referral) {\n', '        NBU = IERC20(nbu);\n', '        swapRouter = INimbusRouter(router);\n', '        referralProgram = INimbusReferralProgram(referral);\n', '        nbuBonusAmount = 5 * 10 ** 18;\n', '    }\n', '\n', '    function claimBonus(address[] memory users) external {\n', '        for (uint i; i < users.length; i++) {\n', '            claimBonus(users[i]);\n', '        }\n', '    }\n', '\n', '    function claimBonus(address user) public {\n', '        require(influencers[msg.sender], "NBUInfluencerBonusPart: Not influencer");\n', '        require(!processedUsers[msg.sender][user], "NBUInfluencerBonusPart: Bonus for user already received");\n', '        require(referralProgram.userSponsorByAddress(user) == referralProgram.userIdByAddress(msg.sender), "NBUInfluencerBonusPart: Not user sponsor");\n', '        uint amount;\n', '        for (uint i; i < stakingPools.length; i++) {\n', '            amount = amount.add(stakingPools[i].balanceOf(user));\n', '        }\n', '\n', '        address[] memory path = new address[](2);\n', '        path[0] = swapToken;\n', '        path[1] = address(NBU);\n', '        uint minNbuAmountForBonus = swapRouter.getAmountsOut(swapTokenAmountForBonusThreshold, path)[1];\n', '        require (amount >= minNbuAmountForBonus, "NBUInfluencerBonusPart: Bonus threshold not met");\n', '        NBU.transfer(msg.sender, nbuBonusAmount);\n', '        processedUsers[msg.sender][user] = true;\n', '        emit ProcessInfluencerBonus(msg.sender, user, amount, nbuBonusAmount);\n', '    }\n', '\n', '    function isBonusForUserAllowed(address influencer, address user) external view returns (bool) {\n', '        if (!influencers[influencer]) return false;\n', '        if (processedUsers[influencer][user]) return false;\n', '        if (referralProgram.userSponsorByAddress(user) != referralProgram.userIdByAddress(influencer)) return false;\n', '        uint amount;\n', '        for (uint i; i < stakingPools.length; i++) {\n', '            amount = amount.add(stakingPools[i].balanceOf(user));\n', '        }\n', '\n', '        address[] memory path = new address[](2);\n', '        path[0] = swapToken;\n', '        path[1] = address(NBU);\n', '        uint minNbuAmountForBonus = swapRouter.getAmountsOut(swapTokenAmountForBonusThreshold, path)[1];\n', '        return amount >= minNbuAmountForBonus;\n', '    }\n', '\n', '\n', '\n', '    function rescue(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "NBUInfluencerBonusPart: Address is zero");\n', '        require(amount > 0, "NBUInfluencerBonusPart: Should be greater than 0");\n', '        TransferHelper.safeTransferETH(to, amount);\n', '        emit Rescue(to, amount);\n', '    }\n', '\n', '    function rescue(address to, address token, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "NBUInfluencerBonusPart: Address is zero");\n', '        require(amount > 0, "NBUInfluencerBonusPart: Should be greater than 0");\n', '        TransferHelper.safeTransfer(token, to, amount);\n', '        emit RescueToken(token, to, amount);\n', '    }\n', '\n', '    function updateSwapRouter(address newSwapRouter) external onlyOwner {\n', '        require(newSwapRouter != address(0), "NBUInfluencerBonusPart: Address is zero");\n', '        swapRouter = INimbusRouter(newSwapRouter);\n', '    }\n', '    \n', '    function updateStakingPoolAdd(address newStakingPool) external onlyOwner {\n', '        for (uint i; i < stakingPools.length; i++) {\n', '            require (address(stakingPools[i]) != newStakingPool, "NBUInfluencerBonusPart: Pool exists");\n', '        }\n', '        stakingPools.push(INimbusStakingPool(newStakingPool));\n', '    }\n', '\n', '    function updateStakingPoolRemove(uint poolIndex) external onlyOwner {\n', '        stakingPools[poolIndex] = stakingPools[stakingPools.length - 1];\n', '        stakingPools.pop();\n', '    }\n', '\n', '    function updateInfluencer(address influencer, bool isActive) external onlyOwner {\n', '        influencers[influencer] = isActive;\n', '    }\n', '\n', '    function updateNbuBonusAmount(uint newAmount) external onlyOwner {\n', '        nbuBonusAmount = newAmount;\n', '    }\n', '\n', '    function updateSwapToken(address newSwapToken) external onlyOwner {\n', '        require(newSwapToken != address(0), "NBUInfluencerBonusPart: Address is zero");\n', '        swapToken = newSwapToken;\n', '    }\n', '\n', '    function updateSwapTokenAmountForBonusThreshold(uint threshold) external onlyOwner {\n', '        swapTokenAmountForBonusThreshold = threshold;\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}']