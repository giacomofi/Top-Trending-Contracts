['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// Sources flattened with hardhat v2.0.11 https://hardhat.org\n', '\n', '// File contracts/solidity/proxy/IBeacon.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is the interface that {BeaconProxy} expects of its beacon.\n', ' */\n', 'interface IBeacon {\n', '    /**\n', '     * @dev Must return an address that can be used as a delegate call target.\n', '     *\n', '     * {BeaconProxy} will check that this address is a contract.\n', '     */\n', '    function childImplementation() external view returns (address);\n', '    function upgradeChildTo(address newImplementation) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/INFTXVaultFactory.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface INFTXVaultFactory is IBeacon {\n', '  // Read functions.\n', '  function numVaults() external view returns (uint256);\n', '  function zapContract() external view returns (address);\n', '  function feeDistributor() external view returns (address);\n', '  function eligibilityManager() external view returns (address);\n', '  function vault(uint256 vaultId) external view returns (address);\n', '  function vaultsForAsset(address asset) external view returns (address[] memory);\n', '  function isLocked(uint256 id) external view returns (bool);\n', '\n', '  event NewFeeDistributor(address oldDistributor, address newDistributor);\n', '  event NewZapContract(address oldZap, address newZap);\n', '  event NewEligibilityManager(address oldEligManager, address newEligManager);\n', '  event NewVault(uint256 indexed vaultId, address vaultAddress, address assetAddress);\n', '\n', '  // Write functions.\n', '  function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) external;\n', '  function createVault(\n', '      string calldata name,\n', '      string calldata symbol,\n', '      address _assetAddress,\n', '      bool is1155,\n', '      bool allowAllItems\n', '  ) external returns (uint256);\n', '  function setFeeDistributor(address _feeDistributor) external;\n', '  function setEligibilityManager(address _eligibilityManager) external;\n', '  function setZapContract(address _zapContract) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/INFTXEligibility.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface INFTXEligibility {\n', '    // Read functions.\n', '    function name() external pure returns (string memory);\n', '    function finalized() external view returns (bool);\n', '    function targetAsset() external pure returns (address);\n', '    function checkAllEligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool);\n', '    function checkEligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool[] memory);\n', '    function checkAllIneligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool);\n', '    function checkIsEligible(uint256 tokenId) external view returns (bool);\n', '\n', '    // Write functions.\n', '    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\n', '    function beforeMintHook(uint256[] calldata tokenIds) external;\n', '    function afterMintHook(uint256[] calldata tokenIds) external;\n', '    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n', '    function afterRedeemHook(uint256[] calldata tokenIds) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/proxy/Initializable.sol\n', '\n', '\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/util/ContextUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File contracts/solidity/util/OwnableUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '// File contracts/solidity/proxy/ClonesUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library ClonesUpgradeable {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/NFTXEligibilityManager.sol\n', '\n', '\n', '\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', '\n', 'contract NFTXEligibilityManager is OwnableUpgradeable {\n', '    struct EligibilityModule {\n', '        address implementation;\n', '        address targetAsset;\n', '        string name;\n', '    }\n', '    EligibilityModule[] public modules;\n', '\n', '    event ModuleAdded(\n', '        address implementation,\n', '        address targetAsset,\n', '        string name,\n', '        bool finalizedOnDeploy\n', '    );\n', '    event ModuleUpdated(\n', '        address implementation,\n', '        string name,\n', '        bool finalizedOnDeploy\n', '    );\n', '\n', '    function __NFTXEligibilityManager_init() public initializer {\n', '        __Ownable_init();\n', '    }\n', '\n', '    function addModule(address implementation) external onlyOwner {\n', '        require(implementation != address(0), "Impl != address(0)");\n', '        INFTXEligibility elig = INFTXEligibility(implementation);\n', '        string memory name = elig.name();\n', '        EligibilityModule memory module = EligibilityModule(\n', '            implementation,\n', '            elig.targetAsset(),\n', '            name\n', '        );\n', '        modules.push(module);\n', '        emit ModuleAdded(\n', '            implementation,\n', '            module.targetAsset,\n', '            name,\n', '            elig.finalized()\n', '        );\n', '    }\n', '\n', '    function updateModule(uint256 moduleIndex, address implementation)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(moduleIndex < modules.length, "Out of bounds");\n', '        require(implementation != address(0), "Impl != address(0)");\n', '        modules[moduleIndex].implementation = implementation;\n', '        INFTXEligibility elig = INFTXEligibility(implementation);\n', '        emit ModuleUpdated(implementation, elig.name(), elig.finalized());\n', '    }\n', '\n', '    function deployEligibility(uint256 moduleIndex, bytes calldata configData)\n', '        external\n', '        virtual\n', '        returns (address)\n', '    {\n', '        require(moduleIndex < modules.length, "Out of bounds");\n', '        address eligImpl = modules[moduleIndex].implementation;\n', '        address eligibilityClone = ClonesUpgradeable.clone(eligImpl);\n', '        INFTXEligibility(eligibilityClone).__NFTXEligibility_init_bytes(\n', '            configData\n', '        );\n', '        return eligibilityClone;\n', '    }\n', '\n', '    function allModules() external view returns (EligibilityModule[] memory) {\n', '        return modules;\n', '    }\n', '\n', '    function allModuleNames() external view returns (string[] memory) {\n', '        EligibilityModule[] memory modulesCopy = modules;\n', '        string[] memory names = new string[](modulesCopy.length);\n', '        for (uint256 i = 0; i < modulesCopy.length; i++) {\n', '            names[i] = modulesCopy[i].name;\n', '        }\n', '        return names;\n', '    }\n', '}']