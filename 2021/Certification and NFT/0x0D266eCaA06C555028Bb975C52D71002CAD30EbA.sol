['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-16\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity =0.6.11;\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    //rounds to zero if x*y < RAY / 2\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    //rounds to zero if x*y < RAY / 2\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeApprove: approve failed'\n", '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeTransfer: transfer failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::transferFrom: transferFrom failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n", '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'contract HedgehogERC20 is IERC20 {\n', '    using SafeMath for uint;\n', '    \n', '    string public override name;\n', '    string public override symbol;\n', '    uint8 public override decimals;\n', '    uint  public override totalSupply;\n', '    mapping(address => uint) public override balanceOf;\n', '    mapping(address => mapping(address => uint)) public override allowance;\n', '\n', '    function _mint(address to, uint value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint value) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint value) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value) external override returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint value) external override returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value) external override returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Hedgehog is HedgehogERC20{\n', '  using SafeMath for uint256;\n', '\n', '  bool public initialized;\n', '  address public asset;\n', '\n', '  uint256 public timestamp;\n', '  uint256 public oracle;\n', '  uint256 public oracle_prev;\n', '\n', '  event Deposit(address indexed from, uint256 asset_value, uint256 token_value);\n', '  event Withdraw(address indexed from, uint256 asset_value, uint256 token_value);\n', '  event Oracle(uint256 timestamp, uint256 new_price, uint256 old_price);\n', '\n', '  uint256 private unlocked = 1;\n', '  modifier lock() {\n', "      require(unlocked == 1, 'Hedgehog: LOCKED');\n", '      unlocked = 0;\n', '      _;\n', '      unlocked = 1;\n', '  }\n', '\n', '  function initialize(address _asset) public {\n', '      require(initialized == false, "Hedgehog_initialize: already initialized");\n', '      asset = _asset;\n', '      initialized = true;\n', '      string memory _name = IERC20(asset).name();\n', '      name = append("Hedgehog ", _name);\n', '      string memory _symbol = IERC20(asset).symbol();\n', '      symbol = append("h", _symbol);\n', '      decimals = 5;\n', '  }\n', '\n', '  function price() public view returns (uint256) {\n', '      uint256 token_price = calculateAssetIn(1e5);\n', '      return token_price;\n', '  }\n', '  \n', '  function deposit(uint256 token_amount, uint256 expected_assets) public lock {\n', '      uint256 asset_deposit = calculateAssetIn(token_amount);\n', '      require(asset_deposit > 0, "Hedgehog_Deposit: zero asset deposit"); \n', '      require(asset_deposit <= expected_assets, "Hedgehog_Deposit: deposit assets above expected");\n', '      _oracle();\n', '      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), asset_deposit); \n', '      _mint(msg.sender, token_amount);\n', '      Deposit(msg.sender, asset_deposit, token_amount);\n', '  }\n', '\n', '  function withdraw(uint256 token_amount, uint256 expected_assets) public lock {\n', '      uint256 asset_withdraw = calculateAssetOut(token_amount);\n', '      require(asset_withdraw > 0, "Hedgehog_withdraw: zero asset withdraw"); \n', '      require(asset_withdraw >= expected_assets, "Hedgehog_Deposit: withdraw assets below expected");\n', '      _oracle();\n', '      _burn(msg.sender, token_amount);\n', '      TransferHelper.safeTransfer(asset, msg.sender, asset_withdraw);\n', '      Withdraw(msg.sender, asset_withdraw, token_amount);\n', '  }\n', '\n', '  function calculateAssetIn(uint256 token_amount) public view returns (uint256) {\n', '      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\n', '      uint256 token_balance_new = totalSupply.add(token_amount);\n', '      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\n', '      return asset_balance_new.sub(asset_balance);\n', '  }\n', '\n', '  function calculateAssetOut(uint256 token_amount) public view returns (uint256) {\n', '      uint256 asset_balance = IERC20(asset).balanceOf(address(this));\n', '      uint256 token_balance_new = totalSupply.sub(token_amount);\n', '      uint256 asset_balance_new = token_balance_new.mul(token_balance_new);\n', '      return asset_balance.sub(asset_balance_new);\n', '  }\n', '\n', '  function _oracle() internal {\n', '      if (timestamp < block.timestamp && totalSupply > 0){\n', '          timestamp = block.timestamp;\n', '          oracle_prev = oracle;\n', '          oracle = price();\n', '          Oracle(timestamp, oracle, oracle_prev);\n', '      }\n', '  }\n', '\n', '  function append(string memory a, string memory b) internal pure returns (string memory) {\n', '      return string(abi.encodePacked(a, b));\n', '  }\n', '}\n', '\n', 'contract HedgehogFactory {\n', '\n', '    mapping(address =>  address) public hedgehog;\n', '    address[] public allHedgehogs;\n', ' \n', '    function allHedgehogsLength() external view returns (uint) {\n', '        return allHedgehogs.length;\n', '    }\n', '    function createHedgehog(address asset) public returns (address) {\n', '        require(asset != address(0), "HedgehogFactory: zero asset");\n', '        require(hedgehog[asset] == address(0), "HedgehogFactory: existing hedgehog");\n', '        Hedgehog _hedgehog = new Hedgehog();\n', '        hedgehog[asset] = address(_hedgehog);\n', '        allHedgehogs.push(address(_hedgehog));\n', '        _hedgehog.initialize(asset);\n', '        return address(_hedgehog);\n', '    }\n', '}']