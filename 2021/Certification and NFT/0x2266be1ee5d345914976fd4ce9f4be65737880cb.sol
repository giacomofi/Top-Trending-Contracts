['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-27\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '}\n', '\n', 'interface IKeep3rV1 {\n', '    function keepers(address keeper) external returns (bool);\n', '    function KPRH() external view returns (IKeep3rV1Helper);\n', '    function receipt(address credit, address keeper, uint amount) external;\n', '}\n', '\n', 'interface IKeep3rV1Helper {\n', '    function getQuoteLimit(uint gasUsed) external view returns (uint);\n', '}\n', '\n', '// sliding oracle that uses observations collected to provide moving price averages in the past\n', 'contract Keep3rV2Oracle {\n', '    \n', '    constructor(address _pair) {\n', '        _factory = msg.sender;\n', '        pair = _pair;\n', '        (,,uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\n', '        uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(_pair).price0CumulativeLast() * e10 / Q112);\n', '        uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(_pair).price1CumulativeLast() * e10 / Q112);\n', '        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '    }\n', '\n', '    struct Observation {\n', '        uint32 timestamp;\n', '        uint112 price0Cumulative;\n', '        uint112 price1Cumulative;\n', '    }\n', '\n', '    modifier factory() {\n', '        require(msg.sender == _factory, "!F");\n', '        _;\n', '    }\n', '    \n', '    Observation[65535] public observations;\n', '    uint16 public length;\n', '\n', '    address immutable _factory;\n', '    address immutable public pair;\n', '    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n', '    uint constant periodSize = 1800;\n', '    uint Q112 = 2**112;\n', '    uint e10 = 10**18;\n', '    \n', '    // Pre-cache slots for cheaper oracle writes\n', '    function cache(uint size) external {\n', '        uint _length = length+size;\n', '        for (uint i = length; i < _length; i++) observations[i].timestamp = 1;\n', '    }\n', '\n', '    // update the current feed for free\n', '    function update() external factory returns (bool) {\n', '        return _update();\n', '    }\n', '\n', '    function updateable() external view returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint timeElapsed = timestamp - _point.timestamp;\n', '        return timeElapsed > periodSize;\n', '    }\n', '\n', '    function _update() internal returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint32 timeElapsed = timestamp - _point.timestamp;\n', '        if (timeElapsed > periodSize) {\n', '            uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112);\n', '            uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112);\n', '            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _computeAmountOut(uint start, uint end, uint elapsed, uint amountIn) internal view returns (uint amountOut) {\n', '        amountOut = amountIn * (end - start) / e10 / elapsed;\n', '    }\n', '\n', '    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint timestamp) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        Observation memory _observation = observations[length-1];\n', '        uint price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        uint price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '        (,,timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        \n', '        uint timeElapsed = timestamp - _observation.timestamp;\n', '        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n', '        if (token0 == tokenIn) {\n', '            amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n', '        } else {\n', '            amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n', '        }\n', '    }\n', '\n', '    function quote(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint timestamp) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        uint priceAverageCumulative = 0;\n', '        uint _length = length;\n', '        uint i = _length - points;\n', '        Observation memory currentObservation;\n', '        Observation memory nextObservation;\n', '\n', '        uint nextIndex = 0;\n', '        if (token0 == tokenIn) {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i+1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price0Cumulative,\n', '                    nextObservation.price0Cumulative, \n', '                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '            }\n', '        } else {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i+1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price1Cumulative,\n', '                    nextObservation.price1Cumulative, \n', '                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '            }\n', '        }\n', '        amountOut = priceAverageCumulative / points;\n', '        timestamp = nextObservation.timestamp;\n', '    }\n', '    \n', '    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint timestamp) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '        prices = new uint[](points);\n', '        \n', '        if (token0 == tokenIn) {\n', '            {\n', '                uint _length = length;\n', '                uint i = _length - (points * window);\n', '                uint _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i+=window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price0Cumulative,\n', '                        nextObservation.price0Cumulative, \n', '                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '                    _index = _index + 1;\n', '                }\n', '                timestamp = nextObservation.timestamp;\n', '            }\n', '        } else {\n', '            {\n', '                uint _length = length;\n', '                uint i = _length - (points * window);\n', '                uint _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i+=window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price1Cumulative,\n', '                        nextObservation.price1Cumulative, \n', '                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '                    _index = _index + 1;\n', '                }\n', '                timestamp = nextObservation.timestamp;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Keep3rV2OracleFactory {\n', '    \n', '    modifier keeper() {\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '    }\n', '\n', '    modifier upkeep() {\n', '        uint _gasUsed = gasleft();\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed - gasleft());\n', '        KP3R.receipt(address(KP3R), msg.sender, _received);\n', '    }\n', '\n', '    address public governance;\n', '    address public pendingGovernance;\n', '\n', '    /**\n', '     * @notice Allows governance to change governance (for future upgradability)\n', '     * @param _governance new governance address to set\n', '     */\n', '    function setGovernance(address _governance) external {\n', '        require(msg.sender == governance, "!G");\n', '        pendingGovernance = _governance;\n', '    }\n', '\n', '    /**\n', '     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n', '     */\n', '    function acceptGovernance() external {\n', '        require(msg.sender == pendingGovernance, "!pG");\n', '        governance = pendingGovernance;\n', '    }\n', '\n', '    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n', '\n', '    address[] internal _pairs;\n', '    mapping(address => Keep3rV2Oracle) public feeds;\n', '\n', '    function pairs() external view returns (address[] memory) {\n', '        return _pairs;\n', '    }\n', '\n', '    constructor() {\n', '        governance = msg.sender;\n', '    }\n', '\n', '    function update(address pair) external keeper returns (bool) {\n', '        return feeds[pair].update();\n', '    }\n', '\n', '    function deploy(address pair) external returns (address feed) {\n', '        require(msg.sender == governance, "!G");\n', "        require(address(feeds[pair]) == address(0), 'PE');\n", '        bytes memory bytecode = type(Keep3rV2Oracle).creationCode;\n', '        bytes32 salt = keccak256(abi.encodePacked(pair));\n', '        assembly {\n', '            feed := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '        }\n', '        feeds[pair] = Keep3rV2Oracle(feed);\n', '    }\n', '    \n', '    function work() external upkeep {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function work(address pair) external upkeep {\n', '        require(feeds[pair].update(), "!W");\n', '    }\n', '    \n', '    function workForFree() external keeper {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function workForFree(address pair) external keeper {\n', '        feeds[pair].update();\n', '    }\n', '    \n', '    function cache(uint size) external {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].cache(size);\n', '        }\n', '    }\n', '    \n', '    function cache(address pair, uint size) external {\n', '        feeds[pair].cache(size);\n', '    }\n', '\n', '    function workable() public view returns (bool canWork) {\n', '        canWork = true;\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            if (!feeds[_pairs[i]].updateable()) {\n', '                canWork = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    function workable(address pair) public view returns (bool) {\n', '        return feeds[pair].updateable();\n', '    }\n', '}']