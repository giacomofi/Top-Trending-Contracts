['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-14\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.3;\n', 'pragma abicoder v2;\n', '\n', 'contract EverPay {\n', '    // Event\n', '    event Submission(\n', '        bytes32 indexed id,\n', '        uint256 indexed proposalID,\n', '        bytes32 indexed everHash,\n', '        address owner,\n', '        address to,\n', '        uint256 value,\n', '        bytes data\n', '    );\n', '    event SubmissionFailure(\n', '        bytes32 indexed id,\n', '        uint256 indexed proposalID,\n', '        bytes32 indexed everHash,\n', '        address owner,\n', '        address to,\n', '        uint256 value,\n', '        bytes data\n', '    );\n', '    event Execution(\n', '        bytes32 indexed id,\n', '        uint256 indexed proposalID,\n', '        bytes32 indexed everHash,\n', '        address to,\n', '        uint256 value,\n', '        bytes data\n', '    );\n', '    event ExecutionFailure(\n', '        bytes32 indexed id,\n', '        uint256 indexed proposalID,\n', '        bytes32 indexed everHash,\n', '        address to,\n', '        uint256 value,\n', '        bytes data\n', '    );\n', '    // event Revocation(address indexed sender, bytes32 indexed id); // TODO\n', '    event Deposit(address indexed sender, uint256 value);\n', '    event OwnerAddition(address indexed owner);\n', '    event OwnerRemoval(address indexed owner);\n', '    event RequirementChange(uint256 required);\n', '\n', '    event OperatorChange(address indexed operator);\n', '    event PausedChange(bool paused);\n', '    // Event End\n', '\n', '    // Storage & Struct\n', '    uint256 public chainID;\n', '    bool public paused;\n', '    address public operator;\n', '    uint256 public required;\n', '    address[] public owners;\n', '    mapping(address => bool) public isOwner;\n', '\n', '    mapping(bytes32 => bool) public executed;// tx id => bool\n', '    mapping(bytes32 => mapping(address => bool)) public confirmations;\n', '    // Storage & Struct End\n', '\n', '    // Modifier\n', '    modifier validRequirement(uint256 ownerCount, uint256 _required) {\n', '        require(\n', '            ownerCount >= _required && ownerCount != 0 && _required != 0,\n', '            "invalid_required"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyWallet() {\n', '        require(msg.sender == address(this), "not_wallet");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator, "not_operator");\n', '        _;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused, "paused");\n', '        _;\n', '    }\n', '\n', '    // Modifier End\n', '\n', '    // Manage\n', '    function getPaused() public view returns (bool) {\n', '        return paused;\n', '    }\n', '\n', '    function getOperator() public view returns (address) {\n', '        return operator;\n', '    }\n', '\n', '    function getOwners() public view returns (address[] memory) {\n', '        return owners;\n', '    }\n', '\n', '    function getRequire() public view returns (uint256) {\n', '        return required;\n', '    }\n', '\n', '    function setOperator(address _operator) public onlyWallet {\n', '        require(_operator != address(0), "null_address");\n', '\n', '        operator = _operator;\n', '\n', '        emit OperatorChange(operator);\n', '    }\n', '\n', '    function setPaused(bool _paused) public onlyOperator {\n', '        paused = _paused;\n', '\n', '        emit PausedChange(paused);\n', '    }\n', '\n', '    function addOwner(address owner) public onlyWallet {\n', '        require(owner != address(0), "null_address");\n', '\n', '        isOwner[owner] = true;\n', '        owners.push(owner);\n', '\n', '        emit OwnerAddition(owner);\n', '    }\n', '\n', '    function removeOwner(address owner) public onlyWallet {\n', '        require(isOwner[owner], "no_owner_found");\n', '\n', '        isOwner[owner] = false;\n', '        for (uint256 i = 0; i < owners.length - 1; i++) {\n', '            if (owners[i] == owner) {\n', '                owners[i] = owners[owners.length - 1];\n', '                break;\n', '            }\n', '        }\n', '        owners.pop();\n', '\n', '        if (required > owners.length) {\n', '            changeRequirement(owners.length);\n', '        }\n', '\n', '        OwnerRemoval(owner);\n', '    }\n', '\n', '    function replaceOwner(address owner, address newOwner) public onlyWallet {\n', '        require(isOwner[owner], "no_owner_found");\n', '        require(newOwner != address(0), "null_address");\n', '\n', '        for (uint256 i = 0; i < owners.length; i++) {\n', '            if (owners[i] == owner) {\n', '                owners[i] = newOwner;\n', '                break;\n', '            }\n', '        }\n', '        isOwner[owner] = false;\n', '        isOwner[newOwner] = true;\n', '\n', '        OwnerRemoval(owner);\n', '        OwnerAddition(newOwner);\n', '    }\n', '\n', '    function changeRequirement(uint256 _required)\n', '        public\n', '        onlyWallet\n', '        validRequirement(owners.length, _required)\n', '    {\n', '        required = _required;\n', '        emit RequirementChange(_required);\n', '    }\n', '\n', '    // Manage End\n', '\n', '    // Base\n', '    receive() external payable {\n', '        if (msg.value != 0) emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    constructor(address[] memory _owners, uint256 _required) validRequirement(_owners.length, _required)\n', '    {\n', '        for (uint256 i = 0; i < _owners.length; i++) {\n', '            isOwner[_owners[i]] = true;\n', '        }\n', '\n', '        owners = _owners;\n', '        required = _required;\n', '\n', '        uint256 _chainID;\n', '        assembly {\n', '            _chainID := chainid()\n', '        }\n', '        chainID = _chainID;\n', '    }\n', '\n', '    function submit(\n', '        uint256 proposalID, // ar tx id\n', '        bytes32 everHash,\n', '        address to,\n', '        uint256 value,\n', '        bytes memory data,\n', '        bytes[] memory sigs\n', '    ) public whenNotPaused returns (bytes32, bool) {\n', '        bytes32 id = txHash(proposalID, everHash, to, value, data);\n', '        require(!executed[id], "tx_executed");\n', '\n', '        for (uint256 i = 0; i < sigs.length; i++) {\n', '            address owner = ecAddress(id, sigs[i]);\n', '            if (!isOwner[owner]) {\n', '                emit SubmissionFailure(id, proposalID, everHash, owner, to, value, data);\n', '                continue;\n', '            }\n', '\n', '            confirmations[id][owner] = true;\n', '            emit Submission(id, proposalID, everHash, owner, to, value, data);\n', '        }\n', '\n', '        if (!isConfirmed(id)) return (id, false);\n', '        executed[id] = true;\n', '\n', '        (bool ok, ) = to.call{value: value}(data);\n', '        if (ok) {\n', '            emit Execution(id, proposalID, everHash, to, value, data);\n', '        } else {\n', '            emit ExecutionFailure(id, proposalID, everHash, to, value, data);\n', '        }\n', '\n', '        return (id, true);\n', '    }\n', '\n', '    // execute multi calls\n', '    function executes(address[] memory tos, uint256[] memory values, bytes[] memory datas) payable public onlyWallet {\n', '        require(tos.length == values.length, "invalid_length");\n', '        require(tos.length == datas.length, "invalid_length");\n', '\n', '        for (uint256 i = 0; i < tos.length; i++) {\n', '          (bool ok, ) = tos[i].call{value: values[i]}(datas[i]);\n', '          require(ok, "executed_falied");\n', '        }\n', '    }\n', '\n', '    function isConfirmed(bytes32 id) public view returns (bool) {\n', '        uint256 count = 0;\n', '        for (uint256 i = 0; i < owners.length; i++) {\n', '            if (confirmations[id][owners[i]]) count += 1;\n', '            if (count >= required) return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    // Base End\n', '\n', '    // Utils\n', '    function txHash(uint256 proposalID, bytes32 everHash, address to, uint256 value, bytes memory data) public view returns (bytes32) {\n', '        return keccak256(abi.encodePacked(chainID, address(this), proposalID, everHash, to, value, data));\n', '    }\n', '\n', '    function ecAddress(bytes32 id, bytes memory sig)\n', '        public\n', '        pure\n', '        returns (address)\n', '    {\n', '        require(sig.length == 65, "invalid_sig_len");\n', '\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        assembly {\n', '            r := mload(add(sig, 0x20))\n', '            s := mload(add(sig, 0x40))\n', '            v := byte(0, mload(add(sig, 0x60)))\n', '        }\n', '\n', '        require(v == 27 || v == 28, "invalid_sig_v");\n', '\n', '        return\n', '            ecrecover(\n', '                keccak256(\n', '                    abi.encodePacked("\\x19Ethereum Signed Message:\\n32", id)\n', '                ), v, r, s\n', '            );\n', '    }\n', '    // Utils End\n', '}']