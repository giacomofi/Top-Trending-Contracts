['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20Lib.sol";\n', '\n', '\n', '/// @title MinimalProxy Factory\n', '/// @author coinstructor.io\n', '/// @dev Refer to https://eips.ethereum.org/EIPS/eip-1167 for details\n', '/// @notice The Factory contract creates Minimal Proxies using EIP1167,\n', '/// @notice which point to ERC20 contracts implementation, this saving on gas\n', 'contract ERC20Factory {\n', '  // Service fee for each MinimalProxy creation\n', '  uint256 constant serviceFee = 50000000000000000; // 0.05 ETH\n', '\n', '  // The owner of the contract, who receives the funds\n', '  address payable immutable public owner;\n', '\n', '  address immutable public signer;\n', '  bool public requireSigned;\n', '\n', '  /// @notice Event will be emitted every time a new ERC20 MinimalProxy is created\n', '  /// @param newERC20Address is an address of the newly created ERC20 token MinimalProxy\n', '  event ERC20Created(address newERC20Address);\n', '\n', '  // EIP712 niceties\n', '  bytes32 public DOMAIN_SEPARATOR;\n', '\n', '  string public constant version = "1";\n', '\n', '  constructor(address payable _owner, address _signer) {\n', '    owner = _owner;\n', '    signer = _signer;\n', '    uint256 chainId = 0;\n', '    assembly {\n', '        chainId := chainid()\n', '    }\n', '    DOMAIN_SEPARATOR = keccak256(abi.encode(\n', '        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '        keccak256(bytes("ERC20Factory")),\n', '        keccak256(bytes(version)),\n', '        1, //chainId,\n', '        address(this)\n', '    ));\n', '  }\n', '\n', '  /// @notice Creates a MinimalProxy contract via EIP1167 assembly code\n', '  /// @dev Using this implementation: https://github.com/optionality/clone-factory\n', '  /// @param target is an address of implementation, to which the MinimalProxy will point to\n', '  /// @return result is an address of a newly created MinimalProxy\n', '  function createClone(address target) internal returns (address result) {\n', '    bytes20 targetBytes = bytes20(target);\n', '    assembly {\n', '      let clone := mload(0x40)\n', '      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '      mstore(add(clone, 0x14), targetBytes)\n', '      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '      result := create(0, clone, 0x37)\n', '    }\n', '  }\n', '\n', '  /// @notice Tests if MinimalProxy instance really points to the correct implementation\n', '  /// @param target is an address of implementation, to which the MinimalProxy should point to\n', '  /// @param query is an address of MinimalProxy that needs to be tested\n', '  /// @return result is true if MinimalProxy really points to the implementation address\n', '  function isClone(address target, address query) external view returns (bool result) {\n', '    bytes20 targetBytes = bytes20(target);\n', '    assembly {\n', '      let clone := mload(0x40)\n', '      mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n', '      mstore(add(clone, 0xa), targetBytes)\n', '      mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '\n', '      let other := add(clone, 0x40)\n', '      extcodecopy(query, other, 0, 0x2d)\n', '      result := and(\n', '        eq(mload(clone), mload(other)),\n', '        eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n', '      )\n', '    }\n', '  }\n', '\n', '  /// @notice Pays out all Factory ETH balance to owners address\n', '  function payout() external {\n', '    require(owner.send(address(this).balance));\n', '  }\n', '\n', '  /// @notice Pays out all Factory ERC20 token balance to owners address\n', '  /// @param _tokenAddress is an address of the ERC20 token to payout\n', '  function payoutToken(address _tokenAddress) external {\n', '    IERC20Lib token = IERC20Lib(_tokenAddress);\n', '    uint256 amount = token.balanceOf(address(this));\n', '    require(amount > 0, "Nothing to payout");\n', '    token.transfer(owner, amount);\n', '  }\n', '\n', '  /// @notice Creates and initializes the ERC20 MinimalProxy contract\n', '  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\n', '  /// @param name_ is the ERC20 token name\n', '  /// @param symbol_ is the ERC20 token symbol\n', '  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\n', '  function createERC20(address libraryAddress_, string memory name_, string memory symbol_, uint256 totalSupply_) payable external {\n', '    // The service fee should be paid when calling this function\n', '    require(msg.value >= serviceFee, "Service Fee of 0.05ETH wasn\'t paid");\n', '    address clone = createClone(libraryAddress_);\n', '    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\n', '    emit ERC20Created(clone);\n', '  }\n', '\n', '  /// @notice Creates and initializes the ERC20 MinimalProxy contract\n', '  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\n', '  /// @param name_ is the ERC20 token name\n', '  /// @param symbol_ is the ERC20 token symbol\n', '  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\n', '  /// @param referral_ is the referral, who will receive 0.01 ETH from the deployment\n', '  function createERC20WithReferral(address libraryAddress_, string memory name_, string memory symbol_, uint256 totalSupply_, address payable referral_) payable external {\n', '    // The service fee should be paid when calling this function\n', '    require(msg.value >= serviceFee, "Service Fee of 0.05ETH wasn\'t paid");\n', '    require(requireSigned == false, "Only Signed referrals are allowed");\n', '    address clone = createClone(libraryAddress_);\n', '    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\n', '    emit ERC20Created(clone);\n', '\n', '    // Referral must accept money, otherwise he will not be paid (saves gas and eliminates security risks)\n', '    referral_.send(0.01 ether);\n', '  }\n', '\n', '  /// @notice Restricts referral creation to be signed by the service\n', '  /// @param requireSigned_ true if signature is required\n', '  function setRequireSigned(bool requireSigned_) external {\n', '    require(msg.sender == signer);\n', '    requireSigned = requireSigned_;\n', '  }\n', '\n', '  bytes32 public constant PERMIT_TYPEHASH = keccak256("createERC20WithReferralSigned(address libraryAddress,string name,string symbol,uint256 totalSupply,address referral)");\n', '\n', '  /// @notice Creates and initializes the ERC20 MinimalProxy contract using a referral link and signatures\n', '  /// @param libraryAddress_ is an address of implementation, to which the MinimalProxy should point to\n', '  /// @param name_ is the ERC20 token name\n', '  /// @param symbol_ is the ERC20 token symbol\n', '  /// @param totalSupply_ is the ERC20 token totalSupply that will be minted to msg.sender\n', '  /// @param referral_ is the referral, who will receive 0.01 ETH from the deployment\n', '  /// @param v_ A final byte of signature (ECDSA component)\n', '  /// @param r_ The first 32 bytes of signature (ECDSA component)\n', '  /// @param s_ The second 32 bytes of signature (ECDSA component)\n', '  function createERC20WithReferralSigned(address libraryAddress_,\n', '                                   string memory name_,\n', '                                   string memory symbol_,\n', '                                   uint256 totalSupply_,\n', '                                   address payable referral_,\n', '                                   uint8 v_,\n', '                                   bytes32 r_,\n', '                                   bytes32 s_) payable external {\n', '    // The service fee should be paid when calling this function\n', '    require(msg.value >= serviceFee, "Service Fee of 0.05ETH wasn\'t paid");\n', '\n', '    bytes32 digest = keccak256(abi.encodePacked(\n', '                                "\\x19\\x01",\n', '                                DOMAIN_SEPARATOR,\n', '                                keccak256(abi.encode(\n', '                                  PERMIT_TYPEHASH,\n', '                                  libraryAddress_,\n', '                                  keccak256(bytes(name_)),\n', '                                  keccak256(bytes(symbol_)),\n', '                                  totalSupply_,\n', '                                  referral_\n', '                                ))\n', '                              ));\n', '    \n', '    require(signer == ecrecover(digest, v_, r_, s_), "invalid signature or parameters");\n', '\n', '    address clone = createClone(libraryAddress_);\n', '    IERC20Lib(clone).init(msg.sender, name_, symbol_, totalSupply_);\n', '\n', '    emit ERC20Created(clone);\n', '\n', '    // Referral must accept money, otherwise he will not be paid (saves gas and eliminates security risks)\n', '    referral_.send(0.01 ether);\n', '  }\n', '}']