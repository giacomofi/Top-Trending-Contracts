['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-28\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'library Strings {\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = bytes1(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'abstract contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', 'interface IERC721Receiver {\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', 'interface IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', 'interface IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', 'contract CryptoHouse is ERC165, IERC721, IERC721Metadata {\n', '\n', '    using Address for address;\n', '    using Strings for uint256;\n', '   \n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', ' \n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '    \n', '    string private _baseURI;\n', '    address payable public author;\n', '\n', '\tstring constant public _name = "CryptoHouse";\n', '\tstring constant public _symbol = "HOUSE";\n', '\tuint256 public _totalSupply = 250;\n', '\t\n', '    uint public houseRemainingToAssign = 0;\n', '    \n', '    struct Offer {\n', '        bool isForSale;\n', '        uint houseIndex;\n', '        address seller;\n', '        uint minValue;      \n', '        address onlySellTo;     \n', '    }\n', '\n', '    struct Bid {\n', '        bool hasBid;\n', '        uint houseIndex;\n', '        address bidder;\n', '        uint value;\n', '    }\n', '    \n', '    struct Info {\n', '        uint houseIndex;\n', '        string authorInfo;\n', '        string publicInfo;\n', '    }\n', '    \n', '    mapping (uint256 => string) private _tokenURIs;\n', '        \n', '    mapping (address => uint256) public _balances;\n', '    mapping (uint => address) public _owners;\n', '\n', '    mapping (uint => Offer) public houseOfferedForSale;\n', '    mapping (uint => Bid) public houseBids;\n', '    mapping (uint => Info) public houseInfo;\n', '\n', '    mapping (address => uint) public pendingWithdrawals;\n', '    mapping (uint256 => address) public _tokenApprovals;\n', '    mapping (address => mapping (address => bool)) public _operatorApprovals;\n', '    \n', '    event HouseTransferAllowance(uint256 indexed houseIndex, address indexed fromAddress, address indexed toAddress);\n', '    event HouseTransferAllowanceForAll(address indexed fromAddress, address indexed toAddress, bool indexed approved);\n', '    event AssignHouse(uint256 indexed houseIndex, address indexed toAddress);\n', '    event HouseTransfer(uint256 indexed houseIndex, address indexed fromAddress, address indexed toAddress);\n', '    event HouseOffered(uint indexed houseIndex, uint minValue, address indexed toAddress);\n', '    event HouseBidEntered(uint indexed houseIndex, uint value, address indexed fromAddress);\n', '    event HouseBidWithdrawn(uint indexed houseIndex, uint value, address indexed fromAddress);\n', '    event HouseBought(uint indexed houseIndex, uint value, address indexed fromAddress, address indexed toAddress);\n', '    event HouseNoLongerForSaleEvent(uint indexed houseIndex);\n', '    \n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    \n', '    function totalSupply() public view virtual returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '    \n', '    function balanceOf(address owner) public view virtual override returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n', '        return _owners[tokenId];\n', '    }\n', '    \n', '    function getAllOwnerOf() public view returns (address[] memory _holder) {\n', '        address[] memory holders = new address[](totalSupply());\n', '         \n', '        for(uint i = 0; i < totalSupply(); i++) {\n', '            holders[i] = _owners[i];\n', '        }\n', '        \n', '        return (holders);\n', '    }\n', '    \n', '    function getHouseOfferedForSale() public view returns (bool[] memory _isForSale, uint[] memory _houseIndex, address[] memory _seller, uint[] memory _minValue, address[] memory _onlySellTo) {\n', '        bool[] memory isForSale = new bool[](totalSupply());\n', '        uint[] memory houseIndex = new uint[](totalSupply());\n', '        address[] memory seller = new address[](totalSupply());\n', '        uint[] memory minValue = new uint[](totalSupply());\n', '        address[] memory onlySellTo = new address[](totalSupply());\n', '        \n', '        for(uint i = 0; i < totalSupply(); i++) {\n', '            isForSale[i] = houseOfferedForSale[i].isForSale;\n', '            houseIndex[i] = houseOfferedForSale[i].houseIndex;\n', '            seller[i] = houseOfferedForSale[i].seller;\n', '            minValue[i] = houseOfferedForSale[i].minValue;\n', '            onlySellTo[i] = houseOfferedForSale[i].onlySellTo;\n', '        }\n', '        \n', '        return (isForSale, houseIndex, seller, minValue, onlySellTo);\n', '    }\n', '\n', '    function getHouseBids() public view returns (bool[] memory _hasBid, uint[] memory _houseIndex, address[] memory _bidder, uint[] memory _value) {\n', '        bool[] memory hasBid = new bool[](totalSupply());\n', '        uint[] memory houseIndex = new uint[](totalSupply());\n', '        address[] memory bidder = new address[](totalSupply());\n', '        uint[] memory value = new uint[](totalSupply());\n', '         \n', '        for(uint i = 0; i < totalSupply(); i++) {\n', '            hasBid[i] = houseBids[i].hasBid;\n', '            houseIndex[i] = houseBids[i].houseIndex;\n', '            bidder[i] = houseBids[i].bidder;\n', '            value[i] = houseBids[i].value;\n', '        }\n', '        \n', '        return (hasBid, houseIndex, bidder, value);\n', '    }\n', '    \n', '     function getHouseInfo() public view returns (uint[] memory _houseIndex, string[] memory _authorInfo, string[] memory _publicInfo) {\n', '\n', '        uint[] memory houseIndex = new uint[](totalSupply());\n', '        string[] memory authorInfo = new string[](totalSupply());\n', '        string[] memory publicInfo = new string[](totalSupply());\n', '         \n', '        for(uint i = 0; i < totalSupply(); i++) {\n', '            houseIndex[i] = houseInfo[i].houseIndex;\n', '            authorInfo[i] = houseInfo[i].authorInfo;\n', '            publicInfo[i] = houseInfo[i].publicInfo;\n', '        }\n', '        \n', '        return (houseIndex, authorInfo, publicInfo);\n', '    }\n', '    \n', '    constructor() {\n', '        author = msg.sender;\n', '        houseRemainingToAssign = totalSupply();\n', '        \n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '\n', '    function setTokenURI(uint256 tokenId, string memory _tokenURI) public virtual {\n', '         require (author == msg.sender);\n', '\n', '        _tokenURIs[tokenId] = _tokenURI;\n', '    }\n', '    \n', '    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n', '        string memory _tokenURI = _tokenURIs[tokenId];\n', '        string memory base = baseURI();\n', '\n', '        if (bytes(base).length == 0) {\n', '            return _tokenURI;\n', '        }\n', '\n', '        if (bytes(_tokenURI).length > 0) {\n', '            return string(abi.encodePacked(base, _tokenURI));\n', '        }\n', '    \n', '        return string(abi.encodePacked(base, tokenId.toString()));\n', '    }\n', '    \n', '    function setBaseURI(string memory baseURI_) public virtual {\n', '         require (author == msg.sender);\n', '        _baseURI = baseURI_;\n', '    }\n', '    \n', '      function baseURI() public view virtual returns (string memory) {\n', '        return _baseURI;\n', '    }\n', '    \n', '    function approve(address to, uint256 tokenId) public virtual override {\n', '        address owner = _owners[tokenId];\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '        _approve(to, tokenId);\n', '    }\n', '    \n', '    function _approve(address to, uint256 tokenId) internal virtual {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit HouseTransferAllowance(tokenId, _owners[tokenId], to);\n', '        emit Approval(_owners[tokenId], to, tokenId);\n', '    }\n', '\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(operator != msg.sender);\n', '\n', '        _operatorApprovals[msg.sender][operator] = approved;\n', '        emit HouseTransferAllowanceForAll(msg.sender, operator, approved);\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '    \n', '    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n', '   \n', '        return _tokenApprovals[tokenId];\n', '    }\n', '    \n', '    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '    \n', '     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n', '      \n', '        address owner = _owners[tokenId];\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }  \n', '  \n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '      \n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n', '        _transferHouse(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', ' \n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        private returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            msg.sender,\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ), "ERC721: transfer to non ERC721Receiver implementer");\n', '        bytes4 retval = abi.decode(returndata, (bytes4));\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '    \n', '    function transfer(address to, uint houseIndex) public {\n', '        _transferHouse(msg.sender, to, houseIndex);\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '        _transferHouse(from, to, tokenId);\n', '    }\n', '    \n', '    function _transferHouse(address from, address to, uint houseIndex) public {\n', '        require (_owners[houseIndex] == from);\n', '        require (houseIndex < totalSupply());\n', '        if (houseOfferedForSale[houseIndex].isForSale) {\n', '            houseNoLongerForSale(houseIndex);\n', '        }\n', '        \n', '        _approve(address(0), houseIndex);\n', '        \n', '        _owners[houseIndex] = to;\n', '        _balances[from]--;\n', '        _balances[to]++;\n', '        emit Transfer(from, to, houseIndex);\n', '        emit HouseTransfer(houseIndex, from, to);\n', '\n', '        Bid memory bid = houseBids[houseIndex];\n', '        if (bid.bidder == to) {\n', '  \n', '            pendingWithdrawals[to] += bid.value;\n', '            houseBids[houseIndex] = Bid(false, houseIndex, address(0), 0);\n', '        }\n', '    }\n', '\n', '    function houseNoLongerForSale(uint houseIndex) public {\n', '        require (_owners[houseIndex] == msg.sender);\n', '        require (houseIndex < totalSupply());\n', '        houseOfferedForSale[houseIndex] = Offer(false, houseIndex, msg.sender, 0, address(0));\n', '        emit HouseNoLongerForSaleEvent(houseIndex);\n', '    }\n', '\n', '    function offerHouseForSale(uint houseIndex, uint minSalePriceInWei) public {\n', '        require (_owners[houseIndex] == msg.sender);\n', '        require (houseIndex < totalSupply());\n', '        houseOfferedForSale[houseIndex] = Offer(true, houseIndex, msg.sender, minSalePriceInWei, address(0));\n', '        emit HouseOffered(houseIndex, minSalePriceInWei, address(0));\n', '    }\n', '\n', '    function offerHouseForSaleToAddress(uint houseIndex, uint minSalePriceInWei, address toAddress) public {\n', '        require (_owners[houseIndex] == msg.sender);\n', '        require (houseIndex < totalSupply());\n', '        houseOfferedForSale[houseIndex] = Offer(true, houseIndex, msg.sender, minSalePriceInWei, toAddress);\n', '        emit HouseOffered(houseIndex, minSalePriceInWei, toAddress);\n', '    }\n', '\n', '    function buyHouse(uint houseIndex) payable public {\n', '        Offer memory offer = houseOfferedForSale[houseIndex];\n', '        require (houseIndex < totalSupply());\n', '        require (offer.isForSale);              \n', '        require (offer.onlySellTo == address(0) || offer.onlySellTo == msg.sender);  \n', '        require (msg.value >= offer.minValue);    \n', '        require (offer.seller == _owners[houseIndex]); \n', '\n', '        address seller = offer.seller;\n', '\n', '        _owners[houseIndex] = msg.sender;\n', '        _balances[seller]--;\n', '        _balances[msg.sender]++;\n', '        emit Transfer(seller, msg.sender, houseIndex);\n', '\n', '        houseNoLongerForSale(houseIndex);\n', '        pendingWithdrawals[seller] += msg.value;\n', '        emit HouseBought(houseIndex, msg.value, seller, msg.sender);\n', '\n', '        Bid memory bid = houseBids[houseIndex];\n', '        if (bid.bidder == msg.sender) {\n', '            pendingWithdrawals[msg.sender] += bid.value;\n', '            houseBids[houseIndex] = Bid(false, houseIndex, address(0), 0);\n', '        }\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint amount = pendingWithdrawals[msg.sender];\n', '        pendingWithdrawals[msg.sender] = 0;\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function enterBidForHouse(uint houseIndex) payable public {\n', '        require (houseIndex < totalSupply());\n', '        require (_owners[houseIndex] != address(0));\n', '        require (_owners[houseIndex] != msg.sender);\n', '        require (msg.value != 0);\n', '        Bid memory existing = houseBids[houseIndex];\n', '        require (msg.value > existing.value);\n', '        if (existing.value > 0) {\n', '            pendingWithdrawals[existing.bidder] += existing.value;\n', '        }\n', '        houseBids[houseIndex] = Bid(true, houseIndex, msg.sender, msg.value);\n', '        emit HouseBidEntered(houseIndex, msg.value, msg.sender);\n', '    }\n', '\n', '    function acceptBidForHouse(uint houseIndex, uint minPrice) public {\n', '        require (houseIndex < totalSupply());\n', '        require (_owners[houseIndex] == msg.sender);\n', '        address seller = msg.sender;\n', '        Bid memory bid = houseBids[houseIndex];\n', '        require (bid.value != 0);\n', '        require (bid.value >= minPrice);\n', '\n', '        _owners[houseIndex] = bid.bidder;\n', '        _balances[seller]--;\n', '        _balances[bid.bidder]++;\n', '        emit Transfer(seller, bid.bidder, houseIndex);\n', '\n', '        houseOfferedForSale[houseIndex] = Offer(false, houseIndex, bid.bidder, 0, address(0));\n', '        uint amount = bid.value;\n', '        houseBids[houseIndex] = Bid(false, houseIndex, address(0), 0);\n', '        pendingWithdrawals[seller] += amount;\n', '        emit HouseBought(houseIndex, bid.value, seller, bid.bidder);\n', '    }\n', '\n', '    function withdrawBidForHouse(uint houseIndex) public {\n', '        require (houseIndex < totalSupply());\n', '        require (_owners[houseIndex] != address(0));\n', '        require (_owners[houseIndex] != msg.sender);\n', '        Bid memory bid = houseBids[houseIndex];\n', '        require (bid.bidder == msg.sender);\n', '        emit HouseBidWithdrawn(houseIndex, bid.value, msg.sender);\n', '        uint amount = bid.value;\n', '        houseBids[houseIndex] = Bid(false, houseIndex, address(0), 0);\n', '        msg.sender.transfer(amount);\n', '    }\n', '    \n', '    function addHouseInformation(uint houseIndex, string memory authorInfo, string memory publicInfo) public {\n', '        require (houseIndex < totalSupply());\n', '        require (_owners[houseIndex] == msg.sender || author == msg.sender);\n', '      \n', '        if(msg.sender == author){\n', '            houseInfo[houseIndex] = Info(houseIndex, authorInfo, publicInfo);\n', '        }else{\n', '            houseInfo[houseIndex] = Info(houseIndex, "", publicInfo);\n', '        }\n', '    }\n', '    \n', '    function offerHouseForSaleInBatch(uint[] memory houseIndex, uint[] memory minSalePriceInWei) public {\n', '        require (msg.sender == author);\n', '        uint n = houseIndex.length;\n', '        for (uint i = 0; i < n; i++) {\n', '            offerHouseForSale(houseIndex[i], minSalePriceInWei[i]);\n', '        }\n', '    }\n', '    \n', '    function getHouse(uint houseIndex) public payable {\n', '        require (houseRemainingToAssign != 0);\n', '        require (_owners[houseIndex] == address(0));\n', '        \n', '        if(msg.sender != author)\n', '        {\n', '            require (houseIndex < totalSupply() - 25);\n', '            require(msg.value >= 0.05 ether);\n', '            \n', '            author.transfer(msg.value);\n', '        }\n', '                \n', '        _owners[houseIndex] = msg.sender;\n', '        _balances[msg.sender]++;\n', '        houseRemainingToAssign--;\n', '        emit AssignHouse(houseIndex, msg.sender);\n', '        emit Transfer(address(0), msg.sender, houseIndex);\n', '    }\n', '}']