['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-21\n', '*/\n', '\n', '// Dependency file: contracts/Round.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// pragma solidity 0.6.12;\n', '\n', '\n', 'abstract contract RoundStorage {\n', '    // fee to owner of this game\n', '    // fee value = real fee percent value * (10**6)\n', '    uint256 public fee;\n', '\n', '    // amount players can bet\n', '    uint256 public amount;\n', '\n', '    // number of seconds of a round\n', '    uint public roundTime;\n', '\n', '    struct Round {\n', '        // round is over and calculated reward or no\n', '        bool finalized;\n', '\n', '        uint startTime;\n', '        uint endTime;\n', '        uint256 fee;\n', '        uint256 amount;\n', '    }\n', '\n', '    Round[] public rounds;\n', '}\n', '\n', 'contract Round is RoundStorage {\n', '    event Bet(uint256 indexed round, address indexed player, uint256 indexed amount);\n', '    event RoundStarted(uint256 indexed round);\n', '    event RoundEnded(uint256 indexed round);\n', '\n', '    function getCurrentRoundNumber() public view returns(uint256) {\n', '        if (rounds.length > 0) {\n', '            return rounds.length - 1;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function getCurrentRound() public view returns (uint256 number, uint start, uint end, uint256 betAmount) {\n', '        uint256 currentRoundNumber = getCurrentRoundNumber();\n', '        return (\n', '            currentRoundNumber,\n', '            rounds[currentRoundNumber].startTime,\n', '            rounds[currentRoundNumber].endTime,\n', '            rounds[currentRoundNumber].amount\n', '        );\n', '    }\n', '\n', '    function updateRoundFirstDeposit() internal {\n', '        uint256 currentRound = getCurrentRoundNumber();\n', '        if (rounds[currentRound].endTime == 0) {\n', '            rounds[currentRound].endTime = now + roundTime;\n', '        }\n', '    }\n', '\n', '    function roundOver() internal view returns(bool) {\n', '        uint256 currentRound = getCurrentRoundNumber();\n', '        if (rounds[currentRound].endTime == 0) {\n', '            return false;\n', '        } else {\n', '            return rounds[currentRound].endTime < now;\n', '        }\n', '    }\n', '\n', '    function newRound() internal {\n', '        rounds.push(Round({\n', '            finalized: false,\n', '            startTime: now,\n', '            endTime: 0, // the round start when have 1 deposit\n', '            fee: fee,\n', '            amount: amount\n', '        }));\n', '\n', '        emit RoundStarted(getCurrentRoundNumber());\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: contracts/TransferHelper.sol\n', '\n', '\n', '// pragma solidity >=0.6.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '\n', '// pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: contracts/Balance.sol\n', '\n', '\n', '// pragma solidity 0.6.12;\n', '\n', '// import "contracts/TransferHelper.sol";\n', '// import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '\n', 'abstract contract BalanceStorage {\n', '    mapping(address => uint256) public balances;\n', '}\n', '\n', 'contract Balance is BalanceStorage {\n', '    using SafeMath for uint256;\n', '\n', '    // user claim their reward\n', '    function claim() public {\n', '        TransferHelper.safeTransferETH(msg.sender, balances[msg.sender]);\n', '        balances[msg.sender] = 0;\n', '    }\n', '\n', '    function addBalance(address _user, uint256 _amount) internal {\n', '        balances[_user] = balances[_user].add(_amount);\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: contracts/Maintainer.sol\n', '\n', '\n', '// pragma solidity 0.6.12;\n', '\n', '\n', 'abstract contract Maintainer {\n', '    address public maintainer;\n', '\n', '    modifier onlyMaintainer() {\n', '        require(msg.sender == maintainer, "ERROR: permission denied, only maintainer");\n', '        _;\n', '    }\n', '\n', '    function setMaintainer(address _maintainer) external virtual;\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/GSN/Context.sol\n', '\n', '\n', '// pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/access/Ownable.sol\n', '\n', '\n', '// pragma solidity ^0.6.0;\n', '\n', '// import "@openzeppelin/contracts/GSN/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '// Root file: contracts/PingPong.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// import "contracts/Round.sol";\n', '// import "contracts/Balance.sol";\n', '// import "contracts/Maintainer.sol";\n', '// import "contracts/TransferHelper.sol";\n', '// import "@openzeppelin/contracts/math/SafeMath.sol";\n', '// import "@openzeppelin/contracts/access/Ownable.sol";\n', '\n', '\n', '// ping pong game\n', '// every user choose ping or pong\n', '// at the end time, contract random ping or pong as winners\n', 'contract PingPong is Ownable, Round, Balance, Maintainer {\n', '    using SafeMath for uint256;\n', '\n', '    event Bet(uint256 indexed round, address indexed player, uint256 indexed amount, uint choice);\n', '\n', '    enum Choice {\n', '        PING, PONG\n', '    }\n', '\n', '    enum State {\n', '        UNDEFINED, WIN, LOSE, REFUND\n', '    }\n', '\n', '    struct Player {\n', '        address payable addr;\n', '        uint256 balance;\n', '\n', '        Choice choice;\n', '\n', '        // random number used for random algorithm\n', '        uint256 randomSeed;\n', '\n', '        State state;\n', '    }\n', '\n', '    mapping(uint256 => Player[]) public players;\n', '\n', '    constructor(\n', '        uint256 _fee,\n', '        uint256 _amount,\n', '        uint256 _roundTime,\n', '        address _maintainer\n', '    ) public {\n', '        fee = _fee;\n', '        amount = _amount;\n', '        roundTime = _roundTime;\n', '        maintainer = _maintainer;\n', '\n', '        newRound();\n', '    }\n', '\n', '    // get total bet in this round\n', '    function getCurrentRoundBalance() public view returns(uint256 balance) {\n', '        uint256 currentRound = getCurrentRoundNumber();\n', '\n', '        uint256 total;\n', '        for (uint256 i=0; i<players[currentRound].length; i++) {\n', '            total = total.add(players[currentRound][i].balance);\n', '        }\n', '        return total;\n', '    }\n', '\n', '    // player get their info in single round\n', '    function getPlayer(uint256 _round, address payable _player) public view returns(uint256 playerBet, Choice playerChoice, State playerState) {\n', '        for (uint256 i=0; i<players[_round].length; i++) {\n', '            if (players[_round][i].addr == _player) {\n', '                return (players[_round][i].balance, players[_round][i].choice, players[_round][i].state);\n', '            }\n', '        }\n', '\n', '        return (0, Choice.PING, State.UNDEFINED);\n', '    }\n', '\n', '    // get total players of current round\n', '    function getRoundPlayers(uint256 _round) public view returns(uint256) {\n', '        return players[_round].length;\n', '    }\n', '\n', '    function getRoundChoices(uint256 _round) public view returns(uint256 totalPing, uint256 totalPong) {\n', '        uint256 ping;\n', '        uint256 pong;\n', '        for (uint256 i=0; i<players[_round].length; i++) {\n', '            if (players[_round][i].choice == Choice.PING) ping++;\n', '            else pong++;\n', '        }\n', '        return (ping, pong);\n', '    }\n', '\n', '    function bet(uint _pingPong, uint256 _randomSeed) public payable {\n', '        uint256 currentRound = getCurrentRoundNumber();\n', '        require(msg.value == rounds[currentRound].amount, "ERROR: amount not allowed");\n', '        if (rounds[currentRound].endTime !=0 )\n', '            require(rounds[currentRound].endTime >= now, "ERROR: round is over");\n', '\n', '        bool isBet;\n', '        for (uint256 i=0; i<players[currentRound].length; i++) {\n', '            if (players[currentRound][i].addr == msg.sender) {\n', '                isBet = true;\n', '            }\n', '        }\n', '\n', '        require(isBet == false, "ERROR: already bet");\n', '\n', '        if (!isBet) {\n', '            players[currentRound].push(Player({\n', '                addr: msg.sender,\n', '                balance: msg.value,\n', '                randomSeed: _randomSeed,\n', '                choice: Choice(_pingPong),\n', '                state: State.UNDEFINED\n', '            }));\n', '            updateRoundFirstDeposit();\n', '            emit Bet(currentRound, msg.sender, msg.value, _pingPong);\n', '        }\n', '    }\n', '\n', '    // calculate winners and profit\n', '    function _calculate(uint256 _round) internal {\n', '        uint256 totalPing;\n', '        uint256 totalPong;\n', '        uint256 totalReward;\n', '        for (uint256 i=0 ;i<players[_round].length; i++) {\n', '            if (players[_round][i].choice == Choice.PING) {\n', '                totalPing = totalPing.add(1);\n', '            } else {\n', '                totalPong = totalPong.add(1);\n', '            }\n', '\n', '            totalReward = totalReward.add(players[_round][i].balance);\n', '        }\n', '\n', '        if (totalPing == 0 || totalPong == 0) {\n', '            // not enough players to play the game\n', '            // refund to user\n', '            for (uint256 i=0 ;i<players[_round].length; i++) {\n', '                TransferHelper.safeTransferETH(players[_round][i].addr, players[_round][i].balance);\n', '                players[_round][i].state = State.REFUND;\n', '            }\n', '        } else {\n', '            uint256 feeAmount = totalReward.mul(fee).div(100).div(10**6);\n', '            TransferHelper.safeTransferETH(owner(), feeAmount);\n', '            totalReward = totalReward.sub(feeAmount);\n', '\n', '            uint256 winAmount;\n', '            Choice theWinner = Choice(_random(_round));\n', '\n', '            if (theWinner == Choice.PING) {\n', '                winAmount = totalReward.div(totalPing);\n', '            } else {\n', '                winAmount = totalReward.div(totalPong);\n', '            }\n', '\n', '            // update winner reward and state\n', '            for (uint256 i=0; i<players[_round].length; i++) {\n', '                if (players[_round][i].choice == theWinner) {\n', '                    players[_round][i].state = State.WIN;\n', '                    players[_round][i].balance = winAmount;\n', '                    addBalance(players[_round][i].addr, winAmount);\n', '                    totalReward = totalReward.sub(winAmount);\n', '                } else {\n', '                    players[_round][i].state = State.LOSE;\n', '                }\n', '            }\n', '\n', '            if (totalReward > 0) {\n', '                TransferHelper.safeTransferETH(owner(), totalReward);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _random(uint256 _round) internal view returns(uint256) {\n', '        uint256 playersNumber;\n', '        for (uint256 i=0; i<players[_round].length; i++) {\n', '            playersNumber = playersNumber.add(players[_round][i].randomSeed);\n', '        }\n', '\n', '        return (uint256(keccak256(abi.encodePacked(block.difficulty, now, playersNumber))) % 2);\n', '    }\n', '\n', '    // open new round\n', '    function _open() internal {\n', '        newRound();\n', '    }\n', '\n', '    function _end() internal {\n', '        uint256 currentRound = getCurrentRoundNumber();\n', '        _calculate(currentRound);\n', '        rounds[currentRound].finalized = true;\n', '\n', '        emit RoundEnded(currentRound);\n', '    }\n', '\n', '    function setRules(uint256 _fee, uint256 _amount, uint256 _roundTime) public onlyOwner {\n', '        fee = _fee;\n', '        amount = _amount;\n', '        roundTime = _roundTime;\n', '    }\n', '\n', '    function setMaintainer(address _maintainer) public override onlyOwner {\n', '        maintainer = _maintainer;\n', '    }\n', '\n', '    // require the round is over\n', '    // only maintainer address can trigger\n', '    function reset() public onlyMaintainer {\n', '        require(roundOver(), "ERROR: round is not over");\n', '        _end();\n', '        _open();\n', '    }\n', '}']