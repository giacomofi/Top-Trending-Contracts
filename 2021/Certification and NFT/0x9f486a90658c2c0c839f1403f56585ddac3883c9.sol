['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-18\n', '*/\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following \n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/upgrades/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/InitializableV2.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '\n', '/**\n', " * Wrapper around OpenZeppelin's Initializable contract.\n", ' * Exposes initialized state management to ensure logic contract functions cannot be called before initialization.\n', " * This is needed because OZ's Initializable contract no longer exposes initialized state variable.\n", ' * https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.8.0/packages/lib/contracts/Initializable.sol\n', ' */\n', 'contract InitializableV2 is Initializable {\n', '    bool private isInitialized;\n', '\n', '    string private constant ERROR_NOT_INITIALIZED = "InitializableV2: Not initialized";\n', '\n', '    /**\n', "     * @notice wrapper function around parent contract Initializable's `initializable` modifier\n", '     *      initializable modifier ensures this function can only be called once by each deployed child contract\n', '     *      sets isInitialized flag to true to which is used by _requireIsInitialized()\n', '     */\n', '    function initialize() public initializer {\n', '        isInitialized = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts transaction if isInitialized is false. Used by child contracts to ensure\n', '     *      contract is initialized before functions can be called.\n', '     */\n', '    function _requireIsInitialized() internal view {\n', '        require(isInitialized == true, ERROR_NOT_INITIALIZED);\n', '    }\n', '\n', '    /**\n', '     * @notice Exposes isInitialized bool var to child contracts with read-only access\n', '     */\n', '    function _isInitialized() internal view returns (bool) {\n', '        return isInitialized;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Initializable, Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'contract ERC20Burnable is Initializable, Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_burnFrom}.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public {\n', '        _burnFrom(account, amount);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: @aragon/court/contracts/lib/Checkpointing.sol\n', '\n', 'pragma solidity ^0.5.8;\n', '\n', '\n', '/**\n', '* @title Checkpointing - Library to handle a historic set of numeric values\n', '*/\n', 'library Checkpointing {\n', '    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\n', '\n', '    string private constant ERROR_VALUE_TOO_BIG = "CHECKPOINT_VALUE_TOO_BIG";\n', '    string private constant ERROR_CANNOT_ADD_PAST_VALUE = "CHECKPOINT_CANNOT_ADD_PAST_VALUE";\n', '\n', '    /**\n', '    * @dev To specify a value at a given point in time, we need to store two values:\n', '    *      - `time`: unit-time value to denote the first time when a value was registered\n', '    *      - `value`: a positive numeric value to registered at a given point in time\n', '    *\n', '    *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\n', '    *      for it like block numbers, terms, etc.\n', '    */\n', '    struct Checkpoint {\n', '        uint64 time;\n', '        uint192 value;\n', '    }\n', '\n', '    /**\n', '    * @dev A history simply denotes a list of checkpoints\n', '    */\n', '    struct History {\n', '        Checkpoint[] history;\n', '    }\n', '\n', '    /**\n', '    * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\n', '    *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\n', '    *      will be updated.\n', '    * @param self Checkpoints history to be altered\n', '    * @param _time Point in time to register the given value\n', '    * @param _value Numeric value to be registered at the given point in time\n', '    */\n', '    function add(History storage self, uint64 _time, uint256 _value) internal {\n', '        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\n', '        _add192(self, _time, uint192(_value));\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\n', '    * @param self Checkpoints history to be queried\n', '    */\n', '    function getLast(History storage self) internal view returns (uint256) {\n', '        uint256 length = self.history.length;\n', '        if (length > 0) {\n', '            return uint256(self.history[length - 1].value);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\n', '    *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\n', '    *      previous to the first registered value.\n', '    *      It uses a binary search.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function get(History storage self, uint64 _time) internal view returns (uint256) {\n', '        return _binarySearch(self, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the most recent registered past value of a history based on a given point in time. It will return zero\n', '    *      if there is no registered value or if given time is previous to the first registered value.\n', '    *      It uses a linear search starting from the end.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function getRecent(History storage self, uint64 _time) internal view returns (uint256) {\n', '        return _backwardsLinearSearch(self, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\n', '    *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\n', '    *      registered value, it will be updated.\n', '    * @param self Checkpoints history to be altered\n', '    * @param _time Point in time to register the given value\n', '    * @param _value Numeric value to be registered at the given point in time\n', '    */\n', '    function _add192(History storage self, uint64 _time, uint192 _value) private {\n', '        uint256 length = self.history.length;\n', '        if (length == 0 || self.history[self.history.length - 1].time < _time) {\n', '            // If there was no value registered or the given point in time is after the latest registered value,\n', '            // we can insert it to the history directly.\n', '            self.history.push(Checkpoint(_time, _value));\n', '        } else {\n', '            // If the point in time given for the new value is not after the latest registered value, we must ensure\n', '            // we are only trying to update the latest value, otherwise we would be changing past data.\n', '            Checkpoint storage currentCheckpoint = self.history[length - 1];\n', '            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\n', '            currentCheckpoint.value = _value;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to execute a backwards linear search to find the most recent registered past value of a\n', '    *      history based on a given point in time. It will return zero if there is no registered value or if given time\n', '    *      is previous to the first registered value. Note that this function will be more suitable when we already know\n', '    *      that the time used to index the search is recent in the given history.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {\n', '        // If there was no value registered for the given history return simply zero\n', '        uint256 length = self.history.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 index = length - 1;\n', '        Checkpoint storage checkpoint = self.history[index];\n', '        while (index > 0 && checkpoint.time > _time) {\n', '            index--;\n', '            checkpoint = self.history[index];\n', '        }\n', '\n', '        return checkpoint.time > _time ? 0 : uint256(checkpoint.value);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function execute a binary search to find the most recent registered past value of a history based on\n', '    *      a given point in time. It will return zero if there is no registered value or if given time is previous to\n', "    *      the first registered value. Note that this function will be more suitable when don't know how recent the\n", '    *      time used to index may be.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\n', '        // If there was no value registered for the given history return simply zero\n', '        uint256 length = self.history.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // If the requested time is equal to or after the time of the latest registered value, return latest value\n', '        uint256 lastIndex = length - 1;\n', '        if (_time >= self.history[lastIndex].time) {\n', '            return uint256(self.history[lastIndex].value);\n', '        }\n', '\n', '        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\n', '        if (_time < self.history[0].time) {\n', '            return 0;\n', '        }\n', '\n', '        // Execute a binary search between the checkpointed times of the history\n', '        uint256 low = 0;\n', '        uint256 high = lastIndex;\n', '\n', '        while (high > low) {\n', '            // No need for SafeMath: for this to overflow array size should be ~2^255\n', '            uint256 mid = (high + low + 1) / 2;\n', '            Checkpoint storage checkpoint = self.history[mid];\n', '            uint64 midTime = checkpoint.time;\n', '\n', '            if (_time > midTime) {\n', '                low = mid;\n', '            } else if (_time < midTime) {\n', '                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\n', '                high = mid - 1;\n', '            } else {\n', '                return uint256(checkpoint.value);\n', '            }\n', '        }\n', '\n', '        return uint256(self.history[low].value);\n', '    }\n', '}\n', '\n', '// File: @aragon/court/contracts/lib/os/Uint256Helpers.sol\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\n', '// Adapted to use pragma ^0.5.8 and satisfy our linter rules\n', '\n', 'pragma solidity ^0.5.8;\n', '\n', '\n', 'library Uint256Helpers {\n', '    uint256 private constant MAX_UINT8 = uint8(-1);\n', '    uint256 private constant MAX_UINT64 = uint64(-1);\n', '\n', '    string private constant ERROR_UINT8_NUMBER_TOO_BIG = "UINT8_NUMBER_TOO_BIG";\n', '    string private constant ERROR_UINT64_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";\n', '\n', '    function toUint8(uint256 a) internal pure returns (uint8) {\n', '        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\n', '        return uint8(a);\n', '    }\n', '\n', '    function toUint64(uint256 a) internal pure returns (uint64) {\n', '        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\n', '        return uint64(a);\n', '    }\n', '}\n', '\n', '// File: contracts/Staking.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Staking is InitializableV2 {\n', '    using SafeMath for uint256;\n', '    using Uint256Helpers for uint256;\n', '    using Checkpointing for Checkpointing.History;\n', '    using SafeERC20 for ERC20;\n', '\n', '    string private constant ERROR_TOKEN_NOT_CONTRACT = "Staking: Staking token is not a contract";\n', '    string private constant ERROR_AMOUNT_ZERO = "Staking: Zero amount not allowed";\n', '    string private constant ERROR_ONLY_GOVERNANCE = "Staking: Only governance";\n', '    string private constant ERROR_ONLY_DELEGATE_MANAGER = (\n', '      "Staking: Only callable from DelegateManager"\n', '    );\n', '    string private constant ERROR_ONLY_SERVICE_PROVIDER_FACTORY = (\n', '      "Staking: Only callable from ServiceProviderFactory"\n', '    );\n', '\n', '    address private governanceAddress;\n', '    address private claimsManagerAddress;\n', '    address private delegateManagerAddress;\n', '    address private serviceProviderFactoryAddress;\n', '\n', '    /// @dev stores the history of staking and claims for a given address\n', '    struct Account {\n', '        Checkpointing.History stakedHistory;\n', '        Checkpointing.History claimHistory;\n', '    }\n', '\n', '    /// @dev ERC-20 token that will be used to stake with\n', '    ERC20 internal stakingToken;\n', '\n', '    /// @dev maps addresses to staking and claims history\n', '    mapping (address => Account) internal accounts;\n', '\n', '    /// @dev total staked tokens at a given block\n', '    Checkpointing.History internal totalStakedHistory;\n', '\n', '    event Staked(address indexed user, uint256 amount, uint256 total);\n', '    event Unstaked(address indexed user, uint256 amount, uint256 total);\n', '    event Slashed(address indexed user, uint256 amount, uint256 total);\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\n', '     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\n', '     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\n', '     * @param _tokenAddress - address of ERC20 token that will be staked\n', '     * @param _governanceAddress - address for Governance proxy contract\n', '     */\n', '    function initialize(\n', '        address _tokenAddress,\n', '        address _governanceAddress\n', '    ) public initializer\n', '    {\n', '        require(Address.isContract(_tokenAddress), ERROR_TOKEN_NOT_CONTRACT);\n', '        stakingToken = ERC20(_tokenAddress);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ClaimsManaager address\n', '     * @dev Only callable by Governance address\n', '     * @param _claimsManager - address for new ClaimsManaager contract\n', '     */\n', '    function setClaimsManagerAddress(address _claimsManager) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        claimsManagerAddress = _claimsManager;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ServiceProviderFactory address\n', '     * @dev Only callable by Governance address\n', '     * @param _spFactory - address for new ServiceProviderFactory contract\n', '     */\n', '    function setServiceProviderFactoryAddress(address _spFactory) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        serviceProviderFactoryAddress = _spFactory;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the DelegateManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _delegateManager - address for new DelegateManager contract\n', '     */\n', '    function setDelegateManagerAddress(address _delegateManager) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        delegateManagerAddress = _delegateManager;\n', '    }\n', '\n', '    /* External functions */\n', '\n', '    /**\n', '     * @notice Funds `_amount` of tokens from ClaimsManager to target account\n', '     * @param _amount - amount of rewards to  add to stake\n', '     * @param _stakerAccount - address of staker\n', '     */\n', '    function stakeRewards(uint256 _amount, address _stakerAccount) external {\n', '        _requireIsInitialized();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == claimsManagerAddress,\n', '            "Staking: Only callable from ClaimsManager"\n', '        );\n', '        _stakeFor(_stakerAccount, msg.sender, _amount);\n', '\n', '        this.updateClaimHistory(_amount, _stakerAccount);\n', '    }\n', '\n', '    /**\n', '     * @notice Update claim history by adding an event to the claim history\n', '     * @param _amount - amount to add to claim history\n', '     * @param _stakerAccount - address of staker\n', '     */\n', '    function updateClaimHistory(uint256 _amount, address _stakerAccount) external {\n', '        _requireIsInitialized();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == claimsManagerAddress || msg.sender == address(this),\n', '            "Staking: Only callable from ClaimsManager or Staking.sol"\n', '        );\n', '\n', '        // Update claim history even if no value claimed\n', '        accounts[_stakerAccount].claimHistory.add(block.number.toUint64(), _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Slashes `_amount` tokens from _slashAddress\n', '     * @dev Callable from DelegateManager\n', '     * @param _amount - Number of tokens slashed\n', '     * @param _slashAddress - Address being slashed\n', '     */\n', '    function slash(\n', '        uint256 _amount,\n', '        address _slashAddress\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == delegateManagerAddress,\n', '            ERROR_ONLY_DELEGATE_MANAGER\n', '        );\n', '\n', '        // Burn slashed tokens from account\n', '        _burnFor(_slashAddress, _amount);\n', '\n', '        emit Slashed(\n', '            _slashAddress,\n', '            _amount,\n', '            totalStakedFor(_slashAddress)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Stakes `_amount` tokens, transferring them from _accountAddress, and assigns them to `_accountAddress`\n', '     * @param _accountAddress - The final staker of the tokens\n', '     * @param _amount - Number of tokens staked\n', '     */\n', '    function stakeFor(\n', '        address _accountAddress,\n', '        uint256 _amount\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == serviceProviderFactoryAddress,\n', '            ERROR_ONLY_SERVICE_PROVIDER_FACTORY\n', '        );\n', '        _stakeFor(\n', '            _accountAddress,\n', '            _accountAddress,\n', '            _amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Unstakes `_amount` tokens, returning them to the desired account.\n', '     * @param _accountAddress - Account unstaked for, and token recipient\n', '     * @param _amount - Number of tokens staked\n', '     */\n', '    function unstakeFor(\n', '        address _accountAddress,\n', '        uint256 _amount\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == serviceProviderFactoryAddress,\n', '            ERROR_ONLY_SERVICE_PROVIDER_FACTORY\n', '        );\n', '        _unstakeFor(\n', '            _accountAddress,\n', '            _accountAddress,\n', '            _amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Stakes `_amount` tokens, transferring them from `_delegatorAddress` to `_accountAddress`,\n', '               only callable by DelegateManager\n', '     * @param _accountAddress - The final staker of the tokens\n', '     * @param _delegatorAddress - Address from which to transfer tokens\n', '     * @param _amount - Number of tokens staked\n', '     */\n', '    function delegateStakeFor(\n', '        address _accountAddress,\n', '        address _delegatorAddress,\n', '        uint256 _amount\n', '    ) external {\n', '        _requireIsInitialized();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == delegateManagerAddress,\n', '            ERROR_ONLY_DELEGATE_MANAGER\n', '        );\n', '        _stakeFor(\n', '            _accountAddress,\n', '            _delegatorAddress,\n', '            _amount);\n', '    }\n', '\n', '    /**\n', "     * @notice Unstakes '_amount` tokens, transferring them from `_accountAddress` to `_delegatorAddress`,\n", '               only callable by DelegateManager\n', '     * @param _accountAddress - The staker of the tokens\n', '     * @param _delegatorAddress - Address from which to transfer tokens\n', '     * @param _amount - Number of tokens unstaked\n', '     */\n', '    function undelegateStakeFor(\n', '        address _accountAddress,\n', '        address _delegatorAddress,\n', '        uint256 _amount\n', '    ) external {\n', '        _requireIsInitialized();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == delegateManagerAddress,\n', '            ERROR_ONLY_DELEGATE_MANAGER\n', '        );\n', '        _unstakeFor(\n', '            _accountAddress,\n', '            _delegatorAddress,\n', '            _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token used by the contract for staking and locking\n', '     * @return The token used by the contract for staking and locking\n', '     */\n', '    function token() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return address(stakingToken);\n', '    }\n', '\n', '    /**\n', '     * @notice Check whether it supports history of stakes\n', '     * @return Always true\n', '     */\n', '    function supportsHistory() external view returns (bool) {\n', '        _requireIsInitialized();\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Get last time `_accountAddress` modified its staked balance\n', '     * @param _accountAddress - Account requesting for\n', "     * @return Last block number when account's balance was modified\n", '     */\n', '    function lastStakedFor(address _accountAddress) external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        uint256 length = accounts[_accountAddress].stakedHistory.history.length;\n', '        if (length > 0) {\n', '            return uint256(accounts[_accountAddress].stakedHistory.history[length - 1].time);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Get last time `_accountAddress` claimed a staking reward\n', '     * @param _accountAddress - Account requesting for\n', '     * @return Last block number when claim requested\n', '     */\n', '    function lastClaimedFor(address _accountAddress) external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        uint256 length = accounts[_accountAddress].claimHistory.history.length;\n', '        if (length > 0) {\n', '            return uint256(accounts[_accountAddress].claimHistory.history[length - 1].time);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the total amount of tokens staked by `_accountAddress` at block number `_blockNumber`\n', '     * @param _accountAddress - Account requesting for\n', '     * @param _blockNumber - Block number at which we are requesting\n', '     * @return The amount of tokens staked by the account at the given block number\n', '     */\n', '    function totalStakedForAt(\n', '        address _accountAddress,\n', '        uint256 _blockNumber\n', '    ) external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return accounts[_accountAddress].stakedHistory.get(_blockNumber.toUint64());\n', '    }\n', '\n', '    /**\n', '     * @notice Get the total amount of tokens staked by all users at block number `_blockNumber`\n', '     * @param _blockNumber - Block number at which we are requesting\n', '     * @return The amount of tokens staked at the given block number\n', '     */\n', '    function totalStakedAt(uint256 _blockNumber) external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return totalStakedHistory.get(_blockNumber.toUint64());\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /// @notice Get the ClaimsManager address\n', '    function getClaimsManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return claimsManagerAddress;\n', '    }\n', '\n', '    /// @notice Get the ServiceProviderFactory address\n', '    function getServiceProviderFactoryAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderFactoryAddress;\n', '    }\n', '\n', '    /// @notice Get the DelegateManager address\n', '    function getDelegateManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return delegateManagerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Helper function wrapped around totalStakedFor. Checks whether _accountAddress\n', '            is currently a valid staker with a non-zero stake\n', '     * @param _accountAddress - Account requesting for\n', '     * @return Boolean indicating whether account is a staker\n', '     */\n', '    function isStaker(address _accountAddress) external view returns (bool) {\n', '        _requireIsInitialized();\n', '\n', '        return totalStakedFor(_accountAddress) > 0;\n', '    }\n', '\n', '    /* Public functions */\n', '\n', '    /**\n', '     * @notice Get the amount of tokens staked by `_accountAddress`\n', '     * @param _accountAddress - The owner of the tokens\n', '     * @return The amount of tokens staked by the given account\n', '     */\n', '    function totalStakedFor(address _accountAddress) public view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', "        // we assume it's not possible to stake in the future\n", '        return accounts[_accountAddress].stakedHistory.getLast();\n', '    }\n', '\n', '    /**\n', '     * @notice Get the total amount of tokens staked by all users\n', '     * @return The total amount of tokens staked by all users\n', '     */\n', '    function totalStaked() public view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', "        // we assume it's not possible to stake in the future\n", '        return totalStakedHistory.getLast();\n', '    }\n', '\n', '    // ========================================= Internal Functions =========================================\n', '\n', '    /**\n', '     * @notice Adds stake from a transfer account to the stake account\n', '     * @param _stakeAccount - Account that funds will be staked for\n', '     * @param _transferAccount - Account that funds will be transferred from\n', '     * @param _amount - amount to stake\n', '     */\n', '    function _stakeFor(\n', '        address _stakeAccount,\n', '        address _transferAccount,\n', '        uint256 _amount\n', '    ) internal\n', '    {\n', '        // staking 0 tokens is invalid\n', '        require(_amount > 0, ERROR_AMOUNT_ZERO);\n', '\n', '        // Checkpoint updated staking balance\n', '        _modifyStakeBalance(_stakeAccount, _amount, true);\n', '\n', '        // checkpoint total supply\n', '        _modifyTotalStaked(_amount, true);\n', '\n', '        // pull tokens into Staking contract\n', '        stakingToken.safeTransferFrom(_transferAccount, address(this), _amount);\n', '\n', '        emit Staked(\n', '            _stakeAccount,\n', '            _amount,\n', '            totalStakedFor(_stakeAccount));\n', '    }\n', '\n', '    /**\n', '     * @notice Unstakes tokens from a stake account to a transfer account\n', '     * @param _stakeAccount - Account that staked funds will be transferred from\n', '     * @param _transferAccount - Account that funds will be transferred to\n', '     * @param _amount - amount to unstake\n', '     */\n', '    function _unstakeFor(\n', '        address _stakeAccount,\n', '        address _transferAccount,\n', '        uint256 _amount\n', '    ) internal\n', '    {\n', '        require(_amount > 0, ERROR_AMOUNT_ZERO);\n', '\n', '        // checkpoint updated staking balance\n', '        _modifyStakeBalance(_stakeAccount, _amount, false);\n', '\n', '        // checkpoint total supply\n', '        _modifyTotalStaked(_amount, false);\n', '\n', '        // transfer tokens\n', '        stakingToken.safeTransfer(_transferAccount, _amount);\n', '\n', '        emit Unstaked(\n', '            _stakeAccount,\n', '            _amount,\n', '            totalStakedFor(_stakeAccount)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Burn tokens for a given staker\n', '     * @dev Called when slash occurs\n', '     * @param _stakeAccount - Account for which funds will be burned\n', '     * @param _amount - amount to burn\n', '     */\n', '    function _burnFor(address _stakeAccount, uint256 _amount) internal {\n', '        // burning zero tokens is not allowed\n', '        require(_amount > 0, ERROR_AMOUNT_ZERO);\n', '\n', '        // checkpoint updated staking balance\n', '        _modifyStakeBalance(_stakeAccount, _amount, false);\n', '\n', '        // checkpoint total supply\n', '        _modifyTotalStaked(_amount, false);\n', '\n', '        // burn\n', '        ERC20Burnable(address(stakingToken)).burn(_amount);\n', '\n', '        /** No event emitted since token.burn() call already emits a Transfer event */\n', '    }\n', '\n', '    /**\n', '     * @notice Increase or decrease the staked balance for an account\n', '     * @param _accountAddress - Account to modify\n', '     * @param _by - amount to modify\n', '     * @param _increase - true if increase in stake, false if decrease\n', '     */\n', '    function _modifyStakeBalance(address _accountAddress, uint256 _by, bool _increase) internal {\n', '        uint256 currentInternalStake = accounts[_accountAddress].stakedHistory.getLast();\n', '\n', '        uint256 newStake;\n', '        if (_increase) {\n', '            newStake = currentInternalStake.add(_by);\n', '        } else {\n', '            require(\n', '                currentInternalStake >= _by,\n', '                "Staking: Cannot decrease greater than current balance");\n', '            newStake = currentInternalStake.sub(_by);\n', '        }\n', '\n', '        // add new value to account history\n', '        accounts[_accountAddress].stakedHistory.add(block.number.toUint64(), newStake);\n', '    }\n', '\n', '    /**\n', '     * @notice Increase or decrease the staked balance across all accounts\n', '     * @param _by - amount to modify\n', '     * @param _increase - true if increase in stake, false if decrease\n', '     */\n', '    function _modifyTotalStaked(uint256 _by, bool _increase) internal {\n', '        uint256 currentStake = totalStaked();\n', '\n', '        uint256 newStake;\n', '        if (_increase) {\n', '            newStake = currentStake.add(_by);\n', '        } else {\n', '            newStake = currentStake.sub(_by);\n', '        }\n', '\n', '        // add new value to total history\n', '        totalStakedHistory.add(block.number.toUint64(), newStake);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) internal {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "Staking: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '\n', '    // ========================================= Private Functions =========================================\n', '\n', '    function _requireClaimsManagerAddressIsSet() private view {\n', '        require(claimsManagerAddress != address(0x00), "Staking: claimsManagerAddress is not set");\n', '    }\n', '\n', '    function _requireDelegateManagerAddressIsSet() private view {\n', '        require(\n', '            delegateManagerAddress != address(0x00),\n', '            "Staking: delegateManagerAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireServiceProviderFactoryAddressIsSet() private view {\n', '        require(\n', '            serviceProviderFactoryAddress != address(0x00),\n', '            "Staking: serviceProviderFactoryAddress is not set"\n', '        );\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/ServiceTypeManager.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', 'contract ServiceTypeManager is InitializableV2 {\n', '    address governanceAddress;\n', '\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "ServiceTypeManager: Only callable by Governance contract"\n', '    );\n', '\n', '    /**\n', '     * @dev - mapping of serviceType - serviceTypeVersion\n', '     * Example - "discovery-provider" - ["0.0.1", "0.0.2", ..., "currentVersion"]\n', '     */\n', '    mapping(bytes32 => bytes32[]) private serviceTypeVersions;\n', '\n', '    /**\n', '     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n', '     * Example - "discovery-provider" - <"0.0.1", true>\n', '     */\n', '    mapping(bytes32 => mapping(bytes32 => bool)) private serviceTypeVersionInfo;\n', '\n', '    /// @dev List of valid service types\n', '    bytes32[] private validServiceTypes;\n', '\n', '    /// @dev Struct representing service type info\n', '    struct ServiceTypeInfo {\n', '        bool isValid;\n', '        uint256 minStake;\n', '        uint256 maxStake;\n', '    }\n', '\n', '    /// @dev mapping of service type info\n', '    mapping(bytes32 => ServiceTypeInfo) private serviceTypeInfo;\n', '\n', '    event SetServiceVersion(\n', '        bytes32 indexed _serviceType,\n', '        bytes32 indexed _serviceVersion\n', '    );\n', '\n', '    event ServiceTypeAdded(\n', '        bytes32 indexed _serviceType,\n', '        uint256 indexed _serviceTypeMin,\n', '        uint256 indexed _serviceTypeMax\n', '    );\n', '\n', '    event ServiceTypeRemoved(bytes32 indexed _serviceType);\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @param _governanceAddress - Governance proxy address\n', '     */\n', '    function initialize(address _governanceAddress) public initializer\n', '    {\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '    }\n', '\n', '    // ========================================= Service Type Logic =========================================\n', '\n', '    /**\n', '     * @notice Add a new service type\n', '     * @param _serviceType - type of service to add\n', '     * @param _serviceTypeMin - minimum stake for service type\n', '     * @param _serviceTypeMax - maximum stake for service type\n', '     */\n', '    function addServiceType(\n', '        bytes32 _serviceType,\n', '        uint256 _serviceTypeMin,\n', '        uint256 _serviceTypeMax\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        require(\n', '            !this.serviceTypeIsValid(_serviceType),\n', '            "ServiceTypeManager: Already known service type"\n', '        );\n', '        require(\n', '            _serviceTypeMax > _serviceTypeMin,\n', '            "ServiceTypeManager: Max stake must be non-zero and greater than min stake"\n', '        );\n', '\n', '        // Ensure serviceType cannot be re-added if it previously existed and was removed\n', '        // stored maxStake > 0 means it was previously added and removed\n', '        require(\n', '            serviceTypeInfo[_serviceType].maxStake == 0,\n', '            "ServiceTypeManager: Cannot re-add serviceType after it was removed."\n', '        );\n', '\n', '        validServiceTypes.push(_serviceType);\n', '        serviceTypeInfo[_serviceType] = ServiceTypeInfo({\n', '            isValid: true,\n', '            minStake: _serviceTypeMin,\n', '            maxStake: _serviceTypeMax\n', '        });\n', '\n', '        emit ServiceTypeAdded(_serviceType, _serviceTypeMin, _serviceTypeMax);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove an existing service type\n', '     * @param _serviceType - name of service type to remove\n', '     */\n', '    function removeServiceType(bytes32 _serviceType) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        uint256 serviceIndex = 0;\n', '        bool foundService = false;\n', '        for (uint256 i = 0; i < validServiceTypes.length; i ++) {\n', '            if (validServiceTypes[i] == _serviceType) {\n', '                serviceIndex = i;\n', '                foundService = true;\n', '                break;\n', '            }\n', '        }\n', '        require(foundService == true, "ServiceTypeManager: Invalid service type, not found");\n', '        // Overwrite service index\n', '        uint256 lastIndex = validServiceTypes.length - 1;\n', '        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n', '        validServiceTypes.length--;\n', '\n', '        // Mark as invalid\n', '        serviceTypeInfo[_serviceType].isValid = false;\n', '        // Note - stake bounds are not reset so they can be checked to prevent serviceType from being re-added\n', '        emit ServiceTypeRemoved(_serviceType);\n', '    }\n', '\n', '    /**\n', '     * @notice Get isValid, min and max stake for a given service type\n', '     * @param _serviceType - type of service\n', '     * @return isValid, min and max stake for type\n', '     */\n', '    function getServiceTypeInfo(bytes32 _serviceType)\n', '    external view returns (bool isValid, uint256 minStake, uint256 maxStake)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return (\n', '            serviceTypeInfo[_serviceType].isValid,\n', '            serviceTypeInfo[_serviceType].minStake,\n', '            serviceTypeInfo[_serviceType].maxStake\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get list of valid service types\n', '     */\n', '    function getValidServiceTypes()\n', '    external view returns (bytes32[] memory)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return validServiceTypes;\n', '    }\n', '\n', '    /**\n', '     * @notice Return indicating whether this is a valid service type\n', '     */\n', '    function serviceTypeIsValid(bytes32 _serviceType)\n', '    external view returns (bool)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceTypeInfo[_serviceType].isValid;\n', '    }\n', '\n', '    // ========================================= Service Version Logic =========================================\n', '\n', '    /**\n', '     * @notice Add new version for a serviceType\n', '     * @param _serviceType - type of service\n', '     * @param _serviceVersion - new version of service to add\n', '     */\n', '    function setServiceVersion(\n', '        bytes32 _serviceType,\n', '        bytes32 _serviceVersion\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        require(this.serviceTypeIsValid(_serviceType), "ServiceTypeManager: Invalid service type");\n', '        require(\n', '            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n', '            "ServiceTypeManager: Already registered"\n', '        );\n', '\n', '         // Update array of known versions for type\n', '        serviceTypeVersions[_serviceType].push(_serviceVersion);\n', '\n', '        // Update status for this specific service version\n', '        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n', '\n', '        emit SetServiceVersion(_serviceType, _serviceVersion);\n', '    }\n', '\n', '    /**\n', "     * @notice Get a version for a service type given it's index\n", '     * @param _serviceType - type of service\n', '     * @param _versionIndex - index in list of service versions\n', '     * @return bytes32 value for serviceVersion\n', '     */\n', '    function getVersion(bytes32 _serviceType, uint256 _versionIndex)\n', '    external view returns (bytes32)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            serviceTypeVersions[_serviceType].length > _versionIndex,\n', '            "ServiceTypeManager: No registered version of serviceType"\n', '        );\n', '        return (serviceTypeVersions[_serviceType][_versionIndex]);\n', '    }\n', '\n', '    /**\n', '     * @notice Get curent version for a service type\n', '     * @param _serviceType - type of service\n', '     * @return Returns current version of service\n', '     */\n', '    function getCurrentVersion(bytes32 _serviceType)\n', '    external view returns (bytes32)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            serviceTypeVersions[_serviceType].length >= 1,\n', '            "ServiceTypeManager: No registered version of serviceType"\n', '        );\n', '        uint256 latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n', '        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n', '    }\n', '\n', '    /**\n', '     * @notice Get total number of versions for a service type\n', '     * @param _serviceType - type of service\n', '     */\n', '    function getNumberOfVersions(bytes32 _serviceType)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceTypeVersions[_serviceType].length;\n', '    }\n', '\n', '    /**\n', '     * @notice Return boolean indicating whether given version is valid for given type\n', '     * @param _serviceType - type of service\n', '     * @param _serviceVersion - version of service to check\n', '     */\n', '    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n', '    external view returns (bool)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n', '    }\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) internal {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "ServiceTypeManager: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/roles/MinterRole.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', 'contract MinterRole is Initializable, Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event MinterAdded(address indexed account);\n', '    event MinterRemoved(address indexed account);\n', '\n', '    Roles.Role private _minters;\n', '\n', '    function initialize(address sender) public initializer {\n', '        if (!isMinter(sender)) {\n', '            _addMinter(sender);\n', '        }\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(isMinter(_msgSender()), "MinterRole: caller does not have the Minter role");\n', '        _;\n', '    }\n', '\n', '    function isMinter(address account) public view returns (bool) {\n', '        return _minters.has(account);\n', '    }\n', '\n', '    function addMinter(address account) public onlyMinter {\n', '        _addMinter(account);\n', '    }\n', '\n', '    function renounceMinter() public {\n', '        _removeMinter(_msgSender());\n', '    }\n', '\n', '    function _addMinter(address account) internal {\n', '        _minters.add(account);\n', '        emit MinterAdded(account);\n', '    }\n', '\n', '    function _removeMinter(address account) internal {\n', '        _minters.remove(account);\n', '        emit MinterRemoved(account);\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n', ' * which have permission to mint (create) new tokens as they see fit.\n', ' *\n', ' * At construction, the deployer of the contract is the only minter.\n', ' */\n', 'contract ERC20Mintable is Initializable, ERC20, MinterRole {\n', '    function initialize(address sender) public initializer {\n', '        MinterRole.initialize(sender);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the {MinterRole}.\n', '     */\n', '    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n', '        _mint(account, amount);\n', '        return true;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/ClaimsManager.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/// @notice ERC20 imported via Staking.sol\n', '/// @notice SafeERC20 imported via Staking.sol\n', '/// @notice Governance imported via Staking.sol\n', '/// @notice SafeMath imported via ServiceProviderFactory.sol\n', '\n', '\n', '/**\n', ' * Designed to automate claim funding, minting tokens as necessary\n', ' * @notice - will call InitializableV2 constructor\n', ' */\n', 'contract ClaimsManager is InitializableV2 {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for ERC20;\n', '\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "ClaimsManager: Only callable by Governance contract"\n', '    );\n', '\n', '    address private governanceAddress;\n', '    address private stakingAddress;\n', '    address private serviceProviderFactoryAddress;\n', '    address private delegateManagerAddress;\n', '\n', '    /**\n', '      * @notice - Minimum number of blocks between funding rounds\n', '      *       604800 seconds / week\n', '      *       Avg block time - 13s\n', '      *       604800 / 13 = 46523.0769231 blocks\n', '      */\n', '    uint256 private fundingRoundBlockDiff;\n', '\n', '    /**\n', '      * @notice - Configures the current funding amount per round\n', '      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\n', '      *                                 = 70,000,000/365*7 (year is slightly more than a week)\n', '      *                                 = 1342465.75342 new AUDS per week\n', '      *                                 = 1342465753420000000000000 new wei units per week\n', '      * @dev - Past a certain block height, this schedule will be updated\n', '      *      - Logic determining schedule will be sourced from an external contract\n', '      */\n', '    uint256 private fundingAmount;\n', '\n', '    // Denotes current round\n', '    uint256 private roundNumber;\n', '\n', '    // Staking contract ref\n', '    ERC20Mintable private audiusToken;\n', '\n', '    /// @dev - Address to which recurringCommunityFundingAmount is transferred at funding round start\n', '    address private communityPoolAddress;\n', '\n', '    /// @dev - Reward amount transferred to communityPoolAddress at funding round start\n', '    uint256 private recurringCommunityFundingAmount;\n', '\n', '    // Struct representing round state\n', '    // 1) Block at which round was funded\n', '    // 2) Total funded for this round\n', '    // 3) Total claimed in round\n', '    struct Round {\n', '        uint256 fundedBlock;\n', '        uint256 fundedAmount;\n', '        uint256 totalClaimedInRound;\n', '    }\n', '\n', '    // Current round information\n', '    Round private currentRound;\n', '\n', '    event RoundInitiated(\n', '      uint256 indexed _blockNumber,\n', '      uint256 indexed _roundNumber,\n', '      uint256 indexed _fundAmount\n', '    );\n', '\n', '    event ClaimProcessed(\n', '      address indexed _claimer,\n', '      uint256 indexed _rewards,\n', '      uint256 _oldTotal,\n', '      uint256 indexed _newTotal\n', '    );\n', '\n', '    event CommunityRewardsTransferred(\n', '      address indexed _transferAddress,\n', '      uint256 indexed _amount\n', '    );\n', '\n', '    event FundingAmountUpdated(uint256 indexed _amount);\n', '    event FundingRoundBlockDiffUpdated(uint256 indexed _blockDifference);\n', '    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\n', '    event StakingAddressUpdated(address indexed _newStakingAddress);\n', '    event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);\n', '    event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);\n', '    event RecurringCommunityFundingAmountUpdated(uint256 indexed _amount);\n', '    event CommunityPoolAddressUpdated(address indexed _newCommunityPoolAddress);\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @dev stakingAddress must be initialized separately after Staking contract is deployed\n', '     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\n', '     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\n', '     * @param _tokenAddress - address of ERC20 token that will be claimed\n', '     * @param _governanceAddress - address for Governance proxy contract\n', '     */\n', '    function initialize(\n', '        address _tokenAddress,\n', '        address _governanceAddress\n', '    ) public initializer\n', '    {\n', '        _updateGovernanceAddress(_governanceAddress);\n', '\n', '        audiusToken = ERC20Mintable(_tokenAddress);\n', '\n', '        fundingRoundBlockDiff = 46523;\n', '        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\n', '        roundNumber = 0;\n', '\n', '        currentRound = Round({\n', '            fundedBlock: 0,\n', '            fundedAmount: 0,\n', '            totalClaimedInRound: 0\n', '        });\n', '\n', '        // Community pool funding amount and address initialized to zero\n', '        recurringCommunityFundingAmount = 0;\n', '        communityPoolAddress = address(0x0);\n', '\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    /// @notice Get the duration of a funding round in blocks\n', '    function getFundingRoundBlockDiff() external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return fundingRoundBlockDiff;\n', '    }\n', '\n', '    /// @notice Get the last block where a funding round was initiated\n', '    function getLastFundedBlock() external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return currentRound.fundedBlock;\n', '    }\n', '\n', '    /// @notice Get the amount funded per round in wei\n', '    function getFundsPerRound() external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return fundingAmount;\n', '    }\n', '\n', '    /// @notice Get the total amount claimed in the current round\n', '    function getTotalClaimedInRound() external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return currentRound.totalClaimedInRound;\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /// @notice Get the ServiceProviderFactory address\n', '    function getServiceProviderFactoryAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderFactoryAddress;\n', '    }\n', '\n', '    /// @notice Get the DelegateManager address\n', '    function getDelegateManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return delegateManagerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the Staking address\n', '     */\n', '    function getStakingAddress() external view returns (address)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return stakingAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the community pool address\n', '     */\n', '    function getCommunityPoolAddress() external view returns (address)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return communityPoolAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the community funding amount\n', '     */\n', '    function getRecurringCommunityFundingAmount() external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return recurringCommunityFundingAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        emit GovernanceAddressUpdated(_governanceAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Staking address\n', '     * @dev Only callable by Governance address\n', '     * @param _stakingAddress - address for new Staking contract\n', '     */\n', '    function setStakingAddress(address _stakingAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        stakingAddress = _stakingAddress;\n', '        emit StakingAddressUpdated(_stakingAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ServiceProviderFactory address\n', '     * @dev Only callable by Governance address\n', '     * @param _serviceProviderFactoryAddress - address for new ServiceProviderFactory contract\n', '     */\n', '    function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        serviceProviderFactoryAddress = _serviceProviderFactoryAddress;\n', '        emit ServiceProviderFactoryAddressUpdated(_serviceProviderFactoryAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the DelegateManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _delegateManagerAddress - address for new DelegateManager contract\n', '     */\n', '    function setDelegateManagerAddress(address _delegateManagerAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        delegateManagerAddress = _delegateManagerAddress;\n', '        emit DelegateManagerAddressUpdated(_delegateManagerAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Start a new funding round\n', '     * @dev Permissioned to be callable by stakers or governance contract\n', '     */\n', '    function initiateRound() external {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '\n', '        require(\n', '            block.number.sub(currentRound.fundedBlock) > fundingRoundBlockDiff,\n', '            "ClaimsManager: Required block difference not met"\n', '        );\n', '\n', '        currentRound = Round({\n', '            fundedBlock: block.number,\n', '            fundedAmount: fundingAmount,\n', '            totalClaimedInRound: 0\n', '        });\n', '\n', '        roundNumber = roundNumber.add(1);\n', '\n', '        /*\n', '         * Transfer community funding amount to community pool address, if set\n', '         */\n', '        if (recurringCommunityFundingAmount > 0 && communityPoolAddress != address(0x0)) {\n', '            // ERC20Mintable always returns true\n', '            audiusToken.mint(address(this), recurringCommunityFundingAmount);\n', '\n', '            // Approve transfer to community pool address\n', '            audiusToken.approve(communityPoolAddress, recurringCommunityFundingAmount);\n', '\n', '            // Transfer to community pool address\n', '            ERC20(address(audiusToken)).safeTransfer(communityPoolAddress, recurringCommunityFundingAmount);\n', '\n', '            emit CommunityRewardsTransferred(communityPoolAddress, recurringCommunityFundingAmount);\n', '        }\n', '\n', '        emit RoundInitiated(\n', '            currentRound.fundedBlock,\n', '            roundNumber,\n', '            currentRound.fundedAmount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\n', '     * @dev Callable through DelegateManager by Service Provider\n', '     * @param _claimer  - service provider address\n', '     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\n', '     * @return minted rewards for this claimer\n', '     */\n', '    function processClaim(\n', '        address _claimer,\n', '        uint256 _totalLockedForSP\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == delegateManagerAddress,\n', '            "ClaimsManager: ProcessClaim only accessible to DelegateManager"\n', '        );\n', '\n', '        Staking stakingContract = Staking(stakingAddress);\n', '        // Prevent duplicate claim\n', '        uint256 lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\n', '        require(\n', '            lastUserClaimBlock <= currentRound.fundedBlock,\n', '            "ClaimsManager: Claim already processed for user"\n', '        );\n', '        uint256 totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\n', '            _claimer,\n', '            currentRound.fundedBlock);\n', '\n', '        (,,bool withinBounds,,,) = (\n', '            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\n', '        );\n', '\n', '        // Once they claim the zero reward amount, stake can be modified once again\n', '        // Subtract total locked amount for SP from stake at fund block\n', '        uint256 totalActiveClaimerStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\n', '        uint256 totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundedBlock);\n', '\n', '        // Calculate claimer rewards\n', '        uint256 rewardsForClaimer = (\n', '          totalActiveClaimerStake.mul(fundingAmount)\n', '        ).div(totalStakedAtFundBlock);\n', '\n', '        // For a claimer violating bounds, no new tokens are minted\n', '        // Claim history is marked to zero and function is short-circuited\n', '        // Total rewards can be zero if all stake is currently locked up\n', '        if (!withinBounds || rewardsForClaimer == 0) {\n', '            stakingContract.updateClaimHistory(0, _claimer);\n', '            emit ClaimProcessed(\n', '                _claimer,\n', '                0,\n', '                totalStakedAtFundBlockForClaimer,\n', '                totalActiveClaimerStake\n', '            );\n', '            return 0;\n', '        }\n', '\n', '        // ERC20Mintable always returns true\n', '        audiusToken.mint(address(this), rewardsForClaimer);\n', '\n', '        // Approve transfer to staking address for claimer rewards\n', '        // ERC20 always returns true\n', '        audiusToken.approve(stakingAddress, rewardsForClaimer);\n', '\n', '        // Transfer rewards\n', '        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\n', '\n', '        // Update round claim value\n', '        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\n', '\n', '        // Update round claim value\n', '        uint256 newTotal = stakingContract.totalStakedFor(_claimer);\n', '\n', '        emit ClaimProcessed(\n', '            _claimer,\n', '            rewardsForClaimer,\n', '            totalStakedAtFundBlockForClaimer,\n', '            newTotal\n', '        );\n', '\n', '        return rewardsForClaimer;\n', '    }\n', '\n', '    /**\n', '     * @notice Modify funding amount per round\n', '     * @param _newAmount - new amount to fund per round in wei\n', '     */\n', '    function updateFundingAmount(uint256 _newAmount) external\n', '    {\n', '        _requireIsInitialized();\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        fundingAmount = _newAmount;\n', '        emit FundingAmountUpdated(_newAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns boolean indicating whether a claim is considered pending\n', '     * @dev Note that an address with no endpoints can never have a pending claim\n', '     * @param _sp - address of the service provider to check\n', '     * @return true if eligible for claim, false if not\n', '     */\n', '    function claimPending(address _sp) external view returns (bool) {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '\n', '        uint256 lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\n', '        (,,,uint256 numEndpoints,,) = (\n', '            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\n', '        );\n', '        return (lastClaimedForSP < currentRound.fundedBlock && numEndpoints > 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Modify minimum block difference between funding rounds\n', '     * @param _newFundingRoundBlockDiff - new min block difference to set\n', '     */\n', '    function updateFundingRoundBlockDiff(uint256 _newFundingRoundBlockDiff) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        emit FundingRoundBlockDiffUpdated(_newFundingRoundBlockDiff);\n', '        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\n', '    }\n', '\n', '    /**\n', '     * @notice Modify community funding amound for each round\n', '     * @param _newRecurringCommunityFundingAmount - new reward amount transferred to\n', '     *          communityPoolAddress at funding round start\n', '     */\n', '    function updateRecurringCommunityFundingAmount(\n', '        uint256 _newRecurringCommunityFundingAmount\n', '    ) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        recurringCommunityFundingAmount = _newRecurringCommunityFundingAmount;\n', '        emit RecurringCommunityFundingAmountUpdated(_newRecurringCommunityFundingAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Modify community pool address\n', '     * @param _newCommunityPoolAddress - new address to which recurringCommunityFundingAmount\n', '     *          is transferred at funding round start\n', '     */\n', '    function updateCommunityPoolAddress(address _newCommunityPoolAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        communityPoolAddress = _newCommunityPoolAddress;\n', '        emit CommunityPoolAddressUpdated(_newCommunityPoolAddress);\n', '    }\n', '\n', '    // ========================================= Private Functions =========================================\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) private {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "ClaimsManager: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '\n', '    function _requireStakingAddressIsSet() private view {\n', '        require(stakingAddress != address(0x00), "ClaimsManager: stakingAddress is not set");\n', '    }\n', '\n', '    function _requireDelegateManagerAddressIsSet() private view {\n', '        require(\n', '            delegateManagerAddress != address(0x00),\n', '            "ClaimsManager: delegateManagerAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireServiceProviderFactoryAddressIsSet() private view {\n', '        require(\n', '            serviceProviderFactoryAddress != address(0x00),\n', '            "ClaimsManager: serviceProviderFactoryAddress is not set"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/ServiceProviderFactory.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/// @notice Governance imported via Staking.sol\n', '\n', '\n', 'contract ServiceProviderFactory is InitializableV2 {\n', '    using SafeMath for uint256;\n', '\n', '    /// @dev - denominator for deployer cut calculations\n', '    /// @dev - user values are intended to be x/DEPLOYER_CUT_BASE\n', '    uint256 private constant DEPLOYER_CUT_BASE = 100;\n', '\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "ServiceProviderFactory: Only callable by Governance contract"\n', '    );\n', '    string private constant ERROR_ONLY_SP_GOVERNANCE = (\n', '        "ServiceProviderFactory: Only callable by Service Provider or Governance"\n', '    );\n', '\n', '    address private stakingAddress;\n', '    address private delegateManagerAddress;\n', '    address private governanceAddress;\n', '    address private serviceTypeManagerAddress;\n', '    address private claimsManagerAddress;\n', '\n', '    /// @notice Period in blocks that a decrease stake operation is delayed.\n', '    ///         Must be greater than governance votingPeriod + executionDelay in order to\n', '    ///         prevent pre-emptive withdrawal in anticipation of a slash proposal\n', '    uint256 private decreaseStakeLockupDuration;\n', '\n', '    /// @notice Period in blocks that an update deployer cut operation is delayed.\n', '    ///         Must be greater than funding round block diff in order\n', '    ///         to prevent manipulation around a funding round\n', '    uint256 private deployerCutLockupDuration;\n', '\n', '    /// @dev - Stores following entities\n', '    ///        1) Directly staked amount by SP, not including delegators\n', '    ///        2) % Cut of delegator tokens taken during reward\n', '    ///        3) Bool indicating whether this SP has met min/max requirements\n', '    ///        4) Number of endpoints registered by SP\n', '    ///        5) Minimum deployer stake for this service provider\n', '    ///        6) Maximum total stake for this account\n', '    struct ServiceProviderDetails {\n', '        uint256 deployerStake;\n', '        uint256 deployerCut;\n', '        bool validBounds;\n', '        uint256 numberOfEndpoints;\n', '        uint256 minAccountStake;\n', '        uint256 maxAccountStake;\n', '    }\n', '\n', '    /// @dev - Data structure for time delay during withdrawal\n', '    struct DecreaseStakeRequest {\n', '        uint256 decreaseAmount;\n', '        uint256 lockupExpiryBlock;\n', '    }\n', '\n', '    /// @dev - Data structure for time delay during deployer cut update\n', '    struct UpdateDeployerCutRequest {\n', '        uint256 newDeployerCut;\n', '        uint256 lockupExpiryBlock;\n', '    }\n', '\n', '    /// @dev - Struct maintaining information about sp\n', '    /// @dev - blocknumber is block.number when endpoint registered\n', '    struct ServiceEndpoint {\n', '        address owner;\n', '        string endpoint;\n', '        uint256 blocknumber;\n', '        address delegateOwnerWallet;\n', '    }\n', '\n', '    /// @dev - Mapping of service provider address to details\n', '    mapping(address => ServiceProviderDetails) private spDetails;\n', '\n', '    /// @dev - Uniquely assigned serviceProvider ID, incremented for each service type\n', '    /// @notice - Keeps track of the total number of services registered regardless of\n', '    ///           whether some have been deregistered since\n', '    mapping(bytes32 => uint256) private serviceProviderTypeIDs;\n', '\n', '    /// @dev - mapping of (serviceType -> (serviceInstanceId <-> serviceProviderInfo))\n', '    /// @notice - stores the actual service provider data like endpoint and owner wallet\n', '    ///           with the ability lookup by service type and service id */\n', '    mapping(bytes32 => mapping(uint256 => ServiceEndpoint)) private serviceProviderInfo;\n', '\n', '    /// @dev - mapping of keccak256(endpoint) to uint256 ID\n', '    /// @notice - used to check if a endpoint has already been registered and also lookup\n', '    /// the id of an endpoint\n', '    mapping(bytes32 => uint256) private serviceProviderEndpointToId;\n', '\n', '    /// @dev - mapping of address -> sp id array */\n', '    /// @notice - stores all the services registered by a provider. for each address,\n', '    /// provides the ability to lookup by service type and see all registered services\n', '    mapping(address => mapping(bytes32 => uint256[])) private serviceProviderAddressToId;\n', '\n', '    /// @dev - Mapping of service provider -> decrease stake request\n', '    mapping(address => DecreaseStakeRequest) private decreaseStakeRequests;\n', '\n', '    /// @dev - Mapping of service provider -> update deployer cut requests\n', '    mapping(address => UpdateDeployerCutRequest) private updateDeployerCutRequests;\n', '\n', '    event RegisteredServiceProvider(\n', '      uint256 indexed _spID,\n', '      bytes32 indexed _serviceType,\n', '      address indexed _owner,\n', '      string _endpoint,\n', '      uint256 _stakeAmount\n', '    );\n', '\n', '    event DeregisteredServiceProvider(\n', '      uint256 indexed _spID,\n', '      bytes32 indexed _serviceType,\n', '      address indexed _owner,\n', '      string _endpoint,\n', '      uint256 _unstakeAmount\n', '    );\n', '\n', '    event IncreasedStake(\n', '      address indexed _owner,\n', '      uint256 indexed _increaseAmount,\n', '      uint256 indexed _newStakeAmount\n', '    );\n', '\n', '    event DecreaseStakeRequested(\n', '      address indexed _owner,\n', '      uint256 indexed _decreaseAmount,\n', '      uint256 indexed _lockupExpiryBlock\n', '    );\n', '\n', '    event DecreaseStakeRequestCancelled(\n', '      address indexed _owner,\n', '      uint256 indexed _decreaseAmount,\n', '      uint256 indexed _lockupExpiryBlock\n', '    );\n', '\n', '    event DecreaseStakeRequestEvaluated(\n', '      address indexed _owner,\n', '      uint256 indexed _decreaseAmount,\n', '      uint256 indexed _newStakeAmount\n', '    );\n', '\n', '    event EndpointUpdated(\n', '      bytes32 indexed _serviceType,\n', '      address indexed _owner,\n', '      string _oldEndpoint,\n', '      string _newEndpoint,\n', '      uint256 indexed _spID\n', '    );\n', '\n', '    event DelegateOwnerWalletUpdated(\n', '      address indexed _owner,\n', '      bytes32 indexed _serviceType,\n', '      uint256 indexed _spID,\n', '      address _updatedWallet\n', '    );\n', '\n', '    event DeployerCutUpdateRequested(\n', '      address indexed _owner,\n', '      uint256 indexed _updatedCut,\n', '      uint256 indexed _lockupExpiryBlock\n', '    );\n', '\n', '    event DeployerCutUpdateRequestCancelled(\n', '      address indexed _owner,\n', '      uint256 indexed _requestedCut,\n', '      uint256 indexed _finalCut\n', '    );\n', '\n', '    event DeployerCutUpdateRequestEvaluated(\n', '      address indexed _owner,\n', '      uint256 indexed _updatedCut\n', '    );\n', '\n', '    event DecreaseStakeLockupDurationUpdated(uint256 indexed _lockupDuration);\n', '    event UpdateDeployerCutLockupDurationUpdated(uint256 indexed _lockupDuration);\n', '    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\n', '    event StakingAddressUpdated(address indexed _newStakingAddress);\n', '    event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);\n', '    event DelegateManagerAddressUpdated(address indexed _newDelegateManagerAddress);\n', '    event ServiceTypeManagerAddressUpdated(address indexed _newServiceTypeManagerAddress);\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @dev stakingAddress must be initialized separately after Staking contract is deployed\n', '     * @dev delegateManagerAddress must be initialized separately after DelegateManager contract is deployed\n', '     * @dev serviceTypeManagerAddress must be initialized separately after ServiceTypeManager contract is deployed\n', '     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\n', '     * @param _governanceAddress - Governance proxy address\n', '     */\n', '    function initialize (\n', '        address _governanceAddress,\n', '        address _claimsManagerAddress,\n', '        uint256 _decreaseStakeLockupDuration,\n', '        uint256 _deployerCutLockupDuration\n', '    ) public initializer\n', '    {\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        claimsManagerAddress = _claimsManagerAddress;\n', '        _updateDecreaseStakeLockupDuration(_decreaseStakeLockupDuration);\n', '        _updateDeployerCutLockupDuration(_deployerCutLockupDuration);\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    /**\n', '     * @notice Register a new endpoint to the account of msg.sender\n', '     * @dev Transfers stake from service provider into staking pool\n', '     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n', '     * @param _endpoint - url of the service to register - url of the service to register\n', '     * @param _stakeAmount - amount to stake, must be within bounds in ServiceTypeManager\n', '     * @param _delegateOwnerWallet - wallet to delegate some permissions for some basic management properties\n', '     * @return New service provider ID for this endpoint\n', '     */\n', '    function register(\n', '        bytes32 _serviceType,\n', '        string calldata _endpoint,\n', '        uint256 _stakeAmount,\n', '        address _delegateOwnerWallet\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceTypeManagerAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType),\n', '            "ServiceProviderFactory: Valid service type required");\n', '\n', '        // Stake token amount from msg.sender\n', '        if (_stakeAmount > 0) {\n', '            require(\n', '                !_claimPending(msg.sender),\n', '                "ServiceProviderFactory: No pending claim expected"\n', '            );\n', '            Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);\n', '        }\n', '\n', '        require (\n', '            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0,\n', '            "ServiceProviderFactory: Endpoint already registered");\n', '\n', '        uint256 newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);\n', '        serviceProviderTypeIDs[_serviceType] = newServiceProviderID;\n', '\n', '        // Index spInfo\n', '        serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({\n', '            owner: msg.sender,\n', '            endpoint: _endpoint,\n', '            blocknumber: block.number,\n', '            delegateOwnerWallet: _delegateOwnerWallet\n', '        });\n', '\n', '        // Update endpoint mapping\n', '        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;\n', '\n', '        // Update (address -> type -> ids[])\n', '        serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);\n', '\n', '        // Increment number of endpoints for this address\n', '        spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);\n', '\n', '        // Update deployer total\n', '        spDetails[msg.sender].deployerStake = (\n', '            spDetails[msg.sender].deployerStake.add(_stakeAmount)\n', '        );\n', '\n', '        // Update min and max totals for this service provider\n', '        (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager(\n', '            serviceTypeManagerAddress\n', '        ).getServiceTypeInfo(_serviceType);\n', '        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);\n', '        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);\n', '\n', '        // Confirm both aggregate account balance and directly staked amount are valid\n', '        this.validateAccountStakeBalance(msg.sender);\n', '        uint256 currentlyStakedForOwner = Staking(stakingAddress).totalStakedFor(msg.sender);\n', '\n', '\n', '        // Indicate this service provider is within bounds\n', '        spDetails[msg.sender].validBounds = true;\n', '\n', '        emit RegisteredServiceProvider(\n', '            newServiceProviderID,\n', '            _serviceType,\n', '            msg.sender,\n', '            _endpoint,\n', '            currentlyStakedForOwner\n', '        );\n', '\n', '        return newServiceProviderID;\n', '    }\n', '\n', '    /**\n', '     * @notice Deregister an endpoint from the account of msg.sender\n', '     * @dev Unstakes all tokens for service provider if this is the last endpoint\n', '     * @param _serviceType - type of service to deregister\n', '     * @param _endpoint - endpoint to deregister\n', '     * @return spId of the service that was deregistered\n', '     */\n', '    function deregister(\n', '        bytes32 _serviceType,\n', '        string calldata _endpoint\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceTypeManagerAddressIsSet();\n', '\n', '        // Unstake on deregistration if and only if this is the last service endpoint\n', '        uint256 unstakeAmount = 0;\n', '        bool unstaked = false;\n', '        // owned by the service provider\n', '        if (spDetails[msg.sender].numberOfEndpoints == 1) {\n', '            unstakeAmount = spDetails[msg.sender].deployerStake;\n', '\n', '            // Submit request to decrease stake, overriding any pending request\n', '            decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n', '                decreaseAmount: unstakeAmount,\n', '                lockupExpiryBlock: block.number.add(decreaseStakeLockupDuration)\n', '            });\n', '\n', '            unstaked = true;\n', '        }\n', '\n', '        require (\n', '            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] != 0,\n', '            "ServiceProviderFactory: Endpoint not registered");\n', '\n', '        // Cache invalided service provider ID\n', '        uint256 deregisteredID = serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n', '\n', '        // Update endpoint mapping\n', '        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = 0;\n', '\n', '        require(\n', '            keccak256(bytes(serviceProviderInfo[_serviceType][deregisteredID].endpoint)) == keccak256(bytes(_endpoint)),\n', '            "ServiceProviderFactory: Invalid endpoint for service type");\n', '\n', '        require (\n', '            serviceProviderInfo[_serviceType][deregisteredID].owner == msg.sender,\n', '            "ServiceProviderFactory: Only callable by endpoint owner");\n', '\n', '        // Update info mapping\n', '        delete serviceProviderInfo[_serviceType][deregisteredID];\n', '        // Reset id, update array\n', '        uint256 spTypeLength = serviceProviderAddressToId[msg.sender][_serviceType].length;\n', '        for (uint256 i = 0; i < spTypeLength; i ++) {\n', '            if (serviceProviderAddressToId[msg.sender][_serviceType][i] == deregisteredID) {\n', '                // Overwrite element to be deleted with last element in array\n', '                serviceProviderAddressToId[msg.sender][_serviceType][i] = serviceProviderAddressToId[msg.sender][_serviceType][spTypeLength - 1];\n', '                // Reduce array size, exit loop\n', '                serviceProviderAddressToId[msg.sender][_serviceType].length--;\n', '                // Confirm this ID has been found for the service provider\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Decrement number of endpoints for this address\n', '        spDetails[msg.sender].numberOfEndpoints -= 1;\n', '\n', '        // Update min and max totals for this service provider\n', '        (, uint256 typeMin, uint256 typeMax) = ServiceTypeManager(\n', '            serviceTypeManagerAddress\n', '        ).getServiceTypeInfo(_serviceType);\n', '        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.sub(typeMin);\n', '        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.sub(typeMax);\n', '\n', '        emit DeregisteredServiceProvider(\n', '            deregisteredID,\n', '            _serviceType,\n', '            msg.sender,\n', '            _endpoint,\n', '            unstakeAmount);\n', '\n', '        // Confirm both aggregate account balance and directly staked amount are valid\n', '        // Only if unstake operation has not occurred\n', '        if (!unstaked) {\n', '            this.validateAccountStakeBalance(msg.sender);\n', '            // Indicate this service provider is within bounds\n', '            spDetails[msg.sender].validBounds = true;\n', '        }\n', '\n', '        return deregisteredID;\n', '    }\n', '\n', '    /**\n', '     * @notice Increase stake for service provider\n', '     * @param _increaseStakeAmount - amount to increase staked amount by\n', '     * @return New total stake for service provider\n', '     */\n', '    function increaseStake(\n', '        uint256 _increaseStakeAmount\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        // Confirm owner has an endpoint\n', '        require(\n', '            spDetails[msg.sender].numberOfEndpoints > 0,\n', '            "ServiceProviderFactory: Registered endpoint required to increase stake"\n', '        );\n', '        require(\n', '            !_claimPending(msg.sender),\n', '            "ServiceProviderFactory: No claim expected to be pending prior to stake transfer"\n', '        );\n', '\n', '        Staking stakingContract = Staking(\n', '            stakingAddress\n', '        );\n', '\n', '        // Stake increased token amount for msg.sender\n', '        stakingContract.stakeFor(msg.sender, _increaseStakeAmount);\n', '\n', '        uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n', '\n', '        // Update deployer total\n', '        spDetails[msg.sender].deployerStake = (\n', '            spDetails[msg.sender].deployerStake.add(_increaseStakeAmount)\n', '        );\n', '\n', '        // Confirm both aggregate account balance and directly staked amount are valid\n', '        this.validateAccountStakeBalance(msg.sender);\n', '\n', '        // Indicate this service provider is within bounds\n', '        spDetails[msg.sender].validBounds = true;\n', '\n', '        emit IncreasedStake(\n', '            msg.sender,\n', '            _increaseStakeAmount,\n', '            newStakeAmount\n', '        );\n', '\n', '        return newStakeAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Request to decrease stake. This sets a lockup for decreaseStakeLockupDuration after\n', '               which the actual decreaseStake can be called\n', '     * @dev Decreasing stake is only processed if a service provider is within valid bounds\n', '     * @param _decreaseStakeAmount - amount to decrease stake by in wei\n', '     * @return New total stake amount after the lockup\n', '     */\n', '    function requestDecreaseStake(uint256 _decreaseStakeAmount)\n', '    external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            _decreaseStakeAmount > 0,\n', '            "ServiceProviderFactory: Requested stake decrease amount must be greater than zero"\n', '        );\n', '        require(\n', '            !_claimPending(msg.sender),\n', '            "ServiceProviderFactory: No claim expected to be pending prior to stake transfer"\n', '        );\n', '\n', '        Staking stakingContract = Staking(\n', '            stakingAddress\n', '        );\n', '\n', '        uint256 currentStakeAmount = stakingContract.totalStakedFor(msg.sender);\n', '\n', '        // Prohibit decreasing stake to invalid bounds\n', '        _validateBalanceInternal(msg.sender, (currentStakeAmount.sub(_decreaseStakeAmount)));\n', '\n', '        uint256 expiryBlock = block.number.add(decreaseStakeLockupDuration);\n', '        decreaseStakeRequests[msg.sender] = DecreaseStakeRequest({\n', '            decreaseAmount: _decreaseStakeAmount,\n', '            lockupExpiryBlock: expiryBlock\n', '        });\n', '\n', '        emit DecreaseStakeRequested(msg.sender, _decreaseStakeAmount, expiryBlock);\n', '        return currentStakeAmount.sub(_decreaseStakeAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel a decrease stake request during the lockup\n', '     * @dev Either called by the service provider via DelegateManager or governance\n', '            during a slash action\n', '     * @param _account - address of service provider\n', '     */\n', '    function cancelDecreaseStakeRequest(address _account) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == _account || msg.sender == delegateManagerAddress,\n', '            "ServiceProviderFactory: Only owner or DelegateManager"\n', '        );\n', '        require(\n', '            _decreaseRequestIsPending(_account),\n', '            "ServiceProviderFactory: Decrease stake request must be pending"\n', '        );\n', '\n', '        DecreaseStakeRequest memory cancelledRequest = decreaseStakeRequests[_account];\n', '\n', '        // Clear decrease stake request\n', '        decreaseStakeRequests[_account] = DecreaseStakeRequest({\n', '            decreaseAmount: 0,\n', '            lockupExpiryBlock: 0\n', '        });\n', '\n', '        emit DecreaseStakeRequestCancelled(\n', '            _account,\n', '            cancelledRequest.decreaseAmount,\n', '            cancelledRequest.lockupExpiryBlock\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Called by user to decrease a stake after waiting the appropriate lockup period.\n', '     * @return New total stake after decrease\n', '     */\n', '    function decreaseStake() external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '\n', '        require(\n', '            _decreaseRequestIsPending(msg.sender),\n', '            "ServiceProviderFactory: Decrease stake request must be pending"\n', '        );\n', '        require(\n', '            decreaseStakeRequests[msg.sender].lockupExpiryBlock <= block.number,\n', '            "ServiceProviderFactory: Lockup must be expired"\n', '        );\n', '\n', '        Staking stakingContract = Staking(\n', '            stakingAddress\n', '        );\n', '\n', '        uint256 decreaseAmount = decreaseStakeRequests[msg.sender].decreaseAmount;\n', '        // Decrease staked token amount for msg.sender\n', '        stakingContract.unstakeFor(msg.sender, decreaseAmount);\n', '\n', '        // Query current stake\n', '        uint256 newStakeAmount = stakingContract.totalStakedFor(msg.sender);\n', '\n', '        // Update deployer total\n', '        spDetails[msg.sender].deployerStake = (\n', '            spDetails[msg.sender].deployerStake.sub(decreaseAmount)\n', '        );\n', '\n', '        // Confirm both aggregate account balance and directly staked amount are valid\n', '        // During registration this validation is bypassed since no endpoints remain\n', '        if (spDetails[msg.sender].numberOfEndpoints > 0) {\n', '            this.validateAccountStakeBalance(msg.sender);\n', '        }\n', '\n', '        // Indicate this service provider is within bounds\n', '        spDetails[msg.sender].validBounds = true;\n', '\n', '        // Clear decrease stake request\n', '        delete decreaseStakeRequests[msg.sender];\n', '\n', '        emit DecreaseStakeRequestEvaluated(msg.sender, decreaseAmount, newStakeAmount);\n', '        return newStakeAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Update delegate owner wallet for a given endpoint\n', '     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n', '     * @param _endpoint - url of the service to register - url of the service to register\n', '     * @param _updatedDelegateOwnerWallet - address of new delegate wallet\n', '     */\n', '    function updateDelegateOwnerWallet(\n', '        bytes32 _serviceType,\n', '        string calldata _endpoint,\n', '        address _updatedDelegateOwnerWallet\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        uint256 spID = this.getServiceProviderIdFromEndpoint(_endpoint);\n', '\n', '        require(\n', '            serviceProviderInfo[_serviceType][spID].owner == msg.sender,\n', '            "ServiceProviderFactory: Invalid update operation, wrong owner"\n', '        );\n', '\n', '        serviceProviderInfo[_serviceType][spID].delegateOwnerWallet = _updatedDelegateOwnerWallet;\n', '        emit DelegateOwnerWalletUpdated(\n', '            msg.sender,\n', '            _serviceType,\n', '            spID,\n', '            _updatedDelegateOwnerWallet\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Update the endpoint for a given service\n', '     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n', '     * @param _oldEndpoint - old endpoint currently registered\n', '     * @param _newEndpoint - new endpoint to replace old endpoint\n', '     * @return ID of updated service provider\n', '     */\n', '    function updateEndpoint(\n', '        bytes32 _serviceType,\n', '        string calldata _oldEndpoint,\n', '        string calldata _newEndpoint\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        uint256 spId = this.getServiceProviderIdFromEndpoint(_oldEndpoint);\n', '        require (\n', '            spId != 0,\n', '            "ServiceProviderFactory: Could not find service provider with that endpoint"\n', '        );\n', '\n', '        ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][spId];\n', '\n', '        require(\n', '            serviceEndpoint.owner == msg.sender,\n', '            "ServiceProviderFactory: Invalid update endpoint operation, wrong owner"\n', '        );\n', '        require(\n', '            keccak256(bytes(serviceEndpoint.endpoint)) == keccak256(bytes(_oldEndpoint)),\n', '            "ServiceProviderFactory: Old endpoint doesn\'t match what\'s registered for the service provider"\n', '        );\n', '\n', '        // invalidate old endpoint\n', '        serviceProviderEndpointToId[keccak256(bytes(serviceEndpoint.endpoint))] = 0;\n', '\n', '        // update to new endpoint\n', '        serviceEndpoint.endpoint = _newEndpoint;\n', '        serviceProviderInfo[_serviceType][spId] = serviceEndpoint;\n', '        serviceProviderEndpointToId[keccak256(bytes(_newEndpoint))] = spId;\n', '\n', '        emit EndpointUpdated(_serviceType, msg.sender, _oldEndpoint, _newEndpoint, spId);\n', '        return spId;\n', '    }\n', '\n', '    /**\n', '     * @notice Update the deployer cut for a given service provider\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _cut - new value for deployer cut\n', '     */\n', '    function requestUpdateDeployerCut(address _serviceProvider, uint256 _cut) external\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '\n', '        require(\n', '            (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock == 0) &&\n', '            (updateDeployerCutRequests[_serviceProvider].newDeployerCut == 0),\n', '            "ServiceProviderFactory: Update deployer cut operation pending"\n', '        );\n', '\n', '        require(\n', '            _cut <= DEPLOYER_CUT_BASE,\n', '            "ServiceProviderFactory: Service Provider cut cannot exceed base value"\n', '        );\n', '\n', '        uint256 expiryBlock = block.number + deployerCutLockupDuration;\n', '        updateDeployerCutRequests[_serviceProvider] = UpdateDeployerCutRequest({\n', '            lockupExpiryBlock: expiryBlock,\n', '            newDeployerCut: _cut\n', '        });\n', '\n', '        emit DeployerCutUpdateRequested(_serviceProvider, _cut, expiryBlock);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel a pending request to update deployer cut\n', '     * @param _serviceProvider - address of service provider\n', '     */\n', '    function cancelUpdateDeployerCut(address _serviceProvider) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requirePendingDeployerCutOperation(_serviceProvider);\n', '\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '\n', '        UpdateDeployerCutRequest memory cancelledRequest = (\n', '            updateDeployerCutRequests[_serviceProvider]\n', '        );\n', '\n', '        // Zero out request information\n', '        delete updateDeployerCutRequests[_serviceProvider];\n', '        emit DeployerCutUpdateRequestCancelled(\n', '            _serviceProvider,\n', '            cancelledRequest.newDeployerCut,\n', '            spDetails[_serviceProvider].deployerCut\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Evalue request to update service provider cut of claims\n', '     * @notice Update service provider cut as % of delegate claim, divided by the deployerCutBase.\n', '     * @dev SPs will interact with this value as a percent, value translation done client side\n', '       @dev A value of 5 dictates a 5% cut, with ( 5 / 100 ) * delegateReward going to an SP from each delegator each round.\n', '     */\n', '    function updateDeployerCut(address _serviceProvider) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requirePendingDeployerCutOperation(_serviceProvider);\n', '\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '\n', '        require(\n', '            updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock <= block.number,\n', '            "ServiceProviderFactory: Lockup must be expired"\n', '        );\n', '\n', '        spDetails[_serviceProvider].deployerCut = (\n', '            updateDeployerCutRequests[_serviceProvider].newDeployerCut\n', '        );\n', '\n', '        // Zero out request information\n', '        delete updateDeployerCutRequests[_serviceProvider];\n', '\n', '        emit DeployerCutUpdateRequestEvaluated(\n', '            _serviceProvider,\n', '            spDetails[_serviceProvider].deployerCut\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Update service provider balance\n', '     * @dev Called by DelegateManager by functions modifying entire stake like claim and slash\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _amount - new amount of direct state for service provider\n', '     */\n', '    function updateServiceProviderStake(\n', '        address _serviceProvider,\n', '        uint256 _amount\n', '     ) external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == delegateManagerAddress,\n', '            "ServiceProviderFactory: only callable by DelegateManager"\n', '        );\n', '        // Update SP tracked total\n', '        spDetails[_serviceProvider].deployerStake = _amount;\n', '        _updateServiceProviderBoundStatus(_serviceProvider);\n', '    }\n', '\n', '    /// @notice Update service provider lockup duration\n', '    function updateDecreaseStakeLockupDuration(uint256 _duration) external {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == governanceAddress,\n', '            ERROR_ONLY_GOVERNANCE\n', '        );\n', '\n', '        _updateDecreaseStakeLockupDuration(_duration);\n', '        emit DecreaseStakeLockupDurationUpdated(_duration);\n', '    }\n', '\n', '    /// @notice Update service provider lockup duration\n', '    function updateDeployerCutLockupDuration(uint256 _duration) external {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == governanceAddress,\n', '            ERROR_ONLY_GOVERNANCE\n', '        );\n', '\n', '        _updateDeployerCutLockupDuration(_duration);\n', '        emit UpdateDeployerCutLockupDurationUpdated(_duration);\n', '    }\n', '\n', '    /// @notice Get denominator for deployer cut calculations\n', '    function getServiceProviderDeployerCutBase()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return DEPLOYER_CUT_BASE;\n', '    }\n', '\n', '    /// @notice Get current deployer cut update lockup duration\n', '    function getDeployerCutLockupDuration()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return deployerCutLockupDuration;\n', '    }\n', '\n', '    /// @notice Get total number of service providers for a given serviceType\n', '    function getTotalServiceTypeProviders(bytes32 _serviceType)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderTypeIDs[_serviceType];\n', '    }\n', '\n', '    /// @notice Get service provider id for an endpoint\n', '    function getServiceProviderIdFromEndpoint(string calldata _endpoint)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderEndpointToId[keccak256(bytes(_endpoint))];\n', '    }\n', '\n', '    /**\n', '     * @notice Get service provider ids for a given service provider and service type\n', '     * @return List of service ids of that type for a service provider\n', '     */\n', '    function getServiceProviderIdsFromAddress(address _ownerAddress, bytes32 _serviceType)\n', '    external view returns (uint256[] memory)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderAddressToId[_ownerAddress][_serviceType];\n', '    }\n', '\n', '    /**\n', '     * @notice Get information about a service endpoint given its service id\n', '     * @param _serviceType - type of service, must be a valid service from ServiceTypeManager\n', '     * @param _serviceId - id of service\n', '     */\n', '    function getServiceEndpointInfo(bytes32 _serviceType, uint256 _serviceId)\n', '    external view returns (address owner, string memory endpoint, uint256 blockNumber, address delegateOwnerWallet)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        ServiceEndpoint memory serviceEndpoint = serviceProviderInfo[_serviceType][_serviceId];\n', '        return (\n', '            serviceEndpoint.owner,\n', '            serviceEndpoint.endpoint,\n', '            serviceEndpoint.blocknumber,\n', '            serviceEndpoint.delegateOwnerWallet\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get information about a service provider given their address\n', '     * @param _serviceProvider - address of service provider\n', '     */\n', '    function getServiceProviderDetails(address _serviceProvider)\n', '    external view returns (\n', '        uint256 deployerStake,\n', '        uint256 deployerCut,\n', '        bool validBounds,\n', '        uint256 numberOfEndpoints,\n', '        uint256 minAccountStake,\n', '        uint256 maxAccountStake)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return (\n', '            spDetails[_serviceProvider].deployerStake,\n', '            spDetails[_serviceProvider].deployerCut,\n', '            spDetails[_serviceProvider].validBounds,\n', '            spDetails[_serviceProvider].numberOfEndpoints,\n', '            spDetails[_serviceProvider].minAccountStake,\n', '            spDetails[_serviceProvider].maxAccountStake\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get information about pending decrease stake requests for service provider\n', '     * @param _serviceProvider - address of service provider\n', '     */\n', '    function getPendingDecreaseStakeRequest(address _serviceProvider)\n', '    external view returns (uint256 amount, uint256 lockupExpiryBlock)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return (\n', '            decreaseStakeRequests[_serviceProvider].decreaseAmount,\n', '            decreaseStakeRequests[_serviceProvider].lockupExpiryBlock\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get information about pending decrease stake requests for service provider\n', '     * @param _serviceProvider - address of service provider\n', '     */\n', '    function getPendingUpdateDeployerCutRequest(address _serviceProvider)\n', '    external view returns (uint256 newDeployerCut, uint256 lockupExpiryBlock)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return (\n', '            updateDeployerCutRequests[_serviceProvider].newDeployerCut,\n', '            updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock\n', '        );\n', '    }\n', '\n', '    /// @notice Get current unstake lockup duration\n', '    function getDecreaseStakeLockupDuration()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return decreaseStakeLockupDuration;\n', '    }\n', '\n', '    /**\n', '     * @notice Validate that the total service provider balance is between the min and max stakes\n', '               for all their registered services and validate  direct stake for sp is above minimum\n', '     * @param _serviceProvider - address of service provider\n', '     */\n', '    function validateAccountStakeBalance(address _serviceProvider)\n', '    external view\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '\n', '        _validateBalanceInternal(\n', '            _serviceProvider,\n', '            Staking(stakingAddress).totalStakedFor(_serviceProvider)\n', '        );\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /// @notice Get the Staking address\n', '    function getStakingAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return stakingAddress;\n', '    }\n', '\n', '    /// @notice Get the DelegateManager address\n', '    function getDelegateManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return delegateManagerAddress;\n', '    }\n', '\n', '    /// @notice Get the ServiceTypeManager address\n', '    function getServiceTypeManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return serviceTypeManagerAddress;\n', '    }\n', '\n', '    /// @notice Get the ClaimsManager address\n', '    function getClaimsManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return claimsManagerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        emit GovernanceAddressUpdated(_governanceAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Staking address\n', '     * @dev Only callable by Governance address\n', '     * @param _address - address for new Staking contract\n', '     */\n', '    function setStakingAddress(address _address) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        stakingAddress = _address;\n', '        emit StakingAddressUpdated(_address);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the DelegateManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _address - address for new DelegateManager contract\n', '     */\n', '    function setDelegateManagerAddress(address _address) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        delegateManagerAddress = _address;\n', '        emit DelegateManagerAddressUpdated(_address);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ServiceTypeManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _address - address for new ServiceTypeManager contract\n', '     */\n', '    function setServiceTypeManagerAddress(address _address) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        serviceTypeManagerAddress = _address;\n', '        emit ServiceTypeManagerAddressUpdated(_address);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ClaimsManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _address - address for new ClaimsManager contract\n', '     */\n', '    function setClaimsManagerAddress(address _address) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        claimsManagerAddress = _address;\n', '        emit ClaimsManagerAddressUpdated(_address);\n', '    }\n', '\n', '    // ========================================= Internal Functions =========================================\n', '\n', '    /**\n', '     * @notice Update status in spDetails if the bounds for a service provider is valid\n', '     */\n', '    function _updateServiceProviderBoundStatus(address _serviceProvider) internal {\n', '        // Validate bounds for total stake\n', '        uint256 totalSPStake = Staking(stakingAddress).totalStakedFor(_serviceProvider);\n', '        if (totalSPStake < spDetails[_serviceProvider].minAccountStake ||\n', '            totalSPStake > spDetails[_serviceProvider].maxAccountStake) {\n', '            // Indicate this service provider is out of bounds\n', '            spDetails[_serviceProvider].validBounds = false;\n', '        } else {\n', '            // Indicate this service provider is within bounds\n', '            spDetails[_serviceProvider].validBounds = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) internal {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "ServiceProviderFactory: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the deployer cut lockup duration\n', '     * @param _duration - incoming duration\n', '     */\n', '    function _updateDeployerCutLockupDuration(uint256 _duration) internal\n', '    {\n', '        require(\n', '            ClaimsManager(claimsManagerAddress).getFundingRoundBlockDiff() < _duration,\n', '            "ServiceProviderFactory: Incoming duration must be greater than funding round block diff"\n', '        );\n', '        deployerCutLockupDuration = _duration;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the decrease stake lockup duration\n', '     * @param _duration - incoming duration\n', '     */\n', '    function _updateDecreaseStakeLockupDuration(uint256 _duration) internal\n', '    {\n', '        Governance governance = Governance(governanceAddress);\n', '        require(\n', '            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\n', '            "ServiceProviderFactory: decreaseStakeLockupDuration duration must be greater than governance votingPeriod + executionDelay"\n', '        );\n', '        decreaseStakeLockupDuration = _duration;\n', '    }\n', '\n', '    /**\n', '     * @notice Compare a given amount input against valid min and max bounds for service provider\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _amount - amount in wei to compare\n', '     */\n', '    function _validateBalanceInternal(address _serviceProvider, uint256 _amount) internal view\n', '    {\n', '        require(\n', '            _amount <= spDetails[_serviceProvider].maxAccountStake,\n', '            "ServiceProviderFactory: Maximum stake amount exceeded"\n', '        );\n', '        require(\n', '            spDetails[_serviceProvider].deployerStake >= spDetails[_serviceProvider].minAccountStake,\n', '            "ServiceProviderFactory: Minimum stake requirement not met"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get whether a decrease request has been initiated for service provider\n', '     * @param _serviceProvider - address of service provider\n', '     * return Boolean of whether decrease request has been initiated\n', '     */\n', '    function _decreaseRequestIsPending(address _serviceProvider)\n', '    internal view returns (bool)\n', '    {\n', '        return (\n', '            (decreaseStakeRequests[_serviceProvider].lockupExpiryBlock > 0) &&\n', '            (decreaseStakeRequests[_serviceProvider].decreaseAmount > 0)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Boolean indicating whether a claim is pending for this service provider\n', '     */\n', '     /**\n', '     * @notice Get whether a claim is pending for this service provider\n', '     * @param _serviceProvider - address of service provider\n', '     * return Boolean of whether claim is pending\n', '     */\n', '    function _claimPending(address _serviceProvider) internal view returns (bool) {\n', '        return ClaimsManager(claimsManagerAddress).claimPending(_serviceProvider);\n', '    }\n', '\n', '    // ========================================= Private Functions =========================================\n', '    function _requirePendingDeployerCutOperation (address _serviceProvider) private view {\n', '        require(\n', '            (updateDeployerCutRequests[_serviceProvider].lockupExpiryBlock != 0),\n', '            "ServiceProviderFactory: No update deployer cut operation pending"\n', '        );\n', '    }\n', '\n', '    function _requireStakingAddressIsSet() private view {\n', '        require(\n', '            stakingAddress != address(0x00),\n', '            "ServiceProviderFactory: stakingAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireDelegateManagerAddressIsSet() private view {\n', '        require(\n', '            delegateManagerAddress != address(0x00),\n', '            "ServiceProviderFactory: delegateManagerAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireServiceTypeManagerAddressIsSet() private view {\n', '        require(\n', '            serviceTypeManagerAddress != address(0x00),\n', '            "ServiceProviderFactory: serviceTypeManagerAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireClaimsManagerAddressIsSet() private view {\n', '        require(\n', '            claimsManagerAddress != address(0x00),\n', '            "ServiceProviderFactory: claimsManagerAddress is not set"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/DelegateManager.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/// @notice SafeMath imported via ServiceProviderFactory.sol\n', '/// @notice Governance imported via Staking.sol\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * Designed to manage delegation to staking contract\n', ' */\n', 'contract DelegateManager is InitializableV2 {\n', '    using SafeMath for uint256;\n', '\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "DelegateManager: Only callable by Governance contract"\n', '    );\n', '    string private constant ERROR_MINIMUM_DELEGATION = (\n', '        "DelegateManager: Minimum delegation amount required"\n', '    );\n', '    string private constant ERROR_ONLY_SP_GOVERNANCE = (\n', '        "DelegateManager: Only callable by target SP or governance"\n', '    );\n', '    string private constant ERROR_DELEGATOR_STAKE = (\n', '        "DelegateManager: Delegator must be staked for SP"\n', '    );\n', '\n', '    address private governanceAddress;\n', '    address private stakingAddress;\n', '    address private serviceProviderFactoryAddress;\n', '    address private claimsManagerAddress;\n', '\n', '    /**\n', '     * Period in  blocks an undelegate operation is delayed.\n', '     * The undelegate operation speed bump is to prevent a delegator from\n', '     *      attempting to remove their delegation in anticipation of a slash.\n', '     * @notice Must be greater than governance votingPeriod + executionDelay\n', '     */\n', '    uint256 private undelegateLockupDuration;\n', '\n', '    /// @notice Maximum number of delegators a single account can handle\n', '    uint256 private maxDelegators;\n', '\n', '    /// @notice Minimum amount of delegation allowed\n', '    uint256 private minDelegationAmount;\n', '\n', '    /**\n', '     * Lockup duration for a remove delegator request.\n', '     * The remove delegator speed bump is to prevent a service provider from maliciously\n', '     *     removing a delegator prior to the evaluation of a proposal.\n', '     * @notice Must be greater than governance votingPeriod + executionDelay\n', '     */\n', '    uint256 private removeDelegatorLockupDuration;\n', '\n', '    /**\n', '     * Evaluation period for a remove delegator request\n', '     * @notice added to expiry block calculated for removeDelegatorLockupDuration\n', '     */\n', '    uint256 private removeDelegatorEvalDuration;\n', '\n', '    // Staking contract ref\n', '    ERC20Mintable private audiusToken;\n', '\n', '    // Struct representing total delegated to SP and list of delegators\n', '    struct ServiceProviderDelegateInfo {\n', '        uint256 totalDelegatedStake;\n', '        uint256 totalLockedUpStake;\n', '        address[] delegators;\n', '    }\n', '\n', '    // Data structures for lockup during withdrawal\n', '    struct UndelegateStakeRequest {\n', '        address serviceProvider;\n', '        uint256 amount;\n', '        uint256 lockupExpiryBlock;\n', '    }\n', '\n', '    // Service provider address -> ServiceProviderDelegateInfo\n', '    mapping (address => ServiceProviderDelegateInfo) private spDelegateInfo;\n', '\n', '    // Delegator stake by address delegated to\n', '    // delegator -> (service provider -> delegatedStake)\n', '    mapping (address => mapping(address => uint256)) private delegateInfo;\n', '\n', '    // Delegator stake total by address\n', '    // delegator -> (totalDelegated)\n', '    // Note - delegator properties are maintained in a mapping instead of struct\n', '    // in order to facilitate extensibility in the future.\n', '    mapping (address => uint256) private delegatorTotalStake;\n', '\n', '    // Requester to pending undelegate request\n', '    mapping (address => UndelegateStakeRequest) private undelegateRequests;\n', '\n', '    // Pending remove delegator requests\n', '    // service provider -> (delegator -> lockupExpiryBlock)\n', '    mapping (address => mapping (address => uint256)) private removeDelegatorRequests;\n', '\n', '    event IncreaseDelegatedStake(\n', '        address indexed _delegator,\n', '        address indexed _serviceProvider,\n', '        uint256 indexed _increaseAmount\n', '    );\n', '\n', '    event UndelegateStakeRequested(\n', '        address indexed _delegator,\n', '        address indexed _serviceProvider,\n', '        uint256 indexed _amount,\n', '        uint256 _lockupExpiryBlock\n', '    );\n', '\n', '    event UndelegateStakeRequestCancelled(\n', '        address indexed _delegator,\n', '        address indexed _serviceProvider,\n', '        uint256 indexed _amount\n', '    );\n', '\n', '    event UndelegateStakeRequestEvaluated(\n', '        address indexed _delegator,\n', '        address indexed _serviceProvider,\n', '        uint256 indexed _amount\n', '    );\n', '\n', '    event Claim(\n', '        address indexed _claimer,\n', '        uint256 indexed _rewards,\n', '        uint256 indexed _newTotal\n', '    );\n', '\n', '    event Slash(\n', '        address indexed _target,\n', '        uint256 indexed _amount,\n', '        uint256 indexed _newTotal\n', '    );\n', '\n', '    event RemoveDelegatorRequested(\n', '        address indexed _serviceProvider,\n', '        address indexed _delegator,\n', '        uint256 indexed _lockupExpiryBlock\n', '    );\n', '\n', '    event RemoveDelegatorRequestCancelled(\n', '        address indexed _serviceProvider,\n', '        address indexed _delegator\n', '    );\n', '\n', '    event RemoveDelegatorRequestEvaluated(\n', '        address indexed _serviceProvider,\n', '        address indexed _delegator,\n', '        uint256 indexed _unstakedAmount\n', '    );\n', '\n', '    event MaxDelegatorsUpdated(uint256 indexed _maxDelegators);\n', '    event MinDelegationUpdated(uint256 indexed _minDelegationAmount);\n', '    event UndelegateLockupDurationUpdated(uint256 indexed _undelegateLockupDuration);\n', '    event GovernanceAddressUpdated(address indexed _newGovernanceAddress);\n', '    event StakingAddressUpdated(address indexed _newStakingAddress);\n', '    event ServiceProviderFactoryAddressUpdated(address indexed _newServiceProviderFactoryAddress);\n', '    event ClaimsManagerAddressUpdated(address indexed _newClaimsManagerAddress);\n', '    event RemoveDelegatorLockupDurationUpdated(uint256 indexed _removeDelegatorLockupDuration);\n', '    event RemoveDelegatorEvalDurationUpdated(uint256 indexed _removeDelegatorEvalDuration);\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @dev stakingAddress must be initialized separately after Staking contract is deployed\n', '     * @dev serviceProviderFactoryAddress must be initialized separately after ServiceProviderFactory contract is deployed\n', '     * @dev claimsManagerAddress must be initialized separately after ClaimsManager contract is deployed\n', '     * @param _tokenAddress - address of ERC20 token that will be claimed\n', '     * @param _governanceAddress - Governance proxy address\n', '     */\n', '    function initialize (\n', '        address _tokenAddress,\n', '        address _governanceAddress,\n', '        uint256 _undelegateLockupDuration\n', '    ) public initializer\n', '    {\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        audiusToken = ERC20Mintable(_tokenAddress);\n', '        maxDelegators = 175;\n', '        // Default minimum delegation amount set to 100AUD\n', '        minDelegationAmount = 100 * 10**uint256(18);\n', '        InitializableV2.initialize();\n', '\n', '        _updateUndelegateLockupDuration(_undelegateLockupDuration);\n', '\n', '        // 1 week = 168hrs * 60 min/hr * 60 sec/min / ~13 sec/block = 46523 blocks\n', '        _updateRemoveDelegatorLockupDuration(46523);\n', '\n', '        // 24hr * 60min/hr * 60sec/min / ~13 sec/block = 6646 blocks\n', '        removeDelegatorEvalDuration = 6646;\n', '    }\n', '\n', '    /**\n', '     * @notice Allow a delegator to delegate stake to a service provider\n', '     * @param _targetSP - address of service provider to delegate to\n', '     * @param _amount - amount in wei to delegate\n', '     * @return Updated total amount delegated to the service provider by delegator\n', '     */\n', '    function delegateStake(\n', '        address _targetSP,\n', '        uint256 _amount\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            !_claimPending(_targetSP),\n', '            "DelegateManager: Delegation not permitted for SP pending claim"\n', '        );\n', '        address delegator = msg.sender;\n', '        Staking stakingContract = Staking(stakingAddress);\n', '\n', '        // Stake on behalf of target service provider\n', '        stakingContract.delegateStakeFor(\n', '            _targetSP,\n', '            delegator,\n', '            _amount\n', '        );\n', '\n', '        // Update list of delegators to SP if necessary\n', '        if (!_delegatorExistsForSP(delegator, _targetSP)) {\n', '            // If not found, update list of delegates\n', '            spDelegateInfo[_targetSP].delegators.push(delegator);\n', '            require(\n', '                spDelegateInfo[_targetSP].delegators.length <= maxDelegators,\n', '                "DelegateManager: Maximum delegators exceeded"\n', '            );\n', '        }\n', '\n', '        // Update following values in storage through helper\n', '        // totalServiceProviderDelegatedStake = current sp total + new amount,\n', '        // totalStakedForSpFromDelegator = current delegator total for sp + new amount,\n', '        // totalDelegatorStake = current delegator total + new amount\n', '        _updateDelegatorStake(\n', '            delegator,\n', '            _targetSP,\n', '            spDelegateInfo[_targetSP].totalDelegatedStake.add(_amount),\n', '            delegateInfo[delegator][_targetSP].add(_amount),\n', '            delegatorTotalStake[delegator].add(_amount)\n', '        );\n', '\n', '        require(\n', '            delegateInfo[delegator][_targetSP] >= minDelegationAmount,\n', '            ERROR_MINIMUM_DELEGATION\n', '        );\n', '\n', '        // Validate balance\n', '        ServiceProviderFactory(\n', '            serviceProviderFactoryAddress\n', '        ).validateAccountStakeBalance(_targetSP);\n', '\n', '        emit IncreaseDelegatedStake(\n', '            delegator,\n', '            _targetSP,\n', '            _amount\n', '        );\n', '\n', '        // Return new total\n', '        return delegateInfo[delegator][_targetSP];\n', '    }\n', '\n', '    /**\n', '     * @notice Submit request for undelegation\n', '     * @param _target - address of service provider to undelegate stake from\n', '     * @param _amount - amount in wei to undelegate\n', '     * @return Updated total amount delegated to the service provider by delegator\n', '     */\n', '    function requestUndelegateStake(\n', '        address _target,\n', '        uint256 _amount\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        require(\n', '            _amount > 0,\n', '            "DelegateManager: Requested undelegate stake amount must be greater than zero"\n', '        );\n', '        require(\n', '            !_claimPending(_target),\n', '            "DelegateManager: Undelegate request not permitted for SP pending claim"\n', '        );\n', '        address delegator = msg.sender;\n', '        require(\n', '            _delegatorExistsForSP(delegator, _target),\n', '            ERROR_DELEGATOR_STAKE\n', '        );\n', '\n', '        // Confirm no pending delegation request\n', '        require(\n', '            !_undelegateRequestIsPending(delegator),\n', '            "DelegateManager: No pending lockup expected"\n', '        );\n', '\n', '        // Ensure valid bounds\n', '        uint256 currentlyDelegatedToSP = delegateInfo[delegator][_target];\n', '        require(\n', '            _amount <= currentlyDelegatedToSP,\n', '            "DelegateManager: Cannot decrease greater than currently staked for this ServiceProvider"\n', '        );\n', '\n', '        // Submit updated request for sender, with target sp, undelegate amount, target expiry block\n', '        uint256 lockupExpiryBlock = block.number.add(undelegateLockupDuration);\n', '        _updateUndelegateStakeRequest(\n', '            delegator,\n', '            _target,\n', '            _amount,\n', '            lockupExpiryBlock\n', '        );\n', '        // Update total locked for this service provider, increasing by unstake amount\n', '        _updateServiceProviderLockupAmount(\n', '            _target,\n', '            spDelegateInfo[_target].totalLockedUpStake.add(_amount)\n', '        );\n', '\n', '        emit UndelegateStakeRequested(delegator, _target, _amount, lockupExpiryBlock);\n', '        return delegateInfo[delegator][_target].sub(_amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel undelegation request\n', '     */\n', '    function cancelUndelegateStakeRequest() external {\n', '        _requireIsInitialized();\n', '\n', '        address delegator = msg.sender;\n', '        // Confirm pending delegation request\n', '        require(\n', '            _undelegateRequestIsPending(delegator),\n', '            "DelegateManager: Pending lockup expected"\n', '        );\n', '        uint256 unstakeAmount = undelegateRequests[delegator].amount;\n', '        address unlockFundsSP = undelegateRequests[delegator].serviceProvider;\n', '        // Update total locked for this service provider, decreasing by unstake amount\n', '        _updateServiceProviderLockupAmount(\n', '            unlockFundsSP,\n', '            spDelegateInfo[unlockFundsSP].totalLockedUpStake.sub(unstakeAmount)\n', '        );\n', '        // Remove pending request\n', '        _resetUndelegateStakeRequest(delegator);\n', '        emit UndelegateStakeRequestCancelled(delegator, unlockFundsSP, unstakeAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Finalize undelegation request and withdraw stake\n', '     * @return New total amount currently staked after stake has been undelegated\n', '     */\n', '    function undelegateStake() external returns (uint256) {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        address delegator = msg.sender;\n', '\n', '        // Confirm pending delegation request\n', '        require(\n', '            _undelegateRequestIsPending(delegator),\n', '            "DelegateManager: Pending lockup expected"\n', '        );\n', '\n', '        // Confirm lockup expiry has expired\n', '        require(\n', '            undelegateRequests[delegator].lockupExpiryBlock <= block.number,\n', '            "DelegateManager: Lockup must be expired"\n', '        );\n', '\n', '        // Confirm no pending claim for this service provider\n', '        require(\n', '            !_claimPending(undelegateRequests[delegator].serviceProvider),\n', '            "DelegateManager: Undelegate not permitted for SP pending claim"\n', '        );\n', '\n', '        address serviceProvider = undelegateRequests[delegator].serviceProvider;\n', '        uint256 unstakeAmount = undelegateRequests[delegator].amount;\n', '\n', '        // Unstake on behalf of target service provider\n', '        Staking(stakingAddress).undelegateStakeFor(\n', '            serviceProvider,\n', '            delegator,\n', '            unstakeAmount\n', '        );\n', '\n', '        // Update total delegated for SP\n', '        // totalServiceProviderDelegatedStake - total amount delegated to service provider\n', '        // totalStakedForSpFromDelegator - amount staked from this delegator to targeted service provider\n', '        _updateDelegatorStake(\n', '            delegator,\n', '            serviceProvider,\n', '            spDelegateInfo[serviceProvider].totalDelegatedStake.sub(unstakeAmount),\n', '            delegateInfo[delegator][serviceProvider].sub(unstakeAmount),\n', '            delegatorTotalStake[delegator].sub(unstakeAmount)\n', '        );\n', '\n', '        require(\n', '            (delegateInfo[delegator][serviceProvider] >= minDelegationAmount ||\n', '             delegateInfo[delegator][serviceProvider] == 0),\n', '            ERROR_MINIMUM_DELEGATION\n', '        );\n', '\n', '        // Remove from delegators list if no delegated stake remaining\n', '        if (delegateInfo[delegator][serviceProvider] == 0) {\n', '            _removeFromDelegatorsList(serviceProvider, delegator);\n', '        }\n', '\n', '        // Update total locked for this service provider, decreasing by unstake amount\n', '        _updateServiceProviderLockupAmount(\n', '            serviceProvider,\n', '            spDelegateInfo[serviceProvider].totalLockedUpStake.sub(unstakeAmount)\n', '        );\n', '        // Reset undelegate request\n', '        _resetUndelegateStakeRequest(delegator);\n', '\n', '        emit UndelegateStakeRequestEvaluated(\n', '            delegator,\n', '            serviceProvider,\n', '            unstakeAmount\n', '        );\n', '\n', '        // Return new total\n', '        return delegateInfo[delegator][serviceProvider];\n', '    }\n', '\n', '    /**\n', '     * @notice Claim and distribute rewards to delegators and service provider as necessary\n', '     * @param _serviceProvider - Provider for which rewards are being distributed\n', '     * @dev Factors in service provider rewards from delegator and transfers deployer cut\n', '     */\n', '    function claimRewards(address _serviceProvider) external {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireClaimsManagerAddressIsSet();\n', '\n', '        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\n', '\n', '        // Total rewards = (balance in staking) - ((balance in sp factory) + (balance in delegate manager))\n', '        (\n', '            uint256 totalBalanceInStaking,\n', '            uint256 totalBalanceInSPFactory,\n', '            uint256 totalActiveFunds,\n', '            uint256 totalRewards,\n', '            uint256 deployerCut\n', '        ) = _validateClaimRewards(spFactory, _serviceProvider);\n', '\n', '        // No-op if balance is already equivalent\n', '        // This case can occur if no rewards due to bound violation or all stake is locked\n', '        if (totalRewards == 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 totalDelegatedStakeIncrease = _distributeDelegateRewards(\n', '            _serviceProvider,\n', '            totalActiveFunds,\n', '            totalRewards,\n', '            deployerCut,\n', '            spFactory.getServiceProviderDeployerCutBase()\n', '        );\n', '\n', '        // Update total delegated to this SP\n', '        spDelegateInfo[_serviceProvider].totalDelegatedStake = (\n', '            spDelegateInfo[_serviceProvider].totalDelegatedStake.add(totalDelegatedStakeIncrease)\n', '        );\n', '\n', '        // spRewardShare represents rewards directly allocated to service provider for their stake\n', '        // Value is computed as the remainder of total minted rewards after distribution to\n', '        // delegators, eliminating any potential for precision loss.\n', '        uint256 spRewardShare = totalRewards.sub(totalDelegatedStakeIncrease);\n', '\n', '        // Adding the newly calculated reward share to current balance\n', '        uint256 newSPFactoryBalance = totalBalanceInSPFactory.add(spRewardShare);\n', '\n', '        require(\n', '            totalBalanceInStaking == newSPFactoryBalance.add(spDelegateInfo[_serviceProvider].totalDelegatedStake),\n', '            "DelegateManager: claimRewards amount mismatch"\n', '        );\n', '\n', '        spFactory.updateServiceProviderStake(\n', '            _serviceProvider,\n', '            newSPFactoryBalance\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Reduce current stake amount\n', '     * @dev Only callable by governance. Slashes service provider and delegators equally\n', '     * @param _amount - amount in wei to slash\n', '     * @param _slashAddress - address of service provider to slash\n', '     */\n', '    function slash(uint256 _amount, address _slashAddress)\n', '    external\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        Staking stakingContract = Staking(stakingAddress);\n', '        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\n', '\n', '        // Amount stored in staking contract for owner\n', '        uint256 totalBalanceInStakingPreSlash = stakingContract.totalStakedFor(_slashAddress);\n', '        require(\n', '            (totalBalanceInStakingPreSlash >= _amount),\n', '            "DelegateManager: Cannot slash more than total currently staked"\n', '        );\n', '\n', '        // Cancel any withdrawal request for this service provider\n', '        (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_slashAddress);\n', '        if (spLockedStake > 0) {\n', '            spFactory.cancelDecreaseStakeRequest(_slashAddress);\n', '        }\n', '\n', '        // Amount in sp factory for slash target\n', '        (uint256 totalBalanceInSPFactory,,,,,) = (\n', '            spFactory.getServiceProviderDetails(_slashAddress)\n', '        );\n', '        require(\n', '            totalBalanceInSPFactory > 0,\n', '            "DelegateManager: Service Provider stake required"\n', '        );\n', '\n', '        // Decrease value in Staking contract\n', '        // A value of zero slash will fail in staking, reverting this transaction\n', '        stakingContract.slash(_amount, _slashAddress);\n', '        uint256 totalBalanceInStakingAfterSlash = stakingContract.totalStakedFor(_slashAddress);\n', '\n', '        // Emit slash event\n', '        emit Slash(_slashAddress, _amount, totalBalanceInStakingAfterSlash);\n', '\n', '        uint256 totalDelegatedStakeDecrease = 0;\n', '        // For each delegator and deployer, recalculate new value\n', '        // newStakeAmount = newStakeAmount * (oldStakeAmount / totalBalancePreSlash)\n', '        for (uint256 i = 0; i < spDelegateInfo[_slashAddress].delegators.length; i++) {\n', '            address delegator = spDelegateInfo[_slashAddress].delegators[i];\n', '            uint256 preSlashDelegateStake = delegateInfo[delegator][_slashAddress];\n', '            uint256 newDelegateStake = (\n', '             totalBalanceInStakingAfterSlash.mul(preSlashDelegateStake)\n', '            ).div(totalBalanceInStakingPreSlash);\n', '            // slashAmountForDelegator = preSlashDelegateStake - newDelegateStake;\n', '            delegateInfo[delegator][_slashAddress] = (\n', '                delegateInfo[delegator][_slashAddress].sub(preSlashDelegateStake.sub(newDelegateStake))\n', '            );\n', '            // Update total stake for delegator\n', '            _updateDelegatorTotalStake(\n', '                delegator,\n', '                delegatorTotalStake[delegator].sub(preSlashDelegateStake.sub(newDelegateStake))\n', '            );\n', '            // Update total decrease amount\n', '            totalDelegatedStakeDecrease = (\n', '                totalDelegatedStakeDecrease.add(preSlashDelegateStake.sub(newDelegateStake))\n', '            );\n', '            // Check for any locked up funds for this slashed delegator\n', '            // Slash overrides any pending withdrawal requests\n', '            if (undelegateRequests[delegator].amount != 0) {\n', '                address unstakeSP = undelegateRequests[delegator].serviceProvider;\n', '                uint256 unstakeAmount = undelegateRequests[delegator].amount;\n', '                // Remove pending request\n', '                _updateServiceProviderLockupAmount(\n', '                    unstakeSP,\n', '                    spDelegateInfo[unstakeSP].totalLockedUpStake.sub(unstakeAmount)\n', '                );\n', '                _resetUndelegateStakeRequest(delegator);\n', '            }\n', '        }\n', '\n', '        // Update total delegated to this SP\n', '        spDelegateInfo[_slashAddress].totalDelegatedStake = (\n', '            spDelegateInfo[_slashAddress].totalDelegatedStake.sub(totalDelegatedStakeDecrease)\n', '        );\n', '\n', '        // Remaining decrease applied to service provider\n', '        uint256 totalStakeDecrease = (\n', '            totalBalanceInStakingPreSlash.sub(totalBalanceInStakingAfterSlash)\n', '        );\n', '        uint256 totalSPFactoryBalanceDecrease = (\n', '            totalStakeDecrease.sub(totalDelegatedStakeDecrease)\n', '        );\n', '        spFactory.updateServiceProviderStake(\n', '            _slashAddress,\n', '            totalBalanceInSPFactory.sub(totalSPFactoryBalanceDecrease)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Initiate forcible removal of a delegator\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _delegator - address of delegator\n', '     */\n', '    function requestRemoveDelegator(address _serviceProvider, address _delegator) external {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '\n', '        require(\n', '            removeDelegatorRequests[_serviceProvider][_delegator] == 0,\n', '            "DelegateManager: Pending remove delegator request"\n', '        );\n', '\n', '        require(\n', '            _delegatorExistsForSP(_delegator, _serviceProvider),\n', '            ERROR_DELEGATOR_STAKE\n', '        );\n', '\n', '        // Update lockup\n', '        removeDelegatorRequests[_serviceProvider][_delegator] = (\n', '            block.number + removeDelegatorLockupDuration\n', '        );\n', '\n', '        emit RemoveDelegatorRequested(\n', '            _serviceProvider,\n', '            _delegator,\n', '            removeDelegatorRequests[_serviceProvider][_delegator]\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Cancel pending removeDelegator request\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _delegator - address of delegator\n', '     */\n', '    function cancelRemoveDelegatorRequest(address _serviceProvider, address _delegator) external {\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '        require(\n', '            removeDelegatorRequests[_serviceProvider][_delegator] != 0,\n', '            "DelegateManager: No pending request"\n', '        );\n', '        // Reset lockup expiry\n', '        removeDelegatorRequests[_serviceProvider][_delegator] = 0;\n', '        emit RemoveDelegatorRequestCancelled(_serviceProvider, _delegator);\n', '    }\n', '\n', '    /**\n', '     * @notice Evaluate removeDelegator request\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _delegator - address of delegator\n', '     * @return Updated total amount delegated to the service provider by delegator\n', '     */\n', '    function removeDelegator(address _serviceProvider, address _delegator) external {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '\n', '        require(\n', '            msg.sender == _serviceProvider || msg.sender == governanceAddress,\n', '            ERROR_ONLY_SP_GOVERNANCE\n', '        );\n', '\n', '        require(\n', '            removeDelegatorRequests[_serviceProvider][_delegator] != 0,\n', '            "DelegateManager: No pending request"\n', '        );\n', '\n', '        // Enforce lockup expiry block\n', '        require(\n', '            block.number >= removeDelegatorRequests[_serviceProvider][_delegator],\n', '            "DelegateManager: Lockup must be expired"\n', '        );\n', '\n', '        // Enforce evaluation window for request\n', '        require(\n', '            block.number < removeDelegatorRequests[_serviceProvider][_delegator] + removeDelegatorEvalDuration,\n', '            "DelegateManager: RemoveDelegator evaluation window expired"\n', '        );\n', '\n', '        uint256 unstakeAmount = delegateInfo[_delegator][_serviceProvider];\n', '        // Unstake on behalf of target service provider\n', '        Staking(stakingAddress).undelegateStakeFor(\n', '            _serviceProvider,\n', '            _delegator,\n', '            unstakeAmount\n', '        );\n', '        // Update total delegated for SP\n', '        // totalServiceProviderDelegatedStake - total amount delegated to service provider\n', '        // totalStakedForSpFromDelegator - amount staked from this delegator to targeted service provider\n', '        _updateDelegatorStake(\n', '            _delegator,\n', '            _serviceProvider,\n', '            spDelegateInfo[_serviceProvider].totalDelegatedStake.sub(unstakeAmount),\n', '            delegateInfo[_delegator][_serviceProvider].sub(unstakeAmount),\n', '            delegatorTotalStake[_delegator].sub(unstakeAmount)\n', '        );\n', '\n', '        if (\n', '            _undelegateRequestIsPending(_delegator) &&\n', '            undelegateRequests[_delegator].serviceProvider == _serviceProvider\n', '        ) {\n', '            // Remove pending request information\n', '            _updateServiceProviderLockupAmount(\n', '                _serviceProvider,\n', '                spDelegateInfo[_serviceProvider].totalLockedUpStake.sub(undelegateRequests[_delegator].amount)\n', '            );\n', '            _resetUndelegateStakeRequest(_delegator);\n', '        }\n', '\n', '        // Remove from list of delegators\n', '        _removeFromDelegatorsList(_serviceProvider, _delegator);\n', '\n', '        // Reset lockup expiry\n', '        removeDelegatorRequests[_serviceProvider][_delegator] = 0;\n', '        emit RemoveDelegatorRequestEvaluated(_serviceProvider, _delegator, unstakeAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Update duration for undelegate request lockup\n', '     * @param _duration - new lockup duration\n', '     */\n', '    function updateUndelegateLockupDuration(uint256 _duration) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        _updateUndelegateLockupDuration(_duration);\n', '        emit UndelegateLockupDurationUpdated(_duration);\n', '    }\n', '\n', '    /**\n', '     * @notice Update maximum delegators allowed\n', '     * @param _maxDelegators - new max delegators\n', '     */\n', '    function updateMaxDelegators(uint256 _maxDelegators) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        maxDelegators = _maxDelegators;\n', '        emit MaxDelegatorsUpdated(_maxDelegators);\n', '    }\n', '\n', '    /**\n', '     * @notice Update minimum delegation amount\n', '     * @param _minDelegationAmount - min new min delegation amount\n', '     */\n', '    function updateMinDelegationAmount(uint256 _minDelegationAmount) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        minDelegationAmount = _minDelegationAmount;\n', '        emit MinDelegationUpdated(_minDelegationAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Update remove delegator lockup duration\n', '     * @param _duration - new lockup duration\n', '     */\n', '    function updateRemoveDelegatorLockupDuration(uint256 _duration) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        _updateRemoveDelegatorLockupDuration(_duration);\n', '        emit RemoveDelegatorLockupDurationUpdated(_duration);\n', '    }\n', '\n', '    /**\n', '     * @notice Update remove delegator evaluation window duration\n', '     * @param _duration - new window duration\n', '     */\n', '    function updateRemoveDelegatorEvalDuration(uint256 _duration) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        removeDelegatorEvalDuration = _duration;\n', '        emit RemoveDelegatorEvalDurationUpdated(_duration);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        governanceAddress = _governanceAddress;\n', '        emit GovernanceAddressUpdated(_governanceAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Staking address\n', '     * @dev Only callable by Governance address\n', '     * @param _stakingAddress - address for new Staking contract\n', '     */\n', '    function setStakingAddress(address _stakingAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        stakingAddress = _stakingAddress;\n', '        emit StakingAddressUpdated(_stakingAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ServiceProviderFactory address\n', '     * @dev Only callable by Governance address\n', '     * @param _spFactory - address for new ServiceProviderFactory contract\n', '     */\n', '    function setServiceProviderFactoryAddress(address _spFactory) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        serviceProviderFactoryAddress = _spFactory;\n', '        emit ServiceProviderFactoryAddressUpdated(_spFactory);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ClaimsManager address\n', '     * @dev Only callable by Governance address\n', '     * @param _claimsManagerAddress - address for new ClaimsManager contract\n', '     */\n', '    function setClaimsManagerAddress(address _claimsManagerAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        claimsManagerAddress = _claimsManagerAddress;\n', '        emit ClaimsManagerAddressUpdated(_claimsManagerAddress);\n', '    }\n', '\n', '    // ========================================= View Functions =========================================\n', '\n', '    /**\n', '     * @notice Get list of delegators for a given service provider\n', '     * @param _sp - service provider address\n', '     */\n', '    function getDelegatorsList(address _sp)\n', '    external view returns (address[] memory)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return spDelegateInfo[_sp].delegators;\n', '    }\n', '\n', '    /**\n', '     * @notice Get total delegation from a given address\n', '     * @param _delegator - delegator address\n', '     */\n', '    function getTotalDelegatorStake(address _delegator)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return delegatorTotalStake[_delegator];\n', '    }\n', '\n', '    /// @notice Get total amount delegated to a service provider\n', '    function getTotalDelegatedToServiceProvider(address _sp)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return spDelegateInfo[_sp].totalDelegatedStake;\n', '    }\n', '\n', '    /// @notice Get total delegated stake locked up for a service provider\n', '    function getTotalLockedDelegationForServiceProvider(address _sp)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return spDelegateInfo[_sp].totalLockedUpStake;\n', '    }\n', '\n', '    /// @notice Get total currently staked for a delegator, for a given service provider\n', '    function getDelegatorStakeForServiceProvider(address _delegator, address _serviceProvider)\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return delegateInfo[_delegator][_serviceProvider];\n', '    }\n', '\n', '    /**\n', '     * @notice Get status of pending undelegate request for a given address\n', '     * @param _delegator - address of the delegator\n', '     */\n', '    function getPendingUndelegateRequest(address _delegator)\n', '    external view returns (address target, uint256 amount, uint256 lockupExpiryBlock)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        UndelegateStakeRequest memory req = undelegateRequests[_delegator];\n', '        return (req.serviceProvider, req.amount, req.lockupExpiryBlock);\n', '    }\n', '\n', '    /**\n', '     * @notice Get status of pending remove delegator request for a given address\n', '     * @param _serviceProvider - address of the service provider\n', '     * @param _delegator - address of the delegator\n', '     * @return - current lockup expiry block for remove delegator request\n', '     */\n', '    function getPendingRemoveDelegatorRequest(\n', '        address _serviceProvider,\n', '        address _delegator\n', '    ) external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return removeDelegatorRequests[_serviceProvider][_delegator];\n', '    }\n', '\n', '    /// @notice Get current undelegate lockup duration\n', '    function getUndelegateLockupDuration()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return undelegateLockupDuration;\n', '    }\n', '\n', '    /// @notice Current maximum delegators\n', '    function getMaxDelegators()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return maxDelegators;\n', '    }\n', '\n', '    /// @notice Get minimum delegation amount\n', '    function getMinDelegationAmount()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return minDelegationAmount;\n', '    }\n', '\n', '    /// @notice Get the duration for remove delegator request lockup\n', '    function getRemoveDelegatorLockupDuration()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return removeDelegatorLockupDuration;\n', '    }\n', '\n', '    /// @notice Get the duration for evaluation of remove delegator operations\n', '    function getRemoveDelegatorEvalDuration()\n', '    external view returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return removeDelegatorEvalDuration;\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /// @notice Get the ServiceProviderFactory address\n', '    function getServiceProviderFactoryAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderFactoryAddress;\n', '    }\n', '\n', '    /// @notice Get the ClaimsManager address\n', '    function getClaimsManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return claimsManagerAddress;\n', '    }\n', '\n', '    /// @notice Get the Staking address\n', '    function getStakingAddress() external view returns (address)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        return stakingAddress;\n', '    }\n', '\n', '    // ========================================= Internal functions =========================================\n', '\n', '    /**\n', '     * @notice Helper function for claimRewards to get balances from Staking contract\n', '               and do validation\n', '     * @param spFactory - reference to ServiceProviderFactory contract\n', '     * @param _serviceProvider - address for which rewards are being claimed\n', '     * @return (totalBalanceInStaking, totalBalanceInSPFactory, totalActiveFunds, spLockedStake, totalRewards, deployerCut)\n', '     */\n', '    function _validateClaimRewards(ServiceProviderFactory spFactory, address _serviceProvider)\n', '    internal returns (\n', '        uint256 totalBalanceInStaking,\n', '        uint256 totalBalanceInSPFactory,\n', '        uint256 totalActiveFunds,\n', '        uint256 totalRewards,\n', '        uint256 deployerCut\n', '    )\n', '    {\n', '        // Account for any pending locked up stake for the service provider\n', '        (uint256 spLockedStake,) = spFactory.getPendingDecreaseStakeRequest(_serviceProvider);\n', '        uint256 totalLockedUpStake = (\n', '            spDelegateInfo[_serviceProvider].totalLockedUpStake.add(spLockedStake)\n', '        );\n', '\n', '        // Process claim for msg.sender\n', '        // Total locked parameter is equal to delegate locked up stake + service provider locked up stake\n', '        uint256 mintedRewards = ClaimsManager(claimsManagerAddress).processClaim(\n', '            _serviceProvider,\n', '            totalLockedUpStake\n', '        );\n', '\n', '        // Amount stored in staking contract for owner\n', '        totalBalanceInStaking = Staking(stakingAddress).totalStakedFor(_serviceProvider);\n', '\n', '        // Amount in sp factory for claimer\n', '        (\n', '            totalBalanceInSPFactory,\n', '            deployerCut,\n', '            ,,,\n', '        ) = spFactory.getServiceProviderDetails(_serviceProvider);\n', '        // Require active stake to claim any rewards\n', '\n', '        // Amount in delegate manager staked to service provider\n', '        uint256 totalBalanceOutsideStaking = (\n', '            totalBalanceInSPFactory.add(spDelegateInfo[_serviceProvider].totalDelegatedStake)\n', '        );\n', '\n', '        totalActiveFunds = totalBalanceOutsideStaking.sub(totalLockedUpStake);\n', '\n', '        require(\n', '            mintedRewards == totalBalanceInStaking.sub(totalBalanceOutsideStaking),\n', '            "DelegateManager: Reward amount mismatch"\n', '        );\n', '\n', '        // Emit claim event\n', '        emit Claim(_serviceProvider, totalRewards, totalBalanceInStaking);\n', '\n', '        return (\n', '            totalBalanceInStaking,\n', '            totalBalanceInSPFactory,\n', '            totalActiveFunds,\n', '            mintedRewards,\n', '            deployerCut\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Perform state updates when a delegate stake has changed\n', '     * @param _delegator - address of delegator\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _totalServiceProviderDelegatedStake - total delegated to this service provider\n', '     * @param _totalStakedForSpFromDelegator - total delegated to this service provider by delegator\n', '     * @param _totalDelegatorStake - total delegated from this delegator address\n', '     */\n', '    function _updateDelegatorStake(\n', '        address _delegator,\n', '        address _serviceProvider,\n', '        uint256 _totalServiceProviderDelegatedStake,\n', '        uint256 _totalStakedForSpFromDelegator,\n', '        uint256 _totalDelegatorStake\n', '    ) internal\n', '    {\n', '        // Update total delegated for SP\n', '        spDelegateInfo[_serviceProvider].totalDelegatedStake = _totalServiceProviderDelegatedStake;\n', '\n', '        // Update amount staked from this delegator to targeted service provider\n', '        delegateInfo[_delegator][_serviceProvider] = _totalStakedForSpFromDelegator;\n', '\n', '        // Update total delegated from this delegator\n', '        _updateDelegatorTotalStake(_delegator, _totalDelegatorStake);\n', '    }\n', '\n', '    /**\n', '     * @notice Reset pending undelegate stake request\n', '     * @param _delegator - address of delegator\n', '     */\n', '    function _resetUndelegateStakeRequest(address _delegator) internal\n', '    {\n', '        _updateUndelegateStakeRequest(_delegator, address(0), 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Perform updates when undelegate request state has changed\n', '     * @param _delegator - address of delegator\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _amount - amount being undelegated\n', '     * @param _lockupExpiryBlock - block at which stake can be undelegated\n', '     */\n', '    function _updateUndelegateStakeRequest(\n', '        address _delegator,\n', '        address _serviceProvider,\n', '        uint256 _amount,\n', '        uint256 _lockupExpiryBlock\n', '    ) internal\n', '    {\n', '        // Update lockup information\n', '        undelegateRequests[_delegator] = UndelegateStakeRequest({\n', '            lockupExpiryBlock: _lockupExpiryBlock,\n', '            amount: _amount,\n', '            serviceProvider: _serviceProvider\n', '        });\n', '    }\n', '\n', '    /**\n', '     * @notice Update total amount delegated from an address\n', '     * @param _delegator - address of service provider\n', '     * @param _amount - updated delegator total\n', '     */\n', '    function _updateDelegatorTotalStake(address _delegator, uint256 _amount) internal\n', '    {\n', '        delegatorTotalStake[_delegator] = _amount;\n', '    }\n', '\n', '    /**\n', '     * @notice Update amount currently locked up for this service provider\n', '     * @param _serviceProvider - address of service provider\n', '     * @param _updatedLockupAmount - updated lock up amount\n', '     */\n', '    function _updateServiceProviderLockupAmount(\n', '        address _serviceProvider,\n', '        uint256 _updatedLockupAmount\n', '    ) internal\n', '    {\n', '        spDelegateInfo[_serviceProvider].totalLockedUpStake = _updatedLockupAmount;\n', '    }\n', '\n', '    function _removeFromDelegatorsList(address _serviceProvider, address _delegator) internal\n', '    {\n', '        for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {\n', '            if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {\n', '                // Overwrite and shrink delegators list\n', '                spDelegateInfo[_serviceProvider].delegators[i] = spDelegateInfo[_serviceProvider].delegators[spDelegateInfo[_serviceProvider].delegators.length - 1];\n', '                spDelegateInfo[_serviceProvider].delegators.length--;\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Helper function to distribute rewards to any delegators\n', '     * @param _sp - service provider account tracked in staking\n', '     * @param _totalActiveFunds - total funds minus any locked stake\n', '     * @param _totalRewards - total rewaards generated in this round\n', '     * @param _deployerCut - service provider cut of delegate rewards, defined as deployerCut / deployerCutBase\n', '     * @param _deployerCutBase - denominator value for calculating service provider cut as a %\n', '     * @return (totalBalanceInStaking, totalBalanceInSPFactory, totalBalanceOutsideStaking)\n', '     */\n', '    function _distributeDelegateRewards(\n', '        address _sp,\n', '        uint256 _totalActiveFunds,\n', '        uint256 _totalRewards,\n', '        uint256 _deployerCut,\n', '        uint256 _deployerCutBase\n', '    )\n', '    internal returns (uint256 totalDelegatedStakeIncrease)\n', '    {\n', '        // Traverse all delegates and calculate their rewards\n', '        // As each delegate reward is calculated, increment SP cut reward accordingly\n', '        for (uint256 i = 0; i < spDelegateInfo[_sp].delegators.length; i++) {\n', '            address delegator = spDelegateInfo[_sp].delegators[i];\n', '            uint256 delegateStakeToSP = delegateInfo[delegator][_sp];\n', '\n', '            // Subtract any locked up stake\n', '            if (undelegateRequests[delegator].serviceProvider == _sp) {\n', '                delegateStakeToSP = delegateStakeToSP.sub(undelegateRequests[delegator].amount);\n', '            }\n', '\n', '            // Calculate rewards by ((delegateStakeToSP / totalActiveFunds) * totalRewards)\n', '            uint256 rewardsPriorToSPCut = (\n', '              delegateStakeToSP.mul(_totalRewards)\n', '            ).div(_totalActiveFunds);\n', '\n', '            // Multiply by deployer cut fraction to calculate reward for SP\n', '            // Operation constructed to perform all multiplication prior to division\n', '            // uint256 spDeployerCut = (rewardsPriorToSPCut * deployerCut ) / (deployerCutBase);\n', '            //                    = ((delegateStakeToSP * totalRewards) / totalActiveFunds) * deployerCut ) / (deployerCutBase);\n', '            //                    = ((delegateStakeToSP * totalRewards * deployerCut) / totalActiveFunds ) / (deployerCutBase);\n', '            //                    = (delegateStakeToSP * totalRewards * deployerCut) / (deployerCutBase * totalActiveFunds);\n', '            uint256 spDeployerCut = (\n', '                (delegateStakeToSP.mul(_totalRewards)).mul(_deployerCut)\n', '            ).div(\n', '                _totalActiveFunds.mul(_deployerCutBase)\n', '            );\n', '            // Increase total delegate reward in DelegateManager\n', '            // Subtract SP reward from rewards to calculate delegate reward\n', '            // delegateReward = rewardsPriorToSPCut - spDeployerCut;\n', '            delegateInfo[delegator][_sp] = (\n', '                delegateInfo[delegator][_sp].add(rewardsPriorToSPCut.sub(spDeployerCut))\n', '            );\n', '\n', '            // Update total for this delegator\n', '            _updateDelegatorTotalStake(\n', '                delegator,\n', '                delegatorTotalStake[delegator].add(rewardsPriorToSPCut.sub(spDeployerCut))\n', '            );\n', '\n', '            totalDelegatedStakeIncrease = (\n', '                totalDelegatedStakeIncrease.add(rewardsPriorToSPCut.sub(spDeployerCut))\n', '            );\n', '        }\n', '\n', '        return (totalDelegatedStakeIncrease);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) internal {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "DelegateManager: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the remove delegator lockup duration after validating against governance\n', '     * @param _duration - Incoming remove delegator duration value\n', '     */\n', '    function _updateRemoveDelegatorLockupDuration(uint256 _duration) internal {\n', '        Governance governance = Governance(governanceAddress);\n', '        require(\n', '            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\n', '            "DelegateManager: removeDelegatorLockupDuration duration must be greater than governance votingPeriod + executionDelay"\n', '        );\n', '        removeDelegatorLockupDuration = _duration;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the undelegate lockup duration after validating against governance\n', '     * @param _duration - Incoming undelegate lockup duration value\n', '     */\n', '    function _updateUndelegateLockupDuration(uint256 _duration) internal {\n', '        Governance governance = Governance(governanceAddress);\n', '        require(\n', '            _duration > governance.getVotingPeriod() + governance.getExecutionDelay(),\n', '            "DelegateManager: undelegateLockupDuration duration must be greater than governance votingPeriod + executionDelay"\n', '        );\n', '        undelegateLockupDuration = _duration;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns if delegator has delegated to a service provider\n', '     * @param _delegator - address of delegator\n', '     * @param _serviceProvider - address of service provider\n', '     * @return boolean indicating whether delegator exists for service provider\n', '     */\n', '    function _delegatorExistsForSP(\n', '        address _delegator,\n', '        address _serviceProvider\n', '    ) internal view returns (bool)\n', '    {\n', '        for (uint256 i = 0; i < spDelegateInfo[_serviceProvider].delegators.length; i++) {\n', '            if (spDelegateInfo[_serviceProvider].delegators[i] == _delegator) {\n', '                return true;\n', '            }\n', '        }\n', '        // Not found\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Determine if a claim is pending for this service provider\n', '     * @param _sp - address of service provider\n', '     * @return boolean indicating whether a claim is pending\n', '     */\n', '    function _claimPending(address _sp) internal view returns (bool) {\n', '        ClaimsManager claimsManager = ClaimsManager(claimsManagerAddress);\n', '        return claimsManager.claimPending(_sp);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine if a decrease request has been initiated\n', '     * @param _delegator - address of delegator\n', '     * @return boolean indicating whether a decrease request is pending\n', '     */\n', '    function _undelegateRequestIsPending(address _delegator) internal view returns (bool)\n', '    {\n', '        return (\n', '            (undelegateRequests[_delegator].lockupExpiryBlock != 0) &&\n', '            (undelegateRequests[_delegator].amount != 0) &&\n', '            (undelegateRequests[_delegator].serviceProvider != address(0))\n', '        );\n', '    }\n', '\n', '    // ========================================= Private Functions =========================================\n', '\n', '    function _requireStakingAddressIsSet() private view {\n', '        require(\n', '            stakingAddress != address(0x00),\n', '            "DelegateManager: stakingAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireServiceProviderFactoryAddressIsSet() private view {\n', '        require(\n', '            serviceProviderFactoryAddress != address(0x00),\n', '            "DelegateManager: serviceProviderFactoryAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireClaimsManagerAddressIsSet() private view {\n', '        require(\n', '            claimsManagerAddress != address(0x00),\n', '            "DelegateManager: claimsManagerAddress is not set"\n', '        );\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Initializable, Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function initialize(address sender) public initializer {\n', '        _owner = sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/registry/Registry.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title Central hub for Audius protocol. It stores all contract addresses to facilitate\n', '*   external access and enable version management.\n', '*/\n', 'contract Registry is InitializableV2, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @dev addressStorage mapping allows efficient lookup of current contract version\n', '     *      addressStorageHistory maintains record of all contract versions\n', '     */\n', '    mapping(bytes32 => address) private addressStorage;\n', '    mapping(bytes32 => address[]) private addressStorageHistory;\n', '\n', '    event ContractAdded(\n', '        bytes32 indexed _name,\n', '        address indexed _address\n', '    );\n', '\n', '    event ContractRemoved(\n', '        bytes32 indexed _name,\n', '        address indexed _address\n', '    );\n', '\n', '    event ContractUpgraded(\n', '        bytes32 indexed _name,\n', '        address indexed _oldAddress,\n', '        address indexed _newAddress\n', '    );\n', '\n', '    function initialize() public initializer {\n', '        /// @notice Ownable.initialize(address _sender) sets contract owner to _sender.\n', '        Ownable.initialize(msg.sender);\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    // ========================================= Setters =========================================\n', '\n', '    /**\n', '     * @notice addContract registers contract name to address mapping under given registry key\n', '     * @param _name - registry key that will be used for lookups\n', '     * @param _address - address of contract\n', '     */\n', '    function addContract(bytes32 _name, address _address) external onlyOwner {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            addressStorage[_name] == address(0x00),\n', '            "Registry: Contract already registered with given name."\n', '        );\n', '        require(\n', '            _address != address(0x00),\n', '            "Registry: Cannot register zero address."\n', '        );\n', '\n', '        setAddress(_name, _address);\n', '\n', '        emit ContractAdded(_name, _address);\n', '    }\n', '\n', '    /**\n', '     * @notice removes contract address registered under given registry key\n', '     * @param _name - registry key for lookup\n', '     */\n', '    function removeContract(bytes32 _name) external onlyOwner {\n', '        _requireIsInitialized();\n', '\n', '        address contractAddress = addressStorage[_name];\n', '        require(\n', '            contractAddress != address(0x00),\n', '            "Registry: Cannot remove - no contract registered with given _name."\n', '        );\n', '\n', '        setAddress(_name, address(0x00));\n', '\n', '        emit ContractRemoved(_name, contractAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice replaces contract address registered under given key with provided address\n', '     * @param _name - registry key for lookup\n', '     * @param _newAddress - new contract address to register under given key\n', '     */\n', '    function upgradeContract(bytes32 _name, address _newAddress) external onlyOwner {\n', '        _requireIsInitialized();\n', '\n', '        address oldAddress = addressStorage[_name];\n', '        require(\n', '            oldAddress != address(0x00),\n', '            "Registry: Cannot upgrade - no contract registered with given _name."\n', '        );\n', '        require(\n', '            _newAddress != address(0x00),\n', '            "Registry: Cannot upgrade - cannot register zero address."\n', '        );\n', '\n', '        setAddress(_name, _newAddress);\n', '\n', '        emit ContractUpgraded(_name, oldAddress, _newAddress);\n', '    }\n', '\n', '    // ========================================= Getters =========================================\n', '\n', '    /**\n', '     * @notice returns contract address registered under given registry key\n', '     * @param _name - registry key for lookup\n', '     * @return contractAddr - address of contract registered under given registry key\n', '     */\n', '    function getContract(bytes32 _name) external view returns (address contractAddr) {\n', '        _requireIsInitialized();\n', '\n', '        return addressStorage[_name];\n', '    }\n', '\n', '    /// @notice overloaded getContract to return explicit version of contract\n', '    function getContract(bytes32 _name, uint256 _version) external view\n', '    returns (address contractAddr)\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        // array length for key implies version number\n', '        require(\n', '            _version <= addressStorageHistory[_name].length,\n', '            "Registry: Index out of range _version."\n', '        );\n', '        return addressStorageHistory[_name][_version.sub(1)];\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the number of versions for a contract key\n', '     * @param _name - registry key for lookup\n', '     * @return number of contract versions\n', '     */\n', '    function getContractVersionCount(bytes32 _name) external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return addressStorageHistory[_name].length;\n', '    }\n', '\n', '    // ========================================= Private functions =========================================\n', '\n', '    /**\n', '     * @param _key the key for the contract address\n', '     * @param _value the contract address\n', '     */\n', '    function setAddress(bytes32 _key, address _value) private {\n', '        // main map for cheap lookup\n', '        addressStorage[_key] = _value;\n', '        // keep track of contract address history\n', '        addressStorageHistory[_key].push(_value);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Governance.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Governance is InitializableV2 {\n', '    using SafeMath for uint256;\n', '\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "Governance: Only callable by self"\n', '    );\n', '    string private constant ERROR_INVALID_VOTING_PERIOD = (\n', '        "Governance: Requires non-zero _votingPeriod"\n', '    );\n', '    string private constant ERROR_INVALID_REGISTRY = (\n', '        "Governance: Requires non-zero _registryAddress"\n', '    );\n', '    string private constant ERROR_INVALID_VOTING_QUORUM = (\n', '        "Governance: Requires _votingQuorumPercent between 1 & 100"\n', '    );\n', '\n', '    /**\n', '     * @notice Address and contract instance of Audius Registry. Used to ensure this contract\n', '     *      can only govern contracts that are registered in the Audius Registry.\n', '     */\n', '    Registry private registry;\n', '\n', '    /// @notice Address of Audius staking contract, used to permission Governance method calls\n', '    address private stakingAddress;\n', '\n', '    /// @notice Address of Audius ServiceProvider contract, used to permission Governance method calls\n', '    address private serviceProviderFactoryAddress;\n', '\n', '    /// @notice Address of Audius DelegateManager contract, used to permission Governance method calls\n', '    address private delegateManagerAddress;\n', '\n', '    /// @notice Period in blocks for which a governance proposal is open for voting\n', '    uint256 private votingPeriod;\n', '\n', '    /// @notice Number of blocks that must pass after votingPeriod has expired before proposal can be evaluated/executed\n', '    uint256 private executionDelay;\n', '\n', '    /// @notice Required minimum percentage of total stake to have voted to consider a proposal valid\n', '    ///         Percentaged stored as a uint256 between 0 & 100\n', '    ///         Calculated as: 100 * sum of voter stakes / total staked in Staking (at proposal submission block)\n', '    uint256 private votingQuorumPercent;\n', '\n', '    /// @notice Max number of InProgress proposals possible at once\n', '    /// @dev uint16 gives max possible value of 65,535\n', '    uint16 private maxInProgressProposals;\n', '\n', '    /**\n', '     * @notice Address of account that has special Governance permissions. Can veto proposals\n', '     *      and execute transactions directly on contracts.\n', '     */\n', '    address private guardianAddress;\n', '\n', '    /***** Enums *****/\n', '\n', '    /**\n', '     * @notice All Proposal Outcome states.\n', '     *      InProgress - Proposal is active and can be voted on.\n', '     *      Rejected - Proposal votingPeriod has closed and vote failed to pass. Proposal will not be executed.\n', '     *      ApprovedExecuted - Proposal votingPeriod has closed and vote passed. Proposal was successfully executed.\n', '     *      QuorumNotMet - Proposal votingPeriod has closed and votingQuorumPercent was not met. Proposal will not be executed.\n', '     *      ApprovedExecutionFailed - Proposal vote passed, but transaction execution failed.\n', '     *      Evaluating - Proposal vote passed, and evaluateProposalOutcome function is currently running.\n', '     *          This status is transiently used inside that function to prevent re-entrancy.\n', '     *      Vetoed - Proposal was vetoed by Guardian.\n', '     *      TargetContractAddressChanged - Proposal considered invalid since target contract address changed\n', '     *      TargetContractCodeHashChanged - Proposal considered invalid since code has at target contract address has changed\n', '     */\n', '    enum Outcome {\n', '        InProgress,\n', '        Rejected,\n', '        ApprovedExecuted,\n', '        QuorumNotMet,\n', '        ApprovedExecutionFailed,\n', '        Evaluating,\n', '        Vetoed,\n', '        TargetContractAddressChanged,\n', '        TargetContractCodeHashChanged\n', '    }\n', '\n', '    /**\n', '     * @notice All Proposal Vote states for a voter.\n', '     *      None - The default state, for any account that has not previously voted on this Proposal.\n', '     *      No - The account voted No on this Proposal.\n', '     *      Yes - The account voted Yes on this Proposal.\n', '     * @dev Enum values map to uints, so first value in Enum always is 0.\n', '     */\n', '    enum Vote {None, No, Yes}\n', '\n', '    struct Proposal {\n', '        uint256 proposalId;\n', '        address proposer;\n', '        uint256 submissionBlockNumber;\n', '        bytes32 targetContractRegistryKey;\n', '        address targetContractAddress;\n', '        uint256 callValue;\n', '        string functionSignature;\n', '        bytes callData;\n', '        Outcome outcome;\n', '        uint256 voteMagnitudeYes;\n', '        uint256 voteMagnitudeNo;\n', '        uint256 numVotes;\n', '        mapping(address => Vote) votes;\n', '        mapping(address => uint256) voteMagnitudes;\n', '        bytes32 contractHash;\n', '    }\n', '\n', '    /***** Proposal storage *****/\n', '\n', '    /// @notice ID of most recently created proposal. Ids are monotonically increasing and 1-indexed.\n', '    uint256 lastProposalId = 0;\n', '\n', '    /// @notice mapping of proposalId to Proposal struct with all proposal state\n', '    mapping(uint256 => Proposal) proposals;\n', '\n', '    /// @notice array of proposals with InProgress state\n', '    uint256[] inProgressProposals;\n', '\n', '\n', '    /***** Events *****/\n', '    event ProposalSubmitted(\n', '        uint256 indexed _proposalId,\n', '        address indexed _proposer,\n', '        string _name,\n', '        string _description\n', '    );\n', '    event ProposalVoteSubmitted(\n', '        uint256 indexed _proposalId,\n', '        address indexed _voter,\n', '        Vote indexed _vote,\n', '        uint256 _voterStake\n', '    );\n', '    event ProposalVoteUpdated(\n', '        uint256 indexed _proposalId,\n', '        address indexed _voter,\n', '        Vote indexed _vote,\n', '        uint256 _voterStake,\n', '        Vote _previousVote\n', '    );\n', '    event ProposalOutcomeEvaluated(\n', '        uint256 indexed _proposalId,\n', '        Outcome indexed _outcome,\n', '        uint256 _voteMagnitudeYes,\n', '        uint256 _voteMagnitudeNo,\n', '        uint256 _numVotes\n', '    );\n', '    event ProposalTransactionExecuted(\n', '        uint256 indexed _proposalId,\n', '        bool indexed _success,\n', '        bytes _returnData\n', '    );\n', '    event GuardianTransactionExecuted(\n', '        address indexed _targetContractAddress,\n', '        uint256 _callValue,\n', '        string indexed _functionSignature,\n', '        bytes indexed _callData,\n', '        bytes _returnData\n', '    );\n', '    event ProposalVetoed(uint256 indexed _proposalId);\n', '    event RegistryAddressUpdated(address indexed _newRegistryAddress);\n', '    event GuardianshipTransferred(address indexed _newGuardianAddress);\n', '    event VotingPeriodUpdated(uint256 indexed _newVotingPeriod);\n', '    event ExecutionDelayUpdated(uint256 indexed _newExecutionDelay);\n', '    event VotingQuorumPercentUpdated(uint256 indexed _newVotingQuorumPercent);\n', '    event MaxInProgressProposalsUpdated(uint256 indexed _newMaxInProgressProposals);\n', '\n', '    /**\n', '     * @notice Initialize the Governance contract\n', '     * @dev _votingPeriod <= DelegateManager.undelegateLockupDuration\n', '     * @dev stakingAddress must be initialized separately after Staking contract is deployed\n', '     * @param _registryAddress - address of the registry proxy contract\n', '     * @param _votingPeriod - period in blocks for which a governance proposal is open for voting\n', '     * @param _executionDelay - number of blocks that must pass after votingPeriod has expired before proposal can be evaluated/executed\n', '     * @param _votingQuorumPercent - required minimum percentage of total stake to have voted to consider a proposal valid\n', '     * @param _maxInProgressProposals - max number of InProgress proposals possible at once\n', '     * @param _guardianAddress - address of account that has special Governance permissions\n', '     */\n', '    function initialize(\n', '        address _registryAddress,\n', '        uint256 _votingPeriod,\n', '        uint256 _executionDelay,\n', '        uint256 _votingQuorumPercent,\n', '        uint16 _maxInProgressProposals,\n', '        address _guardianAddress\n', '    ) public initializer {\n', '        require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);\n', '        registry = Registry(_registryAddress);\n', '\n', '        require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);\n', '        votingPeriod = _votingPeriod;\n', '\n', '        // executionDelay does not have to be non-zero\n', '        executionDelay = _executionDelay;\n', '\n', '        require(\n', '            _maxInProgressProposals > 0,\n', '            "Governance: Requires non-zero _maxInProgressProposals"\n', '        );\n', '        maxInProgressProposals = _maxInProgressProposals;\n', '\n', '        require(\n', '            _votingQuorumPercent > 0 && _votingQuorumPercent <= 100,\n', '            ERROR_INVALID_VOTING_QUORUM\n', '        );\n', '        votingQuorumPercent = _votingQuorumPercent;\n', '\n', '        require(\n', '            _guardianAddress != address(0x00),\n', '            "Governance: Requires non-zero _guardianAddress"\n', '        );\n', '        guardianAddress = _guardianAddress;  //Guardian address becomes the only party\n', '\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    // ========================================= Governance Actions =========================================\n', '\n', '    /**\n', '     * @notice Submit a proposal for vote. Only callable by addresses with non-zero total active stake.\n', '     *      total active stake = total active deployer stake + total active delegator stake\n', '     *\n', "     * @dev _name and _description length is not enforced since they aren't stored on-chain and only event emitted\n", '     *\n', '     * @param _targetContractRegistryKey - Registry key for the contract concerning this proposal\n', '     * @param _callValue - amount of wei to pass with function call if a token transfer is involved\n', '     * @param _functionSignature - function signature of the function to be executed if proposal is successful\n', '     * @param _callData - encoded value(s) to call function with if proposal is successful\n', '     * @param _name - Text name of proposal to be emitted in event\n', '     * @param _description - Text description of proposal to be emitted in event\n', '     *\n', '     * @return - ID of new proposal\n', '     */\n', '    function submitProposal(\n', '        bytes32 _targetContractRegistryKey,\n', '        uint256 _callValue,\n', '        string calldata _functionSignature,\n', '        bytes calldata _callData,\n', '        string calldata _name,\n', '        string calldata _description\n', '    ) external returns (uint256)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '\n', '        address proposer = msg.sender;\n', '\n', '        // Require all InProgress proposals that can be evaluated have been evaluated before new proposal submission\n', '        require(\n', '            this.inProgressProposalsAreUpToDate(),\n', '            "Governance: Cannot submit new proposal until all evaluatable InProgress proposals are evaluated."\n', '        );\n', '\n', '        // Require new proposal submission would not push number of InProgress proposals over max number\n', '        require(\n', '            inProgressProposals.length < maxInProgressProposals,\n', '            "Governance: Number of InProgress proposals already at max. Please evaluate if possible, or wait for current proposals\' votingPeriods to expire."\n', '        );\n', '\n', '        // Require proposer has non-zero total active stake or is guardian address\n', '        require(\n', '            _calculateAddressActiveStake(proposer) > 0 || proposer == guardianAddress,\n', '            "Governance: Proposer must be address with non-zero total active stake or be guardianAddress."\n', '        );\n', '\n', '        // Require _targetContractRegistryKey points to a valid registered contract\n', '        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n', '        require(\n', '            targetContractAddress != address(0x00),\n', '            "Governance: _targetContractRegistryKey must point to valid registered contract"\n', '        );\n', '\n', '        // Signature cannot be empty\n', '        require(\n', '            bytes(_functionSignature).length != 0,\n', '            "Governance: _functionSignature cannot be empty."\n', '        );\n', '\n', '        // Require non-zero description length\n', '        require(bytes(_description).length > 0, "Governance: _description length must be > 0");\n', '\n', '        // Require non-zero name length\n', '        require(bytes(_name).length > 0, "Governance: _name length must be > 0");\n', '\n', '        // set proposalId\n', '        uint256 newProposalId = lastProposalId.add(1);\n', '\n', '        // Store new Proposal obj in proposals mapping\n', '        proposals[newProposalId] = Proposal({\n', '            proposalId: newProposalId,\n', '            proposer: proposer,\n', '            submissionBlockNumber: block.number,\n', '            targetContractRegistryKey: _targetContractRegistryKey,\n', '            targetContractAddress: targetContractAddress,\n', '            callValue: _callValue,\n', '            functionSignature: _functionSignature,\n', '            callData: _callData,\n', '            outcome: Outcome.InProgress,\n', '            voteMagnitudeYes: 0,\n', '            voteMagnitudeNo: 0,\n', '            numVotes: 0,\n', '            contractHash: _getCodeHash(targetContractAddress)\n', '            /* votes: mappings are auto-initialized to default state */\n', '            /* voteMagnitudes: mappings are auto-initialized to default state */\n', '        });\n', '\n', '        // Append new proposalId to inProgressProposals array\n', '        inProgressProposals.push(newProposalId);\n', '\n', '        emit ProposalSubmitted(\n', '            newProposalId,\n', '            proposer,\n', '            _name,\n', '            _description\n', '        );\n', '\n', '        lastProposalId = newProposalId;\n', '\n', '        return newProposalId;\n', '    }\n', '\n', '    /**\n', '     * @notice Vote on an active Proposal. Only callable by addresses with non-zero active stake.\n', '     * @param _proposalId - id of the proposal this vote is for\n', '     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\n', '     */\n', '    function submitVote(uint256 _proposalId, Vote _vote) external {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        address voter = msg.sender;\n', '\n', '        // Require proposal votingPeriod is still active\n', '        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\n', '        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);\n', '        require(\n', '            block.number > submissionBlockNumber && block.number <= endBlockNumber,\n', '            "Governance: Proposal votingPeriod has ended"\n', '        );\n', '\n', '        // Require voter has non-zero total active stake\n', '        uint256 voterActiveStake = _calculateAddressActiveStake(voter);\n', '        require(\n', '            voterActiveStake > 0,\n', '            "Governance: Voter must be address with non-zero total active stake."\n', '        );\n', '\n', '        // Require previous vote is None\n', '        require(\n', '            proposals[_proposalId].votes[voter] == Vote.None,\n', '            "Governance: To update previous vote, call updateVote()"\n', '        );\n', '\n', '        // Require vote is either Yes or No\n', '        require(\n', '            _vote == Vote.Yes || _vote == Vote.No,\n', '            "Governance: Can only submit a Yes or No vote"\n', '        );\n', '\n', '        // Record vote\n', '        proposals[_proposalId].votes[voter] = _vote;\n', '\n', '        // Record voteMagnitude for voter\n', '        proposals[_proposalId].voteMagnitudes[voter] = voterActiveStake;\n', '\n', '        // Update proposal cumulative vote magnitudes\n', '        if (_vote == Vote.Yes) {\n', '            _increaseVoteMagnitudeYes(_proposalId, voterActiveStake);\n', '        } else {\n', '            _increaseVoteMagnitudeNo(_proposalId, voterActiveStake);\n', '        }\n', '\n', '        // Increment proposal numVotes\n', '        proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);\n', '\n', '        emit ProposalVoteSubmitted(\n', '            _proposalId,\n', '            voter,\n', '            _vote,\n', '            voterActiveStake\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Update previous vote on an active Proposal. Only callable by addresses with non-zero active stake.\n', '     * @param _proposalId - id of the proposal this vote is for\n', '     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\n', '     */\n', '    function updateVote(uint256 _proposalId, Vote _vote) external {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        address voter = msg.sender;\n', '\n', '        // Require proposal votingPeriod is still active\n', '        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\n', '        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod);\n', '        require(\n', '            block.number > submissionBlockNumber && block.number <= endBlockNumber,\n', '            "Governance: Proposal votingPeriod has ended"\n', '        );\n', '\n', '        // Retrieve previous vote\n', '        Vote previousVote = proposals[_proposalId].votes[voter];\n', '\n', '        // Require previous vote is not None\n', '        require(\n', '            previousVote != Vote.None,\n', '            "Governance: To submit new vote, call submitVote()"\n', '        );\n', '\n', '        // Require vote is either Yes or No\n', '        require(\n', '            _vote == Vote.Yes || _vote == Vote.No,\n', '            "Governance: Can only submit a Yes or No vote"\n', '        );\n', '\n', '        // Record updated vote\n', '        proposals[_proposalId].votes[voter] = _vote;\n', '\n', '        // Update vote magnitudes, using vote magnitude from when previous vote was submitted\n', '        uint256 voteMagnitude = proposals[_proposalId].voteMagnitudes[voter];\n', '        if (previousVote == Vote.Yes && _vote == Vote.No) {\n', '            _decreaseVoteMagnitudeYes(_proposalId, voteMagnitude);\n', '            _increaseVoteMagnitudeNo(_proposalId, voteMagnitude);\n', '        } else if (previousVote == Vote.No && _vote == Vote.Yes) {\n', '            _decreaseVoteMagnitudeNo(_proposalId, voteMagnitude);\n', '            _increaseVoteMagnitudeYes(_proposalId, voteMagnitude);\n', '        }\n', '        // If _vote == previousVote, no changes needed to vote magnitudes.\n', '\n', '        // Do not update numVotes\n', '\n', '        emit ProposalVoteUpdated(\n', '            _proposalId,\n', '            voter,\n', '            _vote,\n', '            voteMagnitude,\n', '            previousVote\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Once the voting period + executionDelay for a proposal has ended, evaluate the outcome and\n', '     *      execute the proposal if voting quorum met & vote passes.\n', '     *      To pass, stake-weighted vote must be > 50% Yes.\n', '     * @dev Requires that caller is an active staker at the time the proposal is created\n', '     * @param _proposalId - id of the proposal\n', '     * @return Outcome of proposal evaluation\n', '     */\n', '    function evaluateProposalOutcome(uint256 _proposalId)\n', '    external returns (Outcome)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireStakingAddressIsSet();\n', '        _requireServiceProviderFactoryAddressIsSet();\n', '        _requireDelegateManagerAddressIsSet();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        // Require proposal has not already been evaluated.\n', '        require(\n', '            proposals[_proposalId].outcome == Outcome.InProgress,\n', '            "Governance: Can only evaluate InProgress proposal."\n', '        );\n', '\n', '        // Re-entrancy should not be possible here since this switches the status of the\n', "        // proposal to 'Evaluating' so it should fail the status is 'InProgress' check\n", '        proposals[_proposalId].outcome = Outcome.Evaluating;\n', '\n', '        // Require proposal votingPeriod + executionDelay have ended.\n', '        uint256 submissionBlockNumber = proposals[_proposalId].submissionBlockNumber;\n', '        uint256 endBlockNumber = submissionBlockNumber.add(votingPeriod).add(executionDelay);\n', '        require(\n', '            block.number > endBlockNumber,\n', '            "Governance: Proposal votingPeriod & executionDelay must end before evaluation."\n', '        );\n', '\n', '        address targetContractAddress = registry.getContract(\n', '            proposals[_proposalId].targetContractRegistryKey\n', '        );\n', '\n', '        Outcome outcome;\n', '\n', '        // target contract address changed -> close proposal without execution.\n', '        if (targetContractAddress != proposals[_proposalId].targetContractAddress) {\n', '            outcome = Outcome.TargetContractAddressChanged;\n', '        }\n', '        // target contract code hash changed -> close proposal without execution.\n', '        else if (_getCodeHash(targetContractAddress) != proposals[_proposalId].contractHash) {\n', '            outcome = Outcome.TargetContractCodeHashChanged;\n', '        }\n', '        // voting quorum not met -> close proposal without execution.\n', '        else if (_quorumMet(proposals[_proposalId], Staking(stakingAddress)) == false) {\n', '            outcome = Outcome.QuorumNotMet;\n', '        }\n', '        // votingQuorumPercent met & vote passed -> execute proposed transaction & close proposal.\n', '        else if (\n', '            proposals[_proposalId].voteMagnitudeYes > proposals[_proposalId].voteMagnitudeNo\n', '        ) {\n', '            (bool success, bytes memory returnData) = _executeTransaction(\n', '                targetContractAddress,\n', '                proposals[_proposalId].callValue,\n', '                proposals[_proposalId].functionSignature,\n', '                proposals[_proposalId].callData\n', '            );\n', '\n', '            emit ProposalTransactionExecuted(\n', '                _proposalId,\n', '                success,\n', '                returnData\n', '            );\n', '\n', '            // Proposal outcome depends on success of transaction execution.\n', '            if (success) {\n', '                outcome = Outcome.ApprovedExecuted;\n', '            } else {\n', '                outcome = Outcome.ApprovedExecutionFailed;\n', '            }\n', '        }\n', '        // votingQuorumPercent met & vote did not pass -> close proposal without transaction execution.\n', '        else {\n', '            outcome = Outcome.Rejected;\n', '        }\n', '\n', '        // This records the final outcome in the proposals mapping\n', '        proposals[_proposalId].outcome = outcome;\n', '\n', '        // Remove from inProgressProposals array\n', '        _removeFromInProgressProposals(_proposalId);\n', '\n', '        emit ProposalOutcomeEvaluated(\n', '            _proposalId,\n', '            outcome,\n', '            proposals[_proposalId].voteMagnitudeYes,\n', '            proposals[_proposalId].voteMagnitudeNo,\n', '            proposals[_proposalId].numVotes\n', '        );\n', '\n', '        return outcome;\n', '    }\n', '\n', '    /**\n', '     * @notice Action limited to the guardian address that can veto a proposal\n', '     * @param _proposalId - id of the proposal\n', '     */\n', '    function vetoProposal(uint256 _proposalId) external {\n', '        _requireIsInitialized();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        require(\n', '            msg.sender == guardianAddress,\n', '            "Governance: Only guardian can veto proposals."\n', '        );\n', '\n', '        require(\n', '            proposals[_proposalId].outcome == Outcome.InProgress,\n', '            "Governance: Cannot veto inactive proposal."\n', '        );\n', '\n', '        proposals[_proposalId].outcome = Outcome.Vetoed;\n', '\n', '        // Remove from inProgressProposals array\n', '        _removeFromInProgressProposals(_proposalId);\n', '\n', '        emit ProposalVetoed(_proposalId);\n', '    }\n', '\n', '    // ========================================= Config Setters =========================================\n', '\n', '    /**\n', '     * @notice Set the Staking address\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _stakingAddress - address for new Staking contract\n', '     */\n', '    function setStakingAddress(address _stakingAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(_stakingAddress != address(0x00), "Governance: Requires non-zero _stakingAddress");\n', '        stakingAddress = _stakingAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the ServiceProviderFactory address\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _serviceProviderFactoryAddress - address for new ServiceProviderFactory contract\n', '     */\n', '    function setServiceProviderFactoryAddress(address _serviceProviderFactoryAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(\n', '            _serviceProviderFactoryAddress != address(0x00),\n', '            "Governance: Requires non-zero _serviceProviderFactoryAddress"\n', '        );\n', '        serviceProviderFactoryAddress = _serviceProviderFactoryAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the DelegateManager address\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _delegateManagerAddress - address for new DelegateManager contract\n', '     */\n', '    function setDelegateManagerAddress(address _delegateManagerAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(\n', '            _delegateManagerAddress != address(0x00),\n', '            "Governance: Requires non-zero _delegateManagerAddress"\n', '        );\n', '        delegateManagerAddress = _delegateManagerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Set the voting period for a Governance proposal\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _votingPeriod - new voting period\n', '     */\n', '    function setVotingPeriod(uint256 _votingPeriod) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(_votingPeriod > 0, ERROR_INVALID_VOTING_PERIOD);\n', '        votingPeriod = _votingPeriod;\n', '        emit VotingPeriodUpdated(_votingPeriod);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the voting quorum percentage for a Governance proposal\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _votingQuorumPercent - new voting period\n', '     */\n', '    function setVotingQuorumPercent(uint256 _votingQuorumPercent) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(\n', '            _votingQuorumPercent > 0 && _votingQuorumPercent <= 100,\n', '            ERROR_INVALID_VOTING_QUORUM\n', '        );\n', '        votingQuorumPercent = _votingQuorumPercent;\n', '        emit VotingQuorumPercentUpdated(_votingQuorumPercent);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Registry address\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _registryAddress - address for new Registry contract\n', '     */\n', '    function setRegistryAddress(address _registryAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(_registryAddress != address(0x00), ERROR_INVALID_REGISTRY);\n', '\n', '        registry = Registry(_registryAddress);\n', '\n', '        emit RegistryAddressUpdated(_registryAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the max number of concurrent InProgress proposals\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _newMaxInProgressProposals - new value for maxInProgressProposals\n', '     */\n', '    function setMaxInProgressProposals(uint16 _newMaxInProgressProposals) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        require(\n', '            _newMaxInProgressProposals > 0,\n', '            "Governance: Requires non-zero _newMaxInProgressProposals"\n', '        );\n', '        maxInProgressProposals = _newMaxInProgressProposals;\n', '        emit MaxInProgressProposalsUpdated(_newMaxInProgressProposals);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the execution delay for a proposal\n', '     * @dev Only callable by self via _executeTransaction\n', '     * @param _newExecutionDelay - new value for executionDelay\n', '     */\n', '    function setExecutionDelay(uint256 _newExecutionDelay) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == address(this), ERROR_ONLY_GOVERNANCE);\n', '        // executionDelay does not have to be non-zero\n', '        executionDelay = _newExecutionDelay;\n', '        emit ExecutionDelayUpdated(_newExecutionDelay);\n', '    }\n', '\n', '    // ========================================= Guardian Actions =========================================\n', '\n', '    /**\n', '     * @notice Allows the guardianAddress to execute protocol actions\n', '     * @param _targetContractRegistryKey - key in registry of target contract\n', '     * @param _callValue - amount of wei if a token transfer is involved\n', '     * @param _functionSignature - function signature of the function to be executed if proposal is successful\n', '     * @param _callData - encoded value(s) to call function with if proposal is successful\n', '     */\n', '    function guardianExecuteTransaction(\n', '        bytes32 _targetContractRegistryKey,\n', '        uint256 _callValue,\n', '        string calldata _functionSignature,\n', '        bytes calldata _callData\n', '    ) external\n', '    {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == guardianAddress,\n', '            "Governance: Only guardian."\n', '        );\n', '\n', '        // _targetContractRegistryKey must point to a valid registered contract\n', '        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n', '        require(\n', '            targetContractAddress != address(0x00),\n', '            "Governance: _targetContractRegistryKey must point to valid registered contract"\n', '        );\n', '\n', '        // Signature cannot be empty\n', '        require(\n', '            bytes(_functionSignature).length != 0,\n', '            "Governance: _functionSignature cannot be empty."\n', '        );\n', '\n', '        (bool success, bytes memory returnData) = _executeTransaction(\n', '            targetContractAddress,\n', '            _callValue,\n', '            _functionSignature,\n', '            _callData\n', '        );\n', '\n', '        require(success, "Governance: Transaction failed.");\n', '\n', '        emit GuardianTransactionExecuted(\n', '            targetContractAddress,\n', '            _callValue,\n', '            _functionSignature,\n', '            _callData,\n', '            returnData\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Change the guardian address\n', '     * @dev Only callable by current guardian\n', '     * @param _newGuardianAddress - new guardian address\n', '     */\n', '    function transferGuardianship(address _newGuardianAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(\n', '            msg.sender == guardianAddress,\n', '            "Governance: Only guardian."\n', '        );\n', '\n', '        guardianAddress = _newGuardianAddress;\n', '\n', '        emit GuardianshipTransferred(_newGuardianAddress);\n', '    }\n', '\n', '    // ========================================= Getter Functions =========================================\n', '\n', '    /**\n', '     * @notice Get proposal information by proposal Id\n', '     * @param _proposalId - id of proposal\n', '     */\n', '    function getProposalById(uint256 _proposalId)\n', '    external view returns (\n', '        uint256 proposalId,\n', '        address proposer,\n', '        uint256 submissionBlockNumber,\n', '        bytes32 targetContractRegistryKey,\n', '        address targetContractAddress,\n', '        uint256 callValue,\n', '        string memory functionSignature,\n', '        bytes memory callData,\n', '        Outcome outcome,\n', '        uint256 voteMagnitudeYes,\n', '        uint256 voteMagnitudeNo,\n', '        uint256 numVotes\n', '    )\n', '    {\n', '        _requireIsInitialized();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        Proposal memory proposal = proposals[_proposalId];\n', '        return (\n', '            proposal.proposalId,\n', '            proposal.proposer,\n', '            proposal.submissionBlockNumber,\n', '            proposal.targetContractRegistryKey,\n', '            proposal.targetContractAddress,\n', '            proposal.callValue,\n', '            proposal.functionSignature,\n', '            proposal.callData,\n', '            proposal.outcome,\n', '            proposal.voteMagnitudeYes,\n', '            proposal.voteMagnitudeNo,\n', '            proposal.numVotes\n', '            /** @notice - votes mapping cannot be returned by external function */\n', '            /** @notice - voteMagnitudes mapping cannot be returned by external function */\n', '            /** @notice - returning contractHash leads to stack too deep compiler error, see getProposalTargetContractHash() */\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get proposal target contract hash by proposalId\n', '     * @dev This is a separate function because the getProposalById returns too many\n', '            variables already and by adding more, you get the error\n', '            `InternalCompilerError: Stack too deep, try using fewer variables`\n', '     * @param _proposalId - id of proposal\n', '     */\n', '    function getProposalTargetContractHash(uint256 _proposalId)\n', '    external view returns (bytes32)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        return (proposals[_proposalId].contractHash);\n', '    }\n', '\n', '    /**\n', '     * @notice Get vote direction and vote magnitude for a given proposal and voter\n', '     * @param _proposalId - id of the proposal\n', '     * @param _voter - address of the voter we want to check\n', '     * @return returns vote direction and magnitude if valid vote, else default values\n', '     */\n', '    function getVoteInfoByProposalAndVoter(uint256 _proposalId, address _voter)\n', '    external view returns (Vote vote, uint256 voteMagnitude)\n', '    {\n', '        _requireIsInitialized();\n', '        _requireValidProposalId(_proposalId);\n', '\n', '        return (\n', '            proposals[_proposalId].votes[_voter],\n', '            proposals[_proposalId].voteMagnitudes[_voter]\n', '        );\n', '    }\n', '\n', '    /// @notice Get the contract Guardian address\n', '    function getGuardianAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return guardianAddress;\n', '    }\n', '\n', '    /// @notice Get the Staking address\n', '    function getStakingAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return stakingAddress;\n', '    }\n', '\n', '    /// @notice Get the ServiceProviderFactory address\n', '    function getServiceProviderFactoryAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return serviceProviderFactoryAddress;\n', '    }\n', '\n', '    /// @notice Get the DelegateManager address\n', '    function getDelegateManagerAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return delegateManagerAddress;\n', '    }\n', '\n', '    /// @notice Get the contract voting period\n', '    function getVotingPeriod() external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return votingPeriod;\n', '    }\n', '\n', '    /// @notice Get the contract voting quorum percent\n', '    function getVotingQuorumPercent() external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return votingQuorumPercent;\n', '    }\n', '\n', '    /// @notice Get the registry address\n', '    function getRegistryAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return address(registry);\n', '    }\n', '\n', '    /// @notice Used to check if is governance contract before setting governance address in other contracts\n', '    function isGovernanceAddress() external pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /// @notice Get the max number of concurrent InProgress proposals\n', '    function getMaxInProgressProposals() external view returns (uint16) {\n', '        _requireIsInitialized();\n', '\n', '        return maxInProgressProposals;\n', '    }\n', '\n', '    /// @notice Get the proposal execution delay\n', '    function getExecutionDelay() external view returns (uint256) {\n', '        _requireIsInitialized();\n', '\n', '        return executionDelay;\n', '    }\n', '\n', '    /// @notice Get the array of all InProgress proposal Ids\n', '    function getInProgressProposals() external view returns (uint256[] memory) {\n', '        _requireIsInitialized();\n', '\n', '        return inProgressProposals;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns false if any proposals in inProgressProposals array are evaluatable\n', '     *          Evaluatable = proposals with closed votingPeriod\n', '     * @dev Is public since its called internally in `submitProposal()` as well as externally in UI\n', '     */\n', '    function inProgressProposalsAreUpToDate() external view returns (bool) {\n', '        _requireIsInitialized();\n', '\n', '        // compare current block number against endBlockNumber of each proposal\n', '        for (uint256 i = 0; i < inProgressProposals.length; i++) {\n', '            if (\n', '                block.number >\n', '                (proposals[inProgressProposals[i]].submissionBlockNumber).add(votingPeriod).add(executionDelay)\n', '            ) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // ========================================= Internal Functions =========================================\n', '\n', '    /**\n', '     * @notice Execute a transaction attached to a governance proposal\n', '     * @dev We are aware of both potential re-entrancy issues and the risks associated with low-level solidity\n', '     *      function calls here, but have chosen to keep this code with those issues in mind. All governance\n', '     *      proposals go through a voting process, and all will be reviewed carefully to ensure that they\n', '     *      adhere to the expected behaviors of this call - but adding restrictions here would limit the ability\n', '     *      of the governance system to do required work in a generic way.\n', '     * @param _targetContractAddress - address of registry proxy contract to execute transaction on\n', '     * @param _callValue - amount of wei if a token transfer is involved\n', '     * @param _functionSignature - function signature of the function to be executed if proposal is successful\n', '     * @param _callData - encoded value(s) to call function with if proposal is successful\n', '     */\n', '    function _executeTransaction(\n', '        address _targetContractAddress,\n', '        uint256 _callValue,\n', '        string memory _functionSignature,\n', '        bytes memory _callData\n', '    ) internal returns (bool success, bytes memory returnData)\n', '    {\n', '        bytes memory encodedCallData = abi.encodePacked(\n', '            bytes4(keccak256(bytes(_functionSignature))),\n', '            _callData\n', '        );\n', '        (success, returnData) = (\n', '            // solium-disable-next-line security/no-call-value\n', '            _targetContractAddress.call.value(_callValue)(encodedCallData)\n', '        );\n', '\n', '        return (success, returnData);\n', '    }\n', '\n', '    function _increaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {\n', '        proposals[_proposalId].voteMagnitudeYes = (\n', '            proposals[_proposalId].voteMagnitudeYes.add(_voterStake)\n', '        );\n', '    }\n', '\n', '    function _increaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {\n', '        proposals[_proposalId].voteMagnitudeNo = (\n', '            proposals[_proposalId].voteMagnitudeNo.add(_voterStake)\n', '        );\n', '    }\n', '\n', '    function _decreaseVoteMagnitudeYes(uint256 _proposalId, uint256 _voterStake) internal {\n', '        proposals[_proposalId].voteMagnitudeYes = (\n', '            proposals[_proposalId].voteMagnitudeYes.sub(_voterStake)\n', '        );\n', '    }\n', '\n', '    function _decreaseVoteMagnitudeNo(uint256 _proposalId, uint256 _voterStake) internal {\n', '        proposals[_proposalId].voteMagnitudeNo = (\n', '            proposals[_proposalId].voteMagnitudeNo.sub(_voterStake)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Can make O(1) by storing index pointer in proposals mapping.\n', '     *      Requires inProgressProposals to be 1-indexed, since all proposals that are not present\n', '     *          will have pointer set to 0.\n', '     */\n', '    function _removeFromInProgressProposals(uint256 _proposalId) internal {\n', '        uint256 index = 0;\n', '        for (uint256 i = 0; i < inProgressProposals.length; i++) {\n', '            if (inProgressProposals[i] == _proposalId) {\n', '                index = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Swap proposalId to end of array + pop (deletes last elem + decrements array length)\n', '        inProgressProposals[index] = inProgressProposals[inProgressProposals.length - 1];\n', '        inProgressProposals.pop();\n', '    }\n', '\n', '    /**\n', '     * @notice Returns true if voting quorum percentage met for proposal, else false.\n', '     * @dev Quorum is met if total voteMagnitude * 100 / total active stake in Staking\n', '     * @dev Eventual multiplication overflow:\n', '     *      (proposal.voteMagnitudeYes + proposal.voteMagnitudeNo), with 100% staking participation,\n', '     *          can sum to at most the entire token supply of 10^27\n', '     *      With 7% annual token supply inflation, multiplication can overflow ~1635 years at the earliest:\n', '     *      log(2^256/(10^27*100))/log(1.07) ~= 1635\n', '     *\n', '     * @dev Note that quorum is evaluated based on total staked at proposal submission\n', '     *      not total staked at proposal evaluation, this is expected behavior\n', '     */\n', '    function _quorumMet(Proposal memory proposal, Staking stakingContract)\n', '    internal view returns (bool)\n', '    {\n', '        uint256 participation = (\n', '            (proposal.voteMagnitudeYes + proposal.voteMagnitudeNo)\n', '            .mul(100)\n', '            .div(stakingContract.totalStakedAt(proposal.submissionBlockNumber))\n', '        );\n', '        return participation >= votingQuorumPercent;\n', '    }\n', '\n', '    // ========================================= Private Functions =========================================\n', '\n', '    function _requireStakingAddressIsSet() private view {\n', '        require(\n', '            stakingAddress != address(0x00),\n', '            "Governance: stakingAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireServiceProviderFactoryAddressIsSet() private view {\n', '        require(\n', '            serviceProviderFactoryAddress != address(0x00),\n', '            "Governance: serviceProviderFactoryAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireDelegateManagerAddressIsSet() private view {\n', '        require(\n', '            delegateManagerAddress != address(0x00),\n', '            "Governance: delegateManagerAddress is not set"\n', '        );\n', '    }\n', '\n', '    function _requireValidProposalId(uint256 _proposalId) private view {\n', '        require(\n', '            _proposalId <= lastProposalId && _proposalId > 0,\n', '            "Governance: Must provide valid non-zero _proposalId"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Calculates and returns active stake for address\n', '     *\n', '     * Active stake = (active deployer stake + active delegator stake)\n', '     *      active deployer stake = (direct deployer stake - locked deployer stake)\n', '     *          locked deployer stake = amount of pending decreaseStakeRequest for address\n', '     *      active delegator stake = (total delegator stake - locked delegator stake)\n', '     *          locked delegator stake = amount of pending undelegateRequest for address\n', '     */\n', '    function _calculateAddressActiveStake(address _address) private view returns (uint256) {\n', '        ServiceProviderFactory spFactory = ServiceProviderFactory(serviceProviderFactoryAddress);\n', '        DelegateManager delegateManager = DelegateManager(delegateManagerAddress);\n', '\n', '        // Amount directly staked by address, if any, in ServiceProviderFactory\n', '        (uint256 directDeployerStake,,,,,) = spFactory.getServiceProviderDetails(_address);\n', '        // Amount of pending decreasedStakeRequest for address, if any, in ServiceProviderFactory\n', '        (uint256 lockedDeployerStake,) = spFactory.getPendingDecreaseStakeRequest(_address);\n', '        // active deployer stake = (direct deployer stake - locked deployer stake)\n', '        uint256 activeDeployerStake = directDeployerStake.sub(lockedDeployerStake);\n', '\n', '        // Total amount delegated by address, if any, in DelegateManager\n', '        uint256 totalDelegatorStake = delegateManager.getTotalDelegatorStake(_address);\n', '        // Amount of pending undelegateRequest for address, if any, in DelegateManager\n', '        (,uint256 lockedDelegatorStake, ) = delegateManager.getPendingUndelegateRequest(_address);\n', '        // active delegator stake = (total delegator stake - locked delegator stake)\n', '        uint256 activeDelegatorStake = totalDelegatorStake.sub(lockedDelegatorStake);\n', '\n', '        // activeStake = (activeDeployerStake + activeDelegatorStake)\n', '        uint256 activeStake = activeDeployerStake.add(activeDelegatorStake);\n', '\n', '        return activeStake;\n', '    }\n', '\n', '    // solium-disable security/no-inline-assembly\n', '    /**\n', '     * @notice Helper function to generate the code hash for a contract address\n', '     * @return contract code hash\n', '     */\n', '    function _getCodeHash(address _contract) private view returns (bytes32) {\n', '        bytes32 contractHash;\n', '        assembly {\n', '          contractHash := extcodehash(_contract)\n', '        }\n', '        return contractHash;\n', '    }\n', '}\n', '\n', '// File: contracts/EthRewardsManager.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface Wormhole {\n', '    function lockAssets(\n', '        address asset,\n', '        uint256 amount,\n', '        bytes32 recipient,\n', '        uint8 target_chain,\n', '        uint32 nonce,\n', '        bool refund_dust\n', '    ) external;\n', '}\n', '\n', '\n', 'contract EthRewardsManager is InitializableV2 {\n', '    using SafeERC20 for ERC20;\n', '\n', '    string private constant ERROR_TOKEN_NOT_CONTRACT = (\n', '        "EthRewardsManager: token is not a contract"\n', '    );\n', '    string private constant ERROR_WORMHOLE_NOT_CONTRACT = (\n', '        "EthRewardsManager: wormhole is not a contract"\n', '    );\n', '    string private constant ERROR_ONLY_GOVERNANCE = (\n', '        "EthRewardsManager: Only governance"\n', '    );\n', '\n', '    address private governanceAddress;\n', '\n', '    /// @dev ERC-20 token that will be used to stake with\n', '    ERC20 internal audiusToken;\n', '    Wormhole internal wormhole;\n', '    bytes32 internal recipient;\n', '\n', '    address public antiAbuseOracleAddress;\n', '\n', '    /**\n', '     * @notice Function to initialize the contract\n', '     * @param _tokenAddress - address of ERC20 token\n', '     * @param _governanceAddress - address for Governance proxy contract\n', '     * @param _wormholeAddress - address for Wormhole contract\n', '     * @param _recipient - solana address of recipient\n', '     * @param _antiAbuseOracleAddress - address for antiAbuseOracleAddress\n', '     */\n', '    function initialize(\n', '        address _tokenAddress,\n', '        address _governanceAddress,\n', '        address _wormholeAddress,\n', '        bytes32 _recipient,\n', '        address _antiAbuseOracleAddress\n', '    ) public initializer {\n', '        require(Address.isContract(_tokenAddress), ERROR_TOKEN_NOT_CONTRACT);\n', '        require(\n', '            Address.isContract(_wormholeAddress),\n', '            ERROR_WORMHOLE_NOT_CONTRACT\n', '        );\n', '        audiusToken = ERC20(_tokenAddress);\n', '        wormhole = Wormhole(_wormholeAddress);\n', '        recipient = _recipient;\n', '        antiAbuseOracleAddress = _antiAbuseOracleAddress;\n', '        _updateGovernanceAddress(_governanceAddress);\n', '        InitializableV2.initialize();\n', '    }\n', '\n', '    /**\n', '     * @notice Set the Governance address\n', '     * @dev Only callable by Governance address\n', '     * @param _governanceAddress - address for new Governance contract\n', '     */\n', '    function setGovernanceAddress(address _governanceAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        _updateGovernanceAddress(_governanceAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Set the recipient address\n', '     * @dev Only callable by Governance address\n', '     * @param _recipient - address for new recipient\n', '     */\n', '    function setRecipientAddress(bytes32 _recipient) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        recipient = _recipient;\n', '    }\n', '\n', '    /**\n', '     * @notice Set antiAbuseOracleAddress\n', '     * @dev Only callable by Governance address\n', '     * @param _antiAbuseOracleAddress - value of new antiAbuseOracleAddress\n', '     */\n', '    function setAntiAbuseOracleAddress(address _antiAbuseOracleAddress) external {\n', '        _requireIsInitialized();\n', '\n', '        require(msg.sender == governanceAddress, ERROR_ONLY_GOVERNANCE);\n', '        antiAbuseOracleAddress = _antiAbuseOracleAddress;\n', '    }\n', '\n', '    /* External functions */\n', '\n', '    /**\n', '     * @notice Transfers to solana\n', '     * @param _nonce - nonce for wormhole\n', '     */\n', '    function transferToSolana(uint32 _nonce) external {\n', '        _requireIsInitialized();\n', '\n', '        uint256 balance = audiusToken.balanceOf(address(this));\n', '        audiusToken.approve(address(wormhole), balance);\n', '\n', '        wormhole.lockAssets(\n', '            address(audiusToken),\n', '            balance,\n', '            recipient,\n', '            1,\n', '            _nonce,\n', '            true\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token used by the contract\n', '     * @return The token used by the contract\n', '     */\n', '    function token() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return address(audiusToken);\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getGovernanceAddress() external view returns (address) {\n', '        _requireIsInitialized();\n', '\n', '        return governanceAddress;\n', '    }\n', '\n', '    /// @notice Get the Governance address\n', '    function getRecipientAddress() external view returns (bytes32) {\n', '        _requireIsInitialized();\n', '\n', '        return recipient;\n', '    }\n', '\n', '    // ========================================= Internal Functions =========================================\n', '\n', '    /**\n', '     * @notice Set the governance address after confirming contract identity\n', '     * @param _governanceAddress - Incoming governance address\n', '     */\n', '    function _updateGovernanceAddress(address _governanceAddress) internal {\n', '        require(\n', '            Governance(_governanceAddress).isGovernanceAddress() == true,\n', '            "EthRewardsManager: _governanceAddress is not a valid governance contract"\n', '        );\n', '        governanceAddress = _governanceAddress;\n', '    }\n', '}']