['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-13\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '       \n', '        uint256 size;\n', '       \n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '   \n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '       \n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '   \n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '  \n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '   \n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '   \n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '  \n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () {\n', '        address msgSender = msg.sender;\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(owner() == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'abstract contract ERC165 is IERC165 {\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', 'interface IERC1155 is IERC165 {\n', '  \n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', 'interface IERC1155MetadataURI is IERC1155 {\n', '    function uri() external view returns (string memory);\n', '}\n', '\n', '\n', 'library String {\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to a `string`.\n', '     * via OraclizeAPI - MIT licence\n', '     * https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '     */\n', '    function fromUint(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = byte(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    bytes constant alphabet = "0123456789abcdef";\n', '\n', '    function fromAddress(address _addr) internal pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n', '            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0F))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '}\n', '\n', 'contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, Ownable {\n', '    using Address for address;\n', '\n', '    // Mapping from token ID to account balances\n', '    mapping (uint256 => mapping(address => uint256)) private _balances;\n', '\n', '    // Mapping from account to operator approvals\n', '    mapping (address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n', '    string private _uri = "https://api.bundles.finance/api/token/";\n', '\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n', '        return interfaceId == type(IERC1155).interfaceId\n', '            || interfaceId == type(IERC1155MetadataURI).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    function uri() public view virtual override returns (string memory) {\n', '        return _uri;\n', '    }\n', '\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        return string(abi.encodePacked(\n', '            _uri,\n', '            String.fromAddress(address(this)),\n', '            "/",\n', '            String.fromUint(tokenId)\n', '        ));\n', '    }\n', '\n', '    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n', '        require(account != address(0), "ERC1155: balance query for the zero address");\n', '        return _balances[id][account];\n', '    }\n', '\n', '    function balanceOfBatch(\n', '        address[] memory accounts,\n', '        uint256[] memory ids\n', '    )\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256[] memory)\n', '    {\n', '        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");\n', '\n', '        uint256[] memory batchBalances = new uint256[](accounts.length);\n', '\n', '        for (uint256 i = 0; i < accounts.length; ++i) {\n', '            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n', '        }\n', '\n', '        return batchBalances;\n', '    }\n', '\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(_msgSender() != operator, "ERC1155: setting approval status for self");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[account][operator];\n', '    }\n', '\n', '\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n', '\n', '        uint256 fromBalance = _balances[id][from];\n', '        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '        _balances[id][from] = fromBalance - amount;\n', '        _balances[id][to] += amount;\n', '\n', '        emit TransferSingle(operator, from, to, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n', '    }\n', '\n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: transfer caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n', '\n', '        for (uint256 i = 0; i < ids.length; ++i) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 fromBalance = _balances[id][from];\n', '            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '            _balances[id][from] = fromBalance - amount;\n', '            _balances[id][to] += amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, from, to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n', '    }\n', '\n', '    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n', '        require(account != address(0), "ERC1155: mint to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n', '\n', '        _balances[id][account] += amount;\n', '        emit TransferSingle(operator, address(0), account, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n', '    }\n', '\n', '\n', '    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n', '        require(to != address(0), "ERC1155: mint to the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n', '\n', '        for (uint i = 0; i < ids.length; i++) {\n', '            _balances[ids[i]][to] += amounts[i];\n', '        }\n', '\n', '        emit TransferBatch(operator, address(0), to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n', '    }\n', '\n', '    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");\n', '\n', '        uint256 accountBalance = _balances[id][account];\n', '        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '        _balances[id][account] = accountBalance - amount;\n', '\n', '        emit TransferSingle(operator, account, address(0), id, amount);\n', '    }\n', '\n', '    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");\n', '\n', '        for (uint i = 0; i < ids.length; i++) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 accountBalance = _balances[id][account];\n', '            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '            _balances[id][account] = accountBalance - amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, account, address(0), ids, amounts);\n', '    }\n', '\n', '    function _beforeTokenTransfer(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        internal\n', '        virtual\n', '    { }\n', '\n', '    function _doSafeTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doSafeBatchTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n', '        uint256[] memory array = new uint256[](1);\n', '        array[0] = element;\n', '\n', '        return array;\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '  \n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '       \n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface BundNFTToken {\n', '\n', '    function burn(uint256 amount) external returns (bool);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(\n', '        BundNFTToken token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transfer.selector, to, value)\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        BundNFTToken token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        BundNFTToken token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.approve.selector, spender, value)\n', '        );\n', '    }\n', '\n', '    function safeIncreaseAllowance(\n', '        BundNFTToken token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance =\n', '            token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(\n', '                token.approve.selector,\n', '                spender,\n', '                newAllowance\n', '            )\n', '        );\n', '    }\n', '\n', '    function safeDecreaseAllowance(\n', '        BundNFTToken token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance =\n', '            token.allowance(address(this), spender).sub(\n', '                value,\n', '                "SafeERC20: decreased allowance below zero"\n', '            );\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(\n', '                token.approve.selector,\n', '                spender,\n', '                newAllowance\n', '            )\n', '        );\n', '    }\n', '\n', '    function callOptionalReturn(BundNFTToken token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '\n', '            require(\n', '                abi.decode(returndata, (bool)),\n', '                "SafeERC20: ERC20 operation did not succeed"\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', 'contract BundNFTMarketPlace is ERC1155 {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for BundNFTToken;\n', '\n', '    BundNFTToken public BundNFT;\n', '\n', '    uint8 RareNFT = 0;                       //_______| Rare NFT token index: 0 |_________\n', '    uint8 SpecialNFT = 1;                    //_______| Rare NFT token index: 1 |________\n', '    uint8 LegendNFT = 2;                     //_______| Rare NFT token index: 2 |________\n', '\n', '    uint8 copiesRareNFT = 6;                       //_______| Copies of Rare NFT    : 6 |_________\n', '    uint8 copiesSpecialNFT = 12;                   //_______| Copies of Special NFT :  12 |_________\n', '    uint8 copiesLegendNFT = 1;                     //_______| Copy of Legend NFT    :  1 |_________\n', '\n', '    uint256 basePriceRareNFT = 200*10**18;       //________| 200 BundNFT for each Rare_NFT |_____\n', '    uint256 basePriceSpecialNFT = 400*10**18;    //________| 400 BundNFT for each Rare_NFT |_____\n', '    uint256 basePriceLegendNFT = 800*10**18;     //________| 800 BundNFT for each Rare_NFT |_____\n', '   \n', '    mapping(uint8 => uint8) public mintedNFT;                  //_______| Mapping to track each NFT minting |_______\n', '\n', '    constructor(address _bundNFT) {\n', '        BundNFT = BundNFTToken(_bundNFT); \n', '    }\n', '\n', '    function burn(uint256 _amount) public virtual returns (bool) {\n', '       BundNFT.burn(_amount);\n', '       return true;\n', '    } \n', '    \n', '    function purchaseRareNFT(uint8 _copiesNFT) public {\n', '        \n', '        require(mintedNFT[RareNFT] < copiesRareNFT," RareNFT: Exceeding 6 copies");\n', '        require(BundNFT.balanceOf(msg.sender) >= basePriceRareNFT.mul(_copiesNFT),"Insufficient BundNFT in your wallet");\n', '        \n', '        _mint(msg.sender, RareNFT, _copiesNFT, "");\n', '        BundNFT.safeTransferFrom(msg.sender, address(this), basePriceRareNFT.mul(_copiesNFT)); \n', '\n', '        mintedNFT[RareNFT] += _copiesNFT;                                 \n', '\n', '    }\n', '\n', '    function purchaseSpecialNFT(uint8 _copiesNFT) public {\n', '        \n', '        require(mintedNFT[SpecialNFT] < copiesSpecialNFT," SpecialNFT: Exceeding 12 copies");\n', '        require(BundNFT.balanceOf(msg.sender) >= basePriceSpecialNFT.mul(_copiesNFT),"Insufficient BundNFT in your wallet");\n', '        \n', '        _mint(msg.sender, SpecialNFT, _copiesNFT, "");\n', '        \n', '        BundNFT.safeTransferFrom(msg.sender, address(this), basePriceSpecialNFT.mul(_copiesNFT));\n', '        mintedNFT[SpecialNFT] += _copiesNFT;                                 \n', '    }\n', '\n', '\n', '    function purchaseLegendNFT() public {\n', '        \n', '        require(mintedNFT[LegendNFT] < copiesLegendNFT," LegendNFT: Exceeding 1 copy");\n', '        require(BundNFT.balanceOf(msg.sender) >= basePriceLegendNFT, "Insufficient BundNFT in your wallet");\n', '        \n', '        _mint(msg.sender, LegendNFT, 1, "");\n', '\n', '        BundNFT.safeTransferFrom(msg.sender, address(this), basePriceLegendNFT);\n', '        mintedNFT[LegendNFT] += 1;            \n', '\n', '    }\n', '\n', '    //++++| Burn all bundNFT deposits |+++++\n', '    function burnDeposits() public onlyOwner {\n', '        require(BundNFT.balanceOf(address(this)) >= basePriceLegendNFT, "No bundNFT deposits");\n', '        burn(BundNFT.balanceOf(address(this)));          \n', '    }\n', '\n', '    //++++| Claim all bundNFT deposits |+++++\n', '    function claimDeposits() public onlyOwner {\n', '        require(BundNFT.balanceOf(address(this)) > 0, "No bundNFT deposits in this contract");\n', '        BundNFT.transfer(owner(), BundNFT.balanceOf(address(this))); \n', '                            \n', '    }\n', '\n', '\n', '}']