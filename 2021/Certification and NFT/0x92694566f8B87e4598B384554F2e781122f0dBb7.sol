['// SPDX-License-Identifier: U-U-U-UPPPPP!!!\n', 'pragma solidity ^0.7.4;\n', '\n', '/* ROOTKIT:\n', 'A floor calculator to use with ERC31337 AMM pairs\n', 'Ensures 100% of accessible funds are backed at all times\n', '*/\n', '\n', 'import "./IFloorCalculator.sol";\n', 'import "./SafeMath.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./EnumerableSet.sol";\n', '\n', 'contract EliteFloorCalculator is IFloorCalculator, TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '    IERC20 immutable rootedToken;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    EnumerableSet.AddressSet ignoredAddresses;\n', '\n', '    constructor(IERC20 _rootedToken, IUniswapV2Factory _uniswapV2Factory)\n', '    {\n', '        rootedToken = _rootedToken;\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '    }    \n', '\n', '    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly()\n', '    {\n', '        if (add) \n', '        { \n', '            ignoredAddresses.add(ignoredAddress); \n', '        } \n', '        else \n', '        { \n', '            ignoredAddresses.remove(ignoredAddress); \n', '        }\n', '    }\n', '\n', '    function isIgnoredAddress(address ignoredAddress) public view returns (bool)\n', '    {\n', '        return ignoredAddresses.contains(ignoredAddress);\n', '    }\n', '\n', '    function ignoredAddressCount() public view returns (uint256)\n', '    {\n', '        return ignoredAddresses.length();\n', '    }\n', '\n', '    function ignoredAddressAt(uint256 index) public view returns (address)\n', '    {\n', '        return ignoredAddresses.at(index);\n', '    }\n', '\n', '    function ignoredAddressesTotalBalance() public view returns (uint256)\n', '    {\n', '        uint256 total = 0;\n', '        for (uint i = 0; i < ignoredAddresses.length(); i++) \n', '        {\n', '            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    function calculateExcessInPool(IERC20 token, address pair, uint256 liquidityShare, uint256 rootedTokenTotalSupply, uint256 rootedTokenPoolsLiquidity) internal view returns (uint256)\n', '    {\n', '        uint256 freeRootedToken = (rootedTokenTotalSupply.sub(rootedTokenPoolsLiquidity)).mul(liquidityShare).div(1e12);\n', '\n', '        uint256 sellAllProceeds = 0;\n', '        if (freeRootedToken > 0) \n', '        {\n', '            address[] memory path = new address[](2);\n', '            path[0] = address(rootedToken);\n', '            path[1] = address(token);\n', '            uint256[] memory amountsOut = UniswapV2Library.getAmountsOut(address(uniswapV2Factory), freeRootedToken, path);\n', '            sellAllProceeds = amountsOut[1];\n', '        }\n', '\n', '        uint256 backingInPool = token.balanceOf(pair);\n', '        if (backingInPool <= sellAllProceeds) { return 0; }\n', '        uint256 excessInPool = backingInPool - sellAllProceeds;\n', '\n', '        return excessInPool;\n', '    }\n', '\n', '    function calculateExcessInPools(IERC20 baseToken, IERC20 eliteToken) public view returns (uint256)\n', '    {\n', '        address rootedElitePair = UniswapV2Library.pairFor(address(uniswapV2Factory), address(rootedToken), address(eliteToken));\n', '        address rootedBasePair = UniswapV2Library.pairFor(address(uniswapV2Factory), address(rootedToken), address(baseToken));   \n', '        \n', '        uint256 rootedTokenTotalSupply = rootedToken.totalSupply().sub(ignoredAddressesTotalBalance());\n', '        uint256 rootedTokenPoolsLiquidity = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\n', '        uint256 baseTokenPoolsLiquidity = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\n', '\n', '        uint256 rootedLiquidityShareInElitePair = rootedToken.balanceOf(rootedElitePair).mul(1e12).div(rootedTokenPoolsLiquidity);\n', '        uint256 eliteLiquidityShareInElitePair = eliteToken.balanceOf(rootedElitePair).mul(1e12).div(baseTokenPoolsLiquidity);\n', '        uint256 avgLiquidityShareInElitePair = (rootedLiquidityShareInElitePair.add(eliteLiquidityShareInElitePair)).div(2);\n', '        uint256 one = 1e12;\n', '\n', '        uint256 excessInElitePool = calculateExcessInPool(eliteToken, rootedElitePair, avgLiquidityShareInElitePair, rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n', '        uint256 excessInBasePool = calculateExcessInPool(baseToken, rootedBasePair, (one).sub(avgLiquidityShareInElitePair), rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\n', '        return excessInElitePool.add(excessInBasePool);\n', '    }\n', '\n', '    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256)\n', '    {        \n', '        uint256 excessInPools = calculateExcessInPools(baseToken, eliteToken);\n', '\n', '        uint256 requiredBacking = eliteToken.totalSupply().sub(excessInPools);\n', '        uint256 currentBacking = baseToken.balanceOf(address(eliteToken));\n', '        if (requiredBacking >= currentBacking) { return 0; }\n', '        return currentBacking - requiredBacking;\n', '    }\n', '}']