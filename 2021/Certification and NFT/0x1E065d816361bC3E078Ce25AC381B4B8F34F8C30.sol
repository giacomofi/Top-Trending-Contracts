['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-27\n', '*/\n', '\n', '// Sources flattened with hardhat v2.2.0 https://hardhat.org\n', '\n', '// File contracts/IAmb.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IAMB {\n', '    function messageSender() external view returns (address);\n', '    function maxGasPerTx() external view returns (uint256);\n', '    function transactionHash() external view returns (bytes32);\n', '    function messageId() external view returns (bytes32);\n', '    function messageSourceChainId() external view returns (bytes32);\n', '    function messageCallStatus(bytes32 _messageId) external view returns (bool);\n', '    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);\n', '    function failedMessageReceiver(bytes32 _messageId) external view returns (address);\n', '    function failedMessageSender(bytes32 _messageId) external view returns (address);\n', '    function requireToPassMessage(address _contract, bytes calldata _data, uint256 _gas) external returns (bytes32);\n', '    function requireToConfirmMessage(address _contract, bytes calldata _data, uint256 _gas) external returns (bytes32);\n', '    function sourceChainId() external view returns (uint256);\n', '    function destinationChainId() external view returns (uint256);\n', '}\n', '\n', '\n', '// File contracts/Forwarder.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract Forwarder {\n', '  event PassToEth(bytes32 indexed msgId, address mediator, bytes data);\n', '  event PassToBsc(bytes32 indexed msgId, address mediator, bytes data);\n', '  \n', '  IAMB bscAmb;\n', '  IAMB ethAmb;\n', '  \n', '  address ethMediator;\n', '  address bscMediator;\n', '  uint256 gasLimit;\n', '\n', '  bool isFrozen;\n', '  \n', '  constructor(address _bscAmb, address _ethAmb) {\n', '    bscAmb = IAMB(_bscAmb);\n', '    ethAmb = IAMB(_ethAmb);\n', '  }\n', '\n', '  function set(address _ethMediator,\n', '               address _bscMediator,\n', '               uint256 _gasLimit) public {\n', '    require(!isFrozen, "Contract is frozen");\n', '    ethMediator = _ethMediator;\n', '    bscMediator = _bscMediator;\n', '    gasLimit = _gasLimit;\n', '  }\n', '\n', '  function freeze() public {\n', '    isFrozen = true;\n', '  }\n', '\n', '  function forwardToEth(address _mediator, bytes calldata _data) public {\n', '    require(msg.sender == address(bscAmb), "Only AMB can call.");\n', '    require(bscAmb.messageSender() == bscMediator, "Not receiving this from BSC Mediator.");\n', '    bytes32 msgId = ethAmb.requireToPassMessage(\n', '        _mediator,\n', '        _data,\n', '        gasLimit\n', '    );\n', '    \n', '    emit PassToEth(msgId, _mediator, _data);\n', '  }\n', '\n', '  function forwardToBsc(address _mediator, bytes calldata _data) public {\n', '    require(msg.sender == address(ethAmb), "Only AMB can call.");\n', '    require(ethAmb.messageSender() == ethMediator, "Not receiving this from ETH Mediator.");\n', '    bytes32 msgId = bscAmb.requireToPassMessage(\n', '        _mediator,\n', '        _data,\n', '        gasLimit\n', '    );\n', '\n', '    emit PassToBsc(msgId, _mediator, _data);\n', '  }\n', '}\n', '\n', '\n', '// File contracts/IStrudel.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IStrudel {\n', '  function mint(address to, uint256 amount) external returns (bool);\n', '  function burn(address from, uint256 amount) external returns (bool);\n', '  function burnFrom(address from, uint256 amount) external;\n', '  function renounceMinter() external;\n', '}\n', '\n', '\n', '// File contracts/ITokenRecipient.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/// @title Interface of recipient contract for `approveAndCall` pattern.\n', '///        Implementors will be able to be used in an `approveAndCall`\n', '///        interaction with a supporting contract, such that a token approval\n', '///        can call the contract acting on that approval in a single\n', '///        transaction.\n', '///\n', '///        See the `FundingScript` and `RedemptionScript` contracts as examples.\n', 'interface ITokenRecipient {\n', "  /// Typically called from a token contract's `approveAndCall` method, this\n", '  /// method will receive the original owner of the token (`_from`), the\n', '  /// transferred `_value` (in the case of an ERC721, the token id), the token\n', '  /// address (`_token`), and a blob of `_extraData` that is informally\n', '  /// specified by the implementor of this method as a way to communicate\n', '  /// additional parameters.\n', '  ///\n', '  /// Token calls to `receiveApproval` should revert if `receiveApproval`\n', '  /// reverts, and reverts should remove the approval.\n', '  ///\n', '  /// @param _from The original owner of the token approved for transfer.\n', '  /// @param _value For an ERC20, the amount approved for transfer; for an\n', '  ///        ERC721, the id of the token approved for transfer.\n', '  /// @param _token The address of the contract for the token whose transfer\n', '  ///        was approved.\n', '  /// @param _extraData An additional data blob forwarded unmodified through\n', '  ///        `approveAndCall`, used to allow the token owner to pass\n', '  ///         additional parameters and data to this method. The structure of\n', '  ///         the extra data is informally specified by the implementor of\n', '  ///         this interface.\n', '  function receiveApproval(\n', '    address _from,\n', '    uint256 _value,\n', '    address _token,\n', '    bytes calldata _extraData\n', '  ) external;\n', '}\n', '\n', '\n', '// File contracts/StrudelMediator.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', '\n', 'contract StrudelMediator is ITokenRecipient {\n', '  event StartCross(bytes32 indexed msgId,\n', '                   address indexed sender,\n', '                   address indexed recipient,\n', '                   uint256 value);\n', '  event EndCross(address indexed recipient,\n', '                 uint256 value);\n', '  \n', '  IAMB public amb;\n', '\n', '  address public admin;\n', '  IStrudel public strudel;\n', '  address public otherMediator;\n', '  address public forwarder;\n', '  uint256 public gasLimit;\n', '  bool isMainnet;\n', '\n', '  constructor(address _amb) {\n', '    amb = IAMB(_amb);\n', '    admin = msg.sender;\n', '  }\n', '\n', '  function set(address _strudel,\n', '               address _otherMediator,\n', '               address _forwarder,\n', '               uint256 _gasLimit,\n', '               bool _isMainnet,\n', '               address _admin) public {\n', '    require(msg.sender == admin, "Only admin");\n', '    strudel = IStrudel(_strudel);\n', '    otherMediator = _otherMediator;\n', '    forwarder = _forwarder;\n', '    gasLimit = _gasLimit;\n', '    isMainnet = _isMainnet;\n', '    admin = _admin;\n', '  }\n', '\n', '  function renounceMinter() public {\n', '    require(msg.sender == admin, "Only admin");\n', '    strudel.renounceMinter();\n', '  }\n', '\n', '  function startCross(uint256 _value, address _recipient) public returns (bool) {\n', '\n', '    require(!isMainnet, "Use approveAndCall on mainnet");\n', '\n', '    bytes4 methodSelector = StrudelMediator(address(0)).endCross.selector;\n', '    bytes memory data = abi.encodeWithSelector(methodSelector, _value, _recipient);\n', '\n', '    bytes4 f_methodSelector = Forwarder(address(0)).forwardToEth.selector;\n', '    bytes memory f_data = abi.encodeWithSelector(f_methodSelector, otherMediator, data);\n', '    \n', '    bytes32 msgId = amb.requireToPassMessage(\n', '        forwarder,\n', '        f_data,\n', '        gasLimit\n', '    );\n', '    \n', '    strudel.burn(msg.sender, _value);\n', '    \n', '    emit StartCross(msgId, msg.sender, _recipient, _value);\n', '    return true;\n', '  }\n', '\n', '  function receiveApproval(address _from,\n', '                           uint256 _value,\n', '                           address _token,\n', '                           bytes calldata _extraData\n', '                           ) external override {\n', '    require(msg.sender == address(strudel), "Only strudel can call.");\n', '    require(_token == address(strudel), "Only strudel can call.");\n', '    require(isMainnet, "Use startCross on BSC");\n', '\n', '    address _recipient = getAddr(_extraData);\n', '\n', '    bytes4 methodSelector = StrudelMediator(address(0)).endCross.selector;\n', '    bytes memory data = abi.encodeWithSelector(methodSelector, _value, _recipient);\n', '\n', '    bytes4 f_methodSelector = Forwarder(address(0)).forwardToBsc.selector;\n', '    bytes memory f_data = abi.encodeWithSelector(f_methodSelector, otherMediator, data);\n', '    \n', '    bytes32 msgId = amb.requireToPassMessage(\n', '        forwarder,\n', '        f_data,\n', '        gasLimit\n', '    );\n', '\n', '    strudel.burnFrom(_from, _value);\n', '    emit StartCross(msgId, _from, _recipient, _value);\n', '  }\n', '\n', '  function endCross(uint256 _value, address _recipient) public returns (bool) {\n', '    require(msg.sender == address(amb), "Only AMB can call.");\n', '    require(amb.messageSender() == forwarder, "Not receiving this from forwarder");\n', '\n', '    strudel.mint(_recipient, _value);\n', '    \n', '    emit EndCross(_recipient, _value);\n', '    return true;\n', '  }\n', '\n', '  function getAddr(bytes memory _extraData) internal pure returns (address){\n', '    address addr;\n', '    assembly {\n', '      addr := mload(add(_extraData,20))\n', '    }\n', '    return addr;\n', '  }\n', '}']