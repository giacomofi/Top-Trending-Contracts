['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-24\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract SimpleMultiSig {\n', '\n', '// EIP712 Precomputed hashes:\n', '// keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)")\n', 'bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\n', '\n', '// keccak256("Simple MultiSig")\n', 'bytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;\n', '\n', '// keccak256("1")\n', 'bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n', '\n', '// keccak256("MultiSigTransaction(address destination,uint256 value,bytes data,uint256 nonce,address executor,uint256 gasLimit)")\n', 'bytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;\n', '\n', 'bytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;\n', '\n', '  uint public nonce;                 // (only) mutable state\n', '  uint public threshold;             // immutable state\n', '  mapping (address => bool) isOwner; // immutable state\n', '  address[] public ownersArr;        // immutable state\n', '\n', '  bytes32 DOMAIN_SEPARATOR;          // hash for EIP712, computed from contract address\n', '\n', '  function owners() public view returns (address[]) {\n', '    return ownersArr;\n', '  }\n', '\n', '  // Note that owners_ must be strictly increasing, in order to prevent duplicates\n', '  function setOwners_(uint threshold_, address[] owners_) private {\n', '    require(owners_.length <= 20 && threshold_ <= owners_.length && threshold_ > 0);\n', '\n', '    // remove old owners from map\n', '    for (uint i = 0; i < ownersArr.length; i++) {\n', '      isOwner[ownersArr[i]] = false;\n', '    }\n', '\n', '    // add new owners to map\n', '    address lastAdd = address(0);\n', '    for (i = 0; i < owners_.length; i++) {\n', '      require(owners_[i] > lastAdd);\n', '      isOwner[owners_[i]] = true;\n', '      lastAdd = owners_[i];\n', '    }\n', '\n', '    // set owners array and threshold\n', '    ownersArr = owners_;\n', '    threshold = threshold_;\n', '  }\n', '\n', '  constructor(uint threshold_, address[] owners_, uint chainId) public {\n', '    setOwners_(threshold_, owners_);\n', '\n', '    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,\n', '                                            NAME_HASH,\n', '                                            VERSION_HASH,\n', '                                            chainId,\n', '                                            this,\n', '                                            SALT));\n', '  }\n', '\n', '  // Requires a quorum of owners to call from this contract using execute\n', '  function setOwners(uint threshold_, address[] owners_) external {\n', '    require(msg.sender == address(this));\n', '    setOwners_(threshold_, owners_);\n', '  }\n', '\n', '  // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates\n', '  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data, address executor, uint gasLimit) public {\n', '    require(sigR.length == threshold);\n', '    require(sigR.length == sigS.length && sigR.length == sigV.length);\n', '    require(executor == msg.sender || executor == address(0));\n', '\n', '    // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\n', '    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));\n', '    bytes32 totalHash = keccak256(abi.encodePacked("\\x19\\x01", DOMAIN_SEPARATOR, txInputHash));\n', '\n', '    address lastAdd = address(0); // cannot have address(0) as an owner\n', '    for (uint i = 0; i < threshold; i++) {\n', '      address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);\n', '      require(recovered > lastAdd && isOwner[recovered]);\n', '      lastAdd = recovered;\n', '    }\n', '\n', '    // If we make it here all signatures are accounted for.\n', '    // The address.call() syntax is no longer recommended, see:\n', '    // https://github.com/ethereum/solidity/issues/2884\n', '    nonce = nonce + 1;\n', '    bool success = false;\n', '    assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }\n', '    require(success);\n', '  }\n', '\n', '  function () payable external {}\n', '}']