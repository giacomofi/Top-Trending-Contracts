['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-10\n', '*/\n', '\n', '// SPDX-License-Identifier: https://github.com/lendroidproject/protocol.2.0/blob/master/LICENSE.md\n', '\n', '\n', '// File: @openzeppelin/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n', '    external returns (bytes4);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/ERC721Holder.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '  /**\n', '   * @dev Implementation of the {IERC721Receiver} interface.\n', '   *\n', '   * Accepts all token transfers. \n', '   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n', '   */\n', 'contract ERC721Holder is IERC721Receiver {\n', '\n', '    /**\n', '     * @dev See {IERC721Receiver-onERC721Received}.\n', '     *\n', '     * Always returns `IERC721Receiver.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC721Received.selector;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/access/Ownable.sol\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '     // solhint-disable-next-line func-visibility\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() virtual {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/IDecentralandLandRegistry.sol\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '\n', 'interface IDecentralandLandRegistry {\n', '    // Authorize UpdateOperator\n', '    function setUpdateOperator(uint256 assetId, address operator) external;\n', '}\n', '\n', '// File: contracts/IVault.sol\n', '\n', 'pragma solidity 0.7.5;\n', 'pragma abicoder v2;\n', '\n', '\n', '/**\n', ' * @dev Required interface of a Vault compliant contract.\n', ' */\n', 'interface IVault {\n', '    function lockVault() external;\n', '\n', '    function unlockVault() external;\n', '\n', '    function safeAddAsset(address[] calldata tokenAddresses, uint256[] calldata tokenIds,\n', '            string[] calldata categories) external;\n', '\n', '    function safeTransferAsset(uint256[] calldata assetIds) external;\n', '\n', '    function escapeHatchERC721(address tokenAddress, uint256 tokenId) external;\n', '\n', '    function setDecentralandOperator(address registryAddress, address operatorAddress,\n', '        uint256 assetId) external;\n', '\n', '    function transferOwnership(address newOwner) external;\n', '\n', '    function totalAssetSlots() external view returns (uint256);\n', '\n', '    function vaultOwner() external view returns (address);\n', '\n', '    function onERC721Received(address, uint256, bytes memory) external pure returns (bytes4);\n', '\n', '}\n', '\n', '// File: contracts/SimpleVault.sol\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/** @title SimpleVault\n', '    @author Lendroid Foundation\n', '    @notice Smart contract representing a NFT Vault\n', '    @dev Audit certificate : Pending\n', '*/\n', 'contract SimpleVault is IVault, Ownable, ERC721Holder {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    struct Asset {\n', '        string category;\n', '        address tokenAddress;\n', '        uint256 tokenId;\n', '    }\n', '\n', '    bool public locked;\n', '    Asset[] public assets;\n', '    uint256 public totalAssets;\n', '    // return value for safeTransferFrom function calls of older ERC721 versions\n', '    bytes4 public constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() override virtual {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function lockVault() external override onlyOwner {\n', '        toggleLock(true);\n', '    }\n', '\n', '    function unlockVault() external override onlyOwner {\n', '        toggleLock(false);\n', '    }\n', '\n', '    /**\n', '    * @notice Allows owner to add NFTs to the vault.\n', '    * Eg, [0x67678.., 0x2178..., 0x67678], [3, 1321, 33], ["kitty", "land", "kitty"]\n', '    */\n', '    function safeAddAsset(address[] calldata tokenAddresses, uint256[] calldata tokenIds, string[] calldata categories)\n', '    external override onlyOwner {\n', '        require(!locked, "{safeAddAsset} : locked");\n', '        require(tokenAddresses.length > 0, "{safeAddAsset} : tokenAddresses cannot be empty");\n', '        require(tokenAddresses.length == tokenIds.length,\n', '            "{safeAddAsset} : tokenAddresses and tokenIds lengths are not equal");\n', '        require(tokenAddresses.length == categories.length,\n', '            "{safeAddAsset} : tokenAddresses and categories lengths are not equal");\n', '        // validate inputs\n', '        for (uint i = 0; i < tokenAddresses.length; i++) {\n', '            require(tokenAddresses[i].isContract(), "{safeAddAsset} : invalid tokenAddress");\n', '            require(IERC721(tokenAddresses[i]).ownerOf(tokenIds[i]) == owner(), "{safeAddAsset} : invalid tokenId");\n', '        }\n', '        for (uint i = 0; i < tokenAddresses.length; i++) {\n', '            totalAssets = totalAssets.add(1);\n', '            // transfer the NFT\n', '            IERC721(tokenAddresses[i]).safeTransferFrom(owner(), address(this), tokenIds[i]);\n', '            // save asset to array\n', '            assets.push(Asset({\n', '                category: categories[i],\n', '                tokenAddress: tokenAddresses[i],\n', '                tokenId: tokenIds[i]\n', '            }));\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Allows owner to transfer NFTs from the vault.\n', '    * Eg, [3, 200, 54]\n', '    */\n', '    function safeTransferAsset(uint256[] calldata assetIds) external override onlyOwner {\n', '        require(!locked, "{safeTransferAsset} : locked");\n', '        require(assetIds.length > 0, "{safeTransferAsset} : assetIds cannot be empty");\n', '        // validate inputs\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            require(assets.length > assetIds[i], "{safeTransferAsset} : 400, Invalid assetId");\n', '            require(assets[assetIds[i]].tokenAddress != address(0),\n', '                "{safeTransferAsset} : 404, asset does not exist");\n', '        }\n', '        for (uint i = 0; i < assetIds.length; i++) {\n', '            totalAssets = totalAssets.sub(1);\n', '            // transfer asset to new owner\n', '            IERC721(assets[assetIds[i]].tokenAddress).safeTransferFrom(address(this),\n', '                owner(), assets[assetIds[i]].tokenId);\n', '            // remove asset but preserve array length\n', '            delete assets[assetIds[i]];\n', '        }\n', '    }\n', '\n', '    // admin functions in case something goes wrong\n', '    function escapeHatchERC721(address tokenAddress, uint256 tokenId) external override onlyOwner {\n', '        require(tokenAddress != address(0), "{escapeHatchERC721} : invalid tokenAddress");\n', '        require(IERC721(tokenAddress).ownerOf(tokenId) == address(this), "{escapeHatchERC721} : invalid tokenId");\n', '        IERC721(tokenAddress).safeTransferFrom(address(this), owner(), tokenId);\n', '    }\n', '\n', '    function setDecentralandOperator(address registryAddress, address operatorAddress, uint256 assetId)\n', '    external override onlyOwner {\n', '        require(registryAddress != address(0), "{setDecentralandOperator} : invalid registryAddress");\n', '        require(operatorAddress != address(0), "{setDecentralandOperator} : invalid operatorAddress");\n', '        require(assets.length > assetId, "{setDecentralandOperator} : 400, Invalid assetId");\n', '        IDecentralandLandRegistry(registryAddress).setUpdateOperator(assets[assetId].tokenId, operatorAddress);\n', '    }\n', '\n', '    function totalAssetSlots() external view override returns (uint256) {\n', '        return assets.length;\n', '    }\n', '\n', '    function vaultOwner() public view override returns (address) {\n', '        return owner();\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public override(IVault, Ownable) virtual onlyOwner {\n', '        require(newOwner != address(0), "{transferOwnership} : invalid new owner");\n', '        super.transferOwnership(newOwner);\n', '    }\n', '\n', '    function onERC721Received(address, uint256, bytes memory) public pure override returns (bytes4) {\n', '        return ERC721_RECEIVED_OLD;\n', '    }\n', '\n', '    function toggleLock(bool value) internal {\n', '        require(locked == !value, "{toggleLock} : incorrect value");\n', '        locked = value;\n', '    }\n', '}\n', '\n', '// File: contracts/SimpleVault2.sol\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '\n', '\n', '\n', '\n', '/** @title SimpleVault2\n', '    @author Lendroid Foundation\n', '    @notice Smart contract representing an NFT Vault which contains the NFT key to the B.20 vault\n', '    @dev Audit certificate : Pending (deployed after the B.20 audit)\n', '*/\n', 'contract SimpleVault2 is SimpleVault {\n', '\n', '    using Address for address;\n', '\n', '    // NFT address that would be the key to unlock the B.20 Vault\n', '    IERC721 public vaultKey;\n', '\n', '    // solhint-disable-next-line func-visibility\n', '    constructor(address vaultKeyAddress) {\n', '        // input validations\n', '        require(vaultKeyAddress.isContract(), "{SimpleVault2} : invalid vaultKeyAddress");\n', '        // set values\n', '        vaultKey = IERC721(vaultKeyAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner of the vault key.\n', '     */\n', '    function owner() public view override returns (address) {\n', '        return vaultKey.ownerOf(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner of the vault key.\n', '     */\n', '    modifier onlyOwner() override {\n', '        require(vaultKey.ownerOf(1) == _msgSender(),\n', '            "{SimpleVault2}: caller is not the owner of vault key");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer of ownership is meaningless, since the vault key owner is the actual owner.\n', '     */\n', '    function transferOwnership(address newOwner) public override {\n', '        require(newOwner != address(0), "{transferOwnership} : invalid new owner");\n', '        revert();\n', '    }\n', '\n', '}']