['"""\n', '@title Greenwood Controller\n', '@notice An entry point for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'interface ESCROW:\n', '    def borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]): payable\n', '    def repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]): payable\n', '    def addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]): payable\n', '    def withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32,  _store: address, _version: String[11]): nonpayable\n', '\n', 'interface LIQUIDATOR:\n', '    def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _aave_V2_escrow: address, _compound_escrow: address, _key_count: uint256, _liquidator: address, _loan_keys: bytes32[100], _aave_v2_loan_keys: bytes32[100], _compound_loan_keys: bytes32[100], _store: address, _version: String[11]): nonpayable\n', '\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', 'interface ROUTER:\n', '    def split(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _protocol: String[10], _store: address, _version: String[11]) -> Split: nonpayable\n', '\n', 'interface STORE:\n', '    def getAssetContext(_ticker: String[10]) -> AssetContext: view\n', '    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\n', '    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\n', '    def getLoan(_loan_key: bytes32) -> Loan: view\n', '    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\n', '\n', '# define the events used by the contract\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', 'event TogglePauseBorrow:\n', '    previousIsBorrowPaused: bool\n', '    newIsBorrowPaused: bool\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', '# define the structs used by the contract\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct Loan:\n', '    collateralAsset: address\n', '    borrowAsset: address\n', '    outstanding: uint256\n', '    collateralizationRatio: uint256\n', '    collateralLocked: uint256\n', '    borrower: address\n', '    lastBorrowIndex: uint256\n', '    repaymentTime: uint256\n', '\n', 'struct Split:\n', '    compoundSplit: uint256\n', '    aaveV2Split: uint256\n', '    borrowContext: AssetContext\n', '    collateralContext: AssetContext\n', '\n', '# define the storage variables used by the contract\n', 'isBorrowPaused: public(bool)\n', 'registry: public(address)\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isGovernance(_caller: address, _role: String[20]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @return True if the caller is the Governance, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "governance"\n', '    if keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison boolean\n', '        return governance == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '@external\n', '@payable\n', '@nonreentrant("controller_lock")\n', 'def borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _collateralization_ratio: uint256, _protocol: String[10], _version: String[11]):\n', '    """\n', '    @notice Borrow assets from AaveV2 or Compound at the lowest instantaneous APR\n', '    @param _borrow_ticker The ticker string of the asset that is being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of asset being borrowed scaled by the asset's decimals\n", '    @param _collateralization_ratio The collateralization ratio for the loan\n', '    @param _protocol The name of the underlying lending protocol for the loan\n', '    @param _version The version of the Greenwood protocol to use\n', '    """\n', '\n', '    # require that borrowing is not paused\n', '    assert self.isBorrowPaused == False, "Borrowing is paused"\n', '\n', '    # require that the collateralization ratio is at least 100%\n', '    assert _collateralization_ratio >= 100, "Collateralization ratio too low"\n', '\n', '    # cache the Registry address into memory\n', '    cachedRegistry: address = self.registry\n', '\n', '    # get the addresses of the Greenwood Router and Store for the specified version from the Registry\n', '    store: address = REGISTRY(cachedRegistry).getAddress("store", _version)\n', '    router: address = REGISTRY(cachedRegistry).getAddress("router", _version)\n', '\n', '    # find the protocol with the lowest instantaneous APR\n', '    split: Split = ROUTER(router).split(_borrow_ticker, _collateral_ticker, _amount, _protocol, store, _version)\n', '\n', '    # check if the loan should be routed to Aave V2\n', '    if split.aaveV2Split == 100 and split.compoundSplit == 0:\n', '\n', '        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\n', '        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress("aaveV2Escrow", _version)\n', '        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress("aaveV2Calculator", _version)\n', '\n', '        # call borrow() on the Aave V2 Escrow to initiate the borrow\n', '        ESCROW(aaveV2Escrow).borrow(_borrow_ticker, _collateral_ticker, split.borrowContext, split.collateralContext, _amount, msg.sender, aaveV2Calculator, _collateralization_ratio, store, _version)\n', '\n', '    # check if the loan should be routed to Compound\n', '    elif split.compoundSplit == 100 and split.aaveV2Split == 0:\n', '\n', '        # get the addresses of the Greenwood Compound Escrow and Calculator for the specified version from the Registry\n', '        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress("compoundEscrow", _version)\n', '        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress("compoundCalculator", _version)\n', '\n', '        # call borrow() on the Compound Escrow to initiate the borrow\n', '        ESCROW(compoundEscrow).borrow(_borrow_ticker, _collateral_ticker, split.borrowContext, split.collateralContext, _amount, msg.sender, compoundCalculator, _collateralization_ratio, store, _version, value=msg.value)\n', '\n', '    # catch unsupported borrow splits\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled split values for borrow"\n', '         \n', '@external\n', '@payable\n', '@nonreentrant("controller_lock")\n', 'def repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\n', '    """\n', '    @notice Repay borrowed assets to Aave V2 or Compound\n', '    @param _borrow_ticker The ticker string of the asset that was being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the repayment scaled by the asset's decimals\n", '    @param _loan_key The uinque identifier for the loan\n', '    @param _version The version of the Greenwood protocol to use\n', '    @dev Passing 2 ** 256 - 1 as _amount triggers a full repayment\n', '    """\n', '\n', '    # cache the Registry address into memory\n', '    cachedRegistry: address = self.registry\n', '\n', '    # get the addresses of the Greenwood Store for the specified version from the Registry\n', '    store: address = REGISTRY(cachedRegistry).getAddress("store", _version)\n', '\n', '    # get the loan protocol from the Store\n', '    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol string was returned\n', '    assert keccak256(protocol) != keccak256(""), "No loan protocol returned from the Store"\n', '\n', '    # check if the loan was originated with Aave V2\n', '    if keccak256(protocol) == keccak256("aavev2"):\n', '\n', '        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\n', '        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress("aaveV2Escrow", _version)\n', '        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress("aaveV2Calculator", _version)\n', '\n', '        # call repay() on Escrow to initiate the repayment of the loan\n', '        ESCROW(aaveV2Escrow).repay(_borrow_ticker, _collateral_ticker, _amount, aaveV2Calculator, _loan_key, store, _version)\n', '    \n', '    # check if the loan was originated with Compound\n', '    elif keccak256(protocol) == keccak256("compound"):\n', '\n', '        # get the addresses of the Greenwood Compound escrow and Calculator for the specified version from the Registry\n', '        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress("compoundEscrow", _version)\n', '        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress("compoundCalculator", _version)\n', '\n', '        # call repay() on Escrow to initiate the repayment of the loan\n', '        ESCROW(compoundEscrow).repay(_borrow_ticker, _collateral_ticker, _amount, compoundCalculator, _loan_key, store, _version, value=msg.value)\n', '\n', '    # catch unsupported lending protocols\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled protocol for repay"\n', '\n', '@external\n', '@payable\n', '@nonreentrant("controller_lock")\n', 'def addCollateral(_collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\n', '    """\n', '    @notice Add collateral to an underlying lending protocol\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the deposit scaled by the asset's decimals\n", '    @param _loan_key The uinque identifier for the loan\n', '    @param _version The version of the Greenwood protocol to use\n', '    """\n', '\n', '    # cache the Registry address into memory\n', '    cachedRegistry: address = self.registry\n', '\n', '    # get the address of the Greenwood Store for the specified version from the Registry\n', '    store: address = REGISTRY(cachedRegistry).getAddress("store", _version)\n', '\n', '    # get the loan protocol from the Store\n', '    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol string was returned\n', '    assert keccak256(protocol) != keccak256(""), "No loan protocol returned from the Store"\n', '\n', '    # check if the loan was originated with Aave V2\n', '    if keccak256(protocol) == keccak256("aavev2"):\n', '\n', '        # get the address of the Greenwood Aave V2 Escrow for the specified version from the Registry\n', '        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress("aaveV2Escrow", _version)\n', '\n', '        # call addCollateral() on the Aave V2 Escrow to initiate the addition of collateral\n', '        ESCROW(aaveV2Escrow).addCollateral(_collateral_ticker, _amount, msg.sender, _loan_key, store, _version)\n', '\n', '    # check if the loan was originated with Compound\n', '    elif keccak256(protocol) == keccak256("compound"):\n', '\n', '        # get the address of the Greenwood Compound Escrow for the specified version from the Registry\n', '        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress("compoundEscrow", _version)\n', '\n', '        # call addCollateral() on the Compound Escrow to initiate the addition of collateral\n', '        ESCROW(compoundEscrow).addCollateral(_collateral_ticker, _amount, msg.sender, _loan_key, store, _version, value=msg.value)\n', '\n', '    # catch unsupported lending protocols\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled protocol for addCollateral"\n', '\n', '@external\n', '@nonreentrant("controller_lock")\n', 'def withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _loan_key: bytes32, _version: String[11]):\n', '    """\n', '    @notice Withdraw collateral from an underlying lending protocol\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the withdrawal scaled by the asset's decimals\n", '    @param _loan_key The uinque identifier for the loan\n', '    @param _version The version of the Greenwood protocol to use\n', '    """\n', '\n', '    # cache the Registry address into memory\n', '    cachedRegistry: address = self.registry\n', '\n', '    # get the address of the Greenwood Store for the specified version from the Registry\n', '    store: address = REGISTRY(cachedRegistry).getAddress("store", _version)\n', '\n', '    # get the loan protocol from the Store\n', '    protocol: String[10] = STORE(store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol string was returned\n', '    assert keccak256(protocol) != keccak256(""), "No loan protocol returned from the Store"\n', '\n', '    # check if the loan was originated with Aave V2\n', '    if keccak256(protocol) == keccak256("aavev2"):\n', '\n', '        # get the addresses of the Greenwood Aave V2 Escrow and Calculator for the specified version from the Registry\n', '        aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress("aaveV2Escrow", _version)\n', '        aaveV2Calculator: address = REGISTRY(cachedRegistry).getAddress("aaveV2Calculator", _version)\n', '\n', '        # call withdrawCollateral() on the Aave V2 Escrow to initiate the withdrawal of collateral\n', '        ESCROW(aaveV2Escrow).withdrawCollateral(_borrow_ticker, _collateral_ticker, _amount, aaveV2Calculator, _loan_key, store, _version)\n', '\n', '    # check if the loan was originated with Compound\n', '    elif keccak256(protocol) == keccak256("compound"):\n', '\n', '        # get the addresses of the Greenwood Compound Escrow and Calculator for the specified version from the Registry\n', '        compoundEscrow: address = REGISTRY(cachedRegistry).getAddress("compoundEscrow", _version)\n', '        compoundCalculator: address = REGISTRY(cachedRegistry).getAddress("compoundCalculator", _version)\n', '\n', '        # call withdrawCollateral() on the Compound Escrow to initiate the withdrawal of collateral\n', '        ESCROW(compoundEscrow).withdrawCollateral(_borrow_ticker, _collateral_ticker, _amount, compoundCalculator, _loan_key, store, _version)\n', '    \n', '    # catch unsupported protocols\n', '    else:\n', '        raise "Unhandled protocol for withdrawCollateral"\n', '\n', '@external\n', '@payable\n', '@nonreentrant("controller_lock")\n', 'def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _key_count: uint256, _loan_keys: bytes32[100], _version: String[11]):\n', '    """\n', '    @notice Liquidate undercollateralized loans    \n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _key_count The number of uinque identifiers in the _loan_keys array\n', '    @param _loan_keys The uinque identifiers for the loans\n', '    @param _version The version of the Greenwood protocol to use\n', '    """\n', '\n', '    # require that the key count is less than or equal to the max length of the loan keys array\n', '    assert _key_count <= 100 and _key_count > 0, "Key count must be less than or equal to 100 and greater than 0"\n', '\n', '    # cache the Registry address into memory\n', '    cachedRegistry: address = self.registry\n', '\n', '    # get the addresses of the Greenwood Store for the specified version from the Registry\n', '    store: address = REGISTRY(cachedRegistry).getAddress("store", _version)\n', '\n', '    # get the addresses of the Greenwood Liquidator for the specified version from the Registry\n', '    liquidator: address = REGISTRY(cachedRegistry).getAddress("liquidator", _version)\n', '\n', '    # get the address of the Greenwood Aave V2 Escrow from the Registry\n', '    aaveV2Escrow: address = REGISTRY(cachedRegistry).getAddress("aaveV2Escrow", _version)\n', '\n', '    # get the addresso f the Greenwood Compound Escrow from the Registry\n', '    compoundEscrow: address = REGISTRY(cachedRegistry).getAddress("compoundEscrow", _version)\n', '\n', '    # call liquidate() on the Liquidator\n', '    LIQUIDATOR(liquidator).liquidate(_borrow_ticker, _collateral_ticker, aaveV2Escrow, compoundEscrow, _key_count, msg.sender, _loan_keys, empty(bytes32[100]), empty(bytes32[100]), store, _version)\n', '\n', '@external\n', '@nonreentrant("controller_lock")\n', 'def togglePauseBorrow():\n', '    """\n', '    @notice Pause and unpause the borrow method\n', '    @dev Only the Controller governance can call this method\n', '    """\n', '\n', '    # assert that the method caller is the Governance\n', '    assert self.isGovernance(msg.sender, "governance") == True, "Only Governance can call this method"\n', '\n', '    # get the previous isBorrowPaused\n', '    previousIsBorrowPaused: bool = self.isBorrowPaused\n', '\n', '    # set the isBorrowPaused bool to be the negation of the current value\n', '    self.isBorrowPaused = not self.isBorrowPaused\n', '\n', '    # emit a TogglePauseBorrow event\n', '    log TogglePauseBorrow(previousIsBorrowPaused, not previousIsBorrowPaused, msg.sender, block.number)\n', '\n', '@external\n', '@nonreentrant("controller_lock")\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isGovernance(msg.sender, "governance") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)']