['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', 'pragma solidity ^0.5;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '// File: contracts/StandardProductPurchase.sol\n', '\n', 'pragma solidity ^0.5;\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Invalid Owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract StandardProductPurchase is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    // Base Seller Fee;\n', '    uint256 baseFeePercent;\n', '    uint256 baseFeeDivisor;\n', '    \n', '    \n', '    /* Referral Commision Config */\n', '    uint256 referralCommissionChargePercent;\n', '    uint256 referralCommissionChargeDivisor;\n', '    address payable referralChargeReceiver;\n', '    \n', '    // Transaction Config \n', '    uint256 transactionChargePercent;\n', '    uint256 transactionChargeDivisor;\n', '    address payable transactionChargeReceiver;\n', '    \n', '    \n', '    \n', '    // List of authorizedCaller with escalated permissions\n', '    mapping(address => bool) authorizedCaller;\n', '\n', '   \n', '    /* ProductTx */\n', '    struct ProductTx {\n', '        string _txId;\n', '        string _id;\n', '        uint256 _depositedAmt;\n', '        uint256 _receivableAmt;\n', '        uint256 _feeAmt;\n', '        uint256 _paymentMode;\n', '        uint256 _pledgedFeePercent;\n', '        uint256 _pledgedFeeDivisor;\n', '        address payable _ownerAddress;\n', '    }\n', '    \n', '    // Product Info\n', '    struct ProductInfo {\n', '        string _id;\n', '        uint256 _priceInWei;\n', '        address payable _ownerAddress;\n', '        uint256 _pledgedFeePercent;\n', '        uint256 _pledgedFeeDivisor;\n', '        uint256 _paymentMode;\n', '    }\n', '\n', '   \n', '    // To Get Product TX Info\n', '    mapping(string => ProductTx) public initiatedProductTx;\n', '    mapping(string => ProductInfo) public initiatedProduct;\n', '    \n', '    // Events \n', '    event AuthorizedCaller(address _caller);\n', '    event DeAuthorizedCaller(address _caller);\n', '    \n', '    // Product Updates \n', '    event ProductInfoUpdated(string _id,\n', '        uint256 _priceInWei,\n', '        address payable _ownerAddress,\n', '        uint256 _pledgedFeePercent,\n', '        uint256 _pledgedFeeDivisor,\n', '        uint256 _paymentMode);\n', '    \n', '    // Transaction \n', '\n', '    event ConfigUpdated(\n', '        address payable _transactionChargeReceiver,\n', '        uint256 _transactionChargePercent,\n', '        uint256 _transactionChargeDivisor,\n', '        address payable _referralChargeReceiver,\n', '        uint256 _referralCommissionChargePercent,\n', '        uint256 _referralCommissionChargeDivisor,\n', '        uint256 _baseFeePercent,\n', '        uint256 _baseFeeDivisor\n', '    );\n', '    \n', '\n', '    event TransactionCompleted(\n', '        string _txId\n', '    );\n', '    \n', ' \n', '\n', '    constructor(address payable _transactionChargeReceiver, address payable _referralChargeReceiver) public {\n', '        owner = msg.sender;\n', '        transactionChargeReceiver = _transactionChargeReceiver;\n', '        referralChargeReceiver = _referralChargeReceiver;\n', '    }\n', '\n', '    modifier onlyAuthorized() {\n', '        require(\n', '            authorizedCaller[msg.sender] == true || msg.sender == owner,\n', '            "Only Authorized and Owner can perform this action"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function authorizeCaller(address _caller) public onlyOwner returns (bool) {\n', '        authorizedCaller[_caller] = true;\n', '        emit AuthorizedCaller(_caller);\n', '        return true;\n', '    }\n', '\n', '    function deAuthorizeCaller(address _caller)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        authorizedCaller[_caller] = false;\n', '        emit DeAuthorizedCaller(_caller);\n', '        return true;\n', '    }\n', '\n', '        \n', '\n', '    function getConfig()\n', '        public\n', '        view\n', '        returns (\n', '            address _transactionChargeReceiver,\n', '            uint256 _transactionChargePercent,\n', '            uint256 _transactionChargeDivisor,\n', '            address _referralChargeReceiver,\n', '            uint256 _referralCommissionChargePercent,\n', '            uint256 _referralCommissionChargeDivisor,\n', '            uint256 _baseFeePercent,\n', '            uint256 _baseFeeDivisor\n', '        )\n', '    {\n', '        return (\n', '            transactionChargeReceiver,\n', '            transactionChargePercent,\n', '            transactionChargeDivisor,\n', '            referralChargeReceiver,\n', '            referralCommissionChargePercent,\n', '            referralCommissionChargeDivisor,\n', '            baseFeePercent,\n', '            baseFeeDivisor\n', '        );\n', '    }\n', '\n', '    function updateConfig(\n', '        address payable _transactionChargeReceiver,\n', '        uint256 _transactionChargePercent,\n', '        uint256 _transactionChargeDivisor,\n', '        address payable _referralChargeReceiver,\n', '        uint256 _referralCommissionChargePercent,\n', '        uint256 _referralCommissionChargeDivisor,\n', '        uint256 _baseFeePercent,\n', '        uint256 _baseFeeDivisor\n', '    ) public onlyAuthorized returns (bool) {\n', '        \n', '        // Base Fee \n', '        baseFeePercent = _baseFeePercent;\n', '        baseFeeDivisor = _baseFeeDivisor;\n', '        \n', '        // Transaction \n', '        transactionChargeReceiver = _transactionChargeReceiver;\n', '        transactionChargePercent = _transactionChargePercent;\n', '        transactionChargeDivisor = _transactionChargeDivisor;\n', '    \n', '        // Referral \n', '        referralChargeReceiver = _referralChargeReceiver;\n', '        referralCommissionChargePercent = _referralCommissionChargePercent;\n', '        referralCommissionChargeDivisor = _referralCommissionChargeDivisor;\n', '        \n', '        emit ConfigUpdated(\n', '            _transactionChargeReceiver,\n', '            _transactionChargePercent,\n', '            _transactionChargeDivisor,\n', '            _referralChargeReceiver,\n', '            _referralCommissionChargePercent,\n', '            _referralCommissionChargeDivisor,\n', '            _baseFeePercent,\n', '            _baseFeeDivisor\n', '        );\n', '\n', '        return true;\n', '    }\n', '    \n', '    \n', '\n', '    function updateProductInfo(\n', '        string memory _id,\n', '        uint256 _priceInWei,\n', '        uint256 _pledgedFeePercent,\n', '        uint256 _pledgedFeeDivisor,\n', '        uint256 _paymentMode) public \n', '        returns (bool)\n', '    {\n', '        /* Check if Product Already exist, if yes then check if updated by same owner*/\n', '        if(initiatedProduct[_id]._ownerAddress != address(0x0))\n', '        {\n', '            require(msg.sender == initiatedProduct[_id]._ownerAddress, "Product can only be updated by owner only");\n', '        }\n', '        \n', '        // To Ensure Pledged Percent are within Permissible limits (Should not exceed 100% and Should not be less than Base fee)\n', '        uint256 _baseCheckInt = 10 ** 18;\n', '        \n', '        uint256 _ceilInt = 0;\n', '        uint256 _ceilPercent = 100; \n', '        uint256 _ceilDivisor = 1;\n', '        \n', '        \n', '        uint256 _expectedInt = 0;\n', '        uint256 _actualInt = 0;\n', '        \n', '        \n', '        _ceilInt = _ceilPercent.mul(_baseCheckInt).div(_ceilDivisor.mul(100));\n', '        _expectedInt = baseFeePercent.mul(_baseCheckInt).div(baseFeeDivisor.mul(100));\n', '        _actualInt = _pledgedFeePercent.mul(_baseCheckInt).div(_pledgedFeeDivisor.mul(100));\n', '        \n', '        require(_actualInt >= _expectedInt, "Pledged Fee Should be more than base fee ");\n', '        require(_actualInt < _ceilInt, "Pledged Fee Should be less than 100%");\n', '        \n', '        initiatedProduct[_id]._id = _id;\n', '        initiatedProduct[_id]._priceInWei = _priceInWei;\n', '        initiatedProduct[_id]._ownerAddress = msg.sender;\n', '        initiatedProduct[_id]._pledgedFeePercent = _pledgedFeePercent;\n', '        initiatedProduct[_id]._pledgedFeeDivisor = _pledgedFeeDivisor;\n', '        initiatedProduct[_id]._paymentMode = _paymentMode;\n', '        \n', '        emit ProductInfoUpdated( _id,\n', '         _priceInWei,\n', '         msg.sender,\n', '         _pledgedFeePercent,\n', '         _pledgedFeeDivisor,\n', '         _paymentMode);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    \n', '    \n', '    function purchaseProductViaETH(\n', '        string memory _internalTxId,\n', '        string memory _productId,\n', '        bool _isReferredBuyer\n', '    ) public payable returns (bool){\n', '        \n', '        require(initiatedProductTx[_internalTxId]._ownerAddress == address(0x0),"Transaction already processed");\n', '        \n', '        /* Msg Value  */\n', '        uint256 _depositedAmt = msg.value;\n', '  \n', '        uint256 _baseRecievableAmt = 0;\n', '        uint256 _baseFeeAmt = 0;\n', '        \n', '        uint256 _adminFeeAmt = 0;\n', '        uint256 _referralFeeAmt = 0;\n', '        \n', '   \n', '        \n', '        \n', '        initiatedProductTx[_internalTxId]._txId = _internalTxId; \n', '        initiatedProductTx[_internalTxId]._id = _productId; \n', '        initiatedProductTx[_internalTxId]._paymentMode = 1; // Via Ether\n', '        initiatedProductTx[_internalTxId]._pledgedFeePercent = initiatedProduct[_productId]._pledgedFeePercent; \n', '        initiatedProductTx[_internalTxId]._pledgedFeeDivisor = initiatedProduct[_productId]._pledgedFeeDivisor; \n', '        initiatedProductTx[_internalTxId]._ownerAddress = initiatedProduct[_productId]._ownerAddress; \n', '        \n', '        \n', '        // Owner Address should not be equal to zero \n', '        require(initiatedProduct[_productId]._ownerAddress != address(0x0),"Product does not exists");\n', '        \n', '        \n', '        // Amount should be equal to product price , return any extra amount to sender \n', '        \n', '        require(initiatedProduct[_productId]._priceInWei == _depositedAmt, "Exact Product Price should be provided");\n', '        \n', '        \n', '        // Get Base Receivable and Fee Amount \n', '        \n', '        // Get Product Pledged Fee\n', '        _baseFeeAmt = initiatedProduct[_productId]._pledgedFeePercent.mul(_depositedAmt).div(initiatedProduct[_productId]._pledgedFeeDivisor.mul(100));\n', '        _baseRecievableAmt = _depositedAmt.sub(_baseFeeAmt);\n', '        \n', '        // Update Base Amounts\n', '        initiatedProductTx[_internalTxId]._depositedAmt = _depositedAmt;\n', '        initiatedProductTx[_internalTxId]._receivableAmt = _baseRecievableAmt;\n', '        initiatedProductTx[_internalTxId]._feeAmt = _baseFeeAmt;\n', '        \n', '        \n', '        \n', '        \n', '\n', '        if (transactionChargeDivisor > 0 && transactionChargePercent > 0) {\n', '            /* Calculate Transaction Fee */\n', '            \n', '            _adminFeeAmt = transactionChargePercent.mul(_baseFeeAmt).div(\n', '                transactionChargeDivisor.mul(100)\n', '            );\n', '         \n', '        }\n', '\n', '        /* Debit Referral Commision Fee if set */\n', '        if(referralCommissionChargeDivisor > 0 &&\n', '            referralCommissionChargePercent > 0){\n', '            _referralFeeAmt = referralCommissionChargePercent\n', '                .mul(_baseFeeAmt)\n', '                .div(referralCommissionChargeDivisor.mul(100));\n', '            }\n', '\n', '        if (\n', '            _isReferredBuyer == false\n', '        ) {\n', '            /* Calculate Referral Commision Fee */            \n', '            _adminFeeAmt = _adminFeeAmt.add(_referralFeeAmt);            \n', '        }\n', '\n', '        /* Send Transaction Receiver their share */\n', '        if (_adminFeeAmt > 0) {\n', '            transactionChargeReceiver.transfer(_adminFeeAmt);\n', '        }\n', '\n', '        /* Send Referral Receiver their share */\n', '        if (_referralFeeAmt > 0) {\n', '            referralChargeReceiver.transfer(_referralFeeAmt);\n', '        }\n', '        \n', '        \n', '        /* Transfer Leftover amount to product owner */\n', '        initiatedProduct[_productId]._ownerAddress.transfer(_baseRecievableAmt);\n', '\n', '      \n', '        emit TransactionCompleted(\n', '            initiatedProductTx[_internalTxId]._txId\n', '        );\n', '        \n', '        return true;\n', '    }\n', '\n', '    \n', '}']