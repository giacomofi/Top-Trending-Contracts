['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-06\n', '*/\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', 'contract BDSCITransferableTrustFundAccount {\n', '    address owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function withdrawAll() public {\n', '        require(owner == msg.sender);\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    function withdrawAmount(uint256 amount) public {\n', '        require(owner == msg.sender);\n', '        require(address(this).balance >= amount);\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function() external payable {}\n', '\n', '    function transferAccount(address newAccount) public {\n', '    require(owner == msg.sender);\n', '    require(newAccount != address(0));\n', '    owner = newAccount;\n', '    }\n', '\n', '    function terminateAccount() public {\n', '    require(owner == msg.sender);\n', '    selfdestruct(msg.sender);\n', '    }\n', '}\n', '\n', 'contract BDSCIAssetTokenized{\n', 'uint public supply;\n', 'uint public pricePerEth;\n', 'mapping( address => uint ) public balance;\n', '\n', 'constructor() public {\n', '    supply = 1000000000000;                    // There are a total of 1000 tokens for this asset\n', '    pricePerEth = 100000000000000000; // One token costs 0.1 ether\n', '  }\n', '\n', '  function check() public view returns(uint) {\n', '    return balance[msg.sender];\n', '  }\n', '\n', '  function () external payable {\n', '    balance[msg.sender] += msg.value/pricePerEth; // adds asset tokens to how much ether is sent by the investor\n', '    supply -= msg.value/pricePerEth;              //subtracts the remaining asset tokens from the total supply\n', '  }\n', '}\n', '\n', 'contract CoreInterface {\n', '\n', '    /* Module manipulation events */\n', '\n', '    event ModuleAdded(string name, address indexed module);\n', '\n', '    event ModuleRemoved(string name, address indexed module);\n', '\n', '    event ModuleReplaced(string name, address indexed from, address indexed to);\n', '\n', '\n', '    /* Functions */\n', '\n', '    function set(string memory  _name, address _module, bool _constant) public;\n', '\n', '    function setMetadata(string memory _name, string  memory _description) public;\n', '\n', '    function remove(string memory _name) public;\n', '    \n', '    function contains(address _module)  public view returns (bool);\n', '\n', '    function size() public view returns (uint);\n', '\n', '    function isConstant(string memory _name) public view returns (bool);\n', '\n', '    function get(string memory _name)  public view returns (address);\n', '\n', '    function getName(address _module)  public view returns (string memory);\n', '\n', '    function first() public view returns (address);\n', '\n', '    function next(address _current)  public view returns (address);\n', '}\n', '\n', 'library ISQRT {\n', '\n', '    /**\n', '     * @notice Calculate Square Root\n', '     * @param n Operand of sqrt() function\n', '     * @return greatest integer less than or equal to the square root of n\n', '     */\n', '    function sqrt(uint256 n) internal pure returns(uint256){\n', '        return sqrtBabylonian(n);\n', '    }\n', '\n', '    /**\n', '     * Based on Martin Guy implementation\n', '     * http://freaknet.org/martin/tape/gos/misc/personal/msc/sqrt/sqrt.c\n', '     */\n', '    function isqrtBitByBit(uint256 x) internal pure returns (uint256){\n', '        uint256 op = x;\n', '        uint256 res = 0;\n', '        /* "one" starts at the highest power of four <= than the argument. */\n', '        uint256 one = 1 << 254; /* second-to-top bit set */\n', '        while (one > op) {\n', '            one = one >> 2;\n', '        }\n', '        while (one != 0) {\n', '            if (op >= res + one) {\n', '                op = op - (res + one);\n', '                res = res + (one << 1);\n', '            }\n', '            res = res >> 1;\n', '            one = one >> 2;\n', '        }\n', '        return res;\n', '    }\n', '\n', '    /**\n', '     * Babylonian method implemented in dapp-bin library\n', '     * https://github.com/ethereum/dapp-bin/pull/50\n', '     */\n', '    function sqrtBabylonian(uint256 x) internal pure returns (uint256) {\n', '        // x == MAX_UINT256 makes this method fail, so in this case return value calculated separately\n', '        if (x == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '        uint256 z = (x + 1) / 2;\n', '        uint256 y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2; //No overflow possible here, because greatest possible z = MAX_UINT256/2\n', '        }\n', '        return y;\n', '    }\n', '}']