['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// Verified using https://dapp.tools\n', '\n', '// hevm: flattened sources of src/borrower/collect/collector.sol\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity >=0.5.15 >=0.6.12;\n', '\n', '////// lib/tinlake-auth/src/auth.sol\n', '// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\n', '/* pragma solidity >=0.5.15; */\n', '\n', 'contract Auth {\n', '    mapping (address => uint256) public wards;\n', '    \n', '    event Rely(address indexed usr);\n', '    event Deny(address indexed usr);\n', '\n', '    function rely(address usr) external auth {\n', '        wards[usr] = 1;\n', '        emit Rely(usr);\n', '    }\n', '    function deny(address usr) external auth {\n', '        wards[usr] = 0;\n', '        emit Deny(usr);\n', '    }\n', '\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "not-authorized");\n', '        _;\n', '    }\n', '\n', '}\n', '\n', '////// src/borrower/collect/collector.sol\n', '/* pragma solidity >=0.6.12; */\n', '\n', '/* import "tinlake-auth/auth.sol"; */\n', '\n', 'interface NFTLike_1 {\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '}\n', '\n', 'interface ReserveLike_1 {\n', '    function balance() external;\n', '}\n', '\n', 'interface ThresholdRegistryLike {\n', '    function threshold(uint) external view returns (uint);\n', '}\n', '\n', 'interface PileLike_1 {\n', '    function debt(uint) external returns (uint);\n', '}\n', '\n', 'interface ShelfLike_1 {\n', '    function claim(uint, address) external;\n', '    function token(uint loan) external returns (address, uint);\n', '    function recover(uint loan, address usr, uint wad) external;\n', '}\n', '\n', 'contract Collector is Auth {\n', '\n', '     // -- Collectors --\n', '    mapping (address => uint) public collectors;\n', '    function relyCollector(address usr) public auth { collectors[usr] = 1; emit RelyCollector(usr); }\n', '    function denyCollector(address usr) public auth { collectors[usr] = 0; emit DenyCollector(usr); }\n', '    modifier auth_collector { require(collectors[msg.sender] == 1); _; }\n', '\n', '    // --- Data ---\n', '    ThresholdRegistryLike threshold;\n', '\n', '    struct Option {\n', '        address buyer;\n', '        uint    nftPrice;\n', '    }\n', '\n', '    mapping (uint => Option) public options;\n', '\n', '    ReserveLike_1 reserve;\n', '    ShelfLike_1 shelf;\n', '    PileLike_1 pile;\n', '\n', '    event Collect(uint indexed loan, address indexed buyer);\n', '    event RelyCollector(address indexed usr);\n', '    event DenyCollector(address indexed usr);\n', '    event Depend(bytes32 indexed contractName, address addr);\n', '    event File(bytes32 indexed what, uint indexed loan, address buyer, uint nftPrice);\n', '\n', '    constructor (address shelf_, address pile_, address threshold_) {\n', '        shelf = ShelfLike_1(shelf_);\n', '        pile = PileLike_1(pile_);\n', '        threshold = ThresholdRegistryLike(threshold_);\n', '        wards[msg.sender] = 1;\n', '        emit Rely(msg.sender);\n', '    }\n', '\n', '    // sets the dependency to another contract\n', '    function depend(bytes32 contractName, address addr) external auth {\n', '        if (contractName == "reserve") reserve = ReserveLike_1(addr);\n', '        else if (contractName == "shelf") shelf = ShelfLike_1(addr);\n', '        else if (contractName == "pile") pile = PileLike_1(addr);\n', '        else if (contractName == "threshold") threshold = ThresholdRegistryLike(addr);\n', '        else revert();\n', '        emit Depend(contractName, addr);\n', '    }\n', '\n', '    // sets the liquidation-price of an NFT\n', '    function file(bytes32 what, uint loan, address buyer, uint nftPrice) external auth {\n', '        if (what == "loan") {\n', '            require(nftPrice > 0, "no-nft-price-defined");\n', '            options[loan] = Option(buyer, nftPrice);\n', '        } else revert("unknown parameter");\n', '        emit File(what, loan, buyer, nftPrice);\n', '    }\n', '\n', '\n', '    // if the loan debt is above the loan threshold the NFT should be seized,\n', '    // i.e. taken away from the borrower to be sold off at a later stage.\n', '    // therefore the ownership of the nft is transferred to the collector\n', '    function seize(uint loan) external {\n', '        uint debt = pile.debt(loan);\n', '        require((threshold.threshold(loan) <= debt), "threshold-not-reached");\n', '        shelf.claim(loan, address(this));\n', '    }\n', '\n', '\n', '    // a nft can be collected if the collector is the nft- owner\n', '    // The NFT needs to be `seized` first to transfer ownership to the collector.\n', '    // and then seized by the collector\n', '    function collect(uint loan) external auth_collector {\n', '        _collect(loan, msg.sender);\n', '    }\n', '\n', '    function collect(uint loan, address buyer) external auth {\n', '        _collect(loan, buyer);\n', '    }\n', '\n', '    function _collect(uint loan, address buyer) internal {\n', '        require(buyer == options[loan].buyer || options[loan].buyer == address(0), "not-allowed-to-collect");\n', '        (address registry, uint nft) = shelf.token(loan);\n', '        require(options[loan].nftPrice > 0, "no-nft-price-defined");\n', '        shelf.recover(loan, buyer, options[loan].nftPrice);\n', '        NFTLike_1(registry).transferFrom(address(this), buyer, nft);\n', '        reserve.balance();\n', '        emit Collect(loan, buyer);\n', '    }\n', '}']