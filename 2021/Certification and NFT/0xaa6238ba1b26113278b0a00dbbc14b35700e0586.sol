['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-14\n', '*/\n', '\n', '// File: contracts\\lib\\TransferHelper.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.8.6;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// File: contracts\\interface\\INestMining.sol\n', '\n', '/// @dev This interface defines the mining methods for nest\n', 'interface INestMining {\n', '    \n', '    /// @dev Post event\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param miner Address of miner\n', '    /// @param index Index of the price sheet\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    event Post(address tokenAddress, address miner, uint index, uint ethNum, uint price);\n', '\n', '    /* ========== Structures ========== */\n', '    \n', '    /// @dev Nest mining configuration structure\n', '    struct Config {\n', '        \n', '        // Eth number of each post. 30\n', '        // We can stop post and taking orders by set postEthUnit to 0 (closing and withdraw are not affected)\n', '        uint32 postEthUnit;\n', '\n', '        // Post fee(0.0001eth，DIMI_ETHER). 1000\n', '        uint16 postFeeUnit;\n', '\n', '        // Proportion of miners digging(10000 based). 8000\n', '        uint16 minerNestReward;\n', '        \n', '        // The proportion of token dug by miners is only valid for the token created in version 3.0\n', '        // (10000 based). 9500\n', '        uint16 minerNTokenReward;\n', '\n', '        // When the circulation of ntoken exceeds this threshold, post() is prohibited(Unit: 10000 ether). 500\n', '        uint32 doublePostThreshold;\n', '        \n', '        // The limit of ntoken mined blocks. 100\n', '        uint16 ntokenMinedBlockLimit;\n', '\n', '        // -- Public configuration\n', '        // The number of times the sheet assets have doubled. 4\n', '        uint8 maxBiteNestedLevel;\n', '        \n', '        // Price effective block interval. 20\n', '        uint16 priceEffectSpan;\n', '\n', '        // The amount of nest to pledge for each post（Unit: 1000). 100\n', '        uint16 pledgeNest;\n', '    }\n', '\n', '    /// @dev PriceSheetView structure\n', '    struct PriceSheetView {\n', '        \n', '        // Index of the price sheeet\n', '        uint32 index;\n', '\n', '        // Address of miner\n', '        address miner;\n', '\n', '        // The block number of this price sheet packaged\n', '        uint32 height;\n', '\n', '        // The remain number of this price sheet\n', '        uint32 remainNum;\n', '\n', '        // The eth number which miner will got\n', '        uint32 ethNumBal;\n', '\n', "        // The eth number which equivalent to token's value which miner will got\n", '        uint32 tokenNumBal;\n', '\n', '        // The pledged number of nest in this sheet. (Unit: 1000nest)\n', '        uint24 nestNum1k;\n', '\n', '        // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\n', '        uint8 level;\n', '\n', '        // Post fee shares, if there are many sheets in one block, this value is used to divide up mining value\n', '        uint8 shares;\n', '\n', '        // The token price. (1eth equivalent to (price) token)\n', '        uint152 price;\n', '    }\n', '\n', '    /* ========== Configuration ========== */\n', '\n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config calldata config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Set the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @param ntokenAddress The ntoken address\n', '    function setNTokenAddress(address tokenAddress, address ntokenAddress) external;\n', '\n', '    /// @dev Get the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @return The ntoken address\n', '    function getNTokenAddress(address tokenAddress) external view returns (address);\n', '\n', '    /* ========== Mining ========== */\n', '\n', '    /// @notice Post a price sheet for TOKEN\n', '    /// @dev It is for TOKEN (except USDT and NTOKENs) whose NTOKEN has a total supply below a threshold (e.g. 5,000,000 * 1e18)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    function post(address tokenAddress, uint ethNum, uint tokenAmountPerEth) external payable;\n', '\n', '    /// @notice Post two price sheets for a token and its ntoken simultaneously \n', '    /// @dev Support dual-posts for TOKEN/NTOKEN, (ETH, TOKEN) + (ETH, NTOKEN)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    /// @param ntokenAmountPerEth The price of NTOKEN\n', '    function post2(address tokenAddress, uint ethNum, uint tokenAmountPerEth, uint ntokenAmountPerEth) external payable;\n', '\n', '    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n', '    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum * newTokenAmountPerEth\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeToken(address tokenAddress, uint index, uint takeNum, uint newTokenAmountPerEth) external payable;\n', '\n', '    /// @notice Call the function to buy ETH from a posted price sheet\n', '    /// @dev bite ETH by TOKEN(NTOKEN),  (-ethNumBal, +tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeEth(address tokenAddress, uint index, uint takeNum, uint newTokenAmountPerEth) external payable;\n', '    \n', '    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\n', '    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed \n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param index The index of the price sheet w.r.t. `token`\n', '    function close(address tokenAddress, uint index) external;\n', '\n', '    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param indices A list of indices of sheets w.r.t. `token`\n', '    function closeList(address tokenAddress, uint[] memory indices) external;\n', '\n', '    /// @notice Close two batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN1 contract\n', '    /// @param tokenIndices A list of indices of sheets w.r.t. `token`\n', '    /// @param ntokenIndices A list of indices of sheets w.r.t. `ntoken`\n', '    function closeList2(address tokenAddress, uint[] memory tokenIndices, uint[] memory ntokenIndices) external;\n', '\n', '    /// @dev The function updates the statistics of price sheets\n', '    ///     It calculates from priceInfo to the newest that is effective.\n', '    function stat(address tokenAddress) external;\n', '\n', '    /// @dev Settlement Commission\n', '    /// @param tokenAddress The token address\n', '    function settle(address tokenAddress) external;\n', '\n', '    /// @dev List sheets by page\n', '    /// @param tokenAddress Destination token address\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return List of price sheets\n', '    function list(address tokenAddress, uint offset, uint count, uint order) external view returns (PriceSheetView[] memory);\n', '\n', '    /// @dev Estimated mining amount\n', '    /// @param tokenAddress Destination token address\n', '    /// @return Estimated mining amount\n', '    function estimate(address tokenAddress) external view returns (uint);\n', '\n', '    /// @dev Query the quantity of the target quotation\n', "    /// @param tokenAddress Token address. The token can't mine. Please make sure you don't use the token address when calling\n", '    /// @param index The index of the sheet\n', '    /// @return minedBlocks Mined block period from previous block\n', '    /// @return totalShares Total shares of sheets in the block\n', '    function getMinedBlocks(address tokenAddress, uint index) external view returns (uint minedBlocks, uint totalShares);\n', '\n', '    /* ========== Accounts ========== */\n', '\n', '    /// @dev Withdraw assets\n', '    /// @param tokenAddress Destination token address\n', '    /// @param value The value to withdraw\n', '    function withdraw(address tokenAddress, uint value) external;\n', '\n', '    /// @dev View the number of assets specified by the user\n', '    /// @param tokenAddress Destination token address\n', '    /// @param addr Destination address\n', '    /// @return Number of assets\n', '    function balanceOf(address tokenAddress, address addr) external view returns (uint);\n', '\n', '    /// @dev Gets the address corresponding to the given index number\n', '    /// @param index The index number of the specified address\n', '    /// @return The address corresponding to the given index number\n', '    function indexAddress(uint index) external view returns (address);\n', '    \n', '    /// @dev Gets the registration index number of the specified address\n', '    /// @param addr Destination address\n', '    /// @return 0 means nonexistent, non-0 means index number\n', '    function getAccountIndex(address addr) external view returns (uint);\n', '\n', '    /// @dev Get the length of registered account array\n', '    /// @return The length of registered account array\n', '    function getAccountCount() external view returns (uint);\n', '}\n', '\n', '// File: contracts\\interface\\INestQuery.sol\n', '\n', '/// @dev This interface defines the methods for price query\n', 'interface INestQuery {\n', '    \n', '    /// @dev Get the latest trigger price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function triggeredPrice(address tokenAddress) external view returns (uint blockNumber, uint price);\n', '\n', '    /// @dev Get the full information of latest trigger price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo(address tokenAddress) external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint avgPrice,\n', '        uint sigmaSQ\n', '    );\n', '\n', '    /// @dev Find the price at block number\n', '    /// @param tokenAddress Destination token address\n', '    /// @param height Destination block number\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function findPrice(\n', '        address tokenAddress,\n', '        uint height\n', '    ) external view returns (uint blockNumber, uint price);\n', '\n', '    /// @dev Get the latest effective price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function latestPrice(address tokenAddress) external view returns (uint blockNumber, uint price);\n', '\n', '    /// @dev Get the last (num) effective price\n', '    /// @param tokenAddress Destination token address\n', '    /// @param count The number of prices that want to return\n', '    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\n', '    function lastPriceList(address tokenAddress, uint count) external view returns (uint[] memory);\n', '\n', '    /// @dev Returns the results of latestPrice() and triggeredPriceInfo()\n', '    /// @param tokenAddress Destination token address\n', '    /// @return latestPriceBlockNumber The block number of latest price\n', '    /// @return latestPriceValue The token latest price. (1eth equivalent to (price) token)\n', '    /// @return triggeredPriceBlockNumber The block number of triggered price\n', '    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\n', '    /// @return triggeredAvgPrice Average price\n', '    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function latestPriceAndTriggeredPriceInfo(address tokenAddress) external view \n', '    returns (\n', '        uint latestPriceBlockNumber,\n', '        uint latestPriceValue,\n', '        uint triggeredPriceBlockNumber,\n', '        uint triggeredPriceValue,\n', '        uint triggeredAvgPrice,\n', '        uint triggeredSigmaSQ\n', '    );\n', '\n', '    /// @dev Returns lastPriceList and triggered price info\n', '    /// @param tokenAddress Destination token address\n', '    /// @param count The number of prices that want to return\n', '    /// @return prices An array which length is num * 2, each two element expresses one price like blockNumber｜price\n', '    /// @return triggeredPriceBlockNumber The block number of triggered price\n', '    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\n', '    /// @return triggeredAvgPrice Average price\n', '    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function lastPriceListAndTriggeredPriceInfo(address tokenAddress, uint count) external view \n', '    returns (\n', '        uint[] memory prices,\n', '        uint triggeredPriceBlockNumber,\n', '        uint triggeredPriceValue,\n', '        uint triggeredAvgPrice,\n', '        uint triggeredSigmaSQ\n', '    );\n', '\n', '    /// @dev Get the latest trigger price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    function triggeredPrice2(address tokenAddress) external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice\n', '    );\n', '\n', '    /// @dev Get the full information of latest trigger price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447, \n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    /// @return ntokenAvgPrice Average price of ntoken\n', '    /// @return ntokenSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that\n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo2(address tokenAddress) external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint avgPrice,\n', '        uint sigmaSQ,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice,\n', '        uint ntokenAvgPrice,\n', '        uint ntokenSigmaSQ\n', '    );\n', '\n', '    /// @dev Get the latest effective price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    function latestPrice2(address tokenAddress) external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice\n', '    );\n', '}\n', '\n', '// File: contracts\\interface\\INTokenController.sol\n', '\n', '///@dev This interface defines the methods for ntoken management\n', 'interface INTokenController {\n', '    \n', '    /// @notice when the auction of a token gets started\n', '    /// @param tokenAddress The address of the (ERC20) token\n', '    /// @param ntokenAddress The address of the ntoken w.r.t. token for incentives\n', '    /// @param owner The address of miner who opened the oracle\n', '    event NTokenOpened(address tokenAddress, address ntokenAddress, address owner);\n', '    \n', '    /// @notice ntoken disable event\n', '    /// @param tokenAddress token address\n', '    event NTokenDisabled(address tokenAddress);\n', '    \n', '    /// @notice ntoken enable event\n', '    /// @param tokenAddress token address\n', '    event NTokenEnabled(address tokenAddress);\n', '\n', '    /// @dev ntoken configuration structure\n', '    struct Config {\n', '\n', '        // The number of nest needed to pay for opening ntoken. 10000 ether\n', '        uint96 openFeeNestAmount;\n', '\n', '        // ntoken management is enabled. 0: not enabled, 1: enabled\n', '        uint8 state;\n', '    }\n', '\n', '    /// @dev A struct for an ntoken\n', '    struct NTokenTag {\n', '\n', '        // ntoken address\n', '        address ntokenAddress;\n', '\n', '        // How much nest has paid for open this ntoken\n', '        uint96 nestFee;\n', '    \n', '        // token address\n', '        address tokenAddress;\n', '\n', '        // Index for this ntoken\n', '        uint40 index;\n', '\n', '        // Create time\n', '        uint48 startTime;\n', '\n', '        // State of this ntoken. 0: disabled; 1 normal\n', '        uint8 state;\n', '    }\n', '\n', '    /* ========== Governance ========== */\n', '\n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config calldata config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Set the token mapping\n', '    /// @param tokenAddress Destination token address\n', '    /// @param ntokenAddress Destination ntoken address\n', '    /// @param state status for this map\n', '    function setNTokenMapping(address tokenAddress, address ntokenAddress, uint state) external;\n', '\n', '    /// @dev Get token address from ntoken address\n', '    /// @param ntokenAddress Destination ntoken address\n', '    /// @return token address\n', '    function getTokenAddress(address ntokenAddress) external view returns (address);\n', '\n', '    /// @dev Get ntoken address from token address\n', '    /// @param tokenAddress Destination token address\n', '    /// @return ntoken address\n', '    function getNTokenAddress(address tokenAddress) external view returns (address);\n', '\n', '    /* ========== ntoken management ========== */\n', '    \n', '    /// @dev Bad tokens should be banned \n', '    function disable(address tokenAddress) external;\n', '\n', '    /// @dev enable ntoken\n', '    function enable(address tokenAddress) external;\n', '\n', "    /// @notice Open a NToken for a token by anyone (contracts aren't allowed)\n", '    /// @dev Create and map the (Token, NToken) pair in NestPool\n', '    /// @param tokenAddress The address of token contract\n', '    function open(address tokenAddress) external;\n', '\n', '    /* ========== VIEWS ========== */\n', '\n', '    /// @dev Get ntoken information\n', '    /// @param tokenAddress Destination token address\n', '    /// @return ntoken information\n', '    function getNTokenTag(address tokenAddress) external view returns (NTokenTag memory);\n', '\n', '    /// @dev Get opened ntoken count\n', '    /// @return ntoken count\n', '    function getNTokenCount() external view returns (uint);\n', '\n', '    /// @dev List ntoken information by page\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return ntoken information by page\n', '    function list(uint offset, uint count, uint order) external view returns (NTokenTag[] memory);\n', '}\n', '\n', '// File: contracts\\interface\\INestLedger.sol\n', '\n', '/// @dev This interface defines the nest ledger methods\n', 'interface INestLedger {\n', '\n', '    /// @dev Application Flag Changed event\n', '    /// @param addr DAO application contract address\n', '    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    event ApplicationChanged(address addr, uint flag);\n', '    \n', '    /// @dev Configuration structure of nest ledger contract\n', '    struct Config {\n', '        \n', '        // nest reward scale(10000 based). 2000\n', '        uint16 nestRewardScale;\n', '\n', '        // // ntoken reward scale(10000 based). 8000\n', '        // uint16 ntokenRewardScale;\n', '    }\n', '    \n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config calldata config) external;\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Set DAO application\n', '    /// @param addr DAO application contract address\n', '    /// @param flag Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    function setApplication(address addr, uint flag) external;\n', '\n', '    /// @dev Check DAO application flag\n', '    /// @param addr DAO application contract address\n', '    /// @return Authorization flag, 1 means authorization, 0 means cancel authorization\n', '    function checkApplication(address addr) external view returns (uint);\n', '\n', '    /// @dev Carve reward\n', '    /// @param ntokenAddress Destination ntoken address\n', '    function carveETHReward(address ntokenAddress) external payable;\n', '\n', '    /// @dev Add reward\n', '    /// @param ntokenAddress Destination ntoken address\n', '    function addETHReward(address ntokenAddress) external payable;\n', '\n', '    /// @dev The function returns eth rewards of specified ntoken\n', '    /// @param ntokenAddress The ntoken address\n', '    function totalETHRewards(address ntokenAddress) external view returns (uint);\n', '\n', '    /// @dev Pay\n', '    /// @param ntokenAddress Destination ntoken address. Indicates which ntoken to pay with\n', '    /// @param tokenAddress Token address of receiving funds (0 means ETH)\n', '    /// @param to Address to receive\n', '    /// @param value Amount to receive\n', '    function pay(address ntokenAddress, address tokenAddress, address to, uint value) external;\n', '\n', '    /// @dev Settlement\n', '    /// @param ntokenAddress Destination ntoken address. Indicates which ntoken to settle with\n', '    /// @param tokenAddress Token address of receiving funds (0 means ETH)\n', '    /// @param to Address to receive\n', '    /// @param value Amount to receive\n', '    function settle(address ntokenAddress, address tokenAddress, address to, uint value) external payable;\n', '}\n', '\n', '// File: contracts\\interface\\INToken.sol\n', '\n', '/// @dev ntoken interface\n', 'interface INToken {\n', '        \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @dev Mint \n', '    /// @param value The amount of NToken to add\n', '    function increaseTotal(uint256 value) external;\n', '\n', '    /// @notice The view of variables about minting \n', '    /// @dev The naming follows Nestv3.0\n', '    /// @return createBlock The block number where the contract was created\n', '    /// @return recentlyUsedBlock The block number where the last minting went\n', '    function checkBlockInfo() external view returns(uint256 createBlock, uint256 recentlyUsedBlock);\n', '\n', '    /// @dev The ABI keeps unchanged with old NTokens, so as to support token-and-ntoken-mining\n', '    /// @return The address of bidder\n', '    function checkBidder() external view returns(address);\n', '    \n', '    /// @notice The view of totalSupply\n', '    /// @return The total supply of ntoken\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /// @dev The view of balances\n', '    /// @param owner The address of an account\n', '    /// @return The balance of the account\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256); \n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', '// File: contracts\\interface\\INestMapping.sol\n', '\n', '/// @dev The interface defines methods for nest builtin contract address mapping\n', 'interface INestMapping {\n', '\n', '    /// @dev Set the built-in contract address of the system\n', '    /// @param nestTokenAddress Address of nest token contract\n', '    /// @param nestNodeAddress Address of nest node contract\n', '    /// @param nestLedgerAddress INestLedger implementation contract address\n', '    /// @param nestMiningAddress INestMining implementation contract address for nest\n', '    /// @param ntokenMiningAddress INestMining implementation contract address for ntoken\n', '    /// @param nestPriceFacadeAddress INestPriceFacade implementation contract address\n', '    /// @param nestVoteAddress INestVote implementation contract address\n', '    /// @param nestQueryAddress INestQuery implementation contract address\n', '    /// @param nnIncomeAddress NNIncome contract address\n', '    /// @param nTokenControllerAddress INTokenController implementation contract address\n', '    function setBuiltinAddress(\n', '        address nestTokenAddress,\n', '        address nestNodeAddress,\n', '        address nestLedgerAddress,\n', '        address nestMiningAddress,\n', '        address ntokenMiningAddress,\n', '        address nestPriceFacadeAddress,\n', '        address nestVoteAddress,\n', '        address nestQueryAddress,\n', '        address nnIncomeAddress,\n', '        address nTokenControllerAddress\n', '    ) external;\n', '\n', '    /// @dev Get the built-in contract address of the system\n', '    /// @return nestTokenAddress Address of nest token contract\n', '    /// @return nestNodeAddress Address of nest node contract\n', '    /// @return nestLedgerAddress INestLedger implementation contract address\n', '    /// @return nestMiningAddress INestMining implementation contract address for nest\n', '    /// @return ntokenMiningAddress INestMining implementation contract address for ntoken\n', '    /// @return nestPriceFacadeAddress INestPriceFacade implementation contract address\n', '    /// @return nestVoteAddress INestVote implementation contract address\n', '    /// @return nestQueryAddress INestQuery implementation contract address\n', '    /// @return nnIncomeAddress NNIncome contract address\n', '    /// @return nTokenControllerAddress INTokenController implementation contract address\n', '    function getBuiltinAddress() external view returns (\n', '        address nestTokenAddress,\n', '        address nestNodeAddress,\n', '        address nestLedgerAddress,\n', '        address nestMiningAddress,\n', '        address ntokenMiningAddress,\n', '        address nestPriceFacadeAddress,\n', '        address nestVoteAddress,\n', '        address nestQueryAddress,\n', '        address nnIncomeAddress,\n', '        address nTokenControllerAddress\n', '    );\n', '\n', '    /// @dev Get address of nest token contract\n', '    /// @return Address of nest token contract\n', '    function getNestTokenAddress() external view returns (address);\n', '\n', '    /// @dev Get address of nest node contract\n', '    /// @return Address of nest node contract\n', '    function getNestNodeAddress() external view returns (address);\n', '\n', '    /// @dev Get INestLedger implementation contract address\n', '    /// @return INestLedger implementation contract address\n', '    function getNestLedgerAddress() external view returns (address);\n', '\n', '    /// @dev Get INestMining implementation contract address for nest\n', '    /// @return INestMining implementation contract address for nest\n', '    function getNestMiningAddress() external view returns (address);\n', '\n', '    /// @dev Get INestMining implementation contract address for ntoken\n', '    /// @return INestMining implementation contract address for ntoken\n', '    function getNTokenMiningAddress() external view returns (address);\n', '\n', '    /// @dev Get INestPriceFacade implementation contract address\n', '    /// @return INestPriceFacade implementation contract address\n', '    function getNestPriceFacadeAddress() external view returns (address);\n', '\n', '    /// @dev Get INestVote implementation contract address\n', '    /// @return INestVote implementation contract address\n', '    function getNestVoteAddress() external view returns (address);\n', '\n', '    /// @dev Get INestQuery implementation contract address\n', '    /// @return INestQuery implementation contract address\n', '    function getNestQueryAddress() external view returns (address);\n', '\n', '    /// @dev Get NNIncome contract address\n', '    /// @return NNIncome contract address\n', '    function getNnIncomeAddress() external view returns (address);\n', '\n', '    /// @dev Get INTokenController implementation contract address\n', '    /// @return INTokenController implementation contract address\n', '    function getNTokenControllerAddress() external view returns (address);\n', '\n', '    /// @dev Registered address. The address registered here is the address accepted by nest system\n', '    /// @param key The key\n', '    /// @param addr Destination address. 0 means to delete the registration information\n', '    function registerAddress(string memory key, address addr) external;\n', '\n', '    /// @dev Get registered address\n', '    /// @param key The key\n', '    /// @return Destination address. 0 means empty\n', '    function checkAddress(string memory key) external view returns (address);\n', '}\n', '\n', '// File: contracts\\interface\\INestGovernance.sol\n', '\n', '/// @dev This interface defines the governance methods\n', 'interface INestGovernance is INestMapping {\n', '\n', '    /// @dev Set governance authority\n', '    /// @param addr Destination address\n', '    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \n', '    ///        implemented in the current system, only the difference between authorized and unauthorized. \n', '    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\n', '    function setGovernance(address addr, uint flag) external;\n', '\n', '    /// @dev Get governance rights\n', '    /// @param addr Destination address\n', '    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \n', '    ///        implemented in the current system, only the difference between authorized and unauthorized. \n', '    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\n', '    function getGovernance(address addr) external view returns (uint);\n', '\n', '    /// @dev Check whether the target address has governance rights for the given target\n', '    /// @param addr Destination address\n', '    /// @param flag Permission weight. The permission of the target address must be greater than this weight to pass the check\n', '    /// @return True indicates permission\n', '    function checkGovernance(address addr, uint flag) external view returns (bool);\n', '}\n', '\n', '// File: contracts\\NestBase.sol\n', '\n', '/// @dev Base contract of nest\n', 'contract NestBase {\n', '\n', '    // Address of nest token contract\n', '    address constant NEST_TOKEN_ADDRESS = 0x04abEdA201850aC0124161F037Efd70c74ddC74C;\n', '\n', '    // Genesis block number of nest\n', '    // NEST token contract is created at block height 6913517. However, because the mining algorithm of nest1.0\n', '    // is different from that at present, a new mining algorithm is adopted from nest2.0. The new algorithm\n', '    // includes the attenuation logic according to the block. Therefore, it is necessary to trace the block\n', '    // where the nest begins to decay. According to the circulation when nest2.0 is online, the new mining\n', '    // algorithm is used to deduce and convert the nest, and the new algorithm is used to mine the nest2.0\n', '    // on-line flow, the actual block is 5120000\n', '    uint constant NEST_GENESIS_BLOCK = 5120000;\n', '\n', '    /// @dev To support open-zeppelin/upgrades\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function initialize(address nestGovernanceAddress) virtual public {\n', "        require(_governance == address(0), 'NEST:!initialize');\n", '        _governance = nestGovernanceAddress;\n', '    }\n', '\n', '    /// @dev INestGovernance implementation contract address\n', '    address public _governance;\n', '\n', '    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \n', '    ///      super.update(nestGovernanceAddress) when overriding, and override method without onlyGovernance\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function update(address nestGovernanceAddress) virtual public {\n', '\n', '        address governance = _governance;\n', '        require(governance == msg.sender || INestGovernance(governance).checkGovernance(msg.sender, 0), "NEST:!gov");\n', '        _governance = nestGovernanceAddress;\n', '    }\n', '\n', '    /// @dev Migrate funds from current contract to NestLedger\n', '    /// @param tokenAddress Destination token address.(0 means eth)\n', '    /// @param value Migrate amount\n', '    function migrate(address tokenAddress, uint value) external onlyGovernance {\n', '\n', '        address to = INestGovernance(_governance).getNestLedgerAddress();\n', '        if (tokenAddress == address(0)) {\n', '            INestLedger(to).addETHReward { value: value } (address(0));\n', '        } else {\n', '            TransferHelper.safeTransfer(tokenAddress, to, value);\n', '        }\n', '    }\n', '\n', '    //---------modifier------------\n', '\n', '    modifier onlyGovernance() {\n', '        require(INestGovernance(_governance).checkGovernance(msg.sender, 0), "NEST:!gov");\n', '        _;\n', '    }\n', '\n', '    modifier noContract() {\n', '        require(msg.sender == tx.origin, "NEST:!contract");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts\\NestMining.sol\n', '\n', '/// @dev This contract implemented the mining logic of nest\n', 'contract NestMining is NestBase, INestMining, INestQuery {\n', '\n', '    // /// @param nestTokenAddress Address of nest token contract\n', '    // /// @param nestGenesisBlock Genesis block number of nest\n', '    // constructor(address nestTokenAddress, uint nestGenesisBlock) {\n', '        \n', '    //     NEST_TOKEN_ADDRESS = nestTokenAddress;\n', '    //     NEST_GENESIS_BLOCK = nestGenesisBlock;\n', '\n', '    //     // Placeholder in _accounts, the index of a real account must greater than 0\n', '    //     _accounts.push();\n', '    // }\n', '\n', '    /// @dev To support open-zeppelin/upgrades\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function initialize(address nestGovernanceAddress) override public {\n', '        super.initialize(nestGovernanceAddress);\n', '        // Placeholder in _accounts, the index of a real account must greater than 0\n', '        _accounts.push();\n', '    }\n', '\n', '    ///@dev Definitions for the price sheet, include the full information. (use 256-bits, a storage unit in ethereum evm)\n', '    struct PriceSheet {\n', '        \n', '        // Index of miner account in _accounts. for this way, mapping an address(which need 160-bits) to a 32-bits \n', '        // integer, support 4 billion accounts\n', '        uint32 miner;\n', '\n', '        // The block number of this price sheet packaged\n', '        uint32 height;\n', '\n', '        // The remain number of this price sheet\n', '        uint32 remainNum;\n', '\n', '        // The eth number which miner will got\n', '        uint32 ethNumBal;\n', '\n', "        // The eth number which equivalent to token's value which miner will got\n", '        uint32 tokenNumBal;\n', '\n', '        // The pledged number of nest in this sheet. (Unit: 1000nest)\n', '        uint24 nestNum1k;\n', '\n', '        // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\n', '        uint8 level;\n', '\n', '        // Post fee shares, if there are many sheets in one block, this value is used to divide up mining value\n', '        uint8 shares;\n', '\n', '        // Represent price as this way, may lose precision, the error less than 1/10^14\n', '        // price = priceFraction * 16 ^ priceExponent\n', '        uint56 priceFloat;\n', '    }\n', '\n', '    /// @dev Definitions for the price information\n', '    struct PriceInfo {\n', '\n', '        // Record the index of price sheet, for update price information from price sheet next time.\n', '        uint32 index;\n', '\n', '        // The block number of this price\n', '        uint32 height;\n', '\n', '        // The remain number of this price sheet\n', '        uint32 remainNum;\n', '\n', '        // Price, represent as float\n', '        // Represent price as this way, may lose precision, the error less than 1/10^14\n', '        uint56 priceFloat;\n', '\n', '        // Avg Price, represent as float\n', '        // Represent price as this way, may lose precision, the error less than 1/10^14\n', '        uint56 avgFloat;\n', '\n', '        // Square of price volatility, need divide by 2^48\n', '        uint48 sigmaSQ;\n', '    }\n', '\n', '    /// @dev Price channel\n', '    struct PriceChannel {\n', '\n', '        // Array of price sheets\n', '        PriceSheet[] sheets;\n', '\n', '        // Price information\n', '        PriceInfo price;\n', '\n', '        // Commission is charged for every post(post2), the commission should be deposited to NestLedger,\n', '        // for saving gas, according to sheets.length, every increase of 256 will deposit once, The calculation formula is:\n', '        // \n', '        // totalFee = fee * increment\n', '        // \n', '        // In consideration of takeToken, takeEth, change postFeeUnit or miner pay more fee, the formula will be invalid,\n', '        // at this point, it is need to settle immediately, the details of triggering settlement logic are as follows\n', '        // \n', '        // 1. When there is a bite transaction(currentFee is 0), the counter of no fee sheets will be increase 1\n', '        // 2. If the Commission of this time is inconsistent with that of last time, deposit immediately\n', '        // 3. When the increment of sheets.length is 256, deposit immediately\n', '        // 4. Everyone can trigger immediate settlement by manually calling the settle() method\n', '        // \n', '        // In order to realize the logic above, the following values are defined\n', '        // \n', '        // 1. PriceChannel.feeInfo\n', '        //    Low 128-bits represent last fee per post\n', '        //    High 128-bits represent the current counter of no fee sheets (including settled)\n', '        // \n', '        // 2. COLLECT_REWARD_MASK\n', '        //    The mask of batch deposit trigger, while COLLECT_REWARD_MASK & sheets.length == COLLECT_REWARD_MASK, it will trigger deposit,\n', '        //    COLLECT_REWARD_MASK is set to 0xF for testing (means every 16 sheets will deposit once), \n', '        //    and it will be set to 0xFF for mainnet (means every 256 sheets will deposit once)\n', '\n', '        // The information of mining fee\n', '        // Low 128-bits represent fee per post\n', '        // High 128-bits represent the current counter of no fee sheets (including settled)\n', '        uint feeInfo;\n', '    }\n', '\n', '    /// @dev Structure is used to represent a storage location. Storage variable can be used to avoid indexing from mapping many times\n', '    struct UINT {\n', '        uint value;\n', '    }\n', '\n', '    /// @dev Account information\n', '    struct Account {\n', '        \n', '        // Address of account\n', '        address addr;\n', '\n', '        // Balances of mining account\n', '        // tokenAddress=>balance\n', '        mapping(address=>UINT) balances;\n', '    }\n', '\n', '    // Configuration\n', '    Config _config;\n', '\n', '    // Registered account information\n', '    Account[] _accounts;\n', '\n', '    // Mapping from address to index of account. address=>accountIndex\n', '    mapping(address=>uint) _accountMapping;\n', '\n', '    // Mapping from token address to price channel. tokenAddress=>PriceChannel\n', '    mapping(address=>PriceChannel) _channels;\n', '\n', '    // Mapping from token address to ntoken address. tokenAddress=>ntokenAddress\n', '    mapping(address=>address) _addressCache;\n', '\n', '    // Cache for genesis block number of ntoken. ntokenAddress=>genesisBlockNumber\n', '    mapping(address=>uint) _genesisBlockNumberCache;\n', '\n', '    // INestPriceFacade implementation contract address\n', '    address _nestPriceFacadeAddress;\n', '\n', '    // INTokenController implementation contract address\n', '    address _nTokenControllerAddress;\n', '\n', '    // INestLegder implementation contract address\n', '    address _nestLedgerAddress;\n', '\n', '    // Unit of post fee. 0.0001 ether\n', '    uint constant DIMI_ETHER = 0.0001 ether;\n', '\n', '    // The mask of batch deposit trigger, while COLLECT_REWARD_MASK & sheets.length == COLLECT_REWARD_MASK, it will trigger deposit,\n', '    // COLLECT_REWARD_MASK is set to 0xF for testing (means every 16 sheets will deposit once), \n', '    // and it will be set to 0xFF for mainnet (means every 256 sheets will deposit once)\n', '    uint constant COLLECT_REWARD_MASK = 0xFF;\n', '\n', '    // Ethereum average block time interval, 14 seconds\n', '    uint constant ETHEREUM_BLOCK_TIMESPAN = 14;\n', '\n', '    /* ========== Governance ========== */\n', '\n', '    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call\n', '    ///      super.update(nestGovernanceAddress) when overriding, and override method without onlyGovernance\n', '    /// @param nestGovernanceAddress INestGovernance implementation contract address\n', '    function update(address nestGovernanceAddress) override public {\n', '        \n', '        super.update(nestGovernanceAddress);\n', '        (\n', '            //address nestTokenAddress\n', '            ,\n', '            //address nestNodeAddress\n', '            ,\n', '            //address nestLedgerAddress\n', '            _nestLedgerAddress,   \n', '            //address nestMiningAddress\n', '            ,\n', '            //address ntokenMiningAddress\n', '            ,\n', '            //address nestPriceFacadeAddress\n', '            _nestPriceFacadeAddress, \n', '            //address nestVoteAddress\n', '            , \n', '            //address nestQueryAddress\n', '            , \n', '            //address nnIncomeAddress\n', '            , \n', '            //address nTokenControllerAddress\n', '            _nTokenControllerAddress  \n', '\n', '        ) = INestGovernance(nestGovernanceAddress).getBuiltinAddress();\n', '    }\n', '\n', '    /// @dev Modify configuration\n', '    /// @param config Configuration object\n', '    function setConfig(Config calldata config) override external onlyGovernance {\n', '        _config = config;\n', '    }\n', '\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() override external view returns (Config memory) {\n', '        return _config;\n', '    }\n', '\n', '    /// @dev Clear chache of token. while ntoken recreated, this method is need to call\n', '    /// @param tokenAddress Token address\n', '    function resetNTokenCache(address tokenAddress) external onlyGovernance {\n', '\n', '        // Clear cache\n', '        address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        _genesisBlockNumberCache[ntokenAddress] = 0;\n', '        _addressCache[tokenAddress] = _addressCache[ntokenAddress] = address(0);\n', '    }\n', '\n', '    /// @dev Set the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @param ntokenAddress The ntoken address\n', '    function setNTokenAddress(address tokenAddress, address ntokenAddress) override external onlyGovernance {\n', '        _addressCache[tokenAddress] = ntokenAddress;\n', '    }\n', '\n', '    /// @dev Get the ntokenAddress from tokenAddress, if ntokenAddress is equals to tokenAddress, means the token is disabled\n', '    /// @param tokenAddress Destination token address\n', '    /// @return The ntoken address\n', '    function getNTokenAddress(address tokenAddress) override external view returns (address) {\n', '        return _addressCache[tokenAddress];\n', '    }\n', '\n', '    /* ========== Mining ========== */\n', '\n', '    // Get ntoken address of from token address\n', '    function _getNTokenAddress(address tokenAddress) private returns (address) {\n', '\n', '        address ntokenAddress = _addressCache[tokenAddress];\n', '        if (ntokenAddress == address(0)) {\n', '            ntokenAddress = INTokenController(_nTokenControllerAddress).getNTokenAddress(tokenAddress);\n', '            if (ntokenAddress != address(0)) {\n', '                _addressCache[tokenAddress] = ntokenAddress;\n', '            }\n', '        }\n', '        return ntokenAddress;\n', '    }\n', '\n', '    // Get genesis block number of ntoken\n', '    function _getNTokenGenesisBlock(address ntokenAddress) private returns (uint) {\n', '\n', '        uint genesisBlockNumber = _genesisBlockNumberCache[ntokenAddress];\n', '        if (genesisBlockNumber == 0) {\n', '            (genesisBlockNumber,) = INToken(ntokenAddress).checkBlockInfo();\n', '            _genesisBlockNumberCache[ntokenAddress] = genesisBlockNumber;\n', '        }\n', '        return genesisBlockNumber;\n', '    }\n', '\n', '    /// @notice Post a price sheet for TOKEN\n', '    /// @dev It is for TOKEN (except USDT and NTOKENs) whose NTOKEN has a total supply below a threshold (e.g. 5,000,000 * 1e18)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    function post(address tokenAddress, uint ethNum, uint tokenAmountPerEth) override external payable {\n', '\n', '        Config memory config = _config;\n', '\n', '        // 1. Check arguments\n', '        require(ethNum > 0 && ethNum == uint(config.postEthUnit), "NM:!ethNum");\n', '        require(tokenAmountPerEth > 0, "NM:!price");\n', '\n', '        // 2. Check price channel\n', '        // Check if the token allow post()\n', '        address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        require(ntokenAddress != address(0) && ntokenAddress != tokenAddress, "NM:!tokenAddress");\n', '        // Unit of nest is different, but the total supply already exceeded the number of this issue. No additional judgment will be made\n', '        // ntoken is mint when the price sheet is closed (or withdrawn), this may be the problem that the user\n', '        // intentionally does not close or withdraw, which leads to the inaccurate judgment of the total amount. ignore\n', '        require(INToken(ntokenAddress).totalSupply() < uint(config.doublePostThreshold) * 10000 ether, "NM:!post2");\n', '\n', '        // 3. Load token channel and sheets\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '\n', '        // 4. Freeze assets\n', '        uint accountIndex = _addressIndex(msg.sender);\n', '        // Freeze token and nest\n', '        // Because of the use of floating-point representation(fraction * 16 ^ exponent), it may bring some precision loss\n', '        // After assets are frozen according to tokenAmountPerEth * ethNum, the part with poor accuracy may be lost when\n', '        // the assets are returned, It should be frozen according to decodeFloat(fraction, exponent) * ethNum\n', '        // However, considering that the loss is less than 1 / 10 ^ 14, the loss here is ignored, and the part of\n', '        // precision loss can be transferred out as system income in the future\n', '        _freeze2(\n', '            _accounts[accountIndex].balances, \n', '            tokenAddress, \n', '            tokenAmountPerEth * ethNum, \n', '            uint(config.pledgeNest) * 1000 ether\n', '        );\n', '\n', '        // 5. Deposit fee\n', '        // The revenue is deposited every 256 sheets, deducting the times of taking orders and the settled part\n', '        uint length = sheets.length;\n', '        uint shares = _collect(config, channel, ntokenAddress, length, msg.value - ethNum * 1 ether);\n', '        require(shares > 0 && shares < 256, "NM:!fee");\n', '\n', '        // Calculate the price\n', '        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\n', '        // is placed before the sheet is added, which can reduce unnecessary traversal\n', '        _stat(config, channel, sheets);\n', '\n', '        // 6. Create token price sheet\n', '        emit Post(tokenAddress, msg.sender, length, ethNum, tokenAmountPerEth);\n', '        _createPriceSheet(sheets, accountIndex, uint32(ethNum), uint(config.pledgeNest), shares, tokenAmountPerEth);\n', '    }\n', '\n', '    /// @notice Post two price sheets for a token and its ntoken simultaneously\n', '    /// @dev Support dual-posts for TOKEN/NTOKEN, (ETH, TOKEN) + (ETH, NTOKEN)\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param ethNum The numbers of ethers to post sheets\n', '    /// @param tokenAmountPerEth The price of TOKEN\n', '    /// @param ntokenAmountPerEth The price of NTOKEN\n', '    function post2(\n', '        address tokenAddress, \n', '        uint ethNum, \n', '        uint tokenAmountPerEth, \n', '        uint ntokenAmountPerEth\n', '    ) override external payable {\n', '\n', '        Config memory config = _config;\n', '\n', '        // 1. Check arguments\n', '        require(ethNum > 0 && ethNum == uint(config.postEthUnit), "NM:!ethNum");\n', '        require(tokenAmountPerEth > 0 && ntokenAmountPerEth > 0, "NM:!price");\n', '\n', '        // 2. Check price channel\n', '        address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        require(ntokenAddress != address(0) && ntokenAddress != tokenAddress, "NM:!tokenAddress");\n', '\n', '        // 3. Load token channel and sheets\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '\n', '        // 4. Freeze assets\n', '        uint pledgeNest = uint(config.pledgeNest);\n', '        uint accountIndex = _addressIndex(msg.sender);\n', '        {\n', '            mapping(address=>UINT) storage balances = _accounts[accountIndex].balances;\n', '            _freeze(balances, tokenAddress, ethNum * tokenAmountPerEth);\n', '            _freeze2(balances, ntokenAddress, ethNum * ntokenAmountPerEth, pledgeNest * 2000 ether);\n', '        }\n', '\n', '        // 5. Deposit fee\n', '        // The revenue is deposited every 256 sheets, deducting the times of taking orders and the settled part\n', '        uint length = sheets.length;\n', '        uint shares = _collect(config, channel, ntokenAddress, length, msg.value - ethNum * 2 ether);\n', '        require(shares > 0 && shares < 256, "NM:!fee");\n', '\n', '        // Calculate the price\n', '        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\n', '        // is placed before the sheet is added, which can reduce unnecessary traversal\n', '        _stat(config, channel, sheets);\n', '\n', '        // 6. Create token price sheet\n', '        emit Post(tokenAddress, msg.sender, length, ethNum, tokenAmountPerEth);\n', '        _createPriceSheet(sheets, accountIndex, uint32(ethNum), pledgeNest, shares, tokenAmountPerEth);\n', '\n', '        // 7. Load ntoken channel and sheets\n', '        channel = _channels[ntokenAddress];\n', '        sheets = channel.sheets;\n', '\n', '        // Calculate the price\n', '        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\n', '        // is placed before the sheet is added, which can reduce unnecessary traversal\n', '        _stat(config, channel, sheets);\n', '\n', '        // 8. Create token price sheet\n', '        emit Post(ntokenAddress, msg.sender, sheets.length, ethNum, ntokenAmountPerEth);\n', '        _createPriceSheet(sheets, accountIndex, uint32(ethNum), pledgeNest, 0, ntokenAmountPerEth);\n', '    }\n', '\n', '    /// @notice Call the function to buy TOKEN/NTOKEN from a posted price sheet\n', '    /// @dev bite TOKEN(NTOKEN) by ETH,  (+ethNumBal, -tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum * newTokenAmountPerEth\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeToken(\n', '        address tokenAddress,\n', '        uint index,\n', '        uint takeNum,\n', '        uint newTokenAmountPerEth\n', '    ) override external payable {\n', '\n', '        Config memory config = _config;\n', '\n', '        // 1. Check arguments\n', '        require(takeNum > 0 && takeNum % uint(config.postEthUnit) == 0, "NM:!takeNum");\n', '        require(newTokenAmountPerEth > 0, "NM:!price");\n', '\n', '        // 2. Load price sheet\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '        PriceSheet memory sheet = sheets[index];\n', '\n', '        // 3. Check state\n', '        require(uint(sheet.remainNum) >= takeNum, "NM:!remainNum");\n', '        require(uint(sheet.height) + uint(config.priceEffectSpan) >= block.number, "NM:!state");\n', '\n', '        // 4. Deposit fee\n', '        {\n', '            // The revenue is deposited every 256 sheets, deducting the times of taking orders and the settled part\n', '            address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '            if (tokenAddress != ntokenAddress) {\n', '                _collect(config, channel, ntokenAddress, sheets.length, 0);\n', '            }\n', '        }\n', '\n', '        // 5. Calculate the number of eth, token and nest needed, and freeze them\n', '        uint needEthNum;\n', '        uint level = uint(sheet.level);\n', '\n', '        // When the level of the sheet is less than 4, both the nest and the scale of the offer are doubled\n', '        if (level < uint(config.maxBiteNestedLevel)) {\n', '            // Double scale sheet\n', '            needEthNum = takeNum << 1;\n', '            ++level;\n', '        } \n', '        // When the level of the sheet reaches 4 or more, nest doubles, but the scale does not\n', '        else {\n', '            // Single scale sheet\n', '            needEthNum = takeNum;\n', '            // It is possible that the length of a single chain exceeds 255. When the length of a chain reaches 4\n', '            // or more, there is no logical dependence on the specific value of the contract, and the count will\n', '            // not increase after it is accumulated to 255\n', '            if (level < 255) ++level;\n', '        }\n', '        require(msg.value == (needEthNum + takeNum) * 1 ether, "NM:!value");\n', '\n', '        // Number of nest to be pledged\n', '        //uint needNest1k = ((takeNum << 1) / uint(config.postEthUnit)) * uint(config.pledgeNest);\n', '        // sheet.ethNumBal + sheet.tokenNumBal is always two times to sheet.ethNum\n', '        uint needNest1k = (takeNum << 2) * uint(sheet.nestNum1k) / (uint(sheet.ethNumBal) + uint(sheet.tokenNumBal));\n', '        // Freeze nest and token\n', '        uint accountIndex = _addressIndex(msg.sender);\n', '        {\n', '            mapping(address=>UINT) storage balances = _accounts[accountIndex].balances;\n', '            uint backTokenValue = decodeFloat(sheet.priceFloat) * takeNum;\n', '            if (needEthNum * newTokenAmountPerEth > backTokenValue) {\n', '                _freeze2(\n', '                    balances,\n', '                    tokenAddress,\n', '                    needEthNum * newTokenAmountPerEth - backTokenValue,\n', '                    needNest1k * 1000 ether\n', '                );\n', '            } else {\n', '                _freeze(balances, NEST_TOKEN_ADDRESS, needNest1k * 1000 ether);\n', '                _unfreeze(balances, tokenAddress, backTokenValue - needEthNum * newTokenAmountPerEth);\n', '            }\n', '        }\n', '\n', '        // 6. Update the biten sheet\n', '        sheet.remainNum = uint32(uint(sheet.remainNum) - takeNum);\n', '        sheet.ethNumBal = uint32(uint(sheet.ethNumBal) + takeNum);\n', '        sheet.tokenNumBal = uint32(uint(sheet.tokenNumBal) - takeNum);\n', '        sheets[index] = sheet;\n', '\n', '        // 7. Calculate the price\n', '        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\n', '        // is placed before the sheet is added, which can reduce unnecessary traversal\n', '        _stat(config, channel, sheets);\n', '\n', '        // 8. Create price sheet\n', '        emit Post(tokenAddress, msg.sender, sheets.length, needEthNum, newTokenAmountPerEth);\n', '        _createPriceSheet(sheets, accountIndex, uint32(needEthNum), needNest1k, level << 8, newTokenAmountPerEth);\n', '    }\n', '\n', '    /// @notice Call the function to buy ETH from a posted price sheet\n', '    /// @dev bite ETH by TOKEN(NTOKEN),  (-ethNumBal, +tokenNumBal)\n', '    /// @param tokenAddress The address of token(ntoken)\n', '    /// @param index The position of the sheet in priceSheetList[token]\n', '    /// @param takeNum The amount of biting (in the unit of ETH), realAmount = takeNum\n', '    /// @param newTokenAmountPerEth The new price of token (1 ETH : some TOKEN), here some means newTokenAmountPerEth\n', '    function takeEth(\n', '        address tokenAddress,\n', '        uint index,\n', '        uint takeNum,\n', '        uint newTokenAmountPerEth\n', '    ) override external payable {\n', '\n', '        Config memory config = _config;\n', '\n', '        // 1. Check arguments\n', '        require(takeNum > 0 && takeNum % uint(config.postEthUnit) == 0, "NM:!takeNum");\n', '        require(newTokenAmountPerEth > 0, "NM:!price");\n', '\n', '        // 2. Load price sheet\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '        PriceSheet memory sheet = sheets[index];\n', '\n', '        // 3. Check state\n', '        require(uint(sheet.remainNum) >= takeNum, "NM:!remainNum");\n', '        require(uint(sheet.height) + uint(config.priceEffectSpan) >= block.number, "NM:!state");\n', '\n', '        // 4. Deposit fee\n', '        {\n', '            // The revenue is deposited every 256 sheets, deducting the times of taking orders and the settled part\n', '            address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '            if (tokenAddress != ntokenAddress) {\n', '                _collect(config, channel, ntokenAddress, sheets.length, 0);\n', '            }\n', '        }\n', '\n', '        // 5. Calculate the number of eth, token and nest needed, and freeze them\n', '        uint needEthNum;\n', '        uint level = uint(sheet.level);\n', '\n', '        // When the level of the sheet is less than 4, both the nest and the scale of the offer are doubled\n', '        if (level < uint(config.maxBiteNestedLevel)) {\n', '            // Double scale sheet\n', '            needEthNum = takeNum << 1;\n', '            ++level;\n', '        } \n', '        // When the level of the sheet reaches 4 or more, nest doubles, but the scale does not\n', '        else {\n', '            // Single scale sheet\n', '            needEthNum = takeNum;\n', '            // It is possible that the length of a single chain exceeds 255. When the length of a chain reaches 4 \n', '            // or more, there is no logical dependence on the specific value of the contract, and the count will\n', '            // not increase after it is accumulated to 255\n', '            if (level < 255) ++level;\n', '        }\n', '        require(msg.value == (needEthNum - takeNum) * 1 ether, "NM:!value");\n', '\n', '        // Number of nest to be pledged\n', '        //uint needNest1k = ((takeNum << 1) / uint(config.postEthUnit)) * uint(config.pledgeNest);\n', '        // sheet.ethNumBal + sheet.tokenNumBal is always two times to sheet.ethNum\n', '        uint needNest1k = (takeNum << 2) * uint(sheet.nestNum1k) / (uint(sheet.ethNumBal) + uint(sheet.tokenNumBal));\n', '        // Freeze nest and token\n', '        uint accountIndex = _addressIndex(msg.sender);\n', '        _freeze2(\n', '            _accounts[accountIndex].balances, \n', '            tokenAddress, \n', '            needEthNum * newTokenAmountPerEth + decodeFloat(sheet.priceFloat) * takeNum, \n', '            needNest1k * 1000 ether\n', '        );\n', '            \n', '        // 6. Update the biten sheet\n', '        sheet.remainNum = uint32(uint(sheet.remainNum) - takeNum);\n', '        sheet.ethNumBal = uint32(uint(sheet.ethNumBal) - takeNum);\n', '        sheet.tokenNumBal = uint32(uint(sheet.tokenNumBal) + takeNum);\n', '        sheets[index] = sheet;\n', '\n', '        // 7. Calculate the price\n', '        // According to the current mechanism, the newly added sheet cannot take effect, so the calculated price\n', '        // is placed before the sheet is added, which can reduce unnecessary traversal\n', '        _stat(config, channel, sheets);\n', '\n', '        // 8. Create price sheet\n', '        emit Post(tokenAddress, msg.sender, sheets.length, needEthNum, newTokenAmountPerEth);\n', '        _createPriceSheet(sheets, accountIndex, uint32(needEthNum), needNest1k, level << 8, newTokenAmountPerEth);\n', '    }\n', '\n', '    // Create price sheet\n', '    function _createPriceSheet(\n', '        PriceSheet[] storage sheets,\n', '        uint accountIndex,\n', '        uint32 ethNum,\n', '        uint nestNum1k,\n', '        uint level_shares,\n', '        uint tokenAmountPerEth\n', '    ) private {\n', '\n', '        sheets.push(PriceSheet(\n', '            uint32(accountIndex),                       // uint32 miner;\n', '            uint32(block.number),                       // uint32 height;\n', '            ethNum,                                     // uint32 remainNum;\n', '            ethNum,                                     // uint32 ethNumBal;\n', '            ethNum,                                     // uint32 tokenNumBal;\n', '            uint24(nestNum1k),                          // uint32 nestNum1k;\n', '            uint8(level_shares >> 8),                   // uint8 level;\n', '            uint8(level_shares & 0xFF),\n', '            encodeFloat(tokenAmountPerEth)\n', '        ));\n', '    }\n', '\n', '    // Nest ore drawing attenuation interval. 2400000 blocks, about one year\n', '    uint constant NEST_REDUCTION_SPAN = 2400000;\n', '    // The decay limit of nest ore drawing becomes stable after exceeding this interval. 24 million blocks, about 10 years\n', '    uint constant NEST_REDUCTION_LIMIT = 24000000; //NEST_REDUCTION_SPAN * 10;\n', '    // Attenuation gradient array, each attenuation step value occupies 16 bits. The attenuation value is an integer\n', '    uint constant NEST_REDUCTION_STEPS = 0x280035004300530068008300A300CC010001400190;\n', '        // 0\n', '        // | (uint(400 / uint(1)) << (16 * 0))\n', '        // | (uint(400 * 8 / uint(10)) << (16 * 1))\n', '        // | (uint(400 * 8 * 8 / uint(10 * 10)) << (16 * 2))\n', '        // | (uint(400 * 8 * 8 * 8 / uint(10 * 10 * 10)) << (16 * 3))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10)) << (16 * 4))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10)) << (16 * 5))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10)) << (16 * 6))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 7))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 8))\n', '        // | (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 9))\n', '        // //| (uint(400 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 * 8 / uint(10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10)) << (16 * 10));\n', '        // | (uint(40) << (16 * 10));\n', '\n', '    // Calculation of attenuation gradient\n', '    function _redution(uint delta) private pure returns (uint) {\n', '\n', '        if (delta < NEST_REDUCTION_LIMIT) {\n', '            return (NEST_REDUCTION_STEPS >> ((delta / NEST_REDUCTION_SPAN) << 4)) & 0xFFFF;\n', '        }\n', '        return (NEST_REDUCTION_STEPS >> 160) & 0xFFFF;\n', '    }\n', '\n', '    /// @notice Close a price sheet of (ETH, USDx) | (ETH, NEST) | (ETH, TOKEN) | (ETH, NTOKEN)\n', '    /// @dev Here we allow an empty price sheet (still in VERIFICATION-PERIOD) to be closed\n', '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param index The index of the price sheet w.r.t. `token`\n', '    function close(address tokenAddress, uint index) override external {\n', '        \n', '        Config memory config = _config;\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '\n', '        // Load the price channel\n', '        address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        // Call _close() method to close price sheet\n', '        (uint accountIndex, Tunple memory total) = _close(config, sheets, index, ntokenAddress);\n', '\n', '        if (accountIndex > 0) {\n', '            // Return eth\n', '            if (uint(total.ethNum) > 0) {\n', '                payable(indexAddress(accountIndex)).transfer(uint(total.ethNum) * 1 ether);\n', '            }\n', '            // Unfreeze assets\n', '            _unfreeze3(\n', '                _accounts[accountIndex].balances, \n', '                tokenAddress, \n', '                total.tokenValue, \n', '                ntokenAddress, \n', '                uint(total.ntokenValue), \n', '                uint(total.nestValue)\n', '            );\n', '        }\n', '\n', '        // Calculate the price\n', '        _stat(config, channel, sheets);\n', '    }\n', '\n', '    /// @notice Close a batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN contract\n', '    /// @param indices A list of indices of sheets w.r.t. `token`\n', '    function closeList(address tokenAddress, uint[] memory indices) override external {\n', '        \n', '        // Call _closeList() method to close price sheets\n', '        (\n', '            uint accountIndex,\n', '            Tunple memory total,\n', '            address ntokenAddress\n', '        ) = _closeList(_config, _channels[tokenAddress], tokenAddress, indices);\n', '\n', '        // Return eth\n', '        payable(indexAddress(accountIndex)).transfer(uint(total.ethNum) * 1 ether);\n', '        // Unfreeze assets\n', '        _unfreeze3(\n', '            _accounts[accountIndex].balances,\n', '            tokenAddress,\n', '            uint(total.tokenValue),\n', '            ntokenAddress,\n', '            uint(total.ntokenValue),\n', '            uint(total.nestValue)\n', '        );\n', '    }\n', '\n', '    /// @notice Close two batch of price sheets passed VERIFICATION-PHASE\n', "    /// @dev Empty sheets but in VERIFICATION-PHASE aren't allowed\n", '    /// @param tokenAddress The address of TOKEN1 contract\n', '    /// @param tokenIndices A list of indices of sheets w.r.t. `token`\n', '    /// @param ntokenIndices A list of indices of sheets w.r.t. `ntoken`\n', '    function closeList2(\n', '        address tokenAddress,\n', '        uint[] memory tokenIndices,\n', '        uint[] memory ntokenIndices\n', '    ) override external {\n', '\n', '        Config memory config = _config;\n', '        mapping(address=>PriceChannel) storage channels = _channels;\n', '\n', '        // Call _closeList() method to close price sheets\n', '        (\n', '            uint accountIndex1,\n', '            Tunple memory total1,\n', '            address ntokenAddress\n', '        ) = _closeList(config, channels[tokenAddress], tokenAddress, tokenIndices);\n', '\n', '        (\n', '            uint accountIndex2,\n', '            Tunple memory total2,\n', '            //address ntokenAddress2\n', '        ) = _closeList(config, channels[ntokenAddress], ntokenAddress, ntokenIndices);\n', '\n', '        require(accountIndex1 == accountIndex2, "NM:!miner");\n', '        //require(ntokenAddress1 == tokenAddress2, "NM:!tokenAddress");\n', '        require(uint(total2.ntokenValue) == 0, "NM!ntokenValue");\n', '\n', '        // Return eth\n', '        payable(indexAddress(accountIndex1)).transfer((uint(total1.ethNum) + uint(total2.ethNum)) * 1 ether);\n', '        // Unfreeze assets\n', '        _unfreeze3(\n', '            _accounts[accountIndex1].balances,\n', '            tokenAddress,\n', '            uint(total1.tokenValue),\n', '            ntokenAddress,\n', '            uint(total1.ntokenValue) + uint(total2.tokenValue)/* + uint(total2.ntokenValue) */,\n', '            uint(total1.nestValue) + uint(total2.nestValue)\n', '        );\n', '    }\n', '\n', '    // Calculation number of blocks which mined\n', '    function _calcMinedBlocks(\n', '        PriceSheet[] storage sheets,\n', '        uint index,\n', '        PriceSheet memory sheet\n', '    ) private view returns (uint minedBlocks, uint totalShares) {\n', '\n', '        uint length = sheets.length;\n', '        uint height = uint(sheet.height);\n', '        totalShares = uint(sheet.shares);\n', '\n', '        // Backward looking for sheets in the same block\n', '        for (uint i = index; ++i < length && uint(sheets[i].height) == height;) {\n', '            \n', '            // Multiple sheets in the same block is a small probability event at present, so it can be ignored\n', '            // to read more than once, if there are always multiple sheets in the same block, it means that the\n', '            // sheets are very intensive, and the gas consumed here does not have a great impact\n', '            totalShares += uint(sheets[i].shares);\n', '        }\n', '\n', '        //i = index;\n', '        // Find sheets in the same block forward\n', '        uint prev = height;\n', '        while (index > 0 && uint(prev = sheets[--index].height) == height) {\n', '\n', '            // Multiple sheets in the same block is a small probability event at present, so it can be ignored \n', '            // to read more than once, if there are always multiple sheets in the same block, it means that the\n', '            // sheets are very intensive, and the gas consumed here does not have a great impact\n', '            totalShares += uint(sheets[index].shares);\n', '        }\n', '\n', '        if (index > 0 || height > prev) {\n', '            minedBlocks = height - prev;\n', '        } else {\n', '            minedBlocks = 10;\n', '        }\n', '    }\n', '\n', '    // This structure is for the _close() method to return multiple values\n', '    struct Tunple {\n', '        uint tokenValue;\n', '        uint64 ethNum;\n', '        uint96 nestValue;\n', '        uint96 ntokenValue;\n', '    }\n', '\n', '    // Close price sheet\n', '    function _close(\n', '        Config memory config,\n', '        PriceSheet[] storage sheets,\n', '        uint index,\n', '        address ntokenAddress\n', '    ) private returns (uint accountIndex, Tunple memory value) {\n', '\n', '        PriceSheet memory sheet = sheets[index];\n', '        uint height = uint(sheet.height);\n', '\n', '        // Check the status of the price sheet to see if it has reached the effective block interval or has been finished\n', '        if ((accountIndex = uint(sheet.miner)) > 0 && (height + uint(config.priceEffectSpan) < block.number)) {\n', '\n', '            // TMP: tmp is a polysemous name, here means sheet.shares\n', '            uint tmp = uint(sheet.shares);\n', '            // Mining logic\n', "            // The price sheet which shares is zero dosen't mining\n", '            if (tmp > 0) {\n', '\n', '                // Currently, mined represents the number of blocks has mined\n', '                (uint mined, uint totalShares) = _calcMinedBlocks(sheets, index, sheet);\n', '                // nest mining\n', '                if (ntokenAddress == NEST_TOKEN_ADDRESS) {\n', '\n', '                    // Since then, mined represents the amount of mining\n', '                    // mined = (\n', '                    //     mined \n', '                    //     * uint(sheet.shares) \n', '                    //     * _redution(height - NEST_GENESIS_BLOCK) \n', '                    //     * 1 ether \n', '                    //     * uint(config.minerNestReward) \n', '                    //     / 10000 \n', '                    //     / totalShares\n', '                    // );\n', '                    // The original expression is shown above. In order to save gas,\n', '                    // the part that can be calculated in advance is calculated first\n', '                    mined = (\n', '                        mined\n', '                        * tmp\n', '                        * _redution(height - NEST_GENESIS_BLOCK)\n', '                        * uint(config.minerNestReward)\n', '                        * 0.0001 ether\n', '                        / totalShares\n', '                    );\n', '                }\n', '                // ntoken mining\n', '                else {\n', '\n', '                    // The limit blocks can be mined\n', '                    if (mined > uint(config.ntokenMinedBlockLimit)) {\n', '                        mined = uint(config.ntokenMinedBlockLimit);\n', '                    }\n', '                    \n', '                    // Since then, mined represents the amount of mining\n', '                    mined = (\n', '                        mined\n', '                        * tmp\n', '                        * _redution(height - _getNTokenGenesisBlock(ntokenAddress))\n', '                        * 0.01 ether\n', '                        / totalShares\n', '                    );\n', '\n', '                    // Put this logic into widhdran() method to reduce gas consumption\n', '                    // ntoken bidders\n', '                    address bidder = INToken(ntokenAddress).checkBidder();\n', '                    // Legacy ntoken, need separate\n', '                    if (bidder != address(this)) {\n', '\n', '                        // Considering that multiple sheets in the same block are small probability events,\n', '                        // we can send token to bidders in each closing operation\n', '                        // 5% for bidder\n', '\n', '                        // TMP: tmp is a polysemous name, here means mint ntoken amount for miner\n', '                        tmp = mined * uint(config.minerNTokenReward) / 10000;\n', '                        _unfreeze(\n', '                            _accounts[_addressIndex(bidder)].balances,\n', '                            ntokenAddress,\n', '                            mined - tmp\n', '                        );\n', '\n', '                        // Miner take according proportion which set\n', '                        mined = tmp;\n', '                    }\n', '                }\n', '\n', '                value.ntokenValue = uint96(mined);\n', '            }\n', '\n', '            value.nestValue = uint96(uint(sheet.nestNum1k) * 1000 ether);\n', '            value.ethNum = uint64(sheet.ethNumBal);\n', '            value.tokenValue = decodeFloat(sheet.priceFloat) * uint(sheet.tokenNumBal);\n', '\n', '            // Set sheet.miner to 0, express the sheet is closed\n', '            sheet.miner = uint32(0);\n', '            sheet.ethNumBal = uint32(0);\n', '            sheet.tokenNumBal = uint32(0);\n', '            sheets[index] = sheet;\n', '        }\n', '    }\n', '\n', '    // Batch close sheets\n', '    function _closeList(\n', '        Config memory config,\n', '        PriceChannel storage channel,\n', '        address tokenAddress,\n', '        uint[] memory indices\n', '    ) private returns (uint accountIndex, Tunple memory total, address ntokenAddress) {\n', '\n', '        ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        PriceSheet[] storage sheets = channel.sheets;\n', '        accountIndex = 0; \n', '\n', '        // 1. Traverse sheets\n', '        for (uint i = indices.length; i > 0;) {\n', '\n', '            // Because too many variables need to be returned, too many variables will be defined, so the structure of tunple is defined\n', '            (uint minerIndex, Tunple memory value) = _close(config, sheets, indices[--i], ntokenAddress);\n', '            // Batch closing quotation can only close sheet of the same user\n', '            if (accountIndex == 0) {\n', '                // accountIndex == 0 means the first sheet, and the number of this sheet is taken\n', '                accountIndex = minerIndex;\n', '            } else {\n', '                // accountIndex != 0 means that it is a follow-up sheet, and the miner number must be consistent with the previous record\n', '                require(accountIndex == minerIndex, "NM:!miner");\n', '            }\n', '\n', '            total.ntokenValue += value.ntokenValue;\n', '            total.nestValue += value.nestValue;\n', '            total.ethNum += value.ethNum;\n', '            total.tokenValue += value.tokenValue;\n', '        }\n', '\n', '        _stat(config, channel, sheets);\n', '    }\n', '\n', '    // Calculate price, average price and volatility\n', '    function _stat(Config memory config, PriceChannel storage channel, PriceSheet[] storage sheets) private {\n', '\n', '        // Load token price information\n', '        PriceInfo memory p0 = channel.price;\n', '\n', '        // Length of sheets\n', '        uint length = sheets.length;\n', '        // The index of the sheet to be processed in the sheet array\n', '        uint index = uint(p0.index);\n', '        // The latest block number for which the price has been calculated\n', '        uint prev = uint(p0.height);\n', "        // It's not necessary to load the price information in p0\n", '        // Eth count variable used to calculate price\n', '        uint totalEthNum = 0; \n', '        // Token count variable for price calculation\n', '        uint totalTokenValue = 0; \n', '        // Block number of current sheet\n', '        uint height = 0;\n', '\n', '        // Traverse the sheets to find the effective price\n', '        uint effectBlock = block.number - uint(config.priceEffectSpan);\n', '        PriceSheet memory sheet;\n', '        for (; ; ++index) {\n', '\n', '            // Gas attack analysis, each post transaction, calculated according to post, needs to write\n', '            // at least one sheet and freeze two kinds of assets, which needs to consume at least 30000 gas,\n', '            // In addition to the basic cost of the transaction, at least 50000 gas is required.\n', '            // In addition, there are other reading and calculation operations. The gas consumed by each\n', '            // transaction is impossible less than 70000 gas, The attacker can accumulate up to 20 blocks\n', '            // of sheets to be generated. To ensure that the calculation can be completed in one block,\n', '            // it is necessary to ensure that the consumption of each price does not exceed 70000 / 20 = 3500 gas,\n', '            // According to the current logic, each calculation of a price needs to read a storage unit (800)\n', '            // and calculate the consumption, which can not reach the dangerous value of 3500, so the gas attack\n', '            // is not considered\n', '\n', '            // Traverse the sheets that has reached the effective interval from the current position\n', '            bool flag = index >= length || (height = uint((sheet = sheets[index]).height)) >= effectBlock;\n', '\n', '            // Not the same block (or flag is false), calculate the price and update it\n', '            if (flag || prev != height) {\n', '\n', '                // totalEthNum > 0 Can calculate the price\n', '                if (totalEthNum > 0) {\n', '\n', '                    // Calculate average price and Volatility\n', '                    // Calculation method of volatility of follow-up price\n', '                    uint tmp = decodeFloat(p0.priceFloat);\n', '                    // New price\n', '                    uint price = totalTokenValue / totalEthNum;\n', '                    // Update price\n', '                    p0.remainNum = uint32(totalEthNum);\n', '                    p0.priceFloat = encodeFloat(price);\n', '                    // Clear cumulative values\n', '                    totalEthNum = 0;\n', '                    totalTokenValue = 0;\n', '\n', '                    if (tmp > 0) {\n', '                        // Calculate average price\n', '                        // avgPrice[i + 1] = avgPrice[i] * 90% + price[i] * 10%\n', '                        p0.avgFloat = encodeFloat((decodeFloat(p0.avgFloat) * 9 + price) / 10);\n', '\n', '                        // When the accuracy of the token is very high or the value of the token relative to\n', '                        // eth is very low, the price may be very large, and there may be overflow problem,\n', '                        // it is not considered for the moment\n', '                        tmp = (price << 48) / tmp;\n', '                        if (tmp > 0x1000000000000) {\n', '                            tmp = tmp - 0x1000000000000;\n', '                        } else {\n', '                            tmp = 0x1000000000000 - tmp;\n', '                        }\n', '\n', '                        // earn = price[i] / price[i - 1] - 1;\n', '                        // seconds = time[i] - time[i - 1];\n', '                        // sigmaSQ[i + 1] = sigmaSQ[i] * 90% + (earn ^ 2 / seconds) * 10%\n', '                        tmp = (\n', '                            uint(p0.sigmaSQ) * 9 + \n', '                            // It is inevitable that prev greatter than p0.height\n', '                            ((tmp * tmp / ETHEREUM_BLOCK_TIMESPAN / (prev - uint(p0.height))) >> 48)\n', '                        ) / 10;\n', '\n', '                        // The current implementation assumes that the volatility cannot exceed 1, and\n', '                        // corresponding to this, when the calculated value exceeds 1, expressed as 0xFFFFFFFFFFFF\n', '                        if (tmp > 0xFFFFFFFFFFFF) {\n', '                            tmp = 0xFFFFFFFFFFFF;\n', '                        }\n', '                        p0.sigmaSQ = uint48(tmp);\n', '                    }\n', '                    // The calculation methods of average price and volatility are different for first price\n', '                    else {\n', '                        // The average price is equal to the price\n', '                        //p0.avgTokenAmount = uint64(price);\n', '                        p0.avgFloat = p0.priceFloat;\n', '\n', '                        // The volatility is 0\n', '                        p0.sigmaSQ = uint48(0);\n', '                    }\n', '\n', '                    // Update price block number\n', '                    p0.height = uint32(prev);\n', '                }\n', '\n', '                // Move to new block number\n', '                prev = height;\n', '            }\n', '\n', '            if (flag) {\n', '                break;\n', '            }\n', '\n', '            // Cumulative price information\n', '            totalEthNum += uint(sheet.remainNum);\n', '            totalTokenValue += decodeFloat(sheet.priceFloat) * uint(sheet.remainNum);\n', '        }\n', '\n', '        // Update price infomation\n', '        if (index > uint(p0.index)) {\n', '            p0.index = uint32(index);\n', '            channel.price = p0;\n', '        }\n', '    }\n', '\n', '    /// @dev The function updates the statistics of price sheets\n', '    ///     It calculates from priceInfo to the newest that is effective.\n', '    function stat(address tokenAddress) override external {\n', '        PriceChannel storage channel = _channels[tokenAddress];\n', '        _stat(_config, channel, channel.sheets);\n', '    }\n', '\n', '    // Collect and deposit the commission into NestLedger\n', '    function _collect(\n', '        Config memory config,\n', '        PriceChannel storage channel,\n', '        address ntokenAddress,\n', '        uint length,\n', '        uint currentFee\n', '    ) private returns (uint) {\n', '\n', '        // Commission is charged for every post(post2), the commission should be deposited to NestLedger,\n', '        // for saving gas, according to sheets.length, every increase of 256 will deposit once, The calculation formula is:\n', '        // \n', '        // totalFee = fee * increment\n', '        // \n', '        // In consideration of takeToken, takeEth, change postFeeUnit or miner pay more fee, the formula will be invalid,\n', '        // at this point, it is need to settle immediately, the details of triggering settlement logic are as follows\n', '        // \n', '        // 1. When there is a bite transaction(currentFee is 0), the counter of no fee sheets will be increase 1\n', '        // 2. If the Commission of this time is inconsistent with that of last time, deposit immediately\n', '        // 3. When the increment of sheets.length is 256, deposit immediately\n', '        // 4. Everyone can trigger immediate settlement by manually calling the settle() method\n', '        // \n', '        // In order to realize the logic above, the following values are defined\n', '        // \n', '        // 1. PriceChannel.feeInfo\n', '        //    Low 128-bits represent last fee per post\n', '        //    High 128-bits represent the current counter of no fee sheets (including settled)\n', '        // \n', '        // 2. COLLECT_REWARD_MASK\n', '        //    The mask of batch deposit trigger, while COLLECT_REWARD_MASK & sheets.length == COLLECT_REWARD_MASK, it will trigger deposit,\n', '        //    COLLECT_REWARD_MASK is set to 0xF for testing (means every 16 sheets will deposit once), \n', '        //    and it will be set to 0xFF for mainnet (means every 256 sheets will deposit once)\n', '\n', '        uint feeUnit = uint(config.postFeeUnit) * DIMI_ETHER;\n', '        require(currentFee % feeUnit == 0, "NM:!fee");\n', '        uint feeInfo = channel.feeInfo;\n', '        uint oldFee = feeInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '        // length == 255 means is time to save reward\n', '        // currentFee != oldFee means the fee is changed, need to settle\n', '        if (length & COLLECT_REWARD_MASK == COLLECT_REWARD_MASK || (currentFee != oldFee && currentFee > 0)) {\n', '            // Save reward\n', '            INestLedger(_nestLedgerAddress).carveETHReward { \n', '                value: currentFee + oldFee * ((length & COLLECT_REWARD_MASK) - (feeInfo >> 128))\n', '            } (ntokenAddress);\n', '            // Update fee information\n', '            channel.feeInfo = currentFee | (((length + 1) & COLLECT_REWARD_MASK) << 128);\n', '        }\n', '        // currentFee is 0, increase no fee counter\n', '        else if (currentFee == 0) {\n', '            // channel.feeInfo = feeInfo + (1 << 128);\n', '            channel.feeInfo = feeInfo + 0x100000000000000000000000000000000;\n', '        }\n', '\n', '        // Calculate share count\n', '        return currentFee / feeUnit;\n', '    }\n', '\n', '    /// @dev Settlement Commission\n', '    /// @param tokenAddress The token address\n', '    function settle(address tokenAddress) override external {\n', '\n', '        address ntokenAddress = _getNTokenAddress(tokenAddress);\n', '        // ntoken is no reward\n', '        if (tokenAddress != ntokenAddress) {\n', '\n', '            PriceChannel storage channel = _channels[tokenAddress];\n', '            uint length = channel.sheets.length & COLLECT_REWARD_MASK;\n', '            uint feeInfo = channel.feeInfo;\n', '\n', '            // Save reward\n', '            INestLedger(_nestLedgerAddress).carveETHReward {\n', '                value: (feeInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) * (length - (feeInfo >> 128))\n', '            } (ntokenAddress);\n', '\n', '            // Manual settlement does not need to update Commission variables\n', '            channel.feeInfo = (feeInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (length << 128);\n', '        }\n', '    }\n', '\n', '    // Convert PriceSheet to PriceSheetView\n', '    function _toPriceSheetView(PriceSheet memory sheet, uint index) private view returns (PriceSheetView memory) {\n', '\n', '        return PriceSheetView(\n', '            // Index number\n', '            uint32(index),\n', '            // Miner address\n', '            indexAddress(sheet.miner),\n', '            // The block number of this price sheet packaged\n', '            sheet.height,\n', '            // The remain number of this price sheet\n', '            sheet.remainNum,\n', '            // The eth number which miner will got\n', '            sheet.ethNumBal,\n', "            // The eth number which equivalent to token's value which miner will got\n", '            sheet.tokenNumBal,\n', '            // The pledged number of nest in this sheet. (Unit: 1000nest)\n', '            sheet.nestNum1k,\n', '            // The level of this sheet. 0 expresses initial price sheet, a value greater than 0 expresses bite price sheet\n', '            sheet.level,\n', '            // Post fee shares\n', '            sheet.shares,\n', '            // Price\n', '            uint152(decodeFloat(sheet.priceFloat))\n', '        );\n', '    }\n', '\n', '    /// @dev List sheets by page\n', '    /// @param tokenAddress Destination token address\n', '    /// @param offset Skip previous (offset) records\n', '    /// @param count Return (count) records\n', '    /// @param order Order. 0 reverse order, non-0 positive order\n', '    /// @return List of price sheets\n', '    function list(\n', '        address tokenAddress,\n', '        uint offset,\n', '        uint count,\n', '        uint order\n', '    ) override external view noContract returns (PriceSheetView[] memory) {\n', '\n', '        PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '        PriceSheetView[] memory result = new PriceSheetView[](count);\n', '        uint length = sheets.length;\n', '        uint i = 0;\n', '\n', '        // Reverse order\n', '        if (order == 0) {\n', '\n', '            uint index = length - offset;\n', '            uint end = index > count ? index - count : 0;\n', '            while (index > end) {\n', '                --index;\n', '                result[i++] = _toPriceSheetView(sheets[index], index);\n', '            }\n', '        } \n', '        // Positive order\n', '        else {\n', '\n', '            uint index = offset;\n', '            uint end = index + count;\n', '            if (end > length) {\n', '                end = length;\n', '            }\n', '            while (index < end) {\n', '                result[i++] = _toPriceSheetView(sheets[index], index);\n', '                ++index;\n', '            }\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /// @dev Estimated mining amount\n', '    /// @param tokenAddress Destination token address\n', '    /// @return Estimated mining amount\n', '    function estimate(address tokenAddress) override external view returns (uint) {\n', '\n', '        address ntokenAddress = INTokenController(_nTokenControllerAddress).getNTokenAddress(tokenAddress);\n', '        if (tokenAddress != ntokenAddress) {\n', '\n', '            PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '            uint index = sheets.length;\n', '            while (index > 0) {\n', '\n', '                PriceSheet memory sheet = sheets[--index];\n', '                if (uint(sheet.shares) > 0) {\n', '\n', '                    // Standard mining amount\n', '                    uint standard = (block.number - uint(sheet.height)) * 1 ether;\n', '                    // Genesis block number of ntoken\n', '                    uint genesisBlock = NEST_GENESIS_BLOCK;\n', '\n', '                    // Not nest, the calculation methods of standard mining amount and genesis block number are different\n', '                    if (ntokenAddress != NEST_TOKEN_ADDRESS) {\n', '                        // The standard mining amount of ntoken is 1/100 of nest\n', '                        standard /= 100;\n', '                        // Genesis block number of ntoken is obtained separately\n', '                        (genesisBlock,) = INToken(ntokenAddress).checkBlockInfo();\n', '                    }\n', '\n', '                    return standard * _redution(block.number - genesisBlock);\n', '                }\n', '            }\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /// @dev Query the quantity of the target quotation\n', "    /// @param tokenAddress Token address. The token can't mine. Please make sure you don't use the token address when calling\n", '    /// @param index The index of the sheet\n', '    /// @return minedBlocks Mined block period from previous block\n', '    /// @return totalShares Total shares of sheets in the block\n', '    function getMinedBlocks(\n', '        address tokenAddress,\n', '        uint index\n', '    ) override external view returns (uint minedBlocks, uint totalShares) {\n', '\n', '        PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '        PriceSheet memory sheet = sheets[index];\n', '\n', "        // The bite sheet or ntoken sheet dosen't mining\n", '        if (uint(sheet.shares) == 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        return _calcMinedBlocks(sheets, index, sheet);\n', '    }\n', '\n', '    /* ========== Accounts ========== */\n', '\n', '    /// @dev Withdraw assets\n', '    /// @param tokenAddress Destination token address\n', '    /// @param value The value to withdraw\n', '    function withdraw(address tokenAddress, uint value) override external {\n', '\n', "        // The user's locked nest and the mining pool's nest are stored together. When the nest is mined over,\n", '        // the problem of taking the locked nest as the ore drawing will appear\n', '        // As it will take a long time for nest to finish mining, this problem will not be considered for the time being\n', '        UINT storage balance = _accounts[_accountMapping[msg.sender]].balances[tokenAddress];\n', '        //uint balanceValue = balance.value;\n', '        //require(balanceValue >= value, "NM:!balance");\n', '        balance.value -= value;\n', '\n', '        // ntoken mining\n', '        uint ntokenBalance = INToken(tokenAddress).balanceOf(address(this));\n', '        if (ntokenBalance < value) {\n', '            // mining\n', '            INToken(tokenAddress).increaseTotal(value - ntokenBalance);\n', '        }\n', '\n', '        TransferHelper.safeTransfer(tokenAddress, msg.sender, value);\n', '    }\n', '\n', '    /// @dev View the number of assets specified by the user\n', '    /// @param tokenAddress Destination token address\n', '    /// @param addr Destination address\n', '    /// @return Number of assets\n', '    function balanceOf(address tokenAddress, address addr) override external view returns (uint) {\n', '        return _accounts[_accountMapping[addr]].balances[tokenAddress].value;\n', '    }\n', '\n', '    /// @dev Gets the index number of the specified address. If it does not exist, register\n', '    /// @param addr Destination address\n', '    /// @return The index number of the specified address\n', '    function _addressIndex(address addr) private returns (uint) {\n', '\n', '        uint index = _accountMapping[addr];\n', '        if (index == 0) {\n', "            // If it exceeds the maximum number that 32 bits can store, you can't continue to register a new account.\n", '            // If you need to support a new account, you need to update the contract\n', '            require((_accountMapping[addr] = index = _accounts.length) < 0x100000000, "NM:!accounts");\n', '            _accounts.push().addr = addr;\n', '        }\n', '\n', '        return index;\n', '    }\n', '\n', '    /// @dev Gets the address corresponding to the given index number\n', '    /// @param index The index number of the specified address\n', '    /// @return The address corresponding to the given index number\n', '    function indexAddress(uint index) override public view returns (address) {\n', '        return _accounts[index].addr;\n', '    }\n', '\n', '    /// @dev Gets the registration index number of the specified address\n', '    /// @param addr Destination address\n', '    /// @return 0 means nonexistent, non-0 means index number\n', '    function getAccountIndex(address addr) override external view returns (uint) {\n', '        return _accountMapping[addr];\n', '    }\n', '\n', '    /// @dev Get the length of registered account array\n', '    /// @return The length of registered account array\n', '    function getAccountCount() override external view returns (uint) {\n', '        return _accounts.length;\n', '    }\n', '\n', '    /* ========== Asset management ========== */\n', '\n', '    /// @dev Freeze token\n', '    /// @param balances Balances ledger\n', '    /// @param tokenAddress Destination token address\n', '    /// @param value token amount\n', '    function _freeze(mapping(address=>UINT) storage balances, address tokenAddress, uint value) private {\n', '\n', '        UINT storage balance = balances[tokenAddress];\n', '        uint balanceValue = balance.value;\n', '        if (balanceValue < value) {\n', '            balance.value = 0;\n', '            TransferHelper.safeTransferFrom(tokenAddress, msg.sender, address(this), value - balanceValue);\n', '        } else {\n', '            balance.value = balanceValue - value;\n', '        }\n', '    }\n', '\n', '    /// @dev Unfreeze token\n', '    /// @param balances Balances ledgerBalances ledger\n', '    /// @param tokenAddress Destination token address\n', '    /// @param value token amount\n', '    function _unfreeze(mapping(address=>UINT) storage balances, address tokenAddress, uint value) private {\n', '        UINT storage balance = balances[tokenAddress];\n', '        balance.value += value;\n', '    }\n', '\n', '    /// @dev freeze token and nest\n', '    /// @param balances Balances ledger\n', '    /// @param tokenAddress Destination token address\n', '    /// @param tokenValue token amount \n', '    /// @param nestValue nest amount\n', '    function _freeze2(\n', '        mapping(address=>UINT) storage balances, \n', '        address tokenAddress, \n', '        uint tokenValue, \n', '        uint nestValue\n', '    ) private {\n', '\n', '        UINT storage balance;\n', '        uint balanceValue;\n', '\n', '        // If tokenAddress is NEST_TOKEN_ADDRESS, add it to nestValue\n', '        if (NEST_TOKEN_ADDRESS == tokenAddress) {\n', '            nestValue += tokenValue;\n', '        }\n', '        // tokenAddress is not NEST_TOKEN_ADDRESS, unfreeze it\n', '        else {\n', '            balance = balances[tokenAddress];\n', '            balanceValue = balance.value;\n', '            if (balanceValue < tokenValue) {\n', '                balance.value = 0;\n', '                TransferHelper.safeTransferFrom(tokenAddress, msg.sender, address(this), tokenValue - balanceValue);\n', '            } else {\n', '                balance.value = balanceValue - tokenValue;\n', '            }\n', '        }\n', '\n', '        // Unfreeze nest\n', '        balance = balances[NEST_TOKEN_ADDRESS];\n', '        balanceValue = balance.value;\n', '        if (balanceValue < nestValue) {\n', '            balance.value = 0;\n', '            TransferHelper.safeTransferFrom(NEST_TOKEN_ADDRESS, msg.sender, address(this), nestValue - balanceValue);\n', '        } else {\n', '            balance.value = balanceValue - nestValue;\n', '        }\n', '    }\n', '\n', '    /// @dev Unfreeze token, ntoken and nest\n', '    /// @param balances Balances ledger\n', '    /// @param tokenAddress Destination token address\n', '    /// @param tokenValue token amount\n', '    /// @param ntokenAddress Destination ntoken address\n', '    /// @param ntokenValue ntoken amount\n', '    /// @param nestValue nest amount\n', '    function _unfreeze3(\n', '        mapping(address=>UINT) storage balances,\n', '        address tokenAddress,\n', '        uint tokenValue,\n', '        address ntokenAddress,\n', '        uint ntokenValue,\n', '        uint nestValue\n', '    ) private {\n', '\n', '        UINT storage balance;\n', '        \n', '        // If tokenAddress is ntokenAddress, add it to ntokenValue\n', '        if (ntokenAddress == tokenAddress) {\n', '            ntokenValue += tokenValue;\n', '        }\n', '        // tokenAddress is not ntokenAddress, unfreeze it\n', '        else {\n', '            balance = balances[tokenAddress];\n', '            balance.value += tokenValue;\n', '        }\n', '\n', '        // If ntokenAddress is NEST_TOKEN_ADDRESS, add it to nestValue\n', '        if (NEST_TOKEN_ADDRESS == ntokenAddress) {\n', '            nestValue += ntokenValue;\n', '        }\n', '        // ntokenAddress is NEST_TOKEN_ADDRESS, unfreeze it\n', '        else {\n', '            balance = balances[ntokenAddress];\n', '            balance.value += ntokenValue;\n', '        }\n', '\n', '        // Unfreeze nest\n', '        balance = balances[NEST_TOKEN_ADDRESS];\n', '        balance.value += nestValue;\n', '    }\n', '\n', '    /* ========== INestQuery ========== */\n', '    \n', '    // Check msg.sender\n', '    function _check() private view {\n', '        require(msg.sender == _nestPriceFacadeAddress || msg.sender == tx.origin);\n', '    }\n', '\n', '    /// @dev Get the latest trigger price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function triggeredPrice(address tokenAddress) override public view returns (uint blockNumber, uint price) {\n', '\n', '        _check();\n', '        PriceInfo memory priceInfo = _channels[tokenAddress].price;\n', '\n', '        if (uint(priceInfo.remainNum) > 0) {\n', '            return (uint(priceInfo.height) + uint(_config.priceEffectSpan), decodeFloat(priceInfo.priceFloat));\n', '        }\n', '        \n', '        return (0, 0);\n', '    }\n', '\n', '    /// @dev Get the full information of latest trigger price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo(address tokenAddress) override public view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint avgPrice,\n', '        uint sigmaSQ\n', '    ) {\n', '\n', '        _check();\n', '        PriceInfo memory priceInfo = _channels[tokenAddress].price;\n', '\n', '        if (uint(priceInfo.remainNum) > 0) {\n', '            return (\n', '                uint(priceInfo.height) + uint(_config.priceEffectSpan),\n', '                decodeFloat(priceInfo.priceFloat),\n', '                decodeFloat(priceInfo.avgFloat),\n', '                (uint(priceInfo.sigmaSQ) * 1 ether) >> 48\n', '            );\n', '        }\n', '\n', '        return (0, 0, 0, 0);\n', '    }\n', '\n', '    /// @dev Find the price at block number\n', '    /// @param tokenAddress Destination token address\n', '    /// @param height Destination block number\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function findPrice(\n', '        address tokenAddress,\n', '        uint height\n', '    ) override external view returns (uint blockNumber, uint price) {\n', '\n', '        _check();\n', '        PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '        uint priceEffectSpan = uint(_config.priceEffectSpan);\n', '\n', '        uint length = sheets.length;\n', '        uint index = 0;\n', '        uint sheetHeight;\n', '        height -= priceEffectSpan;\n', '        {\n', '            // If there is no sheet in this channel, length is 0, length - 1 will overflow,\n', '            uint right = length - 1;\n', '            uint left = 0;\n', '            // Find the index use Binary Search\n', '            while (left < right) {\n', '\n', '                index = (left + right) >> 1;\n', '                sheetHeight = uint(sheets[index].height);\n', '                if (height > sheetHeight) {\n', '                    left = ++index;\n', '                } else if (height < sheetHeight) {\n', '                    // When index = 0, this statement will have an underflow exception, which usually \n', '                    // indicates that the effective block height passed during the call is lower than \n', '                    // the block height of the first quotation\n', '                    right = --index;\n', '                } else {\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Calculate price\n', '        uint totalEthNum = 0;\n', '        uint totalTokenValue = 0;\n', '        uint h = 0;\n', '        uint remainNum;\n', '        PriceSheet memory sheet;\n', '\n', '        // Find sheets forward\n', '        for (uint i = index; i < length;) {\n', '\n', '            sheet = sheets[i++];\n', '            sheetHeight = uint(sheet.height);\n', '            if (height < sheetHeight) {\n', '                break;\n', '            }\n', '            remainNum = uint(sheet.remainNum);\n', '            if (remainNum > 0) {\n', '                if (h == 0) {\n', '                    h = sheetHeight;\n', '                } else if (h != sheetHeight) {\n', '                    break;\n', '                }\n', '                totalEthNum += remainNum;\n', '                totalTokenValue += decodeFloat(sheet.priceFloat) * remainNum;\n', '            }\n', '        }\n', '\n', '        // Find sheets backward\n', '        while (index > 0) {\n', '\n', '            sheet = sheets[--index];\n', '            remainNum = uint(sheet.remainNum);\n', '            if (remainNum > 0) {\n', '                sheetHeight = uint(sheet.height);\n', '                if (h == 0) {\n', '                    h = sheetHeight;\n', '                } else if (h != sheetHeight) {\n', '                    break;\n', '                }\n', '                totalEthNum += remainNum;\n', '                totalTokenValue += decodeFloat(sheet.priceFloat) * remainNum;\n', '            }\n', '        }\n', '\n', '        if (totalEthNum > 0) {\n', '            return (h + priceEffectSpan, totalTokenValue / totalEthNum);\n', '        }\n', '        return (0, 0);\n', '    }\n', '\n', '    /// @dev Get the latest effective price\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    function latestPrice(address tokenAddress) override public view returns (uint blockNumber, uint price) {\n', '\n', '        _check();\n', '        PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '        PriceSheet memory sheet;\n', '\n', '        uint priceEffectSpan = uint(_config.priceEffectSpan);\n', '        uint h = block.number - priceEffectSpan;\n', '        uint index = sheets.length;\n', '        uint totalEthNum = 0;\n', '        uint totalTokenValue = 0;\n', '        uint height = 0;\n', '\n', '        for (; ; ) {\n', '\n', '            bool flag = index == 0;\n', '            if (flag || height != uint((sheet = sheets[--index]).height)) {\n', '                if (totalEthNum > 0 && height <= h) {\n', '                    return (height + priceEffectSpan, totalTokenValue / totalEthNum);\n', '                }\n', '                if (flag) {\n', '                    break;\n', '                }\n', '                totalEthNum = 0;\n', '                totalTokenValue = 0;\n', '                height = uint(sheet.height);\n', '            }\n', '\n', '            uint remainNum = uint(sheet.remainNum);\n', '            totalEthNum += remainNum;\n', '            totalTokenValue += decodeFloat(sheet.priceFloat) * remainNum;\n', '        }\n', '\n', '        return (0, 0);\n', '    }\n', '\n', '    /// @dev Get the last (num) effective price\n', '    /// @param tokenAddress Destination token address\n', '    /// @param count The number of prices that want to return\n', '    /// @return An array which length is num * 2, each two element expresses one price like blockNumber｜price\n', '    function lastPriceList(address tokenAddress, uint count) override public view returns (uint[] memory) {\n', '\n', '        _check();\n', '        PriceSheet[] storage sheets = _channels[tokenAddress].sheets;\n', '        PriceSheet memory sheet;\n', '        uint[] memory array = new uint[](count <<= 1);\n', '\n', '        uint priceEffectSpan = uint(_config.priceEffectSpan);\n', '        uint h = block.number - priceEffectSpan;\n', '        uint index = sheets.length;\n', '        uint totalEthNum = 0;\n', '        uint totalTokenValue = 0;\n', '        uint height = 0;\n', '\n', '        for (uint i = 0; i < count;) {\n', '\n', '            bool flag = index == 0;\n', '            if (flag || height != uint((sheet = sheets[--index]).height)) {\n', '                if (totalEthNum > 0 && height <= h) {\n', '                    array[i++] = height + priceEffectSpan;\n', '                    array[i++] = totalTokenValue / totalEthNum;\n', '                }\n', '                if (flag) {\n', '                    break;\n', '                }\n', '                totalEthNum = 0;\n', '                totalTokenValue = 0;\n', '                height = uint(sheet.height);\n', '            }\n', '\n', '            uint remainNum = uint(sheet.remainNum);\n', '            totalEthNum += remainNum;\n', '            totalTokenValue += decodeFloat(sheet.priceFloat) * remainNum;\n', '        }\n', '\n', '        return array;\n', '    } \n', '\n', '    /// @dev Returns the results of latestPrice() and triggeredPriceInfo()\n', '    /// @param tokenAddress Destination token address\n', '    /// @return latestPriceBlockNumber The block number of latest price\n', '    /// @return latestPriceValue The token latest price. (1eth equivalent to (price) token)\n', '    /// @return triggeredPriceBlockNumber The block number of triggered price\n', '    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\n', '    /// @return triggeredAvgPrice Average price\n', '    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function latestPriceAndTriggeredPriceInfo(address tokenAddress) override external view \n', '    returns (\n', '        uint latestPriceBlockNumber,\n', '        uint latestPriceValue,\n', '        uint triggeredPriceBlockNumber,\n', '        uint triggeredPriceValue,\n', '        uint triggeredAvgPrice,\n', '        uint triggeredSigmaSQ\n', '    ) {\n', '        (latestPriceBlockNumber, latestPriceValue) = latestPrice(tokenAddress);\n', '        (\n', '            triggeredPriceBlockNumber, \n', '            triggeredPriceValue, \n', '            triggeredAvgPrice, \n', '            triggeredSigmaSQ\n', '        ) = triggeredPriceInfo(tokenAddress);\n', '    }\n', '\n', '    /// @dev Returns lastPriceList and triggered price info\n', '    /// @param tokenAddress Destination token address\n', '    /// @param count The number of prices that want to return\n', '    /// @return prices An array which length is num * 2, each two element expresses one price like blockNumber｜price\n', '    /// @return triggeredPriceBlockNumber The block number of triggered price\n', '    /// @return triggeredPriceValue The token triggered price. (1eth equivalent to (price) token)\n', '    /// @return triggeredAvgPrice Average price\n', '    /// @return triggeredSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function lastPriceListAndTriggeredPriceInfo(address tokenAddress, uint count) override external view \n', '    returns (\n', '        uint[] memory prices,\n', '        uint triggeredPriceBlockNumber,\n', '        uint triggeredPriceValue,\n', '        uint triggeredAvgPrice,\n', '        uint triggeredSigmaSQ\n', '    ) {\n', '        prices = lastPriceList(tokenAddress, count);\n', '        (\n', '            triggeredPriceBlockNumber, \n', '            triggeredPriceValue, \n', '            triggeredAvgPrice, \n', '            triggeredSigmaSQ\n', '        ) = triggeredPriceInfo(tokenAddress);\n', '    }\n', '\n', '    /// @dev Get the latest trigger price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    function triggeredPrice2(address tokenAddress) override external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice\n', '    ) {\n', '        (blockNumber, price) = triggeredPrice(tokenAddress);\n', '        (ntokenBlockNumber, ntokenPrice) = triggeredPrice(_addressCache[tokenAddress]);\n', '    }\n', '\n', '    /// @dev Get the full information of latest trigger price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447, \n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    /// @return ntokenAvgPrice Average price of ntoken\n', '    /// @return ntokenSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that\n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo2(address tokenAddress) override external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint avgPrice,\n', '        uint sigmaSQ,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice,\n', '        uint ntokenAvgPrice,\n', '        uint ntokenSigmaSQ\n', '    ) {\n', '        (blockNumber, price, avgPrice, sigmaSQ) = triggeredPriceInfo(tokenAddress);\n', '        (\n', '            ntokenBlockNumber,\n', '            ntokenPrice,\n', '            ntokenAvgPrice,\n', '            ntokenSigmaSQ\n', '        ) = triggeredPriceInfo(_addressCache[tokenAddress]);\n', '    }\n', '\n', '    /// @dev Get the latest effective price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    function latestPrice2(address tokenAddress) override external view returns (\n', '        uint blockNumber,\n', '        uint price,\n', '        uint ntokenBlockNumber,\n', '        uint ntokenPrice\n', '    ) {\n', '        (blockNumber, price) = latestPrice(tokenAddress);\n', '        (ntokenBlockNumber, ntokenPrice) = latestPrice(_addressCache[tokenAddress]);\n', '    }\n', '\n', '    /* ========== Tools and methods ========== */\n', '\n', '    /// @dev Encode the uint value as a floating-point representation in the form of fraction * 16 ^ exponent\n', '    /// @param value Destination uint value\n', '    /// @return float format\n', '    function encodeFloat(uint value) private pure returns (uint56) {\n', '\n', '        uint exponent = 0; \n', '        while (value > 0x3FFFFFFFFFFFF) {\n', '            value >>= 4;\n', '            ++exponent;\n', '        }\n', '        return uint56((value << 6) | exponent);\n', '    }\n', '\n', '    /// @dev Decode the floating-point representation of fraction * 16 ^ exponent to uint\n', '    /// @param floatValue fraction value\n', '    /// @return decode format\n', '    function decodeFloat(uint56 floatValue) private pure returns (uint) {\n', '        return (uint(floatValue) >> 6) << ((uint(floatValue) & 0x3F) << 2);\n', '    }\n', '}']