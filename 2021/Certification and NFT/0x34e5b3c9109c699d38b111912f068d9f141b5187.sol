['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-27\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    function decimals() external view returns (uint256 digits);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}  library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}  library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}  library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     */\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '} \n', '\n', '\n', '\n', 'abstract contract IAaveProtocolDataProviderV2 {\n', '\n', '  struct TokenData {\n', '    string symbol;\n', '    address tokenAddress;\n', '  }\n', '\n', '  function getAllReservesTokens() external virtual view returns (TokenData[] memory);\n', '\n', '  function getAllATokens() external virtual view returns (TokenData[] memory);\n', '\n', '  function getReserveConfigurationData(address asset)\n', '    external virtual\n', '    view\n', '    returns (\n', '      uint256 decimals,\n', '      uint256 ltv,\n', '      uint256 liquidationThreshold,\n', '      uint256 liquidationBonus,\n', '      uint256 reserveFactor,\n', '      bool usageAsCollateralEnabled,\n', '      bool borrowingEnabled,\n', '      bool stableBorrowRateEnabled,\n', '      bool isActive,\n', '      bool isFrozen\n', '    );\n', '\n', '  function getReserveData(address asset)\n', '    external virtual\n', '    view\n', '    returns (\n', '      uint256 availableLiquidity,\n', '      uint256 totalStableDebt,\n', '      uint256 totalVariableDebt,\n', '      uint256 liquidityRate,\n', '      uint256 variableBorrowRate,\n', '      uint256 stableBorrowRate,\n', '      uint256 averageStableBorrowRate,\n', '      uint256 liquidityIndex,\n', '      uint256 variableBorrowIndex,\n', '      uint40 lastUpdateTimestamp\n', '    );\n', '\n', '  function getUserReserveData(address asset, address user)\n', '    external virtual\n', '    view\n', '    returns (\n', '      uint256 currentATokenBalance,\n', '      uint256 currentStableDebt,\n', '      uint256 currentVariableDebt,\n', '      uint256 principalStableDebt,\n', '      uint256 scaledVariableDebt,\n', '      uint256 stableBorrowRate,\n', '      uint256 liquidityRate,\n', '      uint40 stableRateLastUpdated,\n', '      bool usageAsCollateralEnabled\n', '    );\n', '\n', '  function getReserveTokensAddresses(address asset)\n', '    external virtual\n', '    view\n', '    returns (\n', '      address aTokenAddress,\n', '      address stableDebtTokenAddress,\n', '      address variableDebtTokenAddress\n', '    );\n', '} \n', '\n', '  \n', '\n', '/**\n', ' * @title LendingPoolAddressesProvider contract\n', ' * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n', ' * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n', ' * - Owned by the Aave Governance\n', ' * @author Aave\n', ' **/\n', 'interface ILendingPoolAddressesProviderV2 {\n', '  event LendingPoolUpdated(address indexed newAddress);\n', '  event ConfigurationAdminUpdated(address indexed newAddress);\n', '  event EmergencyAdminUpdated(address indexed newAddress);\n', '  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n', '  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n', '  event PriceOracleUpdated(address indexed newAddress);\n', '  event LendingRateOracleUpdated(address indexed newAddress);\n', '  event ProxyCreated(bytes32 id, address indexed newAddress);\n', '  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n', '\n', '  function setAddress(bytes32 id, address newAddress) external;\n', '\n', '  function setAddressAsProxy(bytes32 id, address impl) external;\n', '\n', '  function getAddress(bytes32 id) external view returns (address);\n', '\n', '  function getLendingPool() external view returns (address);\n', '\n', '  function setLendingPoolImpl(address pool) external;\n', '\n', '  function getLendingPoolConfigurator() external view returns (address);\n', '\n', '  function setLendingPoolConfiguratorImpl(address configurator) external;\n', '\n', '  function getLendingPoolCollateralManager() external view returns (address);\n', '\n', '  function setLendingPoolCollateralManager(address manager) external;\n', '\n', '  function getPoolAdmin() external view returns (address);\n', '\n', '  function setPoolAdmin(address admin) external;\n', '\n', '  function getEmergencyAdmin() external view returns (address);\n', '\n', '  function setEmergencyAdmin(address admin) external;\n', '\n', '  function getPriceOracle() external view returns (address);\n', '\n', '  function setPriceOracle(address priceOracle) external;\n', '\n', '  function getLendingRateOracle() external view returns (address);\n', '\n', '  function setLendingRateOracle(address lendingRateOracle) external;\n', '}\n', '\n', 'library DataTypes {\n', '  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n', '  struct ReserveData {\n', '    //stores the reserve configuration\n', '    ReserveConfigurationMap configuration;\n', '    //the liquidity index. Expressed in ray\n', '    uint128 liquidityIndex;\n', '    //variable borrow index. Expressed in ray\n', '    uint128 variableBorrowIndex;\n', '    //the current supply rate. Expressed in ray\n', '    uint128 currentLiquidityRate;\n', '    //the current variable borrow rate. Expressed in ray\n', '    uint128 currentVariableBorrowRate;\n', '    //the current stable borrow rate. Expressed in ray\n', '    uint128 currentStableBorrowRate;\n', '    uint40 lastUpdateTimestamp;\n', '    //tokens addresses\n', '    address aTokenAddress;\n', '    address stableDebtTokenAddress;\n', '    address variableDebtTokenAddress;\n', '    //address of the interest rate strategy\n', '    address interestRateStrategyAddress;\n', '    //the id of the reserve. Represents the position in the list of the active reserves\n', '    uint8 id;\n', '  }\n', '\n', '  struct ReserveConfigurationMap {\n', '    //bit 0-15: LTV\n', '    //bit 16-31: Liq. threshold\n', '    //bit 32-47: Liq. bonus\n', '    //bit 48-55: Decimals\n', '    //bit 56: Reserve is active\n', '    //bit 57: reserve is frozen\n', '    //bit 58: borrowing is enabled\n', '    //bit 59: stable rate borrowing enabled\n', '    //bit 60-63: reserved\n', '    //bit 64-79: reserve factor\n', '    uint256 data;\n', '  }\n', '\n', '  struct UserConfigurationMap {\n', '    uint256 data;\n', '  }\n', '\n', '  enum InterestRateMode {NONE, STABLE, VARIABLE}\n', '}\n', '\n', 'interface ILendingPoolV2 {\n', '  /**\n', '   * @dev Emitted on deposit()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The address initiating the deposit\n', '   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n', '   * @param amount The amount deposited\n', '   * @param referral The referral code used\n', '   **/\n', '  event Deposit(\n', '    address indexed reserve,\n', '    address user,\n', '    address indexed onBehalfOf,\n', '    uint256 amount,\n', '    uint16 indexed referral\n', '  );\n', '\n', '  /**\n', '   * @dev Emitted on withdraw()\n', '   * @param reserve The address of the underlyng asset being withdrawn\n', '   * @param user The address initiating the withdrawal, owner of aTokens\n', '   * @param to Address that will receive the underlying\n', '   * @param amount The amount to be withdrawn\n', '   **/\n', '  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n', '\n', '  /**\n', '   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n', '   * @param reserve The address of the underlying asset being borrowed\n', '   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n', '   * initiator of the transaction on flashLoan()\n', '   * @param onBehalfOf The address that will be getting the debt\n', '   * @param amount The amount borrowed out\n', '   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n', '   * @param borrowRate The numeric rate at which the user has borrowed\n', '   * @param referral The referral code used\n', '   **/\n', '  event Borrow(\n', '    address indexed reserve,\n', '    address user,\n', '    address indexed onBehalfOf,\n', '    uint256 amount,\n', '    uint256 borrowRateMode,\n', '    uint256 borrowRate,\n', '    uint16 indexed referral\n', '  );\n', '\n', '  /**\n', '   * @dev Emitted on repay()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The beneficiary of the repayment, getting his debt reduced\n', '   * @param repayer The address of the user initiating the repay(), providing the funds\n', '   * @param amount The amount repaid\n', '   **/\n', '  event Repay(\n', '    address indexed reserve,\n', '    address indexed user,\n', '    address indexed repayer,\n', '    uint256 amount\n', '  );\n', '\n', '  /**\n', '   * @dev Emitted on swapBorrowRateMode()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The address of the user swapping his rate mode\n', '   * @param rateMode The rate mode that the user wants to swap to\n', '   **/\n', '  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n', '\n', '  /**\n', '   * @dev Emitted on setUserUseReserveAsCollateral()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The address of the user enabling the usage as collateral\n', '   **/\n', '  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n', '\n', '  /**\n', '   * @dev Emitted on setUserUseReserveAsCollateral()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The address of the user enabling the usage as collateral\n', '   **/\n', '  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n', '\n', '  /**\n', '   * @dev Emitted on rebalanceStableBorrowRate()\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param user The address of the user for which the rebalance has been executed\n', '   **/\n', '  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n', '\n', '  /**\n', '   * @dev Emitted on flashLoan()\n', '   * @param target The address of the flash loan receiver contract\n', '   * @param initiator The address initiating the flash loan\n', '   * @param asset The address of the asset being flash borrowed\n', '   * @param amount The amount flash borrowed\n', '   * @param premium The fee flash borrowed\n', '   * @param referralCode The referral code used\n', '   **/\n', '  event FlashLoan(\n', '    address indexed target,\n', '    address indexed initiator,\n', '    address indexed asset,\n', '    uint256 amount,\n', '    uint256 premium,\n', '    uint16 referralCode\n', '  );\n', '\n', '  /**\n', '   * @dev Emitted when the pause is triggered.\n', '   */\n', '  event Paused();\n', '\n', '  /**\n', '   * @dev Emitted when the pause is lifted.\n', '   */\n', '  event Unpaused();\n', '\n', '  /**\n', '   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n', '   * LendingPoolCollateral manager using a DELEGATECALL\n', '   * This allows to have the events in the generated ABI for LendingPool.\n', '   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n', '   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n', '   * @param user The address of the borrower getting liquidated\n', '   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n', '   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n', '   * @param liquidator The address of the liquidator\n', '   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n', '   * to receive the underlying collateral asset directly\n', '   **/\n', '  event LiquidationCall(\n', '    address indexed collateralAsset,\n', '    address indexed debtAsset,\n', '    address indexed user,\n', '    uint256 debtToCover,\n', '    uint256 liquidatedCollateralAmount,\n', '    address liquidator,\n', '    bool receiveAToken\n', '  );\n', '\n', '  /**\n', '   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n', '   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n', '   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n', '   * gets added to the LendingPool ABI\n', '   * @param reserve The address of the underlying asset of the reserve\n', '   * @param liquidityRate The new liquidity rate\n', '   * @param stableBorrowRate The new stable borrow rate\n', '   * @param variableBorrowRate The new variable borrow rate\n', '   * @param liquidityIndex The new liquidity index\n', '   * @param variableBorrowIndex The new variable borrow index\n', '   **/\n', '  event ReserveDataUpdated(\n', '    address indexed reserve,\n', '    uint256 liquidityRate,\n', '    uint256 stableBorrowRate,\n', '    uint256 variableBorrowRate,\n', '    uint256 liquidityIndex,\n', '    uint256 variableBorrowIndex\n', '  );\n', '\n', '  /**\n', '   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n', '   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n', '   * @param asset The address of the underlying asset to deposit\n', '   * @param amount The amount to be deposited\n', '   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n', '   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n', '   *   is a different wallet\n', '   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n', '   *   0 if the action is executed directly by the user, without any middle-man\n', '   **/\n', '  function deposit(\n', '    address asset,\n', '    uint256 amount,\n', '    address onBehalfOf,\n', '    uint16 referralCode\n', '  ) external;\n', '\n', '  /**\n', '   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n', '   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n', '   * @param asset The address of the underlying asset to withdraw\n', '   * @param amount The underlying amount to be withdrawn\n', '   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n', '   * @param to Address that will receive the underlying, same as msg.sender if the user\n', '   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n', '   *   different wallet\n', '   **/\n', '  function withdraw(\n', '    address asset,\n', '    uint256 amount,\n', '    address to\n', '  ) external;\n', '\n', '  /**\n', '   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n', '   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n', '   * corresponding debt token (StableDebtToken or VariableDebtToken)\n', '   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n', '   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n', '   * @param asset The address of the underlying asset to borrow\n', '   * @param amount The amount to be borrowed\n', '   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n', '   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n', '   *   0 if the action is executed directly by the user, without any middle-man\n', '   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n', '   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n', '   * if he has been given credit delegation allowance\n', '   **/\n', '  function borrow(\n', '    address asset,\n', '    uint256 amount,\n', '    uint256 interestRateMode,\n', '    uint16 referralCode,\n', '    address onBehalfOf\n', '  ) external;\n', '\n', '  /**\n', '   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n', '   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n', '   * @param asset The address of the borrowed underlying asset previously borrowed\n', '   * @param amount The amount to repay\n', '   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n', '   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n', '   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n', '   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n', '   * other borrower whose debt should be removed\n', '   **/\n', '  function repay(\n', '    address asset,\n', '    uint256 amount,\n', '    uint256 rateMode,\n', '    address onBehalfOf\n', '  ) external;\n', '\n', '  /**\n', '   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n', '   * @param asset The address of the underlying asset borrowed\n', '   * @param rateMode The rate mode that the user wants to swap to\n', '   **/\n', '  function swapBorrowRateMode(address asset, uint256 rateMode) external;\n', '\n', '  /**\n', '   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n', '   * - Users can be rebalanced if the following conditions are satisfied:\n', '   *     1. Usage ratio is above 95%\n', '   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n', '   *        borrowed at a stable rate and depositors are not earning enough\n', '   * @param asset The address of the underlying asset borrowed\n', '   * @param user The address of the user to be rebalanced\n', '   **/\n', '  function rebalanceStableBorrowRate(address asset, address user) external;\n', '\n', '  /**\n', '   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n', '   * @param asset The address of the underlying asset deposited\n', '   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n', '   **/\n', '  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n', '\n', '  /**\n', '   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n', '   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n', '   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n', '   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n', '   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n', '   * @param user The address of the borrower getting liquidated\n', '   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n', '   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n', '   * to receive the underlying collateral asset directly\n', '   **/\n', '  function liquidationCall(\n', '    address collateralAsset,\n', '    address debtAsset,\n', '    address user,\n', '    uint256 debtToCover,\n', '    bool receiveAToken\n', '  ) external;\n', '\n', '  /**\n', '   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n', '   * as long as the amount taken plus a fee is returned.\n', '   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n', '   * For further details please visit https://developers.aave.com\n', '   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n', '   * @param assets The addresses of the assets being flash-borrowed\n', '   * @param amounts The amounts amounts being flash-borrowed\n', '   * @param modes Types of the debt to open if the flash loan is not returned:\n', "   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n", '   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n', '   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n', '   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n', '   * @param params Variadic packed params to pass to the receiver as extra information\n', '   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n', '   *   0 if the action is executed directly by the user, without any middle-man\n', '   **/\n', '  function flashLoan(\n', '    address receiverAddress,\n', '    address[] calldata assets,\n', '    uint256[] calldata amounts,\n', '    uint256[] calldata modes,\n', '    address onBehalfOf,\n', '    bytes calldata params,\n', '    uint16 referralCode\n', '  ) external;\n', '\n', '  /**\n', '   * @dev Returns the user account data across all the reserves\n', '   * @param user The address of the user\n', '   * @return totalCollateralETH the total collateral in ETH of the user\n', '   * @return totalDebtETH the total debt in ETH of the user\n', '   * @return availableBorrowsETH the borrowing power left of the user\n', '   * @return currentLiquidationThreshold the liquidation threshold of the user\n', '   * @return ltv the loan to value of the user\n', '   * @return healthFactor the current health factor of the user\n', '   **/\n', '  function getUserAccountData(address user)\n', '    external\n', '    view\n', '    returns (\n', '      uint256 totalCollateralETH,\n', '      uint256 totalDebtETH,\n', '      uint256 availableBorrowsETH,\n', '      uint256 currentLiquidationThreshold,\n', '      uint256 ltv,\n', '      uint256 healthFactor\n', '    );\n', '\n', '  function initReserve(\n', '    address reserve,\n', '    address aTokenAddress,\n', '    address stableDebtAddress,\n', '    address variableDebtAddress,\n', '    address interestRateStrategyAddress\n', '  ) external;\n', '\n', '  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\n', '    external;\n', '\n', '  function setConfiguration(address reserve, uint256 configuration) external;\n', '\n', '  /**\n', '   * @dev Returns the configuration of the reserve\n', '   * @param asset The address of the underlying asset of the reserve\n', '   * @return The configuration of the reserve\n', '   **/\n', '  function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n', '\n', '  /**\n', '   * @dev Returns the configuration of the user across all the reserves\n', '   * @param user The user address\n', '   * @return The configuration of the user\n', '   **/\n', '  function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n', '\n', '  /**\n', '   * @dev Returns the normalized income normalized income of the reserve\n', '   * @param asset The address of the underlying asset of the reserve\n', "   * @return The reserve's normalized income\n", '   */\n', '  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the normalized variable debt per unit of asset\n', '   * @param asset The address of the underlying asset of the reserve\n', '   * @return The reserve normalized variable debt\n', '   */\n', '  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the state and configuration of the reserve\n', '   * @param asset The address of the underlying asset of the reserve\n', '   * @return The state of the reserve\n', '   **/\n', '  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n', '\n', '  function finalizeTransfer(\n', '    address asset,\n', '    address from,\n', '    address to,\n', '    uint256 amount,\n', '    uint256 balanceFromAfter,\n', '    uint256 balanceToBefore\n', '  ) external;\n', '\n', '  function getReservesList() external view returns (address[] memory);\n', '\n', '  function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);\n', '\n', '  function setPause(bool val) external;\n', '\n', '  function paused() external view returns (bool);\n', '}  abstract contract TokenInterface {\n', '\taddress public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    \n', '    function allowance(address, address) public virtual returns (uint256);\n', '\n', '    function balanceOf(address) public virtual returns (uint256);\n', '\n', '    function approve(address, uint256) public virtual;\n', '\n', '    function transfer(address, uint256) public virtual returns (bool);\n', '\n', '    function transferFrom(address, address, uint256) public virtual returns (bool);\n', '\n', '    function deposit() public virtual payable;\n', '\n', '    function withdraw(uint256) public virtual;\n', '}  abstract contract IAToken {\n', '    function redeem(uint256 _amount) external virtual;\n', '    function balanceOf(address _owner) external virtual view returns (uint256 balance);\n', '}  abstract contract ILendingPool {\n', '    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n', '    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n', '\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n', '\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n', '\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\n', '\tfunction swapBorrowRateMode(address _reserve) external virtual;\n', '    function getReserves() external virtual view returns(address[] memory);\n', '\n', '    /// @param _reserve underlying token address\n', '    function getReserveData(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidity,               // reserve total liquidity\n', '            uint256 availableLiquidity,           // reserve available liquidity for borrowing\n', '            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\n', '            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\n', '            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\n', '            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\n', '            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\n', '            uint256 averageStableBorrowRate,      // current average stable borrow rate\n', '            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\n', '            uint256 liquidityIndex,               // cumulative liquidity index\n', '            uint256 variableBorrowIndex,          // cumulative variable borrow index\n', '            address aTokenAddress,                // aTokens contract address for the specific _reserve\n', '            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\n', '        );\n', '\n', '    /// @param _user users address\n', '    function getUserAccountData(address _user)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\n', '            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\n', '            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\n', '            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\n', '            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\n', '            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\n', '            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\n', '            uint256 healthFactor                  // user current Health Factor\n', '    );\n', '\n', '    /// @param _reserve underlying token address\n', '    /// @param _user users address\n', '    function getUserReserveData(address _reserve, address _user)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 currentATokenBalance,         // user current reserve aToken balance\n', '            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\n', '            uint256 principalBorrowBalance,       // user balance of borrowed asset\n', '            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\n', '            uint256 borrowRate,                   // user current borrow rate APY\n', '            uint256 liquidityRate,                // user current earn rate on _reserve\n', '            uint256 originationFee,               // user outstanding loan origination fee\n', '            uint256 variableBorrowIndex,          // user variable cumulative index\n', '            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\n', "            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\n", '    );\n', '\n', '    function getReserveConfigurationData(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 ltv,\n', '            uint256 liquidationThreshold,\n', '            uint256 liquidationBonus,\n', '            address rateStrategyAddress,\n', '            bool usageAsCollateralEnabled,\n', '            bool borrowingEnabled,\n', '            bool stableBorrowRateEnabled,\n', '            bool isActive\n', '    );\n', '\n', '    // ------------------ LendingPoolCoreData ------------------------\n', '    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\n', '    function getReserveConfiguration(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (uint256, uint256, uint256, bool);\n', '    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    function getReserveCurrentLiquidityRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveCurrentVariableBorrowRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveCurrentStableBorrowRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalLiquidity(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveAvailableLiquidity(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalBorrowsVariable(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalBorrowsStable(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    // ---------------- LendingPoolDataProvider ---------------------\n', '    function calculateUserGlobalData(address _user)\n', '        public virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidityBalanceETH,\n', '            uint256 totalCollateralBalanceETH,\n', '            uint256 totalBorrowBalanceETH,\n', '            uint256 totalFeesETH,\n', '            uint256 currentLtv,\n', '            uint256 currentLiquidationThreshold,\n', '            uint256 healthFactor,\n', '            bool healthFactorBelowThreshold\n', '        );\n', '}  /**\n', '@title ILendingPoolAddressesProvider interface\n', '@notice provides the interface to fetch the LendingPoolCore address\n', ' */\n', 'abstract contract ILendingPoolAddressesProvider {\n', '\n', '    function getLendingPool() public virtual view returns (address);\n', '    function getLendingPoolCore() public virtual view returns (address payable);\n', '    function getLendingPoolConfigurator() public virtual view returns (address);\n', '    function getLendingPoolDataProvider() public virtual view returns (address);\n', '    function getLendingPoolParametersProvider() public virtual view returns (address);\n', '    function getTokenDistributor() public virtual view returns (address);\n', '    function getFeeProvider() public virtual view returns (address);\n', '    function getLendingPoolLiquidationManager() public virtual view returns (address);\n', '    function getLendingPoolManager() public virtual view returns (address);\n', '    function getPriceOracle() public virtual view returns (address);\n', '    function getLendingRateOracle() public virtual view returns (address);\n', '} \n', '\n', '\n', '  \n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AaveMigration {\n', '    using SafeERC20 for ERC20;\n', '\n', '    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '    uint16 public constant AAVE_REFERRAL_CODE = 64;\n', '\n', '    address public constant AAVE_V1_LENDING_POOL_ADDRESSES =\n', '        0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n', '\n', '    struct MigrateLoanData {\n', '        address market;\n', '        address[] collAssets;\n', '        bool[] isColl;\n', '        address[] borrowAssets;\n', '        uint256[] borrowAmounts;\n', '        uint256[] fees;\n', '        uint256[] modes;\n', '    }\n', '\n', '    function migrateLoan(MigrateLoanData memory _loanData) public {\n', '        address lendingPoolCoreV1 =\n', '            ILendingPoolAddressesProvider(AAVE_V1_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n', '\n', '        address lendingPoolV2 = ILendingPoolAddressesProviderV2(_loanData.market).getLendingPool();\n', '\n', '        // payback AaveV1 loans\n', '        for (uint256 i = 0; i < _loanData.borrowAssets.length; ++i) {\n', '            paybackAaveV1(lendingPoolCoreV1, _loanData.borrowAssets[i], _loanData.borrowAmounts[i]);\n', '        }\n', '\n', '        // withdraw from AaveV1 and deposit to V2\n', '        for (uint256 i = 0; i < _loanData.collAssets.length; ++i) {\n', '            address aTokenAddr =\n', '                ILendingPool(lendingPoolCoreV1).getReserveATokenAddress(_loanData.collAssets[i]);\n', '\n', '            uint256 withdrawnAmount = withdrawAaveV1(aTokenAddr);\n', '\n', '            depositAaveV2(\n', '                lendingPoolV2,\n', '                _loanData.market,\n', '                _loanData.collAssets[i],\n', '                withdrawnAmount,\n', '                _loanData.isColl[i]\n', '\n', '            );\n', '        }\n', '\n', '        // borrow debt from AaveV2\n', '        // for (uint256 i = 0; i < _loanData.borrowAssets.length; ++i) {\n', '        //     borrowAaveV2(\n', '        //         lendingPoolV2,\n', '        //         _loanData.borrowAssets[i],\n', '        //         (_loanData.borrowAmounts[i] + _loanData.fees[i]),\n', '        //         _loanData.modes[i]\n', '        //     );\n', '        // }\n', '    }\n', '\n', '    function depositAaveV2(\n', '        address _lendingPoolV2,\n', '        address _market,\n', '        address _tokenAddr,\n', '        uint256 _amount,\n', '        bool _isColl\n', '    ) internal {\n', '        // handle weth\n', '        if (_tokenAddr == ETH_ADDR) {\n', '            TokenInterface(WETH_ADDRESS).deposit{value: _amount}();\n', '            _tokenAddr = WETH_ADDRESS;\n', '        }\n', '\n', '        ERC20(_tokenAddr).safeApprove(_lendingPoolV2, _amount);\n', '        ILendingPoolV2(_lendingPoolV2).deposit(\n', '            _tokenAddr,\n', '            _amount,\n', '            address(this),\n', '            AAVE_REFERRAL_CODE\n', '        );\n', '\n', '        if (_isColl) {\n', '            setUserUseReserveAsCollateralIfNeeded(_lendingPoolV2, _market, _tokenAddr);\n', '        }\n', '    }\n', '\n', '    // function borrowAaveV2(\n', '    //     address _lendingPoolV2,\n', '    //     address _tokenAddr,\n', '    //     uint256 _amount,\n', '    //     uint256 _type\n', '    // ) internal {\n', '    //     _tokenAddr = _tokenAddr == ETH_ADDR ? WETH_ADDRESS : _tokenAddr;\n', '\n', '    //     ILendingPoolV2(_lendingPoolV2).borrow(\n', '    //         _tokenAddr,\n', '    //         _amount,\n', '    //         _type,\n', '    //         AAVE_REFERRAL_CODE,\n', '    //         address(this)\n', '    //     );\n', '\n', '    //     ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\n', '    // }\n', '\n', '    function withdrawAaveV1(address _aTokenAddr)\n', '        internal\n', '        returns (uint256 amount)\n', '    {\n', '        amount = ERC20(_aTokenAddr).balanceOf(address(this));\n', '\n', '        IAToken(_aTokenAddr).redeem(amount);\n', '    }\n', '\n', '    function paybackAaveV1(\n', '        address _lendingPoolCore,\n', '        address _tokenAddr,\n', '        uint256 _amount\n', '    ) internal {\n', '        address lendingPool =\n', '            ILendingPoolAddressesProvider(AAVE_V1_LENDING_POOL_ADDRESSES).getLendingPool();\n', '\n', '        uint256 ethAmount = 0;\n', '\n', '        if (_tokenAddr != WETH_ADDRESS) {\n', '            ERC20(_tokenAddr).safeApprove(_lendingPoolCore, uint(-1));\n', '        } else {\n', '            ethAmount = _amount;\n', '            TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n', '        }\n', '\n', '        ILendingPool(lendingPool).repay{value: ethAmount}(\n', '            _tokenAddr,\n', '            _amount,\n', '            payable(address(this))\n', '        );\n', '    }\n', '\n', '    function setUserUseReserveAsCollateralIfNeeded(\n', '        address _lendingPoolV2,\n', '        address _market,\n', '        address _tokenAddr\n', '    ) public {\n', '        IAaveProtocolDataProviderV2 dataProvider = getDataProvider(_market);\n', '\n', '        (, , , , , , , , bool collateralEnabled) =\n', '            dataProvider.getUserReserveData(_tokenAddr, address(this));\n', '\n', '        if (!collateralEnabled) {\n', '            ILendingPoolV2(_lendingPoolV2).setUserUseReserveAsCollateral(_tokenAddr, true);\n', '        }\n', '    }\n', '\n', '    function getDataProvider(address _market) internal view returns (IAaveProtocolDataProviderV2) {\n', '        return\n', '            IAaveProtocolDataProviderV2(\n', '                ILendingPoolAddressesProviderV2(_market).getAddress(\n', '                    0x0100000000000000000000000000000000000000000000000000000000000000\n', '                )\n', '            );\n', '    }\n', '}']