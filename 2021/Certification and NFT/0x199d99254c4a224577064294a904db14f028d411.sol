['pragma solidity ^0.5.8;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./TransferHelper.sol";\n', 'import "./IWithdraw.sol";\n', 'import "./ECDSA.sol";\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract Withdraw is IWithdraw, ReentrancyGuard, Owned {\n', '    IERC20 private tokenAddr;\n', '    using TransferHelper for address;\n', '    using SafeMath for uint256;\n', '    using ECDSA for bytes32;\n', '    string public name;\n', '    bool public stop_status = false;\n', '\n', '    mapping(uint256 => bool) usedNonce;\n', '\n', '    modifier withdraw_status {\n', '        require(stop_status == false, "WITHDRAW:STOP");\n', '        _;\n', '    }\n', '\n', '    constructor(address _tokenAddr, address _owner) public {\n', '        tokenAddr = IERC20(_tokenAddr);\n', '        name = "ADAO-WITHDRAW";\n', '        owner = _owner;\n', '    }\n', '\n', '    function verifySign(\n', '        uint256 amount,\n', '        uint256 nonce,\n', '        address userAddr,\n', '        bytes memory signature\n', '    ) public view returns (bool) {\n', '        address recoverAddr =\n', '            keccak256(abi.encode(userAddr, amount, nonce, this))\n', '                .toEthSignedMessageHash()\n', '                .recover(signature);\n', '        require(recoverAddr == owner, "WITHDRAW:SIGN_FAILURE");\n', '        require(!usedNonce[nonce], "WITHDRAW:NONCE_USED");\n', '        return true;\n', '    }\n', '\n', '    function withdraw(\n', '        uint256 amount,\n', '        uint256 nonce,\n', '        bytes memory signature\n', '    ) public nonReentrant withdraw_status returns (bool) {\n', '        verifySign(amount, nonce, msg.sender, signature);\n', '        usedNonce[nonce] = true;\n', '        require(\n', '            address(tokenAddr).safeTransfer(msg.sender, amount),\n', '            "WITHDRAW:INSUFFICIENT_CONTRACT_BALANCE"\n', '        );\n', '        emit WithdrawEvent(msg.sender, amount, nonce);\n', '        return true;\n', '    }\n', '\n', '    function stop() public nonReentrant onlyOwner {\n', '        stop_status = true;\n', '    }\n', '\n', '    function draw(uint256 amount, address toAddr)\n', '        public\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        require(\n', '            address(tokenAddr).safeTransfer(toAddr, amount),\n', '            "WITHDRAW:INSUFFICIENT_CONTRACT_BALANCE"\n', '        );\n', '        emit DrawEvent(toAddr, amount);\n', '    }\n', '}']