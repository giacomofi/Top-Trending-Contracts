['// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@indexed-finance/uniswap-v2-oracle/contracts/lib/FixedPoint.sol";\n', 'import "./interfaces/ICirculatingMarketCapOracle.sol";\n', '\n', '\n', '/**\n', ' * @dev Temporary contract to convert market caps denominated in ETH\n', ' * to market caps denominated in USD.\n', ' */\n', 'contract CirculatingMarketCapEthToDAI {\n', '  using FixedPoint for FixedPoint.uq112x112;\n', '  using FixedPoint for FixedPoint.uq144x112;\n', '\n', '  address public immutable uniswapOracle;\n', '  address public immutable circulatingMarketCapOracle;\n', '  address public immutable dai;\n', '\n', '  uint32 internal constant SHORT_TWAP_MIN_TIME_ELAPSED = 20 minutes;\n', '  uint32 internal constant SHORT_TWAP_MAX_TIME_ELAPSED = 2 days;\n', '\n', '  constructor (\n', '    address uniswapOracle_,\n', '    address circulatingMarketCapOracle_,\n', '    address dai_\n', '  ) public {\n', '    uniswapOracle = uniswapOracle_;\n', '    circulatingMarketCapOracle = circulatingMarketCapOracle_;\n', '    dai = dai_;\n', '  }\n', '\n', '  function getCirculatingMarketCaps(address[] calldata tokens) external view returns (uint256[] memory values) {\n', '    uint256 len = tokens.length;\n', '    FixedPoint.uq112x112 memory ethPriceForDai = IIndexedUniswapV2Oracle(uniswapOracle).computeAverageEthPrice(\n', '      dai,\n', '      SHORT_TWAP_MIN_TIME_ELAPSED,\n', '      SHORT_TWAP_MAX_TIME_ELAPSED\n', '    );\n', '    values = ICirculatingMarketCapOracle(circulatingMarketCapOracle).getCirculatingMarketCaps(tokens);\n', '    for (uint256 i = 0; i < len; i++) {\n', '      values[i] = ethPriceForDai.mul(values[i]).decode144();\n', '    }\n', '  }\n', '}\n', '\n', '\n', 'interface IIndexedUniswapV2Oracle {\n', '  function computeAverageEthPrice(\n', '    address token,\n', '    uint256 minTimeElapsed,\n', '    uint256 maxTimeElapsed\n', '  )\n', '    external\n', '    view\n', '    returns (FixedPoint.uq112x112 memory priceAverage);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/************************************************************************************************\n', 'From https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/FixedPoint.sol\n', '\n', 'Copied from the github repository at commit hash 9642a0705fdaf36b477354a4167a8cd765250860.\n', '\n', 'Modifications:\n', '- Removed `sqrt` function\n', '\n', 'Subject to the GPL-3.0 license\n', '*************************************************************************************************/\n', '\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'library FixedPoint {\n', '  // range: [0, 2**112 - 1]\n', '  // resolution: 1 / 2**112\n', '  struct uq112x112 {\n', '    uint224 _x;\n', '  }\n', '\n', '  // range: [0, 2**144 - 1]\n', '  // resolution: 1 / 2**112\n', '  struct uq144x112 {\n', '    uint _x;\n', '  }\n', '\n', '  uint8 private constant RESOLUTION = 112;\n', '  uint private constant Q112 = uint(1) << RESOLUTION;\n', '  uint private constant Q224 = Q112 << RESOLUTION;\n', '\n', '  // encode a uint112 as a UQ112x112\n', '  function encode(uint112 x) internal pure returns (uq112x112 memory) {\n', '    return uq112x112(uint224(x) << RESOLUTION);\n', '  }\n', '\n', '  // encodes a uint144 as a UQ144x112\n', '  function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n', '    return uq144x112(uint256(x) << RESOLUTION);\n', '  }\n', '\n', '  // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '  function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n', '    require(x != 0, "FixedPoint: DIV_BY_ZERO");\n', '    return uq112x112(self._x / uint224(x));\n', '  }\n', '\n', '  // multiply a UQ112x112 by a uint, returning a UQ144x112\n', '  // reverts on overflow\n', '  function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n', '    uint z;\n', '    require(\n', '      y == 0 || (z = uint(self._x) * y) / y == uint(self._x),\n', '      "FixedPoint: MULTIPLICATION_OVERFLOW"\n', '    );\n', '    return uq144x112(z);\n', '  }\n', '\n', '  // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n', '  // equivalent to encode(numerator).div(denominator)\n', '  function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '    require(denominator > 0, "FixedPoint: DIV_BY_ZERO");\n', '    return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n', '  }\n', '\n', '  // decode a UQ112x112 into a uint112 by truncating after the radix point\n', '  function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '    return uint112(self._x >> RESOLUTION);\n', '  }\n', '\n', '  // decode a UQ144x112 into a uint144 by truncating after the radix point\n', '  function decode144(uq144x112 memory self) internal pure returns (uint144) {\n', '    return uint144(self._x >> RESOLUTION);\n', '  }\n', '\n', '  // take the reciprocal of a UQ112x112\n', '  function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', '    require(self._x != 0, "FixedPoint: ZERO_RECIPROCAL");\n', '    return uq112x112(uint224(Q224 / self._x));\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'interface ICirculatingMarketCapOracle {\n', '  function getCirculatingMarketCap(address) external view returns (uint256);\n', '\n', '  function getCirculatingMarketCaps(address[] calldata) external view returns (uint256[] memory);\n', '\n', '  function updateCirculatingMarketCaps(address[] calldata) external;\n', '}']