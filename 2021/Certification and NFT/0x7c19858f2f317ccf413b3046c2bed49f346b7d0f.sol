['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '/**\n', ' * SPDX-License-Identifier: UNLICENSED\n', ' */\n', 'pragma solidity =0.6.10;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: contracts/packages/oz/upgradeability/Initializable.sol\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/packages/oz/upgradeability/GSN/ContextUpgradeable.sol\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {}\n', '\n', '    function _msgSender() internal virtual view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal virtual view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// File: contracts/packages/oz/upgradeability/OwnableUpgradeSafe.sol\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract OwnableUpgradeSafe is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '\n', '    function __Ownable_init(address _sender) internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained(_sender);\n', '    }\n', '\n', '    function __Ownable_init_unchained(address _sender) internal initializer {\n', '        _owner = _sender;\n', '        emit OwnershipTransferred(address(0), _sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: contracts/packages/oz/upgradeability/ReentrancyGuardUpgradeSafe.sol\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuardUpgradeSafe is Initializable {\n', '    bool private _notEntered;\n', '\n', '    function __ReentrancyGuard_init() internal initializer {\n', '        __ReentrancyGuard_init_unchained();\n', '    }\n', '\n', '    function __ReentrancyGuard_init_unchained() internal initializer {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: contracts/packages/oz/SafeMath.sol\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/MarginVault.sol\n', '\n', '/**\n', ' * MarginVault Error Codes\n', ' * V1: invalid short otoken amount\n', ' * V2: invalid short otoken index\n', ' * V3: short otoken address mismatch\n', ' * V4: invalid long otoken amount\n', ' * V5: invalid long otoken index\n', ' * V6: long otoken address mismatch\n', ' * V7: invalid collateral amount\n', ' * V8: invalid collateral token index\n', ' * V9: collateral token address mismatch\n', ' */\n', '\n', '/**\n', ' * @title MarginVault\n', ' * @author Opyn Team\n', ' * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\n', ' * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\n', ' */\n', 'library MarginVault {\n', '    using SafeMath for uint256;\n', '\n', '    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n', '    struct Vault {\n', '        // addresses of oTokens a user has shorted (i.e. written) against this vault\n', '        address[] shortOtokens;\n', '        // addresses of oTokens a user has bought and deposited in this vault\n', '        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n', "        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\n", '        address[] longOtokens;\n', '        // addresses of other ERC-20s a user has deposited as collateral in this vault\n', '        address[] collateralAssets;\n', '        // quantity of oTokens minted/written for each oToken address in shortOtokens\n', '        uint256[] shortAmounts;\n', '        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n', '        uint256[] longAmounts;\n', '        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n', '        uint256[] collateralAmounts;\n', '    }\n', '\n', '    /**\n', '     * @dev increase the short oToken balance in a vault when a new oToken is minted\n', '     * @param _vault vault to add or increase the short position in\n', "     * @param _shortOtoken address of the _shortOtoken being minted from the user's vault\n", "     * @param _amount number of _shortOtoken being minted from the user's vault\n", "     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n", '     */\n', '    function addShort(\n', '        Vault storage _vault,\n', '        address _shortOtoken,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        require(_amount > 0, "V1");\n', '\n', '        // valid indexes in any array are between 0 and array.length - 1.\n', '        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n', '        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {\n', '            _vault.shortOtokens.push(_shortOtoken);\n', '            _vault.shortAmounts.push(_amount);\n', '        } else {\n', '            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), "V2");\n', '            address existingShort = _vault.shortOtokens[_index];\n', '            require((existingShort == _shortOtoken) || (existingShort == address(0)), "V3");\n', '\n', '            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);\n', '            _vault.shortOtokens[_index] = _shortOtoken;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev decrease the short oToken balance in a vault when an oToken is burned\n', '     * @param _vault vault to decrease short position in\n', "     * @param _shortOtoken address of the _shortOtoken being reduced in the user's vault\n", "     * @param _amount number of _shortOtoken being reduced in the user's vault\n", "     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n", '     */\n', '    function removeShort(\n', '        Vault storage _vault,\n', '        address _shortOtoken,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        // check that the removed short oToken exists in the vault at the specified index\n', '        require(_index < _vault.shortOtokens.length, "V2");\n', '        require(_vault.shortOtokens[_index] == _shortOtoken, "V3");\n', '\n', '        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);\n', '\n', '        if (newShortAmount == 0) {\n', '            delete _vault.shortOtokens[_index];\n', '        }\n', '        _vault.shortAmounts[_index] = newShortAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev increase the long oToken balance in a vault when an oToken is deposited\n', '     * @param _vault vault to add a long position to\n', "     * @param _longOtoken address of the _longOtoken being added to the user's vault\n", "     * @param _amount number of _longOtoken the protocol is adding to the user's vault\n", "     * @param _index index of _longOtoken in the user's vault.longOtokens array\n", '     */\n', '    function addLong(\n', '        Vault storage _vault,\n', '        address _longOtoken,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        require(_amount > 0, "V4");\n', '\n', '        // valid indexes in any array are between 0 and array.length - 1.\n', '        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n', '        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {\n', '            _vault.longOtokens.push(_longOtoken);\n', '            _vault.longAmounts.push(_amount);\n', '        } else {\n', '            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), "V5");\n', '            address existingLong = _vault.longOtokens[_index];\n', '            require((existingLong == _longOtoken) || (existingLong == address(0)), "V6");\n', '\n', '            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);\n', '            _vault.longOtokens[_index] = _longOtoken;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev decrease the long oToken balance in a vault when an oToken is withdrawn\n', '     * @param _vault vault to remove a long position from\n', "     * @param _longOtoken address of the _longOtoken being removed from the user's vault\n", "     * @param _amount number of _longOtoken the protocol is removing from the user's vault\n", "     * @param _index index of _longOtoken in the user's vault.longOtokens array\n", '     */\n', '    function removeLong(\n', '        Vault storage _vault,\n', '        address _longOtoken,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        // check that the removed long oToken exists in the vault at the specified index\n', '        require(_index < _vault.longOtokens.length, "V5");\n', '        require(_vault.longOtokens[_index] == _longOtoken, "V6");\n', '\n', '        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);\n', '\n', '        if (newLongAmount == 0) {\n', '            delete _vault.longOtokens[_index];\n', '        }\n', '        _vault.longAmounts[_index] = newLongAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev increase the collateral balance in a vault\n', '     * @param _vault vault to add collateral to\n', "     * @param _collateralAsset address of the _collateralAsset being added to the user's vault\n", "     * @param _amount number of _collateralAsset being added to the user's vault\n", "     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n", '     */\n', '    function addCollateral(\n', '        Vault storage _vault,\n', '        address _collateralAsset,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        require(_amount > 0, "V7");\n', '\n', '        // valid indexes in any array are between 0 and array.length - 1.\n', '        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n', '        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {\n', '            _vault.collateralAssets.push(_collateralAsset);\n', '            _vault.collateralAmounts.push(_amount);\n', '        } else {\n', '            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), "V8");\n', '            address existingCollateral = _vault.collateralAssets[_index];\n', '            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), "V9");\n', '\n', '            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);\n', '            _vault.collateralAssets[_index] = _collateralAsset;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev decrease the collateral balance in a vault\n', '     * @param _vault vault to remove collateral from\n', "     * @param _collateralAsset address of the _collateralAsset being removed from the user's vault\n", "     * @param _amount number of _collateralAsset being removed from the user's vault\n", "     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n", '     */\n', '    function removeCollateral(\n', '        Vault storage _vault,\n', '        address _collateralAsset,\n', '        uint256 _amount,\n', '        uint256 _index\n', '    ) external {\n', '        // check that the removed collateral exists in the vault at the specified index\n', '        require(_index < _vault.collateralAssets.length, "V8");\n', '        require(_vault.collateralAssets[_index] == _collateralAsset, "V9");\n', '\n', '        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);\n', '\n', '        if (newCollateralAmount == 0) {\n', '            delete _vault.collateralAssets[_index];\n', '        }\n', '        _vault.collateralAmounts[_index] = newCollateralAmount;\n', '    }\n', '}\n', '\n', '// File: contracts/libs/Actions.sol\n', '\n', '/**\n', ' * @title Actions\n', ' * @author Opyn Team\n', ' * @notice A library that provides a ActionArgs struct, sub types of Action structs, and functions to parse ActionArgs into specific Actions.\n', ' * errorCode\n', ' * A1 can only parse arguments for open vault actions\n', ' * A2 cannot open vault for an invalid account\n', ' * A3 cannot open vault with an invalid type\n', ' * A4 can only parse arguments for mint actions\n', ' * A5 cannot mint from an invalid account\n', ' * A6 can only parse arguments for burn actions\n', ' * A7 cannot burn from an invalid account\n', ' * A8 can only parse arguments for deposit actions\n', ' * A9 cannot deposit to an invalid account\n', ' * A10 can only parse arguments for withdraw actions\n', ' * A11 cannot withdraw from an invalid account\n', ' * A12 cannot withdraw to an invalid account\n', ' * A13 can only parse arguments for redeem actions\n', ' * A14 cannot redeem to an invalid account\n', ' * A15 can only parse arguments for settle vault actions\n', ' * A16 cannot settle vault for an invalid account\n', ' * A17 cannot withdraw payout to an invalid account\n', ' * A18 can only parse arguments for liquidate action\n', ' * A19 cannot liquidate vault for an invalid account owner\n', ' * A20 cannot send collateral to an invalid account\n', ' * A21 cannot parse liquidate action with no round id\n', ' * A22 can only parse arguments for call actions\n', ' * A23 target address cannot be address(0)\n', ' */\n', 'library Actions {\n', '    // possible actions that can be performed\n', '    enum ActionType {\n', '        OpenVault,\n', '        MintShortOption,\n', '        BurnShortOption,\n', '        DepositLongOption,\n', '        WithdrawLongOption,\n', '        DepositCollateral,\n', '        WithdrawCollateral,\n', '        SettleVault,\n', '        Redeem,\n', '        Call,\n', '        Liquidate\n', '    }\n', '\n', '    struct ActionArgs {\n', '        // type of action that is being performed on the system\n', '        ActionType actionType;\n', '        // address of the account owner\n', '        address owner;\n', '        // address which we move assets from or to (depending on the action type)\n', '        address secondAddress;\n', '        // asset that is to be transfered\n', '        address asset;\n', '        // index of the vault that is to be modified (if any)\n', '        uint256 vaultId;\n', '        // amount of asset that is to be transfered\n', '        uint256 amount;\n', '        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n', '        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n', '        uint256 index;\n', '        // any other data that needs to be passed in for arbitrary function calls\n', '        bytes data;\n', '    }\n', '\n', '    struct MintArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // index of the vault from which the asset will be minted\n', '        uint256 vaultId;\n', '        // address to which we transfer the minted oTokens\n', '        address to;\n', '        // oToken that is to be minted\n', '        address otoken;\n', '        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n', '        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n', '        uint256 index;\n', '        // amount of oTokens that is to be minted\n', '        uint256 amount;\n', '    }\n', '\n', '    struct BurnArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // index of the vault from which the oToken will be burned\n', '        uint256 vaultId;\n', '        // address from which we transfer the oTokens\n', '        address from;\n', '        // oToken that is to be burned\n', '        address otoken;\n', '        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n', '        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n', '        uint256 index;\n', '        // amount of oTokens that is to be burned\n', '        uint256 amount;\n', '    }\n', '\n', '    struct OpenVaultArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // vault id to create\n', '        uint256 vaultId;\n', '        // vault type, 0 for spread/max loss and 1 for naked margin vault\n', '        uint256 vaultType;\n', '    }\n', '\n', '    struct DepositArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // index of the vault to which the asset will be added\n', '        uint256 vaultId;\n', '        // address from which we transfer the asset\n', '        address from;\n', '        // asset that is to be deposited\n', '        address asset;\n', '        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n', '        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n', '        uint256 index;\n', '        // amount of asset that is to be deposited\n', '        uint256 amount;\n', '    }\n', '\n', '    struct RedeemArgs {\n', '        // address to which we pay out the oToken proceeds\n', '        address receiver;\n', '        // oToken that is to be redeemed\n', '        address otoken;\n', '        // amount of oTokens that is to be redeemed\n', '        uint256 amount;\n', '    }\n', '\n', '    struct WithdrawArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // index of the vault from which the asset will be withdrawn\n', '        uint256 vaultId;\n', '        // address to which we transfer the asset\n', '        address to;\n', '        // asset that is to be withdrawn\n', '        address asset;\n', '        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\n', '        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n', '        uint256 index;\n', '        // amount of asset that is to be withdrawn\n', '        uint256 amount;\n', '    }\n', '\n', '    struct SettleVaultArgs {\n', '        // address of the account owner\n', '        address owner;\n', '        // index of the vault to which is to be settled\n', '        uint256 vaultId;\n', '        // address to which we transfer the remaining collateral\n', '        address to;\n', '    }\n', '\n', '    struct LiquidateArgs {\n', '        // address of the vault owner to liquidate\n', '        address owner;\n', '        // address of the liquidated collateral receiver\n', '        address receiver;\n', '        // vault id to liquidate\n', '        uint256 vaultId;\n', '        // amount of debt(otoken) to repay\n', '        uint256 amount;\n', '        // chainlink round id\n', '        uint256 roundId;\n', '    }\n', '\n', '    struct CallArgs {\n', '        // address of the callee contract\n', '        address callee;\n', '        // data field for external calls\n', '        bytes data;\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for an open vault action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a open vault action\n', '     */\n', '    function _parseOpenVaultArgs(ActionArgs memory _args) internal pure returns (OpenVaultArgs memory) {\n', '        require(_args.actionType == ActionType.OpenVault, "A1");\n', '        require(_args.owner != address(0), "A2");\n', '\n', '        // if not _args.data included, vault type will be 0 by default\n', '        uint256 vaultType;\n', '\n', '        if (_args.data.length == 32) {\n', '            // decode vault type from _args.data\n', '            vaultType = abi.decode(_args.data, (uint256));\n', '        }\n', '\n', '        // for now we only have 2 vault types\n', '        require(vaultType < 2, "A3");\n', '\n', '        return OpenVaultArgs({owner: _args.owner, vaultId: _args.vaultId, vaultType: vaultType});\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a mint action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a mint action\n', '     */\n', '    function _parseMintArgs(ActionArgs memory _args) internal pure returns (MintArgs memory) {\n', '        require(_args.actionType == ActionType.MintShortOption, "A4");\n', '        require(_args.owner != address(0), "A5");\n', '\n', '        return\n', '            MintArgs({\n', '                owner: _args.owner,\n', '                vaultId: _args.vaultId,\n', '                to: _args.secondAddress,\n', '                otoken: _args.asset,\n', '                index: _args.index,\n', '                amount: _args.amount\n', '            });\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a burn action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a burn action\n', '     */\n', '    function _parseBurnArgs(ActionArgs memory _args) internal pure returns (BurnArgs memory) {\n', '        require(_args.actionType == ActionType.BurnShortOption, "A6");\n', '        require(_args.owner != address(0), "A7");\n', '\n', '        return\n', '            BurnArgs({\n', '                owner: _args.owner,\n', '                vaultId: _args.vaultId,\n', '                from: _args.secondAddress,\n', '                otoken: _args.asset,\n', '                index: _args.index,\n', '                amount: _args.amount\n', '            });\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a deposit action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a deposit action\n', '     */\n', '    function _parseDepositArgs(ActionArgs memory _args) internal pure returns (DepositArgs memory) {\n', '        require(\n', '            (_args.actionType == ActionType.DepositLongOption) || (_args.actionType == ActionType.DepositCollateral),\n', '            "A8"\n', '        );\n', '        require(_args.owner != address(0), "A9");\n', '\n', '        return\n', '            DepositArgs({\n', '                owner: _args.owner,\n', '                vaultId: _args.vaultId,\n', '                from: _args.secondAddress,\n', '                asset: _args.asset,\n', '                index: _args.index,\n', '                amount: _args.amount\n', '            });\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a withdraw action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a withdraw action\n', '     */\n', '    function _parseWithdrawArgs(ActionArgs memory _args) internal pure returns (WithdrawArgs memory) {\n', '        require(\n', '            (_args.actionType == ActionType.WithdrawLongOption) || (_args.actionType == ActionType.WithdrawCollateral),\n', '            "A10"\n', '        );\n', '        require(_args.owner != address(0), "A11");\n', '        require(_args.secondAddress != address(0), "A12");\n', '\n', '        return\n', '            WithdrawArgs({\n', '                owner: _args.owner,\n', '                vaultId: _args.vaultId,\n', '                to: _args.secondAddress,\n', '                asset: _args.asset,\n', '                index: _args.index,\n', '                amount: _args.amount\n', '            });\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for an redeem action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a redeem action\n', '     */\n', '    function _parseRedeemArgs(ActionArgs memory _args) internal pure returns (RedeemArgs memory) {\n', '        require(_args.actionType == ActionType.Redeem, "A13");\n', '        require(_args.secondAddress != address(0), "A14");\n', '\n', '        return RedeemArgs({receiver: _args.secondAddress, otoken: _args.asset, amount: _args.amount});\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a settle vault action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a settle vault action\n', '     */\n', '    function _parseSettleVaultArgs(ActionArgs memory _args) internal pure returns (SettleVaultArgs memory) {\n', '        require(_args.actionType == ActionType.SettleVault, "A15");\n', '        require(_args.owner != address(0), "A16");\n', '        require(_args.secondAddress != address(0), "A17");\n', '\n', '        return SettleVaultArgs({owner: _args.owner, vaultId: _args.vaultId, to: _args.secondAddress});\n', '    }\n', '\n', '    function _parseLiquidateArgs(ActionArgs memory _args) internal pure returns (LiquidateArgs memory) {\n', '        require(_args.actionType == ActionType.Liquidate, "A18");\n', '        require(_args.owner != address(0), "A19");\n', '        require(_args.secondAddress != address(0), "A20");\n', '        require(_args.data.length == 32, "A21");\n', '\n', '        // decode chainlink round id from _args.data\n', '        uint256 roundId = abi.decode(_args.data, (uint256));\n', '\n', '        return\n', '            LiquidateArgs({\n', '                owner: _args.owner,\n', '                receiver: _args.secondAddress,\n', '                vaultId: _args.vaultId,\n', '                amount: _args.amount,\n', '                roundId: roundId\n', '            });\n', '    }\n', '\n', '    /**\n', '     * @notice parses the passed in action arguments to get the arguments for a call action\n', '     * @param _args general action arguments structure\n', '     * @return arguments for a call action\n', '     */\n', '    function _parseCallArgs(ActionArgs memory _args) internal pure returns (CallArgs memory) {\n', '        require(_args.actionType == ActionType.Call, "A22");\n', '        require(_args.secondAddress != address(0), "A23");\n', '\n', '        return CallArgs({callee: _args.secondAddress, data: _args.data});\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/AddressBookInterface.sol\n', '\n', 'interface AddressBookInterface {\n', '    /* Getters */\n', '\n', '    function getOtokenImpl() external view returns (address);\n', '\n', '    function getOtokenFactory() external view returns (address);\n', '\n', '    function getWhitelist() external view returns (address);\n', '\n', '    function getController() external view returns (address);\n', '\n', '    function getOracle() external view returns (address);\n', '\n', '    function getMarginPool() external view returns (address);\n', '\n', '    function getMarginCalculator() external view returns (address);\n', '\n', '    function getLiquidationManager() external view returns (address);\n', '\n', '    function getAddress(bytes32 _id) external view returns (address);\n', '\n', '    /* Setters */\n', '\n', '    function setOtokenImpl(address _otokenImpl) external;\n', '\n', '    function setOtokenFactory(address _factory) external;\n', '\n', '    function setOracleImpl(address _otokenImpl) external;\n', '\n', '    function setWhitelist(address _whitelist) external;\n', '\n', '    function setController(address _controller) external;\n', '\n', '    function setMarginPool(address _marginPool) external;\n', '\n', '    function setMarginCalculator(address _calculator) external;\n', '\n', '    function setLiquidationManager(address _liquidationManager) external;\n', '\n', '    function setAddress(bytes32 _id, address _newImpl) external;\n', '}\n', '\n', '// File: contracts/interfaces/OtokenInterface.sol\n', '\n', 'interface OtokenInterface {\n', '    function addressBook() external view returns (address);\n', '\n', '    function underlyingAsset() external view returns (address);\n', '\n', '    function strikeAsset() external view returns (address);\n', '\n', '    function collateralAsset() external view returns (address);\n', '\n', '    function strikePrice() external view returns (uint256);\n', '\n', '    function expiryTimestamp() external view returns (uint256);\n', '\n', '    function isPut() external view returns (bool);\n', '\n', '    function init(\n', '        address _addressBook,\n', '        address _underlyingAsset,\n', '        address _strikeAsset,\n', '        address _collateralAsset,\n', '        uint256 _strikePrice,\n', '        uint256 _expiry,\n', '        bool _isPut\n', '    ) external;\n', '\n', '    function getOtokenDetails()\n', '        external\n', '        view\n', '        returns (\n', '            address,\n', '            address,\n', '            address,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        );\n', '\n', '    function mintOtoken(address account, uint256 amount) external;\n', '\n', '    function burnOtoken(address account, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/interfaces/MarginCalculatorInterface.sol\n', '\n', 'interface MarginCalculatorInterface {\n', '    function addressBook() external view returns (address);\n', '\n', '    function getExpiredPayoutRate(address _otoken) external view returns (uint256);\n', '\n', '    function getExcessCollateral(MarginVault.Vault calldata _vault, uint256 _vaultType)\n', '        external\n', '        view\n', '        returns (uint256 netValue, bool isExcess);\n', '\n', '    function isLiquidatable(\n', '        MarginVault.Vault memory _vault,\n', '        uint256 _vaultType,\n', '        uint256 _vaultLatestUpdate,\n', '        uint256 _roundId\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            uint256,\n', '            uint256\n', '        );\n', '}\n', '\n', '// File: contracts/interfaces/OracleInterface.sol\n', '\n', 'interface OracleInterface {\n', '    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n', '\n', '    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n', '\n', '    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool);\n', '\n', '    function getDisputer() external view returns (address);\n', '\n', '    function getPricer(address _asset) external view returns (address);\n', '\n', '    function getPrice(address _asset) external view returns (uint256);\n', '\n', '    function getPricerLockingPeriod(address _pricer) external view returns (uint256);\n', '\n', '    function getPricerDisputePeriod(address _pricer) external view returns (uint256);\n', '\n', '    function getChainlinkRoundData(address _asset, uint80 _roundId) external view returns (uint256, uint256);\n', '\n', '    // Non-view function\n', '\n', '    function setAssetPricer(address _asset, address _pricer) external;\n', '\n', '    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external;\n', '\n', '    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external;\n', '\n', '    function setExpiryPrice(\n', '        address _asset,\n', '        uint256 _expiryTimestamp,\n', '        uint256 _price\n', '    ) external;\n', '\n', '    function disputeExpiryPrice(\n', '        address _asset,\n', '        uint256 _expiryTimestamp,\n', '        uint256 _price\n', '    ) external;\n', '\n', '    function setDisputer(address _disputer) external;\n', '}\n', '\n', '// File: contracts/interfaces/WhitelistInterface.sol\n', '\n', 'interface WhitelistInterface {\n', '    /* View functions */\n', '\n', '    function addressBook() external view returns (address);\n', '\n', '    function isWhitelistedProduct(\n', '        address _underlying,\n', '        address _strike,\n', '        address _collateral,\n', '        bool _isPut\n', '    ) external view returns (bool);\n', '\n', '    function isWhitelistedCollateral(address _collateral) external view returns (bool);\n', '\n', '    function isWhitelistedOtoken(address _otoken) external view returns (bool);\n', '\n', '    function isWhitelistedCallee(address _callee) external view returns (bool);\n', '\n', '    /* Admin / factory only functions */\n', '    function whitelistProduct(\n', '        address _underlying,\n', '        address _strike,\n', '        address _collateral,\n', '        bool _isPut\n', '    ) external;\n', '\n', '    function blacklistProduct(\n', '        address _underlying,\n', '        address _strike,\n', '        address _collateral,\n', '        bool _isPut\n', '    ) external;\n', '\n', '    function whitelistCollateral(address _collateral) external;\n', '\n', '    function blacklistCollateral(address _collateral) external;\n', '\n', '    function whitelistOtoken(address _otoken) external;\n', '\n', '    function blacklistOtoken(address _otoken) external;\n', '\n', '    function whitelistCallee(address _callee) external;\n', '\n', '    function blacklistCallee(address _callee) external;\n', '}\n', '\n', '// File: contracts/interfaces/MarginPoolInterface.sol\n', '\n', 'interface MarginPoolInterface {\n', '    /* Getters */\n', '    function addressBook() external view returns (address);\n', '\n', '    function farmer() external view returns (address);\n', '\n', '    function getStoredBalance(address _asset) external view returns (uint256);\n', '\n', '    /* Admin-only functions */\n', '    function setFarmer(address _farmer) external;\n', '\n', '    function farm(\n', '        address _asset,\n', '        address _receiver,\n', '        uint256 _amount\n', '    ) external;\n', '\n', '    /* Controller-only functions */\n', '    function transferToPool(\n', '        address _asset,\n', '        address _user,\n', '        uint256 _amount\n', '    ) external;\n', '\n', '    function transferToUser(\n', '        address _asset,\n', '        address _user,\n', '        uint256 _amount\n', '    ) external;\n', '\n', '    function batchTransferToPool(\n', '        address[] calldata _asset,\n', '        address[] calldata _user,\n', '        uint256[] calldata _amount\n', '    ) external;\n', '\n', '    function batchTransferToUser(\n', '        address[] calldata _asset,\n', '        address[] calldata _user,\n', '        uint256[] calldata _amount\n', '    ) external;\n', '}\n', '\n', '// File: contracts/interfaces/CalleeInterface.sol\n', '\n', '/**\n', ' * @dev Contract interface that can be called from Controller as a call action.\n', ' */\n', 'interface CalleeInterface {\n', '    /**\n', '     * Allows users to send this contract arbitrary data.\n', '     * @param _sender The msg.sender to Controller\n', '     * @param _data Arbitrary data given by the sender\n', '     */\n', '    function callFunction(address payable _sender, bytes memory _data) external;\n', '}\n', '\n', '// File: contracts/core/Controller.sol\n', '\n', '/**\n', ' * Controller Error Codes\n', ' * C1: sender is not full pauser\n', ' * C2: sender is not partial pauser\n', ' * C3: callee is not a whitelisted address\n', ' * C4: system is partially paused\n', ' * C5: system is fully paused\n', ' * C6: msg.sender is not authorized to run action\n', ' * C7: invalid addressbook address\n', ' * C8: invalid owner address\n', ' * C9: invalid input\n', ' * C10: fullPauser cannot be set to address zero\n', ' * C11: partialPauser cannot be set to address zero\n', ' * C12: can not run actions for different owners\n', ' * C13: can not run actions on different vaults\n', ' * C14: invalid final vault state\n', ' * C15: can not run actions on inexistent vault\n', ' * C16: cannot deposit long otoken from this address\n', ' * C17: otoken is not whitelisted to be used as collateral\n', ' * C18: otoken used as collateral is already expired\n', ' * C19: can not withdraw an expired otoken\n', ' * C20: cannot deposit collateral from this address\n', ' * C21: asset is not whitelisted to be used as collateral\n', ' * C22: can not withdraw collateral from a vault with an expired short otoken\n', ' * C23: otoken is not whitelisted to be minted\n', ' * C24: can not mint expired otoken\n', ' * C25: cannot burn from this address\n', ' * C26: can not burn expired otoken\n', ' * C27: otoken is not whitelisted to be redeemed\n', ' * C28: can not redeem un-expired otoken\n', ' * C29: asset prices not finalized yet\n', " * C30: can't settle vault with no otoken\n", ' * C31: can not settle vault with un-expired otoken\n', ' * C32: can not settle undercollateralized vault\n', ' * C33: can not liquidate vault\n', ' * C34: can not leave less than collateral dust\n', ' * C35: invalid vault id\n', ' * C36: cap amount should be greater than zero\n', ' * C37: collateral exceed naked margin cap\n', ' */\n', '\n', '/**\n', ' * @title Controller\n', ' * @author Opyn Team\n', ' * @notice Contract that controls the Gamma Protocol and the interaction of all sub contracts\n', ' */\n', 'contract Controller is Initializable, OwnableUpgradeSafe, ReentrancyGuardUpgradeSafe {\n', '    using MarginVault for MarginVault.Vault;\n', '    using SafeMath for uint256;\n', '\n', '    AddressBookInterface public addressbook;\n', '    WhitelistInterface public whitelist;\n', '    OracleInterface public oracle;\n', '    MarginCalculatorInterface public calculator;\n', '    MarginPoolInterface public pool;\n', '\n', '    ///@dev scale used in MarginCalculator\n', '    uint256 internal constant BASE = 8;\n', '\n', '    /// @notice address that has permission to partially pause the system, where system functionality is paused\n', '    /// except redeem and settleVault\n', '    address public partialPauser;\n', '\n', '    /// @notice address that has permission to fully pause the system, where all system functionality is paused\n', '    address public fullPauser;\n', '\n', '    /// @notice True if all system functionality is paused other than redeem and settle vault\n', '    bool public systemPartiallyPaused;\n', '\n', '    /// @notice True if all system functionality is paused\n', '    bool public systemFullyPaused;\n', '\n', '    /// @notice True if a call action can only be executed to a whitelisted callee\n', '    bool public callRestricted;\n', '\n', '    /// @dev mapping between an owner address and the number of owner address vaults\n', '    mapping(address => uint256) internal accountVaultCounter;\n', '    /// @dev mapping between an owner address and a specific vault using a vault id\n', '    mapping(address => mapping(uint256 => MarginVault.Vault)) internal vaults;\n', '    /// @dev mapping between an account owner and their approved or unapproved account operators\n', '    mapping(address => mapping(address => bool)) internal operators;\n', '\n', '    /******************************************************************** V2.0.0 storage upgrade ******************************************************/\n', '\n', '    /// @dev mapping to map vault by each vault type, naked margin vault should be set to 1, spread/max loss vault should be set to 0\n', '    mapping(address => mapping(uint256 => uint256)) internal vaultType;\n', '    /// @dev mapping to store the timestamp at which the vault was last updated, will be updated in every action that changes the vault state or when calling sync()\n', '    mapping(address => mapping(uint256 => uint256)) internal vaultLatestUpdate;\n', '\n', '    /// @dev mapping to store cap amount for naked margin vault per options collateral asset (scaled by collateral asset decimals)\n', '    mapping(address => uint256) internal nakedCap;\n', '\n', '    /// @dev mapping to store amount of naked margin vaults in pool\n', '    mapping(address => uint256) internal nakedPoolBalance;\n', '\n', '    /// @notice emits an event when an account operator is updated for a specific account owner\n', '    event AccountOperatorUpdated(address indexed accountOwner, address indexed operator, bool isSet);\n', '    /// @notice emits an event when a new vault is opened\n', '    event VaultOpened(address indexed accountOwner, uint256 vaultId, uint256 indexed vaultType);\n', '    /// @notice emits an event when a long oToken is deposited into a vault\n', '    event LongOtokenDeposited(\n', '        address indexed otoken,\n', '        address indexed accountOwner,\n', '        address indexed from,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when a long oToken is withdrawn from a vault\n', '    event LongOtokenWithdrawed(\n', '        address indexed otoken,\n', '        address indexed AccountOwner,\n', '        address indexed to,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when a collateral asset is deposited into a vault\n', '    event CollateralAssetDeposited(\n', '        address indexed asset,\n', '        address indexed accountOwner,\n', '        address indexed from,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when a collateral asset is withdrawn from a vault\n', '    event CollateralAssetWithdrawed(\n', '        address indexed asset,\n', '        address indexed AccountOwner,\n', '        address indexed to,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when a short oToken is minted from a vault\n', '    event ShortOtokenMinted(\n', '        address indexed otoken,\n', '        address indexed AccountOwner,\n', '        address indexed to,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when a short oToken is burned\n', '    event ShortOtokenBurned(\n', '        address indexed otoken,\n', '        address indexed AccountOwner,\n', '        address indexed from,\n', '        uint256 vaultId,\n', '        uint256 amount\n', '    );\n', '    /// @notice emits an event when an oToken is redeemed\n', '    event Redeem(\n', '        address indexed otoken,\n', '        address indexed redeemer,\n', '        address indexed receiver,\n', '        address collateralAsset,\n', '        uint256 otokenBurned,\n', '        uint256 payout\n', '    );\n', '    /// @notice emits an event when a vault is settled\n', '    event VaultSettled(\n', '        address indexed accountOwner,\n', '        address indexed oTokenAddress,\n', '        address to,\n', '        uint256 payout,\n', '        uint256 vaultId,\n', '        uint256 indexed vaultType\n', '    );\n', '    /// @notice emits an event when a vault is liquidated\n', '    event VaultLiquidated(\n', '        address indexed liquidator,\n', '        address indexed receiver,\n', '        address indexed vaultOwner,\n', '        uint256 auctionPrice,\n', '        uint256 auctionStartingRound,\n', '        uint256 collateralPayout,\n', '        uint256 debtAmount,\n', '        uint256 vaultId\n', '    );\n', '    /// @notice emits an event when a call action is executed\n', '    event CallExecuted(address indexed from, address indexed to, bytes data);\n', '    /// @notice emits an event when the fullPauser address changes\n', '    event FullPauserUpdated(address indexed oldFullPauser, address indexed newFullPauser);\n', '    /// @notice emits an event when the partialPauser address changes\n', '    event PartialPauserUpdated(address indexed oldPartialPauser, address indexed newPartialPauser);\n', '    /// @notice emits an event when the system partial paused status changes\n', '    event SystemPartiallyPaused(bool isPaused);\n', '    /// @notice emits an event when the system fully paused status changes\n', '    event SystemFullyPaused(bool isPaused);\n', '    /// @notice emits an event when the call action restriction changes\n', '    event CallRestricted(bool isRestricted);\n', '    /// @notice emits an event when a donation transfer executed\n', '    event Donated(address indexed donator, address indexed asset, uint256 amount);\n', '    /// @notice emits an event when naked cap is updated\n', '    event NakedCapUpdated(address indexed collateral, uint256 cap);\n', '\n', '    /**\n', '     * @notice modifier to check if the system is not partially paused, where only redeem and settleVault is allowed\n', '     */\n', '    modifier notPartiallyPaused {\n', '        _isNotPartiallyPaused();\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice modifier to check if the system is not fully paused, where no functionality is allowed\n', '     */\n', '    modifier notFullyPaused {\n', '        _isNotFullyPaused();\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice modifier to check if sender is the fullPauser address\n', '     */\n', '    modifier onlyFullPauser {\n', '        require(msg.sender == fullPauser, "C1");\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice modifier to check if the sender is the partialPauser address\n', '     */\n', '    modifier onlyPartialPauser {\n', '        require(msg.sender == partialPauser, "C2");\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice modifier to check if the sender is the account owner or an approved account operator\n', '     * @param _sender sender address\n', '     * @param _accountOwner account owner address\n', '     */\n', '    modifier onlyAuthorized(address _sender, address _accountOwner) {\n', '        _isAuthorized(_sender, _accountOwner);\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice modifier to check if the called address is a whitelisted callee address\n', '     * @param _callee called address\n', '     */\n', '    modifier onlyWhitelistedCallee(address _callee) {\n', '        if (callRestricted) {\n', '            require(_isCalleeWhitelisted(_callee), "C3");\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev check if the system is not in a partiallyPaused state\n', '     */\n', '    function _isNotPartiallyPaused() internal view {\n', '        require(!systemPartiallyPaused, "C4");\n', '    }\n', '\n', '    /**\n', '     * @dev check if the system is not in an fullyPaused state\n', '     */\n', '    function _isNotFullyPaused() internal view {\n', '        require(!systemFullyPaused, "C5");\n', '    }\n', '\n', '    /**\n', '     * @dev check if the sender is an authorized operator\n', '     * @param _sender msg.sender\n', '     * @param _accountOwner owner of a vault\n', '     */\n', '    function _isAuthorized(address _sender, address _accountOwner) internal view {\n', '        require((_sender == _accountOwner) || (operators[_accountOwner][_sender]), "C6");\n', '    }\n', '\n', '    /**\n', '     * @notice initalize the deployed contract\n', '     * @param _addressBook addressbook module\n', '     * @param _owner account owner address\n', '     */\n', '    function initialize(address _addressBook, address _owner) external initializer {\n', '        require(_addressBook != address(0), "C7");\n', '        require(_owner != address(0), "C8");\n', '\n', '        __Ownable_init(_owner);\n', '        __ReentrancyGuard_init_unchained();\n', '\n', '        addressbook = AddressBookInterface(_addressBook);\n', '        _refreshConfigInternal();\n', '\n', '        callRestricted = true;\n', '    }\n', '\n', '    /**\n', '     * @notice send asset amount to margin pool\n', '     * @dev use donate() instead of direct transfer() to store the balance in assetBalance\n', '     * @param _asset asset address\n', '     * @param _amount amount to donate to pool\n', '     */\n', '    function donate(address _asset, uint256 _amount) external {\n', '        pool.transferToPool(_asset, msg.sender, _amount);\n', '\n', '        emit Donated(msg.sender, _asset, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice allows the partialPauser to toggle the systemPartiallyPaused variable and partially pause or partially unpause the system\n', '     * @dev can only be called by the partialPauser\n', '     * @param _partiallyPaused new boolean value to set systemPartiallyPaused to\n', '     */\n', '    function setSystemPartiallyPaused(bool _partiallyPaused) external onlyPartialPauser {\n', '        require(systemPartiallyPaused != _partiallyPaused, "C9");\n', '\n', '        systemPartiallyPaused = _partiallyPaused;\n', '\n', '        emit SystemPartiallyPaused(systemPartiallyPaused);\n', '    }\n', '\n', '    /**\n', '     * @notice allows the fullPauser to toggle the systemFullyPaused variable and fully pause or fully unpause the system\n', '     * @dev can only be called by the fullyPauser\n', '     * @param _fullyPaused new boolean value to set systemFullyPaused to\n', '     */\n', '    function setSystemFullyPaused(bool _fullyPaused) external onlyFullPauser {\n', '        require(systemFullyPaused != _fullyPaused, "C9");\n', '\n', '        systemFullyPaused = _fullyPaused;\n', '\n', '        emit SystemFullyPaused(systemFullyPaused);\n', '    }\n', '\n', '    /**\n', '     * @notice allows the owner to set the fullPauser address\n', '     * @dev can only be called by the owner\n', '     * @param _fullPauser new fullPauser address\n', '     */\n', '    function setFullPauser(address _fullPauser) external onlyOwner {\n', '        require(_fullPauser != address(0), "C10");\n', '        require(fullPauser != _fullPauser, "C9");\n', '        emit FullPauserUpdated(fullPauser, _fullPauser);\n', '        fullPauser = _fullPauser;\n', '    }\n', '\n', '    /**\n', '     * @notice allows the owner to set the partialPauser address\n', '     * @dev can only be called by the owner\n', '     * @param _partialPauser new partialPauser address\n', '     */\n', '    function setPartialPauser(address _partialPauser) external onlyOwner {\n', '        require(_partialPauser != address(0), "C11");\n', '        require(partialPauser != _partialPauser, "C9");\n', '        emit PartialPauserUpdated(partialPauser, _partialPauser);\n', '        partialPauser = _partialPauser;\n', '    }\n', '\n', '    /**\n', '     * @notice allows the owner to toggle the restriction on whitelisted call actions and only allow whitelisted\n', '     * call addresses or allow any arbitrary call addresses\n', '     * @dev can only be called by the owner\n', '     * @param _isRestricted new call restriction state\n', '     */\n', '    function setCallRestriction(bool _isRestricted) external onlyOwner {\n', '        require(callRestricted != _isRestricted, "C9");\n', '\n', '        callRestricted = _isRestricted;\n', '\n', '        emit CallRestricted(callRestricted);\n', '    }\n', '\n', '    /**\n', '     * @notice allows a user to give or revoke privileges to an operator which can act on their behalf on their vaults\n', '     * @dev can only be updated by the vault owner\n', '     * @param _operator operator that the sender wants to give privileges to or revoke them from\n', '     * @param _isOperator new boolean value that expresses if the sender is giving or revoking privileges for _operator\n', '     */\n', '    function setOperator(address _operator, bool _isOperator) external {\n', '        require(operators[msg.sender][_operator] != _isOperator, "C9");\n', '\n', '        operators[msg.sender][_operator] = _isOperator;\n', '\n', '        emit AccountOperatorUpdated(msg.sender, _operator, _isOperator);\n', '    }\n', '\n', '    /**\n', '     * @dev updates the configuration of the controller. can only be called by the owner\n', '     */\n', '    function refreshConfiguration() external onlyOwner {\n', '        _refreshConfigInternal();\n', '    }\n', '\n', '    /**\n', '     * @notice set cap amount for collateral asset used in naked margin\n', '     * @dev can only be called by owner\n', '     * @param _collateral collateral asset address\n', '     * @param _cap cap amount, should be scaled by collateral asset decimals\n', '     */\n', '    function setNakedCap(address _collateral, uint256 _cap) external onlyOwner {\n', '        require(_cap > 0, "C36");\n', '\n', '        nakedCap[_collateral] = _cap;\n', '\n', '        emit NakedCapUpdated(_collateral, _cap);\n', '    }\n', '\n', '    /**\n', '     * @notice execute a number of actions on specific vaults\n', '     * @dev can only be called when the system is not fully paused\n', '     * @param _actions array of actions arguments\n', '     */\n', '    function operate(Actions.ActionArgs[] memory _actions) external nonReentrant notFullyPaused {\n', '        (bool vaultUpdated, address vaultOwner, uint256 vaultId) = _runActions(_actions);\n', '        if (vaultUpdated) {\n', '            _verifyFinalState(vaultOwner, vaultId);\n', '            vaultLatestUpdate[vaultOwner][vaultId] = now;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice sync vault latest update timestamp\n', '     * @dev anyone can update the latest time the vault was touched by calling this function\n', '     * vaultLatestUpdate will sync if the vault is well collateralized\n', '     * @param _owner vault owner address\n', '     * @param _vaultId vault id\n', '     */\n', '    function sync(address _owner, uint256 _vaultId) external nonReentrant notFullyPaused {\n', '        _verifyFinalState(_owner, _vaultId);\n', '        vaultLatestUpdate[_owner][_vaultId] = now;\n', '    }\n', '\n', '    /**\n', '     * @notice check if a specific address is an operator for an owner account\n', '     * @param _owner account owner address\n', '     * @param _operator account operator address\n', '     * @return True if the _operator is an approved operator for the _owner account\n', '     */\n', '    function isOperator(address _owner, address _operator) external view returns (bool) {\n', '        return operators[_owner][_operator];\n', '    }\n', '\n', '    /**\n', '     * @notice returns the current controller configuration\n', '     * @return whitelist, the address of the whitelist module\n', '     * @return oracle, the address of the oracle module\n', '     * @return calculator, the address of the calculator module\n', '     * @return pool, the address of the pool module\n', '     */\n', '    function getConfiguration()\n', '        external\n', '        view\n', '        returns (\n', '            address,\n', '            address,\n', '            address,\n', '            address\n', '        )\n', '    {\n', '        return (address(whitelist), address(oracle), address(calculator), address(pool));\n', '    }\n', '\n', '    /**\n', "     * @notice return a vault's proceeds pre or post expiry, the amount of collateral that can be removed from a vault\n", '     * @param _owner account owner of the vault\n', '     * @param _vaultId vaultId to return balances for\n', '     * @return amount of collateral that can be taken out\n', '     */\n', '    function getProceed(address _owner, uint256 _vaultId) external view returns (uint256) {\n', '        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);\n', '\n', '        (uint256 netValue, bool isExcess) = calculator.getExcessCollateral(vault, typeVault);\n', '\n', '        if (!isExcess) return 0;\n', '\n', '        return netValue;\n', '    }\n', '\n', '    /**\n', '     * @notice check if a vault is liquidatable in a specific round id\n', '     * @param _owner vault owner address\n', '     * @param _vaultId vault id to check\n', '     * @param _roundId chainlink round id to check vault status at\n', '     * @return isUnderCollat, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n', '     */\n', '    function isLiquidatable(\n', '        address _owner,\n', '        uint256 _vaultId,\n', '        uint256 _roundId\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            bool,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (, bool isUnderCollat, uint256 price, uint256 dust) = _isLiquidatable(_owner, _vaultId, _roundId);\n', '        return (isUnderCollat, price, dust);\n', '    }\n', '\n', '    /**\n', "     * @notice get an oToken's payout/cash value after expiry, in the collateral asset\n", '     * @param _otoken oToken address\n', '     * @param _amount amount of the oToken to calculate the payout for, always represented in 1e8\n', '     * @return amount of collateral to pay out\n', '     */\n', '    function getPayout(address _otoken, uint256 _amount) public view returns (uint256) {\n', '        return calculator.getExpiredPayoutRate(_otoken).mul(_amount).div(10**BASE);\n', '    }\n', '\n', '    /**\n', '     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n', '     * strike and collateral assets at this specific expiry is available in our Oracle module\n', '     * @param _otoken oToken\n', '     */\n', '    function isSettlementAllowed(address _otoken) external view returns (bool) {\n', '        (address underlying, address strike, address collateral, uint256 expiry) = _getOtokenDetails(_otoken);\n', '        return _canSettleAssets(underlying, strike, collateral, expiry);\n', '    }\n', '\n', '    /**\n', '     * @dev return if underlying, strike, collateral are all allowed to be settled\n', '     * @param _underlying oToken underlying asset\n', '     * @param _strike oToken strike asset\n', '     * @param _collateral oToken collateral asset\n', '     * @param _expiry otoken expiry timestamp\n', '     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n', '     */\n', '    function canSettleAssets(\n', '        address _underlying,\n', '        address _strike,\n', '        address _collateral,\n', '        uint256 _expiry\n', '    ) external view returns (bool) {\n', '        return _canSettleAssets(_underlying, _strike, _collateral, _expiry);\n', '    }\n', '\n', '    /**\n', '     * @notice get the number of vaults for a specified account owner\n', '     * @param _accountOwner account owner address\n', '     * @return number of vaults\n', '     */\n', '    function getAccountVaultCounter(address _accountOwner) external view returns (uint256) {\n', '        return accountVaultCounter[_accountOwner];\n', '    }\n', '\n', '    /**\n', '     * @notice check if an oToken has expired\n', '     * @param _otoken oToken address\n', '     * @return True if the otoken has expired, False if not\n', '     */\n', '    function hasExpired(address _otoken) external view returns (bool) {\n', '        return now >= OtokenInterface(_otoken).expiryTimestamp();\n', '    }\n', '\n', '    /**\n', '     * @notice return a specific vault\n', '     * @param _owner account owner\n', '     * @param _vaultId vault id of vault to return\n', '     * @return Vault struct that corresponds to the _vaultId of _owner\n', '     */\n', '    function getVault(address _owner, uint256 _vaultId) external view returns (MarginVault.Vault memory) {\n', '        return (vaults[_owner][_vaultId]);\n', '    }\n', '\n', '    /**\n', '     * @notice return a specific vault\n', '     * @param _owner account owner\n', '     * @param _vaultId vault id of vault to return\n', '     * @return Vault struct that corresponds to the _vaultId of _owner, vault type and the latest timestamp when the vault was updated\n', '     */\n', '    function getVaultWithDetails(address _owner, uint256 _vaultId)\n', '        public\n', '        view\n', '        returns (\n', '            MarginVault.Vault memory,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (vaults[_owner][_vaultId], vaultType[_owner][_vaultId], vaultLatestUpdate[_owner][_vaultId]);\n', '    }\n', '\n', '    /**\n', '     * @notice get cap amount for collateral asset\n', '     * @param _asset collateral asset address\n', '     * @return cap amount\n', '     */\n', '    function getNakedCap(address _asset) external view returns (uint256) {\n', '        return nakedCap[_asset];\n', '    }\n', '\n', '    /**\n', '     * @notice get amount of collateral deposited in all naked margin vaults\n', '     * @param _asset collateral asset address\n', '     * @return naked pool balance\n', '     */\n', '    function getNakedPoolBalance(address _asset) external view returns (uint256) {\n', '        return nakedPoolBalance[_asset];\n', '    }\n', '\n', '    /**\n', '     * @notice execute a variety of actions\n', '     * @dev for each action in the action array, execute the corresponding action, only one vault can be modified\n', '     * for all actions except SettleVault, Redeem, and Call\n', '     * @param _actions array of type Actions.ActionArgs[], which expresses which actions the user wants to execute\n', '     * @return vaultUpdated, indicates if a vault has changed\n', '     * @return owner, the vault owner if a vault has changed\n', '     * @return vaultId, the vault Id if a vault has changed\n', '     */\n', '    function _runActions(Actions.ActionArgs[] memory _actions)\n', '        internal\n', '        returns (\n', '            bool,\n', '            address,\n', '            uint256\n', '        )\n', '    {\n', '        address vaultOwner;\n', '        uint256 vaultId;\n', '        bool vaultUpdated;\n', '\n', '        for (uint256 i = 0; i < _actions.length; i++) {\n', '            Actions.ActionArgs memory action = _actions[i];\n', '            Actions.ActionType actionType = action.actionType;\n', '\n', '            // actions except Settle, Redeem, Liquidate and Call are "Vault-updating actinos"\n', '            // only allow update 1 vault in each operate call\n', '            if (\n', '                (actionType != Actions.ActionType.SettleVault) &&\n', '                (actionType != Actions.ActionType.Redeem) &&\n', '                (actionType != Actions.ActionType.Liquidate) &&\n', '                (actionType != Actions.ActionType.Call)\n', '            ) {\n', '                // check if this action is manipulating the same vault as all other actions, if a vault has already been updated\n', '                if (vaultUpdated) {\n', '                    require(vaultOwner == action.owner, "C12");\n', '                    require(vaultId == action.vaultId, "C13");\n', '                }\n', '                vaultUpdated = true;\n', '                vaultId = action.vaultId;\n', '                vaultOwner = action.owner;\n', '            }\n', '\n', '            if (actionType == Actions.ActionType.OpenVault) {\n', '                _openVault(Actions._parseOpenVaultArgs(action));\n', '            } else if (actionType == Actions.ActionType.DepositLongOption) {\n', '                _depositLong(Actions._parseDepositArgs(action));\n', '            } else if (actionType == Actions.ActionType.WithdrawLongOption) {\n', '                _withdrawLong(Actions._parseWithdrawArgs(action));\n', '            } else if (actionType == Actions.ActionType.DepositCollateral) {\n', '                _depositCollateral(Actions._parseDepositArgs(action));\n', '            } else if (actionType == Actions.ActionType.WithdrawCollateral) {\n', '                _withdrawCollateral(Actions._parseWithdrawArgs(action));\n', '            } else if (actionType == Actions.ActionType.MintShortOption) {\n', '                _mintOtoken(Actions._parseMintArgs(action));\n', '            } else if (actionType == Actions.ActionType.BurnShortOption) {\n', '                _burnOtoken(Actions._parseBurnArgs(action));\n', '            } else if (actionType == Actions.ActionType.Redeem) {\n', '                _redeem(Actions._parseRedeemArgs(action));\n', '            } else if (actionType == Actions.ActionType.SettleVault) {\n', '                _settleVault(Actions._parseSettleVaultArgs(action));\n', '            } else if (actionType == Actions.ActionType.Liquidate) {\n', '                _liquidate(Actions._parseLiquidateArgs(action));\n', '            } else if (actionType == Actions.ActionType.Call) {\n', '                _call(Actions._parseCallArgs(action));\n', '            }\n', '        }\n', '\n', '        return (vaultUpdated, vaultOwner, vaultId);\n', '    }\n', '\n', '    /**\n', '     * @notice verify the vault final state after executing all actions\n', '     * @param _owner account owner address\n', '     * @param _vaultId vault id of the final vault\n', '     */\n', '    function _verifyFinalState(address _owner, uint256 _vaultId) internal view {\n', '        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_owner, _vaultId);\n', '        (, bool isValidVault) = calculator.getExcessCollateral(vault, typeVault);\n', '\n', '        require(isValidVault, "C14");\n', '    }\n', '\n', '    /**\n', '     * @notice open a new vault inside an account\n', '     * @dev only the account owner or operator can open a vault, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args OpenVaultArgs structure\n', '     */\n', '    function _openVault(Actions.OpenVaultArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        uint256 vaultId = accountVaultCounter[_args.owner].add(1);\n', '\n', '        require(_args.vaultId == vaultId, "C15");\n', '\n', '        // store new vault\n', '        accountVaultCounter[_args.owner] = vaultId;\n', '        vaultType[_args.owner][vaultId] = _args.vaultType;\n', '\n', '        emit VaultOpened(_args.owner, vaultId, _args.vaultType);\n', '    }\n', '\n', '    /**\n', '     * @notice deposit a long oToken into a vault\n', '     * @dev only the account owner or operator can deposit a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args DepositArgs structure\n', '     */\n', '    function _depositLong(Actions.DepositArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '        // only allow vault owner or vault operator to deposit long otoken\n', '        require((_args.from == msg.sender) || (_args.from == _args.owner), "C16");\n', '\n', '        require(whitelist.isWhitelistedOtoken(_args.asset), "C17");\n', '\n', '        OtokenInterface otoken = OtokenInterface(_args.asset);\n', '\n', '        require(now < otoken.expiryTimestamp(), "C18");\n', '\n', '        vaults[_args.owner][_args.vaultId].addLong(_args.asset, _args.amount, _args.index);\n', '\n', '        pool.transferToPool(_args.asset, _args.from, _args.amount);\n', '\n', '        emit LongOtokenDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice withdraw a long oToken from a vault\n', '     * @dev only the account owner or operator can withdraw a long oToken, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args WithdrawArgs structure\n', '     */\n', '    function _withdrawLong(Actions.WithdrawArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '\n', '        OtokenInterface otoken = OtokenInterface(_args.asset);\n', '\n', '        require(now < otoken.expiryTimestamp(), "C19");\n', '\n', '        vaults[_args.owner][_args.vaultId].removeLong(_args.asset, _args.amount, _args.index);\n', '\n', '        pool.transferToUser(_args.asset, _args.to, _args.amount);\n', '\n', '        emit LongOtokenWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice deposit a collateral asset into a vault\n', '     * @dev only the account owner or operator can deposit collateral, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args DepositArgs structure\n', '     */\n', '    function _depositCollateral(Actions.DepositArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '        // only allow vault owner or vault operator to deposit collateral\n', '        require((_args.from == msg.sender) || (_args.from == _args.owner), "C20");\n', '\n', '        require(whitelist.isWhitelistedCollateral(_args.asset), "C21");\n', '\n', '        (, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n', '\n', '        if (typeVault == 1) {\n', '            nakedPoolBalance[_args.asset] = nakedPoolBalance[_args.asset].add(_args.amount);\n', '\n', '            require(nakedPoolBalance[_args.asset] <= nakedCap[_args.asset], "C37");\n', '        }\n', '\n', '        vaults[_args.owner][_args.vaultId].addCollateral(_args.asset, _args.amount, _args.index);\n', '\n', '        pool.transferToPool(_args.asset, _args.from, _args.amount);\n', '\n', '        emit CollateralAssetDeposited(_args.asset, _args.owner, _args.from, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice withdraw a collateral asset from a vault\n', '     * @dev only the account owner or operator can withdraw collateral, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args WithdrawArgs structure\n', '     */\n', '    function _withdrawCollateral(Actions.WithdrawArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '\n', '        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n', '\n', '        if (_isNotEmpty(vault.shortOtokens)) {\n', '            OtokenInterface otoken = OtokenInterface(vault.shortOtokens[0]);\n', '\n', '            require(now < otoken.expiryTimestamp(), "C22");\n', '        }\n', '\n', '        if (typeVault == 1) {\n', '            nakedPoolBalance[_args.asset] = nakedPoolBalance[_args.asset].sub(_args.amount);\n', '        }\n', '\n', '        vaults[_args.owner][_args.vaultId].removeCollateral(_args.asset, _args.amount, _args.index);\n', '\n', '        pool.transferToUser(_args.asset, _args.to, _args.amount);\n', '\n', '        emit CollateralAssetWithdrawed(_args.asset, _args.owner, _args.to, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice mint short oTokens from a vault which creates an obligation that is recorded in the vault\n', '     * @dev only the account owner or operator can mint an oToken, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args MintArgs structure\n', '     */\n', '    function _mintOtoken(Actions.MintArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '        require(whitelist.isWhitelistedOtoken(_args.otoken), "C23");\n', '\n', '        OtokenInterface otoken = OtokenInterface(_args.otoken);\n', '\n', '        require(now < otoken.expiryTimestamp(), "C24");\n', '\n', '        vaults[_args.owner][_args.vaultId].addShort(_args.otoken, _args.amount, _args.index);\n', '\n', '        otoken.mintOtoken(_args.to, _args.amount);\n', '\n', '        emit ShortOtokenMinted(_args.otoken, _args.owner, _args.to, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice burn oTokens to reduce or remove the minted oToken obligation recorded in a vault\n', '     * @dev only the account owner or operator can burn an oToken, cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args MintArgs structure\n', '     */\n', '    function _burnOtoken(Actions.BurnArgs memory _args)\n', '        internal\n', '        notPartiallyPaused\n', '        onlyAuthorized(msg.sender, _args.owner)\n', '    {\n', '        // check that vault id is valid for this vault owner\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '        // only allow vault owner or vault operator to burn otoken\n', '        require((_args.from == msg.sender) || (_args.from == _args.owner), "C25");\n', '\n', '        OtokenInterface otoken = OtokenInterface(_args.otoken);\n', '\n', '        // do not allow burning expired otoken\n', '        require(now < otoken.expiryTimestamp(), "C26");\n', '\n', '        // remove otoken from vault\n', '        vaults[_args.owner][_args.vaultId].removeShort(_args.otoken, _args.amount, _args.index);\n', '\n', '        // burn otoken\n', '        otoken.burnOtoken(_args.from, _args.amount);\n', '\n', '        emit ShortOtokenBurned(_args.otoken, _args.owner, _args.from, _args.vaultId, _args.amount);\n', '    }\n', '\n', '    /**\n', '     * @notice redeem an oToken after expiry, receiving the payout of the oToken in the collateral asset\n', '     * @dev cannot be called when system is fullyPaused\n', '     * @param _args RedeemArgs structure\n', '     */\n', '    function _redeem(Actions.RedeemArgs memory _args) internal {\n', '        OtokenInterface otoken = OtokenInterface(_args.otoken);\n', '\n', '        // check that otoken to redeem is whitelisted\n', '        require(whitelist.isWhitelistedOtoken(_args.otoken), "C27");\n', '\n', '        (address collateral, address underlying, address strike, uint256 expiry) = _getOtokenDetails(address(otoken));\n', '\n', '        // only allow redeeming expired otoken\n', '        require(now >= expiry, "C28");\n', '\n', '        require(_canSettleAssets(underlying, strike, collateral, expiry), "C29");\n', '\n', '        uint256 payout = getPayout(_args.otoken, _args.amount);\n', '\n', '        otoken.burnOtoken(msg.sender, _args.amount);\n', '\n', '        pool.transferToUser(collateral, _args.receiver, payout);\n', '\n', '        emit Redeem(_args.otoken, msg.sender, _args.receiver, collateral, _args.amount, payout);\n', '    }\n', '\n', '    /**\n', '     * @notice settle a vault after expiry, removing the net proceeds/collateral after both long and short oToken payouts have settled\n', '     * @dev deletes a vault of vaultId after net proceeds/collateral is removed, cannot be called when system is fullyPaused\n', '     * @param _args SettleVaultArgs structure\n', '     */\n', '    function _settleVault(Actions.SettleVaultArgs memory _args) internal onlyAuthorized(msg.sender, _args.owner) {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '\n', '        (MarginVault.Vault memory vault, uint256 typeVault, ) = getVaultWithDetails(_args.owner, _args.vaultId);\n', '\n', '        OtokenInterface otoken;\n', '\n', '        // new scope to avoid stack too deep error\n', '        // check if there is short or long otoken in vault\n', '        // do not allow settling vault that have no short or long otoken\n', '        // if there is a long otoken, burn it\n', '        // store otoken address outside of this scope\n', '        {\n', '            bool hasShort = _isNotEmpty(vault.shortOtokens);\n', '            bool hasLong = _isNotEmpty(vault.longOtokens);\n', '\n', '            require(hasShort || hasLong, "C30");\n', '\n', '            otoken = hasShort ? OtokenInterface(vault.shortOtokens[0]) : OtokenInterface(vault.longOtokens[0]);\n', '\n', '            if (hasLong) {\n', '                OtokenInterface longOtoken = OtokenInterface(vault.longOtokens[0]);\n', '\n', '                longOtoken.burnOtoken(address(pool), vault.longAmounts[0]);\n', '            }\n', '        }\n', '\n', '        (address collateral, address underlying, address strike, uint256 expiry) = _getOtokenDetails(address(otoken));\n', '\n', '        // do not allow settling vault with un-expired otoken\n', '        require(now >= expiry, "C31");\n', '        require(_canSettleAssets(underlying, strike, collateral, expiry), "C29");\n', '\n', '        (uint256 payout, bool isValidVault) = calculator.getExcessCollateral(vault, typeVault);\n', '\n', '        // require that vault is valid (has excess collateral) before settling\n', '        // to avoid allowing settling undercollateralized naked margin vault\n', '        require(isValidVault, "C32");\n', '\n', '        delete vaults[_args.owner][_args.vaultId];\n', '\n', '        if (typeVault == 1) {\n', '            nakedPoolBalance[collateral] = nakedPoolBalance[collateral].sub(payout);\n', '        }\n', '\n', '        pool.transferToUser(collateral, _args.to, payout);\n', '\n', '        uint256 vaultId = _args.vaultId;\n', '        address payoutRecipient = _args.to;\n', '\n', '        emit VaultSettled(_args.owner, address(otoken), payoutRecipient, payout, vaultId, typeVault);\n', '    }\n', '\n', '    /**\n', '     * @notice liquidate naked margin vault\n', '     * @dev can liquidate different vaults id in the same operate() call\n', '     * @param _args liquidation action arguments struct\n', '     */\n', '    function _liquidate(Actions.LiquidateArgs memory _args) internal notPartiallyPaused {\n', '        require(_checkVaultId(_args.owner, _args.vaultId), "C35");\n', '\n', '        // check if vault is undercollateralized\n', '        // the price is the amount of collateral asset to pay per 1 repaid debt(otoken)\n', '        // collateralDust is the minimum amount of collateral that can be left in the vault when a partial liquidation occurs\n', '        (MarginVault.Vault memory vault, bool isUnderCollat, uint256 price, uint256 collateralDust) = _isLiquidatable(\n', '            _args.owner,\n', '            _args.vaultId,\n', '            _args.roundId\n', '        );\n', '\n', '        require(isUnderCollat, "C33");\n', '\n', '        // amount of collateral to offer to liquidator\n', '        uint256 collateralToSell = _args.amount.mul(price).div(1e8);\n', '\n', '        // if vault is partially liquidated (amount of short otoken is still greater than zero)\n', '        // make sure remaining collateral amount is greater than dust amount\n', '        if (vault.shortAmounts[0].sub(_args.amount) > 0) {\n', '            require(vault.collateralAmounts[0].sub(collateralToSell) >= collateralDust, "C34");\n', '        }\n', '\n', '        // burn short otoken from liquidator address, index of short otoken hardcoded at 0\n', '        // this should always work, if vault have no short otoken, it will not reach this step\n', '        OtokenInterface(vault.shortOtokens[0]).burnOtoken(msg.sender, _args.amount);\n', '\n', '        // decrease amount of collateral in liquidated vault, index of collateral to decrease is hardcoded at 0\n', '        vaults[_args.owner][_args.vaultId].removeCollateral(vault.collateralAssets[0], collateralToSell, 0);\n', '\n', '        // decrease amount of short otoken in liquidated vault, index of short otoken to decrease is hardcoded at 0\n', '        vaults[_args.owner][_args.vaultId].removeShort(vault.shortOtokens[0], _args.amount, 0);\n', '\n', '        // decrease internal naked margin collateral amount\n', '        nakedPoolBalance[vault.collateralAssets[0]] = nakedPoolBalance[vault.collateralAssets[0]].sub(collateralToSell);\n', '\n', '        pool.transferToUser(vault.collateralAssets[0], _args.receiver, collateralToSell);\n', '\n', '        emit VaultLiquidated(\n', '            msg.sender,\n', '            _args.receiver,\n', '            _args.owner,\n', '            price,\n', '            _args.roundId,\n', '            collateralToSell,\n', '            _args.amount,\n', '            _args.vaultId\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice execute arbitrary calls\n', '     * @dev cannot be called when system is partiallyPaused or fullyPaused\n', '     * @param _args Call action\n', '     */\n', '    function _call(Actions.CallArgs memory _args) internal notPartiallyPaused onlyWhitelistedCallee(_args.callee) {\n', '        CalleeInterface(_args.callee).callFunction(msg.sender, _args.data);\n', '\n', '        emit CallExecuted(msg.sender, _args.callee, _args.data);\n', '    }\n', '\n', '    /**\n', '     * @notice check if a vault id is valid for a given account owner address\n', '     * @param _accountOwner account owner address\n', '     * @param _vaultId vault id to check\n', '     * @return True if the _vaultId is valid, False if not\n', '     */\n', '    function _checkVaultId(address _accountOwner, uint256 _vaultId) internal view returns (bool) {\n', '        return ((_vaultId > 0) && (_vaultId <= accountVaultCounter[_accountOwner]));\n', '    }\n', '\n', '    function _isNotEmpty(address[] memory _array) internal pure returns (bool) {\n', '        return (_array.length > 0) && (_array[0] != address(0));\n', '    }\n', '\n', '    /**\n', '     * @notice return if a callee address is whitelisted or not\n', '     * @param _callee callee address\n', '     * @return True if callee address is whitelisted, False if not\n', '     */\n', '    function _isCalleeWhitelisted(address _callee) internal view returns (bool) {\n', '        return whitelist.isWhitelistedCallee(_callee);\n', '    }\n', '\n', '    /**\n', '     * @notice check if a vault is liquidatable in a specific round id\n', '     * @param _owner vault owner address\n', '     * @param _vaultId vault id to check\n', '     * @param _roundId chainlink round id to check vault status at\n', '     * @return vault struct, isLiquidatable, true if vault is undercollateralized, the price of 1 repaid otoken and the otoken collateral dust amount\n', '     */\n', '    function _isLiquidatable(\n', '        address _owner,\n', '        uint256 _vaultId,\n', '        uint256 _roundId\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            MarginVault.Vault memory,\n', '            bool,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (MarginVault.Vault memory vault, uint256 typeVault, uint256 latestUpdateTimestamp) = getVaultWithDetails(\n', '            _owner,\n', '            _vaultId\n', '        );\n', '        (bool isUnderCollat, uint256 price, uint256 collateralDust) = calculator.isLiquidatable(\n', '            vault,\n', '            typeVault,\n', '            latestUpdateTimestamp,\n', '            _roundId\n', '        );\n', '\n', '        return (vault, isUnderCollat, price, collateralDust);\n', '    }\n', '\n', '    /**\n', '     * @dev get otoken detail, from both otoken versions\n', '     */\n', '    function _getOtokenDetails(address _otoken)\n', '        internal\n', '        view\n', '        returns (\n', '            address,\n', '            address,\n', '            address,\n', '            uint256\n', '        )\n', '    {\n', '        OtokenInterface otoken = OtokenInterface(_otoken);\n', '        try otoken.getOtokenDetails() returns (\n', '            address collateral,\n', '            address underlying,\n', '            address strike,\n', '            uint256,\n', '            uint256 expiry,\n', '            bool\n', '        ) {\n', '            return (collateral, underlying, strike, expiry);\n', '        } catch {\n', '            return (otoken.collateralAsset(), otoken.underlyingAsset(), otoken.strikeAsset(), otoken.expiryTimestamp());\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev return if an expired oToken is ready to be settled, only true when price for underlying,\n', '     * strike and collateral assets at this specific expiry is available in our Oracle module\n', '     * @return True if the oToken has expired AND all oracle prices at the expiry timestamp have been finalized, False if not\n', '     */\n', '    function _canSettleAssets(\n', '        address _underlying,\n', '        address _strike,\n', '        address _collateral,\n', '        uint256 _expiry\n', '    ) internal view returns (bool) {\n', '        return\n', '            oracle.isDisputePeriodOver(_underlying, _expiry) &&\n', '            oracle.isDisputePeriodOver(_strike, _expiry) &&\n', '            oracle.isDisputePeriodOver(_collateral, _expiry);\n', '    }\n', '\n', '    /**\n', '     * @dev updates the internal configuration of the controller\n', '     */\n', '    function _refreshConfigInternal() internal {\n', '        whitelist = WhitelistInterface(addressbook.getWhitelist());\n', '        oracle = OracleInterface(addressbook.getOracle());\n', '        calculator = MarginCalculatorInterface(addressbook.getMarginCalculator());\n', '        pool = MarginPoolInterface(addressbook.getMarginPool());\n', '    }\n', '}']