['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-07\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {cs := extcodesize(self)}\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library ECDSA {\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            revert("ECDSA: signature length is invalid");\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n', '            revert("ECDSA: signature.s is in the wrong range");\n', '        }\n', '\n', '        if (v != 27 && v != 28) {\n', '            revert("ECDSA: signature.v is in the wrong range");\n', '        }\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '     * @dev Fallback function.\n', '     * Implemented entirely in `_fallback`.\n', '     */\n', '    function() payable external {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @return The Address of the implementation.\n', '     */\n', '    function _implementation() internal view returns (address);\n', '\n', '    /**\n', '     * @dev Delegates execution to an implementation contract.\n', "     * This is a low level function that doesn't return to its internal call site.\n", '     * It will return to the external caller whatever the implementation returns.\n', '     * @param implementation Address to delegate.\n', '     */\n', '    function _delegate(address implementation) internal {\n', '        assembly {\n', '        // Copy msg.data. We take full control of memory in this inline assembly\n', '        // block because it will not return to Solidity code. We overwrite the\n', '        // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '        // Call the implementation.\n', "        // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '        // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 {revert(0, returndatasize)}\n', '            default {return (0, returndatasize)}\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function that is run as the first thing in the fallback function.\n', '     * Can be redefined in derived contracts to add functionality.\n', '     * Redefinitions must call super._willFallback().\n', '     */\n', '    function _willFallback() internal {\n', '    }\n', '\n', '    /**\n', '     * @dev fallback implementation.\n', '     * Extracted to enable manual triggering.\n', '     */\n', '    function _fallback() internal {\n', '        _willFallback();\n', '        _delegate(_implementation());\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n', ' */\n', 'library OpenZeppelinUpgradesAddress {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {size := extcodesize(account)}\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BaseUpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract BaseUpgradeabilityProxy is Proxy {\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * @return Address of the current implementation\n', '     */\n', '    function _implementation() internal view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the proxy to a new implementation.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function _setImplementation(address newImplementation) internal {\n', '        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n', ' * implementation and init data.\n', ' */\n', 'contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '     * @dev Contract constructor.\n', '     * @param _logic Address of the initial implementation.\n', '     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '     */\n', '    constructor(address _logic, bytes memory _data) public payable {\n', "        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BaseAdminUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with an authorization\n', ' * mechanism for administrative tasks.\n', ' * All external functions in this contract must be guarded by the\n', ' * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n', ' * feature proposal that would enable this to be done automatically.\n', ' */\n', 'contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '     * @dev Emitted when the administration has been transferred.\n', '     * @param previousAdmin Address of the previous admin.\n', '     * @param newAdmin Address of the new admin.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '\n', '    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the admin.\n', '     * If it is, it will run the function. Otherwise, it will delegate the call\n', '     * to the implementation.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == _admin()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return The address of the proxy admin.\n', '     */\n', '    function admin() external ifAdmin returns (address) {\n', '        return _admin();\n', '    }\n', '\n', '    /**\n', '     * @return The address of the implementation.\n', '     */\n', '    function implementation() external ifAdmin returns (address) {\n', '        return _implementation();\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * Only the current admin can call this function.\n', '     * @param newAdmin Address to transfer proxy administration to.\n', '     */\n', '    function changeAdmin(address newAdmin) external ifAdmin {\n', '        require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");\n', '        emit AdminChanged(_admin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the backing implementation of the proxy.\n', '     * Only the admin can call this function.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function upgradeTo(address newImplementation) external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the backing implementation of the proxy and call a function\n', '     * on the new implementation.\n', '     * This is useful to initialize the proxied contract.\n', '     * @param newImplementation Address of the new implementation.\n', '     * @param data Data to send as msg.data in the low level call.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     */\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '        (bool success,) = newImplementation.delegatecall(data);\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @return The admin slot.\n', '     */\n', '    function _admin() internal view returns (address adm) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            adm := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the proxy admin.\n', '     * @param newAdmin Address of the new proxy admin.\n', '     */\n', '    function _setAdmin(address newAdmin) internal {\n', '        bytes32 slot = ADMIN_SLOT;\n', '\n', '        assembly {\n', '            sstore(slot, newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Only fall back when the sender is not the admin.\n', '     */\n', '    function _willFallback() internal {\n', '        require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");\n', '        super._willFallback();\n', '    }\n', '}\n', '\n', '/**\n', ' * @title InitializableUpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n', ' * implementation and init data.\n', ' */\n', 'contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '     * @dev Contract initializer.\n', '     * @param _logic Address of the initial implementation.\n', '     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '     */\n', '    function initialize(address _logic, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', "        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title InitializableAdminUpgradeabilityProxy\n', ' * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for\n', ' * initializing the implementation, admin, and init data.\n', ' */\n', 'contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n', '    /**\n', '     * Contract initializer.\n', '     * @param _logic address of the initial implementation.\n', '     * @param _admin Address of the proxy administrator.\n', '     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '     * It should include the signature and the parameters of the function to be called, as described in\n', '     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '     */\n', '    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', '        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n', "        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n", '        _setAdmin(_admin);\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal {}\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this;\n', '        // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Initializable, Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function initialize(address sender) public initializer {\n', '        _owner = sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is Initializable, Ownable {\n', '    address public pendingOwner;\n', '\n', '    function initialize(address _nextOwner) public initializer {\n', '        Ownable.initialize(_nextOwner);\n', '    }\n', '\n', '    modifier onlyPendingOwner() {\n', '        require(\n', '            _msgSender() == pendingOwner,\n', '            "Claimable: caller is not the pending owner"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(\n', '            newOwner != owner() && newOwner != pendingOwner,\n', '            "Claimable: invalid new owner"\n', '        );\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public onlyPendingOwner {\n', '        _transferOwnership(pendingOwner);\n', '        delete pendingOwner;\n', '    }\n', '}\n', '\n', 'library String {\n', '    /// @notice Convert a uint value to its decimal string representation\n', '    // solium-disable-next-line security/no-assign-params\n', '    function fromUint(uint256 _i) internal pure returns (string memory) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint256 j = _i;\n', '        uint256 len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint256 k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '\n', '    /// @notice Convert a bytes32 value to its hex string representation.\n', '    function fromBytes32(bytes32 _value) internal pure returns (string memory) {\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(32 * 2 + 2);\n', '        str[0] = "0";\n', '        str[1] = "x";\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            str[2 + i * 2] = alphabet[uint256(uint8(_value[i] >> 4))];\n', '            str[3 + i * 2] = alphabet[uint256(uint8(_value[i] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    /// @notice Convert an address to its hex string representation.\n', '    function fromAddress(address _addr) internal pure returns (string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(20 * 2 + 2);\n', '        str[0] = "0";\n', '        str[1] = "x";\n', '        for (uint256 i = 0; i < 20; i++) {\n', '            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\n', '            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    /// @notice Append eight strings.\n', '    function add8(\n', '        string memory a,\n', '        string memory b,\n', '        string memory c,\n', '        string memory d,\n', '        string memory e,\n', '        string memory f,\n', '        string memory g,\n', '        string memory h\n', '    ) internal pure returns (string memory) {\n', '        return string(abi.encodePacked(a, b, c, d, e, f, g, h));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ERC20Staked is Initializable, Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public minimumStakeBalance;\n', '\n', '    struct stakeHolder {\n', '        uint index;\n', '        uint256 reward;\n', '        bool status;\n', '    }\n', '\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => stakeHolder) public _stakeHolderMap;\n', '    address[] internal _stakeHolders;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    uint256 private _totalPendingReward;\n', '\n', '    function initialize(uint256 _minimumStakeBalance) public initializer {\n', '        minimumStakeBalance = _minimumStakeBalance;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // staking function, remain reward is not claimed\n', '    function totalPendingReward() public view returns (uint256) {\n', '        return _totalPendingReward;\n', '    }\n', '\n', '    /**\n', '     * @notice A method to add a stakeholder.\n', '     * @param account The account to add.\n', '     */\n', '    function _addStakeholder(address account) private {\n', '        // if user exists, add _val\n', '        if (!_stakeHolderMap[account].status) {\n', '            // else its new user\n', '            _stakeHolders.push(account);\n', '            _stakeHolderMap[account].status = true;\n', '            _stakeHolderMap[account].index = _stakeHolders.length - 1;\n', '        }\n', '    }\n', '    /**\n', '     * @notice A method to remove a stakeholder.\n', '     * @param account The stakeholder to remove.\n', '     */\n', '    function _removeStakeholder(address account) private {\n', '        if (_stakeHolderMap[account].status) {\n', '            stakeHolder memory deletedHolder = _stakeHolderMap[account];\n', '            if (deletedHolder.index != _stakeHolders.length - 1) {\n', '                address lastAddress = _stakeHolders[_stakeHolders.length - 1];\n', '                _stakeHolders[deletedHolder.index] = lastAddress; // swap the last address to removed address\n', '                _stakeHolderMap[lastAddress].index = deletedHolder.index; // update index for the previous last one\n', '            }\n', '            _stakeHolderMap[account].status = false;\n', '            _stakeHolders.length--;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice A method to remove a stakeholder.\n', '     * @param account The account need to check.\n', '     */\n', '    function _checkStake(address account) private {\n', '        if (_balances[account] > minimumStakeBalance) {\n', '            _addStakeholder(account);\n', '        } else {\n', '            _removeStakeholder(account);\n', '        }\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    // staking function\n', '    function rewardOf(address account) public view returns (uint256) {\n', '        return _stakeHolderMap[account].reward;\n', '    }\n', '\n', '    // staking function\n', '    function isStaking(address account) public view returns (bool) {\n', '        return _stakeHolderMap[account].status;\n', '    }\n', '\n', '    // staking function\n', '    function getStakeIndex(address account) public view returns (uint) {\n', '        return _stakeHolderMap[account].index;\n', '    }\n', '\n', '    // staking function\n', '    function totalStakeHolders() public view returns (uint) {\n', '        return _stakeHolders.length;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _updateMinimumStakeBalance(uint256 _nextMinimumStakeBalance) internal {\n', '        minimumStakeBalance = _nextMinimumStakeBalance;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        _checkStake(sender);\n', '        // stake checking\n', '        _checkStake(recipient);\n', '        // stake checking\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        _checkStake(account);\n', '        // stake checking\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _checkStake(account);\n', '        // stake checking\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    // staking function, add stake amount and split to all holders base on totalSupply\n', '    function _splitStakeReward(uint256 amount) internal {\n', '        _totalPendingReward = _totalPendingReward.add(amount);\n', '        for (uint256 s = 0; s < _stakeHolders.length; s += 1) {\n', '            address account = _stakeHolders[s];\n', '            uint256 reward = amount.mul(_balances[account]).div(_totalSupply);\n', '            _stakeHolderMap[account].reward = _stakeHolderMap[account].reward.add(reward);\n', '        }\n', '    }\n', '\n', '    function _claimStakeReward(address account) internal {\n', '        _mint(account, _stakeHolderMap[account].reward);\n', '        _totalPendingReward = _totalPendingReward.sub(_stakeHolderMap[account].reward);\n', '        _stakeHolderMap[account].reward = 0;\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Optional functions from the ERC20 standard.\n', ' */\n', 'contract ERC20Detailed is Initializable, IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n', '     * these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {codehash := extcodehash(account)}\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success,) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {// Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract CanReclaimTokens is Claimable {\n', '    using SafeERC20 for ERC20Staked;\n', '\n', '    mapping(address => bool) private recoverableTokensBlacklist;\n', '\n', '    function initialize(address _nextOwner) public initializer {\n', '        Claimable.initialize(_nextOwner);\n', '    }\n', '\n', '    function blacklistRecoverableToken(address _token) public onlyOwner {\n', '        recoverableTokensBlacklist[_token] = true;\n', '    }\n', '\n', '    /// @notice Allow the owner of the contract to recover funds accidentally\n', '    /// sent to the contract. To withdraw ETH, the token should be set to `0x0`.\n', '    function recoverTokens(address _token) external onlyOwner {\n', '        require(\n', '            !recoverableTokensBlacklist[_token],\n', '            "CanReclaimTokens: token is not recoverable"\n', '        );\n', '\n', '        if (_token == address(0x0)) {\n', '            msg.sender.transfer(address(this).balance);\n', '        } else {\n', '            ERC20Staked(_token).safeTransfer(\n', '                msg.sender,\n', '                ERC20Staked(_token).balanceOf(address(this))\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '/// @notice Taken from the DAI token.\n', 'contract ERC20WithPermit is Initializable, ERC20Staked, ERC20Detailed {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) public nonces;\n', '\n', '    // If the token is redeployed, the version is increased to prevent a permit\n', '    // signature being used on both token instances.\n', '    string public version;\n', '\n', '    // --- EIP712 niceties ---\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    // PERMIT_TYPEHASH is the value returned from\n', '    // keccak256("Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)")\n', '    bytes32\n', '    public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n', '\n', '    function initialize(\n', '        uint256 _chainId,\n', '        string memory _version,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint8 _decimals\n', '    ) public initializer {\n', '        ERC20Detailed.initialize(_name, _symbol, _decimals);\n', '        version = _version;\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256(\n', '                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '                ),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes(version)),\n', '                _chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    // --- Approve by signature ---\n', '    function permit(\n', '        address holder,\n', '        address spender,\n', '        uint256 nonce,\n', '        uint256 expiry,\n', '        bool allowed,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                keccak256(\n', '                    abi.encode(\n', '                        PERMIT_TYPEHASH,\n', '                        holder,\n', '                        spender,\n', '                        nonce,\n', '                        expiry,\n', '                        allowed\n', '                    )\n', '                )\n', '            )\n', '        );\n', '\n', '        require(holder != address(0), "ERC20WithRate: address must not be 0x0");\n', '        require(\n', '            holder == ecrecover(digest, v, r, s),\n', '            "ERC20WithRate: invalid signature"\n', '        );\n', '        require(\n', '            expiry == 0 || now <= expiry,\n', '            "ERC20WithRate: permit has expired"\n', '        );\n', '        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");\n', '        uint256 amount = allowed ? uint256(- 1) : 0;\n', '        _approve(holder, spender, amount);\n', '    }\n', '}\n', '\n', 'contract TornomyERC20Staked is\n', 'Initializable,\n', 'ERC20Staked,\n', 'ERC20Detailed,\n', 'Ownable,\n', 'ERC20WithPermit,\n', 'Claimable,\n', 'CanReclaimTokens\n', '{\n', '    using SafeMath for uint256;\n', '    address public stakeAdmin;\n', '\n', '    function initialize(\n', '        uint256 _chainId,\n', '        address _nextOwner,\n', '        string memory _version,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint256 _minimumStakeBalance,\n', '        uint8 _decimals\n', '    ) public initializer {\n', '        ERC20Staked.initialize(_minimumStakeBalance);\n', '        ERC20Detailed.initialize(_name, _symbol, _decimals);\n', '        Ownable.initialize(_nextOwner);\n', '        ERC20WithPermit.initialize(\n', '            _chainId,\n', '            _version,\n', '            _name,\n', '            _symbol,\n', '            _decimals\n', '        );\n', '        Claimable.initialize(_nextOwner);\n', '        CanReclaimTokens.initialize(_nextOwner);\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) public onlyOwner {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    function burn(address _from, uint256 _amount) public onlyOwner {\n', '        _burn(_from, _amount);\n', '    }\n', '\n', '    function splitStakeReward(uint256 _amount) public onlyOwner {\n', '        _splitStakeReward(_amount);\n', '    }\n', '\n', "    /// @notice Allow the stakeAdmin to update the 'mint' fee.\n", '    function updateMinimumStakeBalance(uint256 _nextMinimumStakeBalance) public onlyOwner {\n', '        _updateMinimumStakeBalance(_nextMinimumStakeBalance);\n', '    }\n', '\n', '    function claimStakeReward() public {\n', '        _claimStakeReward(msg.sender);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        require(\n', '            recipient != address(this),\n', '            "TORNOMY ERC20: can\'t transfer to token address"\n', '        );\n', '        return super.transfer(recipient, amount);\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool)\n', '    {\n', '        require(\n', '            recipient != address(this),\n', '            "TORNOMY ERC20: can\'t transfer to stoken address"\n', '        );\n', '        return super.transferFrom(sender, recipient, amount);\n', '    }\n', '}\n', '\n', '// TODO: In ^0.6.0, should be `interface IGateway is IMintGateway,IBurnGateway {}`\n', 'interface IGateway {\n', '    // is IMintGateway\n', '    function mint(\n', '        string calldata _symbol,\n', '        address _recipient,\n', '        uint256 _amount,\n', '        bytes32 _nHash,\n', '        bytes calldata _sig\n', '    ) external returns (uint256);\n', '\n', '    function mintFee() external view returns (uint256);\n', '\n', '    // is IBurnGateway\n', '    function burn(bytes calldata _to, uint256 _amountScaled)\n', '    external\n', '    returns (uint256);\n', '\n', '    function burnFee() external view returns (uint256);\n', '}\n', '\n', 'contract GatewayState {\n', '    uint256 constant BIPS_DENOMINATOR = 10000;\n', '    uint256 public minimumBurnAmount;\n', '\n', '    /// @notice Each Gateway is tied to a specific TornomyERC20 token.\n', '    TornomyERC20Staked public token;\n', '\n', '    /// @notice The mintAuthority is an address that can sign mint requests.\n', '    address public mintAuthority;\n', '\n', '    /// @notice The stakeAuthority is an address that can call add stake reward.\n', '    address public stakeAuthority;\n', '\n', '    /// @dev feeRecipient is assumed to be an address (or a contract) that can\n', '    /// accept erc20 payments it cannot be 0x0.\n', '    /// @notice When tokens are mint or burnt, a portion of the tokens are\n', '    /// forwarded to a fee recipient.\n', '    address public feeRecipient;\n', '\n', '    /// @notice The mint fee in bips.\n', '    uint16 public mintFee;\n', '\n', '    /// @notice The burn fee in bips.\n', '    uint16 public burnFee;\n', '\n', '    /// @notice Each signature can only be seen once.\n', '    mapping(bytes32 => bool) public status;\n', '\n', '    // LogMint and LogBurn contain a unique `n` that identifies\n', '    // the mint or burn event.\n', '    uint256 public nextN = 0;\n', '}\n', '\n', '/// @notice Gateway handles verifying mint and burn requests. A mintAuthority\n', '/// approves new assets to be minted by providing a digital signature. An ownernpm\n', '/// of an asset can request for it to be burnt.\n', 'contract TornomyTokenGateway is\n', 'Initializable,\n', 'Claimable,\n', 'CanReclaimTokens,\n', 'GatewayState\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    event LogMintAuthorityUpdated(address indexed _newMintAuthority);\n', '    event LogStakeAuthorityUpdated(address indexed _newStakeAuthority);\n', '    event LogMint(\n', '        address indexed _to,\n', '        uint256 _amount,\n', '        uint256 indexed _n,\n', '        bytes32 indexed _signedMessageHash\n', '    );\n', '\n', '    event LogBurn(\n', '        bytes _to,\n', '        uint256 _amount,\n', '        uint256 indexed _n,\n', '        bytes indexed _indexedTo\n', '    );\n', '\n', '    /// @notice Only allow the Darknode Payment contract.\n', '    modifier onlyOwnerOrMintAuthority() {\n', '        require(\n', '            msg.sender == mintAuthority || msg.sender == owner(),\n', '            "Gateway: caller is not the owner or mint authority"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /// @param _token The TornomyERC20Staked this Gateway is responsible for.\n', '    /// @param _feeRecipient The recipient of burning and minting fees.\n', '    /// @param _mintAuthority The address of the key that can sign mint\n', '    ///        requests.\n', '    /// @param _mintFee The amount subtracted each mint request and\n', '    ///        forwarded to the feeRecipient. In BIPS.\n', '    /// @param _burnFee The amount subtracted each burn request and\n', '    ///        forwarded to the feeRecipient. In BIPS.\n', '    function initialize(\n', '        TornomyERC20Staked _token,\n', '        address _feeRecipient,\n', '        address _mintAuthority,\n', '        address _stakeAuthority,\n', '        uint16 _mintFee,\n', '        uint16 _burnFee,\n', '        uint256 _minimumBurnAmount\n', '    ) public initializer {\n', '        Claimable.initialize(msg.sender);\n', '        CanReclaimTokens.initialize(msg.sender);\n', '        minimumBurnAmount = _minimumBurnAmount;\n', '        token = _token;\n', '        mintFee = _mintFee;\n', '        burnFee = _burnFee;\n', '        updateStakeAuthority(_stakeAuthority);\n', '        updateMintAuthority(_mintAuthority);\n', '        updateFeeRecipient(_feeRecipient);\n', '    }\n', '\n', '    // Public functions ////////////////////////////////////////////////////////\n', '\n', '    /// @notice Claims ownership of the token passed in to the constructor.\n', '    /// `transferStoreOwnership` must have previously been called.\n', '    /// Anyone can call this function.\n', '    function claimTokenOwnership() public {\n', '        token.claimOwnership();\n', '    }\n', '\n', '    /// @notice Allow the owner to update the owner of the TornomyERC20Staked token.\n', '    function transferTokenOwnership(TornomyTokenGateway _nextTokenOwner)\n', '    public\n', '    onlyOwner\n', '    {\n', '        token.transferOwnership(address(_nextTokenOwner));\n', '        _nextTokenOwner.claimTokenOwnership();\n', '    }\n', '\n', '    /// @notice Allow the owner to update the fee recipient.\n', '    ///\n', '    /// @param _nextMintAuthority The address to start paying fees to.\n', '    function updateMintAuthority(address _nextMintAuthority)\n', '    public\n', '    onlyOwnerOrMintAuthority\n', '    {\n', '        // The mint authority should not be set to 0, which is the result\n', '        // returned by ecrecover for an invalid signature.\n', '        require(\n', '            _nextMintAuthority != address(0),\n', '            "Gateway: mintAuthority cannot be set to address zero"\n', '        );\n', '        mintAuthority = _nextMintAuthority;\n', '        emit LogMintAuthorityUpdated(mintAuthority);\n', '    }\n', '\n', '    /// @notice Allow the owner to update the stakeAuthority\n', '    ///\n', '    /// @param _nextStakeAuthority The address to add stake reward.\n', '    function updateStakeAuthority(address _nextStakeAuthority) public onlyOwner {\n', '        // The stake authority should not be set to 0, which is the result\n', '        require(_nextStakeAuthority != address(0), "Gateway: _nextStakeAuthority cannot be set to address zero");\n', '        stakeAuthority = _nextStakeAuthority;\n', '        emit LogStakeAuthorityUpdated(_nextStakeAuthority);\n', '    }\n', '\n', '    /// @notice Allow the owner to update the minimum burn amount.\n', '    ///\n', '    /// @param _minimumStakeBalance The new min burn amount.\n', '    function updateMinimumStakeBalance(uint256 _minimumStakeBalance) public onlyOwner {\n', '        token.updateMinimumStakeBalance(_minimumStakeBalance);\n', '    }\n', '\n', '    /// @notice Allow the owner to update the minimum burn amount.\n', '    ///\n', '    /// @param _minimumBurnAmount The new min burn amount.\n', '    function updateMinimumBurnAmount(uint256 _minimumBurnAmount) public onlyOwner {\n', '        minimumBurnAmount = _minimumBurnAmount;\n', '    }\n', '\n', '    /// @notice Allow the stake authority to add stake reward.\n', '    ///\n', '    /// @param amount: reward amount to split to all stakeholder.\n', '    function addStakeReward(uint256 amount) public {\n', '        require(\n', '            msg.sender == stakeAuthority,\n', '            "Gateway: only stake authority can add stake reward"\n', '        );\n', '        token.splitStakeReward(amount);\n', '    }\n', '\n', '    /// @notice Allow the owner to update the fee recipient.\n', '    ///\n', '    /// @param _nextFeeRecipient The address to start paying fees to.\n', '    function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {\n', "        // 'mint' and 'burn' will fail if the feeRecipient is 0x0\n", '        require(\n', '            _nextFeeRecipient != address(0x0),\n', '            "Gateway: fee recipient cannot be 0x0"\n', '        );\n', '\n', '        feeRecipient = _nextFeeRecipient;\n', '    }\n', '\n', "    /// @notice Allow the owner to update the 'mint' fee.\n", '    ///\n', '    /// @param _nextMintFee The new fee for minting and burning.\n', '    function updateMintFee(uint16 _nextMintFee) public onlyOwner {\n', '        mintFee = _nextMintFee;\n', '    }\n', '\n', '    /// @notice Allow the owner to update the burn fee.\n', '    ///\n', '    /// @param _nextBurnFee The new fee for minting and burning.\n', '    function updateBurnFee(uint16 _nextBurnFee) public onlyOwner {\n', '        burnFee = _nextBurnFee;\n', '    }\n', '\n', '    function mint(\n', '        string calldata _symbol,\n', '        address _recipient,\n', '        uint256 _amount,\n', '        bytes32 _nHash,\n', '        bytes calldata _sig\n', '    ) external {\n', '        bytes32 payloadHash = keccak256(abi.encode(_symbol, _recipient));\n', '        // Verify signature\n', '        bytes32 signedMessageHash = hashForSignature(\n', '            _symbol,\n', '            _recipient,\n', '            _amount,\n', '            msg.sender,\n', '            _nHash\n', '        );\n', '        require(\n', '            status[signedMessageHash] == false,\n', '            "Gateway: nonce hash already spent"\n', '        );\n', '        if (!verifySignature(signedMessageHash, _sig)) {\n', '            // Return a detailed string containing the hash and recovered\n', '            // signer. This is somewhat costly but is only run in the revert\n', '            // branch.\n', '            revert(\n', '                String.add8(\n', '                    "Gateway: invalid signature. pHash: ",\n', '                    String.fromBytes32(payloadHash),\n', '                    ", amount: ",\n', '                    String.fromUint(_amount),\n', '                    ", msg.sender: ",\n', '                    String.fromAddress(msg.sender),\n', '                    ", _nHash: ",\n', '                    String.fromBytes32(_nHash)\n', '                )\n', '            );\n', '        }\n', '        status[signedMessageHash] = true;\n', '\n', '        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n', '        uint256 absoluteFee = _amount.mul(mintFee).div(\n', '            BIPS_DENOMINATOR\n', '        );\n', '        uint256 receivedAmount = _amount.sub(\n', '            absoluteFee,\n', '            "Gateway: fee exceeds amount"\n', '        );\n', '\n', '        // Mint amount minus the fee\n', '        token.mint(_recipient, receivedAmount);\n', '        // Mint the fee\n', '        token.mint(feeRecipient, absoluteFee);\n', '\n', '        emit LogMint(\n', '            _recipient,\n', '            receivedAmount,\n', '            nextN,\n', '            signedMessageHash\n', '        );\n', '        nextN += 1;\n', '    }\n', '\n', '    /// @notice burn destroys tokens after taking a fee for the `_feeRecipient`,\n', '    ///         allowing the associated assets to be released on their native\n', '    ///         chain.\n', '    ///\n', '    /// @param _to The address to receive the un-bridged asset. The format of\n', '    ///        this address should be of the destination chain.\n', '    ///        For example, when burning to Bitcoin, _to should be a\n', '    ///        Bitcoin address.\n', '    /// @param _amount The amount of the token being burnt, in its\n', '    ///        smallest value. (e.g. satoshis for BTC)\n', '    function burn(bytes calldata _to, uint256 _amount) external {\n', '        //    function burn(bytes memory _to, uint256 _amount) public returns (uint256) {\n', '        require(\n', '            token.transferFrom(_msgSender(), address(this), _amount),\n', '            "token transfer failed"\n', '        );\n', '        // The recipient must not be empty. Better validation is possible,\n', '        // but would need to be customized for each destination ledger.\n', '        require(_to.length != 0, "Gateway: to address is empty");\n', '\n', '        // Calculate fee, subtract it from amount being burnt.\n', '        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);\n', '        uint256 amountAfterFee = _amount.sub(\n', '            fee,\n', '            "Gateway: fee exceeds amount"\n', '        );\n', '\n', '        // Burn the whole amount, and then re-mint the fee.\n', '        token.burn(address(this), _amount);\n', '        token.mint(feeRecipient, fee);\n', '\n', '        require(\n', '        // Must be strictly greater, to that the release transaction is of\n', '        // at least one unit.\n', '            amountAfterFee > minimumBurnAmount,\n', '            "Gateway: amount is less than the minimum burn amount"\n', '        );\n', '\n', '        emit LogBurn(_to, amountAfterFee, nextN, _to);\n', '        nextN += 1;\n', '    }\n', '\n', '    /// @notice verifySignature checks the the provided signature matches the provided\n', '    /// parameters.\n', '    function verifySignature(bytes32 _signedMessageHash, bytes memory _sig) public view returns (bool)\n', '    {\n', '        bytes32 ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_signedMessageHash);\n', '        address signer = ECDSA.recover(ethSignedMessageHash, _sig);\n', '        return mintAuthority == signer;\n', '    }\n', '\n', '\n', '    /// @notice hashForSignature hashes the parameters so that they can be signed.\n', '    function hashForSignature(\n', '        string memory _symbol,\n', '        address _recipient,\n', '        uint256 _amount,\n', '        address _caller,\n', '        bytes32 _nHash\n', '    ) public view returns (bytes32) {\n', '        bytes32 payloadHash = keccak256(abi.encode(_symbol, _recipient));\n', '        return\n', '        keccak256(abi.encode(payloadHash, _amount, address(token), _caller, _nHash));\n', '    }\n', '}']