['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import {SafeMath} from "../../lib/SafeMath.sol";\n', 'import {Ownable} from "../../lib/Ownable.sol";\n', 'import {FixedPoint} from "../../lib/FixedPoint.sol";\n', '\n', 'import {IKeep3rV1} from "./IKeep3rV1.sol";\n', 'import {UniswapV2OracleLibrary} from "./UniswapV2OracleLibrary.sol";\n', 'import {UniswapV2Library} from "./UniswapV2Library.sol";\n', '\n', '/**\n', ' * @notice A Time-weighted average prices oracle and Keeper job for any uniswap pair\n', ' */\n', 'contract ArcUniswapV2Oracle is Ownable {\n', '    /* ========== Libraries ========== */\n', '\n', '    using SafeMath for uint;\n', '\n', '    /* ========== Storage ========== */\n', '\n', '    IKeep3rV1 public KP3R;\n', '\n', '    address public uniV2Factory;\n', '\n', '    uint public periodWindow = 1 hours;\n', '\n', '    // mapping from pair address to a list of price observations of that pair\n', '    mapping(address => Observation[]) public pairObservations;\n', '\n', '    address[] internal _pairs;\n', '\n', '    mapping(address => bool) internal _known;\n', '\n', '    /* ========== Types ========== */\n', '\n', '    struct Observation {\n', '        uint timestamp;\n', '        uint price0Cumulative;\n', '        uint price1Cumulative;\n', '    }\n', '\n', '    /* ========== Events ========== */\n', '\n', '    event WorkDone(address keeper);\n', '\n', '    event UpdatedAll(address caller);\n', '\n', '    event PairUpdated(address pair);\n', '\n', '    event PairAdded(address pair);\n', '\n', '    event PairRemoved(address pair);\n', '\n', '    event Keep3rV1AddressSet(address kp3r);\n', '\n', '    event PeriodWindowSet(uint newPeriodWindow);\n', '\n', '    event UniV2FactorySet(address newUniV2Factory);\n', '\n', '    /* ========== Modifiers ========== */\n', '\n', '    modifier keeper() {\n', '        require(\n', '            KP3R.isKeeper(msg.sender),\n', '            "isKeeper(): keeper is not registered"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /* ========== Constructor ========== */\n', '\n', '    constructor(\n', '        address _kp3r,\n', '        address _uniV2Factory\n', '    )\n', '        public\n', '    {\n', '        require(\n', '            _kp3r != address(0) && _uniV2Factory != address(0),\n', '            "ArcUniswapV2Oracle: Keeper and univ2Factory address must not be null"\n', '        );\n', '\n', '        KP3R = IKeep3rV1(_kp3r);\n', '        uniV2Factory = _uniV2Factory;\n', '    }\n', '\n', '    /* ========== Keeper Functions ========== */\n', '\n', '    /**\n', '     * @notice Updates all pairs. The function to be called by the keeper to be rewarded.\n', '     */\n', '    function work() external keeper {\n', '        bool worked = _updateAll();\n', '\n', '        require(\n', '            worked,\n', '            "ArcUniswapV2Oracle:work: the work was not completed!"\n', '        );\n', '\n', '        KP3R.worked(msg.sender);\n', '\n', '        emit WorkDone(msg.sender);\n', '    }\n', '\n', '    /* ========== External Functions ========== */\n', '\n', '    /**\n', '     * @notice Updates the pair if it is known\n', '     * @return `true` if the pair was successfully updated\n', '     */\n', '    function updateTokensPair(\n', '        address _token0,\n', '        address _token1\n', '    )\n', '        external\n', '        returns (bool)\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\n', '        return updatePair(pair);\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the given pair\n', '     * @param _pair The pair to be updated\n', '     */\n', '    function updatePair(address _pair)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(\n', '            _known[_pair],\n', '            "ArcUniswapV2Oracle:updatePair(): The pair is not known"\n', '        );\n', '\n', '        bool updated = _update(_pair);\n', '\n', '        if (updated) {\n', '            emit PairUpdated(_pair);\n', '        }\n', '\n', '        return updated;\n', '    }\n', '\n', '    /**\n', '     * @notice Updates all pairs\n', '     */\n', '    function updateAll() external returns (bool) {\n', '        bool worked = _updateAll();\n', '\n', '        if (worked) {\n', '            emit UpdatedAll(msg.sender);\n', '        }\n', '\n', '        return worked;\n', '    }\n', '\n', '    /* ========== Public Getters ========== */\n', '\n', '    function getPairObservations(address _pair)\n', '        external\n', '        view\n', '        returns (Observation[] memory)\n', '    {\n', '        return pairObservations[_pair];\n', '    }\n', '\n', '    function getPairs()\n', '        external\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        return _pairs;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the last recorded observation for the pair\n', '     * @param _pair The pair we want the last observation for\n', '     */\n', '    function lastObservation(address _pair)\n', '        public\n', '        view\n', '        returns (Observation memory)\n', '    {\n', '        require(\n', '            _known[_pair],\n', '            "ArcUniswapV2Oracle:lastObservation(): The pair is not known"\n', '        );\n', '\n', '        Observation[] memory foundPairObservations = pairObservations[_pair];\n', '        return pairObservations[_pair][foundPairObservations.length - 1];\n', '    }\n', '\n', '    /**\n', '     * @notice returns the last observation for the token pair\n', '     */\n', '    function lastObservationTokens(\n', '        address _token0,\n', '        address _token1\n', '    )\n', '        external\n', '        view\n', '        returns (Observation memory)\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\n', '\n', '        require(\n', '            _known[pair],\n', '            "ArcUniswapV2Oracle:lastObservationTokens(): The pair is not known"\n', '        );\n', '\n', '        Observation[] memory foundPairObservations = pairObservations[pair];\n', '        return pairObservations[pair][foundPairObservations.length - 1];\n', '    }\n', '\n', '    /**\n', '     * @notice Returns true if pair is updatable given the period window. Therefore calling work() will yield a reward\n', '     * @param _pair The pair to make the check for\n', '     */\n', '    function workablePair(address _pair)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        require(\n', '            _known[_pair],\n', '            "ArcUniswapV2Oracle:workablePair(): pair is not known"\n', '        );\n', '\n', '        Observation memory observation = lastObservation(_pair);\n', '        uint timeElapsed = block.timestamp.sub(observation.timestamp);\n', '\n', '        return timeElapsed > periodWindow;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns true if pair is updatable given the period window. Therefore calling work() will yield a reward\n', '     */\n', '    function workableTokens(\n', '        address _token0,\n', '        address _token1\n', '    )\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\n', '\n', '        require(\n', '            _known[pair],\n', '            "ArcUniswapV2Oracle:workableTokens(): pair is not known"\n', '        );\n', '\n', '        Observation memory observation = lastObservation(pair);\n', '        uint timeElapsed = block.timestamp.sub(observation.timestamp);\n', '\n', '        return timeElapsed > periodWindow;\n', '    }\n', '\n', '    /**\n', '     * @notice Iterates over all known pairs and checks wether there is at least one pair that is updatable\n', '     */\n', '    function workable()\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            if (workablePair(_pairs[i])) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the pair address of the two tokens\n', '     */\n', '    function pairFor(address _token0, address _token1)\n', '        external\n', '        view\n', '        returns (address)\n', '    {\n', '        return UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\n', '    }\n', '\n', '    /**\n', '     * @notice Computes and returns how much of `_tokenOut` you would get if you give `_amountIn` of `_tokenIn`\n', '     *\n', '     * @param _tokenIn the address of the token in\n', '     * @param _amountIn the amount in terms of `_tokenIn`\n', '     * @param _tokenOut the address of the token out\n', '     */\n', '    function current(\n', '        address _tokenIn,\n', '        uint _amountIn,\n', '        address _tokenOut\n', '    )\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenIn, _tokenOut);\n', '\n', '        require(\n', '            _valid(pair, periodWindow.mul(2)),\n', '            "ArcUniswapV2Oracle:current(): stale prices"\n', '        );\n', '\n', '        (address token0, ) = UniswapV2Library.sortTokens(_tokenIn, _tokenOut);\n', '        Observation memory observation = lastObservation(pair);\n', '        (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n', '\n', '        if (block.timestamp == observation.timestamp) {\n', '            Observation[] memory observationsForPair = pairObservations[pair];\n', '            observation = pairObservations[pair][observationsForPair.length.sub(2)];\n', '        }\n', '\n', '        uint timeElapsed = block.timestamp.sub(observation.timestamp);\n', '        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n', '\n', '        if (token0 == _tokenIn) {\n', '            // prettier-ignore\n', '            return _computeAmountOut(\n', '                observation.price0Cumulative,\n', '                price0Cumulative,\n', '                timeElapsed,\n', '                _amountIn\n', '            );\n', '        } else {\n', '            // prettier-ignore\n', '            return _computeAmountOut(\n', '                observation.price1Cumulative,\n', '                price1Cumulative,\n', '                timeElapsed,\n', '                _amountIn\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Gives a price quote based on the granularity\n', '     * @param _tokenIn the token that `_amountIn` is denominated in\n', '     * @param _amountIn the amount to get the quote for\n', '     * @param _tokenOut the token that the result is denominated in\n', '     * @param _granularity the granularity of the quote in terms of time.\n', '     *                     Ex. if `_granularity` = 2, the quote will be return a\n', '     *                     price based on the `periodWindow` * 2\n', '     */\n', '    function quote(\n', '        address _tokenIn,\n', '        uint _amountIn,\n', '        address _tokenOut,\n', '        uint _granularity\n', '    )\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenIn, _tokenOut);\n', '\n', '        require(\n', '            _valid(pair, periodWindow.mul(_granularity)),\n', '            "ArcUniswapV2Oracle:quote(): stale prices"\n', '        );\n', '\n', '        (address token0, ) = UniswapV2Library.sortTokens(_tokenIn, _tokenOut);\n', '\n', '        uint priceAverageCumulative = 0;\n', '        uint length = pairObservations[pair].length - 1;\n', '        uint i = length.sub(_granularity);\n', '\n', '        uint nextIndex = 0;\n', '        if (token0 == _tokenIn) {\n', '            for (; i < length; i++) {\n', '                nextIndex = i + 1;\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    pairObservations[pair][i].price0Cumulative,\n', '                    pairObservations[pair][nextIndex].price0Cumulative,\n', '                    pairObservations[pair][nextIndex].timestamp.sub(pairObservations[pair][i].timestamp),\n', '                    _amountIn\n', '                );\n', '            }\n', '        } else {\n', '            for (; i < length; i++) {\n', '                nextIndex = i + 1;\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    pairObservations[pair][i].price1Cumulative,\n', '                    pairObservations[pair][nextIndex].price1Cumulative,\n', '                    pairObservations[pair][nextIndex].timestamp.sub(pairObservations[pair][i].timestamp),\n', '                    _amountIn\n', '                );\n', '            }\n', '        }\n', '\n', '        return priceAverageCumulative.div(_granularity);\n', '    }\n', '\n', '    /* ========== Owner functions ========== */\n', '\n', '    /**\n', '     * @notice Sets the period window\n', '     */\n', '    function setPeriodWindow(uint _periodWindow) external onlyOwner {\n', '\n', '        require(\n', '            _periodWindow != 0,\n', '            "ArcUniswapV2Oracle:setPeriodWindow(): period window cannot be 0!"\n', '        );\n', '\n', '        periodWindow = _periodWindow;\n', '        emit PeriodWindowSet(_periodWindow);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the Keep3rV1 address\n', '     */\n', '    function setKeep3rAddress(address _kp3r) external onlyOwner {\n', '        require(\n', '            _kp3r != address(0),\n', '            "ArcUniswapV2Oracle:setKeep3rAddress(): _kp3r must not be null"\n', '        );\n', '\n', '        KP3R = IKeep3rV1(_kp3r);\n', '        emit Keep3rV1AddressSet(_kp3r);\n', '    }\n', '\n', '    /**\n', '     * @notice Adds the pair to the known pairs. Will start updating the given pair\n', "     * @dev the order doesn't matter because they are be sorted later down the road\n", '     * @param _token0 first token of the pair\n', '     * @param _token1 second token of the pair\n', '     */\n', '    function addPair(\n', '        address _token0,\n', '        address _token1\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _token0, _token1);\n', '\n', '        require(!_known[pair], "ArcUniswapV2Oracle:addPair(): already known");\n', '\n', '        _known[pair] = true;\n', '        _pairs.push(pair);\n', '\n', '        // Add an observation\n', '        (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(pair);\n', '        pairObservations[pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n', '\n', '        emit PairAdded(pair);\n', '        emit PairUpdated(pair);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes a pair\n', '     */\n', '    function removePair(\n', '        address _tokenA,\n', '        address _tokenB\n', '    )\n', '        external\n', '        onlyOwner\n', '    {\n', '        address pair = UniswapV2Library.pairFor(uniV2Factory, _tokenA, _tokenB);\n', '\n', '        require(\n', '            _known[pair],\n', '            "ArcUniswapV2Oracle:removePair(): pair not added"\n', '        );\n', '\n', '        // Remove the pair from the pairs array\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            if (_pairs[i] == pair) {\n', '                delete _pairs[i];\n', '                _pairs[i] = _pairs[_pairs.length - 1];\n', '                _pairs.length--;\n', '\n', '                break;\n', '            }\n', '        }\n', '\n', '        delete _known[pair];\n', '        delete pairObservations[pair];\n', '\n', '        emit PairRemoved(pair);\n', '    }\n', '\n', '    /**\n', '     * @notice sets the univ2 factory address\n', '     */\n', '    function setUniV2FactoryAddress(address _uniV2Factory)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            _uniV2Factory != address(0),\n', '            "ArcUniswapV2Oracle:setUniV2FactoryAddress(): _uniV2Factory cannot be 0"\n', '        );\n', '\n', '        uniV2Factory = _uniV2Factory;\n', '        emit UniV2FactorySet(_uniV2Factory);\n', '    }\n', '\n', '    /* ========== Internal Functions ========== */\n', '\n', '    /**\n', '     * @dev Updates the pair if within the time window\n', '     * @param _pair The pair to update\n', '     */\n', '    function _update(address _pair)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        // we only want to commit updates once per period (i.e. windowSize / granularity)\n', '        uint timeElapsed = block.timestamp - lastObservation(_pair).timestamp;\n', '\n', '        if (timeElapsed > periodWindow) {\n', '            (uint price0Cumulative, uint price1Cumulative, ) = UniswapV2OracleLibrary.currentCumulativePrices(_pair);\n', '\n', '            pairObservations[_pair].push(Observation(block.timestamp, price0Cumulative, price1Cumulative));\n', '\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Loops over all registered pairs and updates them\n', '     */\n', '    function _updateAll()\n', '        internal\n', '        returns (bool updated)\n', '    {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            if (_update(_pairs[i])) {\n', '                updated = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks wether the pair was updated within `age` time\n', '     */\n', '    function _valid(\n', '        address _pair,\n', '        uint _age\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return block.timestamp.sub(lastObservation(_pair).timestamp) <= _age;\n', '    }\n', '\n', '    function _computeAmountOut(\n', '        uint _priceCumulativeStart,\n', '        uint _priceCumulativeEnd,\n', '        uint _timeElapsed,\n', '        uint _amountIn\n', '    )\n', '        private\n', '        pure\n', '        returns (uint amountOut)\n', '    {\n', '        // overflow is desired.\n', '        FixedPoint.uq112x112 memory priceAverage =\n', '            FixedPoint.uq112x112(uint224((_priceCumulativeEnd - _priceCumulativeStart) / _timeElapsed));\n', '        FixedPoint.uq144x112 memory priceAverageMultiplied = FixedPoint.mul(priceAverage, _amountIn);\n', '\n', '        return FixedPoint.decode144(priceAverageMultiplied);\n', '    }\n', '}']