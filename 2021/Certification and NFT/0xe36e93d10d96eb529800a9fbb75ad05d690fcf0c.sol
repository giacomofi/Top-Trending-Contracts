['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-26\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IV2Strategy {\n', '    function name() external view returns (string memory);\n', '\n', '    function apiVersion() external view returns (string memory);\n', '\n', '    function strategist() external view returns (address);\n', '\n', '    function rewards() external view returns (address);\n', '\n', '    function vault() external view returns (address);\n', '\n', '    function keeper() external view returns (address);\n', '\n', '    function want() external view returns (address);\n', '\n', '    function emergencyExit() external view returns (bool);\n', '\n', '    function isActive() external view returns (bool);\n', '\n', '    function delegatedAssets() external view returns (uint256);\n', '\n', '    function estimatedTotalAssets() external view returns (uint256);\n', '    \n', '    function doHealthCheck() external view returns (bool);\n', '    \n', '    function healthCheck() external view returns (address);\n', '}\n', '\n', 'interface IAddressesGenerator {\n', '    function assetsAddresses() external view returns (address[] memory);\n', '}\n', '\n', 'interface IV2Vault {\n', '    function withdrawalQueue(uint256 arg0) external view returns (address);\n', '}\n', '\n', 'interface IHelper {\n', '    function mergeAddresses(address[][] memory addressesSets)\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '}\n', '\n', 'contract StrategiesHelper {\n', '    address public addressesGeneratorAddress;\n', '    address public helperAddress;\n', '    address public ownerAddress;\n', '\n', '    struct StrategyMetadata {\n', '        string name;\n', '        string apiVersion;\n', '        address strategist;\n', '        address rewards;\n', '        address vault;\n', '        address keeper;\n', '        address want;\n', '        bool emergencyExit;\n', '        bool isActive;\n', '        uint256 delegatedAssets;\n', '        uint256 estimatedTotalAssets;\n', '        bool doHealthCheck;\n', '        address healthCheckAddress;\n', '    }\n', '\n', '    constructor(address _addressesGeneratorAddress, address _helperAddress) {\n', '        addressesGeneratorAddress = _addressesGeneratorAddress;\n', '        helperAddress = _helperAddress;\n', '        ownerAddress = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * Fetch the number of strategies for a vault\n', '     */\n', '    function assetStrategiesLength(address assetAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 strategyIdx;\n', '        while (true) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            if (strategyAddress == address(0)) {\n', '                break;\n', '            }\n', '            strategyIdx++;\n', '        }\n', '        return strategyIdx;\n', '    }\n', '\n', '    /**\n', '     * Fetch the total number of strategies for all vaults\n', '     */\n', '    function assetsStrategiesLength() public view returns (uint256) {\n', '        return assetsStrategiesAddresses().length;\n', '    }\n', '\n', '    /**\n', '     * Fetch strategy addresses given a vault address\n', '     */\n', '    function assetStrategiesAddresses(address assetAddress)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n', '        address[] memory _strategiesAddresses =\n', '            new address[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            _strategiesAddresses[strategyIdx] = strategyAddress;\n', '        }\n', '        return _strategiesAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch all strategy addresses for all vaults\n', '     */\n', '     function assetsStrategiesAddresses() public view returns (address[] memory) {\n', '        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n', '        return assetsStrategiesAddresses(_assetsAddresses);\n', '     }\n', '\n', '    /**\n', '     * Fetch all strategy addresses given an array of vaults\n', '     */\n', '    function assetsStrategiesAddresses(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        address[][] memory _strategiesForAssets =\n', '            new address[][](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            address[] memory _assetStrategiessAddresses =\n', '                assetStrategiesAddresses(assetAddress);\n', '            _strategiesForAssets[assetIdx] = _assetStrategiessAddresses;\n', '        }\n', '        address[] memory mergedAddresses =\n', '            IHelper(helperAddress).mergeAddresses(_strategiesForAssets);\n', '        return mergedAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch total delegated balance for all strategies\n', '     */\n', '    function assetsStrategiesDelegatedBalance()\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address[] memory _assetsAddresses = IAddressesGenerator(addressesGeneratorAddress).assetsAddresses();\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        uint256 assetsDelegatedBalance;\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            uint256 assetDelegatedBalance =\n', '                assetStrategiesDelegatedBalance(assetAddress);\n', '            assetsDelegatedBalance += assetDelegatedBalance;\n', '        }\n', '        return assetsDelegatedBalance;\n', '    }\n', '\n', '    /**\n', "     * Fetch delegated balance for all of a vault's strategies\n", '     */\n', '    function assetStrategiesDelegatedBalance(address assetAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address[] memory _assetStrategiesAddresses =\n', '            assetStrategiesAddresses(assetAddress);\n', '        uint256 numberOfStrategies = _assetStrategiesAddresses.length;\n', '        uint256 strategiesDelegatedBalance;\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = _assetStrategiesAddresses[strategyIdx];\n', '            IV2Strategy _strategy = IV2Strategy(strategyAddress);\n', '            uint256 strategyDelegatedBalance = _strategy.delegatedAssets();\n', '            strategiesDelegatedBalance += strategyDelegatedBalance;\n', '        }\n', '        return strategiesDelegatedBalance;\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for all strategies scoped to a vault\n', '     */\n', '    function assetStrategies(address assetAddress)\n', '        external\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        uint256 numberOfStrategies = assetStrategiesLength(assetAddress);\n', '        StrategyMetadata[] memory _strategies =\n', '            new StrategyMetadata[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = vault.withdrawalQueue(strategyIdx);\n', '            StrategyMetadata memory _strategy = strategy(strategyAddress);\n', '            _strategies[strategyIdx] = _strategy;\n', '        }\n', '        return _strategies;\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for all strategies\n', '     */\n', '    function assetsStrategies()\n', '        external\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        address[] memory _assetsStrategiesAddresses =\n', '            assetsStrategiesAddresses();\n', '        return strategies(_assetsStrategiesAddresses);\n', '    }\n', '    \n', '    /**\n', '     * Fetch metadata for a strategy given a strategy address\n', '     */\n', '    function strategy(address strategyAddress)\n', '        public\n', '        view\n', '        returns (StrategyMetadata memory)\n', '    {\n', '        IV2Strategy _strategy = IV2Strategy(strategyAddress);\n', '        bool _doHealthCheck;\n', '        address _healthCheckAddress;\n', '        try _strategy.doHealthCheck() {\n', '            _doHealthCheck = _strategy.doHealthCheck();\n', '        } catch {}\n', '        try _strategy.healthCheck() {\n', '             _healthCheckAddress = _strategy.healthCheck();\n', '        } catch {}\n', '        return\n', '            StrategyMetadata({\n', '                name: _strategy.name(),\n', '                apiVersion: _strategy.apiVersion(),\n', '                strategist: _strategy.strategist(),\n', '                rewards: _strategy.rewards(),\n', '                vault: _strategy.vault(),\n', '                keeper: _strategy.keeper(),\n', '                want: _strategy.want(),\n', '                emergencyExit: _strategy.emergencyExit(),\n', '                isActive: _strategy.isActive(),\n', '                delegatedAssets: _strategy.delegatedAssets(),\n', '                estimatedTotalAssets: _strategy.estimatedTotalAssets(),\n', '                doHealthCheck: _doHealthCheck,\n', '                healthCheckAddress: _healthCheckAddress\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch metadata for strategies given an array of strategy addresses\n', '     */\n', '    function strategies(address[] memory _strategiesAddresses)\n', '        public\n', '        view\n', '        returns (StrategyMetadata[] memory)\n', '    {\n', '        uint256 numberOfStrategies = _strategiesAddresses.length;\n', '        StrategyMetadata[] memory _strategies =\n', '            new StrategyMetadata[](numberOfStrategies);\n', '        for (\n', '            uint256 strategyIdx = 0;\n', '            strategyIdx < numberOfStrategies;\n', '            strategyIdx++\n', '        ) {\n', '            address strategyAddress = _strategiesAddresses[strategyIdx];\n', '            StrategyMetadata memory _strategy = strategy(strategyAddress);\n', '            _strategies[strategyIdx] = _strategy;\n', '        }\n', '        return _strategies;\n', '    }\n', '    \n', '    /**\n', '     * Allow storage slots to be manually updated\n', '     */\n', '    function updateSlot(bytes32 slot, bytes32 value) external {\n', '        require(msg.sender == ownerAddress, "Caller is not the owner");\n', '        assembly {\n', '            sstore(slot, value)\n', '        }\n', '    }\n', '}']