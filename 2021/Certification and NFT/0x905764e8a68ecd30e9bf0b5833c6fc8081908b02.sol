['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-03\n', '*/\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '// SPDX-License-Identifier: MIT\n', '\n', 'interface IERC20 {\n', '  function symbol() external view returns (string memory);\n', '\n', '  function name() external view returns (string memory);\n', '\n', '  function decimals() external view returns (uint256);\n', '\n', '  function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'interface IMdexPair {\n', '  function token0() external view returns (address);\n', '\n', '  function token1() external view returns (address);\n', '\n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '}\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '\n', '  function _msgData() internal view virtual returns (bytes memory) {\n', '    this;\n', '    return msg.data;\n', '  }\n', '}\n', '\n', 'contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ow1");\n', '    _;\n', '  }\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ow2");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b, "mul e0");\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0, "div e0");\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Map is Ownable {\n', '  using SafeMath for uint256;\n', '  IERC20 private r_fee_token;\n', '  IERC20 private r_usdt_token;\n', '  IMdexPair private r_fee_pair;\n', '  address private r_router_address;\n', '  uint256 private r_tx_fee_rate;\n', '  uint256 private r_tx_fee_type;\n', '  address private r_tx_fee_address;\n', '\n', '\n', '  struct token_info_item {\n', '    address token_address;\n', '    string name;\n', '    string symbol;\n', '    uint256 decimals;\n', '    uint256 balance;\n', '  }\n', '\n', '  function getTokenInfo(IERC20 _token, address _user) public view returns (token_info_item memory token_info) {\n', '    token_info.token_address = address(_token);\n', '    token_info.name = _token.name();\n', '    token_info.symbol = _token.symbol();\n', '    token_info.decimals = _token.decimals();\n', '    token_info.balance = _token.balanceOf(_user);\n', '  }\n', '\n', '  function set(IERC20 _fee_token, IERC20 _usdt_token, IMdexPair _fee_pair, address _router_address, uint256 _tx_fee_rate, uint256 _tx_fee_type, address _tx_fee_address) public onlyOwner {\n', '    r_fee_token = _fee_token;\n', '    r_usdt_token = _usdt_token;\n', '    r_fee_pair = _fee_pair;\n', '    r_router_address = _router_address;\n', '    r_tx_fee_rate = _tx_fee_rate;\n', '    r_tx_fee_type = _tx_fee_type;\n', '    r_tx_fee_address = _tx_fee_address;\n', '  }\n', '\n', '  function setTxFeeRate(uint256 _tx_fee_rate) public onlyOwner {\n', '    r_tx_fee_rate = _tx_fee_rate;\n', '  }\n', '\n', '  function setTxFeeType(uint256 _tx_fee_type) public onlyOwner {\n', '    r_tx_fee_type = _tx_fee_type;\n', '  }\n', '\n', '  function getPrice() internal view returns (uint256) {\n', '    if (address(r_fee_pair) == address(0)) {\n', '      return 0;\n', '    }\n', '    address token0_new = IMdexPair(r_fee_pair).token0();\n', '    address token1_new = IMdexPair(r_fee_pair).token1();\n', '    (uint256 _reserve0,uint256  _reserve1,) = IMdexPair(r_fee_pair).getReserves();\n', '    uint256 decimals0 = IERC20(token0_new).decimals();\n', '    uint256 decimals1 = IERC20(token1_new).decimals();\n', '    uint256 price1 = _reserve0.mul(10 ** 18).mul(10 ** decimals1).div(_reserve1).div(10 ** decimals0);\n', '    uint256 price2 = _reserve1.mul(10 ** 18).mul(10 ** decimals0).div(_reserve0).div(10 ** decimals1);\n', '    uint256 tx_price;\n', '    if (token0_new == address(r_fee_token))\n', '      tx_price = price1;\n', '    else\n', '      tx_price = price2;\n', '    return tx_price;\n', '  }\n', '\n', '  function getFeeNum() public view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address) {\n', '    tx_price = getPrice();\n', '    tx_fee_rate = r_tx_fee_rate;\n', '    tx_fee_type = r_tx_fee_type;\n', '    fee_token_decimals = 18;\n', '    usdt_token_decimals = 18;\n', '    if (address(r_fee_token) != address(0)) {\n', '      fee_token_decimals = r_fee_token.decimals();\n', '    }\n', '    if (address(r_usdt_token) != address(0)) {\n', '      usdt_token_decimals = r_usdt_token.decimals();\n', '    }\n', '    fee_token = r_fee_token;\n', '    usdt_token = r_usdt_token;\n', '    tx_fee_address = r_tx_fee_address;\n', '    router_address = r_router_address;\n', '  }\n', '\n', '}']