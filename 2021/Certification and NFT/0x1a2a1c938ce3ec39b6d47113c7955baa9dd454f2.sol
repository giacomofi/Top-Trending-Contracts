['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-28\n', '*/\n', '\n', '// File: @axie/contract-library/contracts/access/HasAdmin.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract HasAdmin {\n', '  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\n', '  event AdminRemoved(address indexed _oldAdmin);\n', '\n', '  address public admin;\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  constructor() internal {\n', '    admin = msg.sender;\n', '    emit AdminChanged(address(0), admin);\n', '  }\n', '\n', '  function changeAdmin(address _newAdmin) external onlyAdmin {\n', '    require(_newAdmin != address(0));\n', '    emit AdminChanged(admin, _newAdmin);\n', '    admin = _newAdmin;\n', '  }\n', '\n', '  function removeAdmin() external onlyAdmin {\n', '    emit AdminRemoved(admin);\n', '    admin = address(0);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/proxy/ProxyStorage.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ProxyStorage\n', ' * @dev Store the address of logic contact that the proxy should forward to.\n', ' */\n', 'contract ProxyStorage is HasAdmin {\n', '  address internal _proxyTo;\n', '}\n', '\n', '// File: @axie/contract-library/contracts/proxy/Proxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Gives the possibility to delegate any call to a foreign implementation.\n', ' */\n', 'contract Proxy is ProxyStorage {\n', '\n', '  event ProxyUpdated(address indexed _new, address indexed _old);\n', '\n', '  constructor(address _proxyTo) public {\n', '    updateProxyTo(_proxyTo);\n', '  }\n', '\n', '  /**\n', '  * @dev Tells the address of the implementation where every call will be delegated.\n', '  * @return address of the implementation to which it will be delegated\n', '  */\n', '  function implementation() public view returns (address) {\n', '    return _proxyTo;\n', '  }\n', '\n', '  /**\n', '  * @dev See more at: https://eips.ethereum.org/EIPS/eip-897\n', '  * @return type of proxy - always upgradable\n', '  */\n', '  function proxyType() external pure returns (uint256) {\n', '      // Upgradeable proxy\n', '      return 2;\n', '  }\n', '\n', '  /**\n', '  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n', '  * This function will return whatever the implementation call returns\n', '  */\n', '  function () payable external {\n', '    address _impl = implementation();\n', '    require(_impl != address(0));\n', '\n', '    assembly {\n', '      let ptr := mload(0x40)\n', '      calldatacopy(ptr, 0, calldatasize)\n', '      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n', '      let size := returndatasize\n', '      returndatacopy(ptr, 0, size)\n', '\n', '      switch result\n', '      case 0 { revert(ptr, size) }\n', '      default { return(ptr, size) }\n', '    }\n', '  }\n', '\n', '  function updateProxyTo(address _newProxyTo) public onlyAdmin {\n', '    require(_newProxyTo != address(0x0));\n', '\n', '    _proxyTo = _newProxyTo;\n', '    emit ProxyUpdated(_newProxyTo, _proxyTo);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/lifecycle/Pausable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract Pausable is HasAdmin {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool public paused;\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyAdmin whenNotPaused {\n', '    paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  function unpause() public onlyAdmin whenPaused {\n', '    paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    require(c / a == b);\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Since Solidity automatically asserts when dividing by 0,\n', '    // but we only need it to revert.\n', '    require(b > 0);\n', '    return a / b;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Same reason as `div`.\n', '    require(b > 0);\n', '    return a % b;\n', '  }\n', '\n', '  function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    return add(div(a, b), mod(a, b) > 0 ? 1 : 0);\n', '  }\n', '\n', '  function subU64(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function addU8(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '}\n', '\n', '// File: contracts/chain/common/IValidator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', 'contract IValidator {\n', '  event ValidatorAdded(uint256 indexed _id, address indexed _validator);\n', '  event ValidatorRemoved(uint256 indexed _id, address indexed _validator);\n', '  event ThresholdUpdated(\n', '    uint256 indexed _id,\n', '    uint256 indexed _numerator,\n', '    uint256 indexed _denominator,\n', '    uint256 _previousNumerator,\n', '    uint256 _previousDenominator\n', '  );\n', '\n', '  function isValidator(address _addr) public view returns (bool);\n', '  function getValidators() public view returns (address[] memory _validators);\n', '\n', '  function checkThreshold(uint256 _voteCount) public view returns (bool);\n', '}\n', '\n', '// File: contracts/chain/common/Validator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', 'contract Validator is IValidator {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => bool) validatorMap;\n', '  address[] public validators;\n', '  uint256 public validatorCount;\n', '\n', '  uint256 public num;\n', '  uint256 public denom;\n', '\n', '  constructor(address[] memory _validators, uint256 _num, uint256 _denom)\n', '    public\n', '  {\n', '    validators = _validators;\n', '    validatorCount = _validators.length;\n', '\n', '    for (uint256 _i = 0; _i < validatorCount; _i++) {\n', '      address _validator = _validators[_i];\n', '      validatorMap[_validator] = true;\n', '    }\n', '\n', '    num = _num;\n', '    denom = _denom;\n', '  }\n', '\n', '  function isValidator(address _addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return validatorMap[_addr];\n', '  }\n', '\n', '  function getValidators()\n', '    public\n', '    view\n', '    returns (address[] memory _validators)\n', '  {\n', '    _validators = validators;\n', '  }\n', '\n', '  function checkThreshold(uint256 _voteCount)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return _voteCount.mul(denom) >= num.mul(validatorCount);\n', '  }\n', '\n', '  function _addValidator(uint256 _id, address _validator)\n', '    internal\n', '  {\n', '    require(!validatorMap[_validator]);\n', '\n', '    validators.push(_validator);\n', '    validatorMap[_validator] = true;\n', '    validatorCount++;\n', '\n', '    emit ValidatorAdded(_id, _validator);\n', '  }\n', '\n', '  function _removeValidator(uint256 _id, address _validator)\n', '    internal\n', '  {\n', '    require(isValidator(_validator));\n', '\n', '    uint256 _index;\n', '    for (uint256 _i = 0; _i < validatorCount; _i++) {\n', '      if (validators[_i] == _validator) {\n', '        _index = _i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    validatorMap[_validator] = false;\n', '    validators[_index] = validators[validatorCount - 1];\n', '    validators.pop();\n', '\n', '    validatorCount--;\n', '\n', '    emit ValidatorRemoved(_id, _validator);\n', '  }\n', '\n', '  function _updateQuorum(uint256 _id, uint256 _numerator, uint256 _denominator)\n', '    internal\n', '  {\n', '    require(_numerator <= _denominator);\n', '    uint256 _previousNumerator = num;\n', '    uint256 _previousDenominator = denom;\n', '\n', '    num = _numerator;\n', '    denom = _denominator;\n', '\n', '    emit ThresholdUpdated(\n', '      _id,\n', '      _numerator,\n', '      _denominator,\n', '      _previousNumerator,\n', '      _previousDenominator\n', '    );\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainValidator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Validator\n', ' * @dev Simple validator contract\n', ' */\n', 'contract MainchainValidator is Validator, HasAdmin {\n', '  uint256 nonce;\n', '\n', '  constructor(\n', '    address[] memory _validators,\n', '    uint256 _num,\n', '    uint256 _denom\n', '  ) Validator(_validators, _num, _denom) public {\n', '  }\n', '\n', '  function addValidators(address[] calldata _validators) external onlyAdmin {\n', '    for (uint256 _i; _i < _validators.length; ++_i) {\n', '      _addValidator(nonce++, _validators[_i]);\n', '    }\n', '  }\n', '\n', '  function removeValidator(address _validator) external onlyAdmin {\n', '    _removeValidator(nonce++, _validator);\n', '  }\n', '\n', '  function updateQuorum(uint256 _numerator, uint256 _denominator) external onlyAdmin {\n', '    _updateQuorum(nonce++, _numerator, _denominator);\n', '  }\n', '}\n', '\n', '// File: contracts/chain/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', 'contract Registry is HasAdmin {\n', '\n', '  event ContractAddressUpdated(\n', '    string indexed _name,\n', '    bytes32 indexed _code,\n', '    address indexed _newAddress\n', '  );\n', '\n', '  event TokenMapped(\n', '    address indexed _mainchainToken,\n', '    address indexed _sidechainToken,\n', '    uint32 _standard\n', '  );\n', '\n', '  string public constant GATEWAY = "GATEWAY";\n', '  string public constant WETH_TOKEN = "WETH_TOKEN";\n', '  string public constant VALIDATOR = "VALIDATOR";\n', '  string public constant ACKNOWLEDGEMENT = "ACKNOWLEDGEMENT";\n', '\n', '  struct TokenMapping {\n', '    address mainchainToken;\n', '    address sidechainToken;\n', '    uint32 standard; // 20, 721 or any other standards\n', '  }\n', '\n', '  mapping(bytes32 => address) public contractAddresses;\n', '  mapping(address => TokenMapping) public mainchainMap;\n', '  mapping(address => TokenMapping) public sidechainMap;\n', '\n', '  function getContract(string calldata _name)\n', '    external\n', '    view\n', '    returns (address _address)\n', '  {\n', '    bytes32 _code = getCode(_name);\n', '    _address = contractAddresses[_code];\n', '    require(_address != address(0));\n', '  }\n', '\n', '  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n', '\n', '    return _mapping.mainchainToken != address(0) &&\n', '      _mapping.sidechainToken != address(0) &&\n', '      _mapping.standard == _standard;\n', '  }\n', '\n', '  function updateContract(string calldata _name, address _newAddress)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    bytes32 _code = getCode(_name);\n', '    contractAddresses[_code] = _newAddress;\n', '\n', '    emit ContractAddressUpdated(_name, _code, _newAddress);\n', '  }\n', '\n', '  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    TokenMapping memory _map = TokenMapping(\n', '      _mainchainToken,\n', '      _sidechainToken,\n', '      _standard\n', '    );\n', '\n', '    mainchainMap[_mainchainToken] = _map;\n', '    sidechainMap[_sidechainToken] = _map;\n', '\n', '    emit TokenMapped(\n', '      _mainchainToken,\n', '      _sidechainToken,\n', '      _standard\n', '    );\n', '  }\n', '\n', '  function clearMapToken(address _mainchainToken, address _sidechainToken)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    TokenMapping storage _mainchainMap = mainchainMap[_mainchainToken];\n', '    _clearMapEntry(_mainchainMap);\n', '\n', '    TokenMapping storage _sidechainMap = sidechainMap[_sidechainToken];\n', '    _clearMapEntry(_sidechainMap);\n', '  }\n', '\n', '  function getMappedToken(\n', '    address _token,\n', '    bool _isMainchain\n', '  )\n', '    external\n', '    view\n', '  returns (\n', '    address _mainchainToken,\n', '    address _sidechainToken,\n', '    uint32 _standard\n', '  )\n', '  {\n', '    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n', '    _mainchainToken = _mapping.mainchainToken;\n', '    _sidechainToken = _mapping.sidechainToken;\n', '    _standard = _mapping.standard;\n', '  }\n', '\n', '  function getCode(string memory _name)\n', '    public\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    return keccak256(abi.encodePacked(_name));\n', '  }\n', '\n', '  function _getTokenMapping(\n', '    address _token,\n', '    bool isMainchain\n', '  )\n', '    internal\n', '    view\n', '    returns (TokenMapping memory _mapping)\n', '  {\n', '    if (isMainchain) {\n', '      _mapping = mainchainMap[_token];\n', '    } else {\n', '      _mapping = sidechainMap[_token];\n', '    }\n', '  }\n', '\n', '  function _clearMapEntry(TokenMapping storage _entry)\n', '    internal\n', '  {\n', '    _entry.mainchainToken = address(0);\n', '    _entry.sidechainToken = address(0);\n', '    _entry.standard = 0;\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainGatewayStorage.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title GatewayStorage\n', ' * @dev Storage of deposit and withdraw information.\n', ' */\n', 'contract MainchainGatewayStorage is ProxyStorage, Pausable {\n', '\n', '  event TokenDeposited(\n', '    uint256 indexed _depositId,\n', '    address indexed _owner,\n', '    address indexed _tokenAddress,\n', '    address _sidechainAddress,\n', '    uint32  _standard,\n', '    uint256 _tokenNumber // ERC-20 amount or ERC721 tokenId\n', '  );\n', '\n', '  event TokenWithdrew(\n', '    uint256 indexed _withdrawId,\n', '    address indexed _owner,\n', '    address indexed _tokenAddress,\n', '    uint256 _tokenNumber\n', '  );\n', '\n', '  struct DepositEntry {\n', '    address owner;\n', '    address tokenAddress;\n', '    address sidechainAddress;\n', '    uint32  standard;\n', '    uint256 tokenNumber;\n', '  }\n', '\n', '  struct WithdrawalEntry {\n', '    address owner;\n', '    address tokenAddress;\n', '    uint256 tokenNumber;\n', '  }\n', '\n', '  Registry public registry;\n', '\n', '  uint256 public depositCount;\n', '  DepositEntry[] public deposits;\n', '  mapping(uint256 => WithdrawalEntry) public withdrawals;\n', '\n', '  function updateRegistry(address _registry) external onlyAdmin {\n', '    registry = Registry(_registry);\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainGatewayProxy.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract MainchainGatewayProxy is Proxy, MainchainGatewayStorage {\n', '  constructor(address _proxyTo, address _registry)\n', '    public\n', '    Proxy(_proxyTo)\n', '  {\n', '    registry = Registry(_registry);\n', '  }\n', '}']