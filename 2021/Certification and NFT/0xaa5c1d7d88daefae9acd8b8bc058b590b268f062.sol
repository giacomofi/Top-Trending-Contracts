['/* SPDX-License-Identifier: LGPL-3.0-or-later */\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./Admin.sol";\n', 'import "./CarefulMath.sol";\n', 'import "./Erc20Interface.sol";\n', 'import "./Erc20Recover.sol";\n', 'import "./SafeErc20.sol";\n', 'import "./ReentrancyGuard.sol";\n', '\n', 'import "./FintrollerInterface.sol";\n', 'import "./RedemptionPoolInterface.sol";\n', '\n', '/**\n', ' * @title RedemptionPool\n', ' * @author Hifi\n', ' * @notice Mints 1 fyToken in exhchange for 1 underlying before maturation and burns 1 fyToken\n', ' * in exchange for 1 underlying after maturation.\n', ' * @dev Instantiated by the fyToken in its constructor.\n', ' */\n', 'contract RedemptionPool is\n', '    CarefulMath, /* no dependency */\n', '    ReentrancyGuard, /* no dependency */\n', '    RedemptionPoolInterface, /* one dependency */\n', '    Admin, /* two dependencies */\n', '    Erc20Recover /* five dependencies */\n', '{\n', '    using SafeErc20 for Erc20Interface;\n', '\n', '    /**\n', '     * @param fintroller_ The address of the Fintroller contract.\n', '     * @param fyToken_ The address of the fyToken contract.\n', '     */\n', '    constructor(FintrollerInterface fintroller_, FyTokenInterface fyToken_) Admin() {\n', '        /* Set the Fintroller contract and sanity check it. */\n', '        fintroller = fintroller_;\n', '        fintroller.isFintroller();\n', '\n', '        /**\n', '         * Set the fyToken contract. It cannot be sanity-checked because the fyToken creates this\n', '         * contract in its own constructor and contracts cannot be called while initializing.\n', '         */\n', '        fyToken = fyToken_;\n', '    }\n', '\n', '    struct RedeemFyTokensLocalVars {\n', '        MathError mathErr;\n', '        uint256 newUnderlyingTotalSupply;\n', '        uint256 underlyingPrecisionScalar;\n', '        uint256 underlyingAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Pays the token holder the face value at maturation time.\n', '     *\n', '     * @dev Emits a {RedeemFyTokens} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - Must be called after maturation.\n', '     * - The amount to redeem cannot be zero.\n', '     * - The Fintroller must allow this action to be performed.\n', '     * - There must be enough liquidity in the Redemption Pool.\n', '     *\n', '     * @param fyTokenAmount The amount of fyTokens to redeem for the underlying asset.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function redeemFyTokens(uint256 fyTokenAmount) external override nonReentrant returns (bool) {\n', '        RedeemFyTokensLocalVars memory vars;\n', '\n', '        /* Checks: maturation time. */\n', '        require(block.timestamp >= fyToken.expirationTime(), "ERR_BOND_NOT_MATURED");\n', '\n', '        /* Checks: the zero edge case. */\n', '        require(fyTokenAmount > 0, "ERR_REDEEM_FYTOKENS_ZERO");\n', '\n', '        /* Checks: the Fintroller allows this action to be performed. */\n', '        require(fintroller.getRedeemFyTokensAllowed(fyToken), "ERR_REDEEM_FYTOKENS_NOT_ALLOWED");\n', '\n', '        /**\n', '         * fyTokens always have 18 decimals so the underlying amount needs to be downscaled.\n', '         * If the precision scalar is 1, it means that the underlying also has 18 decimals.\n', '         */\n', '        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();\n', '        if (vars.underlyingPrecisionScalar != 1) {\n', '            (vars.mathErr, vars.underlyingAmount) = divUInt(fyTokenAmount, vars.underlyingPrecisionScalar);\n', '            require(vars.mathErr == MathError.NO_ERROR, "ERR_REDEEM_FYTOKENS_MATH_ERROR");\n', '        } else {\n', '            vars.underlyingAmount = fyTokenAmount;\n', '        }\n', '\n', '        /* Checks: there is enough liquidity. */\n', '        require(vars.underlyingAmount <= totalUnderlyingSupply, "ERR_REDEEM_FYTOKENS_INSUFFICIENT_UNDERLYING");\n', '\n', '        /* Effects: decrease the remaining supply of underlying. */\n', '        (vars.mathErr, vars.newUnderlyingTotalSupply) = subUInt(totalUnderlyingSupply, vars.underlyingAmount);\n', '        assert(vars.mathErr == MathError.NO_ERROR);\n', '        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;\n', '\n', '        /* Interactions: burn the fyTokens. */\n', '        require(fyToken.burn(msg.sender, fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_BURN");\n', '\n', '        /* Interactions: perform the Erc20 transfer. */\n', '        fyToken.underlying().safeTransfer(msg.sender, vars.underlyingAmount);\n', '\n', '        emit RedeemFyTokens(msg.sender, fyTokenAmount, vars.underlyingAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    struct SupplyUnderlyingLocalVars {\n', '        MathError mathErr;\n', '        uint256 fyTokenAmount;\n', '        uint256 newUnderlyingTotalSupply;\n', '        uint256 underlyingPrecisionScalar;\n', '    }\n', '\n', '    /**\n', '     * @notice An alternative to the usual minting method that does not involve taking on debt.\n', '     *\n', '     * @dev Emits a {SupplyUnderlying} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - Must be called prior to maturation.\n', '     * - The amount to supply cannot be zero.\n', '     * - The Fintroller must allow this action to be performed.\n', '     * - The caller must have allowed this contract to spend `underlyingAmount` tokens.\n', '     *\n', '     * @param underlyingAmount The amount of underlying to supply to the Redemption Pool.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function supplyUnderlying(uint256 underlyingAmount) external override nonReentrant returns (bool) {\n', '        SupplyUnderlyingLocalVars memory vars;\n', '\n', '        /* Checks: maturation time. */\n', '        require(block.timestamp < fyToken.expirationTime(), "ERR_BOND_MATURED");\n', '\n', '        /* Checks: the zero edge case. */\n', '        require(underlyingAmount > 0, "ERR_SUPPLY_UNDERLYING_ZERO");\n', '\n', '        /* Checks: the Fintroller allows this action to be performed. */\n', '        require(fintroller.getSupplyUnderlyingAllowed(fyToken), "ERR_SUPPLY_UNDERLYING_NOT_ALLOWED");\n', '\n', '        /* Effects: update storage. */\n', '        (vars.mathErr, vars.newUnderlyingTotalSupply) = addUInt(totalUnderlyingSupply, underlyingAmount);\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");\n', '        totalUnderlyingSupply = vars.newUnderlyingTotalSupply;\n', '\n', '        /**\n', '         * fyTokens always have 18 decimals so the underlying amount needs to be upscaled.\n', '         * If the precision scalar is 1, it means that the underlying also has 18 decimals.\n', '         */\n', '        vars.underlyingPrecisionScalar = fyToken.underlyingPrecisionScalar();\n', '        if (vars.underlyingPrecisionScalar != 1) {\n', '            (vars.mathErr, vars.fyTokenAmount) = mulUInt(underlyingAmount, vars.underlyingPrecisionScalar);\n', '            require(vars.mathErr == MathError.NO_ERROR, "ERR_SUPPLY_UNDERLYING_MATH_ERROR");\n', '        } else {\n', '            vars.fyTokenAmount = underlyingAmount;\n', '        }\n', '\n', '        /* Interactions: mint the fyTokens. */\n', '        require(fyToken.mint(msg.sender, vars.fyTokenAmount), "ERR_SUPPLY_UNDERLYING_CALL_MINT");\n', '\n', '        /* Interactions: perform the Erc20 transfer. */\n', '        fyToken.underlying().safeTransferFrom(msg.sender, address(this), underlyingAmount);\n', '\n', '        emit SupplyUnderlying(msg.sender, underlyingAmount, vars.fyTokenAmount);\n', '\n', '        return true;\n', '    }\n', '}']