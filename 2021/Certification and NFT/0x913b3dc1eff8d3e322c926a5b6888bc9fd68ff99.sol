['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-16\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-05\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-29\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC1155 compliant contract, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '/**\n', ' * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n', ' * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155MetadataURI is IERC1155 {\n', '    /**\n', '     * @dev Returns the URI for token type `id`.\n', '     *\n', '     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n', '     * clients with the actual token type ID.\n', '     */\n', '    function uri(uint256 id) external view returns (string memory);\n', '}\n', '\n', '/**\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise\n', '     * be too long), and then calling {toEthSignedMessageHash} on it.\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            revert("ECDSA: invalid signature length");\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        return recover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Overload of {ECDSA-recover} that receives the `v`,\n', '     * `r` and `s` signature fields separately.\n', '     */\n', '    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n', '        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer != address(0), "ECDSA: invalid signature");\n', '\n', '        return signer;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n', '     * produces hash corresponding to the one signed with the\n', '     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n', '     * JSON-RPC method as part of EIP-191.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Typed Data, created from a\n', '     * `domainSeparator` and a `structHash`. This produces hash corresponding\n', '     * to the one signed with the\n', '     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n', '     * JSON-RPC method as part of EIP-712.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n', ' *\n', ' * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n', ' * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n', ' * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n', ' *\n', ' * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n', ' * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n', ' * ({_hashTypedDataV4}).\n', ' *\n', ' * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n', ' * the chain id to protect against replay attacks on an eventual fork of the chain.\n', ' *\n', ' * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method\n', ' * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'abstract contract EIP712 {\n', '    /* solhint-disable var-name-mixedcase */\n', '    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n', '    // invalidate the cached domain separator if the chain id changes.\n', '    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n', '    uint256 private immutable _CACHED_CHAIN_ID;\n', '\n', '    bytes32 private immutable _HASHED_NAME;\n', '    bytes32 private immutable _HASHED_VERSION;\n', '    bytes32 private immutable _TYPE_HASH;\n', '    /* solhint-enable var-name-mixedcase */\n', '\n', '    /**\n', '     * @dev Initializes the domain separator and parameter caches.\n', '     *\n', '     * The meaning of `name` and `version` is specified in\n', '     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n', '     *\n', '     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n', '     * - `version`: the current major version of the signing domain.\n', '     *\n', '     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n', '     * contract upgrade].\n', '     */\n', '    constructor(string memory name, string memory version) {\n', '        bytes32 hashedName = keccak256(bytes(name));\n', '        bytes32 hashedVersion = keccak256(bytes(version));\n', '        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '        _HASHED_NAME = hashedName;\n', '        _HASHED_VERSION = hashedVersion;\n', '        _CACHED_CHAIN_ID = block.chainid;\n', '        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n', '        _TYPE_HASH = typeHash;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the domain separator for the current chain.\n', '     */\n', '    function _domainSeparatorV4() internal view returns (bytes32) {\n', '        if (block.chainid == _CACHED_CHAIN_ID) {\n', '            return _CACHED_DOMAIN_SEPARATOR;\n', '        } else {\n', '            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n', '        }\n', '    }\n', '\n', '    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n', '        return keccak256(\n', '            abi.encode(\n', '                typeHash,\n', '                name,\n', '                version,\n', '                block.chainid,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n', '     * function returns the hash of the fully encoded EIP712 message for this domain.\n', '     *\n', '     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n', '     *\n', '     * ```solidity\n', '     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n', '     *     keccak256("Mail(address to,string contents)"),\n', '     *     mailTo,\n', '     *     keccak256(bytes(mailContents))\n', '     * )));\n', '     * address signer = ECDSA.recover(digest, signature);\n', '     * ```\n', '     */\n', '    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n', '        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender) + value;\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        unchecked {\n', '            uint256 oldAllowance = token.allowance(address(this), spender);\n', '            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n', '            uint256 newAllowance = oldAllowance - value;\n', '            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev String operations.\n', ' */\n', 'library Strings {\n', '    bytes16 private constant alphabet = "0123456789abcdef";\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n', '     */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        while (value != 0) {\n', '            digits -= 1;\n', '            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n', '            value /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n', '     */\n', '    function toHexString(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0x00";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 length = 0;\n', '        while (temp != 0) {\n', '            length++;\n', '            temp >>= 8;\n', '        }\n', '        return toHexString(value, length);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n', '     */\n', '    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n', '        bytes memory buffer = new bytes(2 * length + 2);\n', '        buffer[0] = "0";\n', '        buffer[1] = "x";\n', '        for (uint256 i = 2 * length + 1; i > 1; --i) {\n', '            buffer[i] = alphabet[value & 0xf];\n', '            value >>= 4;\n', '        }\n', '        require(value == 0, "Strings: hex length insufficient");\n', '        return string(buffer);\n', '    }\n', '\n', '}\n', '\n', 'interface HasSecondarySaleFees {\n', '\n', '    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\n', '\n', '    /*\n', "     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n", "     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n", '     *\n', '     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n', '     * bytes4 internal constant _INTERFACE_ID_FEES = 0xb7799584;\n', '     */\n', '    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);\n', '    function getFeeBps(uint256 id) external view returns (uint[] memory);\n', '}\n', '\n', '/**\n', ' *\n', ' * @dev Implementation of the basic standard multi-token.\n', ' * See https://eips.ethereum.org/EIPS/eip-1155\n', ' * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, HasSecondarySaleFees {\n', '    using Address for address;\n', '    using Strings for uint256;\n', '\n', '    // Mapping from token ID to account balances\n', '    mapping (uint256 => mapping(address => uint256)) private _balances;\n', '\n', '    // Mapping from account to operator approvals\n', '    mapping (address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n', '    string internal _uri;\n', '    \n', '    uint256 public constant FEE_DIVISIONER = 10000;\n', '\n', '    /**\n', '     * @dev See {_setURI}.\n', '     */\n', '    constructor (string memory uri_) {\n', '        _setURI(uri_);\n', '    }\n', '    \n', '    struct Fee {\n', '        address payable recipient;\n', '        uint256 value;\n', '    }\n', '    \n', '    mapping (uint256 => Fee[]) public secondaryFees;\n', '    mapping (uint256 => Fee) public primaryFee;\n', '    \n', '    function getFeeRecipients(uint256 id) public view override returns (address payable[] memory) {\n', '        Fee[] memory _fees = secondaryFees[id];\n', '        address payable[] memory result = new address payable[](_fees.length);\n', '        for (uint i = 0; i < _fees.length; i++) {\n', '            result[i] = _fees[i].recipient;\n', '        }\n', '        return result;\n', '    }\n', '    \n', '    function getFeeBps(uint256 id) public view override returns (uint[] memory) {\n', '        Fee[] memory _fees = secondaryFees[id];\n', '        uint[] memory result = new uint[](_fees.length);\n', '        for (uint i = 0; i < _fees.length; i++) {\n', '            result[i] = _fees[i].value;\n', '        }\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n', '        return interfaceId == type(IERC1155).interfaceId\n', '            || interfaceId == type(IERC1155MetadataURI).interfaceId\n', '            || interfaceId == type(HasSecondarySaleFees).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155MetadataURI-uri}.\n', '     *\n', '     * This implementation returns the same URI for *all* token types. It relies\n', '     * on the token type ID substitution mechanism\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n', '     *\n', '     * Clients calling this function must replace the `\\{id\\}` substring with the\n', '     * actual token type ID.\n', '     */\n', '    function uri(uint256 tokenId) external view virtual override returns (string memory) {\n', '        return bytes(_uri).length > 0\n', '            ? string(abi.encodePacked(_uri, tokenId.toString()))\n', "            : '';\n", '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n', '        require(account != address(0), "ERC1155: balance query for the zero address");\n', '        return _balances[id][account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-balanceOfBatch}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(\n', '        address[] memory accounts,\n', '        uint256[] memory ids\n', '    )\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256[] memory)\n', '    {\n', '        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");\n', '\n', '        uint256[] memory batchBalances = new uint256[](accounts.length);\n', '\n', '        for (uint256 i = 0; i < accounts.length; ++i) {\n', '            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n', '        }\n', '\n', '        return batchBalances;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(_msgSender() != operator, "ERC1155: setting approval status for self");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[account][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        public\n', '        override\n', '    {\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        uint256 fromBalance = _balances[id][from];\n', '        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '        _balances[id][from] = fromBalance - amount;\n', '        _balances[id][to] += amount;\n', '\n', '        emit TransferSingle(operator, from, to, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n', '    }\n', '\n', '    function _safeTransferWithSig(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        internal\n', '        \n', '    {\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        uint256 fromBalance = _balances[id][from];\n', '        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '        _balances[id][from] = fromBalance - amount;\n', '        _balances[id][to] += amount;\n', '\n', '        emit TransferSingle(operator, from, to, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-safeBatchTransferFrom}.\n', '     */\n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        public\n', '        override\n', '    {\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: transfer caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        for (uint256 i = 0; i < ids.length; ++i) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 fromBalance = _balances[id][from];\n', '            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '            _balances[id][from] = fromBalance - amount;\n', '            _balances[id][to] += amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, from, to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets a new URI for all token types, by relying on the token type ID\n', '     * substitution mechanism\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n', '     *\n', '     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n', '     * URI or any of the amounts in the JSON file at said URI will be replaced by\n', '     * clients with the token type ID.\n', '     *\n', '     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n', '     * interpreted by clients as\n', '     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n', '     * for token type ID 0x4cce0.\n', '     *\n', '     * See {uri}.\n', '     *\n', '     * Because these URIs cannot be meaningfully represented by the {URI} event,\n', '     * this function emits no events.\n', '     */\n', '    function _setURI(string memory newuri) internal virtual {\n', '        _uri = newuri;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function _mint(address account, uint256 id, uint256 amount, Fee memory _primaryFee, Fee[] memory _secondaryFees, bytes memory data) internal virtual {\n', '        require(amount > 0, "Amount should be positive");\n', '        require(account != address(0), "ERC1155: mint to the zero address");\n', '\n', '        address operator = _msgSender();\n', '        \n', '        require(_primaryFee.recipient != address(0), "Primary Fee: Recipient should be present");\n', '        require(_primaryFee.value > 0 && _primaryFee.value <= FEE_DIVISIONER, "Primary Fee: Fee value should be positive and less or equal 100 percents");\n', '        \n', '        primaryFee[id] = _primaryFee;\n', '        \n', '        address[] memory recipients = new address[](_secondaryFees.length);\n', '        uint[] memory bps = new uint[](_secondaryFees.length);\n', '        uint256 sumBps;\n', '        \n', '        for (uint i = 0; i < _secondaryFees.length; i++) {\n', '            require(_secondaryFees[i].recipient != address(0), "Secondary Fee: Recipient should be present");\n', '            require(_secondaryFees[i].value > 0, "Secondary Fee: Fee value should be positive");\n', '            secondaryFees[id].push(_secondaryFees[i]);\n', '            recipients[i] = _secondaryFees[i].recipient;\n', '            bps[i] = _secondaryFees[i].value;\n', '            sumBps += _secondaryFees[i].value;\n', '        }\n', '        require(sumBps <= FEE_DIVISIONER, "Secondary Fee: Fee percentage should be less or equal 100 percent");\n', '        if (_secondaryFees.length > 0) {\n', '            emit SecondarySaleFees(id, recipients, bps);\n', '        }\n', '\n', '        _balances[id][account] += amount;\n', '        emit TransferSingle(operator, address(0), account, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n', '    }\n', '\n', '    \n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens of token type `id` from `account`\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens of token type `id`.\n', '     */\n', '    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        uint256 accountBalance = _balances[id][account];\n', '        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '        _balances[id][account] = accountBalance - amount;\n', '\n', '        emit TransferSingle(operator, account, address(0), id, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     */\n', '    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        for (uint i = 0; i < ids.length; i++) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 accountBalance = _balances[id][account];\n', '            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '            _balances[id][account] = accountBalance - amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, account, address(0), ids, amounts);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning, as well as batched variants.\n', '     *\n', '     * The same hook is called on both single and batched variants. For single\n', '     * transfers, the length of the `id` and `amount` arrays will be 1.\n', '     *\n', '     * Calling conditions (for each `id` and `amount` pair):\n', '     *\n', "     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * of token type `id` will be  transferred to `to`.\n', '     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n', '     * for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n", '     * will be burned.\n', '     * - `from` and `to` are never both zero.\n', '     * - `ids` and `amounts` have the same, non-zero length.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '\n', '    function _doSafeTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doSafeBatchTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n', '        uint256[] memory array = new uint256[](1);\n', '        array[0] = element;\n', '\n', '        return array;\n', '    }\n', '}\n', '\n', 'contract GenesisArt_Common is ERC1155, Ownable, EIP712 {\n', '    using SafeERC20 for IERC20;\n', '    \n', '    mapping (address => bool) public allowedTradingErc20Tokens;\n', '    \n', '    constructor (string memory _uri, address tradingToken1, address tradingToken2,\n', '    string memory eip712Name, string memory eip712Version) ERC1155(_uri) EIP712(eip712Name, eip712Version) {\n', '        \n', '        require(tradingToken1 != address(0) && tradingToken2 != address(0), "GenesisArt: Trading Token zero address");\n', '        \n', '        allowedTradingErc20Tokens[tradingToken1] = true;\n', '        allowedTradingErc20Tokens[tradingToken2] = true;\n', '    }\n', '    \n', '    string private constant FORWARD_DATA_TYPE = "ForwardData(address from,address to,address tradingTokenAddr,uint256 id,uint256 amount,uint256 value,uint256 nonce,uint256 deadline)";\n', '  \n', '    bytes32 private constant FORWARD_DATA_TYPEHASH = keccak256(abi.encodePacked(FORWARD_DATA_TYPE));\n', '    \n', '    struct ForwardData {\n', '        address from;\n', '        address to;\n', '        address tradingTokenAddr;\n', '        uint256 id;\n', '        uint256 amount;\n', '        uint256 value;\n', '        uint256 nonce;\n', '        uint256 deadline;\n', '    }\n', '    \n', '    mapping(address => uint256) private nonces;\n', '    \n', '    function getNonce(address from) public view returns (uint256) {\n', '        return nonces[from];\n', '    }\n', '\n', '    function _verifyNonce(address account, uint256 nonce) internal view {\n', '        require(nonces[account] == nonce, "nonce mismatch");\n', '    }\n', '\n', '    function _verifySig(ForwardData memory data, bytes memory sig) internal view {\n', '        bytes32 structHash = hashStruct(data);\n', '        bytes32 digest = _hashTypedDataV4(structHash);\n', '        require(ECDSA.recover(digest, sig) == data.from, "GenesisArt: signature mismatch");\n', '    }\n', '\n', '    function _updateNonce(address account) internal {\n', '        nonces[account]++;\n', '    }\n', '    \n', '    function hashStruct(ForwardData memory data) private pure returns(bytes32) {\n', '        return keccak256(abi.encode(\n', '                FORWARD_DATA_TYPEHASH,\n', '                data.from,\n', '                data.to,\n', '                data.tradingTokenAddr,\n', '                data.id,\n', '                data.amount,\n', '                data.value,\n', '                data.nonce,\n', '                data.deadline\n', '            ));\n', '    }\n', '    \n', '    function mint(uint256 id, uint256 amount, Fee memory _primaryFee, Fee[] memory _secondaryFees) external onlyOwner {\n', '        bytes memory data;\n', '        _mint(owner(), id, amount, _primaryFee, _secondaryFees, data);\n', '    }\n', '    \n', '    function burn(address account, uint256 id, uint256 amount) external onlyOwner {\n', '        _burn(account, id, amount);\n', '    }\n', '    \n', '    function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) external onlyOwner {\n', '        _burnBatch(account, ids, amounts);\n', '    }\n', '    \n', '    function setBaseURI(string memory _uri) external onlyOwner {\n', '        _setURI(_uri);\n', '    }\n', '    \n', '    function tokenSaleFrom( //sig from buyer\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        uint256 price,\n', '        uint256 _buyerNonce,\n', '        address tradingTokenAddress,\n', '        uint256 _deadline,\n', '        bytes calldata sig\n', '    ) \n', '        external \n', '    {\n', '        \n', '        require(allowedTradingErc20Tokens[tradingTokenAddress], "GenesisArt: trading token not allowed");\n', '        ForwardData memory data = ForwardData({\n', '            from: to,\n', '            to: from,\n', '            tradingTokenAddr: tradingTokenAddress,\n', '            id: id,\n', '            amount: amount,\n', '            value: price,\n', '            nonce: _buyerNonce,\n', '            deadline: _deadline\n', '        });\n', '        _verifyNonce(data.from, data.nonce);\n', '        _verifySig(data, sig);\n', '        _updateNonce(data.from);\n', '        require(msg.sender == data.to, "GenesisArt: not allowed to sell");\n', '        require(block.timestamp <= data.deadline, "GenesisArt: signature is out-of-date");\n', '        require(data.to != address(0));\n', '        \n', '        \n', '        IERC20 tradingToken = IERC20(tradingTokenAddress);\n', '        tradingToken.safeTransferFrom(data.from, address(this), data.value);\n', '        \n', '        \n', '        if (data.to == owner()) {\n', '            Fee memory _primaryFee = primaryFee[data.id];\n', '            \n', '            uint256 toRealOwnerAmount = data.value / FEE_DIVISIONER * _primaryFee.value;\n', '            uint256 toPlatformAmount = data.value - toRealOwnerAmount;\n', '            \n', '            tradingToken.safeTransfer(_primaryFee.recipient, toRealOwnerAmount);\n', '            tradingToken.safeTransfer(owner(), toPlatformAmount);\n', '            \n', '            bytes memory transferData;\n', '            safeTransferFrom(data.to, data.from, data.id, data.amount, transferData);\n', '        } else {\n', '            Fee[] memory _secondaryFees = secondaryFees[data.id];\n', '            uint256 feeSum;\n', '            \n', '            for (uint i = 0; i < _secondaryFees.length; i++) {\n', '                uint256 toFeeRecipientAmount = data.value / FEE_DIVISIONER * _secondaryFees[i].value;\n', '                feeSum += toFeeRecipientAmount;\n', '                tradingToken.safeTransfer(_secondaryFees[i].recipient, toFeeRecipientAmount);\n', '            }\n', '            \n', '            uint256 toAssetOwnerAmount = data.value - feeSum;\n', '            \n', '            tradingToken.safeTransfer(data.to, toAssetOwnerAmount);\n', '            \n', '            bytes memory transferData;\n', '            safeTransferFrom(data.to, data.from, data.id, data.amount, transferData);\n', '        }\n', '    }\n', '    \n', '    function tokenSale(  //sig from seller\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        uint256 price,\n', '        uint256 _buyerNonce,\n', '        address tradingTokenAddress,\n', '        uint256 _deadline,\n', '        bytes calldata sig\n', '    ) \n', '        external \n', '    {\n', '        \n', '        require(allowedTradingErc20Tokens[tradingTokenAddress], "GenesisArt: trading token not allowed");\n', '        ForwardData memory data = ForwardData({\n', '            from: from,\n', '            to: to,\n', '            tradingTokenAddr: tradingTokenAddress,\n', '            id: id,\n', '            amount: amount,\n', '            value: price,\n', '            nonce: _buyerNonce,\n', '            deadline: _deadline\n', '        });\n', '        _verifyNonce(data.to, data.nonce);\n', '        _verifySig(data, sig);\n', '        _updateNonce(data.to);\n', '        require(data.to != address(0));\n', '        require(msg.sender == data.to, "GenesisArt: not allowed to buy");\n', '        require(block.timestamp <= data.deadline, "GenesisArt: signature is out-of-date");\n', '        \n', '        \n', '        \n', '        IERC20 tradingToken = IERC20(tradingTokenAddress);\n', '        tradingToken.safeTransferFrom(data.to, address(this), data.value);\n', '        \n', '        \n', '        if (data.from == owner()) {\n', '            Fee memory _primaryFee = primaryFee[data.id];\n', '            \n', '            uint256 toRealOwnerAmount = data.value / FEE_DIVISIONER * _primaryFee.value;\n', '            uint256 toPlatformAmount = data.value - toRealOwnerAmount;\n', '            \n', '            tradingToken.safeTransfer(_primaryFee.recipient, toRealOwnerAmount);\n', '            tradingToken.safeTransfer(owner(), toPlatformAmount);\n', '            \n', '            bytes memory transferData;\n', '            _safeTransferWithSig(data.from, data.to, data.id, data.amount, transferData);\n', '        } else {\n', '            Fee[] memory _secondaryFees = secondaryFees[data.id];\n', '            uint256 feeSum;\n', '            \n', '            for (uint i = 0; i < _secondaryFees.length; i++) {\n', '                uint256 toFeeRecipientAmount = data.value / FEE_DIVISIONER * _secondaryFees[i].value;\n', '                feeSum += toFeeRecipientAmount;\n', '                tradingToken.safeTransfer(_secondaryFees[i].recipient, toFeeRecipientAmount);\n', '            }\n', '            \n', '            uint256 toAssetOwnerAmount = data.value - feeSum;\n', '            \n', '            tradingToken.safeTransfer(data.from, toAssetOwnerAmount);\n', '            \n', '            bytes memory transferData;\n', '            _safeTransferWithSig(data.from, data.to, data.id, data.amount, transferData);\n', '        }\n', '    }\n', '    \n', '}']