['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '// File: contracts/lib/MathUint.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', 'library MathUint\n', '{\n', '    using MathUint for uint;\n', '\n', '    function mul(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "MUL_OVERFLOW");\n', '    }\n', '\n', '    function sub(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        require(b <= a, "SUB_UNDERFLOW");\n', '        return a - b;\n', '    }\n', '\n', '    function add(\n', '        uint a,\n', '        uint b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '\n', '    function add64(\n', '        uint64 a,\n', '        uint64 b\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint64 c)\n', '    {\n', '        c = a + b;\n', '        require(c >= a, "ADD_OVERFLOW");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Poseidon.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Poseidon hash function\n', '///        See: https://eprint.iacr.org/2019/458.pdf\n', '///        Code auto-generated by generate_poseidon_EVM_code.py\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library Poseidon\n', '{\n', '    //\n', '    // hash_t5f6p52\n', '    //\n', '\n', '    struct HashInputs5\n', '    {\n', '        uint t0;\n', '        uint t1;\n', '        uint t2;\n', '        uint t3;\n', '        uint t4;\n', '    }\n', '\n', '    function hash_t5f6p52_internal(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3,\n', '        uint t4,\n', '        uint q\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        assembly {\n', '            function mix(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := mulmod(_t0, 4977258759536702998522229302103997878600602264560359702680165243908162277980, _q)\n', '                nt0 := addmod(nt0, mulmod(_t1, 19167410339349846567561662441069598364702008768579734801591448511131028229281, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t2, 14183033936038168803360723133013092560869148726790180682363054735190196956789, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t3, 9067734253445064890734144122526450279189023719890032859456830213166173619761, _q), _q)\n', '                nt0 := addmod(nt0, mulmod(_t4, 16378664841697311562845443097199265623838619398287411428110917414833007677155, _q), _q)\n', '                nt1 := mulmod(_t0, 107933704346764130067829474107909495889716688591997879426350582457782826785, _q)\n', '                nt1 := addmod(nt1, mulmod(_t1, 17034139127218860091985397764514160131253018178110701196935786874261236172431, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t2, 2799255644797227968811798608332314218966179365168250111693473252876996230317, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t3, 2482058150180648511543788012634934806465808146786082148795902594096349483974, _q), _q)\n', '                nt1 := addmod(nt1, mulmod(_t4, 16563522740626180338295201738437974404892092704059676533096069531044355099628, _q), _q)\n', '                nt2 := mulmod(_t0, 13596762909635538739079656925495736900379091964739248298531655823337482778123, _q)\n', '                nt2 := addmod(nt2, mulmod(_t1, 18985203040268814769637347880759846911264240088034262814847924884273017355969, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t2, 8652975463545710606098548415650457376967119951977109072274595329619335974180, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t3, 970943815872417895015626519859542525373809485973005165410533315057253476903, _q), _q)\n', '                nt2 := addmod(nt2, mulmod(_t4, 19406667490568134101658669326517700199745817783746545889094238643063688871948, _q), _q)\n', '                nt3 := mulmod(_t0, 2953507793609469112222895633455544691298656192015062835263784675891831794974, _q)\n', '                nt3 := addmod(nt3, mulmod(_t1, 19025623051770008118343718096455821045904242602531062247152770448380880817517, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t2, 9077319817220936628089890431129759976815127354480867310384708941479362824016, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t3, 4770370314098695913091200576539533727214143013236894216582648993741910829490, _q), _q)\n', '                nt3 := addmod(nt3, mulmod(_t4, 4298564056297802123194408918029088169104276109138370115401819933600955259473, _q), _q)\n', '                nt4 := mulmod(_t0, 8336710468787894148066071988103915091676109272951895469087957569358494947747, _q)\n', '                nt4 := addmod(nt4, mulmod(_t1, 16205238342129310687768799056463408647672389183328001070715567975181364448609, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t2, 8303849270045876854140023508764676765932043944545416856530551331270859502246, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t3, 20218246699596954048529384569730026273241102596326201163062133863539137060414, _q), _q)\n', '                nt4 := addmod(nt4, mulmod(_t4, 1712845821388089905746651754894206522004527237615042226559791118162382909269, _q), _q)\n', '            }\n', '\n', '            function ark(_t0, _t1, _t2, _t3, _t4, _q, c) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := addmod(_t0, c, _q)\n', '                nt1 := addmod(_t1, c, _q)\n', '                nt2 := addmod(_t2, c, _q)\n', '                nt3 := addmod(_t3, c, _q)\n', '                nt4 := addmod(_t4, c, _q)\n', '            }\n', '\n', '            function sbox_full(_t0, _t1, _t2, _t3, _t4, _q) -> nt0, nt1, nt2, nt3, nt4 {\n', '                nt0 := mulmod(_t0, _t0, _q)\n', '                nt0 := mulmod(nt0, nt0, _q)\n', '                nt0 := mulmod(_t0, nt0, _q)\n', '                nt1 := mulmod(_t1, _t1, _q)\n', '                nt1 := mulmod(nt1, nt1, _q)\n', '                nt1 := mulmod(_t1, nt1, _q)\n', '                nt2 := mulmod(_t2, _t2, _q)\n', '                nt2 := mulmod(nt2, nt2, _q)\n', '                nt2 := mulmod(_t2, nt2, _q)\n', '                nt3 := mulmod(_t3, _t3, _q)\n', '                nt3 := mulmod(nt3, nt3, _q)\n', '                nt3 := mulmod(_t3, nt3, _q)\n', '                nt4 := mulmod(_t4, _t4, _q)\n', '                nt4 := mulmod(nt4, nt4, _q)\n', '                nt4 := mulmod(_t4, nt4, _q)\n', '            }\n', '\n', '            function sbox_partial(_t, _q) -> nt {\n', '                nt := mulmod(_t, _t, _q)\n', '                nt := mulmod(nt, nt, _q)\n', '                nt := mulmod(_t, nt, _q)\n', '            }\n', '\n', '            // round 0\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 1\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 2\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 3\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 4\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 5\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 6\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 7\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 8\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 9\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 10\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 11\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 12\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 13\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 14\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 15\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 16\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 17\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 18\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 19\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 20\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 21\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 22\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 23\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 24\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 25\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 26\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 27\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 28\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 29\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 30\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 31\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 32\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 33\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 34\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 35\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 36\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 37\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 38\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 71447649211767888770311304010816315780740050029903404046389165015534756512)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 39\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 40\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 41\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 42\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 43\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 44\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 45\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 46\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 47\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 48\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 49\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 50\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 51\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 52\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 53\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 54\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849)\n', '            t0 := sbox_partial(t0, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 55\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 56\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '            // round 57\n', '            t0, t1, t2, t3, t4 := ark(t0, t1, t2, t3, t4, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544)\n', '            t0, t1, t2, t3, t4 := sbox_full(t0, t1, t2, t3, t4, q)\n', '            t0, t1, t2, t3, t4 := mix(t0, t1, t2, t3, t4, q)\n', '        }\n', '        return t0;\n', '    }\n', '\n', '    function hash_t5f6p52(HashInputs5 memory i, uint q) internal pure returns (uint)\n', '    {\n', '        // validate inputs\n', '        require(i.t0 < q, "INVALID_INPUT");\n', '        require(i.t1 < q, "INVALID_INPUT");\n', '        require(i.t2 < q, "INVALID_INPUT");\n', '        require(i.t3 < q, "INVALID_INPUT");\n', '        require(i.t4 < q, "INVALID_INPUT");\n', '\n', '        return hash_t5f6p52_internal(i.t0, i.t1, i.t2, i.t3, i.t4, q);\n', '    }\n', '\n', '\n', '    //\n', '    // hash_t7f6p52\n', '    //\n', '\n', '    struct HashInputs7\n', '    {\n', '        uint t0;\n', '        uint t1;\n', '        uint t2;\n', '        uint t3;\n', '        uint t4;\n', '        uint t5;\n', '        uint t6;\n', '    }\n', '\n', '    function mix(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, 14183033936038168803360723133013092560869148726790180682363054735190196956789, q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t1, 9067734253445064890734144122526450279189023719890032859456830213166173619761, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t2, 16378664841697311562845443097199265623838619398287411428110917414833007677155, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t3, 12968540216479938138647596899147650021419273189336843725176422194136033835172, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t4, 3636162562566338420490575570584278737093584021456168183289112789616069756675, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t5, 8949952361235797771659501126471156178804092479420606597426318793013844305422, q), q);\n', '        o.t0 = addmod(o.t0, mulmod(i.t6, 13586657904816433080148729258697725609063090799921401830545410130405357110367, q), q);\n', '        o.t1 = mulmod(i.t0, 2799255644797227968811798608332314218966179365168250111693473252876996230317, q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t1, 2482058150180648511543788012634934806465808146786082148795902594096349483974, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t2, 16563522740626180338295201738437974404892092704059676533096069531044355099628, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t3, 10468644849657689537028565510142839489302836569811003546969773105463051947124, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t4, 3328913364598498171733622353010907641674136720305714432354138807013088636408, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t5, 8642889650254799419576843603477253661899356105675006557919250564400804756641, q), q);\n', '        o.t1 = addmod(o.t1, mulmod(i.t6, 14300697791556510113764686242794463641010174685800128469053974698256194076125, q), q);\n', '        o.t2 = mulmod(i.t0, 8652975463545710606098548415650457376967119951977109072274595329619335974180, q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t1, 970943815872417895015626519859542525373809485973005165410533315057253476903, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t2, 19406667490568134101658669326517700199745817783746545889094238643063688871948, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t3, 17049854690034965250221386317058877242629221002521630573756355118745574274967, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t4, 4964394613021008685803675656098849539153699842663541444414978877928878266244, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t5, 15474947305445649466370538888925567099067120578851553103424183520405650587995, q), q);\n', '        o.t2 = addmod(o.t2, mulmod(i.t6, 1016119095639665978105768933448186152078842964810837543326777554729232767846, q), q);\n', '        o.t3 = mulmod(i.t0, 9077319817220936628089890431129759976815127354480867310384708941479362824016, q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t1, 4770370314098695913091200576539533727214143013236894216582648993741910829490, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t2, 4298564056297802123194408918029088169104276109138370115401819933600955259473, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t3, 6905514380186323693285869145872115273350947784558995755916362330070690839131, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t4, 4783343257810358393326889022942241108539824540285247795235499223017138301952, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t5, 1420772902128122367335354247676760257656541121773854204774788519230732373317, q), q);\n', '        o.t3 = addmod(o.t3, mulmod(i.t6, 14172871439045259377975734198064051992755748777535789572469924335100006948373, q), q);\n', '        o.t4 = mulmod(i.t0, 8303849270045876854140023508764676765932043944545416856530551331270859502246, q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t1, 20218246699596954048529384569730026273241102596326201163062133863539137060414, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t2, 1712845821388089905746651754894206522004527237615042226559791118162382909269, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t3, 13001155522144542028910638547179410124467185319212645031214919884423841839406, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t4, 16037892369576300958623292723740289861626299352695838577330319504984091062115, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t5, 19189494548480259335554606182055502469831573298885662881571444557262020106898, q), q);\n', '        o.t4 = addmod(o.t4, mulmod(i.t6, 19032687447778391106390582750185144485341165205399984747451318330476859342654, q), q);\n', '        o.t5 = mulmod(i.t0, 13272957914179340594010910867091459756043436017766464331915862093201960540910, q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t1, 9416416589114508529880440146952102328470363729880726115521103179442988482948, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t2, 8035240799672199706102747147502951589635001418759394863664434079699838251138, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t3, 21642389080762222565487157652540372010968704000567605990102641816691459811717, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t4, 20261355950827657195644012399234591122288573679402601053407151083849785332516, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t5, 14514189384576734449268559374569145463190040567900950075547616936149781403109, q), q);\n', '        o.t5 = addmod(o.t5, mulmod(i.t6, 19038036134886073991945204537416211699632292792787812530208911676638479944765, q), q);\n', '        o.t6 = mulmod(i.t0, 15627836782263662543041758927100784213807648787083018234961118439434298020664, q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t1, 5655785191024506056588710805596292231240948371113351452712848652644610823632, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t2, 8265264721707292643644260517162050867559314081394556886644673791575065394002, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t3, 17151144681903609082202835646026478898625761142991787335302962548605510241586, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t4, 18731644709777529787185361516475509623264209648904603914668024590231177708831, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t5, 20697789991623248954020701081488146717484139720322034504511115160686216223641, q), q);\n', '        o.t6 = addmod(o.t6, mulmod(i.t6, 6200020095464686209289974437830528853749866001482481427982839122465470640886, q), q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function ark(HashInputs7 memory i, uint q, uint c) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = addmod(i.t0, c, q);\n', '        o.t1 = addmod(i.t1, c, q);\n', '        o.t2 = addmod(i.t2, c, q);\n', '        o.t3 = addmod(i.t3, c, q);\n', '        o.t4 = addmod(i.t4, c, q);\n', '        o.t5 = addmod(i.t5, c, q);\n', '        o.t6 = addmod(i.t6, c, q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function sbox_full(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, i.t0, q);\n', '        o.t0 = mulmod(o.t0, o.t0, q);\n', '        o.t0 = mulmod(i.t0, o.t0, q);\n', '        o.t1 = mulmod(i.t1, i.t1, q);\n', '        o.t1 = mulmod(o.t1, o.t1, q);\n', '        o.t1 = mulmod(i.t1, o.t1, q);\n', '        o.t2 = mulmod(i.t2, i.t2, q);\n', '        o.t2 = mulmod(o.t2, o.t2, q);\n', '        o.t2 = mulmod(i.t2, o.t2, q);\n', '        o.t3 = mulmod(i.t3, i.t3, q);\n', '        o.t3 = mulmod(o.t3, o.t3, q);\n', '        o.t3 = mulmod(i.t3, o.t3, q);\n', '        o.t4 = mulmod(i.t4, i.t4, q);\n', '        o.t4 = mulmod(o.t4, o.t4, q);\n', '        o.t4 = mulmod(i.t4, o.t4, q);\n', '        o.t5 = mulmod(i.t5, i.t5, q);\n', '        o.t5 = mulmod(o.t5, o.t5, q);\n', '        o.t5 = mulmod(i.t5, o.t5, q);\n', '        o.t6 = mulmod(i.t6, i.t6, q);\n', '        o.t6 = mulmod(o.t6, o.t6, q);\n', '        o.t6 = mulmod(i.t6, o.t6, q);\n', '        i.t0 = o.t0;\n', '        i.t1 = o.t1;\n', '        i.t2 = o.t2;\n', '        i.t3 = o.t3;\n', '        i.t4 = o.t4;\n', '        i.t5 = o.t5;\n', '        i.t6 = o.t6;\n', '    }\n', '\n', '    function sbox_partial(HashInputs7 memory i, uint q) internal pure\n', '    {\n', '        HashInputs7 memory o;\n', '        o.t0 = mulmod(i.t0, i.t0, q);\n', '        o.t0 = mulmod(o.t0, o.t0, q);\n', '        o.t0 = mulmod(i.t0, o.t0, q);\n', '        i.t0 = o.t0;\n', '    }\n', '\n', '    function hash_t7f6p52(HashInputs7 memory i, uint q) internal pure returns (uint)\n', '    {\n', '        // validate inputs\n', '        require(i.t0 < q, "INVALID_INPUT");\n', '        require(i.t1 < q, "INVALID_INPUT");\n', '        require(i.t2 < q, "INVALID_INPUT");\n', '        require(i.t3 < q, "INVALID_INPUT");\n', '        require(i.t4 < q, "INVALID_INPUT");\n', '        require(i.t5 < q, "INVALID_INPUT");\n', '        require(i.t6 < q, "INVALID_INPUT");\n', '\n', '        // round 0\n', '        ark(i, q, 14397397413755236225575615486459253198602422701513067526754101844196324375522);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 1\n', '        ark(i, q, 10405129301473404666785234951972711717481302463898292859783056520670200613128);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 2\n', '        ark(i, q, 5179144822360023508491245509308555580251733042407187134628755730783052214509);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 3\n', '        ark(i, q, 9132640374240188374542843306219594180154739721841249568925550236430986592615);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 4\n', '        ark(i, q, 20360807315276763881209958738450444293273549928693737723235350358403012458514);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 5\n', '        ark(i, q, 17933600965499023212689924809448543050840131883187652471064418452962948061619);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 6\n', '        ark(i, q, 3636213416533737411392076250708419981662897009810345015164671602334517041153);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 7\n', '        ark(i, q, 2008540005368330234524962342006691994500273283000229509835662097352946198608);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 8\n', '        ark(i, q, 16018407964853379535338740313053768402596521780991140819786560130595652651567);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 9\n', '        ark(i, q, 20653139667070586705378398435856186172195806027708437373983929336015162186471);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 10\n', '        ark(i, q, 17887713874711369695406927657694993484804203950786446055999405564652412116765);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 11\n', '        ark(i, q, 4852706232225925756777361208698488277369799648067343227630786518486608711772);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 12\n', '        ark(i, q, 8969172011633935669771678412400911310465619639756845342775631896478908389850);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 13\n', '        ark(i, q, 20570199545627577691240476121888846460936245025392381957866134167601058684375);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 14\n', '        ark(i, q, 16442329894745639881165035015179028112772410105963688121820543219662832524136);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 15\n', '        ark(i, q, 20060625627350485876280451423010593928172611031611836167979515653463693899374);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 16\n', '        ark(i, q, 16637282689940520290130302519163090147511023430395200895953984829546679599107);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 17\n', '        ark(i, q, 15599196921909732993082127725908821049411366914683565306060493533569088698214);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 18\n', '        ark(i, q, 16894591341213863947423904025624185991098788054337051624251730868231322135455);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 19\n', '        ark(i, q, 1197934381747032348421303489683932612752526046745577259575778515005162320212);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 20\n', '        ark(i, q, 6172482022646932735745595886795230725225293469762393889050804649558459236626);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 21\n', '        ark(i, q, 21004037394166516054140386756510609698837211370585899203851827276330669555417);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 22\n', '        ark(i, q, 15262034989144652068456967541137853724140836132717012646544737680069032573006);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 23\n', '        ark(i, q, 15017690682054366744270630371095785995296470601172793770224691982518041139766);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 24\n', '        ark(i, q, 15159744167842240513848638419303545693472533086570469712794583342699782519832);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 25\n', '        ark(i, q, 11178069035565459212220861899558526502477231302924961773582350246646450941231);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 26\n', '        ark(i, q, 21154888769130549957415912997229564077486639529994598560737238811887296922114);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 27\n', '        ark(i, q, 20162517328110570500010831422938033120419484532231241180224283481905744633719);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 28\n', '        ark(i, q, 2777362604871784250419758188173029886707024739806641263170345377816177052018);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 29\n', '        ark(i, q, 15732290486829619144634131656503993123618032247178179298922551820261215487562);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 30\n', '        ark(i, q, 6024433414579583476444635447152826813568595303270846875177844482142230009826);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 31\n', '        ark(i, q, 17677827682004946431939402157761289497221048154630238117709539216286149983245);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 32\n', '        ark(i, q, 10716307389353583413755237303156291454109852751296156900963208377067748518748);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 33\n', '        ark(i, q, 14925386988604173087143546225719076187055229908444910452781922028996524347508);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 34\n', '        ark(i, q, 8940878636401797005293482068100797531020505636124892198091491586778667442523);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 35\n', '        ark(i, q, 18911747154199663060505302806894425160044925686870165583944475880789706164410);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 36\n', '        ark(i, q, 8821532432394939099312235292271438180996556457308429936910969094255825456935);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 37\n', '        ark(i, q, 20632576502437623790366878538516326728436616723089049415538037018093616927643);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 38\n', '        ark(i, q, 71447649211767888770311304010816315780740050029903404046389165015534756512);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 39\n', '        ark(i, q, 2781996465394730190470582631099299305677291329609718650018200531245670229393);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 40\n', '        ark(i, q, 12441376330954323535872906380510501637773629931719508864016287320488688345525);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 41\n', '        ark(i, q, 2558302139544901035700544058046419714227464650146159803703499681139469546006);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 42\n', '        ark(i, q, 10087036781939179132584550273563255199577525914374285705149349445480649057058);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 43\n', '        ark(i, q, 4267692623754666261749551533667592242661271409704769363166965280715887854739);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 44\n', '        ark(i, q, 4945579503584457514844595640661884835097077318604083061152997449742124905548);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 45\n', '        ark(i, q, 17742335354489274412669987990603079185096280484072783973732137326144230832311);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 46\n', '        ark(i, q, 6266270088302506215402996795500854910256503071464802875821837403486057988208);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 47\n', '        ark(i, q, 2716062168542520412498610856550519519760063668165561277991771577403400784706);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 48\n', '        ark(i, q, 19118392018538203167410421493487769944462015419023083813301166096764262134232);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 49\n', '        ark(i, q, 9386595745626044000666050847309903206827901310677406022353307960932745699524);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 50\n', '        ark(i, q, 9121640807890366356465620448383131419933298563527245687958865317869840082266);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 51\n', '        ark(i, q, 3078975275808111706229899605611544294904276390490742680006005661017864583210);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 52\n', '        ark(i, q, 7157404299437167354719786626667769956233708887934477609633504801472827442743);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 53\n', '        ark(i, q, 14056248655941725362944552761799461694550787028230120190862133165195793034373);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 54\n', '        ark(i, q, 14124396743304355958915937804966111851843703158171757752158388556919187839849);\n', '        sbox_partial(i, q);\n', '        mix(i, q);\n', '        // round 55\n', '        ark(i, q, 11851254356749068692552943732920045260402277343008629727465773766468466181076);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 56\n', '        ark(i, q, 9799099446406796696742256539758943483211846559715874347178722060519817626047);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '        // round 57\n', '        ark(i, q, 10156146186214948683880719664738535455146137901666656566575307300522957959544);\n', '        sbox_full(i, q);\n', '        mix(i, q);\n', '\n', '        return i.t0;\n', '    }\n', '}\n', '\n', '\n', '// File: contracts/core/iface/IAgentRegistry.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', 'interface IAgent{}\n', '\n', 'abstract contract IAgentRegistry\n', '{\n', '    /// @dev Returns whether an agent address is an agent of an account owner\n', '    /// @param owner The account owner.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address owner,\n', '        address agent\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is an agent of all account owners\n', '    /// @param owners The account owners.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is an agent for the account owner, else false\n', '    function isAgent(\n', '        address[] calldata owners,\n', '        address            agent\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Returns whether an agent address is a universal agent.\n', '    /// @param agent The agent address\n', '    /// @return True if the agent address is a universal agent, else false\n', '    function isUniversalAgent(address agent)\n', '        public\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Ownable\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable\n', '{\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner()\n', '    {\n', '        require(msg.sender == owner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      new owner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function renounceOwnership()\n', '        public\n', '        onlyOwner\n', '    {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Claimable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title Claimable\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable\n', '{\n', '    address public pendingOwner;\n', '\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner, "UNAUTHORIZED");\n', '        _;\n', '    }\n', '\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(\n', '        address newOwner\n', '        )\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        require(newOwner != address(0) && newOwner != owner, "INVALID_ADDRESS");\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership()\n', '        public\n', '        onlyPendingOwner\n', '    {\n', '        emit OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/core/iface/IBlockVerifier.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title IBlockVerifier\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'abstract contract IBlockVerifier is Claimable\n', '{\n', '    // -- Events --\n', '\n', '    event CircuitRegistered(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    event CircuitDisabled(\n', '        uint8  indexed blockType,\n', '        uint16         blockSize,\n', '        uint8          blockVersion\n', '    );\n', '\n', '    // -- Public functions --\n', '\n', '    /// @dev Sets the verifying key for the specified circuit.\n', '    ///      Every block permutation needs its own circuit and thus its own set of\n', '    ///      verification keys. Only a limited number of block sizes per block\n', '    ///      type are supported.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param vk The verification key\n', '    function registerCircuit(\n', '        uint8    blockType,\n', '        uint16   blockSize,\n', '        uint8    blockVersion,\n', '        uint[18] calldata vk\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Disables the use of the specified circuit.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    function disableCircuit(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Verifies blocks with the given public data and proofs.\n', '    ///      Verifying a block makes sure all requests handled in the block\n', '    ///      are correctly handled by the operator.\n', '    /// @param blockType The type of block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @param publicInputs The hash of all the public data of the blocks\n', '    /// @param proofs The ZK proofs proving that the blocks are correct\n', '    /// @return True if the block is valid, false otherwise\n', '    function verifyProofs(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion,\n', '        uint[] calldata publicInputs,\n', '        uint[] calldata proofs\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit with the specified parameters is registered.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is registered, false otherwise\n', '    function isCircuitRegistered(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Checks if a circuit can still be used to commit new blocks.\n', '    /// @param blockType The type of the block\n', '    /// @param blockSize The number of requests handled in the block\n', '    /// @param blockVersion The block version (i.e. which circuit version needs to be used)\n', '    /// @return True if the circuit is enabled, false otherwise\n', '    function isCircuitEnabled(\n', '        uint8  blockType,\n', '        uint16 blockSize,\n', '        uint8  blockVersion\n', '        )\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/core/iface/IDepositContract.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title IDepositContract.\n', '/// @dev   Contract storing and transferring funds for an exchange.\n', '///\n', '///        ERC1155 tokens can be supported by registering pseudo token addresses calculated\n', '///        as `address(keccak256(real_token_address, token_params))`. Then the custom\n', '///        deposit contract can look up the real token address and paramsters with the\n', '///        pseudo token address before doing the transfers.\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'interface IDepositContract\n', '{\n', '    /// @dev Returns if a token is suppoprted by this contract.\n', '    function isTokenSupported(address token)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /// @dev Transfers tokens from a user to the exchange. This function will\n', '    ///      be called when a user deposits funds to the exchange.\n', '    ///      In a simple implementation the funds are simply stored inside the\n', '    ///      deposit contract directly. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest, so this function could directly\n', '    ///      call the necessary functions to store the funds there.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens to transfer.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the deposit\n', "    /// @return amountReceived The amount to deposit to the user's account in the Merkle tree\n", '    function deposit(\n', '        address from,\n', '        address token,\n', '        uint96  amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable\n', '        returns (uint96 amountReceived);\n', '\n', '    /// @dev Transfers tokens from the exchange to a user. This function will\n', '    ///      be called when a withdrawal is done for a user on the exchange.\n', '    ///      In the simplest implementation the funds are simply stored inside the\n', '    ///      deposit contract directly so this simply transfers the requested tokens back\n', '    ///      to the user. More advanced implementations may store the funds\n', '    ///      in some DeFi application to earn interest so the function would\n', '    ///      need to get those tokens back from the DeFi application first before they\n', '    ///      can be transferred to the user.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', "    /// @param from The address from which 'amount' tokens are transferred.\n", "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (`0x0` for ETH).\n', '    /// @param amount The amount of tokens transferred.\n', '    /// @param extraData Opaque data that can be used by the contract to handle the withdrawal\n', '    function withdraw(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount,\n', '        bytes   calldata extraData\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Transfers tokens (ETH not supported) for a user using the allowance set\n', '    ///      for the exchange. This way the approval can be used for all functionality (and\n', '    ///      extended functionality) of the exchange.\n', '    ///      Should NOT be used to deposit/withdraw user funds, `deposit`/`withdraw`\n', '    ///      should be used for that as they will contain specialised logic for those operations.\n', '    ///      This function can be called by the exchange to transfer onchain funds of users\n', '    ///      necessary for Agent functionality.\n', '    ///\n', '    ///      This function needs to throw when an error occurred!\n', '    ///\n', '    ///      This function can only be called by the exchange.\n', '    ///\n', '    /// @param from The address of the account that sends the tokens.\n', "    /// @param to The address to which 'amount' tokens are transferred.\n", '    /// @param token The address of the token to transfer (ETH is and cannot be suppported).\n', '    /// @param amount The amount of tokens transferred.\n', '    function transfer(\n', '        address from,\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '        )\n', '        external\n', '        payable;\n', '\n', '    /// @dev Checks if the given address is used for depositing ETH or not.\n', '    ///      Is used while depositing to send the correct ETH amount to the deposit contract.\n', '    ///\n', '    ///      Note that 0x0 is always registered for deposting ETH when the exchange is created!\n', '    ///      This function allows additional addresses to be used for depositing ETH, the deposit\n', '    ///      contract can implement different behaviour based on the address value.\n', '    ///\n', '    /// @param addr The address to check\n', '    /// @return True if the address is used for depositing ETH, else false.\n', '    function isETH(address addr)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/core/iface/ILoopringV3.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '/// @title ILoopringV3\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', 'abstract contract ILoopringV3 is Claimable\n', '{\n', '    // == Events ==\n', '    event ExchangeStakeDeposited(address exchangeAddr, uint amount);\n', '    event ExchangeStakeWithdrawn(address exchangeAddr, uint amount);\n', '    event ExchangeStakeBurned(address exchangeAddr, uint amount);\n', '    event SettingsUpdated(uint time);\n', '\n', '    // == Public Variables ==\n', '    mapping (address => uint) internal exchangeStake;\n', '\n', '    uint    public totalStake;\n', '    address public blockVerifierAddress;\n', '    uint    public forcedWithdrawalFee;\n', '    uint    public tokenRegistrationFeeLRCBase;\n', '    uint    public tokenRegistrationFeeLRCDelta;\n', '    uint8   public protocolTakerFeeBips;\n', '    uint8   public protocolMakerFeeBips;\n', '\n', '    address payable public protocolFeeVault;\n', '\n', '    // == Public Functions ==\n', '\n', '    /// @dev Returns the LRC token address\n', '    /// @return the LRC token address\n', '    function lrcAddress()\n', '        external\n', '        view\n', '        virtual\n', '        returns (address);\n', '\n', '    /// @dev Updates the global exchange settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateSettings(\n', '        address payable _protocolFeeVault,   // address(0) not allowed\n', '        address _blockVerifierAddress,       // address(0) not allowed\n', '        uint    _forcedWithdrawalFee\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Updates the global protocol fee settings.\n', '    ///      This function can only be called by the owner of this contract.\n', '    ///\n', '    ///      Warning: these new values will be used by existing and\n', '    ///      new Loopring exchanges.\n', '    function updateProtocolFeeSettings(\n', '        uint8 _protocolTakerFeeBips,\n', '        uint8 _protocolMakerFeeBips\n', '        )\n', '        external\n', '        virtual;\n', '\n', '    /// @dev Gets the amount of staked LRC for an exchange.\n', '    /// @param exchangeAddr The address of the exchange\n', '    /// @return stakedLRC The amount of LRC\n', '    function getExchangeStake(\n', '        address exchangeAddr\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Burns a certain amount of staked LRC for a specific exchange.\n', '    ///      This function is meant to be called only from exchange contracts.\n', '    /// @return burnedLRC The amount of LRC burned. If the amount is greater than\n', '    ///         the staked amount, all staked LRC will be burned.\n', '    function burnExchangeStake(\n', '        uint amount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint burnedLRC);\n', '\n', '    /// @dev Stakes more LRC for an exchange.\n', '    /// @param  exchangeAddr The address of the exchange\n', '    /// @param  amountLRC The amount of LRC to stake\n', '    /// @return stakedLRC The total amount of LRC staked for the exchange\n', '    function depositExchangeStake(\n', '        address exchangeAddr,\n', '        uint    amountLRC\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint stakedLRC);\n', '\n', '    /// @dev Withdraws a certain amount of staked LRC for an exchange to the given address.\n', '    ///      This function is meant to be called only from within exchange contracts.\n', '    /// @param  recipient The address to receive LRC\n', '    /// @param  requestedAmount The amount of LRC to withdraw\n', '    /// @return amountLRC The amount of LRC withdrawn\n', '    function withdrawExchangeStake(\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amountLRC);\n', '\n', '    /// @dev Gets the protocol fee values for an exchange.\n', '    /// @return takerFeeBips The protocol taker fee\n', '    /// @return makerFeeBips The protocol maker fee\n', '    function getProtocolFeeValues(\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (\n', '            uint8 takerFeeBips,\n', '            uint8 makerFeeBips\n', '        );\n', '}\n', '\n', '// File: contracts/core/iface/ExchangeData.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeData\n', '/// @dev All methods in this lib are internal, therefore, there is no need\n', '///      to deploy this library independently.\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ExchangeData\n', '{\n', '    // -- Enums --\n', '    enum TransactionType\n', '    {\n', '        NOOP,\n', '        DEPOSIT,\n', '        WITHDRAWAL,\n', '        TRANSFER,\n', '        SPOT_TRADE,\n', '        ACCOUNT_UPDATE,\n', '        AMM_UPDATE,\n', '        SIGNATURE_VERIFICATION\n', '    }\n', '\n', '    // -- Structs --\n', '    struct Token\n', '    {\n', '        address token;\n', '    }\n', '\n', '    struct ProtocolFeeData\n', '    {\n', '        uint32 syncedAt; // only valid before 2105 (85 years to go)\n', '        uint8  takerFeeBips;\n', '        uint8  makerFeeBips;\n', '        uint8  previousTakerFeeBips;\n', '        uint8  previousMakerFeeBips;\n', '    }\n', '\n', '    // General auxiliary data for each conditional transaction\n', '    struct AuxiliaryData\n', '    {\n', '        uint  txIndex;\n', '        bool  approved;\n', '        bytes data;\n', '    }\n', '\n', '    // This is the (virtual) block the owner  needs to submit onchain to maintain the\n', '    // per-exchange (virtual) blockchain.\n', '    struct Block\n', '    {\n', '        uint8      blockType;\n', '        uint16     blockSize;\n', '        uint8      blockVersion;\n', '        bytes      data;\n', '        uint256[8] proof;\n', '\n', '        // Whether we should store the @BlockInfo for this block on-chain.\n', '        bool storeBlockInfoOnchain;\n', '\n', '        // Block specific data that is only used to help process the block on-chain.\n', '        // It is not used as input for the circuits and it is not necessary for data-availability.\n', '        // This bytes array contains the abi encoded AuxiliaryData[] data.\n', '        bytes auxiliaryData;\n', '\n', '        // Arbitrary data, mainly for off-chain data-availability, i.e.,\n', '        // the multihash of the IPFS file that contains the block data.\n', '        bytes offchainData;\n', '    }\n', '\n', '    struct BlockInfo\n', '    {\n', '        // The time the block was submitted on-chain.\n', '        uint32  timestamp;\n', '        // The public data hash of the block (the 28 most significant bytes).\n', '        bytes28 blockDataHash;\n', '    }\n', '\n', '    // Represents an onchain deposit request.\n', '    struct Deposit\n', '    {\n', '        uint96 amount;\n', '        uint64 timestamp;\n', '    }\n', '\n', '    // A forced withdrawal request.\n', "    // If the actual owner of the account initiated the request (we don't know who the owner is\n", '    // at the time the request is being made) the full balance will be withdrawn.\n', '    struct ForcedWithdrawal\n', '    {\n', '        address owner;\n', '        uint64  timestamp;\n', '    }\n', '\n', '    struct Constants\n', '    {\n', '        uint SNARK_SCALAR_FIELD;\n', '        uint MAX_OPEN_FORCED_REQUESTS;\n', '        uint MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE;\n', '        uint TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS;\n', '        uint MAX_NUM_ACCOUNTS;\n', '        uint MAX_NUM_TOKENS;\n', '        uint MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED;\n', '        uint MIN_TIME_IN_SHUTDOWN;\n', '        uint TX_DATA_AVAILABILITY_SIZE;\n', '        uint MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND;\n', '    }\n', '\n', '    // This is the prime number that is used for the alt_bn128 elliptic curve, see EIP-196.\n', '    uint public constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n', '\n', '    uint public constant MAX_OPEN_FORCED_REQUESTS = 4096;\n', '    uint public constant MAX_AGE_FORCED_REQUEST_UNTIL_WITHDRAW_MODE = 15 days;\n', '    uint public constant TIMESTAMP_HALF_WINDOW_SIZE_IN_SECONDS = 7 days;\n', '    uint public constant MAX_NUM_ACCOUNTS = 2 ** 32;\n', '    uint public constant MAX_NUM_TOKENS = 2 ** 16;\n', '    uint public constant MIN_AGE_PROTOCOL_FEES_UNTIL_UPDATED = 7 days;\n', '    uint public constant MIN_TIME_IN_SHUTDOWN = 30 days;\n', '    // The amount of bytes each rollup transaction uses in the block data for data-availability.\n', '    // This is the maximum amount of bytes of all different transaction types.\n', '    uint32 public constant MAX_AGE_DEPOSIT_UNTIL_WITHDRAWABLE_UPPERBOUND = 15 days;\n', '    uint32 public constant ACCOUNTID_PROTOCOLFEE = 0;\n', '\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE = 68;\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE_PART_1 = 29;\n', '    uint public constant TX_DATA_AVAILABILITY_SIZE_PART_2 = 39;\n', '\n', '    struct AccountLeaf\n', '    {\n', '        uint32   accountID;\n', '        address  owner;\n', '        uint     pubKeyX;\n', '        uint     pubKeyY;\n', '        uint32   nonce;\n', '        uint     feeBipsAMM;\n', '    }\n', '\n', '    struct BalanceLeaf\n', '    {\n', '        uint16   tokenID;\n', '        uint96   balance;\n', '        uint96   weightAMM;\n', '        uint     storageRoot;\n', '    }\n', '\n', '    struct MerkleProof\n', '    {\n', '        ExchangeData.AccountLeaf accountLeaf;\n', '        ExchangeData.BalanceLeaf balanceLeaf;\n', '        uint[48]                 accountMerkleProof;\n', '        uint[24]                 balanceMerkleProof;\n', '    }\n', '\n', '    struct BlockContext\n', '    {\n', '        bytes32 DOMAIN_SEPARATOR;\n', '        uint32  timestamp;\n', '    }\n', '\n', '    // Represents the entire exchange state except the owner of the exchange.\n', '    struct State\n', '    {\n', '        uint32  maxAgeDepositUntilWithdrawable;\n', '        bytes32 DOMAIN_SEPARATOR;\n', '\n', '        ILoopringV3      loopring;\n', '        IBlockVerifier   blockVerifier;\n', '        IAgentRegistry   agentRegistry;\n', '        IDepositContract depositContract;\n', '\n', '\n', '        // The merkle root of the offchain data stored in a Merkle tree. The Merkle tree\n', '        // stores balances for users using an account model.\n', '        bytes32 merkleRoot;\n', '\n', '        // List of all blocks\n', '        mapping(uint => BlockInfo) blocks;\n', '        uint  numBlocks;\n', '\n', '        // List of all tokens\n', '        Token[] tokens;\n', '\n', '        // A map from a token to its tokenID + 1\n', '        mapping (address => uint16) tokenToTokenId;\n', '\n', '        // A map from an accountID to a tokenID to if the balance is withdrawn\n', '        mapping (uint32 => mapping (uint16 => bool)) withdrawnInWithdrawMode;\n', '\n', '        // A map from an account to a token to the amount withdrawable for that account.\n', '        // This is only used when the automatic distribution of the withdrawal failed.\n', '        mapping (address => mapping (uint16 => uint)) amountWithdrawable;\n', '\n', '        // A map from an account to a token to the forced withdrawal (always full balance)\n', '        mapping (uint32 => mapping (uint16 => ForcedWithdrawal)) pendingForcedWithdrawals;\n', '\n', '        // A map from an address to a token to a deposit\n', '        mapping (address => mapping (uint16 => Deposit)) pendingDeposits;\n', '\n', '        // A map from an account owner to an approved transaction hash to if the transaction is approved or not\n', '        mapping (address => mapping (bytes32 => bool)) approvedTx;\n', '\n', '        // A map from an account owner to a destination address to a tokenID to an amount to a storageID to a new recipient address\n', '        mapping (address => mapping (address => mapping (uint16 => mapping (uint => mapping (uint32 => address))))) withdrawalRecipient;\n', '\n', '\n', '        // Counter to keep track of how many of forced requests are open so we can limit the work that needs to be done by the owner\n', '        uint32 numPendingForcedTransactions;\n', '\n', '        // Cached data for the protocol fee\n', '        ProtocolFeeData protocolFeeData;\n', '\n', '        // Time when the exchange was shutdown\n', '        uint shutdownModeStartTime;\n', '\n', '        // Time when the exchange has entered withdrawal mode\n', '        uint withdrawalModeStartTime;\n', '\n', '        // Last time the protocol fee was withdrawn for a specific token\n', '        mapping (address => uint) protocolFeeLastWithdrawnTime;\n', '    }\n', '}\n', '\n', '// File: contracts/core/impl/libexchange/ExchangeBalances.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title ExchangeBalances.\n', '/// @author Daniel Wang  - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ExchangeBalances\n', '{\n', '    using MathUint  for uint;\n', '\n', '    function verifyAccountBalance(\n', '        uint                              merkleRoot,\n', '        ExchangeData.MerkleProof calldata merkleProof\n', '        )\n', '        public\n', '        pure\n', '    {\n', '        require(\n', '            isAccountBalanceCorrect(merkleRoot, merkleProof),\n', '            "INVALID_MERKLE_TREE_DATA"\n', '        );\n', '    }\n', '\n', '    function isAccountBalanceCorrect(\n', '        uint                            merkleRoot,\n', '        ExchangeData.MerkleProof memory merkleProof\n', '        )\n', '        public\n', '        pure\n', '        returns (bool)\n', '    {\n', '        // Calculate the Merkle root using the Merkle paths provided\n', '        uint calculatedRoot = getBalancesRoot(\n', '            merkleProof.balanceLeaf.tokenID,\n', '            merkleProof.balanceLeaf.balance,\n', '            merkleProof.balanceLeaf.weightAMM,\n', '            merkleProof.balanceLeaf.storageRoot,\n', '            merkleProof.balanceMerkleProof\n', '        );\n', '        calculatedRoot = getAccountInternalsRoot(\n', '            merkleProof.accountLeaf.accountID,\n', '            merkleProof.accountLeaf.owner,\n', '            merkleProof.accountLeaf.pubKeyX,\n', '            merkleProof.accountLeaf.pubKeyY,\n', '            merkleProof.accountLeaf.nonce,\n', '            merkleProof.accountLeaf.feeBipsAMM,\n', '            calculatedRoot,\n', '            merkleProof.accountMerkleProof\n', '        );\n', '        // Check against the expected Merkle root\n', '        return (calculatedRoot == merkleRoot);\n', '    }\n', '\n', '    function getBalancesRoot(\n', '        uint16   tokenID,\n', '        uint     balance,\n', '        uint     weightAMM,\n', '        uint     storageRoot,\n', '        uint[24] memory balanceMerkleProof\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        // Hash the balance leaf\n', '        uint balanceItem = hashImpl(balance, weightAMM, storageRoot, 0);\n', '        // Calculate the Merkle root of the balance quad Merkle tree\n', '        uint _id = tokenID;\n', '        for (uint depth = 0; depth < 8; depth++) {\n', '            uint base = depth * 3;\n', '            if (_id & 3 == 0) {\n', '                balanceItem = hashImpl(\n', '                    balanceItem,\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 1) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceItem,\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 2) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceItem,\n', '                    balanceMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 3) {\n', '                balanceItem = hashImpl(\n', '                    balanceMerkleProof[base],\n', '                    balanceMerkleProof[base + 1],\n', '                    balanceMerkleProof[base + 2],\n', '                    balanceItem\n', '                );\n', '            }\n', '            _id = _id >> 2;\n', '        }\n', '        return balanceItem;\n', '    }\n', '\n', '    function getAccountInternalsRoot(\n', '        uint32   accountID,\n', '        address  owner,\n', '        uint     pubKeyX,\n', '        uint     pubKeyY,\n', '        uint     nonce,\n', '        uint     feeBipsAMM,\n', '        uint     balancesRoot,\n', '        uint[48] memory accountMerkleProof\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        // Hash the account leaf\n', '        uint accountItem = hashAccountLeaf(uint(owner), pubKeyX, pubKeyY, nonce, feeBipsAMM, balancesRoot);\n', '        // Calculate the Merkle root of the account quad Merkle tree\n', '        uint _id = accountID;\n', '        for (uint depth = 0; depth < 16; depth++) {\n', '            uint base = depth * 3;\n', '            if (_id & 3 == 0) {\n', '                accountItem = hashImpl(\n', '                    accountItem,\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 1) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountItem,\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 2) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountItem,\n', '                    accountMerkleProof[base + 2]\n', '                );\n', '            } else if (_id & 3 == 3) {\n', '                accountItem = hashImpl(\n', '                    accountMerkleProof[base],\n', '                    accountMerkleProof[base + 1],\n', '                    accountMerkleProof[base + 2],\n', '                    accountItem\n', '                );\n', '            }\n', '            _id = _id >> 2;\n', '        }\n', '        return accountItem;\n', '    }\n', '\n', '    function hashAccountLeaf(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3,\n', '        uint t4,\n', '        uint t5\n', '        )\n', '        public\n', '        pure\n', '        returns (uint)\n', '    {\n', '        Poseidon.HashInputs7 memory inputs = Poseidon.HashInputs7(t0, t1, t2, t3, t4, t5, 0);\n', '        return Poseidon.hash_t7f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD);\n', '    }\n', '\n', '    function hashImpl(\n', '        uint t0,\n', '        uint t1,\n', '        uint t2,\n', '        uint t3\n', '        )\n', '        private\n', '        pure\n', '        returns (uint)\n', '    {\n', '        Poseidon.HashInputs5 memory inputs = Poseidon.HashInputs5(t0, t1, t2, t3, 0);\n', '        return Poseidon.hash_t5f6p52(inputs, ExchangeData.SNARK_SCALAR_FIELD);\n', '    }\n', '}']