['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-24\n', '*/\n', '\n', '// File: contracts/interface/IMarketRegulator.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IMarketRegulator {\n', '    function IsInWhiteList(address wantToken)\n', '        external\n', '        view\n', '        returns (bool inTheList);\n', '\n', '    function IsInBlackList(uint256 _shardPoolId)\n', '        external\n', '        view\n', '        returns (bool inTheList);\n', '}\n', '\n', '// File: contracts/interface/IBuyoutProposals.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract DelegationStorage {\n', '    address public governance;\n', '    /**\n', '     * @notice Implementation address for this contract\n', '     */\n', '    address public implementation;\n', '}\n', '\n', 'contract IBuyoutProposalsStorge is DelegationStorage {\n', '    address public regulator;\n', '    address public market;\n', '\n', '    uint256 public proposolIdCount;\n', '\n', '    uint256 public voteLenth = 259200;\n', '\n', '    mapping(uint256 => uint256) public proposalIds;\n', '\n', '    mapping(uint256 => uint256[]) internal proposalsHistory;\n', '\n', '    mapping(uint256 => Proposal) public proposals;\n', '\n', '    mapping(uint256 => mapping(address => bool)) public voted;\n', '\n', '    uint256 public passNeeded = 75;\n', '\n', '    // n times higher than the market price to buyout\n', '    uint256 public buyoutTimes = 100;\n', '\n', '    uint256 internal constant max = 100;\n', '\n', '    uint256 public buyoutProportion = 15;\n', '\n', '    mapping(uint256 => uint256) allVotes;\n', '\n', '    struct Proposal {\n', '        uint256 votesReceived;\n', '        uint256 voteTotal;\n', '        bool passed;\n', '        address submitter;\n', '        uint256 voteDeadline;\n', '        uint256 shardAmount;\n', '        uint256 wantTokenAmount;\n', '        uint256 buyoutTimes;\n', '        uint256 price;\n', '        bool isSubmitterWithDraw;\n', '        uint256 shardPoolId;\n', '        bool isFailedConfirmed;\n', '        uint256 blockHeight;\n', '        uint256 createTime;\n', '    }\n', '}\n', '\n', 'abstract contract IBuyoutProposals is IBuyoutProposalsStorge {\n', '    function createProposal(\n', '        uint256 _shardPoolId,\n', '        uint256 shardBalance,\n', '        uint256 wantTokenAmount,\n', '        uint256 currentPrice,\n', '        uint256 totalShardSupply,\n', '        address submitter\n', '    ) external virtual returns (uint256 proposalId, uint256 buyoutTimes);\n', '\n', '    function vote(\n', '        uint256 _shardPoolId,\n', '        bool isAgree,\n', '        address shard,\n', '        address voter\n', '    ) external virtual returns (uint256 proposalId, uint256 balance);\n', '\n', '    function voteResultConfirm(uint256 _shardPoolId)\n', '        external\n', '        virtual\n', '        returns (\n', '            uint256 proposalId,\n', '            bool result,\n', '            address submitter,\n', '            uint256 shardAmount,\n', '            uint256 wantTokenAmount\n', '        );\n', '\n', '    function exchangeForWantToken(uint256 _shardPoolId, uint256 shardAmount)\n', '        external\n', '        view\n', '        virtual\n', '        returns (uint256 wantTokenAmount);\n', '\n', '    function redeemForBuyoutFailed(uint256 _proposalId, address submitter)\n', '        external\n', '        virtual\n', '        returns (\n', '            uint256 _shardPoolId,\n', '            uint256 shardTokenAmount,\n', '            uint256 wantTokenAmount\n', '        );\n', '\n', '    function setBuyoutTimes(uint256 _buyoutTimes) external virtual;\n', '\n', '    function setVoteLenth(uint256 _voteLenth) external virtual;\n', '\n', '    function setPassNeeded(uint256 _passNeeded) external virtual;\n', '\n', '    function setBuyoutProportion(uint256 _buyoutProportion) external virtual;\n', '\n', '    function setMarket(address _market) external virtual;\n', '\n', '    function setRegulator(address _regulator) external virtual;\n', '\n', '    function getProposalsForExactPool(uint256 _shardPoolId)\n', '        external\n', '        view\n', '        virtual\n', '        returns (uint256[] memory _proposalsHistory);\n', '}\n', '\n', '// File: contracts/interface/IShardToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IShardToken {\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external pure returns (string memory);\n', '\n', '    function symbol() external pure returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function burn(uint256 value) external;\n', '\n', '    function mint(address to, uint256 value) external;\n', '\n', '    function initialize(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        address market\n', '    ) external;\n', '\n', '    function getPriorVotes(address account, uint256 blockNumber)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/BuyoutProposals.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', 'contract BuyoutProposals is IBuyoutProposals {\n', '    using SafeMath for uint256;\n', '\n', '    constructor() public {}\n', '\n', '    function initialize(address _governance, address _regulator) external {\n', '        require(governance == msg.sender, "UNAUTHORIZED");\n', '        require(regulator == address(0), "ALREADY INITIALIZED");\n', '        governance = _governance;\n', '        regulator = _regulator;\n', '    }\n', '\n', '    function createProposal(\n', '        uint256 _shardPoolId,\n', '        uint256 shardBalance,\n', '        uint256 wantTokenAmount,\n', '        uint256 currentPrice,\n', '        uint256 totalShardSupply,\n', '        address submitter\n', '    ) external override returns (uint256, uint256) {\n', '        require(msg.sender == market, "UNAUTHORIZED");\n', '        require(\n', '            shardBalance >= totalShardSupply.mul(buyoutProportion).div(max),\n', '            "INSUFFIENT BALANCE"\n', '        );\n', '        uint256 otherShards = totalShardSupply.sub(shardBalance);\n', '        uint256 needAmount =\n', '            otherShards.mul(currentPrice).mul(buyoutTimes).div(max).div(1e18);\n', '        require(wantTokenAmount >= needAmount, "INSUFFICIENT WANTTOKENAMOUNT");\n', '        require(\n', '            !IMarketRegulator(regulator).IsInBlackList(_shardPoolId),\n', '            "ON THE BLACKLIST"\n', '        );\n', '        uint256 proposalId = proposolIdCount.add(1);\n', '        proposalIds[_shardPoolId] = proposalId;\n', '        uint256 timestamp = block.timestamp.add(voteLenth);\n', '        proposals[proposalId] = Proposal({\n', '            votesReceived: 0,\n', '            voteTotal: 0,\n', '            passed: false,\n', '            submitter: submitter,\n', '            voteDeadline: timestamp,\n', '            shardAmount: shardBalance,\n', '            wantTokenAmount: wantTokenAmount,\n', '            buyoutTimes: buyoutTimes,\n', '            price: currentPrice,\n', '            isSubmitterWithDraw: false,\n', '            shardPoolId: _shardPoolId,\n', '            isFailedConfirmed: false,\n', '            blockHeight: block.number,\n', '            createTime: block.timestamp\n', '        });\n', '        allVotes[proposalId] = otherShards;\n', '        proposalsHistory[_shardPoolId].push(proposalId);\n', '        voted[proposalId][submitter] = true;\n', '        proposolIdCount = proposalId;\n', '        return (proposalId, buyoutTimes);\n', '    }\n', '\n', '    function vote(\n', '        uint256 _shardPoolId,\n', '        bool isAgree,\n', '        address shard,\n', '        address voter\n', '    ) external override returns (uint256 proposalId, uint256 balance) {\n', '        require(msg.sender == market, "UNAUTHORIZED");\n', '        proposalId = proposalIds[_shardPoolId];\n', '        require(\n', '            block.timestamp <= proposals[proposalId].voteDeadline,\n', '            "EXPIRED"\n', '        );\n', '        uint256 blockHeight = proposals[proposalId].blockHeight;\n', '        balance = IShardToken(shard).getPriorVotes(voter, blockHeight);\n', '        require(balance > 0, "INSUFFICIENT VOTERIGHT");\n', '        require(!voted[proposalId][voter], "AlREADY VOTED");\n', '        voted[proposalId][voter] = true;\n', '        if (isAgree) {\n', '            proposals[proposalId].votesReceived = proposals[proposalId]\n', '                .votesReceived\n', '                .add(balance);\n', '            proposals[proposalId].voteTotal = proposals[proposalId]\n', '                .voteTotal\n', '                .add(balance);\n', '        } else {\n', '            proposals[proposalId].voteTotal = proposals[proposalId]\n', '                .voteTotal\n', '                .add(balance);\n', '        }\n', '    }\n', '\n', '    function voteResultConfirm(uint256 _shardPoolId)\n', '        external\n', '        override\n', '        returns (\n', '            uint256 proposalId,\n', '            bool result,\n', '            address submitter,\n', '            uint256 shardAmount,\n', '            uint256 wantTokenAmount\n', '        )\n', '    {\n', '        require(msg.sender == market, "UNAUTHORIZED");\n', '        proposalId = proposalIds[_shardPoolId];\n', '        require(\n', '            block.timestamp > proposals[proposalId].voteDeadline,\n', '            "NOT READY"\n', '        );\n', '        uint256 votesRejected =\n', '            proposals[proposalId].voteTotal.sub(\n', '                proposals[proposalId].votesReceived\n', '            );\n', '        uint256 rejectNeed = max.sub(passNeeded);\n', '        if (\n', '            votesRejected <= allVotes[proposalId].mul(rejectNeed).div(max) &&\n', '            !IMarketRegulator(regulator).IsInBlackList(_shardPoolId)\n', '        ) {\n', '            proposals[proposalId].passed = true;\n', '            result = true;\n', '            submitter = proposals[proposalId].submitter;\n', '            shardAmount = proposals[proposalId].shardAmount;\n', '            wantTokenAmount = proposals[proposalId].wantTokenAmount;\n', '        } else {\n', '            proposals[proposalId].passed = false;\n', '            proposals[proposalId].isFailedConfirmed = true;\n', '            result = false;\n', '        }\n', '    }\n', '\n', '    function exchangeForWantToken(uint256 _shardPoolId, uint256 shardAmount)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256 wantTokenAmount)\n', '    {\n', '        uint256 proposalId = proposalIds[_shardPoolId];\n', '        Proposal memory p = proposals[proposalId];\n', '        uint256 otherShards = allVotes[proposalId];\n', '        wantTokenAmount = shardAmount.mul(p.wantTokenAmount).div(otherShards);\n', '    }\n', '\n', '    function redeemForBuyoutFailed(uint256 _proposalId, address submitter)\n', '        external\n', '        override\n', '        returns (\n', '            uint256 shardPoolId,\n', '            uint256 shardTokenAmount,\n', '            uint256 wantTokenAmount\n', '        )\n', '    {\n', '        require(msg.sender == market, "UNAUTHORIZED");\n', '        Proposal memory p = proposals[_proposalId];\n', '        require(submitter == p.submitter, "UNAUTHORIZED");\n', '        require(\n', '            p.isFailedConfirmed && !p.isSubmitterWithDraw && !p.passed,\n', '            "WRONG STATE"\n', '        );\n', '        shardPoolId = p.shardPoolId;\n', '        shardTokenAmount = p.shardAmount;\n', '        wantTokenAmount = p.wantTokenAmount;\n', '        proposals[_proposalId].isSubmitterWithDraw = true;\n', '    }\n', '\n', '    function setVoteLenth(uint256 _voteLenth) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        voteLenth = _voteLenth;\n', '    }\n', '\n', '    function setPassNeeded(uint256 _passNeeded) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        require(_passNeeded < max, "INVALID");\n', '        passNeeded = _passNeeded;\n', '    }\n', '\n', '    function setBuyoutProportion(uint256 _buyoutProportion) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        require(_buyoutProportion < max, "INVALID");\n', '        buyoutProportion = _buyoutProportion;\n', '    }\n', '\n', '    function setBuyoutTimes(uint256 _buyoutTimes) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        buyoutTimes = _buyoutTimes;\n', '    }\n', '\n', '    function setMarket(address _market) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        market = _market;\n', '    }\n', '\n', '    function setRegulator(address _regulator) external override {\n', '        require(msg.sender == governance, "UNAUTHORIZED");\n', '        regulator = _regulator;\n', '    }\n', '\n', '    function getProposalsForExactPool(uint256 _shardPoolId)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256[] memory _proposalsHistory)\n', '    {\n', '        _proposalsHistory = proposalsHistory[_shardPoolId];\n', '    }\n', '}\n', '\n', '// File: contracts/BuyoutProposalsdelegate.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'contract BuyoutProposalsDelegate is BuyoutProposals {\n', '    /**\n', '     * @notice Construct an empty delegate\n', '     */\n', '    constructor() public {}\n', '}']