['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-04\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', 'pragma solidity =0.8.4;\n', 'pragma experimental ABIEncoderV2;\n', '// Leak alpha with https://twitter.com/mevalphaleak\n', '\n', '// All existing flash-loan providers have at least one of the following downsides\n', '// - Taking excessive fee for the service\n', '// - Hard to loan multiple assets at once\n', '// - Horribly inefficient in terms of gas:\n', '//  - Emitting pointless events\n', '//  - Creating useless additional transfers\n', '//  - No SLOAD/SSTORE optimisation past EIP-2929\n', '\n', '// ApeBank is introduced to make most gas efficient flash-loans available to everyone completely for free\n', '// Combined with native gas refunds without any additional sstore operations\n', '\n', "// ApeBank doesnt use safeMath and cuts corners everywhere, it isn't suitable for flash-mintable tokens\n", "// Contract wasnt audited by anyone and there's no benefit for depositing tokens into this contract and no APY\n", '// Anyone with half-working brain should think twice before putting anything into this contract\n', 'contract ApeBank {\n', '    string  public   constant name = "YEET 2.0";\n', '    address internal constant TOKEN_ETH  = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address internal constant TOKEN_WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address internal constant TOKEN_WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n', '    address internal constant TOKEN_DAI  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    address internal constant TOKEN_USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '    address internal constant TOKEN_USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '\n', '    uint256 internal constant TOKEN_WETH_MULTIPLIER = 10 ** 14; // 0.4$ at the time of contract creation\n', '    uint256 internal constant TOKEN_WBTC_MULTIPLIER = 10 ** 3;  // 0.5$ at the time of contract creation\n', '    uint256 internal constant TOKEN_DAI_MULTIPLIER  = 10 ** 18;\n', '    uint256 internal constant TOKEN_USDC_MULTIPLIER = 10 ** 6;\n', '    uint256 internal constant TOKEN_USDT_MULTIPLIER = 10 ** 6;\n', '\n', '    uint256 internal constant FLAG_BORROW_ETH  = 0x1;\n', '    uint256 internal constant FLAG_BORROW_WETH = 0x2;\n', '    uint256 internal constant FLAG_BORROW_WBTC = 0x4;\n', '    uint256 internal constant FLAG_BORROW_DAI  = 0x8;\n', '    uint256 internal constant FLAG_BORROW_USDC = 0x10;\n', '    uint256 internal constant FLAG_BORROW_USDT = 0x20;\n', '    uint256 internal constant FLAG_COVER_WETH  = 0x40;\n', '\n', '    uint256 internal constant FLAG_BURN_NATIVE = 0x80;\n', '    uint256 internal constant FLAG_BURN_GST2   = 0x100;\n', '    uint256 internal constant FLAG_BURN_CHI    = 0x200;\n', '\n', '    uint256 internal constant FLAG_SMALL_CALLBACK = 0x400;\n', '    uint256 internal constant FLAG_LARGE_CALLBACK = 0x800;\n', '\n', '    uint256 internal constant FLAG_FREE_GAS_TOKEN               = 0x1000;\n', '    uint256 internal constant FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT  = 0x1000000000000000000000000000000000000000000000000000000000000;\n', '\n', '    Types.BankState public state;\n', '    Types.GasTokenPrices public gasTokenBurnPrices;\n', '\n', "    // Total amount of tokens deposited into ApeBank, this value can be lower than balances in 'state'\n", '    mapping (address => uint256) public totalDeposits;\n', '    mapping (address => uint256) public userEthBalances;\n', '    mapping (address => Types.BankState) public userTokenBalances;\n', '    // Our hall of fame which allows to use gas tokens for free\n', '    mapping (address => bool) public bestApeOperators;\n', '    \n', '    // Used to collect excess balances and acquire gas tokens\n', '    address public treasury;\n', '    address public pendingTresury;\n', '\n', '    event Deposit(address indexed user, address indexed token, uint256 amount);\n', '    event Withdrawal(address indexed user, address indexed token, uint256 amount);\n', '    event SkimmedBalance(address indexed treasury, address indexed token, uint256 amount);\n', '    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n', '\n', '    constructor () {\n', '        treasury = msg.sender;\n', '        pendingTresury = 0x0000000000000000000000000000000000000000;\n', '        emit TreasuryUpdated(pendingTresury, treasury);\n', '    }\n', '    function nominateTreasury(address nomination) external {\n', '        require(msg.sender == treasury);\n', '        pendingTresury = nomination;\n', '    }\n', '    function acceptNomination() external {\n', '        require(msg.sender == pendingTresury);\n', '        emit TreasuryUpdated(treasury, pendingTresury);\n', '        treasury = pendingTresury;\n', '        pendingTresury = 0x0000000000000000000000000000000000000000;\n', '    }\n', '    function updateGasTokenPrices(uint80 priceGST2, uint80 priceCHI, uint80 priceNative) external {\n', '        require(msg.sender == treasury);\n', '        Types.GasTokenPrices memory cachedPrices;\n', '        cachedPrices.priceGST2 = priceGST2;\n', '        cachedPrices.priceCHI = priceCHI;\n', '        cachedPrices.priceNative = priceNative;\n', '        gasTokenBurnPrices = cachedPrices;\n', '    }\n', '    function promoteToFreeGasTokens(address apeOperator) external {\n', '        require(msg.sender == treasury);\n', '        bestApeOperators[apeOperator] = true;\n', '    }\n', '    \n', '    fallback() external payable {}\n', '    receive() external payable {}\n', '\n', '    // Logic to skim excess balances into treasury to acquire more gas tokens\n', '    function skimExcessBalances(address token) external {\n', '        require(msg.sender == treasury);\n', '        uint256 minBalanceToKeep = totalDeposits[token] + 1;\n', '\n', '        Types.BankState memory cachedBankState = state;\n', '        uint256 availableBalance;\n', '        if (token == TOKEN_ETH) {\n', '            availableBalance = address(this).balance;\n', '            require(availableBalance > minBalanceToKeep);\n', '            TransferHelper.safeTransferETH(\n', '                msg.sender,\n', '                availableBalance - minBalanceToKeep\n', '            );\n', "            // ETH balances aren't saved in state\n", '        } else {\n', '            availableBalance = IERC20Token(token).balanceOf(address(this));\n', '            require(availableBalance > minBalanceToKeep);\n', '            TransferHelper.safeTransfer(\n', '                token,\n', '                msg.sender,\n', '                availableBalance - minBalanceToKeep\n', '            );\n', '\n', '            if (token == TOKEN_WETH) {\n', '                cachedBankState.wethBalance = uint32(minBalanceToKeep / TOKEN_WETH_MULTIPLIER);\n', '            } else if (token == TOKEN_WBTC) {\n', '                cachedBankState.wbtcBalance = uint32(minBalanceToKeep / TOKEN_WBTC_MULTIPLIER);\n', '            } else if (token == TOKEN_DAI) {\n', '                cachedBankState.daiBalance  = uint32(minBalanceToKeep / TOKEN_DAI_MULTIPLIER );\n', '            } else if (token == TOKEN_USDC) {\n', '                cachedBankState.usdcBalance = uint32(minBalanceToKeep / TOKEN_USDC_MULTIPLIER);\n', '            } else if (token == TOKEN_USDT) {\n', '                cachedBankState.usdtBalance = uint32(minBalanceToKeep / TOKEN_USDT_MULTIPLIER);\n', '            }\n', '        }\n', '\n', '        require(cachedBankState.numCalls == state.numCalls);\n', '        cachedBankState.numCalls += 1;\n', '        state = cachedBankState;\n', '        emit SkimmedBalance(msg.sender, token, availableBalance - minBalanceToKeep);\n', '    }\n', '\n', '    function deposit(address token, uint256 amount) external payable {\n', '        Types.BankState memory cachedBankState = state;\n', '        if (msg.value > 0) {\n', '            require(token == TOKEN_ETH && msg.value == amount, "Incorrect deposit amount");\n', '            userEthBalances[msg.sender] += msg.value;\n', '        } else {\n', '            TransferHelper.safeTransferFrom(\n', '                token,\n', '                msg.sender,\n', '                address(this),\n', '                amount\n', '            );            \n', '            if (token == TOKEN_WETH) {\n', '                require(amount % TOKEN_WETH_MULTIPLIER == 0, "Incorrect deposit amount");\n', '                uint256 newBalance = cachedBankState.wethBalance + (amount / TOKEN_WETH_MULTIPLIER);\n', '                require(newBalance < (2 ** 32), "Bank size is excessive");\n', '                cachedBankState.wethBalance = uint32(newBalance);\n', '                userTokenBalances[msg.sender].wethBalance += uint32(amount / TOKEN_WETH_MULTIPLIER);\n', '            } else if (token == TOKEN_WBTC) {\n', '                require(amount % TOKEN_WBTC_MULTIPLIER == 0, "Incorrect deposit amount");\n', '                uint256 newBalance = cachedBankState.wbtcBalance + (amount / TOKEN_WBTC_MULTIPLIER);\n', '                require(newBalance < (2 ** 32), "Bank size is excessive");\n', '                cachedBankState.wbtcBalance = uint32(newBalance);\n', '                userTokenBalances[msg.sender].wbtcBalance += uint32(amount / TOKEN_WBTC_MULTIPLIER);\n', '            } else if (token == TOKEN_DAI) {\n', '                require(amount % TOKEN_DAI_MULTIPLIER == 0, "Incorrect deposit amount");\n', '                uint256 newBalance = cachedBankState.daiBalance + (amount / TOKEN_DAI_MULTIPLIER);\n', '                require(newBalance < (2 ** 32), "Bank size is excessive");\n', '                cachedBankState.daiBalance = uint32(newBalance);\n', '                userTokenBalances[msg.sender].daiBalance += uint32(amount / TOKEN_DAI_MULTIPLIER);\n', '            } else if (token == TOKEN_USDC) {\n', '                require(amount % TOKEN_USDC_MULTIPLIER == 0, "Incorrect deposit amount");\n', '                uint256 newBalance = cachedBankState.usdcBalance + (amount / TOKEN_USDC_MULTIPLIER);\n', '                require(newBalance < (2 ** 32), "Bank size is excessive");\n', '                cachedBankState.usdcBalance = uint32(newBalance);\n', '                userTokenBalances[msg.sender].usdcBalance += uint32(amount / TOKEN_USDC_MULTIPLIER);\n', '            } else {\n', '                require(token == TOKEN_USDT, "Token not supported");\n', '                require(amount % TOKEN_USDT_MULTIPLIER == 0, "Incorrect deposit amount");\n', '                uint256 newBalance = cachedBankState.usdtBalance + (amount / TOKEN_USDT_MULTIPLIER);\n', '                require(newBalance < (2 ** 32), "Bank size is excessive");\n', '                cachedBankState.usdtBalance = uint32(newBalance);\n', '                userTokenBalances[msg.sender].usdtBalance += uint32(amount / TOKEN_USDT_MULTIPLIER);\n', '            }\n', '        }\n', '        totalDeposits[token] += amount;\n', '        \n', '        require(cachedBankState.numCalls == state.numCalls);\n', '        cachedBankState.numCalls += 1;\n', '        state = cachedBankState;\n', '        emit Deposit(msg.sender, token, amount);\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) external {\n', '        Types.BankState memory cachedBankState = state;\n', '        \n', '        totalDeposits[token] -= amount;\n', '        if (token == TOKEN_ETH) {\n', '            require(userEthBalances[msg.sender] >= amount);\n', '            userEthBalances[msg.sender] -= amount;\n', "            // ETH balances aren't saved into state\n", '            TransferHelper.safeTransferETH(\n', '                msg.sender,\n', '                amount\n', '            );\n', '        } else {\n', '            if (token == TOKEN_WETH) {\n', '                require(amount % TOKEN_WETH_MULTIPLIER == 0, "Incorrect withdraw amount");\n', '                uint256 amountDelta = amount / TOKEN_WETH_MULTIPLIER;\n', '                require(uint256(userTokenBalances[msg.sender].wethBalance) >= amountDelta);\n', '                userTokenBalances[msg.sender].wethBalance -= uint32(amountDelta);\n', '                cachedBankState.wethBalance -= uint32(amountDelta);\n', '            } else if (token == TOKEN_WBTC) {\n', '                require(amount % TOKEN_WBTC_MULTIPLIER == 0, "Incorrect withdraw amount");\n', '                uint256 amountDelta = amount / TOKEN_WBTC_MULTIPLIER;\n', '                require(uint256(userTokenBalances[msg.sender].wbtcBalance) >= amountDelta);\n', '                userTokenBalances[msg.sender].wbtcBalance -= uint32(amountDelta);\n', '                cachedBankState.wbtcBalance -= uint32(amountDelta);\n', '            } else if (token == TOKEN_DAI) {\n', '                require(amount % TOKEN_DAI_MULTIPLIER == 0, "Incorrect withdraw amount");\n', '                uint256 amountDelta = amount / TOKEN_DAI_MULTIPLIER;\n', '                require(uint256(userTokenBalances[msg.sender].daiBalance) >= amountDelta);\n', '                userTokenBalances[msg.sender].daiBalance -= uint32(amountDelta);\n', '                cachedBankState.daiBalance -= uint32(amountDelta);\n', '            } else if (token == TOKEN_USDC) {\n', '                require(amount % TOKEN_USDC_MULTIPLIER == 0, "Incorrect withdraw amount");\n', '                uint256 amountDelta = amount / TOKEN_USDC_MULTIPLIER;\n', '                require(uint256(userTokenBalances[msg.sender].usdcBalance) >= amountDelta);\n', '                userTokenBalances[msg.sender].usdcBalance -= uint32(amountDelta);\n', '                cachedBankState.usdcBalance -= uint32(amountDelta);\n', '            } else {\n', '                require(token == TOKEN_USDT, "Token not supported");\n', '                require(amount % TOKEN_USDT_MULTIPLIER == 0, "Incorrect withdraw amount");\n', '                uint256 amountDelta = amount / TOKEN_USDT_MULTIPLIER;\n', '                require(uint256(userTokenBalances[msg.sender].usdtBalance) >= amountDelta);\n', '                userTokenBalances[msg.sender].usdtBalance -= uint32(amountDelta);\n', '                cachedBankState.usdtBalance -= uint32(amountDelta);\n', '            }\n', '            TransferHelper.safeTransfer(\n', '                token,\n', '                msg.sender,\n', '                amount\n', '            );        \n', '        }\n', '        \n', '        require(cachedBankState.numCalls == state.numCalls);\n', '        cachedBankState.numCalls += 1;\n', '        state = cachedBankState;\n', '        emit Withdrawal(msg.sender, token, amount);\n', '    }\n', '    \n', '    function flashApe(address payable callTo, uint256 flags, bytes calldata params) external payable {\n', '        Types.BankState memory cachedBankState = state;\n', '\n', '        if ((flags & FLAG_BORROW_WETH) > 0) {\n', '            TransferHelper.safeTransfer(\n', '                TOKEN_WETH,\n', '                callTo,\n', '                uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER\n', '            );\n', '        }\n', '        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\n', '            if ((flags & FLAG_BORROW_WBTC) > 0) {\n', '                TransferHelper.safeTransfer(\n', '                    TOKEN_WBTC,\n', '                    callTo,\n', '                    uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER\n', '                );\n', '            }\n', '            if ((flags & FLAG_BORROW_DAI) > 0) {\n', '                TransferHelper.safeTransfer(\n', '                    TOKEN_DAI,\n', '                    callTo,\n', '                    uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER\n', '                );\n', '            }\n', '            if ((flags & FLAG_BORROW_USDC) > 0) {\n', '                TransferHelper.safeTransfer(\n', '                    TOKEN_USDC,\n', '                    callTo,\n', '                    uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER\n', '                );\n', '            }\n', '            if ((flags & FLAG_BORROW_USDT) > 0) {\n', '                TransferHelper.safeTransfer(\n', '                    TOKEN_USDT,\n', '                    callTo,\n', '                    uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER\n', '                );\n', '            }\n', '        }\n', '        uint256 oldSelfBalance = address(this).balance;\n', '\n', '        // For "ease" of integration allowing several different callback options\n', '        if ((flags & (FLAG_SMALL_CALLBACK | FLAG_LARGE_CALLBACK)) > 0) {\n', '            // Native payable callbacks\n', '            if ((flags & FLAG_SMALL_CALLBACK) > 0) {\n', '                IApeBot(callTo).smallApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\n', '                    params\n', '                );\n', '            } else {\n', '                IApeBot(callTo).largeApeCallback{value: ((flags & FLAG_BORROW_ETH) > 0) ? oldSelfBalance - 1 : 0}(\n', '                    msg.sender,\n', '                    (((flags & FLAG_BORROW_WETH) > 0) ? uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER : 0),\n', '                    (((flags & FLAG_BORROW_WBTC) > 0) ? uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER : 0),\n', '                    (((flags & FLAG_BORROW_DAI ) > 0) ? uint256(cachedBankState.daiBalance ) * TOKEN_DAI_MULTIPLIER  : 0),\n', '                    (((flags & FLAG_BORROW_USDC) > 0) ? uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER : 0),\n', '                    (((flags & FLAG_BORROW_USDT) > 0) ? uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER : 0),\n', '                    params\n', '                );\n', '            }\n', '        } else {\n', '            // Immitating popular non-payable callback\n', '            if ((flags & FLAG_BORROW_ETH) > 0) {\n', '                TransferHelper.safeTransferETH(\n', '                    callTo,\n', '                    oldSelfBalance - 1\n', '                );\n', '            }\n', '            IApeBot(callTo).callFunction(\n', '                msg.sender,\n', '                Types.AccountInfo({\n', '                    owner: address(msg.sender),\n', '                    number: 1\n', '                }),\n', '                params\n', '            );\n', '        }\n', '\n', '        // Verifying that all funds were returned\n', "        // If Ether was sent into this function it shouldn't be counted against original balance\n", '        oldSelfBalance -= msg.value;\n', '        uint256 newSelfBalance = address(this).balance;\n', '        // Performing gas refunds\n', '        if ((flags & (FLAG_BURN_NATIVE | FLAG_BURN_GST2 | FLAG_BURN_CHI)) > 0) {\n', '            // No point in burning more than 256 tokens\n', '            uint32 tokensToBurn = uint32((flags / FLAG_GAS_TOKEN_BURN_AMOUNT_SHIFT) & 0xff);\n', '\n', '            Types.GasTokenPrices memory cachedBurnPrices;\n', '            if ((flags & FLAG_FREE_GAS_TOKEN) > 0) {\n', '                // Bot can enter hall of fame and get free gas tokens for life\n', '                require(bestApeOperators[msg.sender]);\n', '            } else {\n', '                // Otherwise price of these gas tokens would have to be deducted\n', '                cachedBurnPrices = gasTokenBurnPrices;\n', '            }\n', '\n', '            if (((flags & FLAG_BURN_NATIVE) > 0) && (cachedBankState.totalContractsCreated > cachedBankState.firstContractToDestroy + tokensToBurn)) {\n', '                _destroyContracts(cachedBankState.firstContractToDestroy, cachedBankState.firstContractToDestroy + tokensToBurn);\n', '                cachedBankState.firstContractToDestroy += tokensToBurn;\n', '                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceNative);\n', '                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceNative;\n', '            } else if ((flags & FLAG_BURN_GST2) > 0) {\n', '                IGasToken(0x0000000000b3F879cb30FE243b4Dfee438691c04).free(tokensToBurn);\n', '                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceGST2);\n', '                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceGST2;\n', '            } else if ((flags & FLAG_BURN_CHI) > 0) {\n', '                IGasToken(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c).free(tokensToBurn);\n', '                require(newSelfBalance > tokensToBurn * cachedBurnPrices.priceCHI);\n', '                newSelfBalance -= tokensToBurn * cachedBurnPrices.priceCHI;\n', '            }\n', '        }\n', '\n', '        if ((flags & (FLAG_BORROW_WETH | FLAG_COVER_WETH)) > 0) {\n', '            // We can combine ETH and WETH balances in this case\n', '            uint256 wethBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n', '            require(wethBalance < (2 ** 32) * TOKEN_WETH_MULTIPLIER && (newSelfBalance + wethBalance > oldSelfBalance + uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER));\n', '\n', '            if (wethBalance <= uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER) {\n', "                // User didn't return enough WETH covering via excess ETH\n", '                uint256 deltaToCover = uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + 1 - wethBalance;\n', '                require(newSelfBalance >= oldSelfBalance + deltaToCover);\n', '\n', '                WETH9(TOKEN_WETH).deposit{value: deltaToCover}();\n', "                // newSelfBalance won't be used anywhere below\n", '                // WETH balance stays the same in the newState\n', '            } else if (newSelfBalance < oldSelfBalance) {\n', "                // User didn't return enough ETH covering via excess WETH\n", '                require(wethBalance > uint256(cachedBankState.wethBalance) * TOKEN_WETH_MULTIPLIER + (oldSelfBalance - newSelfBalance));\n', '\n', '                WETH9(TOKEN_WETH).withdraw(oldSelfBalance - newSelfBalance);\n', "                // newSelfBalance won't be used anywhere below\n", '                cachedBankState.wethBalance = uint32((wethBalance - (oldSelfBalance - newSelfBalance)) / TOKEN_WETH_MULTIPLIER);\n', '            } else {\n', '                cachedBankState.wethBalance = uint32(wethBalance / TOKEN_WETH_MULTIPLIER);\n', '            }\n', '        } else {\n', '            require(newSelfBalance >= oldSelfBalance);\n', '        }\n', '\n', '        if ((flags & (FLAG_BORROW_WBTC | FLAG_BORROW_DAI | FLAG_BORROW_USDC | FLAG_BORROW_USDT)) > 0) {\n', '            if ((flags & FLAG_BORROW_WBTC) > 0) {\n', '                uint256 wbtcBalance = IERC20Token(TOKEN_WBTC).balanceOf(address(this));\n', '                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n', '                require(wbtcBalance < (2 ** 32) * TOKEN_WBTC_MULTIPLIER && wbtcBalance > uint256(cachedBankState.wbtcBalance) * TOKEN_WBTC_MULTIPLIER);\n', '                cachedBankState.wbtcBalance = uint32(wbtcBalance / TOKEN_WBTC_MULTIPLIER);\n', '            }\n', '            if ((flags & FLAG_BORROW_DAI) > 0) {\n', '                uint256 daiBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\n', '                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n', '                require(daiBalance < (2 ** 32) * TOKEN_DAI_MULTIPLIER && daiBalance > uint256(cachedBankState.daiBalance) * TOKEN_DAI_MULTIPLIER);\n', '                cachedBankState.daiBalance = uint32(daiBalance / TOKEN_DAI_MULTIPLIER);\n', '            }\n', '            if ((flags & FLAG_BORROW_USDC) > 0) {\n', '                uint256 usdcBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\n', '                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n', '                require(usdcBalance < (2 ** 32) * TOKEN_USDC_MULTIPLIER && usdcBalance > uint256(cachedBankState.usdcBalance) * TOKEN_USDC_MULTIPLIER);\n', '                cachedBankState.usdcBalance = uint32(usdcBalance / TOKEN_USDC_MULTIPLIER);\n', '            }\n', '            if ((flags & FLAG_BORROW_USDT) > 0) {\n', '                uint256 usdtBalance = IERC20Token(TOKEN_USDT).balanceOf(address(this));\n', '                // We use strict comparison here to make sure that token transfers always cost 5k gas and not (20k - 15k)\n', '                require(usdtBalance < (2 ** 32) * TOKEN_USDT_MULTIPLIER && usdtBalance > uint256(cachedBankState.usdtBalance) * TOKEN_USDT_MULTIPLIER);\n', '                cachedBankState.usdtBalance = uint32(usdtBalance / TOKEN_USDT_MULTIPLIER);\n', '            }\n', '        }\n', '\n', '        require(cachedBankState.numCalls == state.numCalls);\n', '        cachedBankState.numCalls += 1;\n', '        state = cachedBankState;\n', '    }\n', '\n', "    // Logic related to native gas refunds, it's very short but brainfuck level ugly\n", '    function generateContracts(uint256 amount) external {\n', '        Types.BankState memory cachedState = state;\n', '        uint256 offset = cachedState.totalContractsCreated;\n', '        assembly {\n', '            mstore(callvalue(), 0x766f454a11ca3a574738c0aab442b62d5d453318585733FF60005260176009f3)\n', '            for {let i := div(amount, 32)} i {i := sub(i, 1)} {\n', '                pop(create2(callvalue(), callvalue(), 32, offset))          pop(create2(callvalue(), callvalue(), 32, add(offset, 1)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 2)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 3)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 4)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 5)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 6)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 7)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 8)))  pop(create2(callvalue(), callvalue(), 32, add(offset, 9)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 10))) pop(create2(callvalue(), callvalue(), 32, add(offset, 11)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 12))) pop(create2(callvalue(), callvalue(), 32, add(offset, 13)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 14))) pop(create2(callvalue(), callvalue(), 32, add(offset, 15)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 16))) pop(create2(callvalue(), callvalue(), 32, add(offset, 17)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 18))) pop(create2(callvalue(), callvalue(), 32, add(offset, 19)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 20))) pop(create2(callvalue(), callvalue(), 32, add(offset, 21)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 22))) pop(create2(callvalue(), callvalue(), 32, add(offset, 23)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 24))) pop(create2(callvalue(), callvalue(), 32, add(offset, 25)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 26))) pop(create2(callvalue(), callvalue(), 32, add(offset, 27)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 28))) pop(create2(callvalue(), callvalue(), 32, add(offset, 29)))\n', '                pop(create2(callvalue(), callvalue(), 32, add(offset, 30))) pop(create2(callvalue(), callvalue(), 32, add(offset, 31)))\n', '                offset := add(offset, 32)\n', '            }\n', '\n', '            for {let i := and(amount, 0x1F)} i {i := sub(i, 1)} {\n', '                pop(create2(callvalue(), callvalue(), 32, offset))\n', '                offset := add(offset, 1)\n', '            }\n', '        }\n', '\n', '        require(cachedState.numCalls == state.numCalls && offset < 2 ** 32);\n', '        cachedState.totalContractsCreated = uint32(offset);\n', '        cachedState.numCalls += 1;\n', '        state = cachedState;\n', '    }\n', '    function _destroyContracts(uint256 firstSlot, uint256 lastSlot) internal {\n', '        assembly {\n', '            let i := firstSlot\n', '\n', '            let data := mload(0x40)\n', '            mstore(data, 0xff00000000454a11ca3a574738c0aab442b62d5d450000000000000000000000)\n', '            mstore(add(data, 53), 0x51b94132314e7e963fa256338c05c5dd9c15d277c686d6750c3bc97835a1ed27)\n', '            let ptr := add(data, 21)\n', '            for { } lt(i, lastSlot) { i := add(i, 1) } {\n', '                mstore(ptr, i)\n', '                pop(call(gas(), keccak256(data, 85), 0, 0, 0, 0, 0))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IApeBot {\n', '    function smallApeCallback(bytes calldata data) external payable;\n', '    function largeApeCallback(\n', '        address sender,\n', '        uint wethToReturn,\n', '        uint wbtcToReturn,\n', '        uint daiToReturn,\n', '        uint usdcToReturn,\n', '        uint usdtToReturn,\n', '        bytes calldata data\n', '    ) external payable;\n', '    function callFunction(address sender, Types.AccountInfo memory accountInfo, bytes memory data) external;\n', '}\n', '\n', 'library Types {\n', '    struct BankState {\n', '        uint32 wethBalance;\n', '        uint32 wbtcBalance;\n', '        uint32 daiBalance;\n', '        uint32 usdcBalance;\n', '        uint32 usdtBalance;\n', '        uint32 firstContractToDestroy;\n', '        uint32 totalContractsCreated;\n', '        uint32 numCalls;\n', '    }\n', '    struct GasTokenPrices {\n', '        uint80 priceGST2;\n', '        uint80 priceCHI;\n', '        uint80 priceNative;\n', '    }\n', '    struct AccountInfo {\n', '        address owner;\n', '        uint256 number;\n', '    }\n', '}\n', '\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// Only relevant calls in interfaces below\n', 'interface IERC20Token {\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '}\n', 'interface WETH9 {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', 'interface IGasToken {\n', '    function free(uint256 value) external returns (uint256);\n', '}']