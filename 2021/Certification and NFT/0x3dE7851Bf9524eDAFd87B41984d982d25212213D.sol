['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-07\n', '*/\n', '\n', '// Sources flattened with hardhat v2.0.11 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts/utils/[email\xa0protected]\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/access/[email\xa0protected]\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/BalanceAggregator.sol\n', '\n', '// SPDX-License-Identifier: LGPL-3.0-only\n', 'pragma solidity >=0.8.0;\n', '\n', 'contract Enum {\n', '    enum Operation {\n', '        Call, DelegateCall\n', '    }\n', '}\n', '\n', 'interface IAdapter {\n', '    function getBalance(\n', '        address token,\n', '        address account\n', '    )\n', '        external\n', '        view\n', '        returns(\n', '            uint256\n', '        );\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(\n', '        address _owner\n', '    )\n', '        external\n', '        view\n', '        returns(\n', '            uint256 balance\n', '        );\n', '}\n', '\n', 'contract BalanceAggregator is Ownable{\n', '\n', '    event AddedAdapter(address owner);\n', '    event RemovedAdapter(address owner);\n', '\n', '    uint256 public adapterCount;\n', '    IERC20 public token;\n', '\n', '    address internal constant SENTINEL_ADAPTERS = address(0x1);\n', '\n', '    // Mapping of adapter contracts\n', '    mapping(address => address) internal adapters;\n', '\n', '    /// @param _adapters adapters that should be enabled immediately\n', '    constructor(\n', '        address _token,\n', '        address[] memory _adapters\n', '    ){\n', '        token = IERC20(_token);\n', '        setupAdapters(_adapters);\n', '    }\n', '\n', '    /// @dev Setup function sets initial storage of contract.\n', '    /// @param _adapters List of adapters.\n', '    function setupAdapters(\n', '        address[] memory _adapters\n', '    )\n', '        internal\n', '    {\n', '        // Initializing adapters.\n', '        address currentAdapter = SENTINEL_ADAPTERS;\n', '        for (uint256 i = 0; i < _adapters.length; i++) {\n', '            address adapter = _adapters[i];\n', '            require(adapter != address(0) && adapter != SENTINEL_ADAPTERS && adapter != address(this) && currentAdapter != adapter, "Adapter address cannot be null, the sentinel, or this contract.");\n', '            require(adapters[adapter] == address(0), " No duplicate adapters allowed.");\n', '            adapters[currentAdapter] = adapter;\n', '            currentAdapter = adapter;\n', '        }\n', '        adapters[currentAdapter] = SENTINEL_ADAPTERS;\n', '        adapterCount = _adapters.length;\n', '    }\n', '\n', '    /// @dev Allows to add a new adapter.\n', '    /// @notice Adds the adapter `adapter`.\n', '    /// @param adapter New adapter address.\n', '    function addAdapter(\n', '        address adapter\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(adapter != address(0) && adapter != SENTINEL_ADAPTERS && adapter != address(this), "Adapter address cannot be null, the sentinel, or this contract.");\n', '        require(adapters[adapter] == address(0), "No duplicate adapters allowed.");\n', '        adapters[adapter] = adapters[SENTINEL_ADAPTERS];\n', '        adapters[SENTINEL_ADAPTERS] = adapter;\n', '        adapterCount++;\n', '        emit AddedAdapter(adapter);\n', '    }\n', '\n', '    /// @dev Allows to remove an adapter.\n', '    /// @notice Removes the adapter `adapter`.\n', '    /// @param prevAdapter Adapter that pointed to the adapter to be removed in the linked list.\n', '    /// @param adapter Adapter address to be removed.\n', '    function removeAdapter(\n', '        address prevAdapter,\n', '        address adapter\n', '    )\n', '        public\n', '        onlyOwner\n', '    {\n', '        // Validate adapter address and check that it corresponds to adapter index.\n', '        require(adapter != address(0) && adapter != SENTINEL_ADAPTERS, "Adapter address cannot be null or the sentinel.");\n', '        require(adapters[prevAdapter] == adapter, "prevAdapter does not point to adapter.");\n', '        adapters[prevAdapter] = adapters[adapter];\n', '        adapters[adapter] = address(0);\n', '        adapterCount--;\n', '        emit RemovedAdapter(adapter);\n', '    }\n', '\n', '    /// @dev Returns array of adapters.\n', '    /// @return Array of adapters.\n', '    function getAdapters()\n', '        public\n', '        view\n', '        returns(\n', '            address[] memory\n', '        )\n', '    {\n', '        address[] memory array = new address[](adapterCount);\n', '\n', '        // populate return array\n', '        uint256 index = 0;\n', '        address currentAdapter = adapters[SENTINEL_ADAPTERS];\n', '        while (currentAdapter != SENTINEL_ADAPTERS) {\n', '            array[index] = currentAdapter;\n', '            currentAdapter = adapters[currentAdapter];\n', '            index++;\n', '        }\n', '        return array;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '        external\n', '        view\n', '        returns(\n', '            uint256 balance\n', '        )\n', '    {\n', '        address[] memory _adapters = getAdapters();\n', '        uint256 _balance = token.balanceOf(_owner);\n', '\n', '        for (uint i = 0; i < _adapters.length; i++){\n', '            IAdapter adapter = IAdapter(_adapters[i]);\n', '            uint adapterBalance = adapter.getBalance(address(token), _owner);\n', '            _balance = _balance + adapterBalance;\n', '        }\n', '        return _balance;\n', '    }\n', '}']