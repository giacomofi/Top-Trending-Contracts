['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-23\n', '*/\n', '\n', '// File: contracts/interfaces/IPriceModule.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.5.0 <0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IPriceModule\n', '{\n', '    function getUSDPrice(address ) external view returns(uint256);\n', '}\n', '\n', '// File: contracts/aps/APContract.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.5.0 <0.7.0;\n', '// pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', 'contract APContract\n', '{\n', '\n', '    address public yieldsterDAO;\n', '\n', '    address public yieldsterTreasury;\n', '\n', '    address public yieldsterGOD;\n', '\n', '    address public emergencyVault;\n', '\n', '    address public yieldsterExchange;\n', '\n', '    address public stringUtils;\n', '\n', '    address public whitelistModule;\n', '\n', '    address public whitelistManager;\n', '\n', '    address public proxyFactory;\n', '\n', '    address public priceModule;\n', '\n', '    address public platFormManagementFee;\n', '\n', '    address public profitManagementFee;\n', '\n', '    address public stockDeposit;\n', '\n', '    address public stockWithdraw;\n', '\n', '    address public safeMinter;\n', '\n', '    address public safeUtils;\n', '\n', '    address public oneInch;\n', '\n', '    struct Asset{\n', '        string name;\n', '        string symbol;\n', '        bool created;\n', '    }\n', '\n', '    struct Protocol{\n', '        string name;\n', '        string symbol;\n', '        bool created;\n', '    }\n', '\n', '    struct Vault {\n', '        mapping(address => bool) vaultAssets;\n', '        mapping(address => bool) vaultDepositAssets;\n', '        mapping(address => bool) vaultWithdrawalAssets;\n', '        mapping(address => bool) vaultEnabledStrategy;\n', '        address depositStrategy;\n', '        address withdrawStrategy;\n', '        address vaultAPSManager;\n', '        address vaultStrategyManager;\n', '        uint256[] whitelistGroup;\n', '        bool created;\n', '    }\n', '\n', '    struct VaultActiveStrategy {\n', '        mapping(address => bool) isActiveStrategy;\n', '        mapping(address => uint256) activeStrategyIndex;\n', '        address[] activeStrategyList;\n', '    }\n', '\n', '    struct Strategy{\n', '        string strategyName;\n', '        mapping(address => bool) strategyProtocols;\n', '        bool created;\n', '        address minter;\n', '        address executor;\n', '        address benefeciary;\n', '        uint256 managementFeePercentage;\n', '    }\n', '\n', '    struct SmartStrategy{\n', '        string smartStrategyName;\n', '        address minter;\n', '        address executor;\n', '        bool created;\n', ' \n', '    }\n', '\n', '    struct vaultActiveManagemetFee {\n', '        mapping(address => bool) isActiveManagementFee;\n', '        mapping(address => uint256) activeManagementFeeIndex;\n', '        address[] activeManagementFeeList;\n', '    }\n', '\n', '    event VaultCreation(address vaultAddress);\n', '\n', '    mapping(address => vaultActiveManagemetFee) managementFeeStrategies;\n', '\n', '    mapping(address => mapping(address => mapping(address => bool))) vaultStrategyEnabledProtocols;\n', '\n', '    mapping(address => VaultActiveStrategy) vaultActiveStrategies;\n', '    \n', '    mapping(address => Asset) assets;\n', '\n', '    mapping(address => Protocol) protocols;\n', '\n', '    mapping(address => Vault) vaults;\n', '\n', '    mapping(address => Strategy) strategies;\n', '\n', '    mapping(address => SmartStrategy) smartStrategies;\n', '\n', '    mapping(address => address) safeOwner;\n', '    \n', '    mapping(address => bool) APSManagers;\n', '\n', '    mapping(address => address) minterStrategyMap;\n', '\n', '    \n', '    constructor(\n', '        address _whitelistModule,\n', '        address _platformManagementFee,\n', '        address _profitManagementFee,\n', '        address _stringUtils,\n', '        address _yieldsterExchange,\n', '        address _oneInch,\n', '        address _priceModule,\n', '        address _safeUtils\n', '    ) \n', '    public\n', '    {\n', '        yieldsterDAO = msg.sender;\n', '        yieldsterTreasury = msg.sender;\n', '        yieldsterGOD = msg.sender;\n', '        emergencyVault = msg.sender;\n', '        APSManagers[msg.sender] = true;\n', '        whitelistModule = _whitelistModule;\n', '        platFormManagementFee = _platformManagementFee;\n', '        stringUtils = _stringUtils;\n', '        yieldsterExchange = _yieldsterExchange;\n', '        oneInch = _oneInch;\n', '        priceModule = _priceModule;\n', '        safeUtils = _safeUtils;\n', '        profitManagementFee = _profitManagementFee;\n', '    }\n', '\n', '    /// @dev Function to add proxy Factory address to Yieldster.\n', '    /// @param _proxyFactory Address of proxy factory.\n', '    function addProxyFactory(address _proxyFactory)\n', '        public\n', '        onlyManager\n', '    {\n', '        proxyFactory = _proxyFactory;\n', '    }\n', '\n', '    function setProfitAndPlatformManagementFeeStrategies(address _platformManagement,address _profitManagement)\n', '        public\n', '        onlyYieldsterDAO\n', '    {\n', '        if (_profitManagement != address(0)) profitManagementFee = _profitManagement;\n', '        if (_platformManagement != address(0)) platFormManagementFee = _platformManagement;\n', '    }\n', '\n', '//Modifiers\n', '    modifier onlyYieldsterDAO{\n', '        require(yieldsterDAO == msg.sender, "Only Yieldster DAO is allowed to perform this operation");\n', '        _;\n', '    }\n', '\n', '    modifier onlyManager{\n', '        require(APSManagers[msg.sender], "Only APS managers allowed to perform this operation!");\n', '        _;\n', '    }\n', '\n', '    modifier onlySafeOwner{\n', '        require(safeOwner[msg.sender] == tx.origin, "Only safe Owner can perform this operation");\n', '        _;\n', '    }\n', '\n', '\n', '    function isVault( address _address) public view returns(bool){\n', '       return vaults[_address].created;\n', '    }\n', '\n', '\n', '    /// @dev Function to add APS manager to Yieldster.\n', '    /// @param _manager Address of the manager.\n', '    function addManager(address _manager) \n', '        public\n', '        onlyYieldsterDAO\n', '    {\n', '        APSManagers[_manager] = true;\n', '    }\n', '\n', '    /// @dev Function to remove APS manager from Yieldster.\n', '    /// @param _manager Address of the manager.\n', '    function removeManager(address _manager)\n', '        public\n', '        onlyYieldsterDAO\n', '    {\n', '        APSManagers[_manager] = false;\n', '    } \n', '\n', '    /// @dev Function to change whitelist Manager.\n', '    /// @param _whitelistManager Address of the whitelist manager.\n', '    function changeWhitelistManager(address _whitelistManager)\n', '        public\n', '        onlyYieldsterDAO\n', '    {\n', '        whitelistManager = _whitelistManager;\n', '    }\n', '\n', '    /// @dev Function to set Yieldster GOD.\n', '    /// @param _yieldsterGOD Address of the Yieldster GOD.\n', '    function setYieldsterGOD(address _yieldsterGOD)\n', '        public\n', '    {\n', '        require(msg.sender == yieldsterGOD, "Only Yieldster GOD can perform this operation");\n', '        yieldsterGOD = _yieldsterGOD;\n', '    }\n', '\n', '    /// @dev Function to disable Yieldster GOD.\n', '    function disableYieldsterGOD()\n', '        public\n', '    {\n', '        require(msg.sender == yieldsterGOD, "Only Yieldster GOD can perform this operation");\n', '        yieldsterGOD = address(0);\n', '    }\n', '\n', '    /// @dev Function to set Emergency vault.\n', '    /// @param _emergencyVault Address of the Yieldster Emergency vault.\n', '    function setEmergencyVault(address _emergencyVault)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        emergencyVault = _emergencyVault;\n', '    }\n', '\n', '\n', '    /// @dev Function to set Safe Minter.\n', '    /// @param _safeMinter Address of the Safe Minter.\n', '    function setSafeMinter(address _safeMinter)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        safeMinter = _safeMinter;\n', '    }\n', '\n', '    /// @dev Function to set safeUtils contract.\n', '    /// @param _safeUtils Address of the safeUtils contract.\n', '    function setSafeUtils(address _safeUtils)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        safeUtils = _safeUtils;\n', '    }\n', '\n', '    /// @dev Function to set oneInch address.\n', '    /// @param _oneInch Address of the oneInch.\n', '    function setOneInch(address _oneInch)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        oneInch = _oneInch;\n', '    }\n', '\n', '    /// @dev Function to get strategy address from minter.\n', '    /// @param _minter Address of the minter.\n', '    function getStrategyFromMinter(address _minter) \n', '        external \n', '        view \n', '        returns(address)\n', '    {\n', '       return minterStrategyMap[_minter];\n', '\n', '    }\n', '\n', '    /// @dev Function to set Yieldster Exchange.\n', '    /// @param _yieldsterExchange Address of the Yieldster exchange.\n', '    function setYieldsterExchange(address _yieldsterExchange)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        yieldsterExchange = _yieldsterExchange;\n', '    }\n', '\n', '    /// @dev Function to set stock Deposit and Withdraw.\n', '    /// @param _stockDeposit Address of the stock deposit contract.\n', '    /// @param _stockWithdraw Address of the stock withdraw contract.\n', '    function setStockDepositWithdraw(address _stockDeposit, address _stockWithdraw)\n', '        onlyYieldsterDAO\n', '        public\n', '    {\n', '        stockDeposit = _stockDeposit;\n', '        stockWithdraw = _stockWithdraw;\n', '    }\n', '\n', '\n', '    /// @dev Function to change the APS Manager for a vault.\n', '    /// @param _vaultAPSManager Address of the new APS Manager.\n', '    function changeVaultAPSManager(address _vaultAPSManager)\n', '        external\n', '    {\n', '        require(vaults[msg.sender].created, "Vault is not present");\n', '        vaults[msg.sender].vaultAPSManager = _vaultAPSManager;\n', '    }\n', '\n', '    /// @dev Function to change the Strategy Manager for a vault.\n', '    /// @param _vaultStrategyManager Address of the new Strategy Manager.\n', '    function changeVaultStrategyManager(address _vaultStrategyManager)\n', '        external\n', '    {\n', '        require(vaults[msg.sender].created, "Vault is not present");\n', '        vaults[msg.sender].vaultStrategyManager = _vaultStrategyManager;\n', '    }\n', '\n', '//Price Module\n', '    /// @dev Function to set Yieldster price module.\n', '    /// @param _priceModule Address of the price module.\n', '    function setPriceModule(address _priceModule)\n', '        public\n', '        onlyManager\n', '    {\n', '        priceModule = _priceModule;\n', '    }\n', '\n', '    /// @dev Function to get the USD price for a token.\n', '    /// @param _tokenAddress Address of the token.\n', '    function getUSDPrice(address _tokenAddress) \n', '        public \n', '        view\n', '        returns(uint256)\n', '    {\n', '        require(_isAssetPresent(_tokenAddress),"Asset not present!");\n', '        return IPriceModule(priceModule).getUSDPrice(_tokenAddress);\n', '    }\n', '\n', '\n', '//Vaults\n', '    /// @dev Function to create a vault.\n', '    /// @param _owner Address of the owner of the vault.\n', '    /// @param _vaultAddress Address of the new vault.\n', '    function createVault(address _owner, address _vaultAddress)\n', '    public\n', '    {\n', '        require(msg.sender == proxyFactory, "Only Proxy Factory can perform this operation");\n', '        safeOwner[_vaultAddress] = _owner;\n', '    }\n', '\n', '\n', '    /// @dev Function to add a vault in the APS.\n', '    /// @param _vaultAPSManager Address of the vaults APS Manager.\n', '    /// @param _vaultStrategyManager Address of the vaults Strateg Manager.\n', '    /// @param _whitelistGroup List of whitelist groups applied to the vault.\n', '    /// @param _owner Address of the vault owner.\n', '    function addVault(\n', '        address _vaultAPSManager,\n', '        address _vaultStrategyManager,\n', '        uint256[] memory _whitelistGroup,\n', '        address _owner\n', '    )\n', '    public\n', '    {   \n', '        require(safeOwner[msg.sender] == _owner, "Only owner can call this function");\n', '        Vault memory newVault = Vault(\n', '            {\n', '            vaultAPSManager : _vaultAPSManager, \n', '            vaultStrategyManager : _vaultStrategyManager,\n', '            whitelistGroup : _whitelistGroup,\n', '            depositStrategy: stockDeposit,\n', '            withdrawStrategy: stockWithdraw,\n', '            created : true\n', '            });\n', '        vaults[msg.sender] = newVault;\n', '\n', '        //applying Platform management fee\n', '        managementFeeStrategies[msg.sender].isActiveManagementFee[platFormManagementFee] = true;\n', '        managementFeeStrategies[msg.sender].activeManagementFeeIndex[platFormManagementFee] = managementFeeStrategies[msg.sender].activeManagementFeeList.length;\n', '        managementFeeStrategies[msg.sender].activeManagementFeeList.push(platFormManagementFee);\n', '\n', '        //applying Profit management fee\n', '        managementFeeStrategies[msg.sender].isActiveManagementFee[profitManagementFee] = true;\n', '        managementFeeStrategies[msg.sender].activeManagementFeeIndex[profitManagementFee] = managementFeeStrategies[msg.sender].activeManagementFeeList.length;\n', '        managementFeeStrategies[msg.sender].activeManagementFeeList.push(profitManagementFee);\n', '    }\n', '\n', '    /// @dev Function to Manage the vault assets.\n', '    /// @param _enabledDepositAsset List of deposit assets to be enabled in the vault.\n', '    /// @param _enabledWithdrawalAsset List of withdrawal assets to be enabled in the vault.\n', '    /// @param _disabledDepositAsset List of deposit assets to be disabled in the vault.\n', '    /// @param _disabledWithdrawalAsset List of withdrawal assets to be disabled in the vault.\n', '    function setVaultAssets(\n', '        address[] memory _enabledDepositAsset,\n', '        address[] memory _enabledWithdrawalAsset,\n', '        address[] memory _disabledDepositAsset,\n', '        address[] memory _disabledWithdrawalAsset\n', '    )\n', '    public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '\n', '        for (uint256 i = 0; i < _enabledDepositAsset.length; i++) {\n', '            address asset = _enabledDepositAsset[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = true;\n', '            vaults[msg.sender].vaultDepositAssets[asset] = true;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _enabledWithdrawalAsset.length; i++) {\n', '            address asset = _enabledWithdrawalAsset[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = true;\n', '            vaults[msg.sender].vaultWithdrawalAssets[asset] = true;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _disabledDepositAsset.length; i++) {\n', '            address asset = _disabledDepositAsset[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = false;\n', '            vaults[msg.sender].vaultDepositAssets[asset] = false;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _disabledWithdrawalAsset.length; i++) {\n', '            address asset = _disabledWithdrawalAsset[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = false;\n', '            vaults[msg.sender].vaultWithdrawalAssets[asset] = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Function to get the list of management fee strategies applied to the vault.\n', '    function getVaultManagementFee()\n', '        public\n', '        view\n', '        returns(address[] memory)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        return managementFeeStrategies[msg.sender].activeManagementFeeList;\n', '    }\n', '\n', '    /// @dev Function to get the deposit strategy applied to the vault.\n', '    function getDepositStrategy()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        return vaults[msg.sender].depositStrategy;\n', '    }\n', '\n', '    /// @dev Function to get the withdrawal strategy applied to the vault.\n', '    function getWithdrawStrategy()\n', '        public\n', '        view\n', '        returns(address)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        return vaults[msg.sender].withdrawStrategy;\n', '    }\n', '\n', '    /// @dev Function to set the management fee strategies applied to a vault.\n', '    /// @param _vaultAddress Address of the vault.\n', '    /// @param _managementFeeAddress Address of the management fee strategy.\n', '    function setManagementFeeStrategies(address _vaultAddress, address _managementFeeAddress)\n', '        public\n', '    {\n', '        require(vaults[_vaultAddress].created, "Vault not present");\n', '        require(vaults[_vaultAddress].vaultStrategyManager == msg.sender, "Sender not Authorized");\n', '        managementFeeStrategies[_vaultAddress].isActiveManagementFee[_managementFeeAddress] = true;\n', '        managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[_managementFeeAddress] = managementFeeStrategies[_vaultAddress].activeManagementFeeList.length;\n', '        managementFeeStrategies[_vaultAddress].activeManagementFeeList.push(_managementFeeAddress);\n', '    }\n', '\n', '    /// @dev Function to deactivate a vault strategy.\n', '    /// @param _managementFeeAddress Address of the Management Fee Strategy.\n', '    function removeManagementFeeStrategies(address _vaultAddress, address _managementFeeAddress)\n', '        public\n', '    {\n', '        require(vaults[_vaultAddress].created, "Vault not present");\n', '        require(managementFeeStrategies[_vaultAddress].isActiveManagementFee[_managementFeeAddress], "Provided ManagementFee is not active");\n', '        require(vaults[_vaultAddress].vaultStrategyManager == msg.sender || yieldsterDAO == msg.sender, "Sender not Authorized");\n', '        require(platFormManagementFee != _managementFeeAddress || yieldsterDAO == msg.sender,"Platfrom Management only changable by dao!");\n', '        managementFeeStrategies[_vaultAddress].isActiveManagementFee[_managementFeeAddress] = false;\n', '\n', '        if(managementFeeStrategies[_vaultAddress].activeManagementFeeList.length == 1) {\n', '            managementFeeStrategies[_vaultAddress].activeManagementFeeList.pop();\n', '        } else {\n', '            uint256 index = managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[_managementFeeAddress];\n', '            uint256 lastIndex = managementFeeStrategies[_vaultAddress].activeManagementFeeList.length - 1;\n', '            delete managementFeeStrategies[_vaultAddress].activeManagementFeeList[index];\n', '            managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[managementFeeStrategies[_vaultAddress].activeManagementFeeList[lastIndex]] = index;\n', '            managementFeeStrategies[_vaultAddress].activeManagementFeeList[index] = managementFeeStrategies[_vaultAddress].activeManagementFeeList[lastIndex];\n', '            managementFeeStrategies[_vaultAddress].activeManagementFeeList.pop();\n', '        }\n', '    }\n', '\n', '    /// @dev Function to set vault active strategy.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    function setVaultActiveStrategy(address _strategyAddress)\n', '        public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        require(strategies[_strategyAddress].created, "Strategy not present");\n', '        vaultActiveStrategies[msg.sender].isActiveStrategy[_strategyAddress] = true;\n', '        vaultActiveStrategies[msg.sender].activeStrategyIndex[_strategyAddress] = vaultActiveStrategies[msg.sender].activeStrategyList.length;\n', '        vaultActiveStrategies[msg.sender].activeStrategyList.push(_strategyAddress);\n', '    }\n', '\n', '    /// @dev Function to deactivate a vault strategy.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    function deactivateVaultStrategy(address _strategyAddress)\n', '        public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        require(vaultActiveStrategies[msg.sender].isActiveStrategy[_strategyAddress], "Provided strategy is not active");\n', '        vaultActiveStrategies[msg.sender].isActiveStrategy[_strategyAddress] = false;\n', '\n', '        if(vaultActiveStrategies[msg.sender].activeStrategyList.length == 1) {\n', '            vaultActiveStrategies[msg.sender].activeStrategyList.pop();\n', '        } else {\n', '            uint256 index = vaultActiveStrategies[msg.sender].activeStrategyIndex[_strategyAddress];\n', '            uint256 lastIndex = vaultActiveStrategies[msg.sender].activeStrategyList.length - 1;\n', '            delete vaultActiveStrategies[msg.sender].activeStrategyList[index];\n', '            vaultActiveStrategies[msg.sender].activeStrategyIndex[vaultActiveStrategies[msg.sender].activeStrategyList[lastIndex]] = index;\n', '            vaultActiveStrategies[msg.sender].activeStrategyList[index] = vaultActiveStrategies[msg.sender].activeStrategyList[lastIndex];\n', '            vaultActiveStrategies[msg.sender].activeStrategyList.pop();\n', '        }\n', '    }\n', '\n', '    /// @dev Function to get vault active strategy.\n', '    function getVaultActiveStrategy(address _vaultAddress)\n', '        public\n', '        view\n', '        returns(address[] memory)\n', '    {\n', '        require(vaults[_vaultAddress].created, "Vault not present");\n', '        return vaultActiveStrategies[_vaultAddress].activeStrategyList;\n', '    }\n', '\n', '    function isStrategyActive(address _vaultAddress, address _strategyAddress)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        return vaultActiveStrategies[_vaultAddress].isActiveStrategy[_strategyAddress];\n', '    }\n', '\n', '    function getStrategyManagementDetails(address _vaultAddress, address _strategyAddress)\n', '        public\n', '        view\n', '        returns(address, uint256)\n', '    {\n', '        require(vaults[_vaultAddress].created, "Vault not present");\n', '        require(strategies[_strategyAddress].created, "Strategy not present");\n', '        require(vaultActiveStrategies[_vaultAddress].isActiveStrategy[_strategyAddress], "Strategy not Active");\n', '        return (strategies[_strategyAddress].benefeciary, strategies[_strategyAddress].managementFeePercentage);\n', '    }\n', '\n', '    /// @dev Function to Manage the vault strategies.\n', '    /// @param _vaultStrategy Address of the strategy.\n', '    /// @param _enabledStrategyProtocols List of protocols that are enabled in the strategy.\n', '    /// @param _disabledStrategyProtocols List of protocols that are disabled in the strategy.\n', '    /// @param _assetsToBeEnabled List of assets that have to be enabled along with the strategy.\n', '    function setVaultStrategyAndProtocol(\n', '        address _vaultStrategy,\n', '        address[] memory _enabledStrategyProtocols,\n', '        address[] memory _disabledStrategyProtocols,\n', '        address[] memory _assetsToBeEnabled\n', '    )\n', '    public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        require(strategies[_vaultStrategy].created, "Strategy not present");\n', '        vaults[msg.sender].vaultEnabledStrategy[_vaultStrategy] = true;\n', '\n', '        for (uint256 i = 0; i < _enabledStrategyProtocols.length; i++) {\n', '            address protocol = _enabledStrategyProtocols[i];\n', '            require(_isProtocolPresent(protocol), "Protocol not supported by Yieldster");\n', '            vaultStrategyEnabledProtocols[msg.sender][_vaultStrategy][protocol] = true;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _disabledStrategyProtocols.length; i++) {\n', '            address protocol = _disabledStrategyProtocols[i];\n', '            require(_isProtocolPresent(protocol), "Protocol not supported by Yieldster");\n', '            vaultStrategyEnabledProtocols[msg.sender][_vaultStrategy][protocol] = false;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _assetsToBeEnabled.length; i++) {\n', '            address asset = _assetsToBeEnabled[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = true;\n', '            vaults[msg.sender].vaultDepositAssets[asset] = true;\n', '            vaults[msg.sender].vaultWithdrawalAssets[asset] = true;\n', '        }\n', '\n', '    }\n', '\n', '    /// @dev Function to disable the vault strategies.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    /// @param _assetsToBeDisabled List of assets that have to be disabled along with the strategy.\n', '    function disableVaultStrategy(address _strategyAddress, address[] memory _assetsToBeDisabled)\n', '        public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        require(strategies[_strategyAddress].created, "Strategy not present");\n', '        require(vaults[msg.sender].vaultEnabledStrategy[_strategyAddress], "Strategy was not enabled");\n', '        vaults[msg.sender].vaultEnabledStrategy[_strategyAddress] = false;\n', '\n', '        for (uint256 i = 0; i < _assetsToBeDisabled.length; i++) {\n', '            address asset = _assetsToBeDisabled[i];\n', '            require(_isAssetPresent(asset), "Asset not supported by Yieldster");\n', '            vaults[msg.sender].vaultAssets[asset] = false;\n', '            vaults[msg.sender].vaultDepositAssets[asset] = false;\n', '            vaults[msg.sender].vaultWithdrawalAssets[asset] = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Function to set smart strategy applied to the vault.\n', '    /// @param _smartStrategyAddress Address of the smart strategy.\n', '    /// @param _type type of smart strategy(deposit or withdraw).\n', '    function setVaultSmartStrategy(address _smartStrategyAddress, uint256 _type)\n', '        public\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        require(_isSmartStrategyPresent(_smartStrategyAddress),"Smart Strategy not Supported by Yieldster");\n', '        if(_type == 1){\n', '            vaults[msg.sender].depositStrategy = _smartStrategyAddress;\n', '        }\n', '        else if(_type == 2){\n', '            vaults[msg.sender].withdrawStrategy = _smartStrategyAddress;\n', '        }\n', '        else{\n', '            revert("Invalid type provided");\n', '        }\n', '    }\n', '\n', '    /// @dev Function to check if a particular protocol is enabled in a strategy for a vault.\n', '    /// @param _vaultAddress Address of the vault.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    /// @param _protocolAddress Address of the protocol to check.\n', '    function _isStrategyProtocolEnabled(\n', '        address _vaultAddress, \n', '        address _strategyAddress, \n', '        address _protocolAddress\n', '    )\n', '    public\n', '    view\n', '    returns(bool)\n', '    {\n', '        if( vaults[_vaultAddress].created &&\n', '            strategies[_strategyAddress].created &&\n', '            protocols[_protocolAddress].created &&\n', '            vaults[_vaultAddress].vaultEnabledStrategy[_strategyAddress] &&\n', '            vaultStrategyEnabledProtocols[_vaultAddress][_strategyAddress][_protocolAddress]){\n', '            return true;\n', '        }\n', '        else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev Function to check if a strategy is enabled for the vault.\n', '    /// @param _vaultAddress Address of the vault.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    function _isStrategyEnabled(\n', '        address _vaultAddress, \n', '        address _strategyAddress\n', '    )\n', '    public\n', '    view\n', '    returns(bool)\n', '    {\n', '        if(vaults[_vaultAddress].created &&\n', '            strategies[_strategyAddress].created &&\n', '            vaults[_vaultAddress].vaultEnabledStrategy[_strategyAddress]){\n', '            return true;\n', '        }\n', '        else{\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /// @dev Function to check if the asset is supported by the vault.\n', '    /// @param cleanUpAsset Address of the asset.\n', '    function _isVaultAsset(address cleanUpAsset)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault is not present");\n', '        return vaults[msg.sender].vaultAssets[cleanUpAsset];\n', '\n', '    }\n', '       \n', '\n', '// Assets\n', '    /// @dev Function to check if an asset is supported by Yieldster.\n', '    /// @param _address Address of the asset.\n', '    function _isAssetPresent(address _address) \n', '        private \n', '        view \n', '        returns(bool)\n', '    {\n', '        return assets[_address].created;\n', '    }\n', '    \n', '    /// @dev Function to add an asset to the Yieldster.\n', '    /// @param _symbol Symbol of the asset.\n', '    /// @param _name Name of the asset.\n', '    /// @param _tokenAddress Address of the asset.\n', '    function addAsset(\n', '        string memory _symbol, \n', '        string memory _name,\n', '        address _tokenAddress\n', '        ) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(!_isAssetPresent(_tokenAddress),"Asset already present!");\n', '        Asset memory newAsset = Asset({name:_name, symbol:_symbol, created:true});\n', '        assets[_tokenAddress] = newAsset;\n', '    }\n', '\n', '    /// @dev Function to remove an asset from the Yieldster.\n', '    /// @param _tokenAddress Address of the asset.\n', '    function removeAsset(address _tokenAddress) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(_isAssetPresent(_tokenAddress),"Asset not present!");\n', '        delete assets[_tokenAddress];\n', '    }\n', '    \n', '    /// @dev Function to check if an asset is supported deposit asset in the vault.\n', '    /// @param _assetAddress Address of the asset.\n', '    function isDepositAsset(address _assetAddress)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        return vaults[msg.sender].vaultDepositAssets[_assetAddress];\n', '    }\n', '\n', '    /// @dev Function to check if an asset is supported withdrawal asset in the vault.\n', '    /// @param _assetAddress Address of the asset.\n', '    function isWithdrawalAsset(address _assetAddress)\n', '        public\n', '        view\n', '        returns(bool)\n', '    {\n', '        require(vaults[msg.sender].created, "Vault not present");\n', '        return vaults[msg.sender].vaultWithdrawalAssets[_assetAddress];\n', '    }\n', '\n', '//Strategies\n', '    /// @dev Function to check if a strategy is supported by Yieldster.\n', '    /// @param _address Address of the strategy.\n', '    function _isStrategyPresent(address _address) \n', '        private \n', '        view \n', '        returns(bool)\n', '    {\n', '        return strategies[_address].created;\n', '    }\n', '\n', '    /// @dev Function to add a strategy to Yieldster.\n', '    /// @param _strategyName Name of the strategy.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    /// @param _strategyAddress List of protocols present in the strategy.\n', '    /// @param _minter Address of strategy minter.\n', '    /// @param _executor Address of strategy executor.\n', '    function addStrategy(\n', '        string memory _strategyName,\n', '        address _strategyAddress,\n', '        address[] memory _strategyProtocols,\n', '        address _minter,\n', '        address _executor,\n', '        address _benefeciary,\n', '        uint256 _managementFeePercentage\n', '        ) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(!_isStrategyPresent(_strategyAddress),"Strategy already present!");\n', '        Strategy memory newStrategy = Strategy({ strategyName:_strategyName, created:true, minter:_minter, executor:_executor, benefeciary:_benefeciary, managementFeePercentage: _managementFeePercentage});\n', '        strategies[_strategyAddress] = newStrategy;\n', '        minterStrategyMap[_minter] = _strategyAddress;\n', '\n', '        for (uint256 i = 0; i < _strategyProtocols.length; i++) {\n', '            address protocol = _strategyProtocols[i];\n', '            require(_isProtocolPresent(protocol), "Protocol not supported by Yieldster");\n', '            strategies[_strategyAddress].strategyProtocols[protocol] = true;\n', '        }\n', '    }\n', '\n', '    /// @dev Function to remove a strategy from Yieldster.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    function removeStrategy(address _strategyAddress) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(_isStrategyPresent(_strategyAddress),"Strategy not present!");\n', '        delete strategies[_strategyAddress];\n', '    }\n', '\n', '    /// @dev Function to get strategy executor address.\n', '    /// @param _strategy Address of the strategy.\n', '    function strategyExecutor(address _strategy) \n', '        external \n', '        view \n', '        returns(address)\n', '    {\n', '        return strategies[_strategy].executor;\n', '    }\n', '\n', '    /// @dev Function to change executor of strategy.\n', '    /// @param _strategyAddress Address of the strategy.\n', '    /// @param _executor Address of the executor.\n', '    function changeStrategyExecutor(address _strategyAddress, address _executor) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(_isStrategyPresent(_strategyAddress),"Strategy not present!");\n', '        strategies[_strategyAddress].executor = _executor;\n', '    }\n', '\n', '//Smart Strategy\n', '    /// @dev Function to check if a smart strategy is supported by Yieldster.\n', '    /// @param _address Address of the smart strategy.\n', '    function _isSmartStrategyPresent(address _address) \n', '        private \n', '        view \n', '        returns(bool)\n', '    {\n', '        return smartStrategies[_address].created;\n', '    }\n', '\n', '    /// @dev Function to add a smart strategy to Yieldster.\n', '    /// @param _smartStrategyName Name of the smart strategy.\n', '    /// @param _smartStrategyAddress Address of the smart strategy.\n', '    function addSmartStrategy(\n', '        string memory _smartStrategyName,\n', '        address _smartStrategyAddress,\n', '        address _minter,\n', '        address _executor\n', '        ) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(!_isSmartStrategyPresent(_smartStrategyAddress),"Smart Strategy already present!");\n', '        SmartStrategy memory newSmartStrategy = SmartStrategy\n', '            ({  smartStrategyName : _smartStrategyName,\n', '                minter : _minter,\n', '                executor : _executor,\n', '                created : true });\n', '        smartStrategies[_smartStrategyAddress] = newSmartStrategy;\n', '        minterStrategyMap[_minter] = _smartStrategyAddress;\n', '    }\n', '\n', '    /// @dev Function to remove a smart strategy from Yieldster.\n', '    /// @param _smartStrategyAddress Address of the smart strategy.\n', '    function removeSmartStrategy(address _smartStrategyAddress) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(!_isSmartStrategyPresent(_smartStrategyAddress),"Smart Strategy not present");\n', '        delete smartStrategies[_smartStrategyAddress];\n', '    }\n', '\n', '    /// @dev Function to get ssmart strategy executor address.\n', '    /// @param _smartStrategy Address of the strategy.\n', '    function smartStrategyExecutor(address _smartStrategy) \n', '        external \n', '        view \n', '        returns(address)\n', '    {\n', '        return smartStrategies[_smartStrategy].executor;\n', '    }\n', '\n', '    /// @dev Function to change executor of smart strategy.\n', '    /// @param _smartStrategy Address of the smart strategy.\n', '    /// @param _executor Address of the executor.\n', '    function changeSmartStrategyExecutor(address _smartStrategy, address _executor) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(_isSmartStrategyPresent(_smartStrategy),"Smart Strategy not present!");\n', '        smartStrategies[_smartStrategy].executor = _executor;\n', '    }\n', '\n', '// Protocols\n', '    /// @dev Function to check if a protocol is supported by Yieldster.\n', '    /// @param _address Address of the protocol.\n', '    function _isProtocolPresent(address _address) \n', '        private \n', '        view \n', '        returns(bool)\n', '    {\n', '        return protocols[_address].created;\n', '    }\n', '\n', '    /// @dev Function to add a protocol to Yieldster.\n', '    /// @param _symbol symbol of the protocol.\n', '    /// @param _name Name of the protocol.\n', '    /// @param _protocolAddress Address of the protocol.\n', '    function addProtocol(\n', '        string memory _symbol,\n', '        string memory _name,\n', '        address _protocolAddress\n', '        ) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(!_isProtocolPresent(_protocolAddress),"Protocol already present!");\n', '        Protocol memory newProtocol = Protocol({ name:_name, created:true, symbol:_symbol });\n', '        protocols[_protocolAddress] = newProtocol;\n', '    }\n', '\n', '    /// @dev Function to remove a protocol from Yieldster.\n', '    /// @param _protocolAddress Address of the protocol.\n', '    function removeProtocol(address _protocolAddress) \n', '        public \n', '        onlyManager\n', '    {\n', '        require(_isProtocolPresent(_protocolAddress),"Protocol not present!");\n', '        delete protocols[_protocolAddress];\n', '    }\n', '}']