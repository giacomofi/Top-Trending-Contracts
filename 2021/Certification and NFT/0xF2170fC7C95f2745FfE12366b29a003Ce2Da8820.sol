['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./CappedTimedCrowdsale.sol";\n', 'import "./RefundPostdevCrowdsale.sol";\n', '\n', '\n', '/**\n', '**  ICO Contract for the LBC crowdsale\n', '*/\n', 'contract HLBICO is CappedTimedCrowdsale, RefundablePostDeliveryCrowdsale {\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '    ** Global State\n', '    */\n', '    bool public initialized; // default : false\n', '\n', '    /*\n', '    ** Addresses\n', '    */\n', "    address public _deployingAddress; // should remain the same as deployer's address\n", '    address public _whitelistingAddress; // should be oracle\n', '    address public _reserveAddress; // should be deployer then humble reserve\n', '\n', '    /*\n', '    ** Events\n', '    */\n', '    event InitializedContract(address indexed changerAddress, address indexed whitelistingAddress);\n', '    event ChangedWhitelisterAddress(address indexed whitelisterAddress, address indexed changerAddress);\n', '    event ChangedReserveAddress(address indexed reserveAddress, address indexed changerAddress);\n', '    event ChangedDeployerAddress(address indexed deployerAddress, address indexed changerAddress);\n', '    event BlacklistedAdded(address indexed account);\n', '    event BlacklistedRemoved(address indexed account);\n', '    event UpdatedCaps(uint256 newGoal, uint256 newCap, uint256 newTranche, uint256 newMaxInvest, uint256 newRate, uint256 newRateCoef);\n', '\n', '    /*\n', '    ** Attrs\n', '    */\n', '    uint256 private _currentRate;\n', '    uint256 private _rateCoef;\n', '    mapping(address => bool) private _blacklistedAddrs;\n', '    mapping(address => uint256) private _investmentAddrs;\n', '    uint256 private _weiMaxInvest;\n', '    uint256 private _etherTranche;\n', '    uint256 private _currentWeiTranche; // Holds the current invested value for a tranche\n', '    uint256 private _deliverToReserve;\n', '    uint256 private _minimumInvest;\n', '\n', '    /*\n', '    * initialRateReceived : Number of token units a buyer gets per wei for the first investment slice. Should be 5000 (diving by 1000 for 3 decimals).\n', '    * walletReceived : Wallet that will get the invested eth at the end of the crowdsale\n', '    * tokenReceived : Address of the LBC token being sold\n', '    * openingTimeReceived : Starting date of the ICO\n', '    * closingtimeReceived : Ending date of the ICO\n', '    * capReceived : Max amount of wei to be contributed\n', '    * goalReceived : Funding goal\n', '    * etherMaxInvestReceived : Maximum ether that can be invested\n', '    */\n', '    constructor(uint256 initialRateReceived,\n', '        uint256 rateCoefficientReceived,\n', '        address payable walletReceived,\n', '        LBCToken tokenReceived,\n', '        uint256 openingTimeReceived,\n', '        uint256 closingTimeReceived,\n', '        uint256 capReceived,\n', '        uint256 goalReceived)\n', '        CrowdsaleMint(initialRateReceived, walletReceived, tokenReceived)\n', '        TimedCrowdsale(openingTimeReceived, closingTimeReceived)\n', '        CappedTimedCrowdsale(capReceived)\n', '        RefundableCrowdsale(goalReceived) {\n', '        _deployingAddress = msg.sender;\n', '        _etherTranche = 250000000000000000000; // 300000€; For eth = 1200 €\n', '        _weiMaxInvest = 8340000000000000000; // 10008€; for eth = 1200 €\n', '        _currentRate = initialRateReceived;\n', '        _rateCoef = rateCoefficientReceived;\n', '        _currentWeiTranche = 0;\n', '        _deliverToReserve = 0;\n', '        _minimumInvest = 1000000000000000; // 1.20€; for eth = 1200€\n', '    }\n', '\n', '    /*\n', '    ** Initializes the contract address and affects addresses to their roles.\n', '    */\n', '    function init(\n', '        address whitelistingAddress,\n', '        address reserveAddress\n', '    )\n', '    public\n', '    isNotInitialized\n', '    onlyDeployingAddress\n', '    {\n', '        require(whitelistingAddress != address(0), "HLBICO: whitelistingAddress cannot be 0x");\n', '        require(reserveAddress != address(0), "HLBICO: reserveAddress cannot be 0x");\n', '\n', '        _whitelistingAddress = whitelistingAddress;\n', '        _reserveAddress = reserveAddress;\n', '        initialized = true;\n', '\n', '        emit InitializedContract(_msgSender(), whitelistingAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the rate of tokens per wei at the present time and computes rate depending on tranche.\n', '     * @param weiAmount The value in wei to be converted into tokens\n', '     * @return The number of tokens a buyer gets per wei for a given tranche\n', '     */\n', '    function _getCustomAmount(uint256 weiAmount) internal returns (uint256) {\n', '        if (!isOpen()) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 calculatedAmount = 0;\n', '\n', '        _currentWeiTranche = _currentWeiTranche.add(weiAmount);\n', '\n', '        if (_currentWeiTranche > _etherTranche) {\n', '            _currentWeiTranche = _currentWeiTranche.sub(_etherTranche);\n', '\n', '            //If we updated the tranche manually to a smaller one\n', '            uint256 manualSkew = weiAmount.sub(_currentWeiTranche);\n', '\n', '            if (manualSkew >= 0) {\n', '                calculatedAmount = calculatedAmount.add(weiAmount.sub(_currentWeiTranche).mul(rate()));\n', '                _currentRate -= _rateCoef; // coefficient for 35 tokens reduction for each tranche\n', '                calculatedAmount = calculatedAmount.add(_currentWeiTranche.mul(rate()));\n', '            }\n', '            //If there is a skew between invested wei and calculated wei for a tranche\n', '            else {\n', '                _currentRate -= _rateCoef; // coefficient for 35 tokens reduction for each tranche\n', '                calculatedAmount = calculatedAmount.add(weiAmount.mul(rate()));\n', '            }\n', '        }\n', '        else\n', '            calculatedAmount = calculatedAmount.add(weiAmount.mul(rate()));\n', '\n', '        uint256 participationAmount = calculatedAmount.mul(5).div(100);\n', '\n', '        calculatedAmount = calculatedAmount.sub(participationAmount);\n', '        _deliverToReserve = _deliverToReserve.add(participationAmount);\n', '\n', '        return calculatedAmount;\n', '    }\n', '\n', '    /*\n', '    ** Adjusts all parameters influenced by Ether value based on a percentage coefficient\n', '    ** coef is based on 4 digits for decimal representation with 1 precision\n', '    ** i.e : 934 -> 93.4%; 1278 -> 127.8%\n', '    */\n', '    function adjustEtherValue(uint256 coef)\n', '    public\n', '    onlyDeployingAddress {\n', '        require(coef > 0 && coef < 10000, "HLBICO: coef isn\'t within range of authorized values");\n', '\n', '        uint256 baseCoef = 1000;\n', '\n', '        changeGoal(goal().mul(coef).div(1000));\n', '        changeCap(cap().mul(coef).div(1000));\n', '        _etherTranche = _etherTranche.mul(coef).div(1000);\n', '        _weiMaxInvest = _weiMaxInvest.mul(coef).div(1000);\n', '        \n', '        if (coef > 1000) {\n', '            coef = coef.sub(1000);\n', '            _currentRate = _currentRate.sub(_currentRate.mul(coef).div(1000));\n', '            _rateCoef = _rateCoef.sub(_rateCoef.mul(coef).div(1000));\n', '        } else {\n', '            coef = baseCoef.sub(coef);\n', '            _currentRate = _currentRate.add(_currentRate.mul(coef).div(1000));\n', '            _rateCoef = _rateCoef.add(_rateCoef.mul(coef).div(1000));\n', '        }\n', '\n', '        emit UpdatedCaps(goal(), cap(), _etherTranche, _weiMaxInvest, _currentRate, _rateCoef);\n', '    }\n', '\n', '    function rate() public view override returns (uint256) {\n', '       return _currentRate;\n', '    }\n', '\n', '    function getNextRate() public view returns (uint256) {\n', '        return _currentRate.sub(_rateCoef);\n', '    }\n', '\n', '    /*\n', '    ** Changes the address of the token contract. Must only be callable by deployer\n', '    */\n', '    function changeToken(LBCToken newToken)\n', '    public\n', '    onlyDeployingAddress\n', '    {\n', '        _changeToken(newToken);\n', '    }\n', '\n', '    /*\n', '    ** Changes the address with whitelisting role and can only be called by deployer\n', '    */\n', '    function changeWhitelister(address newWhitelisterAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    {\n', '        _whitelistingAddress = newWhitelisterAddress;\n', '        emit ChangedWhitelisterAddress(newWhitelisterAddress, _msgSender());\n', '    }\n', '    \n', '    /*\n', '    ** Changes the address with deployer role and can only be called by deployer\n', '    */\n', '    function changeDeployer(address newDeployerAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    {\n', '        _deployingAddress = newDeployerAddress;\n', '        emit ChangedDeployerAddress(_deployingAddress, _msgSender());\n', '    }\n', '\n', '    /*\n', '    ** Changes the address with pause role and can only be called by deployer\n', '    */\n', '    function changeReserveAddress(address newReserveAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    {\n', '        _reserveAddress = newReserveAddress;\n', '        emit ChangedReserveAddress(newReserveAddress, _msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Escrow finalization task, called when finalize() is called.\n', '     */\n', '    function _finalization() override virtual internal {\n', '        // Mints the 5% participation and sends it to humblereserve\n', '        if (goalReached()) {\n', '            _deliverTokens(_reserveAddress, _deliverToReserve);\n', '        }\n', '\n', '        super._finalization();\n', '    }\n', '\n', '    /*\n', '    ** Checks if an adress has been blacklisted before letting them withdraw their funds\n', '    */\n', '    function withdrawTokens(address beneficiary) override virtual public {\n', '        require(!isBlacklisted(beneficiary), "HLBICO: account is blacklisted");\n', '\n', '        super.withdrawTokens(beneficiary);\n', '    }\n', '\n', '    /**\n', '     * @dev Overrides parent method taking into account variable rate.\n', '     * @param weiAmount The value in wei to be converted into tokens\n', '     * @return The number of tokens _weiAmount wei will buy at present time\n', '     */\n', '    function _getTokenAmount(uint256 weiAmount) internal override returns (uint256) {\n', '       return _getCustomAmount(weiAmount);\n', '    }\n', '\n', '    function _forwardFunds() internal override(CrowdsaleMint, RefundablePostDeliveryCrowdsale) {\n', '        RefundablePostDeliveryCrowdsale._forwardFunds();\n', '    }\n', '\n', '    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal override(TimedCrowdsale, CappedTimedCrowdsale) view {\n', '        require(weiAmount >= _minimumInvest, "HLBICO: Investment must be greater than or equal to 0.001 eth");\n', '        _dontExceedAmount(beneficiary, weiAmount);\n', '        CappedTimedCrowdsale._preValidatePurchase(beneficiary, weiAmount);\n', '    }\n', '\n', '    function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal override {\n', '        require(beneficiary != address(0), "HLBICO: _postValidatePurchase benificiary is the zero address");\n', '\n', '        _investmentAddrs[beneficiary] = _investmentAddrs[beneficiary].add(weiAmount);        \n', '    }\n', '\n', '    function _processPurchase(address beneficiary, uint256 tokenAmount) internal override(CrowdsaleMint, RefundablePostDeliveryCrowdsale) {\n', '        RefundablePostDeliveryCrowdsale._processPurchase(beneficiary, tokenAmount);\n', '    }\n', '\n', '    function hasClosed() public view override(TimedCrowdsale, CappedTimedCrowdsale) returns (bool) {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        return CappedTimedCrowdsale.hasClosed();\n', '    }\n', '\n', '    function etherTranche() public view returns (uint256) {\n', '        return _etherTranche;\n', '    }\n', '\n', '    function maxInvest() public view returns (uint256) {\n', '        return _weiMaxInvest;\n', '    }\n', '\n', '    function addBlacklisted(address account) public onlyWhitelistingAddress {\n', '        _addBlacklisted(account);\n', '    }\n', '\n', '    function removeBlacklisted(address account) public onlyWhitelistingAddress {\n', '        _removeBlacklisted(account);\n', '    }\n', '\n', '    function isBlacklisted(address account) public view returns (bool) {\n', '        require(account != address(0), "HLBICO: account is zero address");\n', '        return _blacklistedAddrs[account];\n', '    }\n', '\n', '    function _addBlacklisted(address account) internal {\n', '        require(!isBlacklisted(account), "HLBICO: account already blacklisted");\n', '        _blacklistedAddrs[account] = true;\n', '        emit BlacklistedAdded(account);\n', '    }\n', '\n', '    function _removeBlacklisted(address account) internal {\n', '        require(isBlacklisted(account), "HLBICO: account is not blacklisted");\n', '        _blacklistedAddrs[account] = true;\n', '        emit BlacklistedRemoved(account);\n', '    }\n', '\n', '    function _dontExceedAmount(address beneficiary, uint256 weiAmount) internal view {\n', '        require(_investmentAddrs[beneficiary].add(weiAmount) <= _weiMaxInvest,\n', '          "HLBICO: Cannot invest more than KYC limit.");\n', '    }\n', '\n', '    modifier onlyWhitelistingAddress() {\n', '        require(_msgSender() == _whitelistingAddress, "HLBICO: caller does not have the Whitelisted role");\n', '        _;\n', '    }\n', '\n', '    /*\n', "    ** Checks if the contract hasn't already been initialized\n", '    */\n', '    modifier isNotInitialized() {\n', '        require(initialized == false, "HLBICO: contract is already initialized.");\n', '        _;\n', '    }\n', '\n', '    /*\n', '    ** Checks if the sender is the minter controller address\n', '    */\n', '    modifier onlyDeployingAddress() {\n', '        require(msg.sender == _deployingAddress, "HLBICO: only the deploying address can call this method.");\n', '        _;\n', '    }\n', '\n', '}']