['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "ERC721.sol";\n', 'import "Counters.sol";\n', 'import "Ownable.sol";\n', 'import "SafeMath.sol";\n', '\n', 'interface Randomized {\n', '    function CID_by_ID(uint256 token_ID) external view returns (bytes memory);\n', '}\n', '\n', 'contract Anonz is ERC721, Ownable {\n', "    uint256 MAX_ID = 7000; //7000 ANZ NFT's, not 6999, not 7001\n", '    bool lootery_active;\n', '    bool revealed;\n', '    Randomized contract_CID_randomized;\n', '    bytes internal constant _ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"; //just a kind reminder to our readers.\n', '    string contract_URI_shop;\n', '\n', '    using Counters for Counters.Counter;\n', '    Counters.Counter private _tokenIds;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    constructor() ERC721("ANZ", "Anonz") {\n', '        lootery_active=true;\n', '        revealed=false;\n', '        _setBaseURI("https://ipfs.io/ipfs/");\n', '        contract_URI_shop = "https://ipfs.io/ipfs/Qmbqp5hr2i3ug14V7EyR9PYjCSzKnQ272NyT4pTcqkTrGs";\n', '        }\n', '\n', '    function current_price() public view returns (uint256) {\n', '        uint256 current_ID = _tokenIds.current();\n', '        require(current_ID <= MAX_ID, "No more ANZ to mint");\n', '\n', '        //the "Carl" pricing function\n', '        if (current_ID >= 6300) {\n', '            return 100000000000000000;\n', '        } else if (current_ID >= 5600) {\n', '            return 260000000000000000;\n', '        } else if (current_ID >= 4900) {\n', '            return 390000000000000000;\n', '        } else if (current_ID >= 4200) {\n', '            return 640000000000000000;\n', '        } else if (current_ID >= 3500) {\n', '            return 900000000000000000;\n', '        } else if (current_ID >= 2100) {\n', '            return 640000000000000000;\n', '        } else if (current_ID >= 1400) {\n', '            return 390000000000000000;\n', '        } else if (current_ID >= 700) {\n', '            return 260000000000000000;\n', '        } else {\n', '            return 100000000000000000;\n', '        }\n', '    }\n', '\n', '    function mintNFT(address receiver, uint256 nb_nft) external payable {\n', '        require(nb_nft > 0, "cannot buy 0 ANZ");\n', '        require(nb_nft <= 40, "max 40 NFTs can be minted at a time");\n', '        require(current_price().mul(nb_nft) <= msg.value, "not enough ETH sent");\n', '        require(_tokenIds.current().add(nb_nft) <= MAX_ID, "not enought ANZ left to mint");\n', '\n', '        uint256 value_sent = msg.value;\n', '\n', '        for (uint i = 0; i < nb_nft; i++) {\n', '            require(value_sent >= current_price(), "not enough ETH sent for full tx"); //price changing in the middle of a lot?\n', '            value_sent = value_sent.sub(current_price());\n', '            _tokenIds.increment();\n', '            _mint(receiver, _tokenIds.current());\n', '        }\n', '    }\n', '\n', '    //set the contract where randomized URI are and prevent further change of it\n', '    function set_URI(address rand_contract) public onlyOwner {\n', '        require(revealed==false, "anonz already revealed, no more change allowed");\n', '        contract_CID_randomized = Randomized(rand_contract);\n', '        revealed=true;\n', '    }\n', '\n', '    function tokenURI(uint256 token_id) public view override returns (string memory) {\n', '        require(_exists(token_id), "This anonz has not been minted yet");\n', '        if (revealed == true){\n', '            bytes memory hash_bytes = contract_CID_randomized.CID_by_ID(token_id);\n', '            string memory hash = _toBase58(hash_bytes);\n', '            return string(abi.encodePacked(baseURI(), hash));\n', '        }\n', '        else {\n', '            return "https://ipfs.io/ipfs/QmThsKQpFBQicz3t3SU9rRz3GV81cwjnWsBBLxzznRNvpn";\n', '            //default URI before the Great Reveal Day - pinned\n', '        }\n', '    }\n', '\n', '    function setContractUriShop(string memory new_contract_uri) public onlyOwner {\n', '        contract_URI_shop = new_contract_uri;\n', '    }\n', '\n', '    function contractURI() public view returns (string memory) {\n', '        return contract_URI_shop;\n', '    }\n', '\n', '\n', '    function lootery(address payable winner1, address payable winner2) external onlyOwner {\n', '      require(lootery_active, "lootery is already finished");\n', '      uint256 reward = address(this).balance.div(20);\n', '      lootery_active = false;\n', '      winner1.transfer(reward); //onlyOwner and bool test, ergo no reentrance from winner1, right? ...right?!\n', '      winner2.transfer(reward);\n', '    }\n', '\n', '\n', '    function withdraw() onlyOwner public {\n', '      uint256 balance = address(this).balance;\n', '      msg.sender.transfer(balance);\n', '    }\n', '\n', '    //the _toBase58 consume a lot of gaz when called from another contract. Therefore, calling tokenURI from a contract might fail\n', '    //(no worries for us, view & pure functions are "free" for humans)\n', '\n', '    // Source: verifyIPFS (https://github.com/MrChico/verifyIPFS/blob/master/contracts/verifyIPFS.sol)\n', '    // @author Martin Lundfall ([email\xa0protected])\n', '    // @dev Converts hex string to base 58\n', '    function _toBase58(bytes memory source)\n', '        internal\n', '        pure\n', '        returns (string memory)\n', '    {\n', '        if (source.length == 0) return new string(0);\n', '        uint8[] memory digits = new uint8[](46);\n', '        digits[0] = 0;\n', '        uint8 digitlength = 1;\n', '        for (uint256 i = 0; i < source.length; ++i) {\n', '            uint256 carry = uint8(source[i]);\n', '            for (uint256 j = 0; j < digitlength; ++j) {\n', '                carry += uint256(digits[j]) * 256;\n', '                digits[j] = uint8(carry % 58);\n', '                carry = carry / 58;\n', '            }\n', '\n', '            while (carry > 0) {\n', '                digits[digitlength] = uint8(carry % 58);\n', '                digitlength++;\n', '                carry = carry / 58;\n', '            }\n', '        }\n', '        return string(_toAlphabet(_reverse(_truncate(digits, digitlength))));\n', '    }\n', '\n', '    function _truncate(uint8[] memory array, uint8 length)\n', '        internal\n', '        pure\n', '        returns (uint8[] memory)\n', '    {\n', '        uint8[] memory output = new uint8[](length);\n', '        for (uint256 i = 0; i < length; i++) {\n', '            output[i] = array[i];\n', '        }\n', '        return output;\n', '    }\n', '\n', '    function _reverse(uint8[] memory input)\n', '        internal\n', '        pure\n', '        returns (uint8[] memory)\n', '    {\n', '        uint8[] memory output = new uint8[](input.length);\n', '        for (uint256 i = 0; i < input.length; i++) {\n', '            output[i] = input[input.length - 1 - i];\n', '        }\n', '        return output;\n', '    }\n', '\n', '    function _toAlphabet(uint8[] memory indices)\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory output = new bytes(indices.length);\n', '        for (uint256 i = 0; i < indices.length; i++) {\n', '            output[i] = _ALPHABET[indices[i]];\n', '        }\n', '        return output;\n', '    }\n', '\n', '}']