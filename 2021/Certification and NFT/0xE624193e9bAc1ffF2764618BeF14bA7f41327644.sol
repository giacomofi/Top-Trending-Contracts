['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor () internal {\n', '\n', '        _notEntered = true;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '\n', '\n', 'interface IRewardsDistributionRecipient {\n', '    // function notifyRewardAmount(uint256 reward) external;\n', '    function getRewardToken() external view returns (IERC20);\n', '}\n', '\n', 'abstract contract RewardsDistributionRecipient is IRewardsDistributionRecipient {\n', '\n', '    // @abstract\n', '    // function notifyRewardAmount(uint256 reward) external;\n', '    function getRewardToken() external virtual override view returns (IERC20);\n', '\n', '    // This address has the ability to distribute the rewards\n', '    address public rewardsDistributor;\n', '\n', '    /** @dev Recipient is a module, governed by mStable governance */\n', '    constructor(address _rewardsDistributor)\n', '        internal\n', '    {\n', '        rewardsDistributor = _rewardsDistributor;\n', '    }\n', '\n', '    /**\n', '     * @dev Only the rewards distributor can notify about rewards\n', '     */\n', '    modifier onlyRewardsDistributor() {\n', '        require(msg.sender == rewardsDistributor, "Caller is not reward distributor");\n', '        _;\n', '    }\n', '}\n', '\n', 'library StableMath {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant FULL_SCALE = 1e18;\n', '\n', '    uint256 private constant RATIO_SCALE = 1e8;\n', '\n', '    function getFullScale() internal pure returns (uint256) {\n', '        return FULL_SCALE;\n', '    }\n', '\n', '    function getRatioScale() internal pure returns (uint256) {\n', '        return RATIO_SCALE;\n', '    }\n', '\n', '    function scaleInteger(uint256 x)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x.mul(FULL_SCALE);\n', '    }\n', '\n', '    function mulTruncate(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return mulTruncateScale(x, y, FULL_SCALE);\n', '    }\n', '\n', '    function mulTruncateScale(uint256 x, uint256 y, uint256 scale)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. assume scale = fullScale\n', '        // z = 10e18 * 9e17 = 9e36\n', '        uint256 z = x.mul(y);\n', '        // return 9e38 / 1e18 = 9e18\n', '        return z.div(scale);\n', '    }\n', '\n', '    function mulTruncateCeil(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. 8e17 * 17268172638 = 138145381104e17\n', '        uint256 scaled = x.mul(y);\n', '        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n', '        uint256 ceil = scaled.add(FULL_SCALE.sub(1));\n', '        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n', '        return ceil.div(FULL_SCALE);\n', '    }\n', '\n', '    function divPrecisely(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. 8e18 * 1e18 = 8e36\n', '        uint256 z = x.mul(FULL_SCALE);\n', '        // e.g. 8e36 / 10e18 = 8e17\n', '        return z.div(y);\n', '    }\n', '\n', '    function mulRatioTruncate(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        return mulTruncateScale(x, ratio, RATIO_SCALE);\n', '    }\n', '\n', '    function mulRatioTruncateCeil(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        // e.g. How much mAsset should I burn for this bAsset (x)?\n', '        // 1e18 * 1e8 = 1e26\n', '        uint256 scaled = x.mul(ratio);\n', '        // 1e26 + 9.99e7 = 100..00.999e8\n', '        uint256 ceil = scaled.add(RATIO_SCALE.sub(1));\n', '        // return 100..00.999e8 / 1e8 = 1e18\n', '        return ceil.div(RATIO_SCALE);\n', '    }\n', '\n', '    function divRatioPrecisely(uint256 x, uint256 ratio)\n', '        internal\n', '        pure\n', '        returns (uint256 c)\n', '    {\n', '        // e.g. 1e14 * 1e8 = 1e22\n', '        uint256 y = x.mul(RATIO_SCALE);\n', '        // return 1e22 / 1e12 = 1e10\n', '        return y.div(ratio);\n', '    }\n', '\n', '    function min(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > y ? y : x;\n', '    }\n', '\n', '    function max(uint256 x, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > y ? x : y;\n', '    }\n', '\n', '    function clamp(uint256 x, uint256 upperBound)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return x > upperBound ? upperBound : x;\n', '    }\n', '}\n', '\n', 'contract Kohai is IERC20, Context {\n', '\n', '    using StableMath for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '    IERC20 public token = IERC20(0x5a705745373a780814c379Ef17810630D529EFE0);\n', '    uint256 public lockRate = 2;\n', '    string private _symbol;\n', '    string private _name;\n', '    uint256 private _decimals = 18;\n', '    uint256 public cap = 42000000 * 1e18;\n', '    address _owner = msg.sender;\n', '\n', 'modifier onlyOwner(){\n', '    require(msg.sender == _owner);\n', '    _;\n', '}\n', '\n', '    constructor () public {\n', "        _name = 'Kohai';\n", "        _symbol = 'KOHAI';\n", '        _totalSupply = 100 * 1e18;\n', '        _balances[msg.sender] = _totalSupply;\n', '        emit Transfer(address(this), msg.sender, _totalSupply);\n', '    }\n', '\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '\n', '    function decimals() public view returns (uint256) {\n', '        return _decimals;\n', '    }\n', '\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '   \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(recipient != address(this), "ERC20: transfer to the contract address");\n', '        \n', '       \n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    address public owner;\n', '   \n', '    mapping(address => uint256) public lockingTimeStarts;\n', '    mapping(address => uint256) public lockingTimeEnds;\n', '    mapping(address => uint256) public lockedAmount;\n', '    // Amount the user has staked\n', '    \n', '    uint256 public totalLocked = 0;\n', '\n', '\n', '\n', '\n', '    event Locked(address indexed user, uint256 amount);\n', '\n', '    /***************************************\n', '                    MODIFIERS\n', '    ****************************************/\n', '\n', '    modifier isAccount(address _account) {\n', '        require(!Address.isContract(_account), "Only external owned accounts allowed");\n', '        _;\n', '    }\n', '   \n', '\n', '    /***************************************\n', '                    ACTIONS\n', '    ****************************************/\n', '   \n', '        /****************************\n', '                    LOCK\n', '        ****************************/\n', '   \n', '   \n', '    function lock(uint256 amount) external {\n', "        require(lockingTimeStarts[msg.sender] == 0, 'you have already locked your tokens');\n", '        token.transferFrom(msg.sender, address(this), amount);\n', '        lockingTimeStarts[msg.sender] = block.timestamp;\n', '        lockingTimeEnds[msg.sender] = block.timestamp + 2592000;\n', '        lockedAmount[msg.sender] = amount;\n', '        totalLocked = totalLocked.add(amount);\n', '        emit Locked(msg.sender, amount);\n', '    }\n', '    \n', '    function addLiquidity(uint256 amount) external {\n', "        require(lockedAmount[msg.sender] >= 0, 'you have not locked anything');\n", '        _harvest(msg.sender);\n', '        token.transferFrom(msg.sender, address(this), amount);\n', '        lockedAmount[msg.sender] = lockedAmount[msg.sender].add(amount);\n', '        lockingTimeStarts[msg.sender] = block.timestamp;\n', '        lockingTimeEnds[msg.sender] = block.timestamp + 2592000;\n', '        totalLocked = totalLocked.add(amount);\n', '        emit Locked(msg.sender, amount);\n', '    }\n', '   \n', '    function unlock() external{\n', "        require(lockedAmount[msg.sender] >= 0, 'you have not locked anything');\n", "        require (block.timestamp >= lockingTimeEnds[msg.sender], 'Locking time still remains');\n", '        token.transfer(msg.sender, lockedAmount[msg.sender]);\n', '        _harvest(msg.sender);\n', '        lockingTimeStarts[msg.sender] = 0;\n', '        lockingTimeEnds[msg.sender] = 0;\n', '        totalLocked = totalLocked.sub(lockedAmount[msg.sender]);\n', '        lockedAmount[msg.sender] = 0;\n', '    }\n', '    \n', '    function harvest() external{\n', '        _harvest(msg.sender);\n', '        lockingTimeStarts[msg.sender] = block.timestamp;\n', '        lockingTimeEnds[msg.sender] = block.timestamp + 2592000;\n', '    }\n', '   \n', '   \n', '    function _harvest(address sender) internal{\n', "        require(lockedAmount[sender] >= 0, 'you have not locked anything');\n", '        uint256 locktime = block.timestamp.sub(lockingTimeStarts[sender]);\n', '        uint256 reward = lockedAmount[sender].mul(lockRate).mul(locktime).div(2592000);\n', '        mint(sender, reward);\n', '    }\n', '    \n', '    function myReward(address sender) external view returns (uint256) {\n', "        require(lockedAmount[sender] >= 0, 'you have not locked anything');\n", '        uint256 locktime = block.timestamp.sub(lockingTimeStarts[sender]);\n', '        uint256 reward = lockedAmount[sender].mul(lockRate).mul(locktime).div(2592000);\n', '        return reward;\n', '    }\n', '    \n', '    function myLockedPeriod(address sender) external view returns (uint256) {\n', "        require(lockedAmount[sender] >= 0, 'you have not locked anything');\n", '        uint256 locktime = block.timestamp.sub(lockingTimeStarts[sender]);\n', '        return locktime;\n', '    }\n', '   \n', '\n', '   \n', '    \n', '\n', '\n', '\n', '    /***************************************\n', '                    ADMIN\n', '    ****************************************/\n', '   \n', '    function mint(address account, uint256 amount) internal virtual  {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '   \n', '    function burn(uint256 amount) external{\n', '        _burn(msg.sender, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _beforeTokenTransfer(address from, uint256 amount) internal view virtual {\n', '       \n', '                if (from == address(0)) { // When minting tokens\n', '            require(totalSupply().add(amount) <= cap, "ERC20Capped: cap exceeded");\n', '        }\n', '    }\n', '   \n', '   \n', '\n', '}']