['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-29\n', '*/\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', '// Deployment process:\n', '// deploy 2 proxies\n', '// deploy Dex, Oracle and TokenReserve\n', '// initConfigure Dex and TokenReserve\n', '// migrate data \n', '// remove all migration role members\n', '// contract is trading\n', '\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '//import "./HodlDex.sol";\n', '\n', 'interface IUniswap {\n', '    function getReserves() external view returns(uint112, uint112, uint32);\n', '}\n', '\n', 'interface IHodlDex {\n', '    function increaseTransactionCount(uint256 txnCount) external;\n', '}\n', '\n', 'interface IHOracle {\n', '   function read() external view returns(uint ethUsd18); \n', '}\n', '\n', 'contract HOracle is IHOracle, Ownable {\n', '    using SafeMath for uint; \n', '\n', '    bool called;\n', '    uint private _lastEOSTxnCount;\n', '\n', '    event TxnIncrease(uint indexed currentEOSTxnCount, uint indexed txnIncreaseAmount);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    IUniswap uniswap = IUniswap(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n', '    uint constant PRECISION = 10 ** 18;\n', '    uint constant UNISWAP_SHIFT = 10 ** 12;\n', '    \n', '\n', '    //switch to chainlink\n', '    function read() public view override returns(uint ethUsd18) {\n', '        (uint112 uniswapReserve0, uint112 uniswapReserve1, /*uint32 timeStamp*/) = uniswap.getReserves();\n', '        ethUsd18 = (uint(uniswapReserve0) * PRECISION * UNISWAP_SHIFT) / (uniswapReserve1);\n', '    }\n', '\n', '   \n', '    function getLastEOSTxnCount() external view returns(uint) {\n', '        return _lastEOSTxnCount;\n', '    }\n', '\n', '    function increaseTxnCount(uint currentEOSTxnCount) external onlyOwner returns(bool) {\n', '        require(!called, "waiting for the last call to finish");\n', '        called = true;\n', '        require(_lastEOSTxnCount < currentEOSTxnCount, "current txn count should be larger than last txn count");\n', '        uint txnIncreaseAmount = currentEOSTxnCount.sub(_lastEOSTxnCount);\n', '\n', '        (bool success,  ) = address(0xC310644A0Cf1cAE7E240A48090c3cdB9Edb53941).call{gas: 300000}(abi.encodeWithSignature("increaseTransactionCount(uint256)", txnIncreaseAmount));\n', '        //address(_hodlDexProxy).increaseTransactionCount(txnIncreaseAmount);\n', '        if(success) {\n', '            _lastEOSTxnCount = currentEOSTxnCount;\n', '            emit TxnIncrease(currentEOSTxnCount, txnIncreaseAmount);\n', '        }\n', '        called = false;\n', '        return success;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', 'library Bytes32Set {\n', '    \n', '    struct Set {\n', '        mapping(bytes32 => uint) keyPointers;\n', '        bytes32[] keyList;\n', '    }\n', '    \n', '    /**\n', '     * @notice insert a key. \n', '     * @dev duplicate keys are not permitted.\n', '     * @param self storage pointer to a Set. \n', '     * @param key value to insert.\n', '     */\n', '    function insert(Set storage self, bytes32 key) internal {\n', '        require(!exists(self, key), "Bytes32Set: key already exists in the set.");\n', '        self.keyPointers[key] = self.keyList.length;\n', '        self.keyList.push(key);\n', '    }\n', '\n', '    /**\n', '     * @notice remove a key.\n', '     * @dev key to remove must exist. \n', '     * @param self storage pointer to a Set.\n', '     * @param key value to remove.\n', '     */\n', '    function remove(Set storage self, bytes32 key) internal {\n', '        require(exists(self, key), "Bytes32Set: key does not exist in the set.");\n', '        uint last = count(self) - 1;\n', '        uint rowToReplace = self.keyPointers[key];\n', '        if(rowToReplace != last) {\n', '            bytes32 keyToMove = self.keyList[last];\n', '            self.keyPointers[keyToMove] = rowToReplace;\n', '            self.keyList[rowToReplace] = keyToMove;\n', '        }\n', '        delete self.keyPointers[key];\n', '        self.keyList.pop();\n', '    }\n', '\n', '    /**\n', '     * @notice count the keys.\n', '     * @param self storage pointer to a Set. \n', '     */    \n', '    function count(Set storage self) internal view returns(uint) {\n', '        return(self.keyList.length);\n', '    }\n', '    \n', '    /**\n', '     * @notice check if a key is in the Set.\n', '     * @param self storage pointer to a Set.\n', '     * @param key value to check. \n', '     * @return bool true: Set member, false: not a Set member.\n', '     */\n', '    function exists(Set storage self, bytes32 key) internal view returns(bool) {\n', '        if(self.keyList.length == 0) return false;\n', '        return self.keyList[self.keyPointers[key]] == key;\n', '    }\n', '\n', '    /**\n', '     * @notice fetch a key by row (enumerate).\n', '     * @param self storage pointer to a Set.\n', '     * @param index row to enumerate. Must be < count() - 1.\n', '     */    \n', '    function keyAtIndex(Set storage self, uint index) internal view returns(bytes32) {\n', '        return self.keyList[index];\n', '    }\n', '}\n', '\n', 'library FIFOSet {\n', '    \n', '    using Bytes32Set for Bytes32Set.Set;\n', '    \n', '    bytes32 constant NULL = bytes32(0);\n', '    \n', '    struct Set {\n', '        bytes32 firstKey;\n', '        bytes32 lastKey;\n', '        mapping(bytes32 => KeyStruct) keyStructs;\n', '        Bytes32Set.Set keySet;\n', '    }\n', '\n', '    struct KeyStruct {\n', '            bytes32 nextKey;\n', '            bytes32 previousKey;\n', '    }\n', '\n', '    function count(Set storage self) internal view returns(uint) {\n', '        return self.keySet.count();\n', '    }\n', '    \n', '    function first(Set storage self) internal view returns(bytes32) {\n', '        return self.firstKey;\n', '    }\n', '    \n', '    function last(Set storage self) internal view returns(bytes32) {\n', '        return self.lastKey;\n', '    }\n', '    \n', '    function exists(Set storage self, bytes32 key) internal view returns(bool) {\n', '        return self.keySet.exists(key);\n', '    }\n', '    \n', '    function isFirst(Set storage self, bytes32 key) internal view returns(bool) {\n', '        return key==self.firstKey;\n', '    }\n', '    \n', '    function isLast(Set storage self, bytes32 key) internal view returns(bool) {\n', '        return key==self.lastKey;\n', '    }    \n', '    \n', '    function previous(Set storage self, bytes32 key) internal view returns(bytes32) {\n', '        require(exists(self, key), "FIFOSet: key not found") ;\n', '        return self.keyStructs[key].previousKey;\n', '    }\n', '    \n', '    function next(Set storage self, bytes32 key) internal view returns(bytes32) {\n', '        require(exists(self, key), "FIFOSet: key not found");\n', '        return self.keyStructs[key].nextKey;\n', '    }\n', '    \n', '    function append(Set storage self, bytes32 key) internal {\n', '        require(key != NULL, "FIFOSet: key cannot be zero");\n', '        require(!exists(self, key), "FIFOSet: duplicate key"); \n', '        bytes32 lastKey = self.lastKey;\n', '        KeyStruct storage k = self.keyStructs[key];\n', '        KeyStruct storage l = self.keyStructs[lastKey];\n', '        if(lastKey==NULL) {                \n', '            self.firstKey = key;\n', '        } else {\n', '            l.nextKey = key;\n', '        }\n', '        k.previousKey = lastKey;\n', '        self.keySet.insert(key);\n', '        self.lastKey = key;\n', '    }\n', '\n', '    function remove(Set storage self, bytes32 key) internal {\n', '        require(exists(self, key), "FIFOSet: key not found");\n', '        KeyStruct storage k = self.keyStructs[key];\n', '        bytes32 keyBefore = k.previousKey;\n', '        bytes32 keyAfter = k.nextKey;\n', '        bytes32 firstKey = first(self);\n', '        bytes32 lastKey = last(self);\n', '        KeyStruct storage p = self.keyStructs[keyBefore];\n', '        KeyStruct storage n = self.keyStructs[keyAfter];\n', '        \n', '        if(count(self) == 1) {\n', '            self.firstKey = NULL;\n', '            self.lastKey = NULL;\n', '        } else {\n', '            if(key == firstKey) {\n', '                n.previousKey = NULL;\n', '                self.firstKey = keyAfter;  \n', '            } else \n', '            if(key == lastKey) {\n', '                p.nextKey = NULL;\n', '                self.lastKey = keyBefore;\n', '            } else {\n', '                p.nextKey = keyAfter;\n', '                n.previousKey = keyBefore;\n', '            }\n', '        }\n', '        self.keySet.remove(key);\n', '        delete self.keyStructs[key];\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '//import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', 'interface ProportionalInterface {\n', '    function circulatingSupply() external view returns(uint amount); \n', '}\n', '\n', 'library Proportional {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    uint constant PRECISION = 10 ** 18;\n', '    \n', '    struct System {\n', '        uint birthday;\n', '        uint periodicity;\n', '        address source;\n', '        bytes32 shareAsset;                 // The asset used to determine shares, e.g. use HODL shares to distribute Eth proportionally.\n', '        mapping(bytes32 => Asset) asset;\n', '    }\n', '    \n', '    struct Asset {\n', '        Distribution[] distributions;\n', '        mapping(address => User) users;\n', '    }\n', '    \n', '    struct Distribution {\n', '        uint denominator;                   // Usually the supply, used to calculate user shares, e.g. balance / circulating supply\n', '        uint amount;                        // The distribution amount. Accumulates allocations. Does not decrement with claims. \n', '        uint period;                        // Timestamp when the accounting period was closed. \n', '    }\n', '    \n', '    struct User {\n', '        UserBalance[] userBalances;\n', '        uint processingDistributionIndex;   // The next distribution of *this asset* to process for the user.\n', '        uint processingBalanceIndex;        // The *shareAsset* balance record to use to compute user shares for the next distribution.\n', '    }\n', '    \n', '    struct UserBalance {\n', '        uint balance;                       // Last observed user balance in an accounting period \n', '        uint controlled;                    // Additional funds controlled the the user, e.g. escrowed, time-locked, open sell orders \n', '        uint period;                        // The period observed\n', '    }\n', '    \n', '    bytes32 constant public ETH_ASSET = keccak256("Eth");\n', '\n', '    event IncreaseDistribution(address sender, bytes32 indexed assetId, uint period, uint amount);\n', '    event DistributionClosed(address sender, bytes32 indexed assetId, uint distributionAmount, uint denominator, uint closedPeriod, uint newPeriod);\n', '    event DistributionPaid(address indexed receiver, bytes32 indexed assetId, uint period, uint amount, uint balanceIndex, uint distributionIndex);\n', '    event UserBalanceIncreased(address indexed sender, bytes32 indexed assetId, uint period, address user, uint toBalance, uint toControlled);\n', '    event UserBalanceReduced(address indexed sender, bytes32 indexed assetId, uint period, address user, uint fromBalance, uint fromControlled);\n', '    event UserFastForward(address indexed sender, bytes32 indexed assetId, uint balanceIndex);\n', ' \n', '    /*******************************************************************\n', '     * Initialize before using the library\n', '     *******************************************************************/   \n', '    \n', '    function init(System storage self, bytes32[] storage assetId, bytes32 shareAssetId, uint birthday, uint periodicity, address source) internal {\n', '        Distribution memory d = Distribution({\n', '            denominator: 0,\n', '            amount: 0,\n', '            period: 0\n', '        });\n', '        self.shareAsset = shareAssetId;\n', '        self.birthday = birthday;\n', '        self.periodicity = periodicity;\n', '        self.source = source;\n', '        for(uint i=0; i<assetId.length; i++) {\n', '            Asset storage a = self.asset[assetId[i]];\n', '            a.distributions.push(d); // initialize with an open distribution in row 0.\n', '        }\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Adjust balances \n', '     *******************************************************************/ \n', '     \n', '    function add(System storage self, bytes32 assetId, address user, uint toBalance, uint toControlled) internal {\n', '        Asset storage a = self.asset[assetId];\n', '        User storage u = a.users[user];\n', '        (uint currentBalance, uint balancePeriod, uint controlled) = userLatestBalanceUpdate(self, assetId, user);\n', '        uint balanceCount = u.userBalances.length;\n', '\n', '        uint p = period(self);\n', '        currentBalance = currentBalance.add(toBalance);\n', '        controlled = controlled.add(toControlled);\n', '        UserBalance memory b = UserBalance({\n', '            balance: currentBalance,  \n', '            period: p,\n', '            controlled: controlled\n', '        });\n', '        \n', '        emit UserBalanceIncreased(msg.sender, assetId, p, user, toBalance, toControlled);\n', '\n', '        /**\n', '          We can overwrite the current userBalance, if:\n', '           - this is not the share asset used for calculating proportional shares of distributions\n', '           - the last row is already tracking the current period. \n', '        */\n', '\n', '        if(balanceCount > 0 && (assetId != self.shareAsset || balancePeriod == p)) {\n', '            u.userBalances[balanceCount - 1] = b; // overwrite the last row;\n', '            return;\n', '        }\n', '\n', '        /**\n', '          A new user, not seen before, is not entitled to distributions that closed before the current period. \n', '          Therefore, we point to the last distribution if it is open, or beyond it to indicate that this user will \n', '          participate in the next future distribution, if any.\n', '        */\n', '\n', '        // PATCH April 18, 2021\n', '\n', '        // When receiving sharteAsset (HODL) for the first time, the OTHER asset distribution pointer goes to the most recent open distribution.        \n', '\n', '        if(balanceCount == 0 && assetId == self.shareAsset) {\n', '            // Asset storage ethAsset = self.asset[ETH_ASSET];\n', '            // User storage ethUser = ethAsset.users[user];\n', '            self.asset[ETH_ASSET].users[user].processingDistributionIndex = distributionCount(self, ETH_ASSET) - 1;\n', '            if(self.asset[ETH_ASSET].distributions[self.asset[ETH_ASSET].users[user].processingDistributionIndex].period < p) {\n', '                self.asset[ETH_ASSET].users[user].processingDistributionIndex++;\n', '            }\n', '        }\n', '\n', '        // END PATCH April 18, 2021\n', '\n', '        if(balanceCount == 0) {\n', '            u.processingDistributionIndex = distributionCount(self, assetId) - 1; \n', '            if(a.distributions[u.processingDistributionIndex].period < p) {\n', '                u.processingDistributionIndex++;\n', '            }\n', '        }\n', '\n', '        /**\n', '          There may be gaps in the distribution periods when no distribution was allocated. If the distribution pointer\n', '          refers to a future, undefined distribution, then the balance to use is always the most recent known balance, \n', '          which is this update.\n', '        */\n', '\n', '        if(u.processingDistributionIndex == self.asset[assetId].distributions.length) {\n', '            u.processingBalanceIndex = u.userBalances.length;\n', '        }\n', '\n', '        /**\n', "          Appending a new userBalance preserves the user's closing balance in prior periods. \n", '        */\n', '\n', '        u.userBalances.push(b); \n', '        return;\n', '\n', '    }\n', '    \n', '    function sub(System storage self, bytes32 assetId, address user, uint fromBalance, uint fromControlled) internal {\n', '        Asset storage a = self.asset[assetId];\n', '        User storage u = a.users[user];\n', '        uint balanceCount = u.userBalances.length;\n', '        (uint currentBalance, uint balancePeriod, uint controlled) = userLatestBalanceUpdate(self, assetId, user); \n', '        \n', '        uint p = period(self);\n', '        currentBalance = currentBalance.sub(fromBalance, "Prop NSF");\n', '        controlled = controlled.sub(fromControlled, "Prop nsf");\n', '        UserBalance memory b = UserBalance({\n', '            balance: currentBalance, \n', '            period: p,\n', '            controlled: controlled\n', '        });\n', '        \n', '        emit UserBalanceReduced(msg.sender, assetId, p, user, fromBalance, fromControlled);\n', '        \n', '        // re-use a userBalance row if possible\n', '        if(balanceCount > 0 && (assetId != self.shareAsset || balancePeriod == p)) {\n', '            u.userBalances[balanceCount - 1] = b; \n', '            return;\n', '        }\n', '        \n', '        // if the distribution index points to a future distribution, then the balance index is the most recent balance\n', '        if(u.processingDistributionIndex == self.asset[assetId].distributions.length) {\n', '            u.processingBalanceIndex = u.userBalances.length;\n', '        }\n', '\n', '        // Append a new user balance row when we need to retain history or start a new user\n', '        u.userBalances.push(b); // start a new row \n', '        return;\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Distribute \n', '     *******************************************************************/   \n', '     \n', '    function increaseDistribution(System storage self, bytes32 assetId, uint amount) internal {\n', '        Asset storage a = self.asset[assetId];\n', '        Distribution storage d = a.distributions[a.distributions.length - 1];\n', '        if(d.period < period(self)) {\n', '            _closeDistribution(self, assetId);\n', '            d = a.distributions[a.distributions.length - 1];\n', '        }\n', '        if(amount> 0) {\n', '            d.amount = d.amount.add(amount);\n', '            emit IncreaseDistribution(msg.sender, assetId, period(self), amount);\n', '        }\n', '    }\n', '\n', '    function _closeDistribution(System storage self, bytes32 assetId) private {\n', '        Asset storage a = self.asset[assetId];\n', '        Distribution storage d = a.distributions[a.distributions.length - 1];\n', '        uint p = period(self);\n', '        d.denominator = circulatingSupply(self);\n', '        Distribution memory newDist = Distribution({\n', '            denominator: 0,\n', '            amount: 0,\n', '            period: p\n', '        });\n', '        a.distributions.push(newDist); \n', '        emit DistributionClosed(msg.sender, assetId, d.amount, d.denominator, d.period, p);\n', '    }    \n', '    \n', '    /*******************************************************************\n', '     * Claim \n', '     *******************************************************************/   \n', '     \n', '    // look ahead in accounting history\n', '    \n', '    function peakNextUserBalancePeriod(User storage user, uint balanceIndex) private view returns(uint period) {\n', '        if(balanceIndex + 1 < user.userBalances.length) {\n', '            period = user.userBalances[balanceIndex + 1].period;\n', '        } else {\n', '            period = PRECISION; // never - this large number is a proxy for future, undefined\n', '        }\n', '    }\n', '    \n', '    function peakNextDistributionPeriod(System storage self, uint distributionIndex) private view returns(uint period) {\n', '        Asset storage a = self.asset[self.shareAsset];\n', '        if(distributionIndex + 1 < a.distributions.length) {\n', '            period = a.distributions[distributionIndex + 1].period;\n', '        } else {\n', '            period = PRECISION - 1; // never - this large number is a proxy for future, undefined\n', '        }\n', '    }\n', '    \n', '    // move forward. Pointers are allowed to extend past the end by one row, meaning "next" period with activity.\n', '    \n', '    function nudgeUserBalanceIndex(System storage self, bytes32 assetId, address user, uint balanceIndex) private {\n', '        if(balanceIndex < self.asset[self.shareAsset].users[user].userBalances.length) self.asset[assetId].users[user].processingBalanceIndex = balanceIndex + 1;\n', '    }\n', '    \n', '    function nudgeUserDistributionIndex(System storage self, bytes32 assetId, address user, uint distributionIndex) private {\n', '        if(distributionIndex < self.asset[assetId].distributions.length) self.asset[assetId].users[user].processingDistributionIndex = distributionIndex + 1;\n', '    }\n', '\n', '    function processNextUserDistribution(System storage self, bytes32 assetId, address user) internal returns(uint amount) {\n', '        Asset storage a = self.asset[assetId];\n', '        Asset storage s = self.asset[self.shareAsset]; //always hodlc\n', '        User storage ua = a.users[user];\n', '        User storage us = s.users[user];\n', '        \n', '        /*\n', '          Closing distributions on-the-fly \n', '          - enables all users to begin claiming their distributions\n', '          - reduces the need for a manual "poke" to close a distribution when no allocations take place in the following period \n', '          - reduces gaps from periods when no allocation occured followed by an allocation \n', '          - reduces possible iteration over those gaps near 286.\n', '        */\n', '\n', '        poke(self, assetId);\n', '\n', '        // begin processing next distribution\n', '        uint balanceIndex;\n', '        uint distributionIndex;\n', '        bool closed;\n', '        (amount, balanceIndex, distributionIndex, closed) = nextUserDistributionDetails(self, assetId, user); \n', '        if(!closed) return 0;\n', '        \n', '        Distribution storage d = a.distributions[distributionIndex];\n', '\n', '        // transfer the amount from the distribution to the user\n', '        emit DistributionPaid(user, assetId, d.period, amount, balanceIndex, distributionIndex);\n', '        add(self, assetId, user, amount, 0);\n', '        \n', '        /****************************************************************\n', '         * Adjust the index pointers to prepare for the next distribution \n', '         ****************************************************************/\n', '         \n', '        uint nextUserBalancePeriod = peakNextUserBalancePeriod(us, balanceIndex);\n', '        uint nextDistributionPeriod = peakNextDistributionPeriod(self, distributionIndex);\n', '        \n', '        nudgeUserDistributionIndex(self, assetId, user, distributionIndex);\n', '        \n', "        // if the next distribution to process isn't open (nothing has been writen), \n", '        // then fast-forward to the lastest shareAsset balance\n', '        if(ua.processingDistributionIndex == a.distributions.length) {\n', '            ua.processingBalanceIndex = us.userBalances.length - 1;\n', '            return amount;\n', '        }\n', '      \n', '        /** \n', '         * Consider advancing to the next userBalance index/\n', '         * A gap in distribution records is possible if no funds are distributed, no claims are processed and no one \n', '         * pokes the asset manually. Gaps are discouraged but this loop resolves them if/when they occur.\n', '         ****/\n', '\n', '        while(nextUserBalancePeriod <= nextDistributionPeriod) {\n', '            nudgeUserBalanceIndex(self, assetId, user, balanceIndex);\n', '            (/* amount */, balanceIndex, /* distributionIndex */, /* closed */) = nextUserDistributionDetails(self, assetId, user);\n', '            nextUserBalancePeriod = peakNextUserBalancePeriod(us, balanceIndex);\n', '        }\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Force close a period to enable claims\n', '     *******************************************************************/ \n', '    \n', '    function poke(System storage self, bytes32 assetId) internal  {\n', '        increaseDistribution(self, assetId, 0);\n', '    }\n', '\n', '    /********************************************************************\n', "     * The user's historical shareBalance is used  to compute shares of a supply which is applied to an \n", '     * unclaimed distribution of the asset itself (assetId).  \n', '     ********************************************************************/\n', '    \n', '    function nextUserDistributionDetails(System storage self, bytes32 assetId, address user) \n', '        internal \n', '        view\n', '        returns(\n', '            uint amount,\n', '            uint balanceIndex,\n', '            uint distributionIndex,\n', '            bool closed)\n', '    {\n', '        \n', '        Asset storage a = self.asset[assetId];\n', '        Asset storage s = self.asset[self.shareAsset];\n', '        User storage ua = a.users[user];\n', '        User storage us = s.users[user]; \n', '        \n', '        // shareAsset balance index, this asset distribution index\n', '        balanceIndex = ua.processingBalanceIndex;\n', '        distributionIndex = ua.processingDistributionIndex;\n', '\n', '        // if the user distribution index points to an as-yet uninitialized period (future) then it is not payable\n', '        if(a.distributions.length < distributionIndex + 1) return(0, balanceIndex, distributionIndex, false);\n', '        \n', "        // the distribution to work with (this asset) from the user's asset distribution index\n", '        Distribution storage d = a.distributions[distributionIndex];\n', '        // the demoninator for every asset snapshots the share asset supply when the distribution is closed\n', '        uint supply = d.denominator;\n', '        closed = supply != 0;\n', '        \n', '        // if the user has no balance history then there is no entitlement. If the distribution is open then it is not payable.\n', '        if(us.userBalances.length < balanceIndex + 1 || !closed) return(0, balanceIndex, distributionIndex, closed);\n', '\n', "        // the user balance to work with (share asset) from the user's balance index\n", '        UserBalance storage ub = us.userBalances[balanceIndex];        \n', '        \n', '        // shares include both the unincumbered user balance and any controlled balances, e.g. open sell orders, escrow, etc.\n', '        uint shares = ub.balance + ub.controlled;\n', '        \n', '        // distribution / suppler, e.g. amount per share \n', '        uint distroAmt = d.amount;\n', '        uint globalRatio = (distroAmt * PRECISION) / supply;\n', '        \n', '        // the user receives the amount per unit * the units they have or control \n', '        amount = (shares * globalRatio) / PRECISION;\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Inspect Configuration\n', '     *******************************************************************/    \n', '    \n', '    function configuration(System storage self) internal view returns(uint birthday, uint periodicity, address source, bytes32 shareAsset) {\n', '        birthday = self.birthday;\n', '        periodicity = self.periodicity;\n', '        source = self.source;\n', '        shareAsset = self.shareAsset;\n', '    }\n', '\n', '    /*******************************************************************\n', '     * Inspect Periods \n', '     *******************************************************************/\n', '\n', '    function period(System storage self) internal view returns(uint periodNumber) {\n', '        uint age = now.sub(self.birthday, "P502");\n', '        periodNumber = age / self.periodicity;\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Inspect User Balances \n', '     *******************************************************************/    \n', '\n', '    function balanceOf(System storage self, bytes32 assetId, address user) internal view returns(uint balance) {\n', '        Asset storage a = self.asset[assetId];\n', '        uint nextRow = userBalanceCount(self, assetId, user);\n', '        if(nextRow == 0) return(0);\n', '        UserBalance storage ub = a.users[user].userBalances[nextRow - 1];\n', '        return ub.balance;\n', '    }\n', '    \n', '    function additionalControlled(System storage self, bytes32 assetId, address user) internal view returns(uint controlled) {\n', '        Asset storage a = self.asset[assetId];\n', '        uint nextRow = userBalanceCount(self, assetId, user);\n', '        if(nextRow == 0) return(0);\n', '        return a.users[user].userBalances[nextRow - 1].controlled;\n', '    }\n', '    \n', '    // There are 0-1 userBalance records for each distribution period\n', '    function userBalanceCount(System storage self, bytes32 assetId, address user) internal view returns(uint count) {\n', '        Asset storage a = self.asset[assetId];\n', '        return a.users[user].userBalances.length;\n', '    }\n', '    \n', '    function userBalanceAtIndex(System storage self, bytes32 assetId, address user, uint index) internal view returns(uint balance, uint controlled, uint _period) {\n', '        Asset storage a = self.asset[assetId];\n', '        UserBalance storage ub = a.users[user].userBalances[index];\n', '        return (ub.balance, ub.controlled, ub.period);\n', '    }\n', '    \n', '    function userLatestBalanceUpdate(System storage self, bytes32 assetId, address user) internal view returns(uint balance, uint _period, uint controlled) {\n', '        Asset storage a = self.asset[assetId];\n', '        uint nextRow = userBalanceCount(self, assetId, user);\n', '        if(nextRow == 0) return(0, 0, 0);\n', '        UserBalance storage ub = a.users[user].userBalances[nextRow - 1];\n', '        balance = ub.balance;\n', '        _period = ub.period;\n', '        controlled = ub.controlled;\n', '    }\n', '\n', '    function getPointers(System storage self, bytes32 assetId, address user) internal view returns(uint pdi, uint pbi) {\n', '        Asset storage a = self.asset[assetId];\n', '        a.users[user].processingDistributionIndex;\n', '        return (a.users[user].processingDistributionIndex, a.users[user].processingBalanceIndex);\n', '    }\n', '    \n', '    /*******************************************************************\n', '     * Inspect Distributions\n', '     *******************************************************************/     \n', '\n', '    function circulatingSupply(System storage self) internal view returns(uint supply) {\n', '        supply = ProportionalInterface(self.source).circulatingSupply(); // Inspect the external source\n', '    }\n', '    \n', '    function distributionCount(System storage self, bytes32 assetId) internal view returns(uint count) {\n', '        count = self.asset[assetId].distributions.length;\n', '    }\n', '    \n', '    function distributionAtIndex(System storage self, bytes32 assetId, uint index) internal view returns(uint denominator, uint amount, uint _period) {\n', '        Asset storage a = self.asset[assetId];\n', '        return (\n', '            a.distributions[index].denominator,\n', '            a.distributions[index].amount,\n', '            a.distributions[index].period);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'abstract contract ERC20Burnable is Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public virtual {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n", '     * allowance.\n', '     *\n', '     * See {ERC20-_burn} and {ERC20-allowance}.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have allowance for ``accounts``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public virtual {\n', '        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");\n', '\n', '        _approve(account, _msgSender(), decreasedAllowance);\n', '        _burn(account, amount);\n', '    }\n', '}\n', '// import "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol";\n', '// import "@openzeppelin/contracts/access/Ownable.sol";\n', '\n', '\n', 'contract HTEthUsd is ERC20Burnable, Ownable {\n', '    \n', '    constructor () ERC20("HODL ERC20 Token, Ethereum, US Dollar", "HTETHUSD") public {\n', '    \t_setupDecimals(18);\n', '    }\n', '    \n', '    function mint(address user, uint amount) external onlyOwner { // TODO: Check ownership graph\n', '        _mint(user, amount);\n', '    }\n', '}\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '/**\n', ' * @dev Library for managing\n', ' * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', ' * types.\n', ' *\n', ' * Sets have the following properties:\n', ' *\n', ' * - Elements are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableSet for EnumerableSet.AddressSet;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableSet.AddressSet private mySet;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n', ' * (`UintSet`) are supported.\n', ' */\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint256(_at(set._inner, index)));\n', '    }\n', '\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module that allows children to implement role-based access\n', ' * control mechanisms.\n', ' *\n', ' * Roles are referred to by their `bytes32` identifier. These should be exposed\n', ' * in the external API and be unique. The best way to achieve this is by\n', ' * using `public constant` hash digests:\n', ' *\n', ' * ```\n', ' * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");\n', ' * ```\n', ' *\n', ' * Roles can be used to represent a set of permissions. To restrict access to a\n', ' * function call, use {hasRole}:\n', ' *\n', ' * ```\n', ' * function foo() public {\n', ' *     require(hasRole(MY_ROLE, msg.sender));\n', ' *     ...\n', ' * }\n', ' * ```\n', ' *\n', ' * Roles can be granted and revoked dynamically via the {grantRole} and\n', ' * {revokeRole} functions. Each role has an associated admin role, and only\n', " * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n", ' *\n', ' * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n', ' * that only accounts with this role will be able to grant or revoke other\n', ' * roles. More complex role relationships can be created by using\n', ' * {_setRoleAdmin}.\n', ' *\n', ' * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n', ' * grant and revoke this role. Extra precautions should be taken to secure\n', ' * accounts that have been granted it.\n', ' */\n', 'abstract contract AccessControl is Context {\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '    using Address for address;\n', '\n', '    struct RoleData {\n', '        EnumerableSet.AddressSet members;\n', '        bytes32 adminRole;\n', '    }\n', '\n', '    mapping (bytes32 => RoleData) private _roles;\n', '\n', '    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n', '\n', '    /**\n', "     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n", '     *\n', '     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n', '     * {RoleAdminChanged} not being emitted signaling this.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is granted `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call, an admin role\n', '     * bearer except when using {_setupRole}.\n', '     */\n', '    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is revoked `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call:\n', '     *   - if using `revokeRole`, it is the admin role bearer\n', '     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n', '     */\n', '    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev Returns `true` if `account` has been granted `role`.\n', '     */\n', '    function hasRole(bytes32 role, address account) public view returns (bool) {\n', '        return _roles[role].members.contains(account);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of accounts that have `role`. Can be used\n', '     * together with {getRoleMember} to enumerate all bearers of a role.\n', '     */\n', '    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n', '        return _roles[role].members.length();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns one of the accounts that have `role`. `index` must be a\n', '     * value between 0 and {getRoleMemberCount}, non-inclusive.\n', '     *\n', '     * Role bearers are not sorted in any particular way, and their ordering may\n', '     * change at any point.\n', '     *\n', '     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n', '     * you perform all queries on the same block. See the following\n', '     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n', '     * for more information.\n', '     */\n', '    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n', '        return _roles[role].members.at(index);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the admin role that controls `role`. See {grantRole} and\n', '     * {revokeRole}.\n', '     *\n', "     * To change a role's admin, use {_setRoleAdmin}.\n", '     */\n', '    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n', '        return _roles[role].adminRole;\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function grantRole(bytes32 role, address account) public virtual {\n', '        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to grant");\n', '\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from `account`.\n', '     *\n', '     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function revokeRole(bytes32 role, address account) public virtual {\n', '        require(hasRole(_roles[role].adminRole, _msgSender()), "AccessControl: sender must be an admin to revoke");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from the calling account.\n', '     *\n', "     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n", '     * purpose is to provide a mechanism for accounts to lose their privileges\n', '     * if they are compromised (such as when a trusted device is misplaced).\n', '     *\n', '     * If the calling account had been granted `role`, emits a {RoleRevoked}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be `account`.\n', '     */\n', '    function renounceRole(bytes32 role, address account) public virtual {\n', '        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', "     * event. Note that unlike {grantRole}, this function doesn't perform any\n", '     * checks on the calling account.\n', '     *\n', '     * [WARNING]\n', '     * ====\n', '     * This function should only be called from the constructor when setting\n', '     * up the initial roles for the system.\n', '     *\n', '     * Using this function in any other way is effectively circumventing the admin\n', '     * system imposed by {AccessControl}.\n', '     * ====\n', '     */\n', '    function _setupRole(bytes32 role, address account) internal virtual {\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', "     * @dev Sets `adminRole` as ``role``'s admin role.\n", '     *\n', '     * Emits a {RoleAdminChanged} event.\n', '     */\n', '    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n', '        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n', '        _roles[role].adminRole = adminRole;\n', '    }\n', '\n', '    function _grantRole(bytes32 role, address account) private {\n', '        if (_roles[role].members.add(account)) {\n', '            emit RoleGranted(role, account, _msgSender());\n', '        }\n', '    }\n', '\n', '    function _revokeRole(bytes32 role, address account) private {\n', '        if (_roles[role].members.remove(account)) {\n', '            emit RoleRevoked(role, account, _msgSender());\n', '        }\n', '    }\n', '}\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' * \n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' * \n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function _isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { cs := extcodesize(self) }\n', '        return cs == 0;\n', '    }\n', '}\n', '\n', 'interface IDex {\n', '    function allocateDistribution(uint amountHodl) external;\n', '    function convertHodlToUsd(uint amtHodl) external view returns(uint inUsd);\n', '    function convertUsdToHodl(uint amtUsd) external view returns(uint inHodl);\n', '    function user(address userAddr) external view returns(uint balanceEth, uint balanceHodl, uint controlledHodl);\n', '}\n', '\n', 'contract HTokenReserve is Initializable, AccessControl {\n', '    \n', '    using SafeMath for uint;\n', '    bool initialized;\n', '    uint allocationTimer;\n', '    IDex dex;\n', '    HTEthUsd token;\n', '    \n', '    bytes32 constant public DEX_ROLE = keccak256("Dex Role");\n', '    \n', '    uint constant FREQUENCY = 1 days;\n', '\n', '    modifier periodic {\n', '        if((block.timestamp - allocationTimer) > FREQUENCY) {\n', '            allocateSurplus();\n', '            allocationTimer = block.timestamp;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyDex {\n', '        require(hasRole(DEX_ROLE, msg.sender), "HTokenReserve - 403, sender is not a Dex");\n', '        _;\n', '    }\n', '    \n', '    modifier ifInitialized {\n', '        require(initialized, "HTokenReserve - 403, contract not initialized.");\n', '        _;\n', '    }\n', '    \n', '    event Deployed(address deployer);\n', '    event Configured(address deployer, address dexContract, address tokenContract);\n', '    event HTEthUsdIssued(address indexed user, uint HCEthUsdToReserve, uint HTEthUsdIssued);\n', '    event HCEthUsdRedeemed(address indexed user, uint HTEthUsdBurned, uint HCEthUsdFromReserve);\n', '    event SurplusAllocated(address indexed receiver, uint amountHCEthUsd);\n', '    \n', '    constructor() public {\n', '        emit Deployed(msg.sender);\n', '        allocationTimer = block.timestamp;\n', '    }\n', '\n', '    function init(address dexAddr) external initializer {\n', '        // configure access control\n', '        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n', '        _setupRole(DEX_ROLE, dexAddr); \n', '\n', '        // join contracts       \n', '        dex = IDex(dexAddr);\n', '        token = new HTEthUsd();\n', '        \n', '        initialized = true;\n', '        emit Configured(msg.sender, dexAddr, address(token));        \n', '    }\n', '    \n', '    function dexContract() external view returns(address dexAddr) {\n', '        return address(dex);\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Swaps - amounts (both directions) are USD tokens representing $1 * 10 ** 18\n', '     **************************************************************************************/    \n', '    \n', '    function issueHTEthUsd(address user, uint amountUsd) external ifInitialized periodic onlyDex returns(uint amtHcEthUsd) {\n', '        amtHcEthUsd = dex.convertUsdToHodl(amountUsd);\n', '        emit HTEthUsdIssued(user, amtHcEthUsd, amountUsd); \n', '        token.mint(user, amountUsd);\n', '    }\n', '    \n', '    function burnHTEthUsd(address user, uint amountUsd) external ifInitialized periodic onlyDex returns(uint amtHcEthUsd) {\n', '        amtHcEthUsd = dex.convertUsdToHodl(amountUsd);\n', '        emit HCEthUsdRedeemed(user, amountUsd, amtHcEthUsd);\n', '        token.burnFrom(user, amountUsd);\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Send surplus hodl tokens to the dex for distribution - reserve remains at 100%\n', '     * This occurs periodicially and anyone is allowed to force it to happen.\n', '     **************************************************************************************/ \n', '     \n', '    function allocateSurplus() public ifInitialized {\n', '        uint amount = surplusHCEthUsd();\n', '        emit SurplusAllocated(address(dex), amount);\n', '        dex.allocateDistribution(amount);\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Inspect the state\n', '     **************************************************************************************/     \n', '    \n', '    function erc20Token() public view returns(address erc20) {\n', '        return address(token);\n', '    }\n', '    \n', '    function reservesHCEthUsd() public view returns(uint hcEthUsdBalance) {\n', '        (/* uint balanceEth */, hcEthUsdBalance, /* uint controlledHodl */) = dex.user(address(this));\n', '    }\n', '    \n', '    function reserveUsd() public view returns(uint usdValue) {\n', '        usdValue = dex.convertHodlToUsd(reservesHCEthUsd());\n', '    }\n', '    \n', '    function circulatingUsd() public view returns(uint usdValue) {\n', '        return token.totalSupply();\n', '    }\n', '    \n', '    function surplusHCEthUsd() public view returns(uint HCEthUsdSurplus) {\n', '        uint reserveHCEthUsd = reservesHCEthUsd();\n', '        uint requiredCHEthUsd = dex.convertUsdToHodl(circulatingUsd());\n', '        HCEthUsdSurplus = reserveHCEthUsd.sub(requiredCHEthUsd);\n', '    }\n', '    \n', '    function surplusUsdValue() public  view  returns(uint usdValue) {\n', '        usdValue = reserveUsd().sub(circulatingUsd());\n', '    }  \n', '}\n', '\n', 'interface IHTokenReserve {\n', '    function erc20Contract() external view returns(address erc20);\n', '    function issueHTEthUsd(address user, uint amountUsd) external returns(uint amtHcEthUsd);\n', '    function burnHTEthUsd(address user, uint amountUsd) external returns(uint amtHcEthUsd);\n', '    function tokenReserveContract() external view returns(IHTokenReserve _reserve);\n', '    function dexContract() external view returns(address dexAddr);\n', '}\n', '\n', 'contract HodlDex is IDex, Initializable, AccessControl {\n', '    \n', '    using SafeMath for uint;                                        // OpenZeppelin safeMath utility\n', '    using FIFOSet for FIFOSet.Set;                                  // FIFO key sets\n', '    using Proportional for Proportional.System;                     // Balance management with proportional distribution \n', '    \n', '    IHOracle oracle;                                                // Must implement the read() view function (EthUsd18 uint256)\n', '    IHTokenReserve tokenReserve;                                    // The ERC20 token reserve\n', '    \n', '    bytes32 constant public MIGRATION_ROLE = keccak256("Migration Role");\n', '    bytes32 constant public RESERVE_ROLE = keccak256("Reserve Role");\n', '    bytes32 constant public ORACLE_ROLE = keccak256("Oracle Role");\n', '    bytes32 constant public ADMIN_ROLE = keccak256("Admin Role");  \n', '    bytes32 constant public ETH_ASSET = keccak256("Eth");\n', '    bytes32 constant public HODL_ASSET = keccak256("HODL");\n', '    \n', '    bytes32[] assetIds;                                             // Accessible in the library\n', '\n', '    bytes32 constant NULL = bytes32(0); \n', '    address constant UNDEFINED = address(0);\n', '    uint constant PRECISION = 10 ** 18;                             // Precision is 18 decimal places\n', '    uint constant TOTAL_SUPPLY = 20000000 * (10**18);               // Total supply - initially goes to the reserve, which is address(this)\n', '    uint constant SLEEP_TIME = 30 days;                             // Grace period before time-based accrual kicks in\n', '    uint constant DAILY_ACCRUAL_RATE_DECAY = 999999838576236000;    // Rate of decay applied daily reduces daily accrual APR to about 5% after 30 years\n', '    uint constant USD_TXN_ADJUSTMENT = 10**14;                      // $0.0001 with 18 decimal places of precision - 1/100th of a cent\n', '    \n', '    uint constant BIRTHDAY = 1595899309;                            // Now time when the contract was deployed\n', '    uint constant MIN_ORDER_USD = 50 * 10 ** 18;                    // Minimum order size is $50 in USD precision\n', '    uint constant MAX_THRESHOLD_USD = 10 * 10 ** 18;                // Order limits removed when HODL_USD exceeds $10\n', '    uint constant MAX_ORDER_FACTOR = 5000;                          // Max Order Volume will be 5K * hodl_usd until threshold ($10).  \n', '    uint constant DISTRIBUTION_PERIOD = 30 days;                    // Periodicity for distributions\n', '\n', '    /**************************************************************************************\n', '     * block 11094768 values from old dex at 0x56b9d34F9f4E4A1A82D847128c1B2264B34D2fAe\n', '    **************************************************************************************/    \n', '\n', '    uint constant _accrualDaysProcessed = 54;                       // Days of stateful accrual applied\n', '    uint constant _HODL_USD = 1335574612014710427;                  // HODL:USD exchange rate last recorded\n', '    uint constant _DAILY_ACCRUAL_RATE = 1001892104261953098;        // Initial daily accrual is 0.19% (100.19% multiplier) which is about 100% APR\n', '    uint public accrualDaysProcessed;\n', '    uint private HODL_USD;\n', '    uint private DAILY_ACCRUAL_RATE;\n', '\n', '    /**************************************************************************************\n', '     * Counters\n', '     **************************************************************************************/     \n', '    \n', '    uint public entropy_counter;                                    // Ensure unique order ids\n', '    uint public eth_usd_block;                                      // Block number of last ETH_USD recorded\n', '    uint public error_count;                                        // Oracle read errors\n', '    uint public ETH_USD;                                            // Last recorded ETH_USD rate\n', '\n', '    Proportional.System balance;                                    // Account balances with proportional distribution system \n', '\n', '    struct SellOrder {\n', '        address seller;\n', '        uint volumeHodl;\n', '        uint askUsd;\n', '    } \n', '    \n', '    struct BuyOrder {\n', '        address buyer;\n', '        uint bidEth;\n', '    }\n', '    \n', '    mapping(bytes32 => SellOrder) public sellOrder;\n', '    mapping(bytes32 => BuyOrder) public buyOrder; \n', '\n', '    FIFOSet.Set sellOrderIdFifo;                                    // SELL orders in order of declaration\n', '    FIFOSet.Set buyOrderIdFifo;                                     // BUY orders in order of declaration\n', '    \n', '    modifier onlyAdmin {\n', '        require(hasRole(ADMIN_ROLE, msg.sender), "HodlDex 403 admin");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOracle {\n', '        require(hasRole(ORACLE_ROLE, msg.sender), "HodlDex 403 oracle");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyMigration {\n', '        require(hasRole(MIGRATION_ROLE, msg.sender), "HodlDex 403 migration");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyReserve {\n', '        require(hasRole(RESERVE_ROLE, msg.sender), "HodlDex 403 reserve.");\n', '        _; \n', '    }\n', '    \n', '    modifier ifRunning {\n', '        require(isRunning(), "HodleDex uninitialized.");\n', '        _;\n', '    }\n', '\n', '    modifier accrueByTime {\n', '        _;\n', '        _accrueByTime();\n', '    }\n', '\n', '    event HodlTIssued(address indexed user, uint amountUsd, uint amountHodl);\n', '    event HodlTRedeemed(address indexed user, uint amountUsd, uint amountHodl);\n', '    event SellHodlCRequested(address indexed seller, uint quantityHodl, uint lowGas);\n', '    event SellOrderFilled(address indexed buyer, bytes32 indexed orderId, address indexed seller, uint txnEth, uint txnHodl);\n', '    event SellOrderRefunded(address indexed seller, bytes32 indexed orderId, uint refundedHodl);    \n', '    event SellOrderOpened(bytes32 indexed orderId, address indexed seller, uint quantityHodl, uint askUsd);\n', '    event BuyHodlCRequested(address indexed buyer, uint amountEth, uint lowGas);\n', '    event BuyOrderFilled(address indexed seller, bytes32 indexed orderId, address indexed buyer, uint txnEth, uint txnHodl);\n', '    event BuyOrderRefunded(address indexed seller, bytes32 indexed orderId, uint refundedEth);\n', '    event BuyFromReserve(address indexed buyer, uint txnEth, uint txnHodl);\n', '    event BuyOrderOpened(bytes32 indexed orderedId, address indexed buyer, uint amountEth);\n', '    event SellOrderCancelled(address indexed userAddr, bytes32 indexed orderId);\n', '    event BuyOrderCancelled(address indexed userAddr, bytes32 indexed orderId);\n', '    event UserDepositEth(address indexed user, uint amountEth);\n', '    event UserWithdrawEth(address indexed user, uint amountEth);\n', '    event InitConfigure(address sender, IHTokenReserve tokenReserve, IHOracle oracle);\n', '    event UserInitialized(address admin, address indexed user, uint hodlCR, uint ethCR);\n', '    event UserUninitialized(address admin, address indexed user);\n', '    event OracleSet(address admin, address oracle);\n', '    event SetEthUsd(address setter, uint ethUsd18);\n', '    event SetDailyAccrualRate(address admin, uint dailyAccrualRate);\n', '    event EthUsdError(address sender, uint errorCount, uint ethUsd);\n', '    event IncreaseGas(address sender, uint gasLeft, uint ordersFilled);\n', '    event IncreasedByTransaction(address sender, uint transactionCount, uint newHodlUsd);\n', '    event AccrueByTime(address sender, uint hodlUsdNow, uint dailyAccrualRateNow);\n', '    event InternalTransfer(address sender, address from, address to, uint amount);\n', '    event HodlDistributionAllocated(address sender, uint amount);\n', '\n', '    /**************************************************************************************\n', '     * @dev run init() before using this contract\n', '     **************************************************************************************/ \n', '\n', '    function keyGen() private returns(bytes32 key) {\n', '        entropy_counter++;\n', '        return keccak256(abi.encodePacked(address(this), msg.sender, entropy_counter));\n', '    }\n', '    \n', '    function oracleContract() external view returns(IHOracle _oracle) {\n', '        return oracle;\n', '    }\n', '    \n', '    function tokenReserveContract() external view returns(IHTokenReserve _reserve) {\n', '        return tokenReserve;\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * An admin may change the oracle service\n', '     **************************************************************************************/    \n', '    \n', '    function adminSetOracle(IHOracle _oracle) external onlyAdmin {\n', '        oracle = _oracle;\n', '\n', '        //_setupRole(ORACLE_ROLE, _oracle);\n', '        emit OracleSet(msg.sender, address(_oracle));\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * An Oracle may inject a new Eth:Usd rate\n', '     **************************************************************************************/ \n', '    \n', '    function oracleSetEthUsd(uint ethUsd) external onlyOracle {\n', '        ETH_USD = ethUsd;\n', '        eth_usd_block = block.number;\n', '        emit SetEthUsd(msg.sender, ethUsd);\n', '    }    \n', '\n', '    /**************************************************************************************\n', '     * Anyone can nudge the time-based accrual and distribution accounting periods forward\n', '     **************************************************************************************/ \n', '\n', '    function poke() public ifRunning {\n', '        _accrueByTime();\n', '        _setEthToUsd();\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Convertability to HODLT USD TOKEN ERC20\n', '     **************************************************************************************/    \n', '    \n', '    function hodlTIssue(uint amountUsd) external accrueByTime ifRunning {\n', '        uint amountHodl = tokenReserve.issueHTEthUsd(msg.sender, amountUsd);\n', '        emit HodlTIssued(msg.sender, amountUsd, amountHodl);\n', '        balance.sub(HODL_ASSET, msg.sender, amountHodl, 0);\n', '        balance.add(HODL_ASSET, address(tokenReserve), amountHodl, 0);\n', '    }\n', '\n', '    function hodlTRedeem(uint amountUsd) external accrueByTime ifRunning {\n', '        uint amountHodl = tokenReserve.burnHTEthUsd(msg.sender, amountUsd);\n', '        emit HodlTRedeemed(msg.sender, amountUsd, amountHodl);\n', '        balance.add(HODL_ASSET, msg.sender, amountHodl, 0);\n', '        balance.sub(HODL_ASSET, address(tokenReserve), amountHodl, 0);\n', '    }\n', '\n', '    function allocateDistribution(uint amountHodl) external override ifRunning onlyReserve {\n', '        emit HodlDistributionAllocated(msg.sender, amountHodl);\n', '        balance.sub(HODL_ASSET, address(tokenReserve), amountHodl, 0);\n', '        balance.increaseDistribution(HODL_ASSET, amountHodl);\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Claim distributions\n', '     **************************************************************************************/      \n', '    \n', '    function claimEthDistribution() external virtual ifRunning returns(uint amountEth) {\n', '        amountEth = balance.processNextUserDistribution(ETH_ASSET, msg.sender);\n', '    }\n', '    \n', '    function claimHodlDistribution() external virtual ifRunning returns(uint amountHodl) {\n', '        amountHodl = balance.processNextUserDistribution(HODL_ASSET, msg.sender);\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Sell HodlC to buy orders, or if no buy orders open a sell order.\n', '     * Selectable low gas protects against future EVM price changes.\n', '     * Completes as much as possible (gas) and return unprocessed Hodl.\n', '     **************************************************************************************/ \n', '\n', '    function sellHodlC(uint quantityHodl, uint lowGas) external accrueByTime ifRunning returns(bytes32 orderId) {\n', '        emit SellHodlCRequested(msg.sender, quantityHodl, lowGas);\n', '        uint orderUsd = convertHodlToUsd(quantityHodl); \n', '        uint orderLimit = orderLimit();\n', '        require(orderUsd >= MIN_ORDER_USD, "HodlDex, < min USD");\n', '        require(orderUsd <= orderLimit || orderLimit == 0, "HodlDex, > max USD");\n', '        quantityHodl = _fillBuyOrders(quantityHodl, lowGas);\n', '        orderId = _openSellOrder(quantityHodl);\n', '    }\n', '\n', '    function _fillBuyOrders(uint quantityHodl, uint lowGas) private returns(uint remainingHodl) {\n', '        bytes32 orderId;\n', '        address orderBuyer;\n', '        uint orderHodl;\n', '        uint orderEth;\n', '        uint txnEth;\n', '        uint txnHodl;\n', '        uint ordersFilled;\n', '\n', '        while(buyOrderIdFifo.count() > 0 && quantityHodl > 0) { \n', '            if(gasleft() < lowGas) {\n', '                emit IncreaseGas(msg.sender, gasleft(), ordersFilled);\n', '                return 0;\n', '            }\n', '            orderId = buyOrderIdFifo.first();\n', '            BuyOrder storage o = buyOrder[orderId]; \n', '            orderBuyer = o.buyer;\n', '            orderEth = o.bidEth;\n', '            orderHodl = _convertEthToHodl(orderEth);\n', '            \n', '            if(orderHodl == 0) {\n', '                // First order is now too small to fill. Refund eth and prune the order.\n', '                if(orderEth > 0) {\n', '                    balance.add(ETH_ASSET, orderBuyer, orderEth, 0);\n', '                    emit BuyOrderRefunded(msg.sender, orderId, orderEth); \n', '                }\n', '                delete buyOrder[orderId];\n', '                buyOrderIdFifo.remove(orderId);\n', '            } else {\n', '                // Seller wants to sell hodl with Eth value\n', '                txnEth  = _convertHodlToEth(quantityHodl);\n', '                txnHodl = quantityHodl;\n', '                // Fill some or all of the open order\n', '                if(orderEth < txnEth) {\n', '                    txnEth = orderEth;\n', '                    txnHodl = orderHodl;\n', '                }\n', '                emit BuyOrderFilled(msg.sender, orderId, orderBuyer, txnEth, txnHodl);\n', '                // Transfer hodl from seller to buyer \n', '                balance.sub(HODL_ASSET, msg.sender, txnHodl, 0);\n', '                balance.add(HODL_ASSET, orderBuyer, txnHodl, 0);\n', '                // Award Eth to seller \n', '                balance.add(ETH_ASSET, msg.sender, txnEth, 0);\n', '                if(orderEth == txnEth) {\n', '                    // delete filled order \n', '                    delete buyOrder[orderId];\n', '                    buyOrderIdFifo.remove(orderId);\n', '                // the the order is partially filled, then deduct Eth from the order\n', '                } else {\n', '                    // deduct eth from a partially filled order\n', '                    o.bidEth = orderEth.sub(txnEth, "HodlDex 500");\n', '                    quantityHodl = quantityHodl.sub(txnHodl, "HodlDex 501");  \n', '                }\n', '                ordersFilled++;\n', '                _increaseTransactionCount(1);\n', '            }          \n', '        }\n', '        remainingHodl = quantityHodl;\n', '    }\n', '\n', '    function _openSellOrder(uint quantityHodl) private returns(bytes32 orderId) {\n', '        // Do not allow low gas to result in small sell orders or sell orders to exist while buy orders exist\n', '        if(convertHodlToUsd(quantityHodl) > MIN_ORDER_USD && buyOrderIdFifo.count() == 0) { \n', '            orderId = keyGen();\n', '            (uint askUsd, /* uint accrualRate */) = rates();\n', '            SellOrder storage o = sellOrder[orderId];\n', '            sellOrderIdFifo.append(orderId);\n', '            emit SellOrderOpened(orderId, msg.sender, quantityHodl, askUsd);\n', '            balance.add(HODL_ASSET, msg.sender, 0, quantityHodl);\n', '            o.seller = msg.sender;\n', '            o.volumeHodl = quantityHodl;\n', '            o.askUsd = askUsd;\n', '            balance.sub(HODL_ASSET, msg.sender, quantityHodl, 0);\n', '        }\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Buy HodlC from sell orders, or if no sell orders, from reserve. Lastly, open a \n', '     * buy order is the reserve is sold out.\n', '     * Selectable low gas protects against future EVM price changes.\n', '     * Completes as much as possible (gas) and returns unspent Eth.\n', '     **************************************************************************************/ \n', '\n', '    function buyHodlC(uint amountEth, uint lowGas) external accrueByTime ifRunning returns(bytes32 orderId) {\n', '        emit BuyHodlCRequested(msg.sender, amountEth, lowGas);\n', '        uint orderLimit = orderLimit();         \n', '        uint orderUsd = convertEthToUsd(amountEth);\n', '        require(orderUsd >= MIN_ORDER_USD, "HodlDex, < min USD ");\n', '        require(orderUsd <= orderLimit || orderLimit == 0, "HodlDex, > max USD");\n', '        amountEth = _fillSellOrders(amountEth, lowGas);\n', '        amountEth = _buyFromReserve(amountEth);\n', '        orderId = _openBuyOrder(amountEth);\n', '    }\n', '\n', '    function _fillSellOrders(uint amountEth, uint lowGas) private returns(uint remainingEth) {\n', '        bytes32 orderId;\n', '        address orderSeller;        \n', '        uint orderEth;\n', '        uint orderHodl;\n', '        uint orderAsk;\n', '        uint txnEth;\n', '        uint txnUsd;\n', '        uint txnHodl; \n', '        uint ordersFilled;\n', '\n', '        while(sellOrderIdFifo.count() > 0 && amountEth > 0) {\n', '            if(gasleft() < lowGas) {\n', '                emit IncreaseGas(msg.sender, gasleft(), ordersFilled);\n', '                return 0;\n', '            }\n', '            orderId = sellOrderIdFifo.first();\n', '            SellOrder storage o = sellOrder[orderId];\n', '            orderSeller = o.seller;\n', '            orderHodl = o.volumeHodl; \n', '            orderAsk = o.askUsd;\n', '            orderEth = _convertUsdToEth((orderHodl.mul(orderAsk)).div(PRECISION));\n', '            \n', '            if(orderEth == 0) {\n', '                // Order is now too small to fill. Refund hodl and prune.\n', '                if(orderHodl > 0) {\n', '                    emit SellOrderRefunded(msg.sender, orderId, orderHodl);\n', '                    balance.add(HODL_ASSET, orderSeller, orderHodl, 0);\n', '                    balance.sub(HODL_ASSET, orderSeller, 0, orderHodl);\n', '                }\n', '                delete sellOrder[orderId];\n', '                sellOrderIdFifo.remove(orderId);\n', '            } else {                        \n', '                txnEth = amountEth;\n', '                txnUsd = convertEthToUsd(txnEth);\n', '                txnHodl = txnUsd.mul(PRECISION).div(orderAsk);\n', '                if(orderEth < txnEth) {\n', '                    txnEth = orderEth;\n', '                    txnHodl = orderHodl;\n', '                }\n', '                emit SellOrderFilled(msg.sender, orderId, orderSeller, txnEth, txnHodl);\n', '                balance.sub(ETH_ASSET, msg.sender, txnEth, 0);\n', '                balance.add(ETH_ASSET, orderSeller, txnEth, 0);\n', '                balance.add(HODL_ASSET, msg.sender, txnHodl, 0);\n', '                balance.sub(HODL_ASSET, orderSeller, 0, txnHodl);\n', '                amountEth = amountEth.sub(txnEth, "HodlDex 503"); \n', '\n', '                if(orderHodl == txnHodl) {\n', '                    delete sellOrder[orderId];\n', '                    sellOrderIdFifo.remove(orderId);\n', '                } else {\n', '                    o.volumeHodl = o.volumeHodl.sub(txnHodl, "HodlDex 504");\n', '                }\n', '                ordersFilled++;\n', '                _increaseTransactionCount(1);\n', '            }\n', '        }\n', '        remainingEth = amountEth;\n', '    }\n', '\n', '    function _buyFromReserve(uint amountEth) private returns(uint remainingEth) {\n', '        uint txnHodl;\n', '        uint txnEth;\n', '        uint reserveHodlBalance;\n', '        if(amountEth > 0) {\n', '            uint amountHodl = _convertEthToHodl(amountEth);\n', '            reserveHodlBalance = balance.balanceOf(HODL_ASSET, address(this));\n', '            txnHodl = (amountHodl <= reserveHodlBalance) ? amountHodl : reserveHodlBalance;\n', '            if(txnHodl > 0) {\n', '                txnEth = _convertHodlToEth(txnHodl);\n', '                emit BuyFromReserve(msg.sender, txnEth, txnHodl);\n', '                balance.sub(HODL_ASSET, address(this), txnHodl, 0);\n', '                balance.add(HODL_ASSET, msg.sender, txnHodl, 0);\n', '                balance.sub(ETH_ASSET, msg.sender, txnEth, 0);\n', '                balance.increaseDistribution(ETH_ASSET, txnEth);\n', '                amountEth = amountEth.sub(txnEth, "HodlDex 505");\n', '                _increaseTransactionCount(1);\n', '            }\n', '        }\n', '        remainingEth = amountEth;\n', '    }\n', '\n', '    function _openBuyOrder(uint amountEth) private returns(bytes32 orderId) {\n', '        // do not allow low gas to open a small buy order or buy orders to exist while sell orders exist\n', '        if(convertEthToUsd(amountEth) > MIN_ORDER_USD && sellOrderIdFifo.count() == 0) {\n', '            orderId = keyGen();\n', '            emit BuyOrderOpened(orderId, msg.sender, amountEth);\n', '            BuyOrder storage o = buyOrder[orderId];\n', '            buyOrderIdFifo.append(orderId);\n', '            balance.sub(ETH_ASSET, msg.sender, amountEth, 0);\n', '            o.bidEth = amountEth;\n', '            o.buyer = msg.sender;\n', '        }\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Cancel orders\n', '     **************************************************************************************/ \n', '\n', '    function cancelSell(bytes32 orderId) external ifRunning {\n', '        uint volHodl;\n', '        address orderSeller;\n', '        emit SellOrderCancelled(msg.sender, orderId);\n', '        SellOrder storage o = sellOrder[orderId];\n', '        orderSeller = o.seller;\n', '        require(o.seller == msg.sender, "HodlDex, not seller.");\n', '        volHodl = o.volumeHodl;\n', '        balance.add(HODL_ASSET, msg.sender, volHodl, 0);\n', '        sellOrderIdFifo.remove(orderId);\n', '        balance.sub(HODL_ASSET, orderSeller, 0, volHodl);\n', '        delete sellOrder[orderId];\n', '    }\n', '    function cancelBuy(bytes32 orderId) external ifRunning {\n', '        BuyOrder storage o = buyOrder[orderId];\n', '        emit BuyOrderCancelled(msg.sender, orderId);\n', '        require(o.buyer == msg.sender, "HodlDex, not buyer.");\n', '        balance.add(ETH_ASSET, msg.sender, o.bidEth, 0);\n', '        buyOrderIdFifo.remove(orderId);\n', '        delete buyOrder[orderId];\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * External quote\n', '     **************************************************************************************/\n', '\n', '    function _setEthToUsd() private returns(uint ethUsd18) {\n', '        if(eth_usd_block == block.number) return ETH_USD;\n', '        bool success;\n', '        (ethUsd18, success) = getEthToUsd();\n', '        ETH_USD = ethUsd18;\n', '        eth_usd_block = block.number;\n', '        if(!success) {\n', '            error_count++;\n', '            emit EthUsdError(msg.sender, error_count, ethUsd18);\n', '        }\n', '        emit SetEthUsd(msg.sender, ethUsd18);\n', '        \n', '        // minimize possible gaps in the distribution periods\n', '        \n', '        balance.poke(ETH_ASSET);\n', '        balance.poke(HODL_ASSET);\n', '    }\n', '\n', '    function getEthToUsd() public view returns(uint ethUsd18, bool success) {\n', '        try oracle.read() returns(uint response) {\n', '            ethUsd18 = response;\n', '            success = true;\n', '        } catch {\n', '            ethUsd18 = ETH_USD;\n', '        }\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Prices and quotes, persistent. UniSwap inspection once per block.\n', '     **************************************************************************************/    \n', '    \n', '    function _convertEthToUsd(uint amtEth) private returns(uint inUsd) {\n', '        return amtEth.mul(_setEthToUsd()).div(PRECISION);\n', '    }\n', '    \n', '    function _convertUsdToEth(uint amtUsd) private returns(uint inEth) {\n', '        return amtUsd.mul(PRECISION).div(_convertEthToUsd(PRECISION));\n', '    }\n', '    \n', '    function _convertEthToHodl(uint amtEth) private returns(uint inHodl) {\n', '        uint inUsd = _convertEthToUsd(amtEth);\n', '        return convertUsdToHodl(inUsd);\n', '    }\n', '    \n', '    function _convertHodlToEth(uint amtHodl) private returns(uint inEth) { \n', '        uint inUsd = convertHodlToUsd(amtHodl);\n', '        return _convertUsdToEth(inUsd);\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Prices and quotes, view only.\n', '     **************************************************************************************/    \n', '    \n', '    function convertEthToUsd(uint amtEth) public view returns(uint inUsd) {\n', '        return amtEth.mul(ETH_USD).div(PRECISION);\n', '    }\n', '   \n', '    function convertUsdToEth(uint amtUsd) public view returns(uint inEth) {\n', '        return amtUsd.mul(PRECISION).div(convertEthToUsd(PRECISION));\n', '    }\n', '    \n', '    function convertHodlToUsd(uint amtHodl) public override view returns(uint inUsd) {\n', '        (uint _hodlUsd, /* uint _accrualRate */) = rates();\n', '        return amtHodl.mul(_hodlUsd).div(PRECISION);\n', '    }\n', '    \n', '    function convertUsdToHodl(uint amtUsd) public override view returns(uint inHodl) {\n', '         (uint _hodlUsd, /* uint _accrualRate */) = rates();\n', '        return amtUsd.mul(PRECISION).div(_hodlUsd);\n', '    }\n', '    \n', '    function convertEthToHodl(uint amtEth) public view returns(uint inHodl) {\n', '        uint inUsd = convertEthToUsd(amtEth);\n', '        return convertUsdToHodl(inUsd);\n', '    }\n', '    \n', '    function convertHodlToEth(uint amtHodl) public view returns(uint inEth) { \n', '        uint inUsd = convertHodlToUsd(amtHodl);\n', '        return convertUsdToEth(inUsd);\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Fund Accounts\n', '     **************************************************************************************/ \n', '\n', '    function depositEth() external ifRunning payable {\n', '        require(msg.value > 0, "You must send Eth to this function");\n', '        emit UserDepositEth(msg.sender, msg.value);\n', '        balance.add(ETH_ASSET, msg.sender, msg.value, 0);\n', '    }\n', '    \n', '    function withdrawEth(uint amount) external virtual ifRunning {\n', '        emit UserWithdrawEth(msg.sender, amount);\n', '        balance.sub(ETH_ASSET, msg.sender, amount, 0);\n', '        (bool success, /* bytes memory data */) = msg.sender.call{value:amount}("");\n', '        require(success, "rejected by receiver"); \n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Daily accrual and rate decay over time\n', '     **************************************************************************************/ \n', '\n', '    function rates() public view returns(uint hodlUsd, uint dailyAccrualRate) {\n', '        hodlUsd = HODL_USD;\n', '        dailyAccrualRate = DAILY_ACCRUAL_RATE;\n', '        uint startTime = BIRTHDAY.add(SLEEP_TIME);\n', '        if(now > startTime) {\n', '            uint daysFromStart = (now.sub(startTime)) / 1 days;\n', '            uint daysUnprocessed = daysFromStart.sub(accrualDaysProcessed);\n', '            if(daysUnprocessed > 0) {\n', '                hodlUsd = HODL_USD.mul(DAILY_ACCRUAL_RATE).div(PRECISION);\n', '                dailyAccrualRate = DAILY_ACCRUAL_RATE.mul(DAILY_ACCRUAL_RATE_DECAY).div(PRECISION);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Stateful activity-based and time-based rate adjustments\n', '     **************************************************************************************/\n', '\n', '    function _increaseTransactionCount(uint transactionCount) private {\n', '        if(transactionCount>0) {\n', '            uint exBefore = HODL_USD;\n', '            uint exAfter = exBefore.add(USD_TXN_ADJUSTMENT.mul(transactionCount));\n', '            HODL_USD = exAfter;\n', '            emit IncreasedByTransaction(msg.sender, transactionCount, exAfter);\n', '        }\n', '    }\n', '    \n', '    function increaseTransactionCount(uint transactionCount) external onlyOracle {\n', '        _increaseTransactionCount(transactionCount);\n', '    }\n', '    \n', '    function _accrueByTime() private returns(uint hodlUsdNow, uint dailyAccrualRateNow) {\n', '        (hodlUsdNow, dailyAccrualRateNow) = rates();\n', '        if(hodlUsdNow != HODL_USD || dailyAccrualRateNow != DAILY_ACCRUAL_RATE) { \n', '            HODL_USD = hodlUsdNow;\n', '            DAILY_ACCRUAL_RATE = dailyAccrualRateNow; \n', '            accrualDaysProcessed = accrualDaysProcessed + 1; \n', '            emit AccrueByTime(msg.sender, hodlUsdNow, dailyAccrualRateNow);\n', '        } \n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * View functions to enumerate the state\n', '     **************************************************************************************/\n', '    \n', '    // Proportional Library reads this to compute userBal:supply ratio, always using hodl \n', '    function circulatingSupply() external view returns(uint circulating) {\n', '        uint reserveBalance = balance.balanceOf(HODL_ASSET, address(this));\n', '        return TOTAL_SUPPLY.sub(reserveBalance);\n', '    }\n', '    \n', '    // Open orders, FIFO\n', '    function sellOrderCount() public view returns(uint count) { \n', '        return sellOrderIdFifo.count(); \n', '    }\n', '    function sellOrderFirst() public view returns(bytes32 orderId) { \n', '        return sellOrderIdFifo.first(); \n', '    }\n', '    function sellOrderLast() public view returns(bytes32 orderId) { \n', '        return sellOrderIdFifo.last(); \n', '    }  \n', '    function sellOrderIterate(bytes32 orderId) public view returns(bytes32 idBefore, bytes32 idAfter) { \n', '        return(sellOrderIdFifo.previous(orderId), sellOrderIdFifo.next(orderId)); \n', '    }\n', '    function buyOrderCount() public view returns(uint count) { \n', '        return buyOrderIdFifo.count(); \n', '    }\n', '    function buyOrderFirst() public view returns(bytes32 orderId) { \n', '        return buyOrderIdFifo.first(); \n', '    }\n', '    function buyOrderLast() public view returns(bytes32 orderId) { \n', '        return buyOrderIdFifo.last(); \n', '    }    \n', '    function buyOrderIterate(bytes32 orderId) public view returns(bytes32 idBefore, bytes32 idAfter) { \n', '        return(buyOrderIdFifo.previous(orderId), buyOrderIdFifo.next(orderId)); \n', '    }\n', '\n', '    function user(address userAddr) public override view returns(uint balanceEth, uint balanceHodl, uint controlledHodl) {\n', '        return(\n', '            balance.balanceOf(ETH_ASSET, userAddr),\n', '            balance.balanceOf(HODL_ASSET, userAddr),\n', '            balance.additionalControlled(HODL_ASSET, userAddr));\n', '    }\n', '    function isAccruing() public view returns(bool accruing) {\n', '        return now > BIRTHDAY.add(SLEEP_TIME);\n', '    }\n', '    function isConfigured() public view returns(bool initialized) {\n', '        return address(oracle) != UNDEFINED;\n', '    }\n', '    function isRunning() public view returns(bool running) {\n', '        return getRoleMemberCount(MIGRATION_ROLE) == 0;\n', '    }\n', '    function orderLimit() public view returns(uint limitUsd) {\n', '        (uint askUsd, /* uint accrualRate */) = rates();\n', '        return (askUsd > MAX_THRESHOLD_USD) ? 0 : MAX_ORDER_FACTOR * askUsd;\n', '    }\n', '    \n', '    /**************************************************************************************\n', '     * Explore the Proportional Distribution State and internal User Balance History\n', '     **************************************************************************************/ \n', '    \n', '    function period() external view returns(uint _period) {\n', '        return balance.period();\n', '    }\n', '\n', '    // The next unclaimed distribution that will be processed when the user claims it.\n', '\n', '    function nextUserDistributionDetails(address userAddr, bytes32 assetId) external view returns(\n', '        uint amount,\n', '        uint balanceIndex,\n', '        uint distributionIndex,\n', '        bool closed)\n', '    {\n', '        (amount, balanceIndex, distributionIndex, closed) = balance.nextUserDistributionDetails(assetId, userAddr);\n', '    }\n', '\n', '    function distributionCount(bytes32 assetId) external view returns(uint count) {\n', '        count = balance.distributionCount(assetId);\n', '    }\n', '\n', '    function distributionAtIndex(bytes32 assetId, uint index) external view returns(uint denominator, uint amount, uint _period) {\n', '        return balance.distributionAtIndex(assetId, index);\n', '    }\n', '\n', '    // User balance history\n', '\n', '    function userBalanceCount(bytes32 assetId, address userAddr) external view returns(uint count) {\n', '        return balance.userBalanceCount(assetId, userAddr);\n', '    }\n', '\n', '    function userBalanceAtIndex(bytes32 assetId, address userAddr, uint index) external view returns(uint userBalance, uint controlled, uint _period) {\n', '        return balance.userBalanceAtIndex(assetId, userAddr, index);\n', '    }\n', '\n', '    /**************************************************************************************\n', '     * Initialization functions that support data migration\n', '     **************************************************************************************/  \n', '     \n', '    function init(IHTokenReserve _tokenReserve, IHOracle _oracle) external initializer() {\n', '        \n', '        accrualDaysProcessed = _accrualDaysProcessed;\n', '        HODL_USD = _HODL_USD;\n', '        DAILY_ACCRUAL_RATE = _DAILY_ACCRUAL_RATE;\n', '\n', '        assetIds.push(HODL_ASSET);\n', '        assetIds.push(ETH_ASSET);\n', '        \n', '        // initialize Proportional Assets\n', '        balance.init(assetIds, HODL_ASSET, now, DISTRIBUTION_PERIOD, address(this));\n', '        \n', '        // assign the total hodlc supply to the hodlc reserve\n', '        balance.add(HODL_ASSET, address(this), TOTAL_SUPPLY, 0);\n', '        \n', '        // contract instances\n', '        oracle = _oracle;\n', '        tokenReserve = _tokenReserve;       \n', '        \n', '        // configure access control\n', '        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n', '        _setupRole(ADMIN_ROLE, msg.sender);\n', '        _setupRole(ORACLE_ROLE, msg.sender);\n', '        _setupRole(MIGRATION_ROLE, msg.sender);\n', '        _setupRole(RESERVE_ROLE, address(_tokenReserve));\n', '        \n', '        emit InitConfigure(msg.sender, _tokenReserve, _oracle); \n', '    }\n', '\n', '    function initSetDailyAccrualRate(uint rateAsDecimal18) external onlyMigration {\n', '        DAILY_ACCRUAL_RATE = rateAsDecimal18;\n', '        emit SetDailyAccrualRate(msg.sender, rateAsDecimal18);\n', '    }    \n', '\n', '    function initUser(address userAddr, uint hodl) external onlyMigration payable {\n', '        balance.add(ETH_ASSET, userAddr, msg.value, 0);\n', '        balance.add(HODL_ASSET, userAddr, hodl, 0);\n', '        balance.sub(HODL_ASSET, address(this), hodl, 0);\n', '        emit UserInitialized(msg.sender, userAddr, hodl, msg.value);\n', '    }\n', '    \n', '    function initResetUser(address userAddr) external virtual onlyMigration {\n', '        emit UserUninitialized(msg.sender, userAddr);\n', '        balance.add(HODL_ASSET, address(this), balance.balanceOf(HODL_ASSET, userAddr), 0);\n', '        balance.sub(HODL_ASSET, userAddr, balance.balanceOf(HODL_ASSET, userAddr), 0);\n', '        balance.sub(ETH_ASSET, userAddr, balance.balanceOf(ETH_ASSET, userAddr), 0);\n', '        if(balance.balanceOf(ETH_ASSET, userAddr) > 0) {\n', '            (bool success, /* bytes memory data */) = msg.sender.call{ value: balance.balanceOf(ETH_ASSET, userAddr) }("");\n', '            require(success, "rejected by receiver");\n', '        }\n', '    }\n', '    \n', '    // Revoking the last Migration_Role member starts trading (isRunning). Ensure backup ETH_USD is set.\n', '    function revokeRole(bytes32 role, address account) public override {\n', '        require(ETH_USD > 0, "HodlDex, Set EthUsd");\n', '        AccessControl.revokeRole(role, account);\n', '    }\n', '}']