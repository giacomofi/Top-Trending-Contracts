['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-11\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', '/*******************************************************\n', ' *                       Interfaces                    *\n', ' *******************************************************/\n', 'interface IV2Vault {\n', '    function token() external view returns (address);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function pricePerShare() external view returns (uint256);\n', '\n', '    function totalAssets() external view returns (uint256);\n', '\n', '    function apiVersion() external view returns (string memory);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function emergencyShutdown() external view returns (bool);\n', '\n', '    function depositLimit() external view returns (uint256);\n', '}\n', '\n', 'interface IV2Registry {\n', '    function numTokens() external view returns (uint256);\n', '\n', '    function numVaults(address token) external view returns (uint256);\n', '\n', '    function tokens(uint256 tokenIdx) external view returns (address);\n', '\n', '    function latestVault(address token) external view returns (address);\n', '\n', '    function vaults(address token, uint256 tokenIdx)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'interface IOracle {\n', '    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address spender, address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IHelper {\n', '    // Strategies helper\n', '    function assetStrategiesDelegatedBalance(address)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    // Allowances helper\n', '    struct Allowance {\n', '        address owner;\n', '        address spender;\n', '        uint256 amount;\n', '        address token;\n', '    }\n', '\n', '    function allowances(\n', '        address ownerAddress,\n', '        address[] memory tokensAddresses,\n', '        address[] memory spenderAddresses\n', '    ) external view returns (Allowance[] memory);\n', '}\n', '\n', 'interface ManagementList {\n', '    function isManager(address accountAddress) external returns (bool);\n', '}\n', '\n', '/*******************************************************\n', ' *                     Management List                 *\n', ' *******************************************************/\n', '\n', 'contract Manageable {\n', '    ManagementList public managementList;\n', '\n', '    constructor(address _managementListAddress) {\n', '        managementList = ManagementList(_managementListAddress);\n', '    }\n', '\n', '    modifier onlyManagers() {\n', '        bool isManager = managementList.isManager(msg.sender);\n', '        require(isManager, "ManagementList: caller is not a manager");\n', '        _;\n', '    }\n', '}\n', '\n', '/*******************************************************\n', ' *                     Adapter Logic                   *\n', ' *******************************************************/\n', 'contract RegisteryAdapterV2Vault is Manageable {\n', '    /*******************************************************\n', '     *           Common code shared by all adapters        *\n', '     *******************************************************/\n', '\n', '    IOracle public oracle; // The oracle is used to fetch USDC normalized pricing data\n', '    IV2Registry public registry; // The registry is used to fetch the list of vaults and migration data\n', '    IHelper public helper; // A helper utility is used for batch allowance fetching and address array merging\n', '    address[] public positionSpenderAddresses; // A settable list of spender addresses with which to fetch asset allowances\n', '    mapping(address => bool) public assetDeprecated; // Support for deprecating assets. If an asset is deprecated it will not appear is results\n', '    uint256 public numberOfDeprecatedAssets; // Used to keep track of the number of deprecated assets for an adapter\n', '\n', '    /**\n', '     * High level static information about an asset\n', '     */\n', '    struct AssetStatic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        string name; // Asset Name\n', '        string version; // Asset version\n', '        Token token; // Static asset underlying token information\n', '    }\n', '\n', '    /**\n', '     * High level dynamic information about an asset\n', '     */\n', '    struct AssetDynamic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        address tokenId; // Underlying token address;\n', '        TokenAmount underlyingTokenBalance; // Underlying token balances\n', '        TokenAmount delegatedBalance; // Delegated balances\n', '        AssetMetadata metadata; // Metadata specific to the asset type of this adapter\n', '    }\n', '\n', '    /**\n', '     * Static token data\n', '     */\n', '    struct Token {\n', '        address id; // token address\n', '        string name; // token name\n', '        string symbol; // token symbol\n', '        uint8 decimals; // token decimals\n', '    }\n', '\n', '    /**\n', "     * Information about a user's position relative to an asset\n", '     */\n', '    struct Position {\n', '        address assetId; // Asset address\n', '        address tokenId; // Underlying asset token address\n', '        string typeId; // Position typeId (for example "DEPOSIT," "BORROW," "LEND")\n', '        uint256 balance; // asset.balanceOf(account)\n', '        TokenAmount accountTokenBalance; // User account balance of underlying token (token.balanceOf(account))\n', "        TokenAmount underlyingTokenBalance; // Represents a user's asset position in underlying tokens\n", '        Allowance[] tokenAllowances; // Underlying token allowances\n', '        Allowance[] assetAllowances; // Asset allowances\n', '    }\n', '\n', '    /**\n', '     * Token amount representation\n', '     */\n', '    struct TokenAmount {\n', '        uint256 amount; // Amount in underlying token decimals\n', '        uint256 amountUsdc; // Amount in USDC (6 decimals)\n', '    }\n', '\n', '    /**\n', '     * Allowance information\n', '     */\n', '    struct Allowance {\n', '        address owner; // Allowance owner\n', '        address spender; // Allowance spender\n', '        uint256 amount; // Allowance amount (in underlying token)\n', '    }\n', '\n', '    /**\n', '     * Information about the adapter\n', '     */\n', '    struct AdapterInfo {\n', '        address id; // Adapter address\n', '        string typeId; // Adapter typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        string categoryId; // Adapter categoryId (for example "VAULT")\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsStatic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetStatic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetStatic[] memory _assets = new AssetStatic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetStatic memory _asset = assetStatic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsDynamic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetDynamic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetDynamic[] memory _assets = new AssetDynamic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetDynamic memory _asset = assetDynamic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information for all assets\n', '     */\n', '    function assetsStatic() external view returns (AssetStatic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsStatic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information for all assets\n', '     */\n', '    function assetsDynamic() external view returns (AssetDynamic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsDynamic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch underlying token allowances relative to an asset.\n', '     * This is useful for determining whether or not a user has token approvals\n', '     * to allow depositing into an asset\n', '     */\n', '    function tokenAllowances(\n', '        address accountAddress,\n', '        address tokenAddress,\n', '        address assetAddress\n', '    ) public view returns (Allowance[] memory) {\n', '        address[] memory tokenAddresses = new address[](1);\n', '        address[] memory assetAddresses = new address[](1);\n', '        tokenAddresses[0] = tokenAddress;\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    tokenAddresses,\n', '                    assetAddresses\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Fetch asset allowances based on positionSpenderAddresses (configurable).\n', '     * This is useful to determine if a particular zap contract is approved for the asset (zap out use case)\n', '     */\n', '    function assetAllowances(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Allowance[] memory)\n', '    {\n', '        address[] memory assetAddresses = new address[](1);\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    assetAddresses,\n', '                    positionSpenderAddresses\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Fetch basic static token metadata\n', '     */\n', '    function tokenMetadata(address tokenAddress)\n', '        internal\n', '        view\n', '        returns (Token memory)\n', '    {\n', '        IERC20 _token = IERC20(tokenAddress);\n', '        return\n', '            Token({\n', '                id: tokenAddress,\n', '                name: _token.name(),\n', '                symbol: _token.symbol(),\n', '                decimals: _token.decimals()\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Deprecate or undeprecate an asset. Deprecated assets will not appear in any adapter method call response\n', '     */\n', '    function setAssetDeprecated(address assetAddress, bool newDeprecationStatus)\n', '        public\n', '        onlyManagers\n', '    {\n', '        bool currentDeprecationStatus = assetDeprecated[assetAddress];\n', '        if (currentDeprecationStatus == newDeprecationStatus) {\n', '            revert("Adapter: Unable to change asset deprecation status");\n', '        }\n', '        if (newDeprecationStatus == true) {\n', '            numberOfDeprecatedAssets++;\n', '        } else {\n', '            numberOfDeprecatedAssets--;\n', '        }\n', '        assetDeprecated[assetAddress] = newDeprecationStatus;\n', '    }\n', '\n', '    /**\n', '     * Set position spender addresses. Used by `assetAllowances(address,address)`.\n', '     */\n', '    function setPositionSpenderAddresses(address[] memory addresses)\n', '        public\n', '        onlyManagers\n', '    {\n', '        positionSpenderAddresses = addresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch TVL for adapter\n', '     */\n', '    function assetsTvl() external view returns (uint256) {\n', '        uint256 tvl;\n', '        address[] memory assetAddresses = assetsAddresses();\n', '        uint256 numberOfAssets = assetAddresses.length;\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = assetAddresses[assetIdx];\n', '            uint256 _assetTvl = assetTvl(assetAddress);\n', '            tvl += _assetTvl;\n', '        }\n', '        return tvl;\n', '    }\n', '\n', '    /**\n', '     * Configure adapter\n', '     */\n', '    constructor(\n', '        address _registryAddress,\n', '        address _oracleAddress,\n', '        address _managementListAddress,\n', '        address _helperAddress\n', '    ) Manageable(_managementListAddress) {\n', '        require(\n', '            _managementListAddress != address(0),\n', '            "Missing management list address"\n', '        );\n', '        require(_registryAddress != address(0), "Missing registry address");\n', '        require(_oracleAddress != address(0), "Missing oracle address");\n', '        registry = IV2Registry(_registryAddress);\n', '        oracle = IOracle(_oracleAddress);\n', '        helper = IHelper(_helperAddress);\n', '    }\n', '\n', '    /*******************************************************\n', '     * Common code shared by v1 vaults, v2 vaults and earn *\n', '     *******************************************************/\n', '\n', '    /**\n', '     * Fetch asset positions of an account given an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function positionsOf(\n', '        address accountAddress,\n', '        address[] memory _assetsAddresses\n', '    ) public view returns (Position[] memory) {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        Position[] memory positions = new Position[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            Position memory position = positionOf(accountAddress, assetAddress);\n', '            positions[assetIdx] = position;\n', '        }\n', '        return positions;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset positins for an account for all assets\n', '     */\n', '    function positionsOf(address accountAddress)\n', '        external\n', '        view\n', '        returns (Position[] memory)\n', '    {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return positionsOf(accountAddress, _assetsAddresses);\n', '    }\n', '\n', '    /*******************************************************\n', '     *                 V2 Adapter (unique logic)           *\n', '     *******************************************************/\n', '    /**\n', '     * Return information about the adapter\n', '     */\n', '    function adapterInfo() public view returns (AdapterInfo memory) {\n', '        return\n', '            AdapterInfo({\n', '                id: address(this),\n', '                typeId: "VAULT_V2",\n', '                categoryId: "VAULT"\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Metadata specific to this asset type\n', '     */\n', '    struct AssetMetadata {\n', '        string symbol; // Vault symbol\n', '        uint256 pricePerShare; // Vault pricePerShare\n', '        bool migrationAvailable; // True if a migration is available for this vault\n', '        address latestVaultAddress; // Latest vault migration address\n', '        uint256 depositLimit; // Deposit limit of asset\n', '        bool emergencyShutdown; // Vault is in emergency shutdown mode\n', '    }\n', '\n', '    /**\n', '     * Fetch the underlying token address of an asset\n', '     */\n', '    function underlyingTokenAddress(address assetAddress)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = vault.token();\n', '        return tokenAddress;\n', '    }\n', '\n', '    /**\n', '     * Fetch the total number of assets for this adapter\n', '     */\n', '    function assetsLength() public view returns (uint256) {\n', '        uint256 numTokens = registry.numTokens();\n', '        uint256 numVaults;\n', '        for (uint256 tokenIdx = 0; tokenIdx < numTokens; tokenIdx++) {\n', '            address currentToken = registry.tokens(tokenIdx);\n', '            uint256 numVaultsForToken = registry.numVaults(currentToken);\n', '            numVaults += numVaultsForToken;\n', '        }\n', '        return numVaults - numberOfDeprecatedAssets;\n', '    }\n', '\n', '    /**\n', '     * Fetch all asset addresses for this adapter\n', '     */\n', '    function assetsAddresses() public view returns (address[] memory) {\n', '        uint256 numVaults = assetsLength();\n', '        address[] memory _assetsAddresses = new address[](numVaults);\n', '        uint256 numTokens = registry.numTokens();\n', '        uint256 currentVaultIdx;\n', '        for (uint256 tokenIdx = 0; tokenIdx < numTokens; tokenIdx++) {\n', '            address currentTokenAddress = registry.tokens(tokenIdx);\n', '            uint256 numVaultsForToken = registry.numVaults(currentTokenAddress);\n', '            for (\n', '                uint256 vaultTokenIdx = 0;\n', '                vaultTokenIdx < numVaultsForToken;\n', '                vaultTokenIdx++\n', '            ) {\n', '                address currentAssetAddress =\n', '                    registry.vaults(currentTokenAddress, vaultTokenIdx);\n', '                bool assetIsNotDeprecated =\n', '                    assetDeprecated[currentAssetAddress] == false;\n', '                if (assetIsNotDeprecated) {\n', '                    _assetsAddresses[currentVaultIdx] = currentAssetAddress;\n', '                    currentVaultIdx++;\n', '                }\n', '            }\n', '        }\n', '        return _assetsAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an asset\n', '     */\n', '    function assetStatic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetStatic memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        return\n', '            AssetStatic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                name: vault.name(),\n', '                version: vault.apiVersion(),\n', '                token: tokenMetadata(tokenAddress)\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an asset\n', '     */\n', '    function assetDynamic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetDynamic memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 totalSupply = vault.totalSupply();\n', '        uint256 pricePerShare = 0;\n', '        bool vaultHasShares = totalSupply != 0;\n', '        if (vaultHasShares) {\n', '            pricePerShare = vault.pricePerShare();\n', '        }\n', '\n', '        address latestVaultAddress = registry.latestVault(tokenAddress);\n', '        bool migrationAvailable = latestVaultAddress != assetAddress;\n', '\n', '        AssetMetadata memory metadata =\n', '            AssetMetadata({\n', '                symbol: vault.symbol(),\n', '                pricePerShare: pricePerShare,\n', '                migrationAvailable: migrationAvailable,\n', '                latestVaultAddress: latestVaultAddress,\n', '                depositLimit: vault.depositLimit(),\n', '                emergencyShutdown: vault.emergencyShutdown()\n', '            });\n', '\n', '        TokenAmount memory underlyingTokenBalance =\n', '            TokenAmount({\n', '                amount: assetBalance(assetAddress),\n', '                amountUsdc: assetTvl(assetAddress)\n', '            });\n', '\n', '        uint256 delegatedBalanceAmount =\n', '            helper.assetStrategiesDelegatedBalance(assetAddress);\n', '        TokenAmount memory delegatedBalance =\n', '            TokenAmount({\n', '                amount: delegatedBalanceAmount,\n', '                amountUsdc: oracle.getNormalizedValueUsdc(\n', '                    tokenAddress,\n', '                    delegatedBalanceAmount\n', '                )\n', '            });\n', '\n', '        return\n', '            AssetDynamic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                tokenId: tokenAddress,\n', '                underlyingTokenBalance: underlyingTokenBalance,\n', '                delegatedBalance: delegatedBalance,\n', '                metadata: metadata\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch asset position of an account given an asset address\n', '     */\n', '    function positionOf(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Position memory)\n', '    {\n', '        IV2Vault _asset = IV2Vault(assetAddress);\n', '        uint8 assetDecimals = _asset.decimals();\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        IERC20 token = IERC20(tokenAddress);\n', '        uint256 balance = _asset.balanceOf(accountAddress);\n', '        uint256 _accountTokenBalance =\n', '            (balance * _asset.pricePerShare()) / 10**assetDecimals;\n', '        uint256 _underlyingTokenBalance = token.balanceOf(accountAddress);\n', '        return\n', '            Position({\n', '                assetId: assetAddress,\n', '                tokenId: tokenAddress,\n', '                typeId: "deposit",\n', '                balance: balance,\n', '                underlyingTokenBalance: TokenAmount({\n', '                    amount: _underlyingTokenBalance,\n', '                    amountUsdc: oracle.getNormalizedValueUsdc(\n', '                        tokenAddress,\n', '                        _underlyingTokenBalance\n', '                    )\n', '                }),\n', '                accountTokenBalance: TokenAmount({\n', '                    amount: _accountTokenBalance,\n', '                    amountUsdc: oracle.getNormalizedValueUsdc(\n', '                        tokenAddress,\n', '                        _accountTokenBalance\n', '                    )\n', '                }),\n', '                tokenAllowances: tokenAllowances(\n', '                    accountAddress,\n', '                    tokenAddress,\n', '                    assetAddress\n', '                ),\n', '                assetAllowances: assetAllowances(accountAddress, assetAddress)\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch asset balance in underlying tokens\n', '     */\n', '    function assetBalance(address assetAddress) public view returns (uint256) {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        return vault.totalAssets();\n', '    }\n', '\n', '    /**\n', '     * Fetch TVL of an asset\n', '     */\n', '    function assetTvl(address assetAddress) public view returns (uint256) {\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 amount = assetBalance(assetAddress);\n', '        uint256 delegatedBalanceAmount =\n', '            helper.assetStrategiesDelegatedBalance(assetAddress);\n', '        amount -= delegatedBalanceAmount;\n', '        uint256 tvl = oracle.getNormalizedValueUsdc(tokenAddress, amount);\n', '        return tvl;\n', '    }\n', '}']