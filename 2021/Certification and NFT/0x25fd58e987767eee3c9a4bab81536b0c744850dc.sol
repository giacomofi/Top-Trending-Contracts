['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', 'pragma solidity 0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// -- WyArbiV3 -- //\n', 'contract WyArbiV3 {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using address_make_payable for address;\n', '\n', '    struct MyCustomData {       // 还款信息\n', '        address token;          // token\n', '        uint256 repayAmount;    // 还款数量\n', '    }\n', '\n', '    struct StrategyData {       // 策略信息\n', '        address token_want;     // 需要的token\n', '        address token_media;    // 中转token\n', '        address protocol1;      // 协议1地址\n', '        address protocol2;      // 协议2地址\n', '        uint256 in_amount;      // 输入数量\n', '    }\n', '\n', '    address superMan;\n', '    address keeperDaoAddress;\n', '    address uniswapAddress;\n', '    address WETHAddress;\n', '    address USDTAddress;\n', '    address GasTokenV2;\n', '\n', '    mapping (address => mapping (address => int128)) public tokenId;  //protocol地址->token地址->tokenId\n', '    mapping (address => uint256) public functionId;                   //protocol地址->functionId\n', '\n', '    bool if_turnout = true;             // 盈利是否转出\n', '    bool if_gastoken = true;            // 是否使用GasToken\n', '    StrategyData strategy_data;         // 策略信息\n', '\n', '    constructor () public {\n', '        superMan = address(tx.origin);\n', '        keeperDaoAddress = 0x35fFd6E268610E764fF6944d07760D0EFe5E40E5;\n', '        uniswapAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '        WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '        USDTAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '        GasTokenV2 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n', '\n', '        // curve3pool tokenId DAI USDC USDT\n', '        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 0;\n', '        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\n', '        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 2;\n', '\n', '        // curveYpool tokenId DAI USDC USDT\n', '        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 0;\n', '        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\n', '        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 2;\n', '        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0x0000000000085d4780B73119b644AE5ecd22b376)] = 3;\n', '\n', '        // stableswap tokenId USDP DAI USDC USDT\n', '        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0x1456688345527bE1f37E9e627DA0837D6f08C925)] = 0;\n', '        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 1;\n', '        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 2;\n', '        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 3;\n', '\n', '        // dodo tokenId USDT USDC\n', '        tokenId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 0;\n', '        tokenId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\n', '\n', '        // btcswap tokenId TBTC WBTC renBTC sBTC\n', '        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa)] = 0;\n', '        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)] = 1;\n', '        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D)] = 2;\n', '        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6)] = 3;\n', '\n', '        // curve3Pool functionId\n', '        functionId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)] = 1;\n', '        // curveYPool functionId\n', '        functionId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)] = 2;\n', '        // stableswap functionId\n', '        functionId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)] = 3;\n', '        // component functionId\n', '        functionId[address(0x49519631B404E06ca79C9C7b0dC91648D86F08db)] = 4;\n', '        functionId[address(0x6477960dd932d29518D7e8087d5Ea3D11E606068)] = 4;\n', '        // dodo functionId\n', '        functionId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)] = 5;\n', '        // btcswap functionId\n', '        functionId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)] = 6;\n', '        // uniswapv2 functionId\n', '        functionId[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = 7;\n', '        // sushiswap functionId\n', '        functionId[address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F)] = 7;\n', '        // balancer functionId\n', '        functionId[address(0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21)] = 8;\n', '    }\n', '\n', '    // 发起闪电贷\n', '    function initiateFlashLoan(address token, uint256 amount) public onlyOwner {\n', '        ILiquidity(keeperDaoAddress).borrow(\n', '            token,\n', '            amount,\n', '            abi.encodeWithSelector(this.callFunction.selector, token, amount.add(1))\n', '        );\n', '    }\n', '\n', '    // 闪电贷实现\n', '    function callFunction(address token, uint256 repay_amount) public {\n', '        // 操作\n', '        uint256 output_amount = operation();\n', '\n', '        // 检查盈利\n', '        require(output_amount > repay_amount, "no profit!");\n', '        uint256 profit = output_amount - repay_amount;\n', '\n', '        // 还款\n', '        IERC20(token).transfer(keeperDaoAddress, repay_amount);\n', '\n', '        // 盈利转出\n', '        if (if_turnout) {\n', '            if (token == WETHAddress) {\n', '                WETHToETH(profit);\n', '                turnOutETH(profit);\n', '            } else {\n', '                uint256 eth_out = uniswapTokensForETH(token, profit);\n', '                turnOutETH(eth_out);\n', '            }\n', '        }\n', '    }\n', '\n', '    // 操作\n', '    function operation() public returns (uint256) {\n', '        uint256 media_amount = ExchangeBase(\n', '            strategy_data.protocol1,\n', '            strategy_data.token_want,\n', '            strategy_data.token_media,\n', '            strategy_data.in_amount\n', '        );\n', '        if (media_amount == 0) {\n', '            return strategy_data.in_amount;\n', '        }\n', '        uint256 output_amount = ExchangeBase(\n', '            strategy_data.protocol2,\n', '            strategy_data.token_media,\n', '            strategy_data.token_want,\n', '            media_amount\n', '        );\n', '        return output_amount;\n', '    }\n', '\n', '    // 入口\n', '    function execute(address token_want, address token_media, address protocol1, address protocol2,\n', '        uint256 in_amount, uint256 free_value) public {\n', '\n', '        if (if_gastoken) {\n', '            freeGas(free_value);\n', '        }\n', '\n', '        strategy_data.in_amount = in_amount;\n', '        strategy_data.token_want = token_want;\n', '        strategy_data.token_media = token_media;\n', '        strategy_data.protocol1 = protocol1;\n', '        strategy_data.protocol2 = protocol2;\n', '\n', '        initiateFlashLoan(token_want, in_amount);\n', '    }\n', '\n', '    // ExchangeBase\n', '    function ExchangeBase(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 function_id = functionId[protocol];\n', '        uint256 output_amount = 0;\n', '\n', '        if (token_in == USDTAddress) {\n', '            IERC20(token_in).safeApprove(protocol, 0);\n', '            IERC20(token_in).safeApprove(protocol, in_amount);\n', '        } else {\n', '            IERC20(token_in).approve(protocol, in_amount);\n', '        }\n', '\n', '        if (function_id == 1) {\n', '            output_amount = ICurveFiExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 2) {\n', '            output_amount = ICurveFiExchangeUnderlying(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 3) {\n', '            output_amount = IStableSwapExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 4) {\n', '            output_amount = IComponentExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 5) {\n', '            output_amount = IDODOExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 6) {\n', '            output_amount = IBTCSwapExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 7) {\n', '            output_amount = IUniswapExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        if (function_id == 8) {\n', '            output_amount = IBalancerExchange(protocol, token_in, token_out, in_amount);\n', '        }\n', '        return output_amount;\n', '    }\n', '\n', '    // ICurveFiExchange functionId=1\n', '    function ICurveFiExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 balance = IERC20(token_out).balanceOf(address(this));\n', '        ICurveFi(protocol).exchange(tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\n', '\n', '        return IERC20(token_out).balanceOf(address(this)).sub(balance);\n', '    }\n', '\n', '    // ICurveFiExchangeUnderlying functionId=2\n', '    function ICurveFiExchangeUnderlying(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 balance = IERC20(token_out).balanceOf(address(this));\n', '        ICurveFi(protocol).exchange_underlying(tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\n', '\n', '        return IERC20(token_out).balanceOf(address(this)).sub(balance);\n', '    }\n', '\n', '    // IStableSwapExchange functionId=3\n', '    function IStableSwapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 out_amount = IStableSwap(protocol).exchange_underlying(\n', '            tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\n', '\n', '        return out_amount;\n', '    }\n', '\n', '    // IComponentExchange functionId=4\n', '    function IComponentExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 out_amount = IComponent(protocol).originSwap(token_in, token_out, in_amount, 0, uint256(block.timestamp).add(100));\n', '\n', '        return out_amount;\n', '    }\n', '\n', '    // IDODOExchange functionId=5  Base=0 Quote=1 只支持token_in=base token_out=quote\n', '    function IDODOExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        int128 token_in_id = tokenId[protocol][token_in];\n', '        int128 token_out_id = tokenId[protocol][token_out];\n', '        uint256 out_amount;\n', '        if (token_in_id == 0 && token_out_id == 1) {\n', "            out_amount = IDODO(protocol).sellBaseToken(in_amount, 0, '');\n", '        } else {\n', '            revert("token_id wrong for dodo!");\n', '        }\n', '        return out_amount;\n', '    }\n', '\n', '    // IBTCSwapExchange functionId=6\n', '    function IBTCSwapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint8 token_in_id = uint8(tokenId[protocol][token_in]);\n', '        uint8 token_out_id = uint8(tokenId[protocol][token_out]);\n', '\n', '        uint256 out_amount = IBTCswap(protocol).swap(token_in_id, token_out_id, in_amount, 0, uint256(block.timestamp).add(100));\n', '        return out_amount;\n', '    }\n', '\n', '    // IUniswapExchange functionId=7\n', '    function IUniswapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        address[] memory uniData = new address[](2);\n', '        uniData[0] = token_in;\n', '        uniData[1] = token_out;\n', '        uint[] memory amounts = UniswapV2Router(protocol).swapExactTokensForTokens(in_amount, 0, uniData, address(this),\n', '            uint256(block.timestamp).add(100));\n', '        return uint256(amounts[amounts.length - 1]);\n', '    }\n', '\n', '    // IBalancerExchange functionId=8\n', '    function IBalancerExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\n', '        uint256 out_amount = IBalancerRouter(protocol).smartSwapExactIn(TokenInterface(token_in),\n', '                                                                        TokenInterface(token_out), in_amount, 0, 1);\n', '        return out_amount;\n', '    }\n', '\n', '    // Uniswap\n', '    function uniswapTokensForETH(address token, uint256 amount) public returns(uint256) {\n', '        IERC20(token).safeApprove(uniswapAddress, 0);\n', '        IERC20(token).safeApprove(uniswapAddress, amount);\n', '        address[] memory uniData = new address[](2);\n', '        uniData[0] = token;\n', '        uniData[1] = WETHAddress;\n', '        uint[] memory amounts = UniswapV2Router(uniswapAddress).swapExactTokensForETH(amount, 0, uniData, address(this),\n', '                        uint256(block.timestamp).add(100));\n', '        return uint256(amounts[amounts.length - 1]);\n', '    }\n', '\n', '    // get\n', '    function getSuperMan() public view returns(address) {\n', '        return superMan;\n', '    }\n', '\n', '    function getKeeperDaoAddress() public view returns(address) {\n', '        return keeperDaoAddress;\n', '    }\n', '\n', '    function getUniswapAddress() public view returns(address) {\n', '        return uniswapAddress;\n', '    }\n', '\n', '    function getGasTokenV2Address() public view returns(address) {\n', '        return GasTokenV2;\n', '    }\n', '\n', '    function getTokenId(address protocol, address token) public view returns(int128) {\n', '        return tokenId[protocol][token];\n', '    }\n', '\n', '    function getFunctionId(address protocol) public view returns(uint256) {\n', '        return functionId[protocol];\n', '    }\n', '\n', '    function getTokenBalance(address token) public view returns(uint256) {\n', '        return IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    // set\n', '    function transferOwnership(address new_owner) public onlyOwner {\n', '        superMan = new_owner;\n', '    }\n', '\n', '    function setTokenID(address protocol, address token, int128 id) public onlyOwner {\n', '        tokenId[protocol][token] = id;\n', '    }\n', '\n', '    function setFunctionId(address protocol, uint256 id) public onlyOwner {\n', '        functionId[protocol] = id;\n', '    }\n', '\n', '    function setIfTurnout(bool tof) public onlyOwner {\n', '        if_turnout = tof;\n', '    }\n', '\n', '    function setIfGastoken(bool tof) public onlyOwner {\n', '        if_gastoken = tof;\n', '    }\n', '\n', '    function setKeeperDaoAddress(address new_address) public onlyOwner {\n', '        keeperDaoAddress = new_address;\n', '    }\n', '\n', '    function setUniswapAddress(address new_address) public onlyOwner {\n', '        uniswapAddress = new_address;\n', '    }\n', '\n', '    function setGasTokenV2Address(address new_address) public onlyOwner {\n', '        GasTokenV2 = new_address;\n', '    }\n', '\n', '    function turnOutToken(address token, uint256 amount) public onlyOwner {\n', '        IERC20(token).safeTransfer(superMan, amount);\n', '    }\n', '\n', '    function transferToken(address token, address recipient, uint256 amount) public onlyOwner {\n', '        IERC20(token).safeTransfer(recipient, amount);\n', '    }\n', '\n', '    function turnOutETH(uint256 amount) public {\n', '        address payable addr = superMan.make_payable();\n', '        addr.transfer(amount);\n', '    }\n', '\n', '    function transferETH(address recipient, uint256 amount) public onlyOwner {\n', '        address payable addr = recipient.make_payable();\n', '        addr.transfer(amount);\n', '    }\n', '\n', '    function WETHToETH(uint256 amount) public {\n', '        WETH9(WETHAddress).withdraw(amount);\n', '    }\n', '\n', '    function storeGas(uint256 value) public onlyOwner {\n', '        IGasToken(GasTokenV2).mint(value);\n', '    }\n', '\n', '    function freeGas(uint256 value) public onlyOwner {\n', '        IGasToken(GasTokenV2).freeUpTo(value);\n', '    }\n', '\n', '    modifier onlyOwner(){\n', '        require(address(msg.sender) == superMan, "No authority");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {}\n', '}\n', '\n', '// -- interface -- //\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// Component\n', 'interface IComponent {\n', '    function originSwap (\n', '        address _origin,\n', '        address _target,\n', '        uint _originAmount,\n', '        uint _minTargetAmount,\n', '        uint _deadline\n', '    ) external returns(uint);\n', '}\n', '\n', '// Curve.finance\n', 'interface ICurveFi {\n', '    function exchange(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\n', '    function exchange_underlying(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\n', '}\n', '\n', 'interface IStableSwap {\n', '    function exchange_underlying(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external returns (uint256);\n', '}\n', '\n', '// DODO\n', 'interface IDODO {\n', '    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256);\n', '}\n', '\n', '// BTCswap\n', 'interface IBTCswap{\n', '    function swap(uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx, uint256 minDy, uint256 deadline) external returns (uint256);\n', '}\n', '\n', '// Balancer\n', 'interface TokenInterface {\n', '    function balanceOf(address) external view returns (uint);\n', '    function allowance(address, address) external view returns (uint);\n', '    function approve(address, uint) external returns (bool);\n', '    function transfer(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '    function deposit() external payable;\n', '    function withdraw(uint) external;\n', '}\n', 'interface IBalancerRouter {\n', '    function smartSwapExactIn(TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountIn,\n', '                              uint minTotalAmountOut, uint nPools)   external returns (uint);\n', '}\n', '\n', '// Uniswap\n', 'interface UniswapV2Router {\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '     function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '}\n', '\n', '// WETH\n', 'interface WETH9 {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', '// GasToken\n', 'interface IGasToken {\n', '    function mint(uint256 value) external;\n', '    function freeUpTo(uint256 value) external returns (uint256);\n', '}\n', '\n', 'interface ILiquidity {\n', '    function borrow(address _token, uint256 _amount, bytes calldata _data) external;\n', '}\n', '\n', '// -- library -- //\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library address_make_payable {\n', '   function make_payable(address x) internal pure returns (address payable) {\n', '      return address(uint160(x));\n', '   }\n', '}']