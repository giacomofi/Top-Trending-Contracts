['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-17\n', '*/\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n', '    external returns (bytes4);\n', '}\n', '\n', '\n', 'interface IGoaldDAO721 {\n', '    /** Updates the owner of a deployed Goald. */\n', '    function setGoaldOwner(uint256 id) external;\n', '}\n', '\n', '/*\n', ' * This is an implementation of the ERC721 standard for the Goald project that acts as a psuedo NFT (only has one token).\n', ' *\n', ' * See: @openzeppelin/contracts/token/ERC721/ERC721.sol\n', ' */\n', '\n', 'contract Goald721 {\n', '    //// ERC165 ////\n', '    \n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /// IERC721 ///\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    //// ERC721 ////\n', '\n', '    /*\n', "     *     bytes4(keccak256('balanceOf(address)'))                              == 0x70a08231\n", "     *     bytes4(keccak256('ownerOf(uint256)'))                                == 0x6352211e\n", "     *     bytes4(keccak256('approve(address,uint256)'))                        == 0x095ea7b3\n", "     *     bytes4(keccak256('getApproved(uint256)'))                            == 0x081812fc\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)'))                 == 0xa22cb465\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)'))               == 0xe985e9c5\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)'))           == 0x23b872dd\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)'))       == 0x42842e0e\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n", '     *\n', '     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^\n', '     *        0x081812fc ^ 0xa22cb465 ^ 0xe985e9c5 ^\n', '     *        0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n', '     */\n', '    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    /*\n', "     *     bytes4(keccak256('name()')) == 0x06fdde03\n", "     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n", "     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n", '     *\n', '     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n', '     */\n', '    bytes4 private constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /** @dev The address that is allowed to `safeTransferFrom()` the token. */\n', '    address _approvedTransferer;\n', '\n', '    /** @dev The addresses that are always approved and also set third-party approvals. */\n', '    mapping(address => bool) _approveForAllAddresses;\n', '    \n', '    /** @dev Token name. */\n', '    string  private _name;\n', '\n', '    /** @dev Token symbol. */\n', '    string  private _symbol;\n', '    \n', '    /** @dev We only need to track ownership as a state rather than a balance since each Goald contract only issues a single token. */\n', '    address internal _owner;\n', '\n', '    /** @dev We are only tracking a single token, so we can manage its id as state. */\n', '    uint256 internal _tokenId;\n', '\n', '    /// Goald ///\n', '    \n', '    /** @dev The address of the Goald DAO which fees will be paid into. */\n', '    address internal _daoAddress;\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n', '     */\n', '    constructor (string memory name, string memory symbol, uint256 tokenId) public {\n', '        //// ERC165 ////\n', '        \n', '        // Derived contracts need only register support for their own interfaces, we register support for ERC165 itself here.\n', '        _supportedInterfaces[INTERFACE_ID_ERC165] = true;\n', '\n', '        // Register the supported interface to conform to ERC721 via ERC165.\n', '        _supportedInterfaces[INTERFACE_ID_ERC721] = true;\n', '\n', '        // Register the ERC721MEtatadata extension.\n', '        // NOTE: `tokenURI(uint256)` is not implemented in this contract.\n', '        _supportedInterfaces[INTERFACE_ID_ERC721_METADATA] = true;\n', '\n', '\n', '        //// ERC721 ////\n', '\n', '        _name    = name;\n', '        _symbol  = symbol;\n', '        _tokenId = tokenId;\n', '    }\n', '\n', '    //// ERC165 ////\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /// ERC721  - Views ///\n', '\n', '    /**\n', '     * @dev See {IERC721-balanceOf}.\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256) {\n', '        return owner == _owner ? 1 : 0;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address) {\n', '        require(tokenId == _tokenId, "Wrong token id");\n', '\n', '        return _approvedTransferer;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool) {\n', '        require(owner == _owner, "Not owner");\n', '\n', '        return _approveForAllAddresses[operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-name}.\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-ownerOf}.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address) {\n', '        return tokenId == _tokenId ? _owner : address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-symbol}.\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    //// ERC721 - Non Views ////\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) external {\n', '        require(\n', '               tokenId == _tokenId\n', '            && (\n', '                   msg.sender == _owner\n', '                || _approveForAllAddresses[msg.sender]\n', '               )\n', '        , "Wrong token or not authorized");\n', '\n', '        _approvedTransferer = to;\n', '\n', '        emit Approval(_owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, ""), "ERC721: not ERC721Receiver");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: not ERC721Receiver");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external {\n', '        require(msg.sender == _owner, "Not owner");\n', '\n', '        _approveForAllAddresses[operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external {\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    //// ERC721 - Internal ////\n', '    \n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) internal returns (bool) {\n', "        // If the recipient isn't a contract we can move on. This method relies in extcodesize, which returns 0 for contracts in\n", '        // construction, since the code is only stored at the end of the constructor execution.\n', '        uint256 size;\n', '        assembly { size := extcodesize(to) }\n', '        if (size == 0) {\n', '            return true;\n', '        }\n', '\n', '        // Otherwise validate that they can receive the token.\n', '        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            msg.sender,\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ));\n', '        if (success) {\n', '            bytes4 retval = abi.decode(returndata, (bytes4));\n', '            return (retval == ERC721_RECEIVED);\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert("ERC721: not ERC721Receiver");\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` representation.\n', '     */\n', '    function _toString(uint256 value) internal pure returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = byte(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n', '        require(\n', '            // Throw these in here as well to save gas.\n', '               to != address(0)\n', '            && tokenId == _tokenId\n', '\n', '            && from == _owner\n', '            && (msg.sender == _owner || msg.sender ==_approvedTransferer || _approveForAllAddresses[msg.sender])\n', '        , "Not authorized");\n', '\n', '        // Clear approvals from the previous owner.\n', '        _approvedTransferer = address(0);\n', '\n', '        // Update the owner.\n', '        _owner = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '\n', '        // GoaldDAO.setGoaldOwner transforms the id into an index using its `_idOffset`.\n', '        IGoaldDAO721(_daoAddress).setGoaldOwner(tokenId - 1);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IGoaldDAO {\n', '    /** Returns the next Goald id so that we have a unique ID for each NFT, regardless of which deployer was used. */\n', '    function getNextGoaldId() external view returns (uint256);\n', '\n', '    /** Returns the current address that fees will be sent to. */\n', '    function getProxyAddress() external view returns (address);\n', '\n', '    /** Return the metadata for a specific Goald. */\n', '    function getTokenURI(uint256 tokenId) external view returns (string memory);\n', '\n', '    /** Returns the address of the uniswap router. */\n', '    function getUniswapRouterAddress() external view returns (address);\n', '\n', '    /** Returns true if this deployer is allowed to deploy a goald. */\n', '    function isAllowedDeployer(address deployer) external view returns (bool);\n', '\n', '    /** Lets the DAO know that a Goald was created. */\n', '    function notifyGoaldCreated(address creator, address goaldAddress) external;\n', '\n', '    /** Updates the owner of a deployed Goald. */\n', '    function setGoaldOwner(uint256 id) external;\n', '}\n', '\n', 'contract GoaldFlexibleDeployer {\n', '    address constant DAO_ADDRESS = 0x544664F896eD703Afa025c8465903249D8f1C65A;\n', '\n', '    event GoaldDeployed(address goaldAddress);\n', '\n', '    /**\n', '     * See the constructor of the Goald contract for details on the parameters. There is no concern for reentrancy since this is the\n', '     * only function, and multiple calls will probably hit the block gas limit very quickly.\n', '     */\n', '    function deploy(\n', '        address collateralToken,\n', '        address paymentToken,\n', '        uint96  fee,\n', '        uint8   feeIntervalDays,\n', '        uint16  totalIntervals,\n', '        string memory name\n', '    ) external returns (address) {\n', '        // Make sure that we are allowed to create new Goald.\n', '        IGoaldDAO latestDAO = IGoaldDAO(IGoaldDAO(DAO_ADDRESS).getProxyAddress());\n', '        require(latestDAO.getProxyAddress() == address(latestDAO), "DAO address mismatch");\n', '        require(latestDAO.isAllowedDeployer(address(this)), "Not allowed deployer");\n', '\n', '        // Create the goald.\n', '        GoaldFlexible goald = new GoaldFlexible(\n', '            address(latestDAO),\n', '            msg.sender,\n', '            name,\n', '            latestDAO.getNextGoaldId(),\n', '            collateralToken,\n', '            paymentToken,\n', '            latestDAO.getUniswapRouterAddress(),\n', '            fee,\n', '            feeIntervalDays,\n', '            totalIntervals\n', '        );\n', '        address goaldAddress = address(goald);\n', '\n', '        // Tell the proxy we created a goald.\n', '        latestDAO.notifyGoaldCreated(msg.sender, goaldAddress);\n', '\n', '        // Hello world!\n', '        emit GoaldDeployed(goaldAddress);\n', '\n', '        return goaldAddress;\n', '    }\n', '}\n', '\n', 'contract GoaldFlexible is Goald721 {\n', '    // The masks and shift distances for each value from the packed state variable. This works for both arithmatic and logical shifts,\n', '    // though currrently shifts are logical. This is for big endian values.\n', '    // READ:\n', '    //      1) AND the MASK with the packed values to expose the slot\n', '    //      2) RIGHT SHIFT to get the raw value\n', '    //\n', '    //      value = (_staticValues & MASK) >> SHIFT\n', '    //      \n', '    // WRITE:\n', '    //      1) LEFT SHIFT to position with the slot\n', '    //      2) AND the MASK with the shifted value, to get rid of dirty bits\n', '    //      3) AND the NEGATIVE MASK with the packed values to wipe the slot\n', '    //      4) OR the shifted value to update\n', '    //\n', '    //      _staticValues = ((value << SHIFT) & MASK) | (_staticValues & ~MASK)\n', '    uint256 private constant FEE_MASK                     = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '    uint256 private constant FEE_SHIFT                    = 0;\n', '\n', '    uint256 private constant FEE_INTERVAL_DAYS_MASK       = 0x1FF000000000000000000000000000000000000000000;\n', '    uint256 private constant FEE_INTERVAL_DAYS_SHIFT      = 168;\n', '\n', '    uint256 private constant TOTAL_INTERVALS_MASK         = 0x1FFFFE00000000000000000000000000000000000000000000;\n', '    uint256 private constant TOTAL_INTERVALS_SHIFT        = 177;\n', '\n', '    uint256 private constant FINALIZATION_TIMESTAMP_MASK  = 0x1FFFFFFFFFFFE0000000000000000000000000000000000000000000000000;\n', '    uint256 private constant FINALIZATION_TIMESTAMP_SHIFT = 197;\n', '\n', '    uint256 private constant FINALIZED_MASK               = 0x20000000000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant FINALIZED_SHIFT              = 245;\n', '\n', '    // The divisor used to calculate the fee paid to the Goald DAO. This is currently 0.25%.\n', '    uint256 private constant FEE_DIVISOR = 400;\n', '\n', '\n', '    /** @dev The collateral token stored (e.g., WBTC). */\n', '    address private _collateralAddress;\n', '\n', '    /** @dev The payment token taken (e.g., WETH). */\n', '    address private _paymentAddress;\n', '\n', '    /** @dev The address of the Uniswap router which will facilitate the swap between the payment token and the collateral token. */\n', '    address private _uniswapRouterAddress;\n', '\n', '    /**\n', "     * @dev The owner of the Goald can optionally appoint a steward. The steward's only authority is to update the uniswap router\n", '     * address or replace themself. This is intended if the Goald needs separation between ownership and management (e.g., via DAOs).\n', '     */\n', '    address private _steward;\n', '\n', '    /**\n', '     * @dev Packed static values (all uints). The only one that will change is `finalized`, and only once.\n', '     *\n', '     *  bits    offset    variable name            description\n', '     *  ----    ------    -------------            -----------\n', '     *   168         0    fee                      The fee per interval of the goald.\n', '     *     9       168    feeIntervalDays          How many days between each fee payment; minimum 1.\n', '     *    20       177    totalIntervals           The total number of intervals this goald will have when it is finalized.\n', "     *    48       197    finalizationTimestamp    When the Goald can be finalized if it isn't paid in full.\n", '     *     1       245    finalized                If the Goald can be withdrawn from.\n', '     */\n', '    uint256 private _staticValues;\n', '\n', '    /** @dev The total amount of the payment token that must be paid over the life of the Goald to finalize it. */\n', '    uint256 private _requiredTotalFeePaid;\n', '\n', '    /** @dev The total amount of the payment token that has been paid over the life of the Goald. */\n', '    uint256 private _totalFeePaid;\n', '\n', '    // We include this here instead of the `nonReentrant` modifier to reduce gas costs. We also might change the reentrancy state\n', '    // multiple times within a single function depending on needs.\n', '    // See OpenZeppelin - ReentrancyGuard for more.\n', '    // Reentrancy reversions are the only calls to revert (in this contract) that do not have reasons.\n', '    uint256 private constant RE_NOT_ENTERED = 1;\n', '    uint256 private constant RE_ENTERED     = 2;\n', '    uint256 private _status;\n', '\n', '    /// Events ///\n', '\n', '    /** @dev Emitted whenever a fee is paid. */\n', '    event FeePaid(address paymentToken, uint256 feePaid, uint256 feeTokensSpent, uint256 collateralTokensReceived);\n', '\n', '    /** @dev Emitted when the collateral pool has been withdrawn from. */\n', '    event Withdrawal(uint256 amount);\n', '\n', '    /** @dev Emitted when the Uniswap router address has changed. */\n', '    event RouterAddressChanged(address newAddress);\n', '\n', '    /** @dev Emitted when the steward address has changed. */\n', '    event StewardChanged(address newSteward);\n', '\n', '    /// Modifiers ///\n', '\n', '    /** @dev Applied to functions that must be guarded against reentrancy which only the owner or steward can call. */\n', '    modifier nonReentrant_OnlyOwnerSteward {\n', '        require(_status == RE_NOT_ENTERED && (msg.sender == _owner || msg.sender == _steward));\n', '        _status = RE_ENTERED;\n', '\n', '        _;\n', '\n', '        // Store the original amount to get a refund.\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Applied to functions that must be guarded against reentrancy which only the owner or steward can call. This modifier\n', "     * doesn't update the current value of `_status`, so it cannot make any non-internal function calls.\n", '     */\n', '    modifier nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\n', '        require(_status == RE_NOT_ENTERED && (msg.sender == _owner || msg.sender == _steward));\n', '\n', '        _;\n', '    }\n', '\n', '    /** @dev Applied to functions that must be guarded against reentrancy, but are otherwise publicly accessible. */\n', '    modifier nonReentrant_Public {\n', '        // Reentrancy guard.\n', '        require(_status == RE_NOT_ENTERED);\n', '        _status = RE_ENTERED;\n', '\n', '        _;\n', '\n', '        // Store the original amount to get a refund.\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// Constructor ///\n', '\n', '    /**\n', '     * @param daoAddress The address of the Goald DAO.\n', '     * @param owner Who owns the goald and is required to pay the fees to maintain it (though anyone can pay the fees).\n', '     * @param name The name of this goald.\n', '     * @param goaldId The unique id of this Goald.\n', '     * @param collateralToken Which token will be used as collateral in the collateral pool (e.g., WBTC).\n', '     * @param paymentToken Which token will be used to pay for the collateral token (e.g., WETH).\n', '     * @param uniswapRouterAddress The address of the liquidity swap router.\n', '     * @param fee The periodic fee required to be paid to maintain the goald; minimum 1. Anyone can pay the fee.\n', '     * @param feeIntervalDays How many days between each fee payment; minimum 1.\n', '     * @param totalIntervals How many fee intervals must pass before the goald finalizes; minimum 1.\n', '     */\n', '    constructor(\n', '        address daoAddress,\n', '        address owner,\n', '        string memory name,\n', '        uint256 goaldId,\n', '        address collateralToken,\n', '        address paymentToken,\n', '        address uniswapRouterAddress,\n', '        uint256 fee,\n', '        uint256 feeIntervalDays,\n', '        uint256 totalIntervals\n', '    ) Goald721(name, "GOALD", goaldId) public {\n', "        // Do validation. We don't do any validation on the addresses being contracts, only that they are unique among themselves\n", '        // and are not obviously invalid. It is up to the user to use addresses that are ERC20 compliant.\n', '        require(\n', '            // Validate the addresses.\n', '               daoAddress      != address(0)\n', '            && daoAddress      != address(this)\n', '            && owner           != address(0)\n', '            && owner           != address(this)\n', '            && owner           != collateralToken\n', '            && owner           != paymentToken\n', '            && collateralToken != address(0)\n', '            && collateralToken != address(this)\n', '            && collateralToken != paymentToken\n', '            && paymentToken    != address(0)\n', '            && paymentToken    != address(this)\n', '\n', '            // Validate the numbers.\n', '            && fee             > 0 && fee             <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF // uint168\n', '            && feeIntervalDays > 0 && feeIntervalDays <= 0x1FF                                        // uint9\n', '            && totalIntervals  > 0 && totalIntervals  <= 0xFFFFF                                      // uint20\n', '        , "Invalid parameters");\n', '\n', '        // Clean any dirty bits from the number values.\n', '        fee             = fee             & (FEE_MASK               >> FEE_SHIFT);\n', '        feeIntervalDays = feeIntervalDays & (FEE_INTERVAL_DAYS_MASK >> FEE_INTERVAL_DAYS_SHIFT);\n', '        totalIntervals  = totalIntervals  & (TOTAL_INTERVALS_MASK   >> TOTAL_INTERVALS_SHIFT);\n', '        uint256 finalizationTimestamp = block.timestamp + (totalIntervals * feeIntervalDays * 1 days);\n', '\n', '        // Set the addresses.\n', '        _daoAddress           = daoAddress;\n', '        _collateralAddress    = collateralToken;\n', '        _paymentAddress       = paymentToken;\n', '        _owner                = owner;\n', '        _uniswapRouterAddress = uniswapRouterAddress;\n', '\n', '        // Store the values.\n', '        _requiredTotalFeePaid = fee * totalIntervals;\n', '        _staticValues = 0\n', '            | (fee                   << FEE_SHIFT)\n', '            | (feeIntervalDays       << FEE_INTERVAL_DAYS_SHIFT)\n', '            | (totalIntervals        << TOTAL_INTERVALS_SHIFT)\n', '            | (finalizationTimestamp << FINALIZATION_TIMESTAMP_SHIFT);\n', '\n', '        // Set us up for reentrancy guarding.\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// Views ///\n', '\n', '    /**\n', '     * Single view over all internal state variables.\n', '     *\n', '     * Returns:\n', '     *     Proxy contract address\n', '     *     Collateral token address\n', '     *     Payment token address (or 0 for ETH)\n', '     *     Uniswap router address\n', '     *     Next fee timestamp\n', '     *     Packed state values\n', '     */\n', '    function getDetails() external view returns (uint256[10] memory details) {\n', '        address collateralAddress = _collateralAddress;\n', '\n', '        // Important Addresses.\n', '        details[0] = uint256(_daoAddress);\n', '        details[1] = uint256(collateralAddress);\n', '        details[2] = uint256(_paymentAddress);\n', '        details[3] = uint256(_uniswapRouterAddress);\n', '        details[4] = uint256(_steward);\n', '        details[5] = uint256(_owner);\n', '\n', '        // The id of this Goald.\n', '        details[6] = _tokenId;\n', '\n', '        // The total amount paid into the Goald so far.\n', '        details[7] = _totalFeePaid;\n', '\n', '        // Current balance.\n', '        details[8] = IERC20(collateralAddress).balanceOf(address(this));\n', '\n', '        // Packed values.\n', '        details[9] = _staticValues;\n', '    }\n', '\n', '    /// External Functions ///\n', '\n', '    /**\n', '     * Pay out the stored collateral. This can only be called by and paid out to the owner, not a third party, even the steward. This\n', '     * This can only be called once the finalization date has been reached, but can be called multiple times after that if desired.\n', '     */\n', '    function withdrawFromGoald(uint256 amount) external {\n', '        // So we can extract the packed values without unnecessary SLOADs.\n', '        uint256 values = _staticValues;\n', '        uint256 finalized             = (values & FINALIZED_MASK)              >> FINALIZED_SHIFT;\n', '        uint256 finalizationTimestamp = (values & FINALIZATION_TIMESTAMP_MASK) >> FINALIZATION_TIMESTAMP_SHIFT;\n', '\n', "        // Rather than using a `nonReentrant_OnlyOwner` modifier, we include the reentrancy guard manually. This save gas since we're\n", '        // caching `_owner` into `owner`.\n', '        address owner = _owner;\n', '        require(\n', '               _status == RE_NOT_ENTERED\n', '            && msg.sender == owner\n', '            && (\n', '                // This is only set during a call to `payFee` if the Goald has been fully paid out.\n', '                   finalized > 0\n', '                || block.timestamp >= finalizationTimestamp\n', '            )\n', '        , "Not authorized");\n', '        _status = RE_ENTERED;\n', '\n', '        // Make sure we have something to withdraw.\n', '        IERC20 collateralToken = IERC20(_collateralAddress);\n', '        uint256 currentGoaldBalance = collateralToken.balanceOf(address(this));\n', '        uint256 currentOwnerBalance = collateralToken.balanceOf(owner);\n', '        require(\n', '               amount > 0\n', '            && amount <= currentGoaldBalance\n', '            && currentOwnerBalance + amount > currentOwnerBalance\n', '        , "Invalid amount");\n', '\n', '        // Transfer the collateral.\n', '        require(collateralToken.transfer(owner, amount));\n', '\n', '        // Validate the transfer.\n', '        require(\n', '               collateralToken.balanceOf(address(this)) == currentGoaldBalance - amount\n', '            && collateralToken.balanceOf(owner)         == currentOwnerBalance + amount\n', '        , "Post transfer balance wrong");\n', '\n', '        // Hello world!\n', '        emit Withdrawal(amount);\n', '\n', '        // Store the original amount to get a refund.\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', ' \n', '\n', '    /** Pay the goald fee. Overpayments change the finalization date. */\n', '    function payFee(uint256 amount, address[] calldata swapPath, uint256 deadline) external nonReentrant_Public {\n', '        // Make sure we have a valid swap path.\n', '        require(swapPath.length > 1 && swapPath[swapPath.length - 1] == _collateralAddress, "Invalid swap path");\n', '\n', "        // Clean up any dirty bits in the amount. We don't validate that this is more than zero. At best, the swap function will\n", '        // revert (either on input being zero, or minimum output not being more than one). At worst, The user called this function\n', '        // with invalid parameters.\n', '        amount = amount & (FEE_MASK >> FEE_SHIFT);\n', '\n', '        // Make sure we have the most up to date DAO address. If this call reverts, then no fees can be paid.\n', '        address daoAddress = IGoaldDAO(_daoAddress).getProxyAddress();\n', '        if (address(daoAddress) != daoAddress) {\n', '            _daoAddress = daoAddress;\n', '        }\n', '\n', '        uint256[] memory amounts;\n', '        uint256 receivedAmount;\n', '        { // Scoped to prevent stack too deep error.\n', '            // Transfer from the user.\n', '            IERC20 paymentContract = IERC20(swapPath[0]);\n', '            uint256 fee = amount / FEE_DIVISOR;\n', '            amount -= fee;\n', '            require(paymentContract.transferFrom(msg.sender, address(this), amount)); \n', '            if (fee > 0) {\n', '                require(paymentContract.transferFrom(msg.sender, daoAddress, fee));\n', '            }\n', '\n', "            // We'll be verifying uniswap did what it said it did.\n", '            IERC20 collateralContract = IERC20(_collateralAddress);\n', '            uint256 currentCollateralBalance = collateralContract.balanceOf(address(this));\n', '\n', "            // Set the router's allowance to cover the trade. We are only authorizing enough for the collateral amount.\n", '            address uniswapRouterAddress = _uniswapRouterAddress;\n', '            require(paymentContract.approve(uniswapRouterAddress, amount));\n', '            \n', "            // Try and transfer from the user to the goald. We use Uniswap to get the collateral token. We don't care how much of the\n", '            // collateral was returned, so long as it is greater than zero.\n', '            amounts = IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForTokens(amount, 1, swapPath, address(this), deadline);\n', '\n', '            // Double check the balance. Amounts is the same length as `_uniPath`: 3.\n', '            receivedAmount = amounts[swapPath.length - 1];\n', '            require(currentCollateralBalance + receivedAmount > currentCollateralBalance, "UNI: Overflow error");\n', '            require(collateralContract.balanceOf(address(this)) == currentCollateralBalance + receivedAmount, "UNI: Wrong balance");\n', '\n', "            // Reset the router's allowance to zero to prevent unauthorized spending / double spending. The refund would be larger if\n", '            // it was kept non-zero, but though one token can be considered miniscule (e.g., for WETH, which has 18 decimal places),\n', '            // we still must be diligent.\n', '            require(paymentContract.approve(uniswapRouterAddress, 0));\n', '        }\n', '\n', "        // The Goald hasn't been finalized yet, so update the total amount paid. We don't keep track of how many payments have\n", '        // been made afer the it has been finalized.\n', '        if ((_staticValues & FINALIZED_MASK) >> FINALIZED_SHIFT == 0) {\n', '            // Calculate the new total.\n', '            uint256 totalFeePaid = _totalFeePaid;\n', '            uint256 newTotalFeePaid = totalFeePaid + amount;\n', '\n', "            // We'll consider an overflow on the amount paid to be the same as fully paying out the Goald.\n", '            if (newTotalFeePaid < totalFeePaid) {\n', '                _staticValues |= FINALIZED_MASK;\n', '            } else if (newTotalFeePaid >= _requiredTotalFeePaid) {\n', '                _staticValues |= FINALIZED_MASK;\n', '            } else {\n', '                _totalFeePaid = newTotalFeePaid;\n', '            }\n', '        }\n', '\n', '        // Hello world!\n', '        emit FeePaid(swapPath[0], amount, amounts[0], receivedAmount);\n', '    }\n', '\n', '    /** Failsafe so the owner can withdraw any tokens other than the collateral token that may end up within this Goald. */\n', '    function transferERC20(address tokenAddress, uint256 amount) external nonReentrant_OnlyOwnerSteward {\n', '        require(tokenAddress != _collateralAddress, "Invalid address");\n', '        require(IERC20(tokenAddress).transfer(_owner, amount));\n', '    }\n', '\n', '    /**\n', '     * Changes the uniswap router contract address for the swaps. This can be changed to anything that has the same API:\n', '     * \n', '     * `swapExactTokensForTokens(\n', '     *      uint256   amount,\n', '     *      uint256   minAmount,\n', '     *      address[] path,\n', '     *      address   destination,\n', '     *      uint256   deadline\n', '     *  ) external returns (uint256[] amounts);`\n', '     *\n', '     * Only the owner or steward of the Goald can update the router.\n', '     */\n', '    function updateRouterAddress(address newAddress) external nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\n', "        // We're not doing address validation because this function is restricted to only two callers: the owner or steward. However,\n", '        // the things we would validate against would be:\n', '        //\n', "        // 1) Not being the zero address. Since that address doesn't support the swap function it would revert on any payments.\n", '        // 2) The goald address (or the deployer address). Again, neither support the swap function.\n', '        // 3) The DAO address / a token address. Again, neither support the swap function (although a unified proxy DAO is possible).\n', "        // 4) The steward / owner. It's possible this condition is legitimate.\n", '\n', '        // Update the router address.\n', '        _uniswapRouterAddress = newAddress;\n', '\n', '        emit RouterAddressChanged(newAddress);\n', '    }\n', '\n', '    /** Changes the steward. This can be set to the zero address to disable steward functionality.*/\n', '    function updateSteward(address newSteward) external nonReentrant_OnlyOwnerSteward_InternalCallsOnly {\n', "        // We don't do any validation on the new steward. Either the new address can be aware of its stewardship abilities or it\n", "        // cannot. In the second case, it doesn't matter what it is. In the first case, it would pass all theoretical validation.\n", '\n', '        // Update the steward.\n', '        _steward = newSteward;\n', '\n', '        emit StewardChanged(newSteward);\n', '    }\n', '\n', '    /// "Overridden" Functions ///\n', '\n', '    /** See {IERC721Metadata-tokenURI}. Pull metadata from the DAO. */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(tokenId == _tokenId, "Wrong token");\n', '\n', '        return IGoaldDAO(_daoAddress).getTokenURI(tokenId);\n', '    }\n', '}']