['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./OTCTypes.sol";\n', 'import "./ACOAssetHelper.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IACOFactory.sol";\n', 'import "./IWETH.sol";\n', 'import "./IACOToken.sol";\n', '\n', '/**\n', ' * @title ACOOTC\n', ' * @dev Contract to trade OTC on ACO tokens. \n', ' * Inspired on Swap SC by AirSwap, under Apache License, Version 2.0\n', ' * https://github.com/airswap/airswap-protocols/blob/master/source/swap/contracts/Swap.sol\n', ' */\n', 'contract ACOOTC {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\tevent Swap(\n', '\t\tuint256 indexed nonce,\n', '\t\taddress indexed signer,\n', '\t\taddress indexed sender,\n', '\t\tbool isAskOrder,\n', '\t\tuint256 signerAmount,\n', '\t\taddress signerToken,\n', '\t\tuint256 senderAmount,\n', '\t\taddress senderToken,\n', '\t\taddress affiliate,\n', '\t\tuint256 affiliateAmount,\n', '\t\taddress affiliateToken\n', '\t);\n', '\tevent Cancel(uint256 indexed nonce, address indexed signer);\n', '\tevent CancelUpTo(uint256 indexed nonce, address indexed signer);\n', '\tevent AuthorizeSender(address indexed authorizerAddress, address indexed authorizedSender);\n', '\tevent AuthorizeSigner(address indexed authorizerAddress, address indexed authorizedSigner);\n', '\tevent RevokeSender(address indexed authorizerAddress, address indexed revokedSender);\n', '\tevent RevokeSigner(address indexed authorizerAddress, address indexed revokedSigner);\n', '\t\n', '\t//Domain and version for use in signatures (EIP-712)\n', '\tbytes internal constant DOMAIN_NAME = "ACOOTC";\n', '\tbytes internal constant DOMAIN_VERSION = "1";\n', '\n', '\t// Unique domain identifier for use in signatures (EIP-712)\n', '\tbytes32 private immutable _domainSeparator;\n', '\n', '\t// Possible nonce statuses\n', '\tbytes1 internal constant AVAILABLE = 0x00;\n', '\tbytes1 internal constant UNAVAILABLE = 0x01;\n', '\n', '\t// Address of the ACO Factory contract\n', '\tIACOFactory public immutable acoFactory;\n', '\t// Address of the WETH contract\n', '\tIWETH public immutable weth;\n', '\n', '\t// Mapping of sender address to a delegated sender address and bool\n', '\tmapping(address => mapping(address => bool)) public senderAuthorizations;\n', '\n', '\t// Mapping of signer address to a delegated signer and bool\n', '\tmapping(address => mapping(address => bool)) public signerAuthorizations;\n', '\n', '\t// Mapping of signers to nonces with value AVAILABLE (0x00) or UNAVAILABLE (0x01)\n', '\tmapping(address => mapping(uint256 => bytes1)) public signerNonceStatus;\n', '\n', '\t// Mapping of signer addresses to an optionally set minimum valid nonce\n', '\tmapping(address => uint256) public signerMinimumNonce;\n', '\n', '\t/**\n', '\t * @notice Contract Constructor\n', '\t * @dev Sets domain for signature validation (EIP-712) and the ACO Factory and WETH\n', '\t * @param _acoFactory ACO Factory address\n', '\t * @param _weth WETH address\n', '\t */\n', '\tconstructor(address _acoFactory, address _weth) public {\n', '\t\t_domainSeparator = OTCTypes.hashDomain(\n', '\t\t\tDOMAIN_NAME,\n', '\t\t\tDOMAIN_VERSION,\n', '\t\t\taddress(this)\n', '\t\t);\n', '\t\tacoFactory = IACOFactory(_acoFactory);\n', '\t\tweth = IWETH(_weth);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Receive ETH from WETH contract\n', '\t */\n', '\treceive() external payable {\n', '        require(msg.sender == address(weth), "ACOOTC:: Only WETH");\n', '    }\n', '\n', '\t/**\n', '\t * @notice Atomic Token Swap for an Ask Order\n', '\t * @param order OTCTypes.AskOrder Order to settle\n', '\t */\n', '\tfunction swapAskOrder(OTCTypes.AskOrder calldata order) external {\n', '\t\t// Ensure the order is valid.\n', '\t\taddress finalSender = _baseSwapValidation(\n', '\t\t\torder.expiry,\n', '\t\t\torder.nonce,\n', '\t\t\torder.signer.responsible,\n', '\t\t\torder.sender.responsible,\n', '\t\t\torder.affiliate.responsible,\n', '\t\t\torder.signature.signatory,\n', '\t\t\torder.signature.v\n', '\t\t);\n', '\t\t// Ensure the signature is valid whether it is provided.\n', '\t\trequire(order.signature.v == uint8(0) || isValidAskOrder(order), "ACOOTC:: Signature invalid");\n', '\n', '\t\tACOAssetHelper._callTransferFromERC20(order.sender.token, finalSender, order.signer.responsible, order.sender.amount);\n', '\n', '\t\taddress _aco = _transferAco(order.signer.responsible, finalSender, order.signer);\n', '\n', '\t\t// Transfer token from signer to affiliate if specified.\n', '\t\tif (order.affiliate.token != address(0)) {\n', '\t\t\tACOAssetHelper._callTransferFromERC20(order.affiliate.token, order.signer.responsible, order.affiliate.responsible, order.affiliate.amount);\n', '\t\t}\n', '\n', '\t\temit Swap(\n', '\t\t\torder.nonce,\n', '\t\t\torder.signer.responsible,\n', '\t\t\tfinalSender,\n', '\t\t\ttrue,\n', '\t\t\torder.signer.amount,\n', '\t\t\t_aco,\n', '\t\t\torder.sender.amount,\n', '\t\t\torder.sender.token,\n', '\t\t\torder.affiliate.responsible,\n', '\t\t\torder.affiliate.amount,\n', '\t\t\torder.affiliate.token\n', '\t\t);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @notice Atomic Token Swap for a Bid Order\n', '\t * @param order OTCTypes.BidOrder Order to settle\n', '\t */\n', '\tfunction swapBidOrder(OTCTypes.BidOrder calldata order) external {\n', '\t\t// Ensure the order is valid.\n', '\t\taddress finalSender = _baseSwapValidation(\n', '\t\t\torder.expiry,\n', '\t\t\torder.nonce,\n', '\t\t\torder.signer.responsible,\n', '\t\t\torder.sender.responsible,\n', '\t\t\torder.affiliate.responsible,\n', '\t\t\torder.signature.signatory,\n', '\t\t\torder.signature.v\n', '\t\t);\n', '\t\t// Ensure the signature is valid whether it is provided.\n', '\t\trequire(order.signature.v == uint8(0) || isValidBidOrder(order), "ACOOTC:: Signature invalid");\n', '\n', '\t\taddress _aco = _transferAco(finalSender, order.signer.responsible, order.sender);\n', '\t\t\n', '\t\tACOAssetHelper._callTransferFromERC20(order.signer.token, order.signer.responsible, finalSender, order.signer.amount);\n', '\n', '\t\t// Transfer token from signer to affiliate if specified.\n', '\t\tif (order.affiliate.token != address(0)) {\n', '\t\t\tACOAssetHelper._callTransferFromERC20(order.affiliate.token, order.signer.responsible, order.affiliate.responsible, order.affiliate.amount);\n', '\t\t}\n', '\n', '\t\temit Swap(\n', '\t\t\torder.nonce,\n', '\t\t\torder.signer.responsible,\n', '\t\t\tfinalSender,\n', '\t\t\tfalse,\n', '\t\t\torder.signer.amount,\n', '\t\t\torder.signer.token,\n', '\t\t\torder.sender.amount,\n', '\t\t\t_aco,\n', '\t\t\torder.affiliate.responsible,\n', '\t\t\torder.affiliate.amount,\n', '\t\t\torder.affiliate.token\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Cancel one or more open orders by nonce\n', '\t * @dev Cancelled nonces are marked UNAVAILABLE (0x01)\n', '\t * @dev Emits a Cancel event\n', '\t * @dev Out of gas may occur in arrays of length > 400\n', '\t * @param nonces uint256[] List of nonces to cancel\n', '\t */\n', '\tfunction cancel(uint256[] calldata nonces) external {\n', '\t\tfor (uint256 i = 0; i < nonces.length; i++) {\n', '\t\t\tif (signerNonceStatus[msg.sender][nonces[i]] == AVAILABLE) {\n', '\t\t\t\tsignerNonceStatus[msg.sender][nonces[i]] = UNAVAILABLE;\n', '\t\t\t\temit Cancel(nonces[i], msg.sender);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Cancels all orders below a nonce value\n', '\t * @dev Emits a CancelUpTo event\n', '\t * @param minimumNonce uint256 Minimum valid nonce\n', '\t */\n', '\tfunction cancelUpTo(uint256 minimumNonce) external {\n', '\t\tsignerMinimumNonce[msg.sender] = minimumNonce;\n', '\t\temit CancelUpTo(minimumNonce, msg.sender);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Authorize a delegated sender\n', '\t * @dev Emits an AuthorizeSender event\n', '\t * @param authorizedSender address Address to authorize\n', '\t */\n', '\tfunction authorizeSender(address authorizedSender) external {\n', '\t\trequire(msg.sender != authorizedSender, "ACOOTC:: Self authorization");\n', '\t\tif (!senderAuthorizations[msg.sender][authorizedSender]) {\n', '\t\t\tsenderAuthorizations[msg.sender][authorizedSender] = true;\n', '\t\t\temit AuthorizeSender(msg.sender, authorizedSender);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Authorize a delegated signer\n', '\t * @dev Emits an AuthorizeSigner event\n', '\t * @param authorizedSigner address Address to authorize\n', '\t */\n', '\tfunction authorizeSigner(address authorizedSigner) external {\n', '\t\trequire(msg.sender != authorizedSigner, "ACOOTC:: Self authorization");\n', '\t\tif (!signerAuthorizations[msg.sender][authorizedSigner]) {\n', '\t\t\tsignerAuthorizations[msg.sender][authorizedSigner] = true;\n', '\t\t\temit AuthorizeSigner(msg.sender, authorizedSigner);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Revoke an authorized sender\n', '\t * @dev Emits a RevokeSender event\n', '\t * @param authorizedSender address Address to revoke\n', '\t */\n', '\tfunction revokeSender(address authorizedSender) external {\n', '\t\tif (senderAuthorizations[msg.sender][authorizedSender]) {\n', '\t\t\tdelete senderAuthorizations[msg.sender][authorizedSender];\n', '\t\t\temit RevokeSender(msg.sender, authorizedSender);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Revoke an authorized signer\n', '\t * @dev Emits a RevokeSigner event\n', '\t * @param authorizedSigner address Address to revoke\n', '\t */\n', '\tfunction revokeSigner(address authorizedSigner) external {\n', '\t\tif (signerAuthorizations[msg.sender][authorizedSigner]) {\n', '\t\t\tdelete signerAuthorizations[msg.sender][authorizedSigner];\n', '\t\t\temit RevokeSigner(msg.sender, authorizedSigner);\n', '\t\t}\n', '\t}\n', '\t\n', '    /**\n', '     * @notice Validate signature using an EIP-712 typed data hash\n', '     * @param order OTCTypes.AskOrder Order to validate\n', '     * @return bool True if order has a valid signature\n', '     */\n', '\tfunction isValidAskOrder(OTCTypes.AskOrder memory order) public view returns(bool) {\n', '\t\tbytes32 orderHash = OTCTypes.hashAskOrder(order, _domainSeparator);\n', '\t\treturn _isValid(orderHash, order.signature);\n', '\t}\n', '\n', '    /**\n', '     * @notice Validate signature using an EIP-712 typed data hash\n', '     * @param order OTCTypes.BidOrder Order to validate\n', '     * @return bool True if order has a valid signature\n', '     */\n', '\tfunction isValidBidOrder(OTCTypes.BidOrder memory order) public view returns(bool) {\n', '\t\tbytes32 orderHash = OTCTypes.hashBidOrder(order, _domainSeparator);\n', '\t\treturn _isValid(orderHash, order.signature);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Determine whether a sender delegate is authorized\n', '\t * @param authorizer address Address doing the authorization\n', '\t * @param delegate address Address being authorized\n', '\t * @return bool True if a delegate is authorized to send\n', '\t */\n', '\tfunction _isSenderAuthorized(address authorizer, address delegate) internal view returns(bool) {\n', '\t\treturn ((authorizer == delegate) || senderAuthorizations[authorizer][delegate]);\n', '\t}\n', '\n', '\t/**\n', '\t * @notice Determine whether a signer delegate is authorized\n', '\t * @param authorizer address Address doing the authorization\n', '\t * @param delegate address Address being authorized\n', '\t * @return bool True if a delegate is authorized to sign\n', '\t */\n', '\tfunction _isSignerAuthorized(address authorizer, address delegate) internal view returns(bool) {\n', '\t\treturn ((authorizer == delegate) || signerAuthorizations[authorizer][delegate]);\n', '\t}\n', '\n', '    /**\n', '     * @notice Validate signature using an EIP-712 typed data hash\n', '     * @param orderHash Hashed order to validate\n', '\t * @param signature OTCTypes.Signature teh order signature\n', '     * @return bool True if order has a valid signature\n', '     */\n', '\tfunction _isValid(bytes32 orderHash, OTCTypes.Signature memory signature) internal pure returns(bool) {\n', '\t\tif (signature.version == bytes1(0x01)) {\n', '\t\t\treturn signature.signatory ==\n', '\t\t\t\tecrecover(\n', '\t\t\t\t\torderHash,\n', '\t\t\t\t\tsignature.v,\n', '\t\t\t\t\tsignature.r,\n', '\t\t\t\t\tsignature.s\n', '\t\t\t\t);\n', '\t\t}\n', '\t\tif (signature.version == bytes1(0x45)) {\n', '\t\t\treturn signature.signatory ==\n', '\t\t\t\tecrecover(\n', '\t\t\t\t\tkeccak256(\n', '\t\t\t\t\t\tabi.encodePacked(\n', '\t\t\t\t\t\t\t"\\x19Ethereum Signed Message:\\n32",\n', '\t\t\t\t\t\t\torderHash\n', '\t\t\t\t\t\t)\n', '\t\t\t\t\t),\n', '\t\t\t\t\tsignature.v,\n', '\t\t\t\t\tsignature.r,\n', '\t\t\t\t\tsignature.s\n', '\t\t\t\t);\n', '\t\t}\n', '\t\treturn false;\n', '\t}\n', '\n', '\t/**\n', '     * @notice Validate all base data for a swap order\n', '     * @param expiry Order expiry time\n', '\t * @param nonce Order expiry time\n', '\t * @param signer Order signer responsible address\n', '\t * @param sender Order sender responsible address\n', '\t * @param affiliate Order affiliate responsible address\n', '\t * @param signatory Order signatory address\n', '\t * @param v Order `v` parameter on the signature\n', '     * @return The final sender address\n', '     */\n', '\tfunction _baseSwapValidation(\n', '\t\tuint256 expiry,\n', '\t\tuint256 nonce,\n', '\t\taddress signer,\n', '\t\taddress sender,\n', '\t\taddress affiliate,\n', '\t\taddress signatory,\n', '\t\tuint8 v\n', '\t) internal returns(address) {\n', '\t\t// Ensure the order is not expired.\n', '\t\trequire(expiry > block.timestamp, "ACOOTC:: Order expired");\n', '\n', '\t\t// Ensure the nonce is AVAILABLE (0x00).\n', '\t\trequire(signerNonceStatus[signer][nonce] == AVAILABLE, "ACOOTC:: Order taken or cancelled");\n', '\n', '\t\t// Ensure the order nonce is above the minimum.\n', '\t\trequire(nonce >= signerMinimumNonce[signer], "ACOOTC:: Nonce too low");\n', '\t\t\n', '\t\t// Ensure distinct addresses.\n', '\t\trequire(signer != affiliate, "ACOOTC:: Self transfer");\n', '\n', '\t\t// Mark the nonce UNAVAILABLE (0x01).\n', '\t\tsignerNonceStatus[signer][nonce] = UNAVAILABLE;\n', '\n', '\t\t// Validate the sender side of the trade.\n', '\t\taddress finalSender;\n', '\t\tif (sender == address(0)) {\n', '\t\t\t// Sender is not specified. The msg.sender of the transaction becomes the sender of the order.\n', '\t\t\tfinalSender = msg.sender;\n', '\t\t} else {\n', '\t\t\t// Sender is specified. If the msg.sender is not the specified sender, this determines whether the msg.sender is an authorized sender.\n', '\t\t\trequire(_isSenderAuthorized(sender, msg.sender), "ACOOTC:: Sender unauthorized");\n', '\t\t\t\n', '\t\t\t// The msg.sender is authorized.\n', '\t\t\tfinalSender = sender;\n', '\t\t}\n', '\t\t// Ensure distinct addresses.\n', '\t\trequire(signer != finalSender, "ACOOTC:: Self transfer");\n', '\n', '\t\t// Validate the signer side of the trade.\n', '\t\tif (v == 0) {\n', '\t\t\t// Signature is not provided. The signer may have authorized the msg.sender to swap on its behalf, which does not require a signature.\n', '\t\t\trequire(_isSignerAuthorized(signer, msg.sender), "ACOOTC:: Signer unauthorized");\n', '\t\t} else {\n', '\t\t\t// The signature is provided. Determine whether the signer is authorized.\n', '\t\t\trequire(_isSignerAuthorized(signer, signatory), "ACOOTC:: Signer unauthorized");\n', '\t\t}\n', '\t\t\n', '\t\treturn finalSender;\n', '\t}\n', '\n', '\t/**\n', '     * @notice Transfer an ACO token\n', '\t * With the order ACO party parameters a new ACO token will be created \n', '\t * The collateral is used to mint ACO and then those tokens are transferred\n', '     * @param from The ACO creator responsible\n', '\t * @param to The ACO token destination\n', '\t * @param data OTCTypes.PartyAco Order party parameters to the ACO token\n', '     * @return The created ACO address\n', '     */\n', '\tfunction _transferAco(address from, address to, OTCTypes.PartyAco memory data) internal returns(address) {\n', '\t\taddress collateral;\n', '\t\tuint256 collateralAmount;\n', '\t\tif (data.isCall) {\n', '\t\t\tcollateral = data.underlying;\n', '\t\t\tcollateralAmount = data.amount;\n', '\t\t} else {\n', '\t\t\tcollateral = data.strikeAsset;\n', '\t\t\t\n', '\t\t\tuint256 decimals = uint256(ACOAssetHelper._getAssetDecimals(data.underlying));\n', '\t\t\t// Ensure the underlying decimals will not overflow.\n', '\t\t\trequire(decimals < 78, "ACOOTC:: Invalid underlying");\n', '\t\t\t\n', '\t\t\tcollateralAmount = data.amount.mul(data.strikePrice).div((10 ** decimals));\n', '\t\t}\n', '\t\t// Ensure the collateral amount is not zero.\n', '\t\trequire(collateralAmount > 0, "ACOOTC:: Collateral amount is too low");\n', '\n', '\t\tif (ACOAssetHelper._isEther(collateral)) {\n', '\t\t\tIWETH _weth = weth;\n', '\t\t\tACOAssetHelper._callTransferFromERC20(address(_weth), from, address(this), collateralAmount);\n', '\t\t\t_weth.withdraw(collateralAmount);\n', '\t\t} else {\n', '\t\t\tACOAssetHelper._callTransferFromERC20(collateral, from, address(this), collateralAmount);\n', '\t\t}\n', '\t\t\n', '\t\taddress aco = acoFactory.getAcoToken(\n', '\t\t\tdata.underlying, \n', '\t\t\tdata.strikeAsset, \n', '\t\t\tdata.isCall, \n', '\t\t\tdata.strikePrice, \n', '\t\t\tdata.expiryTime\n', '\t\t);\n', '\t\tif (aco == address(0)) {\n', '\t\t\taco = acoFactory.createAcoToken(\n', '\t\t\t\tdata.underlying, \n', '\t\t\t\tdata.strikeAsset, \n', '\t\t\t\tdata.isCall, \n', '\t\t\t\tdata.strikePrice, \n', '\t\t\t\tdata.expiryTime, \n', '\t\t\t\tuint256(100)\n', '\t\t\t);\n', '\t\t}\n', '\t\t\n', '\t\tif (ACOAssetHelper._isEther(collateral)) {\n', '\t\t\tIACOToken(aco).mintToPayable{value: collateralAmount}(from);\n', '\t\t} else {\n', '\t\t\tACOAssetHelper._callApproveERC20(collateral, aco, collateralAmount);\n', '\t\t\tIACOToken(aco).mintTo(from, collateralAmount);\n', '\t\t}\n', '\t\t\n', '\t\tACOAssetHelper._callTransferERC20(aco, to, data.amount);\n', '\t\t\n', '\t\treturn aco;\n', '\t}\n', '}']