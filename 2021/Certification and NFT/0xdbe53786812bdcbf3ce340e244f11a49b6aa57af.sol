['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-07\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.1;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    function _msgSender() internal view returns (address payable) {\n', '        return payable(msg.sender);\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface ISHP {\n', '  function balanceOfAt(address owner, uint256 blockNumber) external pure returns (uint256);\n', '  function totalSupplyAt(uint256 blockNumber) external pure returns (uint256);\n', '}\n', '\n', 'interface IVegaVesting {\n', '  function tranche_count() external view returns(uint8);\n', '  function withdraw_from_tranche(uint8 tranche_id) external;\n', '  function get_vested_for_tranche(address user, uint8 tranche_id) external view returns(uint256);\n', '  function user_total_all_tranches(address user) external view returns(uint256);\n', '}\n', '\n', 'contract VEGA_Pool is Ownable {\n', '\n', '  uint256 public constant EXEPECTED_VEGA = 422000 ether;\n', '  uint256 public constant EQUITY_RATIO = 2500;\n', '\n', '  uint256 public assignSharesCutoff;\n', '  uint256 public equityTokens;\n', '  uint256 public equityTokensRedeemed;\n', '  uint256 public preferentialTokens;\n', '  uint256 public preferentialTokensRedeemed;\n', '\n', '  address public preferentialAddress;\n', '\n', '  bool public initialized = false;\n', '\n', '  ISHP public shp;\n', '  IERC20 public vega;\n', '  IVegaVesting public vegaVesting;\n', '\n', '  uint256 public referenceBlock;\n', '\n', '  bool public voteComplete = false;\n', '  bool public approveDistribution = false;\n', '\n', '  mapping(address => uint256) public equityShares;\n', '  mapping(address => bool) public permittedEquityHolders;\n', '  mapping(uint256 => address) public equityHolders;\n', '  mapping(address => int8) public distributionVotes;\n', '  mapping(address => bool) public shpTokensRedeemed;\n', '\n', '  uint256 public totalEquityHolders;\n', '  uint256 public totalShares;\n', '  uint256 public totalVotes;\n', '  int256 public voteOutcome;\n', '  uint256 public shpRedemptionCount;\n', '\n', '  event VoteCast(int8 vote, address shareholder);\n', '  event TokensClaimed(uint256 amount, address recipient);\n', '  event ERC20TokenWithdrawn(uint256 amount, address tokenAddress);\n', '  event EtherWithdrawn(uint256 amount);\n', '  event EquityIssued(address holder, uint256 amount,\n', '    uint256 totalEquityHolders, uint256 totalShares);\n', '  event PreferentialTokensRedeemed(uint256 amount);\n', '  event EquityTokensRedeemed(address recipient, uint256 amount);\n', '  event ExcessTokensRedeemed(uint256 amount);\n', '  event PermittedEquityHolderAdded(address holder);\n', '  event VegaPoolInitialized(address vegaAddress, address vestingAddress,\n', '    address preferentialAddress, uint256 assignSharesCutoff,\n', '    uint256 referenceBlock, address shpTokenAddress);\n', '\n', '  // This modifier makes sure the contract has been initialized\n', '  modifier requireInitialized() {\n', '     require(initialized, "Contract is not initialized.");\n', '     _;\n', '  }\n', '\n', '  // This modifier makes sure the contract is not initialized\n', '  modifier notInitialized() {\n', '     require(!initialized, "Contract has been initialized.");\n', '     _;\n', '  }\n', '\n', '  receive() external payable { }\n', '\n', '  /**\n', '  * This function allows equity holders to vote on whether tokens should\n', '  * remain theirs, or whether they should be made available for redemption\n', '  * by SHP token holders.\n', '  *\n', '  * If they vote to allow SHP token holders to redeem VEGA from the contract\n', '  * then SHP token holders will be able to call the claimTokens function\n', '  * and the amount of VEGA will be calculated based on their SHP holding\n', '  * at the reference Ethereum block.\n', '  *\n', '  * Once the vote has been successfully completed, if the equity holders vote\n', '  * AGAINST distrubiton, they will be able to redeem tokens by calling\n', '  * redeemTokensViaEquity. If they vote FOR distribution they will not be\n', '  * able to redeem any tokens. Instead SHP token holders will be able to\n', '  * redeem tokens by calling claimTokens.\n', '  *\n', "  * _vote   the user's vote (1 = for, -1 = against)\n", '  **/\n', '  function castVote(int8 _vote) requireInitialized public {\n', '    require(block.timestamp > assignSharesCutoff,\n', '      "Cannot vote whilst shares can still be assigned.");\n', '    require(distributionVotes[msg.sender] == 0,\n', '      "You have already cast your vote.");\n', '    require(_vote == 1 || _vote == -1,\n', '      "Vote must be 1 or -1");\n', '    require(voteComplete == false,\n', '      "Voting has already concluded.");\n', '    require(equityShares[msg.sender] > 0,\n', '      "You cannot vote without equity shares.");\n', '    int256 weight = int256(getUserEquity(msg.sender));\n', '    distributionVotes[msg.sender] = _vote;\n', '    totalVotes += 1;\n', '    voteOutcome += (_vote * weight);\n', '    if(totalVotes == totalEquityHolders) {\n', '      voteComplete = true;\n', '      approveDistribution = voteOutcome > 0;\n', '    }\n', '    emit VoteCast(_vote, msg.sender);\n', '  }\n', '\n', '  /**\n', '  * This function withdraws any vested tokens and redeems the preferential\n', '  * tokens if they have not already been redeemed.\n', '  **/\n', '  function syncTokens() requireInitialized internal {\n', '    withdrawVestedTokens();\n', '    if(preferentialTokens > preferentialTokensRedeemed) {\n', '      redeemPreferentialTokens();\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function allows users that held SHP at the reference Ethereum block\n', '  * to claim VEGA from the smart contract, provided the equity holders have\n', '  * voted to permit them to do so.\n', '  *\n', '  * If permitted to do so, the equityTokens will be made available to users\n', '  * in direct proportion to the SHP held (divided by total supply) at the\n', '  * reference block.\n', '  **/\n', '  function claimTokens() requireInitialized public {\n', '    require(approveDistribution, "Distribution is not approved");\n', '    syncTokens();\n', '    require(preferentialTokens == preferentialTokensRedeemed,\n', '      "Cannot claim until preferential tokens are redeemed.");\n', '    uint256 shpBalance = shp.balanceOfAt(msg.sender, referenceBlock);\n', '    require(shpTokensRedeemed[msg.sender] == false,\n', '      "SHP holder already claimed tokens.");\n', '    uint256 vegaBalance = vega.balanceOf(address(this));\n', '    require(shpRedemptionCount > 0 || vegaBalance >= equityTokens,\n', '      "Cannot claim until all equity tokens are fully vested.");\n', '    uint256 shpSupply = shp.totalSupplyAt(referenceBlock);\n', '    uint256 mod = 1000000000000;\n', '    uint256 tokenAmount = (((shpBalance * mod) / shpSupply) *\n', '      equityTokens) / mod;\n', '    vega.transfer(msg.sender, tokenAmount);\n', '    equityTokensRedeemed += tokenAmount;\n', '    shpTokensRedeemed[msg.sender] = true;\n', '    shpRedemptionCount += 1;\n', '    emit TokensClaimed(tokenAmount, msg.sender);\n', '  }\n', '\n', '  /**\n', '  * This function allows the owner to withdraw any ERC20 which is not VEGA\n', '  * from the contract at-will. This can be used to redeem staking rewards,\n', '  * or other ERC20s which might end up in this contract by mistake, or by\n', '  * something like an airdrop.\n', '  *\n', '  * _tokenAddress    the contract address for the ERC20\n', '  **/\n', '  function withdrawArbitraryTokens(\n', '    address _tokenAddress\n', '  ) requireInitialized onlyOwner public {\n', '    require(_tokenAddress != address(vega),\n', '      "VEGA cannot be withdrawn at-will.");\n', '    IERC20 token = IERC20(_tokenAddress);\n', '    uint256 amount = token.balanceOf(address(this));\n', '    token.transfer(owner(), amount);\n', '    emit ERC20TokenWithdrawn(amount, _tokenAddress);\n', '  }\n', '\n', '  /**\n', '  * This function performs the same role as withdrawArbitraryTokens, except\n', '  * it is used to withdraw ETH.\n', '  **/\n', '  function withdrawEther() requireInitialized onlyOwner public {\n', '    uint256 amount = address(this).balance;\n', '    payable(owner()).transfer(amount);\n', '    emit EtherWithdrawn(amount);\n', '  }\n', '\n', '  /**\n', '  * This function can be called by anybody and it withdraws unlocked\n', '  * VEGA tokens from the vesting contract. The tokens are transferred\n', '  * to this contract, which allows them to be redeemed by the rightful owner\n', '  * when they call one of the redemption functions.\n', '  **/\n', '  function withdrawVestedTokens() requireInitialized internal {\n', '    for(uint8 i = 1; i < vegaVesting.tranche_count(); i++) {\n', '      if(vegaVesting.get_vested_for_tranche(address(this), i) > 0) {\n', '        vegaVesting.withdraw_from_tranche(i);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * This function allows the owner to issue equity to new users. This is done\n', '  * by assigning an absolute number of shares, which in turn dilutes all\n', '  * existing share holders.\n', '  *\n', '  * _holder    the Ethereum address of the equity holder\n', '  * _amount    the number of shares to be assigned to the holder\n', '  **/\n', '  function issueEquity(\n', '    address _holder,\n', '    uint256 _amount\n', '  ) requireInitialized onlyOwner public {\n', '    require(permittedEquityHolders[_holder],\n', '      "The holder must be permitted to own equity.");\n', '    require(assignSharesCutoff > block.timestamp,\n', '      "The cutoff has passed for assigning shares.");\n', '    if(equityShares[_holder] == 0) {\n', '      equityHolders[totalEquityHolders] = _holder;\n', '      totalEquityHolders += 1;\n', '    }\n', '    totalShares += _amount;\n', '    equityShares[_holder] += _amount;\n', '    emit EquityIssued(_holder, _amount, totalEquityHolders, totalShares);\n', '  }\n', '\n', '  /**\n', '  * This function allows the preferential tokens to be distributed to the\n', '  * rightful owner. This function can be called by anybody.\n', '  **/\n', '  function redeemPreferentialTokens() requireInitialized public {\n', '    require(preferentialTokens > preferentialTokensRedeemed,\n', '      "All preferntial tokens have been redeemed.");\n', '    withdrawVestedTokens();\n', '    uint256 availableTokens = preferentialTokens - preferentialTokensRedeemed;\n', '    uint256 vegaBalance = vega.balanceOf(address(this));\n', '    if(availableTokens > vegaBalance) {\n', '      availableTokens = vegaBalance;\n', '    }\n', '    vega.transfer(preferentialAddress, availableTokens);\n', '    preferentialTokensRedeemed += availableTokens;\n', '    emit PreferentialTokensRedeemed(availableTokens);\n', '  }\n', '\n', '  /**\n', '  * This function distributes tokens to equity holders based on the amount\n', '  * of shares they own.\n', '  *\n', '  * Anybody can call this function in order to ensure all of the tokens are\n', '  * distributed when it becomes eligible to do so.\n', '  **/\n', '  function redeemTokensViaEquity() requireInitialized public {\n', '    require(totalShares > 0, "There are are no equity holders");\n', '    require(assignSharesCutoff < block.timestamp,\n', '      "Tokens cannot be redeemed whilst equity can still be assigned.");\n', '    syncTokens();\n', '    require(preferentialTokens == preferentialTokensRedeemed,\n', '      "Cannot redeem via equity until all preferential tokens are collected.");\n', '    require(voteComplete, "Cannot redeem via equity until vote is completed.");\n', '    require(approveDistribution == false,\n', '      "Tokens can only be redeemed by SHP holders.");\n', '    uint256 availableTokens = equityTokens - equityTokensRedeemed;\n', '    uint256 vegaBalance = vega.balanceOf(address(this));\n', '    if(availableTokens > vegaBalance) {\n', '      availableTokens = vegaBalance;\n', '    }\n', '    for(uint256 i = 0; i < totalEquityHolders; i++) {\n', '      uint256 tokensToRedeem = (availableTokens *\n', '        getUserEquity(equityHolders[i])) / 10000;\n', '      vega.transfer(equityHolders[i], tokensToRedeem);\n', '      equityTokensRedeemed += tokensToRedeem;\n', '      emit EquityTokensRedeemed(equityHolders[i], tokensToRedeem);\n', '    }\n', '  }\n', '\n', '  /**\n', "  * This function allows anybody to redeem excess VEGA to the owner's wallet\n", '  * provided the following conditions are met:\n', '  *\n', '  * 1) No equity shares exist, which happens under two scenarios:\n', '  *      a) They are never issued in the first place\n', '  *      b) They are burnt after redeeming VEGA\n', '  * 2) The cut-off for assigning equity shares is in the past\n', '  *\n', '  * This function transfers the entire VEGA balance held by the\n', '  * smart contract at execution time.\n', '  **/\n', '  function redeemExcessTokens() requireInitialized public {\n', '    if(totalEquityHolders > 0) {\n', '      require(equityTokens == equityTokensRedeemed,\n', '        "Cannot redeem excess tokens until equity tokens are collected.");\n', '    }\n', '    require(preferentialTokens == preferentialTokensRedeemed,\n', '      "Cannot redeem excess tokens until preferential tokens are collected.");\n', '    withdrawVestedTokens();\n', '    uint256 amount = vega.balanceOf(address(this));\n', '    emit ExcessTokensRedeemed(amount);\n', '    vega.transfer(owner(), amount);\n', '  }\n', '\n', '  /**\n', '  * This function calculates the equity of the specified user\n', '  *\n', '  * _holder    the Ethereum address of the equity holder\n', '  **/\n', '  function getUserEquity(\n', '    address _holder\n', '  ) public view returns(uint256) {\n', '    return (equityShares[_holder] * 10000) / totalShares;\n', '  }\n', '\n', '  /**\n', '  * This function allows the contract to be initialized only once.\n', '  * We do not use the constructor, because the Vega vesting contract needs to\n', '  * know the address of this smart contract when it is deployed. Therefore,\n', '  * this contract needs to be deployed, and then updated with the address of\n', '  * the Vega vesting contract afterwards.\n', '  *\n', '  * _vegaAdress           the Ethereum address of the VEGA token contract\n', "  * _vegaVestingAddress   the Ethereum address of Vega's vesting contract\n", '  * _preferentialAddress  Ethereum address for preferential tokens\n', '  * _holders              an array of permitted equity holders\n', '  * _assignSharesCutoff   timestamp after which shares cannot be assigned\n', '  * _referenceBlock       the Ethereum block to lookup SHP balances with\n', '  * _shpTokenAddress      the Ethereum address for SHP token contract\n', '  **/\n', '  function initialize(\n', '    address _vegaAddress,\n', '    address _vegaVestingAddress,\n', '    address _preferentialAddress,\n', '    address[] memory _holders,\n', '    uint256 _assignSharesCutoff,\n', '    uint256 _referenceBlock,\n', '    address _shpTokenAddress\n', '  ) public onlyOwner notInitialized {\n', '    vega = IERC20(_vegaAddress);\n', '    shp = ISHP(_shpTokenAddress);\n', '    vegaVesting = IVegaVesting(_vegaVestingAddress);\n', '    uint256 totalTokens = vegaVesting.user_total_all_tranches(address(this));\n', '    preferentialAddress = _preferentialAddress;\n', '    assignSharesCutoff = _assignSharesCutoff;\n', '    referenceBlock = _referenceBlock;\n', '    require(totalTokens >= EXEPECTED_VEGA,\n', '      "The balance at the vesting contract is too low.");\n', '    for(uint8 x = 0; x < _holders.length; x++) {\n', '      permittedEquityHolders[_holders[x]] = true;\n', '      emit PermittedEquityHolderAdded(_holders[x]);\n', '    }\n', '    equityTokens = (totalTokens * EQUITY_RATIO) / 10000;\n', '    preferentialTokens = totalTokens - equityTokens;\n', '    initialized = true;\n', '    emit VegaPoolInitialized(_vegaAddress, _vegaVestingAddress,\n', '      _preferentialAddress, _assignSharesCutoff,\n', '      _referenceBlock, _shpTokenAddress);\n', '  }\n', '}']