['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', 'import "./Keep3rV2Oracle.sol";\n', '\n', 'contract Keep3rV2OracleFactory {\n', '    function pairForSushi(address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        pair = address(\n', '            uint160(\n', '                uint256(\n', '                    keccak256(\n', '                        abi.encodePacked(\n', '                            hex"ff",\n', '                            0xc35DADB65012eC5796536bD9864eD8773aBc74C4,\n', '                            keccak256(abi.encodePacked(token0, token1)),\n', '                            hex"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303" // init code hash\n', '                        )\n', '                    )\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    function pairForUni(address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        pair = address(\n', '            uint160(\n', '                uint256(\n', '                    keccak256(\n', '                        abi.encodePacked(\n', '                            hex"ff",\n', '                            0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\n', '                            keccak256(abi.encodePacked(token0, token1)),\n', '                            hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f" // init code hash\n', '                        )\n', '                    )\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    modifier keeper() {\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '    }\n', '\n', '    modifier upkeep() {\n', '        uint256 _gasUsed = gasleft();\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '        uint256 _received = KP3R.KPRH().getQuoteLimit(_gasUsed - gasleft());\n', '        KP3R.receipt(address(KP3R), msg.sender, _received);\n', '    }\n', '\n', '    address public governance;\n', '    address public pendingGovernance;\n', '\n', '    /**\n', '     * @notice Allows governance to change governance (for future upgradability)\n', '     * @param _governance new governance address to set\n', '     */\n', '    function setGovernance(address _governance) external {\n', '        require(msg.sender == governance, "!G");\n', '        pendingGovernance = _governance;\n', '    }\n', '\n', '    /**\n', '     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n', '     */\n', '    function acceptGovernance() external {\n', '        require(msg.sender == pendingGovernance, "!pG");\n', '        governance = pendingGovernance;\n', '    }\n', '\n', '    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n', '\n', '    address[] internal _pairs;\n', '    mapping(address => Keep3rV2Oracle) public feeds;\n', '\n', '    function pairs() external view returns (address[] memory) {\n', '        return _pairs;\n', '    }\n', '\n', '    constructor() {\n', '        governance = msg.sender;\n', '    }\n', '\n', '    function update(address pair) external keeper returns (bool) {\n', '        return feeds[pair].update();\n', '    }\n', '\n', '    function byteCode(address pair) external pure returns (bytes memory bytecode) {\n', '        bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n', '    }\n', '\n', '    function deploy(address pair) external returns (address feed) {\n', '        require(msg.sender == governance, "!G");\n', '        require(address(feeds[pair]) == address(0), "PE");\n', '        bytes memory bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n', '        bytes32 salt = keccak256(abi.encodePacked(pair));\n', '        assembly {\n', '            feed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n', '            if iszero(extcodesize(feed)) {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '        feeds[pair] = Keep3rV2Oracle(feed);\n', '        _pairs.push(pair);\n', '    }\n', '\n', '    function work() external upkeep {\n', '        require(workable(), "!W");\n', '        for (uint256 i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function work(address pair) external upkeep {\n', '        require(feeds[pair].update(), "!W");\n', '    }\n', '\n', '    function workForFree() external keeper {\n', '        for (uint256 i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function workForFree(address pair) external keeper {\n', '        feeds[pair].update();\n', '    }\n', '\n', '    function cache(uint256 size) external {\n', '        for (uint256 i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].cache(size);\n', '        }\n', '    }\n', '\n', '    function cache(address pair, uint256 size) external {\n', '        feeds[pair].cache(size);\n', '    }\n', '\n', '    function workable() public view returns (bool canWork) {\n', '        canWork = true;\n', '        for (uint256 i = 0; i < _pairs.length; i++) {\n', '            if (!feeds[_pairs[i]].updateable()) {\n', '                canWork = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    function workable(address pair) public view returns (bool) {\n', '        return feeds[pair].updateable();\n', '    }\n', '\n', '    function sample(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points,\n', '        uint256 window,\n', '        bool sushiswap\n', '    ) external view returns (uint256[] memory prices, uint256 lastUpdatedAgo) {\n', '        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n', '        return feeds[_pair].sample(tokenIn, amountIn, tokenOut, points, window);\n', '    }\n', '\n', '    function sample(\n', '        address pair,\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points,\n', '        uint256 window\n', '    ) external view returns (uint256[] memory prices, uint256 lastUpdatedAgo) {\n', '        return feeds[pair].sample(tokenIn, amountIn, tokenOut, points, window);\n', '    }\n', '\n', '    function quote(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points,\n', '        bool sushiswap\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n', '        return feeds[_pair].quote(tokenIn, amountIn, tokenOut, points);\n', '    }\n', '\n', '    function quote(\n', '        address pair,\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        return feeds[pair].quote(tokenIn, amountIn, tokenOut, points);\n', '    }\n', '\n', '    function current(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        bool sushiswap\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        address _pair = sushiswap ? pairForSushi(tokenIn, tokenOut) : pairForUni(tokenIn, tokenOut);\n', '        return feeds[_pair].current(tokenIn, amountIn, tokenOut);\n', '    }\n', '\n', '    function current(\n', '        address pair,\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        return feeds[pair].current(tokenIn, amountIn, tokenOut);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'interface IKeep3rV1 {\n', '    function keepers(address keeper) external returns (bool);\n', '\n', '    function KPRH() external view returns (IKeep3rV1Helper);\n', '\n', '    function receipt(\n', '        address credit,\n', '        address keeper,\n', '        uint256 amount\n', '    ) external;\n', '}\n', '\n', 'interface IKeep3rV1Helper {\n', '    function getQuoteLimit(uint256 gasUsed) external view returns (uint256);\n', '}\n', '\n', '// sliding oracle that uses observations collected to provide moving price averages in the past\n', 'contract Keep3rV2Oracle {\n', '    constructor(address _pair) {\n', '        _factory = msg.sender;\n', '        pair = _pair;\n', '        (, , uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\n', '        uint112 _price0CumulativeLast = uint112((IUniswapV2Pair(_pair).price0CumulativeLast() * e10) / Q112);\n', '        uint112 _price1CumulativeLast = uint112((IUniswapV2Pair(_pair).price1CumulativeLast() * e10) / Q112);\n', '        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '    }\n', '\n', '    struct Observation {\n', '        uint32 timestamp;\n', '        uint112 price0Cumulative;\n', '        uint112 price1Cumulative;\n', '    }\n', '\n', '    modifier factory() {\n', '        require(msg.sender == _factory, "!F");\n', '        _;\n', '    }\n', '\n', '    Observation[65535] public observations;\n', '    uint16 public length;\n', '\n', '    address immutable _factory;\n', '    address public immutable pair;\n', '    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n', '    uint256 constant periodSize = 1800;\n', '    uint256 Q112 = 2**112;\n', '    uint256 e10 = 10**18;\n', '\n', '    // Pre-cache slots for cheaper oracle writes\n', '    function cache(uint256 size) external {\n', '        uint256 _length = length + size;\n', '        for (uint256 i = length; i < _length; i++) observations[i].timestamp = 1;\n', '    }\n', '\n', '    // update the current feed for free\n', '    function update() external factory returns (bool) {\n', '        return _update();\n', '    }\n', '\n', '    function updateable() external view returns (bool) {\n', '        Observation memory _point = observations[length - 1];\n', '        (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint256 timeElapsed = timestamp - _point.timestamp;\n', '        return timeElapsed > periodSize;\n', '    }\n', '\n', '    function _update() internal returns (bool) {\n', '        Observation memory _point = observations[length - 1];\n', '        (, , uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint32 timeElapsed = timestamp - _point.timestamp;\n', '        if (timeElapsed > periodSize) {\n', '            uint112 _price0CumulativeLast = uint112((IUniswapV2Pair(pair).price0CumulativeLast() * e10) / Q112);\n', '            uint112 _price1CumulativeLast = uint112((IUniswapV2Pair(pair).price1CumulativeLast() * e10) / Q112);\n', '            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _computeAmountOut(\n', '        uint256 start,\n', '        uint256 end,\n', '        uint256 elapsed,\n', '        uint256 amountIn\n', '    ) internal view returns (uint256 amountOut) {\n', '        amountOut = (amountIn * (end - start)) / e10 / elapsed;\n', '    }\n', '\n', '    function current(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        Observation memory _observation = observations[length - 1];\n', '        uint256 price0Cumulative = (IUniswapV2Pair(pair).price0CumulativeLast() * e10) / Q112;\n', '        uint256 price1Cumulative = (IUniswapV2Pair(pair).price1CumulativeLast() * e10) / Q112;\n', '        (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '\n', '        // Handle edge cases where we have no updates, will revert on first reading set\n', '        if (timestamp == _observation.timestamp) {\n', '            _observation = observations[length - 2];\n', '        }\n', '\n', '        uint256 timeElapsed = timestamp - _observation.timestamp;\n', '        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n', '        if (token0 == tokenIn) {\n', '            amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n', '        } else {\n', '            amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n', '        }\n', '        lastUpdatedAgo = timeElapsed;\n', '    }\n', '\n', '    function quote(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points\n', '    ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\n', '        (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        uint256 priceAverageCumulative = 0;\n', '        uint256 _length = length - 1;\n', '        uint256 i = _length - points;\n', '        Observation memory currentObservation;\n', '        Observation memory nextObservation;\n', '\n', '        uint256 nextIndex = 0;\n', '        if (token0 == tokenIn) {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i + 1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price0Cumulative,\n', '                    nextObservation.price0Cumulative,\n', '                    nextObservation.timestamp - currentObservation.timestamp,\n', '                    amountIn\n', '                );\n', '            }\n', '        } else {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i + 1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price1Cumulative,\n', '                    nextObservation.price1Cumulative,\n', '                    nextObservation.timestamp - currentObservation.timestamp,\n', '                    amountIn\n', '                );\n', '            }\n', '        }\n', '        amountOut = priceAverageCumulative / points;\n', '\n', '        (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '    }\n', '\n', '    function sample(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        address tokenOut,\n', '        uint256 points,\n', '        uint256 window\n', '    ) external view returns (uint256[] memory prices, uint256 lastUpdatedAgo) {\n', '        (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '        prices = new uint256[](points);\n', '\n', '        if (token0 == tokenIn) {\n', '            {\n', '                uint256 _length = length - 1;\n', '                uint256 i = _length - (points * window);\n', '                uint256 _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i += window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price0Cumulative,\n', '                        nextObservation.price0Cumulative,\n', '                        nextObservation.timestamp - currentObservation.timestamp,\n', '                        amountIn\n', '                    );\n', '                    _index = _index + 1;\n', '                }\n', '\n', '                (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '            }\n', '        } else {\n', '            {\n', '                uint256 _length = length - 1;\n', '                uint256 i = _length - (points * window);\n', '                uint256 _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i += window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price1Cumulative,\n', '                        nextObservation.price1Cumulative,\n', '                        nextObservation.timestamp - currentObservation.timestamp,\n', '                        amountIn\n', '                    );\n', '                    _index = _index + 1;\n', '                }\n', '\n', '                (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 99999\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']