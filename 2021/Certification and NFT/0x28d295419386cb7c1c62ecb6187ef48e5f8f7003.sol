['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '//Slightly modified SafeMath library - includes a min and max function, removes useless div function\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function add(int256 a, int256 b) internal pure returns (int256 c) {\n', '        if (b > 0) {\n', '            c = a + b;\n', '            assert(c >= a);\n', '        } else {\n', '            c = a + b;\n', '            assert(c <= a);\n', '        }\n', '    }\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a > b ? a : b;\n', '    }\n', '\n', '    function max(int256 a, int256 b) internal pure returns (uint256) {\n', '        return a > b ? uint256(a) : uint256(b);\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(int256 a, int256 b) internal pure returns (int256 c) {\n', '        if (b > 0) {\n', '            c = a - b;\n', '            assert(c <= a);\n', '        } else {\n', '            c = a - b;\n', '            assert(c >= a);\n', '        }\n', '\n', '    }\n', '}\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Tellor Oracle Storage Library\n', ' * @dev Contains all the variables/structs used by Tellor\n', ' */\n', '\n', 'library TellorStorage {\n', '    //Internal struct for use in proof-of-work submission\n', '    struct Details {\n', '        uint256 value;\n', '        address miner;\n', '    }\n', '\n', '    struct Dispute {\n', '        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\n', '        int256 tally; //current tally of votes for - against measure\n', '        bool executed; //is the dispute settled\n', '        bool disputeVotePassed; //did the vote pass?\n', '        bool isPropFork; //true for fork proposal NEW\n', "        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\n", "        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\n", '        address proposedForkAddress; //new fork address (if fork proposal)\n', '        mapping(bytes32 => uint256) disputeUintVars;\n', '        //Each of the variables below is saved in the mapping disputeUintVars for each disputeID\n', '        //e.g. TellorStorageStruct.DisputeById[disputeID].disputeUintVars[keccak256("requestId")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("requestId");//apiID of disputed value\n', '        // uint keccak256("timestamp");//timestamp of disputed value\n', '        // uint keccak256("value"); //the value being disputed\n', '        // uint keccak256("minExecutionDate");//7 days from when dispute initialized\n', '        // uint keccak256("numberOfVotes");//the number of parties who have voted on the measure\n', '        // uint keccak256("blockNumber");// the blocknumber for which votes will be calculated from\n', '        // uint keccak256("minerSlot"); //index in dispute array\n', '        // uint keccak256("fee"); //fee paid corresponding to dispute\n', '        mapping(address => bool) voted; //mapping of address to whether or not they voted\n', '    }\n', '\n', '    struct StakeInfo {\n', '        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\n', '        uint256 startDate; //stake start date\n', '    }\n', '\n', '    //Internal struct to allow balances to be queried by blocknumber for voting purposes\n', '    struct Checkpoint {\n', '        uint128 fromBlock; // fromBlock is the block number that the value was generated from\n', '        uint128 value; // value is the amount of tokens at a specific block number\n', '    }\n', '\n', '    struct Request {\n', '        string queryString; //id to string api\n', '        string dataSymbol; //short name for api request\n', '        bytes32 queryHash; //hash of api string and granularity e.g. keccak256(abi.encodePacked(_api,_granularity))\n', '        uint256[] requestTimestamps; //array of all newValueTimestamps requested\n', '        mapping(bytes32 => uint256) apiUintVars;\n', '        //Each of the variables below is saved in the mapping apiUintVars for each api request\n', '        //e.g. requestDetails[_requestId].apiUintVars[keccak256("totalTip")]\n', '        //These are the variables saved in this mapping:\n', '        // uint keccak256("granularity"); //multiplier for miners\n', '        // uint keccak256("requestQPosition"); //index in requestQ\n', '        // uint keccak256("totalTip");//bonus portion of payout\n', '        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\n', '        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\n', '        mapping(uint256 => uint256) finalValues;\n', '        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\n', '        mapping(uint256 => address[5]) minersByValue;\n', '        mapping(uint256 => uint256[5]) valuesByTimestamp;\n', '    }\n', '\n', '    struct TellorStorageStruct {\n', '        bytes32 currentChallenge; //current challenge to be solved\n', '        uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\n', '        uint256[] newValueTimestamps; //array of all timestamps requested\n', '        Details[5] currentMiners; //This struct is for organizing the five mined values to find the median\n', '        mapping(bytes32 => address) addressVars;\n', '        //Address fields in the Tellor contract are saved the addressVars mapping\n', '        //e.g. addressVars[keccak256("tellorContract")] = address\n', '        //These are the variables saved in this mapping:\n', '        // address keccak256("tellorContract");//Tellor address\n', '        // address  keccak256("_owner");//Tellor Owner address\n', '        // address  keccak256("_deity");//Tellor Owner that can do things at will\n', '        // address  keccak256("pending_owner"); // The proposed new owner\n', '        mapping(bytes32 => uint256) uintVars;\n', '        //uint fields in the Tellor contract are saved the uintVars mapping\n', '        //e.g. uintVars[keccak256("decimals")] = uint\n', '        //These are the variables saved in this mapping:\n', '        // keccak256("decimals");    //18 decimal standard ERC20\n', '        // keccak256("disputeFee");//cost to dispute a mined value\n', '        // keccak256("disputeCount");//totalHistoricalDisputes\n', '        // keccak256("total_supply"); //total_supply of the token in circulation\n', '        // keccak256("stakeAmount");//stakeAmount for miners (we can cut gas if we just hardcoded it in...or should it be variable?)\n', '        // keccak256("stakerCount"); //number of parties currently staked\n', '        // keccak256("timeOfLastNewValue"); // time of last challenge solved\n', '        // keccak256("difficulty"); // Difficulty of current block\n', '        // keccak256("currentTotalTips"); //value of highest api/timestamp PayoutPool\n', '        // keccak256("currentRequestId"); //API being mined--updates with the ApiOnQ Id\n', '        // keccak256("requestCount"); // total number of requests through the system\n', '        // keccak256("slotProgress");//Number of miners who have mined this value so far\n', '        // keccak256("miningReward");//Mining Reward in PoWo tokens given to all miners per value\n', '        // keccak256("timeTarget"); //The time between blocks (mined Oracle values)\n', '        // keccak256("_tblock"); //\n', '        // keccak256("runningTips"); // VAriable to track running tips\n', '        // keccak256("currentReward"); // The current reward\n', '        // keccak256("devShare"); // The amount directed towards th devShare\n', '        // keccak256("currentTotalTips"); //\n', '        //This is a boolean that tells you if a given challenge has been completed by a given miner\n', '        mapping(bytes32 => mapping(address => bool)) minersByChallenge;\n', '        mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\n', '        mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\n', '        mapping(uint256 => Dispute) disputesById; //disputeId=> Dispute details\n', '        mapping(address => Checkpoint[]) balances; //balances of a party given blocks\n', '        mapping(address => mapping(address => uint256)) allowed; //allowance for a given party and approver\n', '        mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\n', '        mapping(uint256 => Request) requestDetails; //mapping of apiID to details\n', '        mapping(bytes32 => uint256) requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\n', '        mapping(bytes32 => uint256) disputeIdByDisputeHash; //maps a hash to an ID for each dispute\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '/**\n', '* @title Tellor Transfer\n', '* @dev Contains the methods related to transfers and ERC20. Tellor.sol and TellorGetters.sol\n', "* reference this library for function's logic.\n", '*/\n', 'library TellorTransfer {\n', '    using SafeMath for uint256;\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value); //ERC20 Approval event\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value); //ERC20 Transfer Event\n', '\n', '    bytes32 public constant stakeAmount = 0x7be108969d31a3f0b261465c71f2b0ba9301cd914d55d9091c3b36a49d4d41b2; //keccak256("stakeAmount")\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '    * @dev Allows for a transfer of tokens to _to\n', '    * @param _to The address to send tokens to\n', '    * @param _amount The amount of tokens to send\n', '    * @return true if transfer is successful\n', '    */\n', '    function transfer(TellorStorage.TellorStorageStruct storage self, address _to, uint256 _amount) public returns (bool success) {\n', '        doTransfer(self, msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @notice Send _amount tokens to _to from _from on the condition it\n', '    * is approved by _from\n', '    * @param _from The address holding the tokens being transferred\n', '    * @param _to The address of the recipient\n', '    * @param _amount The amount of tokens to be transferred\n', '    * @return True if the transfer was successful\n', '    */\n', '    function transferFrom(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(self.allowed[_from][msg.sender] >= _amount, "Allowance is wrong");\n', '        self.allowed[_from][msg.sender] -= _amount;\n', '        doTransfer(self, _from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev This function approves a _spender an _amount of tokens to use\n', '    * @param _spender address\n', '    * @param _amount amount the spender is being approved for\n', '    * @return true if spender approved successfully\n', '    */\n', '    function approve(TellorStorage.TellorStorageStruct storage self, address _spender, uint256 _amount) public returns (bool) {\n', '        require(_spender != address(0), "Spender is 0-address");\n', '        require(self.allowed[msg.sender][_spender] == 0 || _amount == 0, "Spender is already approved");\n', '        self.allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @param _user address of party with the balance\n', '    * @param _spender address of spender of parties said balance\n', '    * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n', '    */\n', '    function allowance(TellorStorage.TellorStorageStruct storage self, address _user, address _spender) public view returns (uint256) {\n', '        return self.allowed[_user][_spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Completes POWO transfers by updating the balances on the current block number\n', '    * @param _from address to transfer from\n', '    * @param _to address to transfer to\n', '    * @param _amount to transfer\n', '    */\n', '    function doTransfer(TellorStorage.TellorStorageStruct storage self, address _from, address _to, uint256 _amount) public {\n', '        require(_amount != 0, "Tried to send non-positive amount");\n', '        require(_to != address(0), "Receiver is 0 address");\n', '        require(allowedToTrade(self, _from, _amount), "Should have sufficient balance to trade");\n', '        uint256 previousBalance = balanceOf(self, _from);\n', '        updateBalanceAtNow(self.balances[_from], previousBalance - _amount);\n', '        previousBalance = balanceOf(self,_to);\n', '        require(previousBalance + _amount >= previousBalance, "Overflow happened"); // Check for overflow\n', '        updateBalanceAtNow(self.balances[_to], previousBalance + _amount);\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets balance of owner specified\n', '    * @param _user is the owner address used to look up the balance\n', '    * @return Returns the balance associated with the passed in _user\n', '    */\n', '    function balanceOf(TellorStorage.TellorStorageStruct storage self, address _user) public view returns (uint256) {\n', '        return balanceOfAt(self, _user, block.number);\n', '    }\n', '\n', '    /**\n', '    * @dev Queries the balance of _user at a specific _blockNumber\n', '    * @param _user The address from which the balance will be retrieved\n', '    * @param _blockNumber The block number when the balance is queried\n', '    * @return The balance at _blockNumber specified\n', '    */\n', '    function balanceOfAt(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _blockNumber) public view returns (uint256) {\n', '        TellorStorage.Checkpoint[] storage checkpoints = self.balances[_user];\n', '        if (checkpoints.length == 0|| checkpoints[0].fromBlock > _blockNumber) {\n', '            return 0;\n', '        } else {\n', '            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock) return checkpoints[checkpoints.length - 1].value;\n', '            // Binary search of the value in the array\n', '            uint256 min = 0;\n', '            uint256 max = checkpoints.length - 2;\n', '            while (max > min) {\n', '                uint256 mid = (max + min + 1) / 2;\n', '                if  (checkpoints[mid].fromBlock ==_blockNumber){\n', '                    return checkpoints[mid].value;\n', '                }else if(checkpoints[mid].fromBlock < _blockNumber) {\n', '                    min = mid;\n', '                } else {\n', '                    max = mid - 1;\n', '                }\n', '            }\n', '            return checkpoints[min].value;\n', '        }\n', '    }\n', '    /**\n', '    * @dev This function returns whether or not a given user is allowed to trade a given amount\n', '    * and removing the staked amount from their balance if they are staked\n', '    * @param _user address of user\n', '    * @param _amount to check if the user can spend\n', '    * @return true if they are allowed to spend the amount being checked\n', '    */\n', '    function allowedToTrade(TellorStorage.TellorStorageStruct storage self, address _user, uint256 _amount) public view returns (bool) { \n', '        if (self.stakerDetails[_user].currentStatus != 0 && self.stakerDetails[_user].currentStatus < 5) {\n', '            //Subtracts the stakeAmount from balance if the _user is staked\n', '            if (balanceOf(self, _user)- self.uintVars[stakeAmount] >= _amount) {\n', '                return true;\n', '            }\n', '            return false;\n', '        } \n', '        return (balanceOf(self, _user) >= _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Updates balance for from and to on the current block number via doTransfer\n', '    * @param checkpoints gets the mapping for the balances[owner]\n', '    * @param _value is the new balance\n', '    */\n', '    function updateBalanceAtNow(TellorStorage.Checkpoint[] storage checkpoints, uint256 _value) public {\n', '        if (checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number) {\n', '           checkpoints.push(TellorStorage.Checkpoint({\n', '                fromBlock : uint128(block.number),\n', '                value : uint128(_value)\n', '            }));\n', '        } else {\n', '            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '/**\n', ' * @title Tellor Dispute\n', " * @dev Contains the methods related to disputes. Tellor.sol references this library for function's logic.\n", ' */\n', '\n', 'library TellorDispute {\n', '    using SafeMath for uint256;\n', '    using SafeMath for int256;\n', '\n', '    //emitted when a new dispute is initialized\n', '    event NewDispute(\n', '        uint256 indexed _disputeId,\n', '        uint256 indexed _requestId,\n', '        uint256 _timestamp,\n', '        address _miner\n', '    );\n', '    //emitted when a new vote happens\n', '    event Voted(\n', '        uint256 indexed _disputeID,\n', '        bool _position,\n', '        address indexed _voter,\n', '        uint256 indexed _voteWeight\n', '    );\n', '    //emitted upon dispute tally\n', '    event DisputeVoteTallied(\n', '        uint256 indexed _disputeID,\n', '        int256 _result,\n', '        address indexed _reportedMiner,\n', '        address _reportingParty,\n', '        bool _active\n', '    );\n', '    event NewTellorAddress(address _newTellor); //emitted when a proposed fork is voted true\n', '\n', '    /*Functions*/\n', '\n', '    /**\n', '     * @dev Helps initialize a dispute by assigning it a disputeId\n', '     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n', '     * invalidated value information to POS voting\n', '     * @param _requestId being disputed\n', '     * @param _timestamp being disputed\n', '     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n', '     * requires 5 miners to submit a value.\n', '     */\n', '    function beginDispute(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        uint256 _requestId,\n', '        uint256 _timestamp,\n', '        uint256 _minerIndex\n', '    ) public {\n', '        TellorStorage.Request storage _request =\n', '            self.requestDetails[_requestId];\n', '        require(_request.minedBlockNum[_timestamp] != 0, "Mined block is 0");\n', '        require(_minerIndex < 5, "Miner index is wrong");\n', '\n', '        //_miner is the miner being disputed. For every mined value 5 miners are saved in an array and the _minerIndex\n', '        //provided by the party initiating the dispute\n', '        address _miner = _request.minersByValue[_timestamp][_minerIndex];\n', '        bytes32 _hash =\n', '            keccak256(abi.encodePacked(_miner, _requestId, _timestamp));\n', '\n', '        //Increase the dispute count by 1\n', '        uint256 disputeId = self.uintVars[keccak256("disputeCount")] + 1;\n', '        self.uintVars[keccak256("disputeCount")] = disputeId;\n', '\n', '        //Sets the new disputeCount as the disputeId\n', '\n', '        //Ensures that a dispute is not already open for the that miner, requestId and timestamp\n', '        uint256 hashId = self.disputeIdByDisputeHash[_hash];\n', '        if (hashId != 0) {\n', '            self.disputesById[disputeId].disputeUintVars[\n', '                keccak256("origID")\n', '            ] = hashId;\n', '        } else {\n', '            self.disputeIdByDisputeHash[_hash] = disputeId;\n', '            hashId = disputeId;\n', '        }\n', '        uint256 origID = hashId;\n', '        uint256 dispRounds =\n', '            self.disputesById[origID].disputeUintVars[\n', '                keccak256("disputeRounds")\n', '            ] + 1;\n', '        self.disputesById[origID].disputeUintVars[\n', '            keccak256("disputeRounds")\n', '        ] = dispRounds;\n', '        self.disputesById[origID].disputeUintVars[\n', '            keccak256(abi.encode(dispRounds))\n', '        ] = disputeId;\n', '        if (disputeId != origID) {\n', '            uint256 lastID =\n', '                self.disputesById[origID].disputeUintVars[\n', '                    keccak256(abi.encode(dispRounds - 1))\n', '                ];\n', '            require(\n', '                self.disputesById[lastID].disputeUintVars[\n', '                    keccak256("minExecutionDate")\n', '                ] <= now,\n', '                "Dispute is already open"\n', '            );\n', '            if (self.disputesById[lastID].executed) {\n', '                require(\n', '                    now -\n', '                        self.disputesById[lastID].disputeUintVars[\n', '                            keccak256("tallyDate")\n', '                        ] <=\n', '                        1 days,\n', '                    "Time for voting haven\'t elapsed"\n', '                );\n', '            }\n', '        }\n', '        uint256 _fee;\n', '        if (_minerIndex == 2) {\n', '            self.requestDetails[_requestId].apiUintVars[\n', '                keccak256("disputeCount")\n', '            ] =\n', '                self.requestDetails[_requestId].apiUintVars[\n', '                    keccak256("disputeCount")\n', '                ] +\n', '                1;\n', '            //update dispute fee for this case\n', '            _fee =\n', '                self.uintVars[keccak256("stakeAmount")] *\n', '                self.requestDetails[_requestId].apiUintVars[\n', '                    keccak256("disputeCount")\n', '                ];\n', '        } else {\n', '            _fee = self.uintVars[keccak256("disputeFee")] * dispRounds;\n', '        }\n', '\n', '        //maps the dispute to the Dispute struct\n', '        self.disputesById[disputeId] = TellorStorage.Dispute({\n', '            hash: _hash,\n', '            isPropFork: false,\n', '            reportedMiner: _miner,\n', '            reportingParty: msg.sender,\n', '            proposedForkAddress: address(0),\n', '            executed: false,\n', '            disputeVotePassed: false,\n', '            tally: 0\n', '        });\n', '\n', '        //Saves all the dispute variables for the disputeId\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("requestId")\n', '        ] = _requestId;\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("timestamp")\n', '        ] = _timestamp;\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("value")\n', '        ] = _request.valuesByTimestamp[_timestamp][_minerIndex];\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("minExecutionDate")\n', '        ] = now + 2 days * dispRounds;\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("blockNumber")\n', '        ] = block.number;\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("minerSlot")\n', '        ] = _minerIndex;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("fee")] = _fee;\n', '        TellorTransfer.doTransfer(self, msg.sender, address(this), _fee);\n', '\n', '        //Values are sorted as they come in and the official value is the median of the first five\n', '        //So the "official value" miner is always minerIndex==2. If the official value is being\n', '        //disputed, it sets its status to inDispute(currentStatus = 3) so that users are made aware it is under dispute\n', '        if (_minerIndex == 2) {\n', '            _request.inDispute[_timestamp] = true;\n', '            _request.finalValues[_timestamp] = 0;\n', '        }\n', '        self.stakerDetails[_miner].currentStatus = 3;\n', '        emit NewDispute(disputeId, _requestId, _timestamp, _miner);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows token holders to vote\n', '     * @param _disputeId is the dispute id\n', '     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n', '     */\n', '    function vote(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        uint256 _disputeId,\n', '        bool _supportsDispute\n', '    ) public {\n', '        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\n', '\n', '        //Get the voteWeight or the balance of the user at the time/blockNumber the dispute began\n', '        uint256 voteWeight =\n', '            TellorTransfer.balanceOfAt(\n', '                self,\n', '                msg.sender,\n', '                disp.disputeUintVars[keccak256("blockNumber")]\n', '            );\n', '\n', '        //Require that the msg.sender has not voted\n', '        require(disp.voted[msg.sender] != true, "Sender has already voted");\n', '\n', '        //Require that the user had a balance >0 at time/blockNumber the dispute began\n', '        require(voteWeight != 0, "User balance is 0");\n', '\n', '        //ensures miners that are under dispute cannot vote\n', '        require(\n', '            self.stakerDetails[msg.sender].currentStatus != 3,\n', '            "Miner is under dispute"\n', '        );\n', '\n', '        //Update user voting status to true\n', '        disp.voted[msg.sender] = true;\n', '\n', '        //Update the number of votes for the dispute\n', '        disp.disputeUintVars[keccak256("numberOfVotes")] += 1;\n', '\n', '        //If the user supports the dispute increase the tally for the dispute by the voteWeight\n', '        //otherwise decrease it\n', '        if (_supportsDispute) {\n', '            disp.tally = disp.tally.add(int256(voteWeight));\n', '        } else {\n', '            disp.tally = disp.tally.sub(int256(voteWeight));\n', '        }\n', '\n', '        //Let the network know the user has voted on the dispute and their casted vote\n', '        emit Voted(_disputeId, _supportsDispute, msg.sender, voteWeight);\n', '    }\n', '\n', '    /**\n', '     * @dev tallies the votes and locks the stake disbursement(currentStatus = 4) if the vote passes\n', '     * @param _disputeId is the dispute id\n', '     */\n', '    function tallyVotes(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        uint256 _disputeId\n', '    ) public {\n', '        TellorStorage.Dispute storage disp = self.disputesById[_disputeId];\n', '\n', '        //Ensure this has not already been executed/tallied\n', '        require(disp.executed == false, "Dispute has been already executed");\n', '        require(\n', '            now >= disp.disputeUintVars[keccak256("minExecutionDate")],\n', '            "Time for voting haven\'t elapsed"\n', '        );\n', '        require(\n', '            disp.reportingParty != address(0),\n', '            "reporting Party is address 0"\n', '        );\n', '        int256 _tally = disp.tally;\n', '        if (_tally > 0) {\n', '            //Set the dispute state to passed/true\n', '            disp.disputeVotePassed = true;\n', '        }\n', '        //If the vote is not a proposed fork\n', '        if (disp.isPropFork == false) {\n', '            //Ensure the time for voting has elapsed\n', '            TellorStorage.StakeInfo storage stakes =\n', '                self.stakerDetails[disp.reportedMiner];\n', '            //If the vote for disputing a value is successful(disp.tally >0) then unstake the reported\n', '            // miner and transfer the stakeAmount and dispute fee to the reporting party\n', '            if (stakes.currentStatus == 3) {\n', '                stakes.currentStatus = 4;\n', '            }\n', '        } else if (\n', '            uint256(_tally) >=\n', '            ((self.uintVars[keccak256("total_supply")] * 10) / 100)\n', '        ) {\n', '            emit NewTellorAddress(disp.proposedForkAddress);\n', '        }\n', '        disp.disputeUintVars[keccak256("tallyDate")] = now;\n', '        disp.executed = true;\n', '        emit DisputeVoteTallied(\n', '            _disputeId,\n', '            _tally,\n', '            disp.reportedMiner,\n', '            disp.reportingParty,\n', '            disp.disputeVotePassed\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Allows for a fork to be proposed\n', '     * @param _propNewTellorAddress address for new proposed Tellor\n', '     */\n', '    function proposeFork(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        address _propNewTellorAddress\n', '    ) public {\n', '        bytes32 _hash = keccak256(abi.encode(_propNewTellorAddress));\n', '        self.uintVars[keccak256("disputeCount")]++;\n', '        uint256 disputeId = self.uintVars[keccak256("disputeCount")];\n', '        if (self.disputeIdByDisputeHash[_hash] != 0) {\n', '            self.disputesById[disputeId].disputeUintVars[\n', '                keccak256("origID")\n', '            ] = self.disputeIdByDisputeHash[_hash];\n', '        } else {\n', '            self.disputeIdByDisputeHash[_hash] = disputeId;\n', '        }\n', '        uint256 origID = self.disputeIdByDisputeHash[_hash];\n', '\n', '        self.disputesById[origID].disputeUintVars[keccak256("disputeRounds")]++;\n', '        uint256 dispRounds =\n', '            self.disputesById[origID].disputeUintVars[\n', '                keccak256("disputeRounds")\n', '            ];\n', '        self.disputesById[origID].disputeUintVars[\n', '            keccak256(abi.encode(dispRounds))\n', '        ] = disputeId;\n', '        if (disputeId != origID) {\n', '            uint256 lastID =\n', '                self.disputesById[origID].disputeUintVars[\n', '                    keccak256(abi.encode(dispRounds - 1))\n', '                ];\n', '            require(\n', '                self.disputesById[lastID].disputeUintVars[\n', '                    keccak256("minExecutionDate")\n', '                ] <= now,\n', '                "Dispute is already open"\n', '            );\n', '            if (self.disputesById[lastID].executed) {\n', '                require(\n', '                    now -\n', '                        self.disputesById[lastID].disputeUintVars[\n', '                            keccak256("tallyDate")\n', '                        ] <=\n', '                        1 days,\n', '                    "Time for voting haven\'t elapsed"\n', '                );\n', '            }\n', '        }\n', '        self.disputesById[disputeId] = TellorStorage.Dispute({\n', '            hash: _hash,\n', '            isPropFork: true,\n', '            reportedMiner: msg.sender,\n', '            reportingParty: msg.sender,\n', '            proposedForkAddress: _propNewTellorAddress,\n', '            executed: false,\n', '            disputeVotePassed: false,\n', '            tally: 0\n', '        });\n', '        TellorTransfer.doTransfer(\n', '            self,\n', '            msg.sender,\n', '            address(this),\n', '            100e18 * 2**(dispRounds - 1)\n', '        ); //This is the fork fee (just 100 tokens flat, no refunds.  Goes up quickly to dispute a bad vote)\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("blockNumber")\n', '        ] = block.number;\n', '        self.disputesById[disputeId].disputeUintVars[\n', '            keccak256("minExecutionDate")\n', '        ] = now + 7 days;\n', '        self.disputesById[disputeId].disputeUintVars[keccak256("newVersion")] =\n', '            self.uintVars[keccak256("version")] +\n', '            1;\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the Tellor address after a proposed fork has\n', '     * passed the vote and day has gone by without a dispute\n', '     * @param _disputeId the disputeId for the proposed fork\n', '     */\n', '    function updateTellor(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        uint256 _disputeId\n', '    ) public {\n', '        bytes32 _hash = self.disputesById[_disputeId].hash;\n', '        uint256 origID = self.disputeIdByDisputeHash[_hash];\n', '        uint256 lastID =\n', '            self.disputesById[origID].disputeUintVars[\n', '                keccak256(\n', '                    abi.encode(\n', '                        self.disputesById[origID].disputeUintVars[\n', '                            keccak256("disputeRounds")\n', '                        ]\n', '                    )\n', '                )\n', '            ];\n', '        TellorStorage.Dispute storage disp = self.disputesById[lastID];\n', '        require(\n', '            disp.disputeUintVars[keccak256("newVersion")] >\n', '                self.uintVars[keccak256("version")],\n', '            "can\'t upgrade to older version"\n', '        );\n', '        require(disp.isPropFork, "is not a propose fork dispute");\n', '        require(\n', '            disp.proposedForkAddress != address(0),\n', '            "can\'t migrate to zero address"\n', '        );\n', '        require(disp.disputeVotePassed == true, "vote needs to pass");\n', '        require(\n', '            now - disp.disputeUintVars[keccak256("tallyDate")] > 1 days,\n', '            "Time for voting for further disputes has not passed"\n', '        );\n', '        self.uintVars[keccak256("version")] = disp.disputeUintVars[\n', '            keccak256("newVersion")\n', '        ];\n', '        self.addressVars[keccak256("tellorContract")] = disp\n', '            .proposedForkAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows disputer to unlock the dispute fee\n', '     * @param _disputeId to unlock fee from\n', '     */\n', '    function unlockDisputeFee(\n', '        TellorStorage.TellorStorageStruct storage self,\n', '        uint256 _disputeId\n', '    ) public {\n', '        uint256 origID =\n', '            self.disputeIdByDisputeHash[self.disputesById[_disputeId].hash];\n', '        uint256 lastID =\n', '            self.disputesById[origID].disputeUintVars[\n', '                keccak256(\n', '                    abi.encode(\n', '                        self.disputesById[origID].disputeUintVars[\n', '                            keccak256("disputeRounds")\n', '                        ]\n', '                    )\n', '                )\n', '            ];\n', '        if (lastID == 0) {\n', '            lastID = origID;\n', '        }\n', '        TellorStorage.Dispute storage disp = self.disputesById[origID];\n', '        TellorStorage.Dispute storage last = self.disputesById[lastID];\n', '        //disputeRounds is increased by 1 so that the _id is not a negative number when it is the first time a dispute is initiated\n', '        uint256 dispRounds = disp.disputeUintVars[keccak256("disputeRounds")];\n', '        if (dispRounds == 0) {\n', '            dispRounds = 1;\n', '        }\n', '        uint256 _id;\n', '        require(\n', '            disp.disputeUintVars[keccak256("paid")] == 0,\n', '            "already paid out"\n', '        );\n', '        require(\n', '            now - last.disputeUintVars[keccak256("tallyDate")] > 1 days,\n', '            "Time for voting haven\'t elapsed"\n', '        );\n', '        TellorStorage.StakeInfo storage stakes =\n', '            self.stakerDetails[disp.reportedMiner];\n', '        disp.disputeUintVars[keccak256("paid")] = 1;\n', '        if (last.disputeVotePassed == true) {\n', '            //Changing the currentStatus and startDate unstakes the reported miner and transfers the stakeAmount\n', '            stakes.startDate = now - (now % 86400);\n', '\n', '            //Reduce the staker count\n', '            self.uintVars[keccak256("stakerCount")] -= 1;\n', '\n', '            //Update the minimum dispute fee that is based on the number of stakers\n', '            updateMinDisputeFee(self);\n', "            //Decreases the stakerCount since the miner's stake is being slashed\n", '            if (stakes.currentStatus == 4) {\n', '                stakes.currentStatus = 5;\n', '                TellorTransfer.doTransfer(\n', '                    self,\n', '                    disp.reportedMiner,\n', '                    disp.reportingParty,\n', '                    self.uintVars[keccak256("stakeAmount")]\n', '                );\n', '                stakes.currentStatus = 0;\n', '            }\n', '            for (uint256 i = 0; i < dispRounds; i++) {\n', '                _id = disp.disputeUintVars[\n', '                    keccak256(abi.encode(dispRounds - i))\n', '                ];\n', '                if (_id == 0) {\n', '                    _id = origID;\n', '                }\n', '                TellorStorage.Dispute storage disp2 = self.disputesById[_id];\n', '                //transfer fee adjusted based on number of miners if the minerIndex is not 2(official value)\n', '                TellorTransfer.doTransfer(\n', '                    self,\n', '                    address(this),\n', '                    disp2.reportingParty,\n', '                    disp2.disputeUintVars[keccak256("fee")]\n', '                );\n', '            }\n', '        } else {\n', '            stakes.currentStatus = 1;\n', '            TellorStorage.Request storage _request =\n', '                self.requestDetails[\n', '                    disp.disputeUintVars[keccak256("requestId")]\n', '                ];\n', '            if (disp.disputeUintVars[keccak256("minerSlot")] == 2) {\n', "                //note we still don't put timestamp back into array (is this an issue? (shouldn't be))\n", '                _request.finalValues[\n', '                    disp.disputeUintVars[keccak256("timestamp")]\n', '                ] = disp.disputeUintVars[keccak256("value")];\n', '            }\n', '            if (\n', '                _request.inDispute[\n', '                    disp.disputeUintVars[keccak256("timestamp")]\n', '                ] == true\n', '            ) {\n', '                _request.inDispute[\n', '                    disp.disputeUintVars[keccak256("timestamp")]\n', '                ] = false;\n', '            }\n', '            for (uint256 i = 0; i < dispRounds; i++) {\n', '                _id = disp.disputeUintVars[\n', '                    keccak256(abi.encode(dispRounds - i))\n', '                ];\n', '                if (_id != 0) {\n', '                    last = self.disputesById[_id]; //handling if happens during an upgrade\n', '                }\n', '                TellorTransfer.doTransfer(\n', '                    self,\n', '                    address(this),\n', '                    last.reportedMiner,\n', '                    self.disputesById[_id].disputeUintVars[keccak256("fee")]\n', '                );\n', '            }\n', '        }\n', '\n', '        if (disp.disputeUintVars[keccak256("minerSlot")] == 2) {\n', '            self.requestDetails[disp.disputeUintVars[keccak256("requestId")]]\n', '                .apiUintVars[keccak256("disputeCount")]--;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev This function updates the minimum dispute fee as a function of the amount\n', '     * of staked miners\n', '     */\n', '    function updateMinDisputeFee(TellorStorage.TellorStorageStruct storage self)\n', '        public\n', '    {\n', '        uint256 stakeAmount = self.uintVars[keccak256("stakeAmount")];\n', '        uint256 targetMiners = self.uintVars[keccak256("targetMiners")];\n', '        self.uintVars[keccak256("disputeFee")] = SafeMath.max(\n', '            15e18,\n', '            (stakeAmount -\n', '                ((stakeAmount *\n', '                    (SafeMath.min(\n', '                        targetMiners,\n', '                        self.uintVars[keccak256("stakerCount")]\n', '                    ) * 1000)) / targetMiners) /\n', '                1000)\n', '        );\n', '    }\n', '}']