['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', "import './Ownable.sol';\n", "import './ACOAssetHelper.sol';\n", "import './ACOPoolLib.sol';\n", "import './ERC20.sol';\n", "import './IACOFactory.sol';\n", "import './IACOPoolFactory2.sol';\n", "import './IACOAssetConverterHelper.sol';\n", "import './IACOToken.sol';\n", "import './IChiToken.sol';\n", "import './IACOPool2.sol';\n", "import './ILendingPool.sol';\n", '\n', '/**\n', ' * @title ACOPool2\n', ' * @dev A pool contract to trade ACO tokens.\n', ' * \n', ' * The SC errors are defined as code to shrunk the SC bytes size and work around the EIP170.\n', ' * The codes are explained in the table below:\n', ' ********************************************************************************************\n', ' * CODE | FUNCTION                            | DESCRIPTION\t\t\t\t\t\t            *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E00  | init                                | SC is already initialized                   *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E01  | init                                | Underlying and strike asset are the same    *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E10  | _deposit                            | Invalid collateral amount                   *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E11  | _deposit                            | Invalid destination address                 *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E12  | _deposit                            | Invalid deposit for lending pool token      *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E13  | _deposit                            | The minimum shares were not satisfied       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E20  | _withdrawWithLocked                 | Invalid shares amount                       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E21  | _withdrawWithLocked                 | Invalid withdraw for lending pool token     *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E30  | _withdrawNoLocked                   | Invalid shares amount                       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E31  | _withdrawNoLocked                   | Invalid withdraw for lending pool token     *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E40  | _swap                               | Swap deadline reached                       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E41  | _swap                               | Invalid destination address                 *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E42  | _internalSelling                    | The maximum payment restriction was reached *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E43  | _internalSelling                    | Insufficient ether amount                   *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E44  | _internalSelling                    | Ether is not expected                       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E45  | _internalSelling                    | The maximum number of open ACOs was reached *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E50  | _quote                              | Invalid token amount                        *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E51  | _quote                              | Invalid ACO token                           *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E60  | restoreCollateral                   | No balance to restore                       *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E70  | lendCollateral                      | Lend is not available for this pool         *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E80  | withdrawStuckToken                  | The token is forbidden to withdraw          *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E81  | _setAcoPermissionConfig             | Invalid below tolerance percentage          *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E82  | _setAcoPermissionConfig             | Invalid minimum below tolerance percentage  *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E83  | _setAcoPermissionConfig             | Invalid minimum above tolerance percentage  *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E84  | _setAcoPermissionConfig             | Invalid expiration range                    *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E85  | _setBaseVolatility                  | Invalid base volatility                     *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E86  | _setStrategy                        | Invalid strategy address                    *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E87  | _setPoolAdmin                       | Invalid pool admin address                  *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E88  | _setProtocolConfig                  | No price on the Oracle                      *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E89  | _setProtocolConfig                  | Invalid fee destination address             *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E90  | _setProtocolConfig                  | Invalid fee value                           *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E91  | _setProtocolConfig                  | Invalid penalty percentage                  *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E92  | _setProtocolConfig                  | Invalid underlying price adjust percentage  *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E93  | _setProtocolConfig                  | Invalid maximum number of open ACOs allowed *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E98  | _onlyPoolAdmin                      | Only the pool admin can call the method     *\n', ' *------------------------------------------------------------------------------------------*\n', ' * E99  | _onlyProtocolOwner                  | Only the pool factory can call the method   *\n', ' ********************************************************************************************\n', ' */\n', 'contract ACOPool2 is Ownable, ERC20 {\n', '    \n', '    uint256 internal constant PERCENTAGE_PRECISION = 100000;\n', '\n', '    event SetValidAcoCreator(address indexed creator, bool indexed previousPermission, bool indexed newPermission);\n', '    \n', '    event SetForbiddenAcoCreator(address indexed creator, bool indexed previousStatus, bool indexed newStatus);\n', '    \n', '    event SetProtocolConfig(IACOPool2.PoolProtocolConfig oldConfig, IACOPool2.PoolProtocolConfig newConfig);\n', '\t\n', '\tevent SetAcoPermissionConfig(IACOPool2.PoolAcoPermissionConfig oldConfig, IACOPool2.PoolAcoPermissionConfig newConfig);\n', '\n', '    event SetBaseVolatility(uint256 indexed oldBaseVolatility, uint256 indexed newBaseVolatility);\n', '\n', '\tevent SetStrategy(address indexed oldStrategy, address indexed newStrategy);\n', '\t\n', '    event SetPoolAdmin(address indexed oldAdmin, address indexed newAdmin);\n', '\n', '    event RestoreCollateral(uint256 amountOut, uint256 collateralRestored);\n', '\n', '    event LendCollateral(uint256 collateralAmount);\n', '\n', '\tevent ACORedeem(address indexed acoToken, uint256 valueSold, uint256 collateralLocked, uint256 collateralRedeemed);\n', '\n', '    event Deposit(address indexed account, uint256 shares, uint256 collateralAmount);\n', '\n', '    event Withdraw(\n', '\t\taddress indexed account, \n', '\t\tuint256 shares, \n', '\t\tbool noLocked, \n', '\t\tuint256 underlyingWithdrawn, \n', '\t\tuint256 strikeAssetWithdrawn, \n', '\t\taddress[] acos, \n', '\t\tuint256[] acosAmount\n', '\t);\n', '\n', '\tevent Swap(\n', '        address indexed account, \n', '        address indexed acoToken, \n', '        uint256 tokenAmount, \n', '        uint256 price, \n', '        uint256 protocolFee,\n', '        uint256 underlyingPrice,\n', '\t\tuint256 volatility\n', '    );\n', '\n', '    IACOFactory public acoFactory;\n', '\tIChiToken public chiToken;\n', '\tILendingPool public lendingPool;\n', '    address public underlying;\n', '    address public strikeAsset;\n', '    bool public isCall;\n', '\n', '    address public poolAdmin;\n', '\taddress public strategy;\n', '    uint256 public baseVolatility;\n', '    \n', '    IACOPool2.PoolAcoPermissionConfig public acoPermissionConfig;\n', '    IACOPool2.PoolProtocolConfig public protocolConfig;\n', '    \n', '    address[] public acoTokens;\n', '    address[] public openAcos;\n', '\n', '    mapping(address => bool) public forbiddenAcoCreators;\n', '    mapping(address => bool) public validAcoCreators;\n', '    mapping(address => IACOPool2.AcoData) public acoData;\n', '\n', '    address internal lendingToken;\n', '\tuint256 internal underlyingPrecision;\n', '\n', '\tmodifier discountCHI {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n', '        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n', '    }\n', '\n', '    function init(IACOPool2.InitData calldata initData) external {\n', '\t\trequire(underlying == address(0) && strikeAsset == address(0), "E00");\n', '        require(initData.underlying != initData.strikeAsset, "E01");\n', '        \n', '        super.init();\n', '\n', '        acoFactory = IACOFactory(initData.acoFactory);\n', '        chiToken = IChiToken(initData.chiToken);\n', '        lendingPool = ILendingPool(initData.lendingPool);\n', '        underlying = initData.underlying;\n', '        strikeAsset = initData.strikeAsset;\n', '        isCall = initData.isCall;\n', '\t\t\n', '\t\t_setProtocolConfig(initData.protocolConfig);\n', '\t\t_setPoolAdmin(initData.admin);\n', '\t\t_setAcoPermissionConfig(initData.acoPermissionConfig);\n', '        _setBaseVolatility(initData.baseVolatility);\n', '        _setStrategy(initData.strategy);\n', '\t\t\n', '\t\tif (!initData.isCall) {\n', '\t\t    lendingToken = ILendingPool(initData.lendingPool).getReserveData(initData.strikeAsset).aTokenAddress;\n', '            _setAuthorizedSpender(initData.strikeAsset, initData.lendingPool);\n', '        }\n', '\t\tunderlyingPrecision = 10 ** uint256(ACOAssetHelper._getAssetDecimals(initData.underlying));\n', '    }\n', '\n', '    receive() external payable {\n', '    }\n', '\n', '    function name() public override view returns(string memory) {\n', '        return ACOPoolLib.name(underlying, strikeAsset, isCall);\n', '    }\n', '\n', '\tfunction symbol() public override view returns(string memory) {\n', '        return name();\n', '    }\n', '\n', '    function decimals() public override view returns(uint8) {\n', '        return ACOAssetHelper._getAssetDecimals(collateral());\n', '    }\n', '\n', '    function numberOfAcoTokensNegotiated() external view returns(uint256) {\n', '        return acoTokens.length;\n', '    }\n', '\n', '    function numberOfOpenAcoTokens() external view returns(uint256) {\n', '        return openAcos.length;\n', '    }\n', '\n', '\tfunction collateral() public view returns(address) {\n', '        return (isCall ? underlying : strikeAsset);\n', '    }\n', '\n', '    function canSwap(address acoToken) external view returns(bool) {\n', '        (address _underlying, address _strikeAsset, bool _isCall, uint256 _strikePrice, uint256 _expiryTime) = _getAcoData(acoToken);\n', '\t\tif (_acoBasicDataIsValid(acoToken, _underlying, _strikeAsset, _isCall)) {\n', '            uint256 price = _getPrice(_underlying, _strikeAsset, protocolConfig.assetConverter);\n', '            return ACOPoolLib.acoStrikeAndExpirationIsValid(_strikePrice, _expiryTime, price, acoPermissionConfig);\n', '        }\n', '        return false;\n', '    }\n', '\n', '\tfunction quote(address acoToken, uint256 tokenAmount) external view returns(\n', '        uint256 swapPrice, \n', '        uint256 protocolFee, \n', '        uint256 underlyingPrice, \n', '        uint256 volatility\n', '    ) {\n', '        IACOPool2.PoolProtocolConfig storage _protocolConfig = protocolConfig;\n', '        (swapPrice, protocolFee, underlyingPrice, volatility,) = _quote(acoToken, tokenAmount, _protocolConfig);\n', '    }\n', '\n', '\tfunction getDepositShares(uint256 collateralAmount) external view returns(uint256) {\n', '        (,,uint256 collateralBalance,) = _getCollateralNormalized(true);\n', '\n', '        if (collateralBalance == 0) {\n', '            return collateralAmount;\n', '        } else {\n', '            return collateralAmount.mul(totalSupply()).div(collateralBalance);\n', '        }\n', '    }\n', '\n', '\tfunction getWithdrawNoLockedData(uint256 shares) external view returns(\n', '        uint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\tbool isPossible\n', '    ) {\n', '        uint256 _totalSupply = totalSupply();\n', '\t\tif (shares > 0 && shares <= _totalSupply) {\n', '\t\t\t\n', '\t\t\t(uint256 underlyingBalance, \n', '             uint256 strikeAssetBalance, \n', '             uint256 collateralBalance, \n', '             uint256 collateralLockedRedeemable) = _getCollateralNormalized(false);\n', '             \n', '            (underlyingWithdrawn, strikeAssetWithdrawn, isPossible) = ACOPoolLib.getBaseWithdrawNoLockedData(\n', '                shares,\n', '                _totalSupply,\n', '                isCall,\n', '                underlyingBalance, \n', '                strikeAssetBalance, \n', '                collateralBalance, \n', '                collateralLockedRedeemable\n', '            );\n', '\t\t}\n', '    }\n', '\n', '\tfunction getWithdrawWithLocked(uint256 shares) external view returns(\n', '        uint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\taddress[] memory acos,\n', '\t\tuint256[] memory acosAmount\n', '    ) {\n', '        uint256 _totalSupply = totalSupply();\t\n', '        if (shares > 0 && shares <= _totalSupply) {\n', '        \n', '            (underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getBaseAssetsWithdrawWithLocked(shares, underlying, strikeAsset, isCall, _totalSupply, lendingToken);\n', '\t\t\n', '            acos = new address[](openAcos.length);\n', '            acosAmount = new uint256[](openAcos.length);\n', '\t\t\tfor (uint256 i = 0; i < openAcos.length; ++i) {\n', '\t\t\t\taddress acoToken = openAcos[i];\n', '\t\t\t\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\n', '\t\t\t\t\n', '\t\t\t\tacos[i] = acoToken;\n', '\t\t\t\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '\n', '\tfunction getGeneralData() external view returns(\n', '        uint256 underlyingBalance,\n', '\t\tuint256 strikeAssetBalance,\n', '\t\tuint256 collateralLocked,\n', '        uint256 collateralOnOpenPosition,\n', '        uint256 collateralLockedRedeemable,\n', '\t\tuint256 poolSupply\n', '    ) {\n', '        poolSupply = totalSupply();\n', '        (underlyingBalance, strikeAssetBalance,, collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getCollateralData(true);\n', '    }\n', '    \n', '    function setAcoPermissionConfig(IACOPool2.PoolAcoPermissionConfig calldata newConfig) external {\n', '        _onlyPoolAdmin();\n', '        _setAcoPermissionConfig(newConfig);\n', '    }\n', '\n', '\tfunction setBaseVolatility(uint256 newBaseVolatility) external {\n', '        _onlyPoolAdmin();\n', '\t\t_setBaseVolatility(newBaseVolatility);\n', '\t}\n', '\t\n', '\tfunction setStrategy(address newStrategy) external {\n', '        _onlyPoolAdmin();\n', '\t\t_setStrategy(newStrategy);\n', '\t}\n', '\t\n', '\tfunction setPoolAdmin(address newAdmin) external {\n', '\t    _onlyPoolAdmin();\n', '\t\t_setPoolAdmin(newAdmin);\n', '\t}\n', '\n', '\tfunction setValidAcoCreator(address acoCreator, bool newPermission) external {\n', '        _onlyProtocolOwner();\n', '        emit SetValidAcoCreator(acoCreator, validAcoCreators[acoCreator], newPermission);\n', '        validAcoCreators[acoCreator] = newPermission;\n', '    }\n', '    \n', '    function setForbiddenAcoCreator(address acoCreator, bool isForbidden) external {\n', '        _onlyProtocolOwner();\n', '        emit SetForbiddenAcoCreator(acoCreator, forbiddenAcoCreators[acoCreator], isForbidden);\n', '        forbiddenAcoCreators[acoCreator] = isForbidden;\n', '    }\n', '    \n', '    function setProtocolConfig(IACOPool2.PoolProtocolConfig calldata newConfig) external {\n', '        _onlyProtocolOwner();\n', '        _setProtocolConfig(newConfig);\n', '    }\n', '\n', '    function withdrawStuckToken(address token, address destination) external {\n', '        _onlyProtocolOwner();\n', '        require(token != underlying && token != strikeAsset && !acoData[token].open && (isCall || token != lendingToken), "E80");\n', '        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\n', '        if (_balance > 0) {\n', '            ACOAssetHelper._transferAsset(token, destination, _balance);\n', '        }\n', '    }\n', '\n', '\tfunction deposit(\n', '\t    uint256 collateralAmount, \n', '\t    uint256 minShares, \n', '\t    address to, \n', '\t    bool isLendingToken\n', '    ) external payable returns(uint256) {\n', '        return _deposit(collateralAmount, minShares, to, isLendingToken);\n', '    }\n', '\n', '\tfunction depositWithGasToken(\n', '\t    uint256 collateralAmount, \n', '\t    uint256 minShares, \n', '\t    address to, \n', '\t    bool isLendingToken\n', '    ) discountCHI external payable returns(uint256) {\n', '        return _deposit(collateralAmount, minShares, to, isLendingToken);\n', '    }\n', '\n', '    function withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) external returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\taddress[] memory acos,\n', '\t\tuint256[] memory acosAmount\n', '\t) {\n', '        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account, withdrawLendingToken);\n', '    }\n', '\n', '\tfunction withdrawWithLockedWithGasToken(uint256 shares, address account, bool withdrawLendingToken) discountCHI external returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\taddress[] memory acos,\n', '\t\tuint256[] memory acosAmount\n', '\t) {\n', '        (underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount) = _withdrawWithLocked(shares, account, withdrawLendingToken);\n', '    }\n', '\n', '\tfunction withdrawNoLocked(\n', '\t    uint256 shares, \n', '\t    uint256 minCollateral, \n', '\t    address account, \n', '\t    bool withdrawLendingToken\n', '    ) external returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn\n', '\t) {\n', '        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account, withdrawLendingToken);\n', '    }\n', '\n', '\tfunction withdrawNoLockedWithGasToken(\n', '\t    uint256 shares, \n', '\t    uint256 minCollateral, \n', '\t    address account, \n', '\t    bool withdrawLendingToken\n', '    ) discountCHI external returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn\n', '\t) {\n', '        (underlyingWithdrawn, strikeAssetWithdrawn) = _withdrawNoLocked(shares, minCollateral, account, withdrawLendingToken);\n', '    }\n', '\n', '\tfunction swap(\n', '        address acoToken, \n', '        uint256 tokenAmount, \n', '        uint256 restriction, \n', '        address to, \n', '        uint256 deadline\n', '    ) external payable {\n', '        _swap(acoToken, tokenAmount, restriction, to, deadline);\n', '    }\n', '\n', '    function swapWithGasToken(\n', '        address acoToken, \n', '        uint256 tokenAmount, \n', '        uint256 restriction, \n', '        address to, \n', '        uint256 deadline\n', '    ) discountCHI external payable {\n', '        _swap(acoToken, tokenAmount, restriction, to, deadline);\n', '    }\n', '\n', '    function redeemACOTokens() public {\n', '        for (uint256 i = openAcos.length; i > 0; --i) {\n', '            address acoToken = openAcos[i - 1];\n', '            redeemACOToken(acoToken);\n', '        }\n', '    }\n', '\n', '\tfunction redeemACOToken(address acoToken) public {\n', '\t\tIACOPool2.AcoData storage data = acoData[acoToken];\n', '\t\tif (data.open && IACOToken(acoToken).expiryTime() <= block.timestamp) {\n', '\t\t\t\n', '            data.open = false;\n', '\t\t\tuint256 lastIndex = openAcos.length - 1;\n', '    \t\tuint256 index = data.openIndex;\n', '    \t\tif (lastIndex != index) {\n', '    \t\t    address last = openAcos[lastIndex];\n', '    \t\t\topenAcos[index] = last;\n', '    \t\t\tacoData[last].openIndex = index;\n', '    \t\t}\n', '    \t\tdata.openIndex = 0;\n', '            openAcos.pop();\n', '\n', '            if (IACOToken(acoToken).currentCollateralizedTokens(address(this)) > 0) {\t\n', '\t\t\t    data.collateralRedeemed = IACOToken(acoToken).redeem();\n', '\t\t\t    if (!isCall) {\n', '\t\t\t        _depositOnLendingPool(data.collateralRedeemed);\n', '\t\t\t    }\n', '            }\n', '\t\t\t\n', '\t\t\temit ACORedeem(acoToken, data.valueSold, data.collateralLocked, data.collateralRedeemed);\n', '\t\t}\n', '    }\n', '\n', '\tfunction restoreCollateral() external {\n', '        _onlyPoolAdmin();\n', '        \n', '        uint256 balanceOut;\n', '        address assetIn;\n', '        address assetOut;\n', '        if (isCall) {\n', '            balanceOut = _getPoolBalanceOf(strikeAsset);\n', '            assetIn = underlying;\n', '            assetOut = strikeAsset;\n', '        } else {\n', '            balanceOut = _getPoolBalanceOf(underlying);\n', '            assetIn = strikeAsset;\n', '            assetOut = underlying;\n', '        }\n', '        require(balanceOut > 0, "E60");\n', '        \n', '\t\tuint256 etherAmount = 0;\n', '        if (ACOAssetHelper._isEther(assetOut)) {\n', '\t\t\tetherAmount = balanceOut;\n', '        }\n', '        uint256 collateralRestored = IACOAssetConverterHelper(protocolConfig.assetConverter).swapExactAmountOut{value: etherAmount}(assetOut, assetIn, balanceOut);\n', '        if (!isCall) {\n', '            _depositOnLendingPool(collateralRestored);\n', '        }\n', '\n', '        emit RestoreCollateral(balanceOut, collateralRestored);\n', '    }\n', '\n', '\tfunction lendCollateral() external {\n', '\t\trequire(!isCall, "E70");\n', '\t    uint256 strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\n', '\t    if (strikeAssetBalance > 0) {\n', '\t        _depositOnLendingPool(strikeAssetBalance);\n', '\t        emit LendCollateral(strikeAssetBalance);\n', '\t    }\n', '    }\n', '\n', '    function _getAcoData(address acoToken) internal view returns(\n', '        address _underlying, \n', '        address _strikeAsset, \n', '        bool _isCall, \n', '        uint256 strikePrice, \n', '        uint256 expiryTime\n', '    ) {\n', '        (_underlying, _strikeAsset, _isCall, strikePrice, expiryTime) = acoFactory.acoTokenData(acoToken);\n', '    }\n', '\n', '\tfunction _quote(\n', '\t    address acoToken, \n', '\t    uint256 tokenAmount, \n', '\t    IACOPool2.PoolProtocolConfig storage _protocolConfig\n', '    ) internal view returns(\n', '        uint256 swapPrice, \n', '        uint256 protocolFee, \n', '        uint256 underlyingPrice, \n', '        uint256 volatility, \n', '        uint256 collateralAmount\n', '    ) {\n', '        require(tokenAmount > 0, "E50");\n', '        \n', '        ACOPoolLib.AcoData memory _acoData = _getAcoDataForQuote(acoToken, tokenAmount);\n', '        \n', '\t\trequire(_acoBasicDataIsValid(acoToken, _acoData.underlying, _acoData.strikeAsset, _acoData.isCall), "E51");\n', '\t\t\n', '\t\tunderlyingPrice = _getPrice(_acoData.underlying, _acoData.strikeAsset, _protocolConfig.assetConverter);\n', '\t\t\n', '\t\t(swapPrice, protocolFee, volatility, collateralAmount) = ACOPoolLib.quote(ACOPoolLib.QuoteData(\n', '    \t\tlendingToken,\n', '    \t\tstrategy,\n', '    \t\tbaseVolatility,\n', '    \t\t_protocolConfig.fee,\n', '    \t\tunderlyingPrice,\n', '    \t\tunderlyingPrecision,\n', '    \t\t_acoData,\n', '    \t\tacoPermissionConfig));\n', '    }\n', '    \n', '    function _getAcoDataForQuote(address acoToken, uint256 tokenAmount) internal view returns(ACOPoolLib.AcoData memory _acoData) {\n', '        (address _underlying, address _strikeAsset, bool _isCall, uint256 strikePrice, uint256 expiryTime) = _getAcoData(acoToken);\n', '        _acoData = ACOPoolLib.AcoData(_isCall, strikePrice, expiryTime, tokenAmount, _underlying, _strikeAsset); \n', '    }\n', '    \n', '\tfunction _deposit(\n', '\t    uint256 collateralAmount, \n', '\t    uint256 minShares, \n', '\t    address to,\n', '\t    bool isLendingToken\n', '    ) internal returns(uint256 shares) {\n', '        require(collateralAmount > 0, "E10");\n', '        require(to != address(0) && to != address(this), "E11");\n', '        require(!isLendingToken || !isCall, "E12");\n', '\t\t\n', '\t\t(,,uint256 collateralBalance,) = _getCollateralNormalized(true);\n', '\n', '\t\taddress _collateral = collateral();\n', '\t\tif (ACOAssetHelper._isEther(_collateral)) {\n', '            collateralBalance = collateralBalance.sub(msg.value);\n', '\t\t}\n', '        \n', '        if (collateralBalance == 0) {\n', '            shares = collateralAmount;\n', '        } else {\n', '            shares = collateralAmount.mul(totalSupply()).div(collateralBalance);\n', '        }\n', '        require(shares >= minShares, "E13");\n', '\n', '        if (isLendingToken) {\n', '            ACOAssetHelper._receiveAsset(lendingToken, collateralAmount);\n', '        } else {\n', '            ACOAssetHelper._receiveAsset(_collateral, collateralAmount);\n', '            if (!isCall) {\n', '                _depositOnLendingPool(collateralAmount);\n', '            }\n', '        }\n', '        \n', '        super._mintAction(to, shares);\n', '        \n', '        emit Deposit(to, shares, collateralAmount);\n', '    }\n', '\n', '\tfunction _withdrawWithLocked(uint256 shares, address account, bool withdrawLendingToken) internal returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\taddress[] memory acos,\n', '\t\tuint256[] memory acosAmount\n', '\t) {\n', '        require(shares > 0, "E20");\n', '        require(!withdrawLendingToken || !isCall, "E21");\n', '        \n', '\t\tredeemACOTokens();\n', '\t\t\n', '        uint256 _totalSupply = totalSupply();\n', '        _callBurn(account, shares);\n', '        \n', '\t\t(underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getAmountToLockedWithdraw(shares, _totalSupply, lendingToken, underlying, strikeAsset, isCall);\n', '\t\t\n', '\t\t(acos, acosAmount) = _transferOpenPositions(shares, _totalSupply);\n', '\n', '\t\t_transferWithdrawnAssets(underlyingWithdrawn, strikeAssetWithdrawn, withdrawLendingToken);\n', '\n', '        emit Withdraw(account, shares, false, underlyingWithdrawn, strikeAssetWithdrawn, acos, acosAmount);\n', '    }\n', '    \n', '    function _withdrawNoLocked(\n', '        uint256 shares, \n', '        uint256 minCollateral, \n', '        address account, \n', '        bool withdrawLendingToken\n', '    ) internal returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn\n', '\t) {\n', '        require(shares > 0, "E30");\n', '        bool _isCall = isCall;\n', '        require(!withdrawLendingToken || !_isCall, "E31");\n', '        \n', '\t\tredeemACOTokens();\n', '\t\t\n', '        uint256 _totalSupply = totalSupply();\n', '        _callBurn(account, shares);\n', '        \n', '        (underlyingWithdrawn, strikeAssetWithdrawn) = _getAmountToNoLockedWithdraw(shares, _totalSupply, minCollateral, _isCall);\n', '        \n', '        _transferWithdrawnAssets(underlyingWithdrawn, strikeAssetWithdrawn, withdrawLendingToken);\n', '\t\t\n', '        emit Withdraw(account, shares, true, underlyingWithdrawn, strikeAssetWithdrawn, new address[](0), new uint256[](0));\n', '    }\n', '\n', '    function _transferWithdrawnAssets(\n', '        uint256 underlyingWithdrawn, \n', '        uint256 strikeAssetWithdrawn, \n', '        bool withdrawLendingToken\n', '    ) internal {\n', '        if (strikeAssetWithdrawn > 0) {\n', '            if (withdrawLendingToken) {\n', '    \t\t    ACOAssetHelper._transferAsset(lendingToken, msg.sender, strikeAssetWithdrawn);\n', '    \t\t} else if (isCall) {\n', '    \t\t    ACOAssetHelper._transferAsset(strikeAsset, msg.sender, strikeAssetWithdrawn);\n', '    \t\t} else {\n', '    \t\t    _withdrawOnLendingPool(strikeAssetWithdrawn, msg.sender);\n', '    \t\t}\n', '        }\n', '        if (underlyingWithdrawn > 0) {\n', '\t\t    ACOAssetHelper._transferAsset(underlying, msg.sender, underlyingWithdrawn);\n', '        }\n', '    }\n', '\n', '\tfunction _getCollateralNormalized(bool isDeposit) internal view returns(\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance, \n', '        uint256 collateralBalance,\n', '        uint256 collateralLockedRedeemable\n', '    ) {\n', '        uint256 collateralLocked;\n', '        uint256 collateralOnOpenPosition;\n', '        (underlyingBalance, strikeAssetBalance, collateralBalance, collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _getCollateralData(isDeposit);\n', '\t        \n', '        collateralBalance = collateralBalance.add(collateralLocked).sub(collateralOnOpenPosition);\n', '    }\n', '    \n', '    function _getCollateralData(bool isDeposit) internal view returns(\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance, \n', '        uint256 collateralBalance,\n', '        uint256 collateralLocked,\n', '        uint256 collateralOnOpenPosition,\n', '        uint256 collateralLockedRedeemable\n', '    ) {\n', '        IACOPool2.PoolProtocolConfig storage _protocolConfig = protocolConfig;\n', '\t    uint256 underlyingPrice = _getPrice(underlying, strikeAsset, _protocolConfig.assetConverter);\n', '        (underlyingBalance, strikeAssetBalance, collateralBalance, collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = ACOPoolLib.getCollateralData(\n', '            ACOPoolLib.OpenPositionData(\n', '                isDeposit,\n', '    \t        isCall,\n', '    \t        underlyingPrice,\n', '    \t        baseVolatility,\n', '    \t        _protocolConfig.underlyingPriceAdjustPercentage,\n', '    \t        _protocolConfig.withdrawOpenPositionPenalty,\n', '    \t        _protocolConfig.fee,\n', '    \t        underlyingPrecision,\n', '    \t        underlying,\n', '    \t        strikeAsset,\n', '    \t        strategy,\n', '    \t        address(acoFactory),\n', '    \t        lendingToken),\n', '\t        openAcos);\n', '    }\n', '    \n', '    function _getAmountToNoLockedWithdraw(\n', '        uint256 shares, \n', '        uint256 _totalSupply, \n', '        uint256 minCollateral,\n', '        bool _isCall\n', '    ) internal view returns (\n', '\t\tuint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn\n', '\t) {\n', '        (uint256 underlyingBalance, \n', '         uint256 strikeAssetBalance, \n', '         uint256 collateralBalance,) = _getCollateralNormalized(false);\n', '\n', '        (underlyingWithdrawn, strikeAssetWithdrawn) = ACOPoolLib.getAmountToNoLockedWithdraw(shares, _totalSupply, underlyingBalance, strikeAssetBalance, collateralBalance, minCollateral, _isCall);\n', '    }\n', '\n', '\tfunction _callBurn(address account, uint256 tokenAmount) internal {\n', '        if (account == msg.sender) {\n', '            super._burnAction(account, tokenAmount);\n', '        } else {\n', '            super._burnFrom(account, tokenAmount);\n', '        }\n', '    }\n', '\n', '\tfunction _swap(\n', '        address acoToken, \n', '        uint256 tokenAmount, \n', '        uint256 restriction, \n', '        address to, \n', '        uint256 deadline\n', '    ) internal {\n', '        require(block.timestamp <= deadline, "E40");\n', '        require(to != address(0) && to != acoToken && to != address(this), "E41");\n', '        \n', '        IACOPool2.PoolProtocolConfig storage _protocolConfig = protocolConfig;\n', '        (uint256 swapPrice, uint256 protocolFee, uint256 underlyingPrice, uint256 volatility, uint256 collateralAmount) = _quote(acoToken, tokenAmount, _protocolConfig);\n', '        \n', '        _internalSelling(to, acoToken, collateralAmount, tokenAmount, restriction, swapPrice, protocolFee);\n', '\n', '        if (protocolFee > 0) {\n', '            ACOAssetHelper._transferAsset(strikeAsset, _protocolConfig.feeDestination, protocolFee);\n', '        }\n', '        \n', '        emit Swap(to, acoToken, tokenAmount, swapPrice, protocolFee, underlyingPrice, volatility);\n', '    }\n', '\n', '    function _internalSelling(\n', '        address to,\n', '        address acoToken, \n', '        uint256 collateralAmount, \n', '        uint256 tokenAmount,\n', '        uint256 maxPayment,\n', '        uint256 swapPrice,\n', '        uint256 protocolFee\n', '    ) internal {\n', '        require(swapPrice <= maxPayment, "E42");\n', '        \n', '        address _strikeAsset = strikeAsset;\n', '        uint256 extra = 0;\n', '        if (ACOAssetHelper._isEther(_strikeAsset)) {\n', '            require(msg.value >= swapPrice, "E43");\n', '            extra = msg.value.sub(swapPrice);\n', '        } else {\n', '            require(msg.value == 0, "E44");\n', '            ACOAssetHelper._callTransferFromERC20(_strikeAsset, msg.sender, address(this), swapPrice);\n', '        }\n', '        \n', '        uint256 remaining = swapPrice.sub(protocolFee);\n', '        \n', '        if (!isCall) {\n', '            _withdrawOnLendingPool(collateralAmount.sub(remaining), address(this));\n', '        }\n', '        \n', '\t\taddress _collateral = collateral();\n', '        IACOPool2.AcoData storage data = acoData[acoToken];\n', '\t\tif (ACOAssetHelper._isEther(_collateral)) {\n', '\t\t\ttokenAmount = IACOToken(acoToken).mintPayable{value: collateralAmount}();\n', '\t\t} else {\n', '\t\t\tif (!data.open) {\n', '\t\t\t\t_setAuthorizedSpender(_collateral, acoToken);    \n', '\t\t\t}\n', '\t\t\ttokenAmount = IACOToken(acoToken).mint(collateralAmount);\n', '\t\t}\n', '\n', '\t\tif (!data.open) {\n', '            require(openAcos.length < protocolConfig.maximumOpenAco, "E45");\n', '\t\t\tacoData[acoToken] = IACOPool2.AcoData(true, remaining, collateralAmount, 0, acoTokens.length, openAcos.length);\n', '            acoTokens.push(acoToken);    \n', '            openAcos.push(acoToken);   \n', '        } else {\n', '\t\t\tdata.collateralLocked = collateralAmount.add(data.collateralLocked);\n', '\t\t\tdata.valueSold = remaining.add(data.valueSold);\n', '\t\t}\n', '        \n', '        ACOAssetHelper._callTransferERC20(acoToken, to, tokenAmount);\n', '        \n', '        if (extra > 0) {\n', '            ACOAssetHelper._transferAsset(_strikeAsset, msg.sender, extra);    \n', '        }\n', '    }\n', '\n', '\tfunction _transferOpenPositions(uint256 shares, uint256 _totalSupply) internal returns(\n', '        address[] memory acos, \n', '        uint256[] memory acosAmount\n', '    ) {\n', '        uint256 size = openAcos.length;\n', '        acos = new address[](size);\n', '        acosAmount = new uint256[](size);\n', '\t\tfor (uint256 i = 0; i < size; ++i) {\n', '\t\t\taddress acoToken = openAcos[i];\n', '\t\t\tuint256 tokens = IACOToken(acoToken).currentCollateralizedTokens(address(this));\n', '\t\t\t\n', '\t\t\tacos[i] = acoToken;\n', '\t\t\tacosAmount[i] = tokens.mul(shares).div(_totalSupply);\n', '\t\t\t\n', '            if (acosAmount[i] > 0) {\n', '\t\t\t    IACOToken(acoToken).transferCollateralOwnership(msg.sender, acosAmount[i]);\n', '            }\n', '\t\t}\n', '\t}\n', '\n', '    function _depositOnLendingPool(uint256 amount) internal {\n', '        lendingPool.deposit(strikeAsset, amount, address(this), protocolConfig.lendingPoolReferral);\n', '    }\n', '\n', '    function _withdrawOnLendingPool(uint256 amount, address to) internal {\n', '        lendingPool.withdraw(strikeAsset, amount, to);\n', '    }\n', '\n', '\tfunction _acoBasicDataIsValid(address acoToken, address _underlying, address _strikeAsset, bool _isCall) internal view returns(bool) {\n', '\t\tif (_underlying == underlying && _strikeAsset == strikeAsset && _isCall == isCall) {\n', '\t\t    address creator = acoFactory.creators(acoToken);\n', '\t\t    return (!forbiddenAcoCreators[creator] && (validAcoCreators[address(0)] || validAcoCreators[creator])); \n', '\t    } else {\n', '\t        return false;\n', '\t    }\n', '\t}\n', '\n', '\tfunction _getPoolBalanceOf(address asset) internal view returns(uint256) {\n', '        return ACOAssetHelper._getAssetBalanceOf(asset, address(this));\n', '    }\n', '\t\n', '\tfunction _getPrice(address _underlying, address _strikeAsset, address assetConverter) internal view returns(uint256) {\n', '\t    return IACOAssetConverterHelper(assetConverter).getPrice(_underlying, _strikeAsset);\n', '\t}\n', '\n', '\tfunction _setAuthorizedSpender(address asset, address spender) internal {\n', '        ACOAssetHelper._callApproveERC20(asset, spender, ACOAssetHelper.MAX_UINT);\n', '    }\n', '\n', '    function _setAcoPermissionConfig(IACOPool2.PoolAcoPermissionConfig memory newConfig) internal {\n', '        require(newConfig.tolerancePriceBelowMax < PERCENTAGE_PRECISION && newConfig.tolerancePriceBelowMin < PERCENTAGE_PRECISION, "E81");\n', '        require(newConfig.tolerancePriceBelowMin <= newConfig.tolerancePriceBelowMax || newConfig.tolerancePriceBelowMax == 0, "E82");\n', '        require(newConfig.tolerancePriceAboveMin <= newConfig.tolerancePriceAboveMax || newConfig.tolerancePriceAboveMax == 0, "E83");\n', '        require(newConfig.minExpiration <= newConfig.maxExpiration, "E84");\n', '        \n', '        emit SetAcoPermissionConfig(acoPermissionConfig, newConfig);\n', '        \n', '        acoPermissionConfig = newConfig;\n', '    }\n', '\n', '    function _setBaseVolatility(uint256 newBaseVolatility) internal {\n', '        require(newBaseVolatility > 0, "E85");\n', '        emit SetBaseVolatility(baseVolatility, newBaseVolatility);\n', '        baseVolatility = newBaseVolatility;\n', '    }\n', '    \n', '    function _setStrategy(address newStrategy) internal {\n', '        require(IACOPoolFactory2(owner()).strategyPermitted(newStrategy), "E86");\n', '        emit SetStrategy(address(strategy), newStrategy);\n', '        strategy = newStrategy;\n', '    }\n', '\n', '    function _setPoolAdmin(address newAdmin) internal {\n', '        require(newAdmin != address(0), "E87");\n', '        emit SetPoolAdmin(poolAdmin, newAdmin);\n', '        poolAdmin = newAdmin;\n', '    }\n', '\n', '    function _setProtocolConfig(IACOPool2.PoolProtocolConfig memory newConfig) internal {\n', '        address _underlying = underlying;\n', '        address _strikeAsset = strikeAsset;\n', '\t\trequire(IACOAssetConverterHelper(newConfig.assetConverter).getPrice(_underlying, _strikeAsset) > 0, "E88");\n', '        require(newConfig.feeDestination != address(0), "E89");\n', '        require(newConfig.fee <= 12500, "E90");\n', '        require(newConfig.withdrawOpenPositionPenalty <= PERCENTAGE_PRECISION, "E91");\n', '        require(newConfig.underlyingPriceAdjustPercentage < PERCENTAGE_PRECISION, "E92");\n', '        require(newConfig.maximumOpenAco > 0, "E93");\n', '        \t\t\n', '\t\tif (isCall) {\n', '            if (!ACOAssetHelper._isEther(_strikeAsset)) {\n', '                _setAuthorizedSpender(_strikeAsset, newConfig.assetConverter);\n', '            }\n', '        } else if (!ACOAssetHelper._isEther(_underlying)) {\n', '            _setAuthorizedSpender(_underlying, newConfig.assetConverter);\n', '        }\n', '        \n', '        emit SetProtocolConfig(protocolConfig, newConfig);\n', '        \n', '        protocolConfig = newConfig;\n', '    }\n', '    \n', '    function _onlyPoolAdmin() internal view {\n', '        require(poolAdmin == msg.sender, "E98");\n', '    }\n', '    \n', '    function _onlyProtocolOwner() internal view {\n', '        require(owner() == msg.sender, "E99");\n', '    }\n', '}']