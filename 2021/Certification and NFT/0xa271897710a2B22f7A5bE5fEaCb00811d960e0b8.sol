['pragma solidity ^0.5.0;\n', '\n', 'import "./ENS.sol";\n', 'import "./ERC721.sol";\n', 'import "./BaseRegistrar.sol";\n', '\n', 'contract BaseRegistrarImplementation is BaseRegistrar, ERC721 {\n', '    // A map of expiry times\n', '    mapping(uint256=>uint) expiries;\n', '\n', '    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256("supportsInterface(bytes4)"));\n', '    bytes4 constant private ERC721_ID = bytes4(\n', '        keccak256("balanceOf(address)") ^\n', '        keccak256("ownerOf(uint256)") ^\n', '        keccak256("approve(address,uint256)") ^\n', '        keccak256("getApproved(uint256)") ^\n', '        keccak256("setApprovalForAll(address,bool)") ^\n', '        keccak256("isApprovedForAll(address,address)") ^\n', '        keccak256("transferFrom(address,address,uint256)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256)") ^\n', '        keccak256("safeTransferFrom(address,address,uint256,bytes)")\n', '    );\n', '    bytes4 constant private RECLAIM_ID = bytes4(keccak256("reclaim(uint256,address)"));\n', '\n', '    constructor(ENS _ens, bytes32 _baseNode) public {\n', '        ens = _ens;\n', '        baseNode = _baseNode;\n', '    }\n', '\n', '    modifier live {\n', '        require(ens.owner(baseNode) == address(this));\n', '        _;\n', '    }\n', '\n', '    modifier onlyController {\n', '        require(controllers[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID. Names become unowned\n', '     *      when their registration expires.\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        require(expiries[tokenId] > now);\n', '        return super.ownerOf(tokenId);\n', '    }\n', '\n', '    // Authorises a controller, who can register and renew domains.\n', '    function addController(address controller) external onlyOwner {\n', '        controllers[controller] = true;\n', '        emit ControllerAdded(controller);\n', '    }\n', '\n', '    // Revoke controller permission for an address.\n', '    function removeController(address controller) external onlyOwner {\n', '        controllers[controller] = false;\n', '        emit ControllerRemoved(controller);\n', '    }\n', '\n', '    // Set the resolver for the TLD this registrar manages.\n', '    function setResolver(address resolver) external onlyOwner {\n', '        ens.setResolver(baseNode, resolver);\n', '    }\n', '\n', '    // Returns the expiration timestamp of the specified id.\n', '    function nameExpires(uint256 id) external view returns(uint) {\n', '        return expiries[id];\n', '    }\n', '\n', '    // Returns true iff the specified name is available for registration.\n', '    function available(uint256 id) public view returns(bool) {\n', "        // Not available if it's registered here or in its grace period.\n", '        return expiries[id] + GRACE_PERIOD < now;\n', '    }\n', '\n', '    /**\n', '     * @dev Register a name.\n', '     * @param id The token ID (keccak256 of the label).\n', '     * @param owner The address that should own the registration.\n', '     * @param duration Duration in seconds for the registration.\n', '     */\n', '    function register(uint256 id, address owner, uint duration) external returns(uint) {\n', '      return _register(id, owner, duration, true);\n', '    }\n', '\n', '    /**\n', '     * @dev Register a name, without modifying the registry.\n', '     * @param id The token ID (keccak256 of the label).\n', '     * @param owner The address that should own the registration.\n', '     * @param duration Duration in seconds for the registration.\n', '     */\n', '    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n', '      return _register(id, owner, duration, false);\n', '    }\n', '\n', '    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n', '        require(available(id));\n', '        require(now + duration + GRACE_PERIOD > now + GRACE_PERIOD); // Prevent future overflow\n', '\n', '        expiries[id] = now + duration;\n', '        if(_exists(id)) {\n', '            // Name was previously owned, and expired\n', '            _burn(id);\n', '        }\n', '        _mint(owner, id);\n', '        if(updateRegistry) {\n', '            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n', '        }\n', '\n', '        emit NameRegistered(id, owner, now + duration);\n', '\n', '        return now + duration;\n', '    }\n', '\n', '    function renew(uint256 id, uint duration) external live onlyController returns(uint) {\n', '        require(expiries[id] + GRACE_PERIOD >= now); // Name must be registered here or in grace period\n', '        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n', '\n', '        expiries[id] += duration;\n', '        emit NameRenewed(id, expiries[id]);\n', '        return expiries[id];\n', '    }\n', '\n', '    /**\n', '     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n', '     */\n', '    function reclaim(uint256 id, address owner) external live {\n', '        require(_isApprovedOrOwner(msg.sender, id));\n', '        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\n', '        return interfaceID == INTERFACE_META_ID ||\n', '               interfaceID == ERC721_ID ||\n', '               interfaceID == RECLAIM_ID;\n', '    }\n', '}']