['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-17\n', '*/\n', '\n', '// Dependency file: @openzeppelin/contracts/utils/Address.sol\n', '\n', '\n', '\n', '// pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [// importANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * // importANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/GSN/Context.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * // importANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/token/ERC20/ERC20.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '// import "@openzeppelin/contracts/GSN/Context.sol";\n', '// import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '// import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) public {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '\n', '// Dependency file: @openzeppelin/contracts/math/Math.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: contracts/lib/AddressArrayUtils.sol\n', '\n', '/*\n', '    Copyright 2020 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '\n', '*/\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '/**\n', ' * @title AddressArrayUtils\n', ' * @author Set Protocol\n', ' *\n', ' * Utility functions to handle Address Arrays\n', ' */\n', 'library AddressArrayUtils {\n', '\n', '    /**\n', '     * Finds the index of the first occurrence of the given element.\n', '     * @param A The input array to search\n', '     * @param a The value to find\n', '     * @return Returns (index and isIn) for the first occurrence starting from index 0\n', '     */\n', '    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n', '        uint256 length = A.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            if (A[i] == a) {\n', '                return (i, true);\n', '            }\n', '        }\n', '        return (uint256(-1), false);\n', '    }\n', '\n', '    /**\n', '    * Returns true if the value is present in the list. Uses indexOf internally.\n', '    * @param A The input array to search\n', '    * @param a The value to find\n', '    * @return Returns isIn for the first occurrence starting from index 0\n', '    */\n', '    function contains(address[] memory A, address a) internal pure returns (bool) {\n', '        (, bool isIn) = indexOf(A, a);\n', '        return isIn;\n', '    }\n', '\n', '    /**\n', '    * Returns true if there are 2 elements that are the same in an array\n', '    * @param A The input array to search\n', '    * @return Returns boolean for the first occurrence of a duplicate\n', '    */\n', '    function hasDuplicate(address[] memory A) internal pure returns(bool) {\n', '        require(A.length > 0, "A is empty");\n', '\n', '        for (uint256 i = 0; i < A.length - 1; i++) {\n', '            address current = A[i];\n', '            for (uint256 j = i + 1; j < A.length; j++) {\n', '                if (current == A[j]) {\n', '                    return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @param A The input array to search\n', '     * @param a The address to remove     \n', '     * @return Returns the array with the object removed.\n', '     */\n', '    function remove(address[] memory A, address a)\n', '        internal\n', '        pure\n', '        returns (address[] memory)\n', '    {\n', '        (uint256 index, bool isIn) = indexOf(A, a);\n', '        if (!isIn) {\n', '            revert("Address not in array.");\n', '        } else {\n', '            (address[] memory _A,) = pop(A, index);\n', '            return _A;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * Removes specified index from array\n', '    * @param A The input array to search\n', '    * @param index The index to remove\n', '    * @return Returns the new array and the removed entry\n', '    */\n', '    function pop(address[] memory A, uint256 index)\n', '        internal\n', '        pure\n', '        returns (address[] memory, address)\n', '    {\n', '        uint256 length = A.length;\n', '        require(index < A.length, "Index must be < A length");\n', '        address[] memory newAddresses = new address[](length - 1);\n', '        for (uint256 i = 0; i < index; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = index + 1; j < length; j++) {\n', '            newAddresses[j - 1] = A[j];\n', '        }\n', '        return (newAddresses, A[index]);\n', '    }\n', '\n', '    /**\n', '     * Returns the combination of the two arrays\n', '     * @param A The first array\n', '     * @param B The second array\n', '     * @return Returns A extended by B\n', '     */\n', '    function extend(address[] memory A, address[] memory B) internal pure returns (address[] memory) {\n', '        uint256 aLength = A.length;\n', '        uint256 bLength = B.length;\n', '        address[] memory newAddresses = new address[](aLength + bLength);\n', '        for (uint256 i = 0; i < aLength; i++) {\n', '            newAddresses[i] = A[i];\n', '        }\n', '        for (uint256 j = 0; j < bLength; j++) {\n', '            newAddresses[aLength + j] = B[j];\n', '        }\n', '        return newAddresses;\n', '    }\n', '}\n', '\n', '// Dependency file: contracts/interfaces/IICManagerV2.sol\n', '\n', '/*\n', '    Copyright 2021 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '// pragma solidity 0.6.10;\n', 'pragma experimental "ABIEncoderV2";\n', '\n', 'interface IICManagerV2 {\n', '    function methodologist() external returns(address);\n', '\n', '    function operator() external returns(address);\n', '\n', '    function interactModule(address _module, bytes calldata _encoded) external;\n', '}\n', '\n', '// Dependency file: contracts/lib/BaseAdapter.sol\n', '\n', '/*\n', '    Copyright 2021 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '// import { IICManagerV2 } from "contracts/interfaces/IICManagerV2.sol";\n', '\n', '/**\n', ' * @title BaseAdapter\n', ' * @author Set Protocol\n', ' *\n', ' * Abstract class that houses common adapter-related state and functions.\n', ' */\n', 'abstract contract BaseAdapter {\n', '\n', '    /* ============ Modifiers ============ */\n', '\n', '    /**\n', '     * Throws if the sender is not the SetToken operator\n', '     */\n', '    modifier onlyOperator() {\n', '        require(msg.sender == manager.operator(), "Must be operator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Throws if the sender is not the SetToken methodologist\n', '     */\n', '    modifier onlyMethodologist() {\n', '        require(msg.sender == manager.methodologist(), "Must be methodologist");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Throws if caller is a contract\n', '     */\n', '    modifier onlyEOA() {\n', '        require(msg.sender == tx.origin, "Caller must be EOA Address");\n', '        _;\n', '    }\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    // Instance of manager contract\n', '    IICManagerV2 public manager;\n', '\n', '\n', '    /* ============ Internal Functions ============ */\n', '    \n', '    /**\n', '     * Invoke call from manager\n', '     *\n', '     * @param _module           Module to interact with\n', '     * @param _encoded          Encoded byte data\n', '     */\n', '    function invokeManager(address _module, bytes memory _encoded) internal {\n', '        manager.interactModule(_module, _encoded);\n', '    }\n', '}\n', '\n', '// Dependency file: contracts/interfaces/ICErc20.sol\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '// import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', '\n', '/**\n', ' * @title ICErc20\n', ' *\n', ' * Interface for interacting with Compound cErc20 tokens (e.g. Dai, USDC)\n', ' */\n', 'interface ICErc20 is IERC20 {\n', '\n', '    function borrowBalanceCurrent(address _account) external returns (uint256);\n', '\n', '    function borrowBalanceStored(address _account) external view returns (uint256);\n', '\n', '    function balanceOfUnderlying(address _account) external returns (uint256);\n', '\n', '    /**\n', '     * Calculates the exchange rate from the underlying to the CToken\n', '     *\n', '     * @notice Accrue interest then return the up-to-date exchange rate\n', '     * @return Calculated exchange rate scaled by 1e18\n', '     */\n', '    function exchangeRateCurrent() external returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256);\n', '\n', '    function underlying() external returns (address);\n', '\n', '    /**\n', '     * Sender supplies assets into the market and receives cTokens in exchange\n', '     *\n', '     * @notice Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param _mintAmount The amount of the underlying asset to supply\n', '     * @return uint256 0=success, otherwise a failure\n', '     */\n', '    function mint(uint256 _mintAmount) external returns (uint256);\n', '\n', '    /**\n', '     * @notice Sender redeems cTokens in exchange for the underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param _redeemTokens The number of cTokens to redeem into underlying\n', '     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeem(uint256 _redeemTokens) external returns (uint256);\n', '\n', '    /**\n', '     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param _redeemAmount The amount of underlying to redeem\n', '     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeemUnderlying(uint256 _redeemAmount) external returns (uint256);\n', '\n', '    /**\n', '      * @notice Sender borrows assets from the protocol to their own address\n', '      * @param _borrowAmount The amount of the underlying asset to borrow\n', '      * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function borrow(uint256 _borrowAmount) external returns (uint256);\n', '\n', '    /**\n', '     * @notice Sender repays their own borrow\n', '     * @param _repayAmount The amount to repay\n', '     * @return uint256 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function repayBorrow(uint256 _repayAmount) external returns (uint256);\n', '}\n', '\n', '// Dependency file: contracts/interfaces/IComptroller.sol\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '\n', '/**\n', ' * @title IComptroller\n', ' *\n', ' * Interface for interacting with Compound Comptroller\n', ' */\n', 'interface IComptroller {\n', '\n', '    /**\n', '     * @notice Add assets to be included in account liquidity calculation\n', '     * @param cTokens The list of addresses of the cToken markets to be enabled\n', '     * @return Success indicator for whether each corresponding market was entered\n', '     */\n', '    function enterMarkets(address[] memory cTokens) external returns (uint256[] memory);\n', '\n', '    /**\n', "     * @notice Removes asset from sender's account liquidity calculation\n", '     * @dev Sender must not have an outstanding borrow balance in the asset,\n', '     *  or be providing neccessary collateral for an outstanding borrow.\n', '     * @param cTokenAddress The address of the asset to be removed\n', '     * @return Whether or not the account successfully exited the market\n', '     */\n', '    function exitMarket(address cTokenAddress) external returns (uint256);\n', '\n', '    function claimComp(address holder) external;\n', '\n', '    function markets(address cTokenAddress) external view returns (bool, uint256, bool);\n', '}\n', '\n', '// Dependency file: contracts/interfaces/ISetToken.sol\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '\n', '// import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', '/**\n', ' * @title ISetToken\n', ' * @author Set Protocol\n', ' *\n', ' * Interface for operating with SetTokens.\n', ' */\n', 'interface ISetToken is IERC20 {\n', '\n', '    /* ============ Enums ============ */\n', '\n', '    enum ModuleState {\n', '        NONE,\n', '        PENDING,\n', '        INITIALIZED\n', '    }\n', '\n', '    /* ============ Structs ============ */\n', '    /**\n', '     * The base definition of a SetToken Position\n', '     *\n', '     * @param component           Address of token in the Position\n', '     * @param module              If not in default state, the address of associated module\n', '     * @param unit                Each unit is the # of components per 10^18 of a SetToken\n', '     * @param positionState       Position ENUM. Default is 0; External is 1\n', '     * @param data                Arbitrary data\n', '     */\n', '    struct Position {\n', '        address component;\n', '        address module;\n', '        int256 unit;\n', '        uint8 positionState;\n', '        bytes data;\n', '    }\n', '\n', '    /**\n', "     * A struct that stores a component's cash position details and external positions\n", "     * This data structure allows O(1) access to a component's cash position units and \n", '     * virtual units.\n', '     *\n', "     * @param virtualUnit               Virtual value of a component's DEFAULT position. Stored as virtual for efficiency\n", '     *                                  updating all units at once via the position multiplier. Virtual units are achieved\n', '     *                                  by dividing a "real" value by the "positionMultiplier"\n', '     * @param componentIndex            \n', '     * @param externalPositionModules   List of external modules attached to each external position. Each module\n', '     *                                  maps to an external position\n', '     * @param externalPositions         Mapping of module => ExternalPosition struct for a given component\n', '     */\n', '    struct ComponentPosition {\n', '      int256 virtualUnit;\n', '      address[] externalPositionModules;\n', '      mapping(address => ExternalPosition) externalPositions;\n', '    }\n', '\n', '    /**\n', "     * A struct that stores a component's external position details including virtual unit and any\n", '     * auxiliary data.\n', '     *\n', "     * @param virtualUnit       Virtual value of a component's EXTERNAL position.\n", '     * @param data              Arbitrary data\n', '     */\n', '    struct ExternalPosition {\n', '      int256 virtualUnit;\n', '      bytes data;\n', '    }\n', '\n', '\n', '    /* ============ Functions ============ */\n', '    \n', '    function addComponent(address _component) external;\n', '    function removeComponent(address _component) external;\n', '    function editDefaultPositionUnit(address _component, int256 _realUnit) external;\n', '    function addExternalPositionModule(address _component, address _positionModule) external;\n', '    function removeExternalPositionModule(address _component, address _positionModule) external;\n', '    function editExternalPositionUnit(address _component, address _positionModule, int256 _realUnit) external;\n', '    function editExternalPositionData(address _component, address _positionModule, bytes calldata _data) external;\n', '\n', '    function invoke(address _target, uint256 _value, bytes calldata _data) external returns(bytes memory);\n', '\n', '    function editPositionMultiplier(int256 _newMultiplier) external;\n', '\n', '    function mint(address _account, uint256 _quantity) external;\n', '    function burn(address _account, uint256 _quantity) external;\n', '\n', '    function lock() external;\n', '    function unlock() external;\n', '\n', '    function addModule(address _module) external;\n', '    function removeModule(address _module) external;\n', '    function initializeModule() external;\n', '\n', '    function setManager(address _manager) external;\n', '\n', '    function manager() external view returns (address);\n', '    function moduleStates(address _module) external view returns (ModuleState);\n', '    function getModules() external view returns (address[] memory);\n', '    \n', '    function getDefaultPositionRealUnit(address _component) external view returns(int256);\n', '    function getExternalPositionRealUnit(address _component, address _positionModule) external view returns(int256);\n', '    function getComponents() external view returns(address[] memory);\n', '    function getExternalPositionModules(address _component) external view returns(address[] memory);\n', '    function getExternalPositionData(address _component, address _positionModule) external view returns(bytes memory);\n', '    function isExternalPositionModule(address _component, address _module) external view returns(bool);\n', '    function isComponent(address _component) external view returns(bool);\n', '    \n', '    function positionMultiplier() external view returns (int256);\n', '    function getPositions() external view returns (Position[] memory);\n', '    function getTotalComponentRealUnits(address _component) external view returns(int256);\n', '\n', '    function isInitializedModule(address _module) external view returns(bool);\n', '    function isPendingModule(address _module) external view returns(bool);\n', '    function isLocked() external view returns (bool);\n', '}\n', '\n', '// Dependency file: contracts/interfaces/ICompoundLeverageModule.sol\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '\n', '// import { ISetToken } from "contracts/interfaces/ISetToken.sol";\n', '\n', 'interface ICompoundLeverageModule {\n', '    function sync(\n', '        ISetToken _setToken\n', '    ) external;\n', '\n', '    function lever(\n', '        ISetToken _setToken,\n', '        address _borrowAsset,\n', '        address _collateralAsset,\n', '        uint256 _borrowQuantity,\n', '        uint256 _minReceiveQuantity,\n', '        string memory _tradeAdapterName,\n', '        bytes memory _tradeData\n', '    ) external;\n', '\n', '    function delever(\n', '        ISetToken _setToken,\n', '        address _collateralAsset,\n', '        address _repayAsset,\n', '        uint256 _redeemQuantity,\n', '        uint256 _minRepayQuantity,\n', '        string memory _tradeAdapterName,\n', '        bytes memory _tradeData\n', '    ) external;\n', '\n', '    function gulp(\n', '        ISetToken _setToken,\n', '        address _collateralAsset,\n', '        uint256 _minNotionalReceiveQuantity,\n', '        string memory _tradeAdapterName,\n', '        bytes memory _tradeData\n', '    ) external;\n', '}\n', '\n', '// Dependency file: contracts/interfaces/ICompoundPriceOracle.sol\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '\n', '/**\n', ' * @title ICompoundPriceOracle\n', ' *\n', ' * Interface for interacting with Compound price oracle\n', ' */\n', 'interface ICompoundPriceOracle {\n', '\n', '    function getUnderlyingPrice(address _asset) external view returns(uint256);\n', '}\n', '\n', '// Dependency file: @openzeppelin/contracts/math/SignedSafeMath.sol\n', '\n', '\n', '// pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title SignedSafeMath\n', ' * @dev Signed math operations with safety checks that revert on error.\n', ' */\n', 'library SignedSafeMath {\n', '    int256 constant private _INT256_MIN = -2**255;\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b, "SignedSafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two signed integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "SignedSafeMath: division by zero");\n', '        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '// Dependency file: contracts/lib/PreciseUnitMath.sol\n', '\n', '/*\n', '    Copyright 2020 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '\n', '\n', '*/\n', '\n', '// pragma solidity 0.6.10;\n', '\n', '\n', '// import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n', '// import { SignedSafeMath } from "@openzeppelin/contracts/math/SignedSafeMath.sol";\n', '\n', '\n', '/**\n', ' * @title PreciseUnitMath\n', ' * @author Set Protocol\n', ' *\n', ' * Arithmetic for fixed-point numbers with 18 decimals of precision. Some functions taken from\n', " * dYdX's BaseMath library.\n", ' *\n', ' * CHANGELOG:\n', ' * - 9/21/20: Added safePower function\n', ' */\n', 'library PreciseUnitMath {\n', '    using SafeMath for uint256;\n', '    using SignedSafeMath for int256;\n', '\n', '    // The number One in precise units.\n', '    uint256 constant internal PRECISE_UNIT = 10 ** 18;\n', '    int256 constant internal PRECISE_UNIT_INT = 10 ** 18;\n', '\n', '    // Max unsigned integer value\n', '    uint256 constant internal MAX_UINT_256 = type(uint256).max;\n', '    // Max and min signed integer value\n', '    int256 constant internal MAX_INT_256 = type(int256).max;\n', '    int256 constant internal MIN_INT_256 = type(int256).min;\n', '\n', '    /**\n', "     * @dev Getter function since constants can't be read directly from libraries.\n", '     */\n', '    function preciseUnit() internal pure returns (uint256) {\n', '        return PRECISE_UNIT;\n', '    }\n', '\n', '    /**\n', "     * @dev Getter function since constants can't be read directly from libraries.\n", '     */\n', '    function preciseUnitInt() internal pure returns (int256) {\n', '        return PRECISE_UNIT_INT;\n', '    }\n', '\n', '    /**\n', "     * @dev Getter function since constants can't be read directly from libraries.\n", '     */\n', '    function maxUint256() internal pure returns (uint256) {\n', '        return MAX_UINT_256;\n', '    }\n', '\n', '    /**\n', "     * @dev Getter function since constants can't be read directly from libraries.\n", '     */\n', '    function maxInt256() internal pure returns (int256) {\n', '        return MAX_INT_256;\n', '    }\n', '\n', '    /**\n', "     * @dev Getter function since constants can't be read directly from libraries.\n", '     */\n', '    function minInt256() internal pure returns (int256) {\n', '        return MIN_INT_256;\n', '    }\n', '\n', '    /**\n', "     * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\n", '     * of a number with 18 decimals precision.\n', '     */\n', '    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a.mul(b).div(PRECISE_UNIT);\n', '    }\n', '\n', '    /**\n', "     * @dev Multiplies value a by value b (result is rounded towards zero). It's assumed that the value b is the\n", '     * significand of a number with 18 decimals precision.\n', '     */\n', '    function preciseMul(int256 a, int256 b) internal pure returns (int256) {\n', '        return a.mul(b).div(PRECISE_UNIT_INT);\n', '    }\n', '\n', '    /**\n', "     * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\n", '     * of a number with 18 decimals precision.\n', '     */\n', '    function preciseMulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '        return a.mul(b).sub(1).div(PRECISE_UNIT).add(1);\n', '    }\n', '\n', '    /**\n', '     * @dev Divides value a by value b (result is rounded down).\n', '     */\n', '    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a.mul(PRECISE_UNIT).div(b);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Divides value a by value b (result is rounded towards 0).\n', '     */\n', '    function preciseDiv(int256 a, int256 b) internal pure returns (int256) {\n', '        return a.mul(PRECISE_UNIT_INT).div(b);\n', '    }\n', '\n', '    /**\n', '     * @dev Divides value a by value b (result is rounded up or away from 0).\n', '     */\n', '    function preciseDivCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "Cant divide by 0");\n', '\n', '        return a > 0 ? a.mul(PRECISE_UNIT).sub(1).div(b).add(1) : 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides value a by value b (result is rounded down - positive numbers toward 0 and negative away from 0).\n', '     */\n', '    function divDown(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "Cant divide by 0");\n', '        require(a != MIN_INT_256 || b != -1, "Invalid input");\n', '\n', '        int256 result = a.div(b);\n', '        if (a ^ b < 0 && a % b != 0) {\n', '            result -= 1;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies value a by value b where rounding is towards the lesser number. \n', '     * (positive values are rounded towards zero and negative values are rounded away from 0). \n', '     */\n', '    function conservativePreciseMul(int256 a, int256 b) internal pure returns (int256) {\n', '        return divDown(a.mul(b), PRECISE_UNIT_INT);\n', '    }\n', '\n', '    /**\n', '     * @dev Divides value a by value b where rounding is towards the lesser number. \n', '     * (positive values are rounded towards zero and negative values are rounded away from 0). \n', '     */\n', '    function conservativePreciseDiv(int256 a, int256 b) internal pure returns (int256) {\n', '        return divDown(a.mul(PRECISE_UNIT_INT), b);\n', '    }\n', '\n', '    /**\n', '    * @dev Performs the power on a specified value, reverts on overflow.\n', '    */\n', '    function safePower(\n', '        uint256 a,\n', '        uint256 pow\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        require(a > 0, "Value must be positive");\n', '\n', '        uint256 result = 1;\n', '        for (uint256 i = 0; i < pow; i++){\n', '            uint256 previousResult = result;\n', '\n', '            // Using safemath multiplication prevents overflows\n', '            result = previousResult.mul(a);\n', '        }\n', '\n', '        return result;\n', '    }\n', '}\n', '\n', '// Root file: contracts/adapters/FlexibleLeverageStrategyAdapter.sol\n', '\n', '/*\n', '    Copyright 2021 Set Labs Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity 0.6.10;\n', '\n', '\n', '// import { Address } from "@openzeppelin/contracts/utils/Address.sol";\n', '// import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\n', '// import { Math } from "@openzeppelin/contracts/math/Math.sol";\n', '// import { SafeMath } from "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '// import { AddressArrayUtils } from "contracts/lib/AddressArrayUtils.sol";\n', '// import { BaseAdapter } from "contracts/lib/BaseAdapter.sol";\n', '// import { ICErc20 } from "contracts/interfaces/ICErc20.sol";\n', '// import { IICManagerV2 } from "contracts/interfaces/IICManagerV2.sol";\n', '// import { IComptroller } from "contracts/interfaces/IComptroller.sol";\n', '// import { ICompoundLeverageModule } from "contracts/interfaces/ICompoundLeverageModule.sol";\n', '// import { ICompoundPriceOracle } from "contracts/interfaces/ICompoundPriceOracle.sol";\n', '// import { ISetToken } from "contracts/interfaces/ISetToken.sol";\n', '// import { PreciseUnitMath } from "contracts/lib/PreciseUnitMath.sol";\n', '\n', '/**\n', ' * @title FlexibleLeverageStrategyAdapter\n', ' * @author Set Protocol\n', ' *\n', ' * Smart contract that enables trustless leverage tokens using the flexible leverage methodology. This adapter is paired with the CompoundLeverageModule from Set\n', ' * protocol where module interactions are invoked via the ICManagerV2 contract. Any leveraged token can be constructed as long as the collateral and borrow\n', ' * asset is available on Compound. This adapter contract also allows the operator to set an ETH reward to incentivize keepers calling the rebalance function at\n', ' * different leverage thresholds.\n', ' *\n', ' */\n', 'contract FlexibleLeverageStrategyAdapter is BaseAdapter {\n', '    using Address for address;\n', '    using AddressArrayUtils for address[];\n', '    using PreciseUnitMath for uint256;\n', '    using SafeMath for uint256;\n', '\n', '    /* ============ Enums ============ */\n', '\n', '    enum ShouldRebalance {\n', '        NONE,\n', '        REBALANCE,\n', '        RIPCORD\n', '    }\n', '\n', '    /* ============ Structs ============ */\n', '\n', '    struct ActionInfo {\n', '        uint256 collateralPrice;                   // Price of underlying in precise units (10e18)\n', '        uint256 borrowPrice;                       // Price of underlying in precise units (10e18)\n', '        uint256 collateralBalance;                 // Balance of underlying held in Compound in base units (e.g. USDC 10e6)\n', '        uint256 borrowBalance;                     // Balance of underlying borrowed from Compound in base units\n', '        uint256 collateralValue;                   // Valuation in USD adjusted for decimals in precise units (10e18)\n', '        uint256 borrowValue;                       // Valuation in USD adjusted for decimals in precise units (10e18)\n', '        uint256 setTotalSupply;                    // Total supply of SetToken\n', '    }\n', '\n', '    struct LeverageTokenSettings {\n', '        ISetToken setToken;                              // Instance of leverage token\n', '        ICompoundLeverageModule leverageModule;          // Instance of Compound leverage module\n', '        IICManagerV2 manager;                            // Instance of manager contract of SetToken\n', '\n', '        IComptroller comptroller;                        // Instance of Compound Comptroller\n', '        ICompoundPriceOracle priceOracle;                // Compound open oracle feed\n', '\n', '        ICErc20 targetCollateralCToken;                  // Instance of target collateral cToken asset\n', '        ICErc20 targetBorrowCToken;                      // Instance of target borrow cToken asset\n', '        address collateralAsset;                         // Address of underlying collateral\n', '        address borrowAsset;                             // Address of underlying borrow asset\n', '        \n', '        uint256 targetLeverageRatio;                     // Long term target ratio in precise units (10e18)\n', '        uint256 minLeverageRatio;                        // In precise units (10e18). If current leverage is below, rebalance target is this ratio\n', '        uint256 maxLeverageRatio;                        // In precise units (10e18). If current leverage is above, rebalance target is this ratio\n', '        uint256 recenteringSpeed;                        // % at which to rebalance back to target leverage in precise units (10e18)\n', '        uint256 rebalanceInterval;                       // Period of time required since last rebalance timestamp in seconds\n', '\n', '        uint256 unutilizedLeveragePercentage;            // Percent of max borrow left unutilized in precise units (1% = 10e16)\n', '        uint256 twapMaxTradeSize;                        // Max trade size in collateral base units\n', '        uint256 twapCooldownPeriod;                      // Cooldown period required since last trade timestamp in seconds\n', '        uint256 slippageTolerance;                       // % in precise units to price min token receive amount from trade quantities\n', '\n', '        uint256 etherReward;                             // ETH reward for incentivized rebalances\n', '        uint256 incentivizedLeverageRatio;               // Leverage ratio for incentivized rebalances\n', '        uint256 incentivizedSlippageTolerance;           // Slippage tolerance percentage for incentivized rebalances\n', '        uint256 incentivizedTwapCooldownPeriod;          // TWAP cooldown in seconds for incentivized rebalances\n', '        uint256 incentivizedTwapMaxTradeSize;            // Max trade size for incentivized rebalances in collateral base units\n', '\n', '        string exchangeName;                             // Name of exchange that is being used for leverage\n', '        bytes exchangeData;                              // Arbitrary exchange data passed into rebalance function\n', '    }\n', '\n', '    /* ============ Events ============ */\n', '\n', '    event TraderStatusUpdated(address indexed _trader, bool _status);\n', '    event AnyoneTradeUpdated(bool indexed _status);\n', '\n', '    /* ============ Modifiers ============ */\n', '\n', '    modifier onlyAllowedTrader(address _caller) {\n', '        require(_isAllowedTrader(_caller), "Address not permitted to trade");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Throws if rebalance is currently in TWAP`\n', '     */\n', '    modifier noRebalanceInProgress() {\n', '        require(twapLeverageRatio == 0, "Rebalance is currently in progress");\n', '        _;\n', '    }\n', '\n', '    /* ============ State Variables ============ */\n', '\n', '    ISetToken public setToken;\n', '    ICompoundLeverageModule public leverageModule;\n', '\n', '    IComptroller public comptroller;\n', '    ICompoundPriceOracle public priceOracle;\n', '\n', '    ICErc20 public targetCollateralCToken;\n', '    ICErc20 public targetBorrowCToken;\n', '    address public collateralAsset;\n', '    address public borrowAsset;\n', '    uint256 internal collateralAssetDecimals;\n', '    uint256 internal borrowAssetDecimals;\n', '    \n', '    uint256 public targetLeverageRatio;\n', '    uint256 public minLeverageRatio;\n', '    uint256 public maxLeverageRatio;\n', '    uint256 public recenteringSpeed;\n', '    uint256 public rebalanceInterval;\n', '\n', '    uint256 public unutilizedLeveragePercentage;\n', '    uint256 public twapMaxTradeSize;\n', '    uint256 public twapCooldownPeriod;\n', '    uint256 public slippageTolerance;\n', '\n', '    uint256 public etherReward;\n', '    uint256 public incentivizedLeverageRatio;\n', '    uint256 public incentivizedSlippageTolerance;\n', '    uint256 public incentivizedTwapCooldownPeriod;\n', '    uint256 public incentivizedTwapMaxTradeSize;\n', '\n', '    string public exchangeName;\n', '    bytes public exchangeData;\n', '\n', '    // Stored leverage ratio to keep track of target between TWAP rebalances\n', '    uint256 public twapLeverageRatio;\n', '\n', '    // Last rebalance timestamp. Must be past rebalance interval to rebalance\n', '    uint256 public lastTradeTimestamp;\n', '\n', '    // Boolean indicating if anyone can call rebalance()\n', '    bool public anyoneTrade;\n', '\n', '    // Mapping of addresses allowed to call rebalance()\n', '    mapping(address => bool) public tradeAllowList;\n', '\n', '    /* ============ Constructor ============ */\n', '\n', '    /**\n', '     * Instantiate addresses, asset decimals, methodology parameters, execution parameters, and initial exchange name and data\n', '     * \n', '     * @param _leverageTokenSettings            Struct containing data for initializing this adapter\n', '     */\n', '    constructor(LeverageTokenSettings memory _leverageTokenSettings) public {  \n', '        require (\n', '            _leverageTokenSettings.minLeverageRatio <= _leverageTokenSettings.targetLeverageRatio,\n', '            "Must be valid min leverage"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.maxLeverageRatio >= _leverageTokenSettings.targetLeverageRatio,\n', '            "Must be valid max leverage"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.recenteringSpeed <= PreciseUnitMath.preciseUnit() && _leverageTokenSettings.recenteringSpeed > 0,\n', '            "Must be valid recentering speed"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.unutilizedLeveragePercentage <= PreciseUnitMath.preciseUnit(),\n', '            "Unutilized leverage must be <100%"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.slippageTolerance <= PreciseUnitMath.preciseUnit(),\n', '            "Slippage tolerance must be <100%"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.incentivizedSlippageTolerance <= PreciseUnitMath.preciseUnit(),\n', '            "Incentivized slippage tolerance must be <100%"\n', '        );\n', '        require (\n', '            _leverageTokenSettings.incentivizedLeverageRatio >= _leverageTokenSettings.maxLeverageRatio,\n', '            "Incentivized leverage ratio must be > max leverage ratio"\n', '        );\n', '\n', '        setToken = _leverageTokenSettings.setToken;\n', '        leverageModule = _leverageTokenSettings.leverageModule;\n', '        manager = _leverageTokenSettings.manager;\n', '\n', '        comptroller = _leverageTokenSettings.comptroller;\n', '        priceOracle = _leverageTokenSettings.priceOracle;\n', '        targetCollateralCToken = _leverageTokenSettings.targetCollateralCToken;\n', '        targetBorrowCToken = _leverageTokenSettings.targetBorrowCToken;\n', '        collateralAsset = _leverageTokenSettings.collateralAsset;\n', '        borrowAsset = _leverageTokenSettings.borrowAsset;\n', '\n', '        collateralAssetDecimals = ERC20(collateralAsset).decimals();\n', '        borrowAssetDecimals = ERC20(borrowAsset).decimals();\n', '\n', '        targetLeverageRatio = _leverageTokenSettings.targetLeverageRatio;\n', '        minLeverageRatio = _leverageTokenSettings.minLeverageRatio;\n', '        maxLeverageRatio = _leverageTokenSettings.maxLeverageRatio;\n', '        recenteringSpeed = _leverageTokenSettings.recenteringSpeed;\n', '        rebalanceInterval = _leverageTokenSettings.rebalanceInterval;\n', '\n', '        unutilizedLeveragePercentage = _leverageTokenSettings.unutilizedLeveragePercentage;\n', '        twapMaxTradeSize = _leverageTokenSettings.twapMaxTradeSize;\n', '        twapCooldownPeriod = _leverageTokenSettings.twapCooldownPeriod;\n', '        slippageTolerance = _leverageTokenSettings.slippageTolerance;\n', '\n', '        incentivizedTwapMaxTradeSize = _leverageTokenSettings.incentivizedTwapMaxTradeSize;\n', '        incentivizedTwapCooldownPeriod = _leverageTokenSettings.incentivizedTwapCooldownPeriod;\n', '        incentivizedSlippageTolerance = _leverageTokenSettings.incentivizedSlippageTolerance;\n', '        etherReward = _leverageTokenSettings.etherReward;\n', '        incentivizedLeverageRatio = _leverageTokenSettings.incentivizedLeverageRatio;\n', '\n', '        exchangeName = _leverageTokenSettings.exchangeName;\n', '        exchangeData = _leverageTokenSettings.exchangeData;\n', '    }\n', '\n', '    /* ============ External Functions ============ */\n', '\n', '    /**\n', '     * OPERATOR ONLY: Engage to target leverage ratio for the first time. SetToken will borrow debt position from Compound and trade for collateral asset. If target\n', '     * leverage ratio is above max borrow or max trade size, then TWAP is kicked off. To complete engage if TWAP, you must call rebalance until target\n', '     * is met.\n', '     */\n', '    function engage() external onlyOperator {\n', '        ActionInfo memory engageInfo = _createActionInfo();\n', '\n', '        require(engageInfo.setTotalSupply > 0, "SetToken must have > 0 supply");\n', '        require(engageInfo.collateralBalance > 0, "Collateral balance must be > 0");\n', '        require(engageInfo.borrowBalance == 0, "Debt must be 0");\n', '\n', '        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n', '        _lever(\n', '            PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n', '            targetLeverageRatio,\n', '            engageInfo\n', '        ); \n', '    }\n', '\n', '    /**\n', '     * ONLY EOA AND ALLOWED TRADER: Rebalance according to flexible leverage methodology. If current leverage ratio is between the max and min bounds, then rebalance \n', '     * can only be called once the rebalance interval has elapsed since last timestamp. If outside the max and min, rebalance can be called anytime to bring leverage\n', '     * ratio back to the max or min bounds. The methodology will determine whether to delever or lever.\n', '     *\n', '     * Note: If the calculated current leverage ratio is above the incentivized leverage ratio then rebalance cannot be called. Instead, you must call ripcord() which\n', '     * is incentivized with a reward in Ether\n', '     */\n', '    function rebalance() external onlyEOA onlyAllowedTrader(msg.sender) {\n', '\n', '        ActionInfo memory rebalanceInfo = _createActionInfo();\n', '        require(rebalanceInfo.borrowBalance > 0, "Borrow balance must exist");\n', '\n', '        uint256 currentLeverageRatio = _calculateCurrentLeverageRatio(\n', '            rebalanceInfo.collateralValue,\n', '            rebalanceInfo.borrowValue\n', '        );\n', '\n', '        // Ensure that when leverage exceeds incentivized threshold, only ripcord can be called to prevent potential state inconsistencies\n', '        require(currentLeverageRatio < incentivizedLeverageRatio, "Must call ripcord");\n', '\n', '        uint256 newLeverageRatio;\n', '        if (twapLeverageRatio != 0) {\n', '            // // importANT: If currently in TWAP and price has moved advantageously. For delever, this means the current leverage ratio has dropped\n', '            // below the TWAP leverage ratio and for lever, this means the current leverage ratio has gone above the TWAP leverage ratio. \n', '            // Update state and exit the function, skipping additional calculations and trade.\n', '            if (_updateStateAndExitIfAdvantageous(currentLeverageRatio)) {\n', '                return;\n', '            }\n', '\n', '            // If currently in the midst of a TWAP rebalance, ensure that the cooldown period has elapsed\n', '            require(lastTradeTimestamp.add(twapCooldownPeriod) < block.timestamp, "Cooldown period must have elapsed");\n', '\n', '            newLeverageRatio = twapLeverageRatio;\n', '        } else {\n', '            require(\n', '                block.timestamp.sub(lastTradeTimestamp) > rebalanceInterval\n', '                || currentLeverageRatio > maxLeverageRatio\n', '                || currentLeverageRatio < minLeverageRatio,\n', '                "Rebalance interval not yet elapsed"\n', '            );\n', '            newLeverageRatio = _calculateNewLeverageRatio(currentLeverageRatio);\n', '        }\n', '        \n', '        if (newLeverageRatio < currentLeverageRatio) {\n', '            _delever(\n', '                currentLeverageRatio,\n', '                newLeverageRatio,\n', '                rebalanceInfo,\n', '                slippageTolerance,\n', '                twapMaxTradeSize\n', '            );\n', '        } else {\n', "            // In the case newLeverageRatio is equal to currentLeverageRatio (which only occurs if we're exactly at the target), the trade quantity\n", '            // will be calculated as 0 and will revert in the CompoundLeverageModule.\n', '            _lever(\n', '                currentLeverageRatio,\n', '                newLeverageRatio,\n', '                rebalanceInfo\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * ONLY EOA: In case the current leverage ratio exceeds the incentivized leverage threshold, the ripcord function can be called by anyone to return leverage ratio\n', '     * back to the max leverage ratio. This function typically would only be called during times of high downside volatility and / or normal keeper malfunctions. The caller\n', "     * of ripcord() will receive a reward in Ether. The ripcord function uses it's own TWAP cooldown period, slippage tolerance and TWAP max trade size which are typically\n", '     * looser than in the rebalance() function.\n', '     */\n', '    function ripcord() external onlyEOA {\n', '        // If currently in the midst of a TWAP rebalance, ensure that the cooldown period has elapsed\n', '        if (twapLeverageRatio != 0) {\n', '            require(\n', '                lastTradeTimestamp.add(incentivizedTwapCooldownPeriod) < block.timestamp,\n', '                "Incentivized cooldown period must have elapsed"\n', '            );\n', '        }\n', '\n', '        ActionInfo memory ripcordInfo = _createActionInfo();\n', '        require(ripcordInfo.borrowBalance > 0, "Borrow balance must exist");\n', '\n', '        uint256 currentLeverageRatio = _calculateCurrentLeverageRatio(\n', '            ripcordInfo.collateralValue,\n', '            ripcordInfo.borrowValue\n', '        );\n', '\n', '        // Ensure that current leverage ratio must be greater than leverage threshold\n', '        require(currentLeverageRatio >= incentivizedLeverageRatio, "Must be above incentivized leverage ratio");\n', '        \n', '        _delever(\n', '            currentLeverageRatio,\n', '            maxLeverageRatio, // The target new leverage ratio is always the max leverage ratio\n', '            ripcordInfo,\n', '            incentivizedSlippageTolerance,\n', '            incentivizedTwapMaxTradeSize\n', '        );\n', '\n', '        _transferEtherRewardToCaller(etherReward);\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Return leverage ratio to 1x and delever to repay loan. This can be used for upgrading or shutting down the strategy.\n', '     *\n', '     * Note: due to rounding on trades, loan value may not be entirely repaid.\n', '     */\n', '    function disengage() external onlyOperator {\n', '        ActionInfo memory disengageInfo = _createActionInfo();\n', '\n', '        require(disengageInfo.setTotalSupply > 0, "SetToken must have > 0 supply");\n', '        require(disengageInfo.collateralBalance > 0, "Collateral balance must be > 0");\n', '        require(disengageInfo.borrowBalance > 0, "Borrow balance must exist");\n', '\n', '        // Get current leverage ratio\n', '        uint256 currentLeverageRatio = _calculateCurrentLeverageRatio(\n', '            disengageInfo.collateralValue,\n', '            disengageInfo.borrowValue\n', '        );\n', '\n', '        _delever(\n', '            currentLeverageRatio,\n', '            PreciseUnitMath.preciseUnit(), // This is reducing back to a leverage ratio of 1\n', '            disengageInfo,\n', '            slippageTolerance,\n', '            twapMaxTradeSize\n', '        );\n', '    }\n', '\n', '    /**\n', '     * ONLY EOA: Call gulp on the CompoundLeverageModule. Gulp will claim COMP from liquidity mining and sell for more collateral asset, which effectively distributes to\n', '     * SetToken holders and reduces the interest rate paid for borrowing. Rebalance must not be in progress. Anyone callable\n', '     */\n', '    function gulp() external noRebalanceInProgress onlyEOA {\n', '        bytes memory gulpCallData = abi.encodeWithSignature(\n', '            "gulp(address,address,uint256,string,bytes)",\n', '            address(setToken),\n', '            collateralAsset,\n', '            0,\n', '            exchangeName,\n', '            exchangeData\n', '        );\n', '\n', '        invokeManager(address(leverageModule), gulpCallData);\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set min leverage ratio. If current leverage ratio falls below, strategy will rebalance to this ratio.\n', '     * Rebalance must not be in progress\n', '     *\n', '     * @param _minLeverageRatio       New min leverage ratio for methodology\n', '     */\n', '    function setMinLeverageRatio(uint256 _minLeverageRatio) external onlyOperator noRebalanceInProgress {\n', '        minLeverageRatio = _minLeverageRatio;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set max leverage ratio. If current leverage ratio rises above, strategy will rebalance to this ratio.\n', '     * Rebalance must not be in progress\n', '     *\n', '     * @param _maxLeverageRatio       New max leverage ratio for methodology\n', '     */\n', '    function setMaxLeverageRatio(uint256 _maxLeverageRatio) external onlyOperator noRebalanceInProgress {\n', '        maxLeverageRatio = _maxLeverageRatio;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set recentering speed in percentage. Rebalance must not be in progress\n', '     *\n', '     * @param _recenteringSpeed       New recentering speed in percentage (1% = 1e16)\n', '     */\n', '    function setRecenteringSpeedPercentage(uint256 _recenteringSpeed) external onlyOperator noRebalanceInProgress {\n', '        recenteringSpeed = _recenteringSpeed;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set rebalance interval in seconds. Rebalance must not be in progress\n', '     *\n', '     * @param _rebalanceInterval      New rebalance interval in seconds\n', '     */\n', '    function setRebalanceInterval(uint256 _rebalanceInterval) external onlyOperator noRebalanceInProgress {\n', '        rebalanceInterval = _rebalanceInterval;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set percentage of max borrow left utilized. Rebalance must not be in progress\n', '     *\n', '     * @param _unutilizedLeveragePercentage       New buffer percentage\n', '     */\n', '    function setUnutilizedLeveragePercentage(uint256 _unutilizedLeveragePercentage) external onlyOperator noRebalanceInProgress {\n', '        unutilizedLeveragePercentage = _unutilizedLeveragePercentage;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set max trade size in collateral base units for regular rebalance. Rebalance must not be in progress\n', '     *\n', '     * @param _twapMaxTradeSize           Max trade size in collateral units\n', '     */\n', '    function setMaxTradeSize(uint256 _twapMaxTradeSize) external onlyOperator noRebalanceInProgress {\n', '        twapMaxTradeSize = _twapMaxTradeSize;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set slippage tolerance in percentage for regular rebalance. Rebalance must not be in progress\n', '     *\n', '     * @param _slippageTolerance           Slippage tolerance in percentage in precise units (1% = 1e16)\n', '     */\n', '    function setSlippageTolerance(uint256 _slippageTolerance) external onlyOperator noRebalanceInProgress {\n', '        slippageTolerance = _slippageTolerance;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set TWAP cooldown period in seconds for regular rebalance. Rebalance must not be in progress\n', '     *\n', '     * @param _twapCooldownPeriod           New TWAP cooldown period in seconds\n', '     */\n', '    function setCooldownPeriod(uint256 _twapCooldownPeriod) external onlyOperator noRebalanceInProgress {\n', '        twapCooldownPeriod = _twapCooldownPeriod;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set max trade size in collateral base units for ripcord function. Rebalance must not be in progress\n', '     *\n', '     * @param _incentivizedTwapMaxTradeSize           Max trade size in collateral units\n', '     */\n', '    function setIncentivizedMaxTradeSize(uint256 _incentivizedTwapMaxTradeSize) external onlyOperator noRebalanceInProgress {\n', '        incentivizedTwapMaxTradeSize = _incentivizedTwapMaxTradeSize;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set cooldown period in seconds for ripcord function. Rebalance must not be in progress\n', '     *\n', '     * @param _incentivizedTwapCooldownPeriod           TWAP cooldown period in seconds\n', '     */\n', '    function setIncentivizedCooldownPeriod(uint256 _incentivizedTwapCooldownPeriod) external onlyOperator noRebalanceInProgress {\n', '        incentivizedTwapCooldownPeriod = _incentivizedTwapCooldownPeriod;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set leverage ratio threshold at which keepers are eligible to call ripcord and receive an ETH reward.\n', '     * Rebalance must not be in progress\n', '     *\n', '     * @param _incentivizedLeverageRatio           Leverage ratio required to receive lower tier of ETH rewards\n', '     */\n', '    function setIncentivizedLeverageRatio(uint256 _incentivizedLeverageRatio) external onlyOperator noRebalanceInProgress {\n', '        incentivizedLeverageRatio = _incentivizedLeverageRatio;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set slippage tolerance for when rebalance is incentivized. Rebalance must not be in progress\n', '     *\n', '     * @param _incentivizedSlippageTolerance           Slippage tolerance in percentage in precise units. (1% = 1e16)\n', '     */\n', '    function setIncentivizedSlippageTolerance(uint256 _incentivizedSlippageTolerance) external onlyOperator noRebalanceInProgress {\n', '        incentivizedSlippageTolerance = _incentivizedSlippageTolerance;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set ETH reward for a single ripcord function call. Rebalance must not be in progress\n', '     *\n', '     * @param _etherReward           Amount of Ether in base units (10e18) per ripcord call\n', '     */\n', '    function setEtherReward(uint256 _etherReward) external onlyOperator noRebalanceInProgress {\n', '        etherReward = _etherReward;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Withdraw entire balance of ETH in this contract to operator. Rebalance must not be in progress\n', '     */\n', '    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set exchange name identifier used to execute trades. Rebalance must not be in progress\n', '     *\n', '     * @param _exchangeName           Name of new exchange to set\n', '     */\n', '    function setExchange(string calldata _exchangeName) external onlyOperator noRebalanceInProgress {\n', '        exchangeName = _exchangeName;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Set exchange data that is used by certain exchanges to execute trades. Rebalance must not be in progress\n', '     *\n', '     * @param _exchangeData           Arbitrary exchange data\n', '     */\n', '    function setExchangeData(bytes calldata _exchangeData) external onlyOperator noRebalanceInProgress {\n', '        exchangeData = _exchangeData;\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Toggle ability for passed addresses to trade from current state \n', '     *\n', '     * @param _traders           Array trader addresses to toggle status\n', '     */\n', '    function updateTraderStatus(address[] calldata _traders, bool[] calldata _statuses) external onlyOperator noRebalanceInProgress {\n', '        require(_traders.length == _statuses.length, "Array length mismatch");\n', '        require(_traders.length > 0, "Array length must be > 0");\n', '        require(!_traders.hasDuplicate(), "Cannot duplicate traders");\n', '\n', '        for (uint256 i = 0; i < _traders.length; i++) {\n', '            address trader = _traders[i];\n', '            bool status = _statuses[i];\n', '            tradeAllowList[trader] = status;\n', '            emit TraderStatusUpdated(trader, status);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * OPERATOR ONLY: Toggle whether anyone can trade, bypassing the traderAllowList \n', '     *\n', '     * @param _status           Boolean indicating whether to allow anyone trade\n', '     */\n', '    function updateAnyoneTrade(bool _status) external onlyOperator noRebalanceInProgress {\n', '        anyoneTrade = _status;\n', '        emit AnyoneTradeUpdated(_status);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    /* ============ External Getter Functions ============ */\n', '\n', '    /**\n', '     * Get current leverage ratio. Current leverage ratio is defined as the USD value of the collateral divided by the USD value of the SetToken. Prices for collateral\n', '     * and borrow asset are retrieved from the Compound Price Oracle.\n', '     *\n', '     * return currentLeverageRatio         Current leverage ratio in precise units (10e18)\n', '     */\n', '    function getCurrentLeverageRatio() public view returns(uint256) {\n', '        ActionInfo memory currentLeverageInfo = _createActionInfo();\n', '\n', '        return _calculateCurrentLeverageRatio(currentLeverageInfo.collateralValue, currentLeverageInfo.borrowValue);\n', '    }\n', '\n', '    /**\n', '     * Get current Ether incentive for when current leverage ratio exceeds incentivized leverage ratio and ripcord can be called\n', '     *\n', '     * return etherReward               Quantity of ETH reward in base units (10e18)\n', '     */\n', '    function getCurrentEtherIncentive() external view returns(uint256) {\n', '        uint256 currentLeverageRatio = getCurrentLeverageRatio();\n', '\n', '        if (currentLeverageRatio >= incentivizedLeverageRatio) {\n', '            // If ETH reward is below the balance on this contract, then return ETH balance on contract instead\n', '            return etherReward < address(this).balance ? etherReward : address(this).balance;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Helper that checks if conditions are met for rebalance or ripcord. Returns an enum with 0 = no rebalance, 1 = call rebalance(), 2 = call ripcord()\n', '     *\n', '     * return ShouldRebalance         Enum detailing whether to rebalance, ripcord or no action\n', '     */\n', '    function shouldRebalance() external view returns(ShouldRebalance) {\n', '        uint256 currentLeverageRatio = getCurrentLeverageRatio();\n', '\n', '        // Check TWAP states first for ripcord and regular rebalances\n', '        if (twapLeverageRatio != 0) {\n', '            // Check incentivized cooldown period has elapsed for ripcord\n', '            if (\n', '                currentLeverageRatio >= incentivizedLeverageRatio\n', '                && lastTradeTimestamp.add(incentivizedTwapCooldownPeriod) < block.timestamp\n', '            ) {\n', '                return ShouldRebalance.RIPCORD;\n', '            }\n', '\n', '            // Check cooldown period has elapsed for rebalance\n', '            if (\n', '                currentLeverageRatio < incentivizedLeverageRatio\n', '                && lastTradeTimestamp.add(twapCooldownPeriod) < block.timestamp\n', '            ) {\n', '                return ShouldRebalance.REBALANCE;\n', '            }\n', '        } else {\n', '            // If not TWAP, then check that current leverage is above ripcord threshold\n', '            if (currentLeverageRatio >= incentivizedLeverageRatio) {\n', '                return ShouldRebalance.RIPCORD;\n', '            }\n', '\n', '            // If not TWAP, then check that either rebalance interval has elapsed, current leverage is above max or current leverage is below min\n', '            if (\n', '                block.timestamp.sub(lastTradeTimestamp) > rebalanceInterval\n', '                || currentLeverageRatio > maxLeverageRatio\n', '                || currentLeverageRatio < minLeverageRatio\n', '            ) {\n', '                return ShouldRebalance.REBALANCE;\n', '            }\n', '        }\n', '\n', '        // If none of the above conditions are satisfied, then should not rebalance\n', '        return ShouldRebalance.NONE;\n', '    }\n', '\n', '    /* ============ Internal Functions ============ */\n', '\n', '    /**\n', '     * Calculate notional rebalance quantity, whether to chunk rebalance based on max trade size and max borrow. Invoke lever on CompoundLeverageModule.\n', '     * All state update on this contract will be at the end in the updateTradeState function. The new leverage ratio will be stored as the TWAP leverage\n', '     * ratio if the chunk size is not equal to total notional and new leverage ratio is not equal to the existing TWAP leverage ratio. If chunk size is\n', '     * the same as calculated total notional, then clear the TWAP leverage ratio state.\n', '     */\n', '    function _lever(\n', '        uint256 _currentLeverageRatio,\n', '        uint256 _newLeverageRatio,\n', '        ActionInfo memory _actionInfo\n', '    )\n', '        internal\n', '    {\n', '        // Get total amount of collateral that needs to be rebalanced\n', '        uint256 totalRebalanceNotional = _newLeverageRatio\n', '            .sub(_currentLeverageRatio)\n', '            .preciseDiv(_currentLeverageRatio)\n', '            .preciseMul(_actionInfo.collateralBalance);\n', '\n', '        uint256 maxBorrow = _calculateMaxBorrowCollateral(_actionInfo, true);\n', '\n', '        uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), twapMaxTradeSize);\n', '\n', '        uint256 collateralRebalanceUnits = chunkRebalanceNotional.preciseDiv(_actionInfo.setTotalSupply);\n', '\n', '        uint256 borrowUnits = _calculateBorrowUnits(collateralRebalanceUnits, _actionInfo);\n', '\n', '        uint256 minReceiveUnits = _calculateMinCollateralReceiveUnits(collateralRebalanceUnits);\n', '\n', '        bytes memory leverCallData = abi.encodeWithSignature(\n', '            "lever(address,address,address,uint256,uint256,string,bytes)",\n', '            address(setToken),\n', '            borrowAsset,\n', '            collateralAsset,\n', '            borrowUnits,\n', '            minReceiveUnits,\n', '            exchangeName,\n', '            exchangeData\n', '        );\n', '\n', '        invokeManager(address(leverageModule), leverCallData);\n', '\n', '        _updateTradeState(chunkRebalanceNotional, totalRebalanceNotional, _newLeverageRatio);\n', '    }\n', '\n', '    /**\n', '     * Calculate notional rebalance quantity, whether to chunk rebalance based on max trade size and max borrow. Invoke delever on CompoundLeverageModule.\n', '     * For ripcord, the slippage tolerance, and TWAP max trade size use the incentivized parameters.\n', '     */\n', '    function _delever(\n', '        uint256 _currentLeverageRatio,\n', '        uint256 _newLeverageRatio,\n', '        ActionInfo memory _actionInfo,\n', '        uint256 _slippageTolerance,\n', '        uint256 _twapMaxTradeSize\n', '    )\n', '        internal\n', '    {\n', '        // Get total amount of collateral that needs to be rebalanced\n', '        uint256 totalRebalanceNotional = _currentLeverageRatio\n', '            .sub(_newLeverageRatio)\n', '            .preciseDiv(_currentLeverageRatio)\n', '            .preciseMul(_actionInfo.collateralBalance);\n', '\n', '        uint256 maxBorrow = _calculateMaxBorrowCollateral(_actionInfo, false);\n', '\n', '        uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), _twapMaxTradeSize);\n', '\n', '        uint256 collateralRebalanceUnits = chunkRebalanceNotional.preciseDiv(_actionInfo.setTotalSupply);\n', '\n', '        uint256 minRepayUnits = _calculateMinRepayUnits(collateralRebalanceUnits, _slippageTolerance, _actionInfo);\n', '\n', '        bytes memory deleverCallData = abi.encodeWithSignature(\n', '            "delever(address,address,address,uint256,uint256,string,bytes)",\n', '            address(setToken),\n', '            collateralAsset,\n', '            borrowAsset,\n', '            collateralRebalanceUnits,\n', '            minRepayUnits,\n', '            exchangeName,\n', '            exchangeData\n', '        );\n', '\n', '        invokeManager(address(leverageModule), deleverCallData);\n', '\n', '        _updateTradeState(chunkRebalanceNotional, totalRebalanceNotional, _newLeverageRatio);\n', '    }\n', '\n', '    /**\n', '     * If in the midst of a TWAP rebalance (twapLeverageRatio is nonzero), check if current leverage ratio has move advantageously\n', '     * and update state and skip rest of trade execution. For levering (twapLeverageRatio < targetLeverageRatio), check if the current\n', '     * leverage ratio surpasses the stored TWAP leverage ratio. For delever (twapLeverageRatio > targetLeverageRatio), check if the\n', '     * current leverage ratio has dropped below the stored TWAP leverage ratio. In both cases, update the trade state and return true.\n', '     *\n', '     * return bool          Boolean indicating if we should skip the rest of the rebalance execution\n', '     */\n', '    function _updateStateAndExitIfAdvantageous(uint256 _currentLeverageRatio) internal returns (bool) {\n', '        if (\n', '            (twapLeverageRatio < targetLeverageRatio && _currentLeverageRatio >= twapLeverageRatio) \n', '            || (twapLeverageRatio > targetLeverageRatio && _currentLeverageRatio <= twapLeverageRatio)\n', '        ) {\n', '            // Update trade timestamp and delete TWAP leverage ratio. Setting chunk and total rebalance notional to 0 will delete\n', '            // TWAP state\n', '            _updateTradeState(0, 0, 0);\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Update state on this strategy adapter to track last trade timestamp and whether to clear TWAP leverage ratio or store new TWAP\n', '     * leverage ratio. There are 3 cases to consider:\n', '     * - End TWAP / regular rebalance: if chunk size is equal to total notional, then rebalances are not chunked and clear TWAP state.\n', '     * - Start TWAP: If chunk size is different from total notional and the new leverage ratio is not already stored, then set TWAP ratio.\n', '     * - Continue TWAP: If chunk size is different from total notional, and new leverage ratio is already stored, then do not set the new \n', '     * TWAP ratio.\n', '     */\n', '    function _updateTradeState(\n', '        uint256 _chunkRebalanceNotional,\n', '        uint256 _totalRebalanceNotional,\n', '        uint256 _newLeverageRatio\n', '    )\n', '        internal\n', '    {\n', '        lastTradeTimestamp = block.timestamp;\n', '\n', '        // If the chunk size is equal to the total notional meaning that rebalances are not chunked, then clear TWAP state.\n', '        if (_chunkRebalanceNotional == _totalRebalanceNotional) {\n', '            delete twapLeverageRatio;\n', '        }\n', '\n', '        // If currently in the midst of TWAP, the new leverage ratio will already have been set to the twapLeverageRatio \n', '        // in the rebalance() function and this check will be skipped.\n', '        if(_chunkRebalanceNotional != _totalRebalanceNotional && _newLeverageRatio != twapLeverageRatio) {\n', '            twapLeverageRatio = _newLeverageRatio;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Transfer ETH reward to caller of the ripcord function. If the ETH balance on this contract is less than required \n', '     * incentive quantity, then transfer contract balance instead to prevent reverts.\n', '     */\n', '    function _transferEtherRewardToCaller(uint256 _etherReward) internal {\n', '        _etherReward < address(this).balance ? msg.sender.transfer(_etherReward) : msg.sender.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * Create the action info struct to be used in internal functions\n', '     *\n', '     * return ActionInfo                Struct containing data used by internal lever and delever functions\n', '     */\n', '    function _createActionInfo() internal view returns(ActionInfo memory) {\n', '        ActionInfo memory rebalanceInfo;\n', '\n', '        rebalanceInfo.collateralPrice = priceOracle.getUnderlyingPrice(address(targetCollateralCToken));\n', '        rebalanceInfo.borrowPrice = priceOracle.getUnderlyingPrice(address(targetBorrowCToken));\n', '\n', '        // Calculate stored exchange rate which does not trigger a state update\n', '        uint256 cTokenBalance = targetCollateralCToken.balanceOf(address(setToken));\n', '        rebalanceInfo.collateralBalance = cTokenBalance.preciseMul(targetCollateralCToken.exchangeRateStored());\n', '        rebalanceInfo.borrowBalance = targetBorrowCToken.borrowBalanceStored(address(setToken));\n', '        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance).preciseDiv(10 ** collateralAssetDecimals);\n', '        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance).preciseDiv(10 ** borrowAssetDecimals);\n', '        rebalanceInfo.setTotalSupply = setToken.totalSupply();\n', '\n', '        return rebalanceInfo;\n', '    }\n', '\n', '    /**\n', '     * Calculate the new leverage ratio using the flexible leverage methodology. The methodology reduces the size of each rebalance by weighting\n', '     * the current leverage ratio against the target leverage ratio by the recentering speed percentage. The lower the recentering speed, the slower\n', '     * the leverage token will move towards the target leverage each rebalance.\n', '     *\n', '     * return uint256          New leverage ratio based on the flexible leverage methodology\n', '     */\n', '    function _calculateNewLeverageRatio(uint256 _currentLeverageRatio) internal view returns(uint256) {\n', '        // CLRt+1 = max(MINLR, min(MAXLR, CLRt * (1 - RS) + TLR * RS))\n', '        uint256 a = targetLeverageRatio.preciseMul(recenteringSpeed);\n', '        uint256 b = PreciseUnitMath.preciseUnit().sub(recenteringSpeed).preciseMul(_currentLeverageRatio);\n', '        uint256 c = a.add(b);\n', '        uint256 d = Math.min(c, maxLeverageRatio);\n', '        return Math.max(minLeverageRatio, d);\n', '    }\n', '\n', '    /**\n', '     * Calculate the max borrow / repay amount allowed in collateral units for lever / delever. This is due to overcollateralization requirements on\n', '     * assets deposited in lending protocols for borrowing.\n', '     * \n', '     * For lever, max borrow is calculated as:\n', '     * (Net borrow limit in USD - existing borrow value in USD) / collateral asset price adjusted for decimals\n', '     *\n', '     * For delever, max borrow is calculated as:\n', '     * Collateral balance in base units * (net borrow limit in USD - existing borrow value in USD) / net borrow limit in USD\n', '     *\n', '     * Net borrow limit is calculated as:\n', '     * The collateral value in USD * Compound collateral factor * (1 - unutilized leverage %)\n', '     *\n', '     * return uint256          Max borrow notional denominated in collateral asset\n', '     */\n', '    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n', '        // Retrieve collateral factor which is the % increase in borrow limit in precise units (75% = 75 * 1e16)\n', '        ( , uint256 collateralFactorMantissa, ) = comptroller.markets(address(targetCollateralCToken));\n', '\n', '        uint256 netBorrowLimit = _actionInfo.collateralValue\n', '            .preciseMul(collateralFactorMantissa)\n', '            .preciseMul(PreciseUnitMath.preciseUnit().sub(unutilizedLeveragePercentage));\n', '\n', '        if (_isLever) {\n', '            return netBorrowLimit\n', '                .sub(_actionInfo.borrowValue)\n', '                .preciseDiv(_actionInfo.collateralPrice)\n', '                .preciseMul(10 ** collateralAssetDecimals);\n', '        } else {\n', '            return _actionInfo.collateralBalance\n', '                .preciseMul(netBorrowLimit.sub(_actionInfo.borrowValue))\n', '                .preciseDiv(netBorrowLimit);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Derive the borrow units for lever. The units are calculated by the collateral units multiplied by collateral / borrow asset price adjusted\n', '     * for decimals.\n', '     *\n', '     * return uint256           Position units to borrow\n', '     */\n', '    function _calculateBorrowUnits(uint256 _collateralRebalanceUnits, ActionInfo memory _actionInfo) internal view returns (uint256) {\n', '        uint256 pairPrice = _actionInfo.collateralPrice.preciseDiv(_actionInfo.borrowPrice);\n', '        return _collateralRebalanceUnits\n', '            .preciseDiv(10 ** collateralAssetDecimals)\n', '            .preciseMul(pairPrice)\n', '            .preciseMul(10 ** borrowAssetDecimals);\n', '    }\n', '\n', '    /**\n', '     * Calculate the min receive units in collateral units for lever. Units are calculated as target collateral rebalance units multiplied by slippage tolerance\n', '     *\n', '     * return uint256           Min position units to receive after lever trade\n', '     */\n', '    function _calculateMinCollateralReceiveUnits(uint256 _collateralRebalanceUnits) internal view returns (uint256) {\n', '        return _collateralRebalanceUnits.preciseMul(PreciseUnitMath.preciseUnit().sub(slippageTolerance));\n', '    }\n', '\n', '    /**\n', '     * Derive the min repay units from collateral units for delever. Units are calculated as target collateral rebalance units multiplied by slippage tolerance\n', '     * and pair price (collateral oracle price / borrow oracle price) adjusted for decimals.\n', '     *\n', '     * return uint256           Min position units to repay in borrow asset\n', '     */\n', '    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal view returns (uint256) {\n', '        uint256 pairPrice = _actionInfo.collateralPrice.preciseDiv(_actionInfo.borrowPrice);\n', '\n', '        return _collateralRebalanceUnits\n', '            .preciseDiv(10 ** collateralAssetDecimals)\n', '            .preciseMul(pairPrice)\n', '            .preciseMul(10 ** borrowAssetDecimals)\n', '            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n', '    }\n', '\n', '    /**\n', '     * Calculate the current leverage ratio given a valuation of the collateral and borrow asset, which is calculated as collateral USD valuation / SetToken USD valuation\n', '     *\n', '     * return uint256            Current leverage ratio\n', '     */\n', '    function _calculateCurrentLeverageRatio(\n', '        uint256 _collateralValue,\n', '        uint256 _borrowValue\n', '    )\n', '        internal\n', '        pure\n', '        returns(uint256)\n', '    {\n', '        return _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n', '    }\n', '\n', '    /**\n', '     * Determine if passed address is allowed to call trade. If anyoneTrade set to true anyone can call otherwise needs to be approved.\n', '     *\n', '     * return bool              Boolean indicating if caller is allowed trader\n', '     */\n', '    function _isAllowedTrader(address _caller) internal view virtual returns (bool) {\n', '        return anyoneTrade || tradeAllowList[_caller];\n', '    }\n', '\n', '}']