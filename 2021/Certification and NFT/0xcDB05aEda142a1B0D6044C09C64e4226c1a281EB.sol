['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-13\n', '*/\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'abstract contract StructLike {\n', '    function val(uint256 _id) virtual public view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @title LinkedList (Structured Link List)\n', ' * @author Vittorio Minacori (https://github.com/vittominacori)\n', ' * @dev A utility library for using sorted linked list data structures in your Solidity project.\n', ' */\n', 'library LinkedList {\n', '\n', '    uint256 private constant NULL = 0;\n', '    uint256 private constant HEAD = 0;\n', '\n', '    bool private constant PREV = false;\n', '    bool private constant NEXT = true;\n', '\n', '    struct List {\n', '        mapping(uint256 => mapping(bool => uint256)) list;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the list exists\n', '     * @param self stored linked list from contract\n', '     * @return bool true if list exists, false otherwise\n', '     */\n', '    function isList(List storage self) internal view returns (bool) {\n', '        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n', '        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if the node exists\n', '     * @param self stored linked list from contract\n', '     * @param _node a node to search for\n', '     * @return bool true if node exists, false otherwise\n', '     */\n', '    function isNode(List storage self, uint256 _node) internal view returns (bool) {\n', '        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\n', '            if (self.list[HEAD][NEXT] == _node) {\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of elements in the list\n', '     * @param self stored linked list from contract\n', '     * @return uint256\n', '     */\n', '    function range(List storage self) internal view returns (uint256) {\n', '        uint256 i;\n', '        uint256 num;\n', '        (, i) = adj(self, HEAD, NEXT);\n', '        while (i != HEAD) {\n', '            (, i) = adj(self, i, NEXT);\n', '            num++;\n', '        }\n', '        return num;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the links of a node as a tuple\n', '     * @param self stored linked list from contract\n', '     * @param _node id of the node to get\n', '     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\n', '     */\n', '    function node(List storage self, uint256 _node) internal view returns (bool, uint256, uint256) {\n', '        if (!isNode(self, _node)) {\n', '            return (false, 0, 0);\n', '        } else {\n', '            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the link of a node `_node` in direction `_direction`.\n', '     * @param self stored linked list from contract\n', '     * @param _node id of the node to step from\n', '     * @param _direction direction to step in\n', '     * @return bool, uint256 true if node exists or false otherwise, node in _direction\n', '     */\n', '    function adj(List storage self, uint256 _node, bool _direction) internal view returns (bool, uint256) {\n', '        if (!isNode(self, _node)) {\n', '            return (false, 0);\n', '        } else {\n', '            return (true, self.list[_node][_direction]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the link of a node `_node` in direction `NEXT`.\n', '     * @param self stored linked list from contract\n', '     * @param _node id of the node to step from\n', '     * @return bool, uint256 true if node exists or false otherwise, next node\n', '     */\n', '    function next(List storage self, uint256 _node) internal view returns (bool, uint256) {\n', '        return adj(self, _node, NEXT);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the link of a node `_node` in direction `PREV`.\n', '     * @param self stored linked list from contract\n', '     * @param _node id of the node to step from\n', '     * @return bool, uint256 true if node exists or false otherwise, previous node\n', '     */\n', '    function prev(List storage self, uint256 _node) internal view returns (bool, uint256) {\n', '        return adj(self, _node, PREV);\n', '    }\n', '\n', '    /**\n', '     * @dev Can be used before `insert` to build an ordered list.\n', '     * @dev Get the node and then `back` or `face` basing on your list order.\n', '     * @dev If you want to order basing on other than `structure.val()` override this function\n', '     * @param self stored linked list from contract\n', '     * @param _struct the structure instance\n', '     * @param _val value to seek\n', '     * @return uint256 next node with a value less than StructLike(_struct).val(next_)\n', '     */\n', '    function sort(List storage self, address _struct, uint256 _val) internal view returns (uint256) {\n', '        if (range(self) == 0) {\n', '            return 0;\n', '        }\n', '        bool exists;\n', '        uint256 next_;\n', '        (exists, next_) = adj(self, HEAD, NEXT);\n', '        while ((next_ != 0) && ((_val < StructLike(_struct).val(next_)) != NEXT)) {\n', '            next_ = self.list[next_][NEXT];\n', '        }\n', '        return next_;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates a bidirectional link between two nodes on direction `_direction`\n', '     * @param self stored linked list from contract\n', '     * @param _node first node for linking\n', '     * @param _link  node to link to in the _direction\n', '     */\n', '    function form(List storage self, uint256 _node, uint256 _link, bool _dir) internal {\n', '        self.list[_link][!_dir] = _node;\n', '        self.list[_node][_dir] = _link;\n', '    }\n', '\n', '    /**\n', '     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n', '     * @param self stored linked list from contract\n', '     * @param _node existing node\n', '     * @param _new  new node to insert\n', '     * @param _direction direction to insert node in\n', '     * @return bool true if success, false otherwise\n', '     */\n', '    function insert(List storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\n', '        if (!isNode(self, _new) && isNode(self, _node)) {\n', '            uint256 c = self.list[_node][_direction];\n', '            form(self, _node, _new, _direction);\n', '            form(self, _new, c, _direction);\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Insert node `_new` beside existing node `_node` in direction `NEXT`.\n', '     * @param self stored linked list from contract\n', '     * @param _node existing node\n', '     * @param _new  new node to insert\n', '     * @return bool true if success, false otherwise\n', '     */\n', '    function face(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\n', '        return insert(self, _node, _new, NEXT);\n', '    }\n', '\n', '    /**\n', '     * @dev Insert node `_new` beside existing node `_node` in direction `PREV`.\n', '     * @param self stored linked list from contract\n', '     * @param _node existing node\n', '     * @param _new  new node to insert\n', '     * @return bool true if success, false otherwise\n', '     */\n', '    function back(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\n', '        return insert(self, _node, _new, PREV);\n', '    }\n', '\n', '    /**\n', '     * @dev Removes an entry from the linked list\n', '     * @param self stored linked list from contract\n', '     * @param _node node to remove from the list\n', '     * @return uint256 the removed node\n', '     */\n', '    function del(List storage self, uint256 _node) internal returns (uint256) {\n', '        if ((_node == NULL) || (!isNode(self, _node))) {\n', '            return 0;\n', '        }\n', '        form(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\n', '        delete self.list[_node][PREV];\n', '        delete self.list[_node][NEXT];\n', '        return _node;\n', '    }\n', '\n', '    /**\n', '     * @dev Pushes an entry to the head or tail of the linked list\n', '     * @param self stored linked list from contract\n', '     * @param _node new entry to push to the head\n', '     * @param _direction push to the head (NEXT) or tail (PREV)\n', '     * @return bool true if success, false otherwise\n', '     */\n', '    function push(List storage self, uint256 _node, bool _direction) internal returns (bool) {\n', '        return insert(self, HEAD, _node, _direction);\n', '    }\n', '\n', '    /**\n', '     * @dev Pops the first entry from the linked list\n', '     * @param self stored linked list from contract\n', '     * @param _direction pop from the head (NEXT) or the tail (PREV)\n', '     * @return uint256 the removed node\n', '     */\n', '    function pop(List storage self, bool _direction) internal returns (uint256) {\n', '        bool exists;\n', '        uint256 adj_;\n', '        (exists, adj_) = adj(self, HEAD, _direction);\n', '        return del(self, adj_);\n', '    }\n', '}\n', '\n', 'abstract contract SAFEEngineLike {\n', '    function collateralTypes(bytes32) virtual public view returns (\n', '        uint256 debtAmount,       // [wad]\n', '        uint256 accumulatedRate   // [ray]\n', '    );\n', '    function updateAccumulatedRate(bytes32,address,int256) virtual external;\n', '    function coinBalance(address) virtual public view returns (uint256);\n', '}\n', '\n', 'contract TaxCollector {\n', '    using LinkedList for LinkedList.List;\n', '\n', '    // --- Auth ---\n', '    mapping (address => uint256) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "TaxCollector/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event InitializeCollateralType(bytes32 collateralType);\n', '    event ModifyParameters(\n', '      bytes32 collateralType,\n', '      bytes32 parameter,\n', '      uint256 data\n', '    );\n', '    event ModifyParameters(bytes32 parameter, uint256 data);\n', '    event ModifyParameters(bytes32 parameter, address data);\n', '    event ModifyParameters(\n', '      bytes32 collateralType,\n', '      uint256 position,\n', '      uint256 val\n', '    );\n', '    event ModifyParameters(\n', '      bytes32 collateralType,\n', '      uint256 position,\n', '      uint256 taxPercentage,\n', '      address receiverAccount\n', '    );\n', '    event AddSecondaryReceiver(\n', '      bytes32 indexed collateralType,\n', '      uint256 secondaryReceiverNonce,\n', '      uint256 latestSecondaryReceiver,\n', '      uint256 secondaryReceiverAllotedTax,\n', '      uint256 secondaryReceiverRevenueSources\n', '    );\n', '    event ModifySecondaryReceiver(\n', '      bytes32 indexed collateralType,\n', '      uint256 secondaryReceiverNonce,\n', '      uint256 latestSecondaryReceiver,\n', '      uint256 secondaryReceiverAllotedTax,\n', '      uint256 secondaryReceiverRevenueSources\n', '    );\n', '    event CollectTax(bytes32 indexed collateralType, uint256 latestAccumulatedRate, int256 deltaRate);\n', '    event DistributeTax(bytes32 indexed collateralType, address indexed target, int256 taxCut);\n', '\n', '    // --- Data ---\n', '    struct CollateralType {\n', '        // Per second borrow rate for this specific collateral type\n', '        uint256 stabilityFee;\n', '        // When SF was last collected for this collateral type\n', '        uint256 updateTime;\n', '    }\n', '    // SF receiver\n', '    struct TaxReceiver {\n', '        // Whether this receiver can accept a negative rate (taking SF from it)\n', '        uint256 canTakeBackTax;                                                 // [bool]\n', '        // Percentage of SF allocated to this receiver\n', '        uint256 taxPercentage;                                                  // [ray%]\n', '    }\n', '\n', '    // Data about each collateral type\n', '    mapping (bytes32 => CollateralType)                  public collateralTypes;\n', "    // Percentage of each collateral's SF that goes to other addresses apart from the primary receiver\n", '    mapping (bytes32 => uint256)                         public secondaryReceiverAllotedTax;              // [%ray]\n', '    // Whether an address is already used for a tax receiver\n', '    mapping (address => uint256)                         public usedSecondaryReceiver;                    // [bool]\n', '    // Address associated to each tax receiver index\n', '    mapping (uint256 => address)                         public secondaryReceiverAccounts;\n', '    // How many collateral types send SF to a specific tax receiver\n', '    mapping (address => uint256)                         public secondaryReceiverRevenueSources;\n', '    // Tax receiver data\n', '    mapping (bytes32 => mapping(uint256 => TaxReceiver)) public secondaryTaxReceivers;\n', '\n', '    address    public primaryTaxReceiver;\n', '    // Base stability fee charged to all collateral types\n', '    uint256    public globalStabilityFee;                                                                 // [ray%]\n', '    // Number of secondary tax receivers ever added\n', '    uint256    public secondaryReceiverNonce;\n', '    // Max number of secondarytax receivers a collateral type can have\n', '    uint256    public maxSecondaryReceivers;\n', '    // Latest secondary tax receiver that still has at least one revenue source\n', '    uint256    public latestSecondaryReceiver;\n', '\n', '    // All collateral types\n', '    bytes32[]        public   collateralList;\n', '    // Linked list with tax receiver data\n', '    LinkedList.List  internal secondaryReceiverList;\n', '\n', '    SAFEEngineLike public safeEngine;\n', '\n', '    // --- Init ---\n', '    constructor(address safeEngine_) public {\n', '        authorizedAccounts[msg.sender] = 1;\n', '        safeEngine = SAFEEngineLike(safeEngine_);\n', '        emit AddAuthorization(msg.sender);\n', '    }\n', '\n', '    // --- Math ---\n', '    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\n', '      assembly {\n', '        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\n', '        default {\n', '          switch mod(n, 2) case 0 { z := b } default { z := x }\n', '          let half := div(b, 2)  // for rounding.\n', '          for { n := div(n, 2) } n { n := div(n,2) } {\n', '            let xx := mul(x, x)\n', '            if iszero(eq(div(xx, x), x)) { revert(0,0) }\n', '            let xxRound := add(xx, half)\n', '            if lt(xxRound, xx) { revert(0,0) }\n', '            x := div(xxRound, b)\n', '            if mod(n,2) {\n', '              let zx := mul(z, x)\n', '              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n', '              let zxRound := add(zx, half)\n', '              if lt(zxRound, zx) { revert(0,0) }\n', '              z := div(zxRound, b)\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    uint256 constant RAY           = 10 ** 27;\n', '    uint256 constant WHOLE_TAX_CUT = 10 ** 29;\n', '    uint256 constant ONE           = 1;\n', '    int256  constant INT256_MIN    = -2**255;\n', '\n', '    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x + y;\n', '        require(z >= x, "TaxCollector/add-uint-uint-overflow");\n', '    }\n', '    function addition(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x + y;\n', '        if (y <= 0) require(z <= x, "TaxCollector/add-int-int-underflow");\n', '        if (y  > 0) require(z > x, "TaxCollector/add-int-int-overflow");\n', '    }\n', '    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "TaxCollector/sub-uint-uint-underflow");\n', '    }\n', '    function subtract(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x - y;\n', '        require(y <= 0 || z <= x, "TaxCollector/sub-int-int-underflow");\n', '        require(y >= 0 || z >= x, "TaxCollector/sub-int-int-overflow");\n', '    }\n', '    function deduct(uint256 x, uint256 y) internal pure returns (int256 z) {\n', '        z = int256(x) - int256(y);\n', '        require(int256(x) >= 0 && int256(y) >= 0, "TaxCollector/ded-invalid-numbers");\n', '    }\n', '    function multiply(uint256 x, int256 y) internal pure returns (int256 z) {\n', '        z = int256(x) * y;\n', '        require(int256(x) >= 0, "TaxCollector/mul-uint-int-invalid-x");\n', '        require(y == 0 || z / y == int256(x), "TaxCollector/mul-uint-int-overflow");\n', '    }\n', '    function multiply(int256 x, int256 y) internal pure returns (int256 z) {\n', '        require(!both(x == -1, y == INT256_MIN), "TaxCollector/mul-int-int-overflow");\n', '        require(y == 0 || (z = x * y) / y == x, "TaxCollector/mul-int-int-invalid");\n', '    }\n', '    function rmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x * y;\n', '        require(y == 0 || z / y == x, "TaxCollector/rmul-overflow");\n', '        z = z / RAY;\n', '    }\n', '\n', '    // --- Boolean Logic ---\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '\n', '    // --- Administration ---\n', '    /**\n', '     * @notice Initialize a brand new collateral type\n', '     * @param collateralType Collateral type name (e.g ETH-A, TBTC-B)\n', '     */\n', '    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\n', '        CollateralType storage collateralType_ = collateralTypes[collateralType];\n', '        require(collateralType_.stabilityFee == 0, "TaxCollector/collateral-type-already-init");\n', '        collateralType_.stabilityFee = RAY;\n', '        collateralType_.updateTime   = now;\n', '        collateralList.push(collateralType);\n', '        emit InitializeCollateralType(collateralType);\n', '    }\n', '    /**\n', '     * @notice Modify collateral specific uint256 params\n', "     * @param collateralType Collateral type who's parameter is modified\n", '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(\n', '        bytes32 collateralType,\n', '        bytes32 parameter,\n', '        uint256 data\n', '    ) external isAuthorized {\n', '        require(now == collateralTypes[collateralType].updateTime, "TaxCollector/update-time-not-now");\n', '        if (parameter == "stabilityFee") collateralTypes[collateralType].stabilityFee = data;\n', '        else revert("TaxCollector/modify-unrecognized-param");\n', '        emit ModifyParameters(\n', '          collateralType,\n', '          parameter,\n', '          data\n', '        );\n', '    }\n', '    /**\n', '     * @notice Modify general uint256 params\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n', '        if (parameter == "globalStabilityFee") globalStabilityFee = data;\n', '        else if (parameter == "maxSecondaryReceivers") maxSecondaryReceivers = data;\n', '        else revert("TaxCollector/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    /**\n', '     * @notice Modify general address params\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n', '        require(data != address(0), "TaxCollector/null-data");\n', '        if (parameter == "primaryTaxReceiver") primaryTaxReceiver = data;\n', '        else revert("TaxCollector/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    /**\n', '     * @notice Set whether a tax receiver can incur negative fees\n', '     * @param collateralType Collateral type giving fees to the tax receiver\n', '     * @param position Receiver position in the list\n', '     * @param val Value that specifies whether a tax receiver can incur negative rates\n', '     */\n', '    function modifyParameters(\n', '        bytes32 collateralType,\n', '        uint256 position,\n', '        uint256 val\n', '    ) external isAuthorized {\n', '        if (both(secondaryReceiverList.isNode(position), secondaryTaxReceivers[collateralType][position].taxPercentage > 0)) {\n', '            secondaryTaxReceivers[collateralType][position].canTakeBackTax = val;\n', '        }\n', '        else revert("TaxCollector/unknown-tax-receiver");\n', '        emit ModifyParameters(\n', '          collateralType,\n', '          position,\n', '          val\n', '        );\n', '    }\n', '    /**\n', "     * @notice Create or modify a secondary tax receiver's data\n", '     * @param collateralType Collateral type that will give SF to the tax receiver\n', '     * @param position Receiver position in the list. Used to determine whether a new tax receiver is\n', '              created or an existing one is edited\n', '     * @param taxPercentage Percentage of SF offered to the tax receiver\n', '     * @param receiverAccount Receiver address\n', '     */\n', '    function modifyParameters(\n', '      bytes32 collateralType,\n', '      uint256 position,\n', '      uint256 taxPercentage,\n', '      address receiverAccount\n', '    ) external isAuthorized {\n', '        (!secondaryReceiverList.isNode(position)) ?\n', '          addSecondaryReceiver(collateralType, taxPercentage, receiverAccount) :\n', '          modifySecondaryReceiver(collateralType, position, taxPercentage);\n', '        emit ModifyParameters(\n', '          collateralType,\n', '          position,\n', '          taxPercentage,\n', '          receiverAccount\n', '        );\n', '    }\n', '\n', '    // --- Tax Receiver Utils ---\n', '    /**\n', '     * @notice Add a new secondary tax receiver\n', '     * @param collateralType Collateral type that will give SF to the tax receiver\n', '     * @param taxPercentage Percentage of SF offered to the tax receiver\n', '     * @param receiverAccount Tax receiver address\n', '     */\n', '    function addSecondaryReceiver(bytes32 collateralType, uint256 taxPercentage, address receiverAccount) internal {\n', '        require(receiverAccount != address(0), "TaxCollector/null-account");\n', '        require(receiverAccount != primaryTaxReceiver, "TaxCollector/primary-receiver-cannot-be-secondary");\n', '        require(taxPercentage > 0, "TaxCollector/null-sf");\n', '        require(usedSecondaryReceiver[receiverAccount] == 0, "TaxCollector/account-already-used");\n', '        require(addition(secondaryReceiversAmount(), ONE) <= maxSecondaryReceivers, "TaxCollector/exceeds-max-receiver-limit");\n', '        require(addition(secondaryReceiverAllotedTax[collateralType], taxPercentage) < WHOLE_TAX_CUT, "TaxCollector/tax-cut-exceeds-hundred");\n', '        secondaryReceiverNonce                                                       = addition(secondaryReceiverNonce, 1);\n', '        latestSecondaryReceiver                                                      = secondaryReceiverNonce;\n', '        usedSecondaryReceiver[receiverAccount]                                       = ONE;\n', '        secondaryReceiverAllotedTax[collateralType]                                  = addition(secondaryReceiverAllotedTax[collateralType], taxPercentage);\n', '        secondaryTaxReceivers[collateralType][latestSecondaryReceiver].taxPercentage = taxPercentage;\n', '        secondaryReceiverAccounts[latestSecondaryReceiver]                           = receiverAccount;\n', '        secondaryReceiverRevenueSources[receiverAccount]                             = ONE;\n', '        secondaryReceiverList.push(latestSecondaryReceiver, false);\n', '        emit AddSecondaryReceiver(\n', '          collateralType,\n', '          secondaryReceiverNonce,\n', '          latestSecondaryReceiver,\n', '          secondaryReceiverAllotedTax[collateralType],\n', '          secondaryReceiverRevenueSources[receiverAccount]\n', '        );\n', '    }\n', '    /**\n', "     * @notice Update a secondary tax receiver's data (add a new SF source or modify % of SF taken from a collateral type)\n", '     * @param collateralType Collateral type that will give SF to the tax receiver\n', "     * @param position Receiver's position in the tax receiver list\n", '     * @param taxPercentage Percentage of SF offered to the tax receiver (ray%)\n', '     */\n', '    function modifySecondaryReceiver(bytes32 collateralType, uint256 position, uint256 taxPercentage) internal {\n', '        if (taxPercentage == 0) {\n', '          secondaryReceiverAllotedTax[collateralType] = subtract(\n', '            secondaryReceiverAllotedTax[collateralType],\n', '            secondaryTaxReceivers[collateralType][position].taxPercentage\n', '          );\n', '\n', '          if (secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] == 1) {\n', '            if (position == latestSecondaryReceiver) {\n', '              (, uint256 prevReceiver) = secondaryReceiverList.prev(latestSecondaryReceiver);\n', '              latestSecondaryReceiver = prevReceiver;\n', '            }\n', '            secondaryReceiverList.del(position);\n', '            delete(usedSecondaryReceiver[secondaryReceiverAccounts[position]]);\n', '            delete(secondaryTaxReceivers[collateralType][position]);\n', '            delete(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]);\n', '            delete(secondaryReceiverAccounts[position]);\n', '          } else if (secondaryTaxReceivers[collateralType][position].taxPercentage > 0) {\n', '            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = subtract(secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]], 1);\n', '            delete(secondaryTaxReceivers[collateralType][position]);\n', '          }\n', '        } else {\n', '          uint256 secondaryReceiverAllotedTax_ = addition(\n', '            subtract(secondaryReceiverAllotedTax[collateralType], secondaryTaxReceivers[collateralType][position].taxPercentage),\n', '            taxPercentage\n', '          );\n', '          require(secondaryReceiverAllotedTax_ < WHOLE_TAX_CUT, "TaxCollector/tax-cut-too-big");\n', '          if (secondaryTaxReceivers[collateralType][position].taxPercentage == 0) {\n', '            secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]] = addition(\n', '              secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]],\n', '              1\n', '            );\n', '          }\n', '          secondaryReceiverAllotedTax[collateralType]                   = secondaryReceiverAllotedTax_;\n', '          secondaryTaxReceivers[collateralType][position].taxPercentage = taxPercentage;\n', '        }\n', '        emit ModifySecondaryReceiver(\n', '          collateralType,\n', '          secondaryReceiverNonce,\n', '          latestSecondaryReceiver,\n', '          secondaryReceiverAllotedTax[collateralType],\n', '          secondaryReceiverRevenueSources[secondaryReceiverAccounts[position]]\n', '        );\n', '    }\n', '\n', '    // --- Tax Collection Utils ---\n', '    /**\n', '     * @notice Check if multiple collateral types are up to date with taxation\n', '     */\n', '    function collectedManyTax(uint256 start, uint256 end) public view returns (bool ok) {\n', '        require(both(start <= end, end < collateralList.length), "TaxCollector/invalid-indexes");\n', '        for (uint256 i = start; i <= end; i++) {\n', '          if (now > collateralTypes[collateralList[i]].updateTime) {\n', '            ok = false;\n', '            return ok;\n', '          }\n', '        }\n', '        ok = true;\n', '    }\n', '    /**\n', "     * @notice Check how much SF will be charged (to collateral types between indexes 'start' and 'end'\n", '     *         in the collateralList) during the next taxation\n', '     * @param start Index in collateralList from which to start looping and calculating the tax outcome\n', '     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\n', '     */\n', '    function taxManyOutcome(uint256 start, uint256 end) public view returns (bool ok, int256 rad) {\n', '        require(both(start <= end, end < collateralList.length), "TaxCollector/invalid-indexes");\n', '        int256  primaryReceiverBalance = -int256(safeEngine.coinBalance(primaryTaxReceiver));\n', '        int256  deltaRate;\n', '        uint256 debtAmount;\n', '        for (uint256 i = start; i <= end; i++) {\n', '          if (now > collateralTypes[collateralList[i]].updateTime) {\n', '            (debtAmount, ) = safeEngine.collateralTypes(collateralList[i]);\n', '            (, deltaRate)  = taxSingleOutcome(collateralList[i]);\n', '            rad = addition(rad, multiply(debtAmount, deltaRate));\n', '          }\n', '        }\n', '        if (rad < 0) {\n', '          ok = (rad < primaryReceiverBalance) ? false : true;\n', '        } else {\n', '          ok = true;\n', '        }\n', '    }\n', '    /**\n', '     * @notice Get how much SF will be distributed after taxing a specific collateral type\n', '     * @param collateralType Collateral type to compute the taxation outcome for\n', '     * @return The newly accumulated rate as well as the delta between the new and the last accumulated rates\n', '     */\n', '    function taxSingleOutcome(bytes32 collateralType) public view returns (uint256, int256) {\n', '        (, uint256 lastAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n', '        uint256 newlyAccumulatedRate =\n', '          rmultiply(\n', '            rpow(\n', '              addition(\n', '                globalStabilityFee,\n', '                collateralTypes[collateralType].stabilityFee\n', '              ),\n', '              subtract(\n', '                now,\n', '                collateralTypes[collateralType].updateTime\n', '              ),\n', '            RAY),\n', '          lastAccumulatedRate);\n', '        return (newlyAccumulatedRate, deduct(newlyAccumulatedRate, lastAccumulatedRate));\n', '    }\n', '\n', '    // --- Tax Receiver Utils ---\n', '    /**\n', '     * @notice Get the secondary tax receiver list length\n', '     */\n', '    function secondaryReceiversAmount() public view returns (uint256) {\n', '        return secondaryReceiverList.range();\n', '    }\n', '    /**\n', '     * @notice Get the collateralList length\n', '     */\n', '    function collateralListLength() public view returns (uint256) {\n', '        return collateralList.length;\n', '    }\n', '    /**\n', '     * @notice Check if a tax receiver is at a certain position in the list\n', '     */\n', '    function isSecondaryReceiver(uint256 _receiver) public view returns (bool) {\n', '        if (_receiver == 0) return false;\n', '        return secondaryReceiverList.isNode(_receiver);\n', '    }\n', '\n', '    // --- Tax (Stability Fee) Collection ---\n', '    /**\n', '     * @notice Collect tax from multiple collateral types at once\n', '     * @param start Index in collateralList from which to start looping and calculating the tax outcome\n', '     * @param end Index in collateralList at which we stop looping and calculating the tax outcome\n', '     */\n', '    function taxMany(uint256 start, uint256 end) external {\n', '        require(both(start <= end, end < collateralList.length), "TaxCollector/invalid-indexes");\n', '        for (uint256 i = start; i <= end; i++) {\n', '            taxSingle(collateralList[i]);\n', '        }\n', '    }\n', '    /**\n', '     * @notice Collect tax from a single collateral type\n', '     * @param collateralType Collateral type to tax\n', '     */\n', '    function taxSingle(bytes32 collateralType) public returns (uint256) {\n', '        uint256 latestAccumulatedRate;\n', '        if (now <= collateralTypes[collateralType].updateTime) {\n', '          (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n', '          return latestAccumulatedRate;\n', '        }\n', '        (, int256 deltaRate) = taxSingleOutcome(collateralType);\n', '        // Check how much debt has been generated for collateralType\n', '        (uint256 debtAmount, ) = safeEngine.collateralTypes(collateralType);\n', '        splitTaxIncome(collateralType, debtAmount, deltaRate);\n', '        (, latestAccumulatedRate) = safeEngine.collateralTypes(collateralType);\n', '        collateralTypes[collateralType].updateTime = now;\n', '        emit CollectTax(collateralType, latestAccumulatedRate, deltaRate);\n', '        return latestAccumulatedRate;\n', '    }\n', '    /**\n', '     * @notice Split SF between all tax receivers\n', '     * @param collateralType Collateral type to distribute SF for\n', '     * @param deltaRate Difference between the last and the latest accumulate rates for the collateralType\n', '     */\n', '    function splitTaxIncome(bytes32 collateralType, uint256 debtAmount, int256 deltaRate) internal {\n', '        // Start looping from the latest tax receiver\n', '        uint256 currentSecondaryReceiver = latestSecondaryReceiver;\n', "        // While we still haven't gone through the entire tax receiver list\n", '        while (currentSecondaryReceiver > 0) {\n', '          // If the current tax receiver should receive SF from collateralType\n', '          if (secondaryTaxReceivers[collateralType][currentSecondaryReceiver].taxPercentage > 0) {\n', '            distributeTax(\n', '              collateralType,\n', '              secondaryReceiverAccounts[currentSecondaryReceiver],\n', '              currentSecondaryReceiver,\n', '              debtAmount,\n', '              deltaRate\n', '            );\n', '          }\n', '          // Continue looping\n', '          (, currentSecondaryReceiver) = secondaryReceiverList.prev(currentSecondaryReceiver);\n', '        }\n', '        // Distribute to primary receiver\n', '        distributeTax(collateralType, primaryTaxReceiver, uint256(-1), debtAmount, deltaRate);\n', '    }\n', '\n', '    /**\n', '     * @notice Give/withdraw SF from a tax receiver\n', '     * @param collateralType Collateral type to distribute SF for\n', '     * @param receiver Tax receiver address\n', '     * @param receiverListPosition Position of receiver in the secondaryReceiverList (if the receiver is secondary)\n', '     * @param debtAmount Total debt currently issued\n', '     * @param deltaRate Difference between the latest and the last accumulated rates for the collateralType\n', '     */\n', '    function distributeTax(\n', '        bytes32 collateralType,\n', '        address receiver,\n', '        uint256 receiverListPosition,\n', '        uint256 debtAmount,\n', '        int256 deltaRate\n', '    ) internal {\n', '        require(safeEngine.coinBalance(receiver) < 2**255, "TaxCollector/coin-balance-does-not-fit-into-int256");\n', '        // Check how many coins the receiver has and negate the value\n', '        int256 coinBalance   = -int256(safeEngine.coinBalance(receiver));\n', '        // Compute the % out of SF that should be allocated to the receiver\n', '        int256 currentTaxCut = (receiver == primaryTaxReceiver) ?\n', '          multiply(subtract(WHOLE_TAX_CUT, secondaryReceiverAllotedTax[collateralType]), deltaRate) / int256(WHOLE_TAX_CUT) :\n', '          multiply(int256(secondaryTaxReceivers[collateralType][receiverListPosition].taxPercentage), deltaRate) / int256(WHOLE_TAX_CUT);\n', '        /**\n', "            If SF is negative and a tax receiver doesn't have enough coins to absorb the loss,\n", '            compute a new tax cut that can be absorbed\n', '        **/\n', '        currentTaxCut  = (\n', '          both(multiply(debtAmount, currentTaxCut) < 0, coinBalance > multiply(debtAmount, currentTaxCut))\n', '        ) ? coinBalance / int256(debtAmount) : currentTaxCut;\n', '        /**\n', "          If the tax receiver's tax cut is not null and if the receiver accepts negative SF\n", '          offer/take SF to/from them\n', '        **/\n', '        if (currentTaxCut != 0) {\n', '          if (\n', '            either(\n', '              receiver == primaryTaxReceiver,\n', '              either(\n', '                deltaRate >= 0,\n', '                both(currentTaxCut < 0, secondaryTaxReceivers[collateralType][receiverListPosition].canTakeBackTax > 0)\n', '              )\n', '            )\n', '          ) {\n', '            safeEngine.updateAccumulatedRate(collateralType, receiver, currentTaxCut);\n', '            emit DistributeTax(collateralType, receiver, currentTaxCut);\n', '          }\n', '       }\n', '    }\n', '}']