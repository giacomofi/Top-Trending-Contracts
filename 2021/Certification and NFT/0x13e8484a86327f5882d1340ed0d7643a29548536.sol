['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-04\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IOwnable {\n', '  function manager() external view returns (address);\n', '\n', '  function renounceManagement() external;\n', '  \n', '  function pushManagement( address newOwner_ ) external;\n', '  \n', '  function pullManagement() external;\n', '}\n', '\n', 'contract Ownable is IOwnable {\n', '\n', '    address internal _owner;\n', '    address internal _newOwner;\n', '\n', '    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n', '    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipPushed( address(0), _owner );\n', '    }\n', '\n', '    function manager() public view override returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require( _owner == msg.sender, "Ownable: caller is not the owner" );\n', '        _;\n', '    }\n', '\n', '    function renounceManagement() public virtual override onlyManager() {\n', '        emit OwnershipPushed( _owner, address(0) );\n', '        _owner = address(0);\n', '    }\n', '\n', '    function pushManagement( address newOwner_ ) public virtual override onlyManager() {\n', '        require( newOwner_ != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipPushed( _owner, newOwner_ );\n', '        _newOwner = newOwner_;\n', '    }\n', '    \n', '    function pullManagement() public virtual override {\n', '        require( msg.sender == _newOwner, "Ownable: must be new owner to pull");\n', '        emit OwnershipPulled( _owner, _newOwner );\n', '        _owner = _newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function sqrrt(uint256 a) internal pure returns (uint c) {\n', '        if (a > 3) {\n', '            c = a;\n', '            uint b = add( div( a, 2), 1 );\n', '            while (b < c) {\n', '                c = b;\n', '                b = div( add( div( a, b ), b), 2 );\n', '            }\n', '        } else if (a != 0) {\n', '            c = 1;\n', '        }\n', '    }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addressToString(address _address) internal pure returns(string memory) {\n', '        bytes32 _bytes = bytes32(uint256(_address));\n', '        bytes memory HEX = "0123456789abcdef";\n', '        bytes memory _addr = new bytes(42);\n', '\n', "        _addr[0] = '0';\n", "        _addr[1] = 'x';\n", '\n', '        for(uint256 i = 0; i < 20; i++) {\n', '            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n', '            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n', '        }\n', '\n', '        return string(_addr);\n', '\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // TODO comment actual hash value.\n', '    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( "ERC20Token" );\n', '    \n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string internal _name;\n', '    \n', '    string internal _symbol;\n', '    \n', '    uint8 internal _decimals;\n', '\n', '    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account_, uint256 ammount_) internal virtual {\n', '        require(account_ != address(0), "ERC20: mint to the zero address");\n', '        _beforeTokenTransfer(address( this ), account_, ammount_);\n', '        _totalSupply = _totalSupply.add(ammount_);\n', '        _balances[account_] = _balances[account_].add(ammount_);\n', '        emit Transfer(address( this ), account_, ammount_);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n', '}\n', '\n', 'interface IERC2612Permit {\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '}\n', '\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Permit is ERC20, IERC2612Permit {\n', '    using Counters for Counters.Counter;\n', '\n', '    mapping(address => Counters.Counter) private _nonces;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    constructor() {\n', '        uint256 chainID;\n', '        assembly {\n', '            chainID := chainid()\n', '        }\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes("1")), // Version\n', '                chainID,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public virtual override {\n', '        require(block.timestamp <= deadline, "Permit: expired deadline");\n', '\n', '        bytes32 hashStruct =\n', '            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\n', '\n', '        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n', '\n', '        address signer = ecrecover(_hash, v, r, s);\n', '        require(signer != address(0) && signer == owner, "ZeroSwapPermit: Invalid signature");\n', '\n', '        _nonces[owner].increment();\n', '        _approve(owner, spender, amount);\n', '    }\n', '\n', '    function nonces(address owner) public view override returns (uint256) {\n', '        return _nonces[owner].current();\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library FullMath {\n', '    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n', '        uint256 mm = mulmod(x, y, uint256(-1));\n', '        l = x * y;\n', '        h = mm - l;\n', '        if (mm < l) h -= 1;\n', '    }\n', '\n', '    function fullDiv(\n', '        uint256 l,\n', '        uint256 h,\n', '        uint256 d\n', '    ) private pure returns (uint256) {\n', '        uint256 pow2 = d & -d;\n', '        d /= pow2;\n', '        l /= pow2;\n', '        l += h * ((-pow2) / pow2 + 1);\n', '        uint256 r = 1;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        return l * r;\n', '    }\n', '\n', '    function mulDiv(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 d\n', '    ) internal pure returns (uint256) {\n', '        (uint256 l, uint256 h) = fullMul(x, y);\n', '        uint256 mm = mulmod(x, y, d);\n', '        if (mm > l) h -= 1;\n', '        l -= mm;\n', "        require(h < d, 'FullMath::mulDiv: overflow');\n", '        return fullDiv(l, h, d);\n', '    }\n', '}\n', '\n', 'library FixedPoint {\n', '\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    struct uq144x112 {\n', '        uint256 _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint256 private constant Q112 = 0x10000000000000000000000000000;\n', '    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n', '\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '\n', '    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n', "        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n", '        if (numerator == 0) return FixedPoint.uq112x112(0);\n', '\n', '        if (numerator <= uint144(-1)) {\n', '            uint256 result = (numerator << RESOLUTION) / denominator;\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        } else {\n', '            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        }\n', '    }\n', '}\n', '\n', 'interface ITreasury {\n', '    function depositPrinciple( uint amount_ ) external returns ( bool );\n', '}\n', '\n', 'interface ICirculatingOHM {\n', '    function OHMCirculatingSupply() external view returns ( uint );\n', '}\n', '\n', 'interface IBondCalculator {\n', '    function valuation( address LP_, uint amount_ ) external view returns ( uint );\n', '    function markdown( address LP_ ) external view returns ( uint );\n', '}\n', '\n', 'contract OlympusBondDepository is Ownable {\n', '\n', '    using FixedPoint for *;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    struct Bond {\n', '        uint valueRemaining; // value of LP given\n', '        uint payoutRemaining; // OHM remaining to be paid\n', '        uint lastBlock; // Last interaction\n', '        uint vestingPeriod; // Blocks left to vest\n', '        uint pricePaid; // In DAI, for front end viewing\n', '    }\n', '    mapping( address => Bond ) public bondInfo; \n', '\n', '    // Bond terms\n', '    uint public controlVariable;\n', '    uint public vestingTerm;\n', '    uint public minimumPrice;\n', '    uint public DAOShare; \n', '    uint public maxPayoutPercent; //  compared to circulating supply, in hundreths. i.e. 50 = 0.5%\n', '\n', '    uint256 public totalDebt; // Total value of outstanding bonds\n', '\n', '    address public immutable OHM;\n', '    address public immutable LP;\n', '\n', '    address public immutable treasury;\n', '    address public immutable distributor;\n', '    address public immutable DAO;\n', '\n', '    address public immutable circulatingOHMContract; // calculates circulating supply\n', '    address public immutable bondCalculator;\n', '\n', '    constructor ( \n', '        address OHM_,\n', '        address LP_,\n', '        address treasury_, \n', '        address distributor_, \n', '        address DAO_, \n', '        address circulatingOHMContract_,\n', '        address bondCalculator_\n', '    ) {\n', '        require( OHM_ != address(0) );\n', '        OHM = OHM_;\n', '        require( LP_ != address(0) );\n', '        LP = LP_;\n', '        require( treasury_ != address(0) );\n', '        treasury = treasury_;\n', '        require( distributor_ != address(0) );\n', '        distributor = distributor_;\n', '        require( DAO_ != address(0) );\n', '        DAO = DAO_;\n', '        require( circulatingOHMContract_ != address(0) );\n', '        circulatingOHMContract = circulatingOHMContract_;\n', '        require( bondCalculator_ != address(0) );\n', '        bondCalculator = bondCalculator_;\n', '    }\n', '\n', '    /**\n', '        @notice set parameters of new bonds\n', '        @param controlVariable_ uint\n', '        @param vestingTerm_ uint\n', '        @param minPrice_ uint\n', '        @param maxPayout_ uint\n', '        @param DAOShare_ uint\n', '        @return bool\n', '     */\n', '    function setBondTerm( \n', '        uint controlVariable_, \n', '        uint vestingTerm_, \n', '        uint minPrice_,\n', '        uint maxPayout_,\n', '        uint DAOShare_\n', '    ) external onlyManager() returns ( bool ) {\n', '        controlVariable = controlVariable_;\n', '        vestingTerm = vestingTerm_;\n', '        minimumPrice = minPrice_;\n', '        maxPayoutPercent = maxPayout_;\n', '        DAOShare = DAOShare_;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice deposit bond\n', '        @param amount_ uint\n', '        @param maxPremium_ uint\n', '        @param depositor_ address\n', '        @return uint\n', '     */\n', '    function deposit( \n', '        uint amount_, \n', '        uint maxPremium_,\n', '        address depositor_\n', '    ) external returns ( uint ) {\n', '        return _deposit( amount_, maxPremium_, depositor_ );\n', '    }\n', '\n', '    function _deposit( \n', '        uint amount_, \n', '        uint maxPrice_,\n', '        address depositor_\n', '    ) internal returns ( uint ) {\n', '        require( depositor_ != address(0), "Invalid address" );\n', '        uint price = bondPriceInDAI(); // DAI price of bond (for depositor info)\n', '\n', '        require( maxPrice_ >= bondPrice(), "Slippage limit: more than max price" ); // slippage protection\n', '\n', '        uint value = IBondCalculator( bondCalculator ).valuation( LP, amount_ );\n', '        uint payout = payoutFor( value );\n', '\n', '        require( payout >= 10000000, "Bond too small" ); // must be > 0.01 OHM\n', '        require( payout <= maxPayout(), "Bond too large");\n', '\n', '        // Transfer in LP\n', '        IERC20( LP ).safeTransferFrom( msg.sender, address(this), amount_ );\n', '        // Deposit LP to mint OHM\n', '        IERC20( LP ).approve( address( treasury ), amount_ );\n', '        ITreasury( treasury ).depositPrinciple( amount_ );\n', '        \n', '        // calculate profits\n', '        uint daoProfit = payout.mul( DAOShare ).div( 10000 );\n', '        // small rounding errors may occur due to improved bond calculator not used by vault\n', '        uint padding = value.div( 10000000 ); // leaves dust to ensure against underflow\n', '        uint profit = value.sub( payout ).sub( daoProfit ).sub( padding );\n', '        // Transfer profits to staking distributor and dao \n', '        IERC20( OHM ).safeTransfer( distributor, profit );\n', '        IERC20( OHM ).safeTransfer( DAO, daoProfit );\n', '\n', '        totalDebt = totalDebt.add( value ); // increase total debt\n', '        \n', '        // Store depositor info\n', '        bondInfo[ depositor_ ] = Bond({\n', '            valueRemaining: bondInfo[ depositor_ ].valueRemaining.add( value ),\n', '            payoutRemaining: bondInfo[ depositor_ ].payoutRemaining.add( payout ),\n', '            lastBlock: block.number,\n', '            vestingPeriod: vestingTerm,\n', '            pricePaid: price\n', '        });\n', '        return payout;\n', '    }\n', '\n', '    /** \n', '        @notice redeem all unvested bonds\n', '        @return payout_ uint\n', '     */ \n', '    function redeem() external returns ( uint ) {        \n', '        Bond memory info = bondInfo[ msg.sender ];\n', '        uint percentVested = percentVestedFor( msg.sender );\n', '\n', '        if ( percentVested >= 10000 ) { // if fully vested, pay full amount & clear info\n', '            delete bondInfo[msg.sender];\n', '            totalDebt = totalDebt.sub( info.valueRemaining );\n', '            IERC20( OHM ).transfer( msg.sender, info.payoutRemaining );\n', '            return info.payoutRemaining;\n', '        } else {\n', '            // calculate reductions from vesting\n', '            uint value = info.valueRemaining.mul( percentVested ).div( 10000 );\n', '            uint payout = info.payoutRemaining.mul( percentVested ).div( 10000 );\n', '            uint blocksSinceLast = block.number.sub( info.lastBlock );\n', '\n', '            // store updated deposit info\n', '            bondInfo[ msg.sender ] = Bond({\n', '                valueRemaining: info.valueRemaining.sub( value ),\n', '                payoutRemaining: info.payoutRemaining.sub( payout ),\n', '                lastBlock: block.number,\n', '                vestingPeriod: info.vestingPeriod.sub( blocksSinceLast ),\n', '                pricePaid: info.pricePaid\n', '            });\n', '\n', '            // reduce total debt by vested amount\n', '            totalDebt = totalDebt.sub( value );\n', '            // send payout\n', '            IERC20( OHM ).transfer( msg.sender, payout );\n', '\n', '            return payout;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice use maxPayoutPercent to determine maximum bond size\n', '        @return uint\n', '     */\n', '    function maxPayout() public view returns ( uint ) {\n', '        uint circulatingOHM = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();\n', '        return circulatingOHM.mul( maxPayoutPercent ).div( 10000 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate how far into vesting a depositor is\n', '        @param depositor_ address\n', '        @return _percentVested uint\n', '     */\n', '    function percentVestedFor( address depositor_ ) public view returns ( uint _percentVested ) {\n', '        Bond memory bond = bondInfo[ depositor_ ];\n', '        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n', '        uint vestingPeriod = bond.vestingPeriod;\n', '\n', '        if ( vestingPeriod > 0 ) {\n', '            _percentVested = blocksSinceLast.mul( 10000 ).div( vestingPeriod );\n', '        } else {\n', '            _percentVested = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate amount of OHM available for claim by depositor\n', '        @param depositor_ address\n', '        @return _pendingPayout uint\n', '     */\n', '    function pendingPayoutFor( address depositor_ ) external view returns ( uint _pendingPayout ) {\n', '        uint percentVested = percentVestedFor( depositor_ );\n', '        uint payoutRemaining = bondInfo[ depositor_ ].payoutRemaining;\n', '\n', '        if ( percentVested >= 10000 ) {\n', '            _pendingPayout = payoutRemaining;\n', '        } else {\n', '            _pendingPayout = payoutRemaining.mul( percentVested ).div( 10000 );\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate interest due for new bond\n', '        @param value_ uint\n', '        @return _interestDue uint\n', '     */\n', '    function payoutFor( uint value_ ) public view returns ( uint ) {\n', '        return FixedPoint.fraction( value_, bondPrice() ).decode112with18().div( 1e16 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate current bond premium\n', '        @return _price uint\n', '     */\n', '    function bondPrice() public view returns ( uint _price ) {        \n', '        _price = controlVariable.mul( _calcDebtRatio() ).add( 1000000000 ).div( 1e7 );\n', '        if ( _price < minimumPrice ) {\n', '            _price = minimumPrice;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate current bond premium without a minimum\n', '        @return _price uint\n', '     */\n', '    function bondPriceWithoutFloor() external view returns ( uint _price ) {\n', '        _price = controlVariable.mul( _calcDebtRatio() ).add( 1000000000 ).div( 1e7 );\n', '    }\n', '\n', '    /**\n', '        @notice converts bond price to DAI value\n', '        @return _price uint\n', '     */\n', '    function bondPriceInDAI() public view returns ( uint _price ) {\n', '        _price = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( LP ) ).div( 1e2 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate current debt ratio\n', '        @return _debtRatio uint\n', '     */\n', '    function debtRatio() external view returns ( uint _debtRatio ) {\n', '        _debtRatio = _calcDebtRatio();\n', '    }\n', '\n', '    function _calcDebtRatio() internal view returns ( uint _debtRatio ) {   \n', '        uint supply = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();\n', '        _debtRatio = FixedPoint.fraction( \n', '            // Must move the decimal to the right by 9 places to avoid math underflow error\n', '            totalDebt.mul( 1e9 ), \n', '            supply\n', '        ).decode112with18().div( 1e18 );\n', '    }\n', '\n', '    /**\n', '        @notice allow anyone to send lost tokens (excluding LP or OHM) to the DAO\n', '        @return bool\n', '     */\n', '    function recoverLostToken( address token_ ) external returns ( bool ) {\n', '        require( token_ != OHM );\n', '        require( token_ != LP );\n', '        IERC20( token_ ).safeTransfer( DAO, IERC20( token_ ).balanceOf( address(this) ) );\n', '        return true;\n', '    }\n', '}']