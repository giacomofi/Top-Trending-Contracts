['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// File: lib/ReentrancyGuard.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () public {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '// File: iface/IPTokenFactory.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPTokenFactory {\n', '    function getGovernance() external view returns(address);\n', '    function getPTokenOperator(address contractAddress) external view returns(bool);\n', '    function getPTokenAuthenticity(address pToken) external view returns(bool);\n', '}\n', '// File: iface/IParasset.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IParasset {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    function destroy(uint256 amount, address account) external;\n', '    function issuance(uint256 amount, address account) external;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: PToken.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', 'contract PToken is IParasset {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '    uint256 public _totalSupply = 0;                                        \n', '    string public name = "";\n', '    string public symbol = "";\n', '    uint8 public decimals = 18;\n', '\n', '    IPTokenFactory pTokenFactory;\n', '\n', '    constructor (string memory _name, \n', '                 string memory _symbol) public {\n', '    \tname = _name;                                                               \n', '    \tsymbol = _symbol;\n', '    \tpTokenFactory = IPTokenFactory(address(msg.sender));\n', '    }\n', '\n', '    //---------modifier---------\n', '\n', '    modifier onlyGovernance() {\n', '        require(address(msg.sender) == pTokenFactory.getGovernance(), "Log:PToken:!governance");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPool() {\n', '    \trequire(pTokenFactory.getPTokenOperator(address(msg.sender)), "Log:PToken:!Pool");\n', '    \t_;\n', '    }\n', '\n', '    //---------view---------\n', '\n', '    // Query factory contract address\n', '    function getPTokenFactory() public view returns(address) {\n', '        return address(pTokenFactory);\n', '    }\n', '\n', '    /// @notice The view of totalSupply\n', '    /// @return The total supply of ntoken\n', '    function totalSupply() override public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /// @dev The view of balances\n', '    /// @param owner The address of an account\n', '    /// @return The balance of the account\n', '    function balanceOf(address owner) override public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    function allowance(address owner, address spender) override public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    //---------transaction---------\n', '\n', '    function changeFactory(address factory) public onlyGovernance {\n', '        pTokenFactory = IPTokenFactory(address(factory));\n', '    }\n', '\n', '    function transfer(address to, uint256 value) override public returns (bool) \n', '    {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 value) override public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) override public returns (bool) \n', '    {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function destroy(uint256 amount, address account) override external onlyPool{\n', '    \trequire(_balances[account] >= amount, "Log:PToken:!destroy");\n', '    \t_balances[account] = _balances[account].sub(amount);\n', '    \t_totalSupply = _totalSupply.sub(amount);\n', '    \temit Transfer(account, address(0x0), amount);\n', '    }\n', '\n', '    function issuance(uint256 amount, address account) override external onlyPool{\n', '    \t_balances[account] = _balances[account].add(amount);\n', '    \t_totalSupply = _totalSupply.add(amount);\n', '    \temit Transfer(address(0x0), account, amount);\n', '    }\n', '}\n', '// File: iface/IMortgagePool.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IMortgagePool {\n', '    function create(address pToken, address insurance, address underlying) external;\n', '    function getUnderlyingToPToken(address uToken) external view returns(address);\n', '    function getPTokenToUnderlying(address pToken) external view returns(address);\n', '    function getGovernance() external view returns(address);\n', '}\n', '// File: iface/IERC20.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IERC20 {\n', '\tfunction decimals() external view returns (uint8);\n', '\tfunction name() external view returns (string memory);\n', '\tfunction symbol() external view returns (string memory);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/Address.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '// File: lib/SafeERC20.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/TransferHelper.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '// File: lib/SafeMath.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0, "ds-math-div-zero");\n', '        z = x / y;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    }\n', '}\n', '// File: InsurancePool.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'contract InsurancePool is ReentrancyGuard {\n', '\tusing SafeMath for uint256;\n', '\tusing SafeERC20 for ERC20;\n', '\n', '\t// Governance address\n', '\taddress public governance;\n', '\t// Underlying asset address => negative account funds\n', '\tmapping(address=>uint256) insNegative;\n', '\t// Underlying asset address => total LP\n', '\tmapping(address=>uint256) totalSupply;\n', '\t// Underlying asset address => latest redemption time\n', '    mapping(address=>uint256) latestTime;\n', '\t// Redemption cycle, 14 days\n', '\tuint256 public redemptionCycle = 15 minutes;\n', '\t// Redemption duration, 2 days\n', '\tuint256 public waitCycle = 30 minutes;\n', '    // User address => Underlying asset address => LP quantity\n', '    mapping(address=>mapping(address=>uint256)) balances;\n', '\t// User address => Underlying asset address => Freeze LP data\n', '\tmapping(address=>mapping(address=>Frozen)) frozenIns;\n', '\tstruct Frozen {\n', '\t\tuint256 amount;\t\t\t\t\t\t\t// Frozen quantity\n', '\t\tuint256 time;\t\t\t\t\t\t\t// Freezing time\n', '\t}\n', '    // Mortgage pool address\n', '    IMortgagePool mortgagePool;\n', '    // PTokenFactory address\n', '    IPTokenFactory pTokenFactory;\n', '    // Status\n', '    uint8 public flag;      // = 0: pause\n', '                            // = 1: active\n', '                            // = 2: redemption only\n', '    // Rate(2/1000)\n', '    uint256 feeRate = 2;\n', '\n', '    event Destroy(address token, uint256 amount, address account);\n', '    event Issuance(address token, uint256 amount, address account);\n', '    event Negative(address token, uint256 amount, uint256 allValue);\n', '\n', '    /// @dev Initialization method\n', '    /// @param factoryAddress PTokenFactory address\n', '\tconstructor (address factoryAddress) public {\n', '        pTokenFactory = IPTokenFactory(factoryAddress);\n', '        governance = pTokenFactory.getGovernance();\n', '        flag = 0;\n', '    }\n', '\n', '\t//---------modifier---------\n', '\n', '    modifier onlyGovernance() {\n', '        require(msg.sender == governance, "Log:InsurancePool:!gov");\n', '        _;\n', '    }\n', '\n', '    modifier onlyMortgagePool() {\n', '        require(msg.sender == address(mortgagePool), "Log:InsurancePool:!mortgagePool");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovOrMor() {\n', '        require(msg.sender == governance || msg.sender == address(mortgagePool), "Log:InsurancePool:!onlyGovOrMor");\n', '        _;\n', '    }\n', '\n', '    modifier whenActive() {\n', '        require(flag == 1, "Log:InsurancePool:!active");\n', '        _;\n', '    }\n', '\n', '    modifier redemptionOnly() {\n', '        require(flag != 0, "Log:InsurancePool:!0");\n', '        _;\n', '    }\n', '\n', '    //---------view---------\n', '\n', '    /// @dev View governance address\n', '    /// @return governance address\n', '    function getGovernance() external view returns(address) {\n', '        return governance;\n', '    }\n', '\n', '    /// @dev View negative ledger\n', '    /// @param token underlying asset address\n', '    /// @return negative ledger\n', '    function getInsNegative(address token) external view returns(uint256) {\n', '        return insNegative[token];\n', '    }\n', '\n', '    /// @dev View total LP\n', '    /// @param token underlying asset address\n', '    /// @return total LP\n', '    function getTotalSupply(address token) external view returns(uint256) {\n', '        return totalSupply[token];\n', '    }\n', '\n', '    /// @dev View personal LP\n', '    /// @param token underlying asset address\n', '    /// @param add user address\n', '    /// @return personal LP\n', '    function getBalances(address token, \n', '                         address add) external view returns(uint256) {\n', '        return balances[add][token];\n', '    }\n', '\n', '    /// @dev View rate\n', '    /// @return rate\n', '    function getFeeRate() external view returns(uint256) {\n', '        return feeRate;\n', '    }\n', '\n', '    /// @dev View mortgage pool address\n', '    /// @return mortgage pool address\n', '    function getMortgagePool() external view returns(address) {\n', '        return address(mortgagePool);\n', '    }\n', '\n', '    /// @dev View the latest redemption time\n', '    /// @param token underlying asset address\n', '    /// @return the latest redemption time\n', '    function getLatestTime(address token) external view returns(uint256) {\n', '        return latestTime[token];\n', '    }\n', '\n', '    /// @dev View redemption period, next time\n', '    /// @param token underlying asset address\n', '    /// @return startTime start time\n', '    /// @return endTime end time\n', '    function getRedemptionTime(address token) external view returns(uint256 startTime, \n', '                                                                    uint256 endTime) {\n', '        uint256 time = latestTime[token];\n', '        if (now > time) {\n', '            uint256 subTime = now.sub(time).div(waitCycle);\n', '            startTime = time.add(waitCycle.mul(uint256(1).add(subTime)));\n', '        } else {\n', '            startTime = time;\n', '        }\n', '        endTime = startTime.add(redemptionCycle);\n', '    }\n', '\n', '    /// @dev View redemption period, this period\n', '    /// @param token underlying asset address\n', '    /// @return startTime start time\n', '    /// @return endTime end time\n', '    function getRedemptionTimeFront(address token) external view returns(uint256 startTime, \n', '                                                                         uint256 endTime) {\n', '        uint256 time = latestTime[token];\n', '        if (now > time) {\n', '            uint256 subTime = now.sub(time).div(waitCycle);\n', '            startTime = time.add(waitCycle.mul(subTime));\n', '        } else {\n', '            startTime = time.sub(waitCycle);\n', '        }\n', '        endTime = startTime.add(redemptionCycle);\n', '    }\n', '\n', '    /// @dev View frozen LP and unfreeze time\n', '    /// @param token underlying asset address\n', '    /// @param add user address\n', '    /// @return frozen LP\n', '    /// @return unfreeze time\n', '    function getFrozenIns(address token, \n', '                          address add) external view returns(uint256, uint256) {\n', '        Frozen memory frozenInfo = frozenIns[add][token];\n', '        return (frozenInfo.amount, frozenInfo.time);\n', '    }\n', '\n', '    /// @dev View frozen LP and unfreeze time, real time\n', '    /// @param token underlying asset address\n', '    /// @param add user address\n', '    /// @return frozen LP\n', '    function getFrozenInsInTime(address token, \n', '                                address add) external view returns(uint256) {\n', '        Frozen memory frozenInfo = frozenIns[add][token];\n', '        if (now > frozenInfo.time) {\n', '            return 0;\n', '        }\n', '        return frozenInfo.amount;\n', '    }\n', '\n', '    /// @dev View redeemable LP, real time\n', '    /// @param token underlying asset address\n', '    /// @param add user address\n', '    /// @return redeemable LP\n', '    function getRedemptionAmount(address token, \n', '                                 address add) external view returns (uint256) {\n', '        Frozen memory frozenInfo = frozenIns[add][token];\n', '        uint256 balanceSelf = balances[add][token];\n', '        if (now > frozenInfo.time) {\n', '            return balanceSelf;\n', '        } else {\n', '            return balanceSelf.sub(frozenInfo.amount);\n', '        }\n', '    }\n', '\n', '\t/// @dev Uniform accuracy\n', '    /// @param inputToken Initial token\n', '    /// @param inputTokenAmount Amount of token\n', '    /// @param outputToken Converted token\n', '    /// @return stability Amount of outputToken\n', '    function getDecimalConversion(address inputToken, \n', '    \t                          uint256 inputTokenAmount, \n', '    \t                          address outputToken) public view returns(uint256) {\n', '    \tuint256 inputTokenDec = 18;\n', '    \tuint256 outputTokenDec = 18;\n', '    \tif (inputToken != address(0x0)) {\n', '    \t\tinputTokenDec = IERC20(inputToken).decimals();\n', '    \t}\n', '    \tif (outputToken != address(0x0)) {\n', '    \t\toutputTokenDec = IERC20(outputToken).decimals();\n', '    \t}\n', '    \treturn inputTokenAmount.mul(10**outputTokenDec).div(10**inputTokenDec);\n', '    }\n', '\n', '    //---------governance----------\n', '\n', '    /// @dev Set contract status\n', '    /// @param num 0: pause, 1: active, 2: redemption only\n', '    function setFlag(uint8 num) public onlyGovernance {\n', '        flag = num;\n', '    }\n', '\n', '    /// @dev Set mortgage pool address\n', '    function setMortgagePool(address add) public onlyGovernance {\n', '    \tmortgagePool = IMortgagePool(add);\n', '    }\n', '\n', '    /// @dev Set the latest redemption time\n', '    function setLatestTime(address token) public onlyGovOrMor {\n', '        latestTime[token] = now.add(waitCycle);\n', '    }\n', '\n', '    /// @dev Set the rate\n', '    function setFeeRate(uint256 num) public onlyGovernance {\n', '        feeRate = num;\n', '    }\n', '\n', '    /// @dev Set redemption cycle\n', '    function setRedemptionCycle(uint256 num) public onlyGovernance {\n', '        require(num > 0, "Log:InsurancePool:!zero");\n', '        redemptionCycle = num * 1 days;\n', '    }\n', '\n', '    /// @dev Set redemption duration\n', '    function setWaitCycle(uint256 num) public onlyGovernance {\n', '        require(num > 0, "Log:InsurancePool:!zero");\n', '        waitCycle = num * 1 days;\n', '    }\n', '\n', '    //---------transaction---------\n', '\n', '    /// @dev Set governance address\n', '    function setGovernance() public {\n', '        governance = pTokenFactory.getGovernance();\n', '    }\n', '\n', '    /// @dev Exchange: ptoken exchanges the underlying asset\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of ptoken\n', '    function exchangePTokenToUnderlying(address pToken, \n', '    \t                                uint256 amount) public whenActive nonReentrant {\n', '        // amount > 0\n', '        require(amount > 0, "Log:InsurancePool:!amount");\n', '\n', '        // Calculate the fee\n', '    \tuint256 fee = amount.mul(feeRate).div(1000);\n', '\n', '        // Transfer to the ptoken\n', '    \tERC20(pToken).safeTransferFrom(address(msg.sender), address(this), amount);\n', '\n', '        // Verify ptoken\n', '        address underlyingToken = mortgagePool.getPTokenToUnderlying(pToken);\n', '        address pToken_s = mortgagePool.getUnderlyingToPToken(underlyingToken);\n', '        require(pToken_s == pToken,"Log:InsurancePool:!pToken");\n', '\n', '        // Calculate the amount of transferred underlying asset\n', '        uint256 uTokenAmount = getDecimalConversion(pToken, amount.sub(fee), underlyingToken);\n', '        require(uTokenAmount > 0, "Log:InsurancePool:!uTokenAmount");\n', '\n', '        // Transfer out underlying asset\n', '    \tif (underlyingToken != address(0x0)) {\n', '    \t\tERC20(underlyingToken).safeTransfer(address(msg.sender), uTokenAmount);\n', '    \t} else {\n', '            TransferHelper.safeTransferETH(address(msg.sender), uTokenAmount);\n', '    \t}\n', '\n', '    \t// Eliminate negative ledger\n', '        _eliminate(pToken, underlyingToken);\n', '    }\n', '\n', '    /// @dev Exchange: underlying asset exchanges the ptoken\n', '    /// @param token underlying asset address\n', '    /// @param amount amount of underlying asset\n', '    function exchangeUnderlyingToPToken(address token, \n', '    \t                                uint256 amount) public payable whenActive nonReentrant {\n', '        // amount > 0\n', '        require(amount > 0, "Log:InsurancePool:!amount");\n', '\n', '        // Calculate the fee\n', '    \tuint256 fee = amount.mul(feeRate).div(1000);\n', '\n', '        // Transfer to the underlying asset\n', '    \tif (token != address(0x0)) {\n', '            // The underlying asset is ERC20\n', '    \t\trequire(msg.value == 0, "Log:InsurancePool:msg.value!=0");\n', '    \t\tERC20(token).safeTransferFrom(address(msg.sender), address(this), amount);\n', '    \t} else {\n', '            // The underlying asset is ETH\n', '    \t\trequire(msg.value == amount, "Log:InsurancePool:!msg.value");\n', '    \t}\n', '\n', '        // Calculate the amount of transferred ptokens\n', '    \taddress pToken = mortgagePool.getUnderlyingToPToken(token);\n', '        uint256 pTokenAmount = getDecimalConversion(token, amount.sub(fee), pToken);\n', '        require(pTokenAmount > 0, "Log:InsurancePool:!pTokenAmount");\n', '\n', '        // Transfer out ptoken\n', '        uint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\n', '        if (pTokenBalance < pTokenAmount) {\n', '            // Insufficient ptoken balance,\n', '            uint256 subNum = pTokenAmount.sub(pTokenBalance);\n', '            PToken(pToken).issuance(subNum, address(this));\n', '            insNegative[token] = insNegative[token].add(subNum);\n', '        }\n', '    \tERC20(pToken).safeTransfer(address(msg.sender), pTokenAmount);\n', '    }\n', '\n', '    /// @dev Subscribe for insurance\n', '    /// @param token underlying asset address\n', '    /// @param amount amount of underlying asset\n', '    function subscribeIns(address token, \n', '    \t                  uint256 amount) public payable whenActive nonReentrant {\n', '        // amount > 0\n', '        require(amount > 0, "Log:InsurancePool:!amount");\n', '\n', '        // Verify ptoken\n', '        address pToken = mortgagePool.getUnderlyingToPToken(token);\n', '        require(pToken != address(0x0), "Log:InsurancePool:!pToken");\n', '\n', '        // Update redemption time\n', '    \tupdateLatestTime(token);\n', '\n', '        // Thaw LP\n', '    \tFrozen storage frozenInfo = frozenIns[address(msg.sender)][token];\n', '    \tif (now > frozenInfo.time) {\n', '    \t\tfrozenInfo.amount = 0;\n', '    \t}\n', '\n', '        // ptoken balance \n', '    \tuint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\n', '        // underlying asset balance\n', '        uint256 tokenBalance;\n', '    \tif (token != address(0x0)) {\n', '            // Underlying asset conversion 18 decimals\n', '    \t\ttokenBalance = getDecimalConversion(token, ERC20(token).balanceOf(address(this)), pToken);\n', '    \t} else {\n', '            // The amount of ETH involved in the calculation does not include the transfer in this time\n', '    \t\trequire(msg.value == amount, "Log:InsurancePool:!msg.value");\n', '    \t\ttokenBalance = address(this).balance.sub(amount);\n', '    \t}\n', '\n', '        // Calculate LP\n', '    \tuint256 insAmount = 0;\n', '    \tuint256 insTotal = totalSupply[token];\n', '        // Insurance pool assets must be greater than 0\n', '        uint256 allBalance = tokenBalance.add(pTokenBalance);\n', '        require(allBalance > insNegative[token], "Log:InsurancePool:allBalanceNotEnough");\n', '    \tif (insTotal != 0) {\n', '            uint256 allValue = allBalance.sub(insNegative[token]);\n', '    \t\tinsAmount = getDecimalConversion(token, amount, pToken).mul(insTotal).div(allValue);\n', '    \t} else {\n', '            // The initial net value is 1\n', '            insAmount = getDecimalConversion(token, amount, pToken);\n', '        }\n', '\n', '    \t// Transfer to the underlying asset(ERC20)\n', '    \tif (token != address(0x0)) {\n', '    \t\trequire(msg.value == 0, "Log:InsurancePool:msg.value!=0");\n', '    \t\tERC20(token).safeTransferFrom(address(msg.sender), address(this), amount);\n', '    \t}\n', '\n', '    \t// Additional LP issuance\n', '    \tissuance(token, insAmount, address(msg.sender));\n', '\n', '    \t// Freeze insurance LP\n', '    \tfrozenInfo.amount = frozenInfo.amount.add(insAmount);\n', '    \tfrozenInfo.time = latestTime[token].add(waitCycle);\n', '    }\n', '\n', '    /// @dev Redemption insurance\n', '    /// @param token underlying asset address\n', '    /// @param amount redemption LP\n', '    function redemptionIns(address token, \n', '    \t                   uint256 amount) public redemptionOnly nonReentrant {\n', '        // amount > 0\n', '        require(amount > 0, "Log:InsurancePool:!amount");\n', '        \n', '        // Verify ptoken\n', '        address pToken = mortgagePool.getUnderlyingToPToken(token);\n', '        require(pToken != address(0x0), "Log:InsurancePool:!pToken");\n', '\n', '        // Update redemption time\n', '    \tupdateLatestTime(token);\n', '\n', '        // Judging the redemption time\n', '        uint256 tokenTime = latestTime[token];\n', '    \trequire(now >= tokenTime.sub(waitCycle) && now <= tokenTime.sub(waitCycle).add(redemptionCycle), "Log:InsurancePool:!time");\n', '\n', '        // Thaw LP\n', '    \tFrozen storage frozenInfo = frozenIns[address(msg.sender)][token];\n', '    \tif (now > frozenInfo.time) {\n', '    \t\tfrozenInfo.amount = 0;\n', '    \t}\n', '    \t\n', '        // ptoken balance\n', '    \tuint256 pTokenBalance = ERC20(pToken).balanceOf(address(this));\n', '        // underlying asset balance\n', '        uint256 tokenBalance;\n', '    \tif (token != address(0x0)) {\n', '    \t\ttokenBalance = getDecimalConversion(token, ERC20(token).balanceOf(address(this)), pToken);\n', '    \t} else {\n', '    \t\ttokenBalance = address(this).balance;\n', '    \t}\n', '\n', '        // Insurance pool assets must be greater than 0\n', '        uint256 allBalance = tokenBalance.add(pTokenBalance);\n', '        require(allBalance > insNegative[token], "Log:InsurancePool:allBalanceNotEnough");\n', '        // Calculated amount of assets\n', '    \tuint256 allValue = allBalance.sub(insNegative[token]);\n', '    \tuint256 insTotal = totalSupply[token];\n', '    \tuint256 underlyingAmount = amount.mul(allValue).div(insTotal);\n', '\n', '        // Destroy LP\n', '        destroy(token, amount, address(msg.sender));\n', '        // Judgment to freeze LP\n', '        require(balances[address(msg.sender)][token] >= frozenInfo.amount, "Log:InsurancePool:frozen");\n', '    \t\n', '    \t// Transfer out assets, priority transfer of the underlying assets, if the underlying assets are insufficient, transfer ptoken\n', '    \tif (token != address(0x0)) {\n', '            // ERC20\n', '            if (tokenBalance >= underlyingAmount) {\n', '                ERC20(token).safeTransfer(address(msg.sender), getDecimalConversion(pToken, underlyingAmount, token));\n', '            } else {\n', '                ERC20(token).safeTransfer(address(msg.sender), getDecimalConversion(pToken, tokenBalance, token));\n', '                ERC20(pToken).safeTransfer(address(msg.sender), underlyingAmount.sub(tokenBalance));\n', '            }\n', '    \t} else {\n', '            // ETH\n', '            if (tokenBalance >= underlyingAmount) {\n', '                TransferHelper.safeTransferETH(address(msg.sender), underlyingAmount);\n', '            } else {\n', '                TransferHelper.safeTransferETH(address(msg.sender), tokenBalance);\n', '                ERC20(pToken).safeTransfer(address(msg.sender), \n', '                                           underlyingAmount.sub(tokenBalance));\n', '            }\n', '    \t}\n', '    }\n', '\n', '    /// @dev Destroy ptoken, update negative ledger\n', '    /// @param pToken ptoken address\n', '    /// @param amount quantity destroyed\n', '    /// @param token underlying asset address\n', '    function destroyPToken(address pToken, \n', '    \t                   uint256 amount,\n', '                           address token) public onlyMortgagePool {\n', '    \tPToken pErc20 = PToken(pToken);\n', '    \tuint256 pTokenBalance = pErc20.balanceOf(address(this));\n', '    \tif (pTokenBalance >= amount) {\n', '    \t\tpErc20.destroy(amount, address(this));\n', '    \t} else {\n', '    \t\tpErc20.destroy(pTokenBalance, address(this));\n', '    \t\t// 记录负账户\n', '            uint256 subAmount = amount.sub(pTokenBalance);\n', '    \t\tinsNegative[token] = insNegative[token].add(subAmount);\n', '            emit Negative(pToken, subAmount, insNegative[token]);\n', '    \t}\n', '    }\n', '\n', '    /// @dev Eliminate negative ledger\n', '    /// @param pToken ptoken address\n', '    /// @param token underlying asset address\n', '    function eliminate(address pToken, \n', '                       address token) public onlyMortgagePool {\n', '    \t_eliminate(pToken, token);\n', '    }\n', '\n', '    function _eliminate(address pToken, \n', '                        address token) private {\n', '\n', '    \tPToken pErc20 = PToken(pToken);\n', '        // negative ledger\n', '    \tuint256 negative = insNegative[token];\n', '        // ptoken balance\n', '    \tuint256 pTokenBalance = pErc20.balanceOf(address(this)); \n', '    \tif (negative > 0 && pTokenBalance > 0) {\n', '    \t\tif (negative >= pTokenBalance) {\n', '                // Increase negative ledger\n', '                pErc20.destroy(pTokenBalance, address(this));\n', '    \t\t\tinsNegative[token] = insNegative[token].sub(pTokenBalance);\n', '                emit Negative(pToken, pTokenBalance, insNegative[token]);\n', '    \t\t} else {\n', '                // negative ledger = 0\n', '                pErc20.destroy(negative, address(this));\n', '    \t\t\tinsNegative[token] = 0;\n', '                emit Negative(pToken, insNegative[token], insNegative[token]);\n', '    \t\t}\n', '    \t}\n', '    }\n', '\n', '    /// @dev Update redemption time\n', '    /// @param token underlying asset address\n', '    function updateLatestTime(address token) public {\n', '        uint256 time = latestTime[token];\n', '    \tif (now > time) {\n', '    \t\tuint256 subTime = now.sub(time).div(waitCycle);\n', '    \t\tlatestTime[token] = time.add(waitCycle.mul(uint256(1).add(subTime)));\n', '    \t}\n', '    }\n', '\n', '    /// @dev Destroy LP\n', '    /// @param token underlying asset address\n', '    /// @param amount quantity destroyed\n', '    /// @param account destroy address\n', '    function destroy(address token, \n', '                     uint256 amount, \n', '                     address account) private {\n', '        require(balances[account][token] >= amount, "Log:InsurancePool:!destroy");\n', '        balances[account][token] = balances[account][token].sub(amount);\n', '        totalSupply[token] = totalSupply[token].sub(amount);\n', '        emit Destroy(token, amount, account);\n', '    }\n', '\n', '    /// @dev Additional LP issuance\n', '    /// @param token underlying asset address\n', '    /// @param amount additional issuance quantity\n', '    /// @param account additional issuance address\n', '    function issuance(address token, \n', '                      uint256 amount, \n', '                      address account) private {\n', '        balances[account][token] = balances[account][token].add(amount);\n', '        totalSupply[token] = totalSupply[token].add(amount);\n', '        emit Issuance(token, amount, account);\n', '    }\n', '\n', '    function takeOutERC20(address token, uint256 amount, address to) public onlyGovernance {\n', '        ERC20(token).safeTransfer(address(to), amount);\n', '    }\n', '\n', '    function takeOutETH(uint256 amount, address to) public onlyGovernance {\n', '        TransferHelper.safeTransferETH(address(to), amount);\n', '    }\n', '}']