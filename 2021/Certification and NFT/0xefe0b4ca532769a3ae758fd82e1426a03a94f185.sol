['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'abstract contract SAFEEngineLike {\n', '    function safes(bytes32, address) virtual public view returns (uint, uint);\n', '    function approveSAFEModification(address) virtual public;\n', '    function transferCollateral(bytes32, address, address, uint) virtual public;\n', '    function transferInternalCoins(address, address, uint) virtual public;\n', '    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n', '    function transferSAFECollateralAndDebt(bytes32, address, address, int, int) virtual public;\n', '}\n', '\n', 'abstract contract LiquidationEngineLike {\n', '    function protectSAFE(bytes32, address, address) virtual external;\n', '}\n', '\n', 'contract SAFEHandler {\n', '    constructor(address safeEngine) public {\n', '        SAFEEngineLike(safeEngine).approveSAFEModification(msg.sender);\n', '    }\n', '}\n', '\n', 'contract GebSafeManager {\n', '    address                   public safeEngine;\n', '    uint                      public safei;               // Auto incremental\n', '    mapping (uint => address) public safes;               // SAFEId => SAFEHandler\n', '    mapping (uint => List)    public safeList;            // SAFEId => Prev & Next SAFEIds (double linked list)\n', '    mapping (uint => address) public ownsSAFE;            // SAFEId => Owner\n', '    mapping (uint => bytes32) public collateralTypes;     // SAFEId => CollateralType\n', '\n', '    mapping (address => uint) public firstSAFEID;         // Owner => First SAFEId\n', '    mapping (address => uint) public lastSAFEID;          // Owner => Last SAFEId\n', '    mapping (address => uint) public safeCount;           // Owner => Amount of SAFEs\n', '\n', '    mapping (\n', '        address => mapping (\n', '            uint => mapping (\n', '                address => uint\n', '            )\n', '        )\n', '    ) public safeCan;                            // Owner => SAFEId => Allowed Addr => True/False\n', '\n', '    mapping (\n', '        address => mapping (\n', '            address => uint\n', '        )\n', '    ) public handlerCan;                        // SAFE handler => Allowed Addr => True/False\n', '\n', '    struct List {\n', '        uint prev;\n', '        uint next;\n', '    }\n', '\n', '    // --- Events ---\n', '    event AllowSAFE(\n', '        address sender,\n', '        uint safe,\n', '        address usr,\n', '        uint ok\n', '    );\n', '    event AllowHandler(\n', '        address sender,\n', '        address usr,\n', '        uint ok\n', '    );\n', '    event TransferSAFEOwnership(\n', '        address sender,\n', '        uint safe,\n', '        address dst\n', '    );\n', '    event OpenSAFE(address indexed sender, address indexed own, uint indexed safe);\n', '    event ModifySAFECollateralization(\n', '        address sender,\n', '        uint safe,\n', '        int deltaCollateral,\n', '        int deltaDebt\n', '    );\n', '    event TransferCollateral(\n', '        address sender,\n', '        uint safe,\n', '        address dst,\n', '        uint wad\n', '    );\n', '    event TransferCollateral(\n', '        address sender,\n', '        bytes32 collateralType,\n', '        uint safe,\n', '        address dst,\n', '        uint wad\n', '    );\n', '    event TransferInternalCoins(\n', '        address sender,\n', '        uint safe,\n', '        address dst,\n', '        uint rad\n', '    );\n', '    event QuitSystem(\n', '        address sender,\n', '        uint safe,\n', '        address dst\n', '    );\n', '    event EnterSystem(\n', '        address sender,\n', '        address src,\n', '        uint safe\n', '    );\n', '    event MoveSAFE(\n', '        address sender,\n', '        uint safeSrc,\n', '        uint safeDst\n', '    );\n', '    event ProtectSAFE(\n', '        address sender,\n', '        uint safe,\n', '        address liquidationEngine,\n', '        address saviour\n', '    );\n', '\n', '    modifier safeAllowed(\n', '        uint safe\n', '    ) {\n', '        require(msg.sender == ownsSAFE[safe] || safeCan[ownsSAFE[safe]][safe][msg.sender] == 1, "safe-not-allowed");\n', '        _;\n', '    }\n', '\n', '    modifier handlerAllowed(\n', '        address handler\n', '    ) {\n', '        require(\n', '          msg.sender == handler ||\n', '          handlerCan[handler][msg.sender] == 1,\n', '          "internal-system-safe-not-allowed"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(address safeEngine_) public {\n', '        safeEngine = safeEngine_;\n', '    }\n', '\n', '    // --- Math ---\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function toInt(uint x) internal pure returns (int y) {\n', '        y = int(x);\n', '        require(y >= 0);\n', '    }\n', '\n', '    // --- SAFE Manipulation ---\n', '\n', '    // Allow/disallow a usr address to manage the safe\n', '    function allowSAFE(\n', '        uint safe,\n', '        address usr,\n', '        uint ok\n', '    ) public safeAllowed(safe) {\n', '        safeCan[ownsSAFE[safe]][safe][usr] = ok;\n', '        emit AllowSAFE(\n', '            msg.sender,\n', '            safe,\n', '            usr,\n', '            ok\n', '        );\n', '    }\n', '\n', '    // Allow/disallow a usr address to quit to the sender handler\n', '    function allowHandler(\n', '        address usr,\n', '        uint ok\n', '    ) public {\n', '        handlerCan[msg.sender][usr] = ok;\n', '        emit AllowHandler(\n', '            msg.sender,\n', '            usr,\n', '            ok\n', '        );\n', '    }\n', '\n', '    // Open a new safe for a given usr address.\n', '    function openSAFE(\n', '        bytes32 collateralType,\n', '        address usr\n', '    ) public returns (uint) {\n', '        require(usr != address(0), "usr-address-0");\n', '\n', '        safei = add(safei, 1);\n', '        safes[safei] = address(new SAFEHandler(safeEngine));\n', '        ownsSAFE[safei] = usr;\n', '        collateralTypes[safei] = collateralType;\n', '\n', '        // Add new SAFE to double linked list and pointers\n', '        if (firstSAFEID[usr] == 0) {\n', '            firstSAFEID[usr] = safei;\n', '        }\n', '        if (lastSAFEID[usr] != 0) {\n', '            safeList[safei].prev = lastSAFEID[usr];\n', '            safeList[lastSAFEID[usr]].next = safei;\n', '        }\n', '        lastSAFEID[usr] = safei;\n', '        safeCount[usr] = add(safeCount[usr], 1);\n', '\n', '        emit OpenSAFE(msg.sender, usr, safei);\n', '        return safei;\n', '    }\n', '\n', '    // Give the safe ownership to a dst address.\n', '    function transferSAFEOwnership(\n', '        uint safe,\n', '        address dst\n', '    ) public safeAllowed(safe) {\n', '        require(dst != address(0), "dst-address-0");\n', '        require(dst != ownsSAFE[safe], "dst-already-owner");\n', '\n', '        // Remove transferred SAFE from double linked list of origin user and pointers\n', '        if (safeList[safe].prev != 0) {\n', '            safeList[safeList[safe].prev].next = safeList[safe].next;    // Set the next pointer of the prev safe (if exists) to the next of the transferred one\n', '        }\n', "        if (safeList[safe].next != 0) {                               // If wasn't the last one\n", '            safeList[safeList[safe].next].prev = safeList[safe].prev;    // Set the prev pointer of the next safe to the prev of the transferred one\n', '        } else {                                                    // If was the last one\n', '            lastSAFEID[ownsSAFE[safe]] = safeList[safe].prev;            // Update last pointer of the owner\n', '        }\n', '        if (firstSAFEID[ownsSAFE[safe]] == safe) {                      // If was the first one\n', '            firstSAFEID[ownsSAFE[safe]] = safeList[safe].next;           // Update first pointer of the owner\n', '        }\n', '        safeCount[ownsSAFE[safe]] = sub(safeCount[ownsSAFE[safe]], 1);\n', '\n', '        // Transfer ownership\n', '        ownsSAFE[safe] = dst;\n', '\n', '        // Add transferred SAFE to double linked list of destiny user and pointers\n', '        safeList[safe].prev = lastSAFEID[dst];\n', '        safeList[safe].next = 0;\n', '        if (lastSAFEID[dst] != 0) {\n', '            safeList[lastSAFEID[dst]].next = safe;\n', '        }\n', '        if (firstSAFEID[dst] == 0) {\n', '            firstSAFEID[dst] = safe;\n', '        }\n', '        lastSAFEID[dst] = safe;\n', '        safeCount[dst] = add(safeCount[dst], 1);\n', '\n', '        emit TransferSAFEOwnership(\n', '            msg.sender,\n', '            safe,\n', '            dst\n', '        );\n', '    }\n', '\n', "    // Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.\n", '    function modifySAFECollateralization(\n', '        uint safe,\n', '        int deltaCollateral,\n', '        int deltaDebt\n', '    ) public safeAllowed(safe) {\n', '        address safeHandler = safes[safe];\n', '        SAFEEngineLike(safeEngine).modifySAFECollateralization(\n', '            collateralTypes[safe],\n', '            safeHandler,\n', '            safeHandler,\n', '            safeHandler,\n', '            deltaCollateral,\n', '            deltaDebt\n', '        );\n', '        emit ModifySAFECollateralization(\n', '            msg.sender,\n', '            safe,\n', '            deltaCollateral,\n', '            deltaDebt\n', '        );\n', '    }\n', '\n', '    // Transfer wad amount of safe collateral from the safe address to a dst address.\n', '    function transferCollateral(\n', '        uint safe,\n', '        address dst,\n', '        uint wad\n', '    ) public safeAllowed(safe) {\n', '        SAFEEngineLike(safeEngine).transferCollateral(collateralTypes[safe], safes[safe], dst, wad);\n', '        emit TransferCollateral(\n', '            msg.sender,\n', '            safe,\n', '            dst,\n', '            wad\n', '        );\n', '    }\n', '\n', '    // Transfer wad amount of any type of collateral (collateralType) from the safe address to a dst address.\n', "    // This function has the purpose to take away collateral from the system that doesn't correspond to the safe but was sent there wrongly.\n", '    function transferCollateral(\n', '        bytes32 collateralType,\n', '        uint safe,\n', '        address dst,\n', '        uint wad\n', '    ) public safeAllowed(safe) {\n', '        SAFEEngineLike(safeEngine).transferCollateral(collateralType, safes[safe], dst, wad);\n', '        emit TransferCollateral(\n', '            msg.sender,\n', '            collateralType,\n', '            safe,\n', '            dst,\n', '            wad\n', '        );\n', '    }\n', '\n', '    // Transfer rad amount of COIN from the safe address to a dst address.\n', '    function transferInternalCoins(\n', '        uint safe,\n', '        address dst,\n', '        uint rad\n', '    ) public safeAllowed(safe) {\n', '        SAFEEngineLike(safeEngine).transferInternalCoins(safes[safe], dst, rad);\n', '        emit TransferInternalCoins(\n', '            msg.sender,\n', '            safe,\n', '            dst,\n', '            rad\n', '        );\n', '    }\n', '\n', '    // Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler\n', '    function quitSystem(\n', '        uint safe,\n', '        address dst\n', '    ) public safeAllowed(safe) handlerAllowed(dst) {\n', '        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safe], safes[safe]);\n', '        int deltaCollateral = toInt(lockedCollateral);\n', '        int deltaDebt = toInt(generatedDebt);\n', '        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\n', '            collateralTypes[safe],\n', '            safes[safe],\n', '            dst,\n', '            deltaCollateral,\n', '            deltaDebt\n', '        );\n', '        emit QuitSystem(\n', '            msg.sender,\n', '            safe,\n', '            dst\n', '        );\n', '    }\n', '\n', '    // Import a position from src handler to the handler owned by safe\n', '    function enterSystem(\n', '        address src,\n', '        uint safe\n', '    ) public handlerAllowed(src) safeAllowed(safe) {\n', '        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safe], src);\n', '        int deltaCollateral = toInt(lockedCollateral);\n', '        int deltaDebt = toInt(generatedDebt);\n', '        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\n', '            collateralTypes[safe],\n', '            src,\n', '            safes[safe],\n', '            deltaCollateral,\n', '            deltaDebt\n', '        );\n', '        emit EnterSystem(\n', '            msg.sender,\n', '            src,\n', '            safe\n', '        );\n', '    }\n', '\n', '    // Move a position from safeSrc handler to the safeDst handler\n', '    function moveSAFE(\n', '        uint safeSrc,\n', '        uint safeDst\n', '    ) public safeAllowed(safeSrc) safeAllowed(safeDst) {\n', '        require(collateralTypes[safeSrc] == collateralTypes[safeDst], "non-matching-safes");\n', '        (uint lockedCollateral, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralTypes[safeSrc], safes[safeSrc]);\n', '        int deltaCollateral = toInt(lockedCollateral);\n', '        int deltaDebt = toInt(generatedDebt);\n', '        SAFEEngineLike(safeEngine).transferSAFECollateralAndDebt(\n', '            collateralTypes[safeSrc],\n', '            safes[safeSrc],\n', '            safes[safeDst],\n', '            deltaCollateral,\n', '            deltaDebt\n', '        );\n', '        emit MoveSAFE(\n', '            msg.sender,\n', '            safeSrc,\n', '            safeDst\n', '        );\n', '    }\n', '\n', "    // Choose a SAFE saviour inside LiquidationEngine for the SAFE with id 'safe'\n", '    function protectSAFE(\n', '        uint safe,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public safeAllowed(safe) {\n', '        LiquidationEngineLike(liquidationEngine).protectSAFE(\n', '            collateralTypes[safe],\n', '            safes[safe],\n', '            saviour\n', '        );\n', '        emit ProtectSAFE(\n', '            msg.sender,\n', '            safe,\n', '            liquidationEngine,\n', '            saviour\n', '        );\n', '    }\n', '}']