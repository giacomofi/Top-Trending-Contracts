['pragma solidity ^0.6.7;\n', '\n', 'import "./StrategyStakingRewardsBase.sol";\n', 'import "./IStakingRewards.sol";\n', '\n', 'abstract contract StrategyFraxFarmBase is StrategyStakingRewardsBase {\n', '    \n', '    // FXS reward staking contracts\n', '    address public FXS_FRAX_UNI_STAKING_CONTRACT = 0xda2c338350a0E59Ce71CDCED9679A3A590Dd9BEC;\n', '    address public FXS_FRAX_SUSHI_STAKING_CONTRACT = 0x35302f77E5Bd7A93cbec05d585e414e14B2A84a8;\n', '\n', '    // Token addresses\n', '    address public fxs = 0x3432B6A60D23Ca0dFCa7761B7ab56459D9C964D0;\n', '    address public frax = 0x853d955aCEf822Db058eb8505911ED77F175b99e;\n', '    address public sushi = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n', '\n', '    // LP Token addresses\n', '    address public FXS_FRAX_UNI_LP = 0xE1573B9D29e2183B1AF0e743Dc2754979A40D237;\n', '    address public FXS_FRAX_SUSHI_LP = 0xc218001e3D102e3d1De9bf2c0F7D9626d76C6f30;\n', '\n', '    // 15% performance fee to pay for gas (est. cost of calling harvest() is $100+), remainder will be staked\n', '    uint256 public keepFXS = 1500;\n', '    uint256 public constant keepFXSmax = 10000;\n', '\n', '    // Uniswap swap paths\n', '    address[] public fxs_frax_path;\n', '    address[] public sushi_fxs_path;\n', '\n', '    constructor(\n', '        address _stakingContract,\n', '        address _want,\n', '        address _strategist\n', '    )\n', '        public\n', '        StrategyStakingRewardsBase(\n', '            _stakingContract,\n', '            _want,\n', '            _strategist\n', '        )\n', '    {\n', '        fxs_frax_path = new address[](2);\n', '        fxs_frax_path[0] = fxs;\n', '        fxs_frax_path[1] = frax;\n', '\n', '        sushi_fxs_path = new address[](3);\n', '        sushi_fxs_path[0] = sushi;\n', '        sushi_fxs_path[1] = weth;\n', '        sushi_fxs_path[2] = fxs;\n', '    }\n', '\n', '    // **** State Mutations ****\n', '\n', '    function harvest() public override onlyOwner {\n', '        // Collects FXS tokens\n', '        IStakingRewards(stakingContract).getReward();\n', '        \n', '        //Swap 1/2 of FXS for Frax\n', '        uint256 _fxsBalance = IERC20(fxs).balanceOf(address(this));\n', '        if (_fxsBalance > 0) {\n', '            _swapUniswapWithPath(fxs_frax_path, _fxsBalance.div(2));\n', '        }\n', '        \n', '        // Add liquidity for FXS/FRAX\n', '        uint256 _frax = IERC20(frax).balanceOf(address(this));\n', '        uint256 _fxs = IERC20(fxs).balanceOf(address(this));\n', '        if (_frax > 0 && _fxs > 0) {\n', '            //should be no danger in giving the router infinite approval, the Curve depositer does the same thing\n', '            //IERC20(frax).safeApprove(currentRouter, 0);\n', '            //IERC20(frax).safeApprove(currentRouter, _frax);\n', '            //IERC20(fxs).safeApprove(currentRouter, 0);\n', '            //IERC20(fxs).safeApprove(currentRouter, _fxs);\n', '\n', '            IUniswapRouterV2(currentRouter).addLiquidity(\n', '                frax,\n', '                fxs,\n', '                _frax,\n', '                _fxs,\n', '                0,\n', '                0,\n', '                address(this),\n', '                now + 60\n', '            );\n', '\n', '            // Donates DUST\n', "            // Costs more to claim dust than it's worth \n", '            /*IERC20(frax).safeTransfer(\n', '                strategist,\n', '                IERC20(frax).balanceOf(address(this))\n', '            );\n', '            IERC20(fxs).safeTransfer(\n', '                strategist,\n', '                IERC20(fxs).balanceOf(address(this))\n', '            );*/\n', '        }\n', '\n', '        //Send performance fee to strategist\n', '        uint256 _want = IERC20(want).balanceOf(address(this));\n', '        if (_want > 0) {\n', '            uint256 performanceFee = _want.mul(keepFXS).div(keepFXSmax);\n', '            IERC20(want).safeTransfer(\n', '                strategist,\n', '                performanceFee\n', '            );\n', '        }\n', '\n', '        // Stake the LP tokens\n', "        // We don't ever distribute the performance fee in _distributePerformanceFeesAndDeposit(), it should be renamed tbh\n", '        _distributePerformanceFeesAndDeposit();\n', '    }\n', '\n', '    //Due to the lower total value of Sushi tokens farmed, converting Sushi to FXS/FRAX LP has been split into a different function to save gas\n', '    function exchangeSushiForUnderlying() public onlyOwner {\n', '        //Swap Sushi to FXS (routed through Sushi -> ETH -> FXS)\n', '        uint256 _sushiBalance = IERC20(sushi).balanceOf(address(this));\n', '        if (_sushiBalance > 0) {\n', '            _swapUniswapWithPath(sushi_fxs_path, _sushiBalance);\n', '        }\n', '        \n', '        //Swap 1/2 of FXS for Frax\n', '        uint256 _fxsBalance = IERC20(fxs).balanceOf(address(this));\n', '        if (_fxsBalance > 0) {\n', '            _swapUniswapWithPath(fxs_frax_path, _fxsBalance.div(2));\n', '        }\n', '        \n', '        // Add liquidity for FXS/FRAX\n', '        uint256 _frax = IERC20(frax).balanceOf(address(this));\n', '        uint256 _fxs = IERC20(fxs).balanceOf(address(this));\n', '        if (_frax > 0 && _fxs > 0) {\n', '            IUniswapRouterV2(currentRouter).addLiquidity(\n', '                frax,\n', '                fxs,\n', '                _frax,\n', '                _fxs,\n', '                0,\n', '                0,\n', '                address(this),\n', '                now + 60\n', '            );\n', '        }\n', '\n', '        //Send performance fee to strategist\n', '        uint256 _want = IERC20(want).balanceOf(address(this));\n', '        if (_want > 0) {\n', '            uint256 performanceFee = _want.mul(keepFXS).div(keepFXSmax);\n', '            IERC20(want).safeTransfer(\n', '                strategist,\n', '                performanceFee\n', '            );\n', '        }\n', '\n', '        // Stake the LP tokens\n', "        // We don't ever distribute the performance fee in _distributePerformanceFeesAndDeposit(), it should be renamed tbh\n", '        _distributePerformanceFeesAndDeposit();\n', '    }\n', '\n', '    function salvage(address recipient, address token, uint256 amount) public onlyOwner {\n', '        //Sushi is the only token that will remain in this contract in any sizable amount after any function calls, so block it from being salvaged\n', '        require(token != sushi);\n', '        IERC20(token).safeTransfer(recipient, amount);\n', '    }\n', '\n', '    function migrate() external {\n', '        require(msg.sender == jar, "unauthorized");\n', '        //Withdraw all staked tokens and remove FXS/FRAX liquidity from Uniswap\n', '        _withdrawSome(balanceOfPool());\n', '        uint256 amount = IERC20(FXS_FRAX_UNI_LP).balanceOf(address(this));\n', '\n', '        IERC20(FXS_FRAX_UNI_LP).safeApprove(uniRouter, 0);\n', '        IERC20(FXS_FRAX_UNI_LP).safeApprove(uniRouter, amount);\n', '        IUniswapRouterV2(uniRouter).removeLiquidity(\n', '                fxs,\n', '                frax,\n', '                amount,\n', '                0,\n', '                0,\n', '                address(this),\n', '                now + 60\n', '            );\n', '\n', '        //Change from Uniswap to Sushiswap\n', '        currentRouter = sushiRouter;\n', '        stakingContract = FXS_FRAX_SUSHI_STAKING_CONTRACT;\n', '        want = FXS_FRAX_SUSHI_LP;\n', '\n', '        // Add FXS/FRAX liquidity to Sushiswap\n', '        uint256 _frax = IERC20(frax).balanceOf(address(this));\n', '        uint256 _fxs = IERC20(fxs).balanceOf(address(this));\n', '        IUniswapRouterV2(sushiRouter).addLiquidity(\n', '                frax,\n', '                fxs,\n', '                _frax,\n', '                _fxs,\n', '                0,\n', '                0,\n', '                address(this),\n', '                now + 60\n', '            );\n', '\n', '        //Deposit to FXS_FRAX_SUSHI_STAKING_CONTRACT\n', '        deposit();\n', '    }\n', '}\n', '\n', 'contract StrategyFxsFrax is StrategyFraxFarmBase {\n', '\n', '    constructor(address _strategist)\n', '        public\n', '        StrategyFraxFarmBase(\n', '            FXS_FRAX_UNI_STAKING_CONTRACT,\n', '            FXS_FRAX_UNI_LP,\n', '            _strategist\n', '        )\n', '    {}\n', '\n', '    // **** Views ****\n', '\n', '    function getName() external override pure returns (string memory) {\n', '        return "StrategyFxsFrax";\n', '    }\n', '\n', '    //Give the Uniswap and Sushiswap routers infinite approval to save gas, since they are known not to be malicious\n', '    function approveForever() public onlyOwner {\n', '        IERC20(frax).approve(uniRouter, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n', '        IERC20(fxs).approve(uniRouter, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n', '        IERC20(frax).approve(sushiRouter, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n', '        IERC20(fxs).approve(sushiRouter, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n', '        IERC20(sushi).approve(sushiRouter, 115792089237316195423570985008687907853269984665640564039457584007913129639935);\n', '    }\n', '}']