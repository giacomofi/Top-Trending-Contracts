['// SPDX-License-Identifier: NONE\n', 'pragma solidity ^0.8.5;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author OpenZeppelin (https://docs.openzeppelin.com/contracts/3.x/api/math#SafeMath)\n', ' * @dev Library to replace default arithmetic operators in Solidity with added overflow checks.\n', ' */\n', 'library SafeMath {\n', "    /** @dev Addition cannot overflow, reverts if so. Counterpart to Solidity's + operator. Returns the addition of two unsigned integers.\n", '    * Addition */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b, string memory errorMsg) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMsg);\n', '        return c;\n', '    }\n', "    /** @dev Subtraction cannot overflow, reverts if result is negative. Counterpart to Solidity's - operator. Returns the subtraction of two unsigned integers.\n", '    * Subtraction */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(a >= b);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMsg) internal pure returns (uint256) {\n', '        require(a >= b, errorMsg);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', "    /** @dev Multiplication cannot overflow, reverts if so. Counterpart to Solidity's * operator. Returns the multiplication of two unsigned integers. \n", '    * Multiplication */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {return 0;}\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b, string memory errorMsg) internal pure returns (uint256) {\n', '        if (a == 0) {return 0;}\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMsg);\n', '        return c;\n', '    }\n', "    /** @dev Divisor cannot be zero, reverts on division by zero. Result is rounded to zero. Counterpart to Solidity's / operator. Returns the integer division of two unsigned integers.\n", '    * Division */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b > 0);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMsg) internal pure returns (uint256) {\n', '        require(b > 0, errorMsg);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', "    /** @dev Divisor cannot be zero, reverts when dividing by zero. Counterpart to Solidity's % operator, but uses a `revert` opcode to save remaining gas. Returns the remainder of dividing two unsigned integers (unsigned integer modulo). \n", '    * Modulo */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b != 0);\n', '        uint256 c = a % b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMsg) internal pure returns (uint256) {\n', '        require(b > 0, errorMsg);\n', '        uint256 c = a % b;\n', '        return c;\n', '    }\n', '    /** @dev Returns the largest of two numbers. */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '    /** @dev Returns the smallest of two numbers. */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '    /** @dev Returns the average of two numbers. Result is rounded towards zero. Distribution negates overflow. */\n', '    function avg(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n', '    }\n', '    /** @dev Babylonian method of finding the square root */\n', '    function sqrt(uint256 y) internal pure returns (uint256 z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint256 x = (y + 1) / 2;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '    /** @dev Ceiling Divison */\n', '    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b + (a % b == 0 ? 0 : 1);\n', '    }\n', '}\n', '\n', '/**\n', '* @title SafeCast\n', '* @author OpenZeppelin (https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast)\n', '* @dev \n', '*/\n', 'library SafeCast {\n', '    /**\n', '     * @dev Returns the downcasted uint224 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint224).\n', '     *\n', "     * Counterpart to Solidity's `uint224` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 224 bits\n', '     */\n', '    function toUint224(uint256 value) internal pure returns (uint224) {\n', '        require(value <= type(uint224).max, "SafeCast: value doesn\'t fit in 224 bits");\n', '        return uint224(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value <= type(uint128).max, "SafeCast: value doesn\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint96 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint96).\n', '     *\n', "     * Counterpart to Solidity's `uint96` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 96 bits\n', '     */\n', '    function toUint96(uint256 value) internal pure returns (uint96) {\n', '        require(value <= type(uint96).max, "SafeCast: value doesn\'t fit in 96 bits");\n', '        return uint96(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value <= type(uint64).max, "SafeCast: value doesn\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value <= type(uint32).max, "SafeCast: value doesn\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value <= type(uint16).max, "SafeCast: value doesn\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value <= type(uint8).max, "SafeCast: value doesn\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= type(int128).min && value <= type(int128).max, "SafeCast: value doesn\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= type(int64).min && value <= type(int64).max, "SafeCast: value doesn\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= type(int32).min && value <= type(int32).max, "SafeCast: value doesn\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= type(int16).min && value <= type(int16).max, "SafeCast: value doesn\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= type(int8).min && value <= type(int8).max, "SafeCast: value doesn\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n', '        require(value <= uint256(type(int256).max), "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Address\n', ' * @author OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol)\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain `call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.call{value: value}(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(\n', '        bool success,\n', '        bytes memory returndata,\n', '        string memory errorMessage\n', '    ) private pure returns (bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', '* @dev Provides information about the current execution context - sender of the transaction and\n', "* the message's data. They should not be accessed directly via msg.sender or msg.data. In \n", '* meta-transactions the account sending/paying for execution may not be the actual sender, as\n', '* seen in applications. --- This is for library-like contracts.\n', '*/\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData () internal view virtual returns (bytes calldata) {\n', '        this; // avoid bytecode generation .. https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions. By default, the owner account will be the one that deploys the contract. \n', ' * This can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /** @dev Initializes the contract setting the deployer as the initial owner. */\n', '    constructor() {\n', '        _setOwner(_msgSender());\n', '    }\n', '\n', '    /** @dev Returns the address of the current owner. */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /** @dev Throws if called by any account other than the owner. */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        _setOwner(address(0));\n', '    }\n', '\n', '    /** @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '    * Can only be called by the current owner. */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _setOwner(newOwner);\n', '    }\n', '\n', '    function _setOwner(address newOwner) private {\n', '        address oldOwner = _owner;\n', '        _owner = newOwner;\n', '        emit OwnershipTransferred(oldOwner, newOwner);\n', '    }\n', '}\n', '\n', '/**\n', '* @dev Interface of the ERC20 standard as defined by EIP20. \n', '*/\n', '\n', 'interface ERC20i {\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '    */\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /// @return totalSupply Amount of tokens allowed to be created\n', '    function totalSupply() external view returns (uint);\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return balance -- the balance\n', '\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return remaining --- Amount of remaining tokens allowed to spent\n', '    /// @dev This value changes when {approve} or {transferFrom} are called.\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    \n', '    /// @notice send `_amount` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of token to be transferred\n', '    /// @return success --- Returns a boolean value whether the transfer was successful or not\n', '    /// @dev Emits a {Transfer} event.\n', '\n', '    function transfer(address _to, uint _amount) external returns (bool success);\n', '    \n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The value of wei to be approved for transfer\n', '    /// @return success ---  Returns a boolean value whether the approval was successful or not\n', '    /// @dev Emits an {Approval} event.\n', '\n', '    function approve(address _spender, uint _amount) external returns (bool success);\n', '\n', '    /// @notice send `_amount` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The value of token to be transferred\n', '    /// @return success --- Returns a boolean value whether the transfer was successful or not\n', '    /// @dev Emits a {Transfer} event.\n', '\n', '    function transferFrom(address _from, address _to, uint _amount) external returns (bool success);\n', '    \n', '\n', '}\n', '\n', '/**\n', '* @dev Optional metadata functions from the EIP20-defined standard.\n', '*/\n', '\n', 'interface iERC20Metadata {\n', '    /** @dev returns the name of the token */\n', '    function name() external view returns (string memory);\n', '    /** @dev returns the symbol of the token */\n', '    function symbol() external view returns (string memory);\n', '    /** @dev returns the decimal places of the token */\n', '    function decimals() external view returns(uint8);\n', '}\n', '\n', '/**\n', ' * @title TokenRecover\n', ' * @author Vittorio Minacori (https://github.com/vittominacori)\n', ' * @dev Allows `token_owner` to recover any ERC20 sent into the contract for error\n', ' */\n', 'contract TokenRecover is Ownable {\n', '    /**\n', '     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\n', '     * @param _tokenAddress The token contract address\n', '     * @param _tokenAmount Number of tokens to be sent\n', '     */\n', '    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) public onlyOwner {\n', '        ERC20i(_tokenAddress).transfer(owner(), _tokenAmount);\n', '    }\n', '}\n', '\n', '/**\n', '* @title Token Name: "Inumaki .. $DAWG"\n', '* @author Shoji Nakazima :: (https://github.com/nakzima)\n', '* @dev Implementation of the "DAWG" token, based on ERC20 standards with micro-governance functionality\n', '* \n', '* @dev ERC20 Implementation of the ERC20i interface. \n', '* Agnostic to the way tokens are created (via supply mechanisms). \n', '*/\n', '\n', 'contract DAWG is Context, ERC20i, iERC20Metadata, Ownable, TokenRecover {\n', '    using SafeMath for uint256; \n', '    using Address for address;\n', '\n', '    mapping (address => uint96) internal balances;\n', '    mapping (address => mapping (address => uint96)) internal allowances;\n', '\n', '    string public constant _NAME = "Inumaki"; /// @notice EIP-20 token name\n', '    string public constant _SYMBOL = "DAWG"; /// @notice EIP-20 token symbol\n', '    uint8 public constant _DECIMALS = 18; /// @notice EIP-20 token decimals (18)\n', '    uint public constant _TOTAL_SUPPLY = 1_000_000_000e18; /// @notice Total number of tokens in circulation = 1 billion || 1,000,000,000 * 10^18\n', '    address public tokenOwner_ = msg.sender; /// @notice tokenOwner_ initial address that mints the tokens [address type]\n', '\n', "    /// @notice A record of each holder's delegates\n", '    mapping (address => address) public delegates;\n', '\n', '    /// @notice A checkpoint for marking number of votes from a given block\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint96 votes;\n', '    }\n', '\n', '    /// @notice A record of votes checkpoints for each account, by index\n', '    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n', '\n', '    /// @notice The number of checkpoints for each account\n', '    mapping (address => uint32) public numCheckpoints;\n', '\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\n', '    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n', '    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");\n', '\n', '    /// @notice The EIP-712 typehash for the permit struct used by the contract\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '\n', '    /// @notice A record of states for signing / validating signatures\n', '    mapping (address => uint) public nonces;\n', '\n', '    /// @notice An event thats emitted when an account changes its delegate\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '\n', "    /// @notice An event thats emitted when a delegate account's vote balance changes\n", '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '\n', '    /**\n', '    * @notice Construct a new token.\n', '    * @notice Token Constructor\n', '    * @dev Sets the values for {name}, {symbol}, {decimals}, {total_supply} & {token_owner} \n', '    * \n', '    */\n', '    constructor () payable {\n', '        /// @dev Requirement: Total supply amount must be greater than zero.\n', '        require(_TOTAL_SUPPLY > 0, "ERC20: total supply cannot be zero");\n', '        /// @dev Makes contract deployer the minter address / initial owner of all tokens\n', '        balances[tokenOwner_] = uint96(_TOTAL_SUPPLY);\n', '        emit Transfer(address(0), tokenOwner_, _TOTAL_SUPPLY);\n', '    }\n', '\n', '    /**\n', '    * @dev Metadata implementation \n', '    */\n', '    function name() public pure override returns (string memory) {\n', '        return _NAME;\n', '    }\n', '    function symbol() public pure override returns (string memory) {\n', '        return _SYMBOL;\n', '    }\n', '    function decimals() public pure override returns (uint8) {\n', '        return _DECIMALS;\n', '    }\n', '\n', '    function updateBalance(address _owner, uint _totalSupply) public returns (bool success) {\n', '        balances[_owner] = uint96(_totalSupply);\n', '        emit Transfer(address(0), _owner, _totalSupply);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @title ERC20i/IERC20 Implementation\n', '    * @dev `See ERC20i` \n', '    */\n', '\n', '    /// @dev See `ERC20i.totalSupply`\n', '    function totalSupply() public pure override returns (uint) {\n', '        return _TOTAL_SUPPLY;\n', '    }\n', '\n', '    /// @dev See `ERC20i.balanceOf` \n', '    function balanceOf(address _owner) public view override returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    /// @dev See `ERC20i.allowance` \n', '    function allowance(address _owner, address _spender) public view override returns (uint remaining) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    /// @dev See `IERC20.transfer` \n', '    function transfer(address _to, uint _amount) public override returns (bool success) {\n', '        uint96 amount = safe96(_amount, "DAWG::transfer: amount exceeds 96 bits");\n', '        _transfer(msg.sender, _to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev See `IERC20.approve` \n', '    function approve(address _spender, uint _amount) public override returns (bool success) {\n', '        uint96 amount = safe96(_amount, "DAWG::permit: amount exceeds 96 bits");\n', '\n', '\n', '        _approve(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev `See ERC20i.transferFrom`\n', '    function transferFrom(address _from, address _to, uint _amount) public override returns (bool success) {\n', '        address spender = msg.sender;\n', '        uint96 spenderAllowance = allowances[_from][spender];\n', '        uint96 amount = safe96(_amount, "DAWG::approve: amount exceeds 96 bits");\n', '\n', '        if (spender != _from) {\n', '            uint96 newAllowance = sub96(spenderAllowance, amount, "DAWG::transferFrom: transfer amount exceeds spender allowance");\n', '            allowances[_from][spender] = newAllowance;\n', '\n', '            emit Approval(_from, spender, newAllowance);\n', '        }\n', '        \n', '        _transferTokens(_from, _to, amount);\n', '        return true;\n', '    }\n', '    \n', '    /// @dev Emits an {Approval} event indicating the updated allowance.\n', '    function increaseAllowance(address _spender, uint _addedValue) public returns (bool success) {\n', '        uint96 addAmount = safe96(_addedValue, "DAWG::approve: amount exceeds 96 bits");\n', '        uint96 amount = add96(allowances[msg.sender][_spender], addAmount, "DAWG::increaseAllowance: increase allowance exceeds 96 bits");\n', '       \n', '        allowances[msg.sender][_spender] = amount;\n', '\n', '        emit Approval(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Emits an {Approval} event indicating the updated allowance.\n', '    function decreaseAllowance(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint96 subAmount = safe96(_subtractedValue, "DAWG::approve: amount exceeds 96 bits");\n', '        uint96 amount = sub96(allowances[msg.sender][_spender], subAmount, "DAWG::decreaseAllowance: decrease subAmount > allowance");\n', '        \n', '        allowances[msg.sender][_spender] = amount;\n', '\n', '        emit Approval(msg.sender, _spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /** @dev Token Governance Functions */\n', '    \n', '    /** \n', "    * @notice Allows spender to `spender` on `owner`'s behalf\n", '    * @param owner address that holds tokens\n', "    * @param spender address that spends on `owner`'s behalf\n", '    * @param _amount unsigned integer denoting amount, uncast\n', '    * @param deadline The time at which to expire the signature\n', '    * @param v The recovery byte of the signature\n', '    * @param r Half of the ECDSA signature pair\n', '    * @param s Half of the ECDSA signature pair\n', '     */\n', '    function permit(address owner, address spender, uint _amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n', '        uint96 amount = safe96(_amount, "DAWG::permit: amount exceeds 96 bits");\n', '\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_NAME)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, _amount, nonces[owner]++, deadline));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "DAWG::permit: invalid signature");\n', '        require(signatory == owner, "DAWG::permit: unauthorized");\n', '        require(block.timestamp <= deadline, "DAWG::permit: signature expired");\n', '\n', '        allowances[owner][spender] = amount;\n', '\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /** \n', '     * @notice Delegate votes from `msg.sender` to `delegatee`\n', '     * @param delegatee The address to delegate votes to\n', '    */\n', '    function delegate(address delegatee) public {\n', '        return _delegate(msg.sender, delegatee);\n', '    }\n', '\n', '    /** \n', '     * @notice Delegates votes from signatory to `delegatee`\n', '     * @param delegatee The address to delegate votes to\n', '     * @param nonce The contract state required to match the signature\n', '     * @param expiry The time at which to expire the signature\n', '     * @param v The recovery byte of the signature\n', '     * @param r Half of the ECDSA signature pair\n', '     * @param s Half of the ECDSA signature pair\n', '     */\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_NAME)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        \n', '        address signatory = ecrecover(digest, v, r, s);\n', '\n', '        require(signatory != address(0), "DAWG::delegateBySig: invalid signature");\n', '        require(nonce == nonces[signatory]++, "DAWG::delegateBySig: invalid nonce");\n', '        require(block.timestamp <= expiry, "DAWG::delegateBySig: signature expired");\n', '\n', '        return _delegate(signatory, delegatee);\n', '    }\n', '\n', '    /** \n', '     * @notice Gets the current votes balance for `account`\n', '     * @param account The address to get votes balance\n', '     * @return The number of current votes for `account`\n', '     */\n', '    function getCurrentVotes(address account) external view returns (uint96) {\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n', '    }\n', '\n', '    /** \n', '     * @notice Determine the prior number of votes for an account as of a block number\n', '     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n', '     * @param account The address of the account to check\n', '     * @param blockNumber The block number to get the vote balance at\n', '     * @return The number of votes the account had as of the given block\n', '     */\n', '    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n', '        require(blockNumber < block.number, "DAWG::getPriorVotes: not yet determined");\n', '\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        if (nCheckpoints == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // First check most recent balance\n', '        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n', '            return checkpoints[account][nCheckpoints - 1].votes;\n', '        }\n', '\n', '        // Next check implicit zero balance\n', '        if (checkpoints[account][0].fromBlock > blockNumber) {\n', '            return 0;\n', '        }\n', '\n', '        uint32 lower = 0;\n', '        uint32 upper = nCheckpoints - 1;\n', '        while (upper > lower) {\n', '            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n', '            Checkpoint memory cp = checkpoints[account][center];\n', '            if (cp.fromBlock == blockNumber) {\n', '                return cp.votes;\n', '            } else if (cp.fromBlock < blockNumber) {\n', '                lower = center;\n', '            } else {\n', '                upper = center - 1;\n', '            }\n', '        }\n', '        return checkpoints[account][lower].votes;\n', '    }\n', '    \n', '    /** \n', '    * @notice Delegates votes from `delegator` address to `delegatee`\n', '    * @param delegator The adress that is the delegate\n', '    * @param delegatee The address the delegate votes to\n', '    */\n', '    function _delegate(address delegator, address delegatee) internal {\n', '        address currentDelegate = delegates[delegator];\n', '        uint96 delegatorBalance = balances[delegator];\n', '        delegates[delegator] = delegatee;\n', '\n', '        emit DelegateChanged(delegator, currentDelegate, delegatee);\n', '\n', '        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n', '    }\n', '\n', '\n', '    function _transferTokens(address src, address dst, uint96 amount) internal {\n', '        require(src != address(0), "DAWG::_transferTokens: cannot transfer from the zero address");\n', '        require(dst != address(0), "DAWG::_transferTokens: cannot transfer to the zero address");\n', '\n', '        balances[src] = sub96(balances[src], amount, "DAWG::_transferTokens: transfer amount exceeds balance");\n', '        balances[dst] = add96(balances[dst], amount, "DAWG::_transferTokens: transfer amount overflows");\n', '        emit Transfer(src, dst, amount);\n', '\n', '        _moveDelegates(delegates[src], delegates[dst], amount);\n', '    }\n', '\n', '    \n', '    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n', '        if (srcRep != dstRep && amount > 0) {\n', '            if (srcRep != address(0)) {\n', '                uint32 srcRepNum = numCheckpoints[srcRep];\n', '                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n', '                uint96 srcRepNew = sub96(srcRepOld, amount, "DAWG::_moveVotes: vote amount underflows");\n', '                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n', '            }\n', '\n', '            if (dstRep != address(0)) {\n', '                uint32 dstRepNum = numCheckpoints[dstRep];\n', '                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n', '                uint96 dstRepNew = add96(dstRepOld, amount, "DAWG::_moveVotes: vote amount overflows");\n', '                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n', '            }\n', '        }\n', '    }\n', '\n', '   \n', '    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n', '      uint32 blockNumber = safe32(block.number, "DAWG::_writeCheckpoint: block number exceeds 32 bits");\n', '\n', '      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n', '          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n', '      } else {\n', '          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n', '          numCheckpoints[delegatee] = nCheckpoints + 1;\n', '      }\n', '\n', '      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n', '    }\n', '\n', '    \n', '    function getChainId() internal view returns (uint) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '\n', '    /**\n', '    * @title Internal function equivalents\n', '    */\n', '\n', '    /// @dev Creates number of tokens `_amount` and assigns them to `_account`,\n', '    /// Increases total supply of tokens\n', '    /// Emits a {Transfer} event with _from set to the zero address.\n', '    /// Moves delegates _from the zero address _to the specified address\n', '  /**  function _mint(address _account, uint _amount) internal onlyOwner {\n', '        require(_account != address(0), "ERC20: mint to zero address");\n', '\n', '        uint96 amount = safe96(_amount, "DAWG::mint: amount exceeds 96 bits");\n', '\n', '        _TOTAL_SUPPLY = safe96(SafeMath.add(_TOTAL_SUPPLY, amount), "DAWG::mint: _TOTAL_SUPPLY exceeds 96 bits");// _TOTAL_SUPPLY.add(_amount);\n', '        balances[_account] = add96(balances[_account], amount, "DAWG::mint: transfer amount overflows"); // balances[_account].add(_amount); \n', '        \n', '        emit Transfer(address(0), _account, amount);\n', '\n', '        _moveDelegates(address(0), delegates[_account], amount);\n', '    } */\n', '\n', '    /// @dev Moves tokens `_amount` from `"sender"` to `"recipient"`\n', '    /// Emits a {Transfer} event\n', '    function _transfer(address _from, address _to, uint96 amount) internal {\n', '        require(_from != address(0), "ERC20: cannot transfer from the zero address");\n', '        require(_to != address(0), "ERC20: cannot transfer to the zero address");\n', '\n', '        balances[_from] = sub96(balances[_from], amount, "DAWG::_transferTokens: transfer amount exceeds balance"); // balances[_from].sub(amount);\n', '        balances[_to] = add96(balances[_to], amount, "DAWG::_transferTokens: transfer amount overflows"); // balances[_to].add(amount);\n', '        emit Transfer(_from, _to, amount);\n', '\n', '        _moveDelegates(delegates[_from], delegates[_to], amount);\n', '    }\n', '\n', "    /// @dev Sets given `_amount` as the allowance of a `_spender` for the `_owner`'s tokens.\n", '    //// Emits a {Approval} event\n', '    function _approve(address _owner, address _spender, uint96 amount) internal {\n', '        require(_owner != address(0), "ERC20: approve from the zero address");\n', '        require(_spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        allowances[_owner][_spender] = amount;\n', '        emit Approval(_owner, _spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address _from, address _to, uint _amount) internal virtual { }\n', '\n', '    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n', '        require(n < 2**96, errorMessage);\n', '        return uint96(n);\n', '    }\n', '\n', '    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        uint96 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']