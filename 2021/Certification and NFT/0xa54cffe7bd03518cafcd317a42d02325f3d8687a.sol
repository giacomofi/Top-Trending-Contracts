['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-06\n', '*/\n', '\n', '// Sources flattened with hardhat v2.2.1 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/utils/[email\xa0protected]\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/beacon/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is the interface that {BeaconProxy} expects of its beacon.\n', ' */\n', 'interface IBeaconUpgradeable {\n', '    /**\n', '     * @dev Must return an address that can be used as a delegate call target.\n', '     *\n', '     * {BeaconProxy} will check that this address is a contract.\n', '     */\n', '    function implementation() external view returns (address);\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library AddressUpgradeable {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Library for reading and writing primitive types to specific storage slots.\n', ' *\n', ' * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n', ' * This library helps with reading and writing to such slots without the need for inline assembly.\n', ' *\n', ' * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n', ' *\n', ' * Example usage to set ERC1967 implementation slot:\n', ' * ```\n', ' * contract ERC1967 {\n', ' *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', ' *\n', ' *     function _getImplementation() internal view returns (address) {\n', ' *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n', ' *     }\n', ' *\n', ' *     function _setImplementation(address newImplementation) internal {\n', ' *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n', ' *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n', ' *     }\n', ' * }\n', ' * ```\n', ' *\n', ' * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n', ' */\n', 'library StorageSlotUpgradeable {\n', '    struct AddressSlot {\n', '        address value;\n', '    }\n', '\n', '    struct BooleanSlot {\n', '        bool value;\n', '    }\n', '\n', '    struct Bytes32Slot {\n', '        bytes32 value;\n', '    }\n', '\n', '    struct Uint256Slot {\n', '        uint256 value;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n', '     */\n', '    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n', '     */\n', '    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n', '     */\n', '    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n', '     */\n', '    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/ERC1967/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev This abstract contract provides getters and event emitting update functions for\n', ' * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n', ' *\n', ' * _Available since v4.1._\n', ' *\n', ' * @custom:oz-upgrades-unsafe-allow delegatecall\n', ' */\n', 'abstract contract ERC1967UpgradeUpgradeable is Initializable {\n', '    function __ERC1967Upgrade_init() internal initializer {\n', '        __ERC1967Upgrade_init_unchained();\n', '    }\n', '\n', '    function __ERC1967Upgrade_init_unchained() internal initializer {\n', '    }\n', '    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1\n', '    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '     * @dev Returns the current implementation address.\n', '     */\n', '    function _getImplementation() internal view returns (address) {\n', '        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 implementation slot.\n', '     */\n', '    function _setImplementation(address newImplementation) private {\n', '        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n', '        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade with additional setup call.\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '        if (data.length > 0 || forceCall) {\n', '            _functionDelegateCall(newImplementation, data);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {\n', '        address oldImplementation = _getImplementation();\n', '\n', '        // Initial upgrade and setup call\n', '        _setImplementation(newImplementation);\n', '        if (data.length > 0 || forceCall) {\n', '            _functionDelegateCall(newImplementation, data);\n', '        }\n', '\n', '        // Perform rollback test if not already in progress\n', '        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n', '        if (!rollbackTesting.value) {\n', '            // Trigger rollback using upgradeTo from the new implementation\n', '            rollbackTesting.value = true;\n', '            _functionDelegateCall(\n', '                newImplementation,\n', '                abi.encodeWithSignature(\n', '                    "upgradeTo(address)",\n', '                    oldImplementation\n', '                )\n', '            );\n', '            rollbackTesting.value = false;\n', '            // Check rollback was effective\n', '            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");\n', '            // Finally reset to the new implementation and log the upgrade\n', '            _setImplementation(newImplementation);\n', '            emit Upgraded(newImplementation);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n', '     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n', '     *\n', '     * Emits a {BeaconUpgraded} event.\n', '     */\n', '    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n', '        _setBeacon(newBeacon);\n', '        emit BeaconUpgraded(newBeacon);\n', '        if (data.length > 0 || forceCall) {\n', '            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '     * @dev Emitted when the admin account has changed.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Returns the current admin.\n', '     */\n', '    function _getAdmin() internal view returns (address) {\n', '        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 admin slot.\n', '     */\n', '    function _setAdmin(address newAdmin) private {\n', '        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n', '        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     *\n', '     * Emits an {AdminChanged} event.\n', '     */\n', '    function _changeAdmin(address newAdmin) internal {\n', '        emit AdminChanged(_getAdmin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n', "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n", '     */\n', '    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n', '\n', '    /**\n', '     * @dev Emitted when the beacon is upgraded.\n', '     */\n', '    event BeaconUpgraded(address indexed beacon);\n', '\n', '    /**\n', '     * @dev Returns the current beacon.\n', '     */\n', '    function _getBeacon() internal view returns (address) {\n', '        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new beacon in the EIP1967 beacon slot.\n', '     */\n', '    function _setBeacon(address newBeacon) private {\n', '        require(\n', '            AddressUpgradeable.isContract(newBeacon),\n', '            "ERC1967: new beacon is not a contract"\n', '        );\n', '        require(\n', '            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n', '            "ERC1967: beacon implementation is not a contract"\n', '        );\n', '        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n', '    }\n', '\n', '    /*\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n', '        require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Base contract for building openzeppelin-upgrades compatible implementations for the {ERC1967Proxy}. It includes\n', ' * publicly available upgrade functions that are called by the plugin and by the secure upgrade mechanism to verify\n', ' * continuation of the upgradability.\n', ' *\n', ' * The {_authorizeUpgrade} function MUST be overridden to include access restriction to the upgrade mechanism.\n', ' *\n', ' * _Available since v4.1._\n', ' */\n', 'abstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n', '    function __UUPSUpgradeable_init() internal initializer {\n', '        __ERC1967Upgrade_init_unchained();\n', '        __UUPSUpgradeable_init_unchained();\n', '    }\n', '\n', '    function __UUPSUpgradeable_init_unchained() internal initializer {\n', '    }\n', '    function upgradeTo(address newImplementation) external virtual {\n', '        _authorizeUpgrade(newImplementation);\n', '        _upgradeToAndCallSecure(newImplementation, bytes(""), false);\n', '    }\n', '\n', '    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n', '        _authorizeUpgrade(newImplementation);\n', '        _upgradeToAndCallSecure(newImplementation, data, true);\n', '    }\n', '\n', '    function _authorizeUpgrade(address newImplementation) internal virtual;\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/access/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '// File contracts/VotingShare.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', 'struct LockAmount {\n', '    uint256 unlockTime;\n', '    uint256 amount;\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'interface ITun {\n', '    function borPledgeInfo(address user) external view returns (uint256);\n', '\n', '    function lockInfo(address user, uint256 index)\n', '        external\n', '        view\n', '        returns (LockAmount memory);\n', '\n', '    function userLockLength(address account) external view returns (uint256);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '}\n', '\n', 'contract VotingShare is UUPSUpgradeable, OwnableUpgradeable {\n', '    IERC20 constant bor = IERC20(0x3c9d6c1C73b31c837832c72E04D3152f051fc1A9);\n', '    IERC20 constant boring = IERC20(0xBC19712FEB3a26080eBf6f2F7849b417FdD792CA);\n', '    // ITun constant tunnel = ITun(0x258a1eb6537Ae84Cf612f06B557B6d53f49cC9A1);\n', '    // goldRush contract for boring\n', '    IERC20 constant gr = IERC20(0xd54D2e3024D5E5Cabab32770b3ab2601139Aba56);\n', '\n', '    IUniswapV2Pair constant uniBor =\n', '        IUniswapV2Pair(0xc9ca10d36441B5b45d5E63480139105f037972e0);\n', '    IUniswapV2Pair constant sushiBor =\n', '        IUniswapV2Pair(0x44D34985826578e5ba24ec78c93bE968549BB918);\n', '\n', '    ITun[] public tunnels;\n', '\n', '    function _authorizeUpgrade(address) internal override onlyOwner {}\n', '\n', '    function initialize(address[] memory _tunnels) public initializer {\n', '        for (uint256 i; i < _tunnels.length; i++) {\n', '            tunnels.push(ITun(_tunnels[i]));\n', '        }\n', '    }\n', '\n', '    function addTunnel(address _tunnel) external onlyOwner {\n', '        tunnels.push(ITun(_tunnel));\n', '    }\n', '\n', '    function decimals() external pure returns (uint8) {\n', '        return uint8(18);\n', '    }\n', '\n', '    function name() external pure returns (string memory) {\n', '        return "BoringDAO Voting Share";\n', '    }\n', '\n', '    function symbol() external pure returns (string memory) {\n', '        return "BoringDAO VS";\n', '    }\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        return bor.totalSupply();\n', '    }\n', '\n', '    function uni(address account) public view returns (uint256) {\n', '        (uint112 borAmount, , ) = uniBor.getReserves();\n', '        uint256 lpAccount = uniBor.balanceOf(account);\n', '        uint256 lpTotal = uniBor.totalSupply();\n', '        return (uint256(borAmount) * lpAccount) / lpTotal;\n', '    }\n', '\n', '    function sushi(address account) public view returns (uint256) {\n', '        (uint112 borAmount, , ) = sushiBor.getReserves();\n', '        uint256 lpAccount = sushiBor.balanceOf(account);\n', '        uint256 lpTotal = sushiBor.totalSupply();\n', '        return (uint256(borAmount) * lpAccount) / lpTotal;\n', '    }\n', '\n', '    function tunnelBor(address _voter) public view returns (uint256) {\n', '        uint totalBor;\n', '        for (uint256 j; j < tunnels.length; j++) {\n', '            ITun tunnel = tunnels[j];\n', '            uint256 bor2 = tunnel.borPledgeInfo(_voter);\n', '            uint256 lock;\n', '            uint256 unlock;\n', '            for (uint256 i; i < tunnel.userLockLength(_voter); i++) {\n', '                if (block.timestamp >= tunnel.lockInfo(_voter, i).unlockTime) {\n', '                    unlock = unlock + tunnel.lockInfo(_voter, i).amount;\n', '                } else {\n', '                    lock = lock + tunnel.lockInfo(_voter, i).amount;\n', '                }\n', '            }\n', '            totalBor = totalBor + bor2 + lock + unlock;\n', '        }\n', '        return totalBor * 10000;\n', '    }\n', '\n', '    function goldRush(address _voter) public view returns (uint) {\n', '        return gr.balanceOf(_voter);\n', '    }\n', '\n', '    function balanceOf(address _voter) external view returns (uint256) {\n', '        // uint256 bor1 = bor.balanceOf(_voter) / 2;\n', '        uint boring1 = boring.balanceOf(_voter);\n', '        uint256 bor2 = tunnelBor(_voter);\n', '        uint boring2 = goldRush(_voter);    \n', '        // uint256 bor3 = uni(_voter);\n', '        // uint256 bor4 = sushi(_voter);\n', '\n', '        return boring1+bor2+boring2;\n', '    }\n', '}']