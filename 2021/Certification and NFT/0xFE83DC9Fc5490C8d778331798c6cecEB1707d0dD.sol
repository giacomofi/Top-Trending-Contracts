['"""\n', '@title Greenwood Treasury\n', '@notice Treasury contract for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', '# define the events emitted by the contract\n', 'event Fallback:\n', '    value: uint256\n', '    sender: address\n', '    blockNumber: uint256\n', '    \n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', 'event TransferERC20:\n', '    amount: uint256\n', '    asset: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', 'event TransferETH:\n', '    value: uint256\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', '# define the storage variables used by the contract\n', 'registry: public(address)\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isGovernance(_caller: address, _role: String[20]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @return True if the caller is the Governance, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "governance"\n', '    if keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison\n', '        return governance == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '@external\n', '@nonreentrant("erc20_lock")\n', 'def transferERC20(_amount: uint256, _asset: address):\n', '    """\n', '    @notice Transfers ERC20 tokens to the Governance\n', "    @param _amount The amount of asset to transfer scaled by the asset's decimals\n", '    @param _asset The underlying address of the asset to transfer\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isGovernance(msg.sender, "governance") == True, "Only Governance can call this method"\n', '\n', '    # get the address of the Governance from the Registry\n', '    to: address = REGISTRY(self.registry).governance()\n', '\n', '    # require that the Governance is not the zero address\n', '    assert to != ZERO_ADDRESS\n', '\n', '    # transfer collected fees to the Governance\n', '    transferResponse: Bytes[32] = raw_call(\n', '        _asset,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(to, bytes32),\n', '            convert(_amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(transferResponse) > 0:\n', '        assert convert(transferResponse, bool), "Failed safeTransfer"\n', '\n', '    # emit a TransferERC20 event\n', '    log TransferERC20(_amount, _asset, to, block.number)\n', '\n', '    \n', '@external\n', '@nonreentrant("eth_lock")\n', 'def transferETH(_amount: uint256):\n', '    """\n', '    @notice Transfers ETH to the Governance\n', '    @param _amount The amount of ETH to transfer in wei\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isGovernance(msg.sender, "governance") == True, "Only Governance can call this method"\n', '\n', '    # get the address of the Governance from the Registry\n', '    to: address = REGISTRY(self.registry).governance()\n', '\n', '    # require that the Governance is not the zero address\n', '    assert to != ZERO_ADDRESS\n', '\n', '    # send fees collected in ETH to the governance\n', '    send(to, _amount)\n', '\n', '    # emit a TransferETH event\n', '    log TransferETH(_amount, to, block.number)\n', '\n', '@external\n', '@nonreentrant("registry_lock")\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isGovernance(msg.sender, "governance") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    """\n', '    @notice Fallback function for receiving ETH\n', '    """\n', '\n', '    log Fallback(msg.value, msg.sender, block.number)']