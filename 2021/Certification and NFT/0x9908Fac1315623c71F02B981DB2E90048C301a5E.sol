['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./BalanceLimitable.sol";\n', 'import "./Blacklistable.sol";\n', 'import "./IERC20.sol";\n', 'import "./Pausable.sol";\n', 'import "./Peggable.sol";\n', 'import "./Taxable.sol";\n', 'import "./AccessControlUpgradeable.sol";\n', 'import "./OwnableUpgradeable.sol";\n', 'import "./ERC20Upgradeable.sol";\n', '\n', 'contract Token is ERC20Upgradeable, OwnableUpgradeable, AccessControlUpgradeable, PeggableToken, BalanceLimitableToken, BlacklistableToken, PausableToken, TaxableToken {\n', '    using SafeMathUpgradeable for uint256;\n', '\n', "    /// @notice EIP-712 typehash for contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\n', '        "EIP712Domain(string name,uint256 chainId,address verifyingContract)"\n', '    );\n', '    /// @notice EIP-712 typehash for the structured hash used by `permit`\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256(\n', '        "Permit(address designator,address spender,uint256 amount,bytes32 nonce,uint256 deadline)"\n', '    );\n', '    /// @notice EIP-712 typehash for the structured hash used by `transferPresigned`\n', '    bytes32 public constant TRANSFER_PRESIGNED_TYPEHASH = keccak256(\n', '        "TransferPresigned(address sender,address recipient,uint256 amount,bytes32 nonce,uint256 deadline)"\n', '    );\n', '\n', '    /// @notice Role for access control\n', '    bytes32 public constant TOKEN_CUSTODIAN_ROLE = keccak256("TOKEN_CUSTODIAN_ROLE");\n', '\n', '    /// @notice Record of single-used nonces for `permit` and `transferPresigned` operations\n', '    mapping (address => mapping (bytes32 => bool)) private _permitNonces;\n', '    mapping (address => mapping (bytes32 => bool)) private _transferPresignedNonces;\n', '\n', '    /// @notice Number of decimals\n', '    uint8 _decimals;\n', '\n', '    /**\n', '     * @dev Initialises the token contract\n', '     */\n', '    function initialize(\n', '        string memory name_,\n', '        string memory symbol_,\n', '        uint8 decimals_,\n', '        address peggedToken,\n', '        uint256 balanceLimit_,\n', '        uint256 taxPercentage_\n', '    ) public initializer {\n', '        address self = address(this);\n', '        initialize(name_, symbol_, decimals_, peggedToken, self, balanceLimit_, self, taxPercentage_);\n', '    }\n', '\n', '    /**\n', '     * @dev Initialises the token contract\n', '     */\n', '    function initialize(\n', '        string memory name_,\n', '        string memory symbol_,\n', '        uint8 decimals_,\n', '        address peggedToken,\n', '        address mintingBeneficiary_,\n', '        uint256 balanceLimit_,\n', '        address taxBeneficiary_,\n', '        uint256 taxPercentage_\n', '    ) public initializer {\n', '        __ERC20_init(name_, symbol_);\n', '        __Ownable_init();\n', '        __AccessControl_init_unchained();\n', '\n', '        __Token_init_unchained(decimals_);\n', '        __Peggable_init_unchained(peggedToken, mintingBeneficiary_);\n', '        __BalanceLimitableToken_init_unchained(balanceLimit_);\n', '        __Paused_init_unchained();\n', '        __TaxableToken_init_unchained(taxBeneficiary_, taxPercentage_);\n', '\n', '        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n', '        initializeBeneficiaryPrivileges();\n', '    }\n', '\n', '    function __Token_init_unchained(uint8 decimals_) internal initializer {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets up the necessary roles and grants the beneficiaries sensible privileges\n', '     */\n', '    function initializeBeneficiaryPrivileges() internal initializer {\n', '        _addBalanceBypasser(mintingBeneficiary());\n', '        _addBalanceBypasser(taxBeneficiary());\n', '    }\n', '\n', '    /**\n', '     * @dev Allow only the addresses with the TOKEN_CUSTODIAN_ROLE privileges\n', '     */\n', '    modifier onlyTokenCustodian() {\n', '        _checkRole(TOKEN_CUSTODIAN_ROLE, _msgSender());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke balance limit bypass privileges from `exBypasser`\n', '     */\n', '    function addBalanceBypasser(address bypasser) public override notPaused onlyBalanceLimiter {\n', '        super.addBalanceBypasser(bypasser);\n', '    }\n', '\n', '    /**\n', '     * @dev Allow `spender` to transfer up to `amount` tokens\n', '     */\n', '    function approve(address spender, uint256 amount) public override notPaused returns (bool) {\n', '        return super.approve(spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Add `convict` to the blacklist\n', '     */\n', '    function blacklist(address convict) public override notPaused onlyBlacklister {\n', '        super.blacklist(convict);\n', '    }\n', '\n', '    /**\n', "     * @dev Burn the sender's tokens and return them the equivalent in the pegged token\n", '     */\n', '    function burn(uint256 amount) public override notBlacklisted notPaused {\n', '        super.burn(amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the minting beneficiary and add the new beneficiary to the balance bypass list\n', '     */\n', '    function changeMintingBeneficiary(address newBeneficiary) public override notPaused onlyBeneficiaryManager {\n', '        _changeMintingBeneficiary(newBeneficiary);\n', '        _addBalanceBypasser(newBeneficiary);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimal places for the contract\n', '     */\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public override notPaused returns (bool) {\n', '        return super.decreaseAllowance(spender, subtractedValue);\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     */\n', '    function grantRole(bytes32 role, address account) public override notPaused onlyRole(getRoleAdmin(role)) {\n', '        super.grantRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public override notPaused returns (bool) {\n', '        return super.increaseAllowance(spender, addedValue);\n', '    }\n', '\n', '    /**\n', '     * @dev Mint `amount` tokens and send them to `recipient`\n', '     */\n', '    function mint(address recipient, uint256 amount) public override notBlacklisted notPaused {\n', '        _mint(recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Validate and execute a pre-signed `allowance` operation\n', '     */\n', '    function permit(\n', '        address designator,\n', '        address spender,\n', '        uint256 amount,\n', '        bytes32 nonce,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public notPaused returns (bool) {\n', '        _permit(designator, spender, amount, nonce, deadline, v, r, s);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if the given address and nonce pair have been used for `permit` operations\n', '     */\n', '    function permitNonceUsed(address designator, bytes32 nonce) public view returns (bool) {\n', '        return _permitNonces[designator][nonce];\n', '    }\n', '\n', '    /**\n', '     * @dev Revoke balance limit bypass privileges from `exBypasser`\n', '     */\n', '    function removeBalanceBypasser(address exBypasser) public override onlyBalanceLimiter notPaused {\n', '        super.removeBalanceBypasser(exBypasser);\n', '    }\n', '\n', '    /**\n', '     * @dev Disable the ability to renounce ownership\n', '     */\n', '    function renounceOwnership() public virtual override onlyOwner {\n', '        revert("disabled");\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from the calling account.\n', '     */\n', '    function renounceRole(bytes32 role, address account) public override notPaused {\n', '        super.renounceRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from `account`.\n', '     */\n', '    function revokeRole(bytes32 role, address account) public override notPaused onlyRole(getRoleAdmin(role)) {\n', '        super.revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the max allowed balance\n', '     */\n', '    function setBalanceLimit(uint256 newBalanceLimit) public override notPaused onlyBalanceLimiter {\n', '        super.setBalanceLimit(newBalanceLimit);\n', '    }\n', '\n', '    /**\n', '     * @dev Change the beneficiary\n', '     */\n', '    function setTaxBeneficiary(address newBeneficiary) public override notPaused onlyTaxManager {\n', '        super.setTaxBeneficiary(newBeneficiary);\n', '        _addBalanceBypasser(newBeneficiary);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the tax percentage\n', '     */\n', '    function setTaxPercentage(uint256 newPercentage) public override notPaused onlyTaxManager {\n', '        super.setTaxPercentage(newPercentage);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer `amount` tokens to `recipient` from caller\n', '     */\n', '    function transfer(address recipient, uint256 amount) public override notBlacklisted notPaused returns (bool) {\n', '        return super.transfer(recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer `amount` tokens from `sender` to `recipient`\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public override notBlacklisted notPaused returns (bool) {\n', '        return super.transferFrom(sender, recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer `amount` tokens for contract `token` to `recipient`\n', '     */\n', '    function transferERC20Token(\n', '        address token,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public notPaused onlyTokenCustodian returns (bool) {\n', '        IERC20(token).transfer(recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Validate and execute a pre-signed `transfer` operation\n', '     */\n', '    function transferPresigned(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount,\n', '        bytes32 nonce,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public notPaused returns (bool) {\n', '        _transferPresigned(sender, recipient, amount, nonce, deadline, v, r, s);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if the given address and nonce pair have been used for `transferPresigned` operations\n', '     */\n', '    function transferPresignedNonceUsed(address sender, bytes32 nonce) public view returns (bool) {\n', '        return _transferPresignedNonces[sender][nonce];\n', '    }\n', '\n', '    /**\n', '     * @dev Remove `parolee` from the blacklist\n', '     */\n', '    function unblacklist(address parolee) public override notPaused onlyBlacklister {\n', '        super.unblacklist(parolee);\n', '    }\n', '\n', '    /**\n', '     * @dev Override `_approve` for method resolution\n', '     */\n', '    function _approve(\n', '        address designator,\n', '        address spender,\n', '        uint256 amount\n', '    ) internal virtual override (ERC20Upgradeable, PausableToken) {\n', '        PausableToken._approve(designator, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Pre-transfer hook for running validation.\n', '     *\n', '     * Overridden to perform validation in the most sensible order.\n', '     */\n', '    function _beforeTokenTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal override (ERC20Upgradeable, BalanceLimitableToken, BlacklistableToken, PausableToken) {\n', '        // avoid calling this to save gas and rely on the modifiers instead\n', '        // PausableToken._beforeTokenTransfer(from, to, amount);\n', '\n', '        BlacklistableToken._beforeTokenTransfer(from, to, amount);\n', '        BalanceLimitableToken._beforeTokenTransfer(from, to, amount);\n', '        ERC20Upgradeable._beforeTokenTransfer(from, to, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current chain ID.\n', '     */\n', '    function _getChainId() internal view returns (uint256) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '\n', '    /**\n', '     * @dev Mint `amount` tokens and send them to the sender\n', '     */\n', '    function _mint(\n', '        address recipient,\n', '        uint256 amount\n', '    ) internal override (ERC20Upgradeable, PeggableToken) notBlacklisted notPaused {\n', '        PeggableToken._mint(recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Validate and execute a pre-signed `allowance` operation\n', '     *\n', '     * The `allowance` operation can be carried out by another party by utilising the `permit` function, as long as the\n', '     * address owner themselves have signed a structured hash containing the details necessary for execution.\n', '     */\n', '    function _permit(\n', '        address designator,\n', '        address spender,\n', '        uint256 amount,\n', '        bytes32 nonce,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) internal {\n', '        require(!permitNonceUsed(designator, nonce), "nonce used");\n', '\n', '        bytes32 domainSeparator = keccak256(\n', '            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), _getChainId(), address(this))\n', '        );\n', '        bytes32 structHash = keccak256(\n', '            abi.encode(\n', '                PERMIT_TYPEHASH,\n', '                designator,\n', '                spender,\n', '                amount,\n', '                nonce,\n', '                deadline\n', '            )\n', '        );\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        _validateSignature(designator, digest, v, r, s, deadline, "permit");\n', '\n', '        _permitNonces[designator][nonce] = true;\n', '        _approve(designator, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Validate and execute a pre-signed `transfer` operation\n', '     *\n', '     * The `transfer` operation can be carried out by another party by utilising the `transferPresigned` function, as\n', '     * long as the address owner themselves have signed a structured hash containing the details necessary for\n', '     * execution.\n', '     */\n', '    function _transferPresigned(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount,\n', '        bytes32 nonce,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) internal {\n', '        require(!transferPresignedNonceUsed(sender, nonce), "nonce used");\n', '\n', '        bytes32 domainSeparator = keccak256(\n', '            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), _getChainId(), address(this))\n', '        );\n', '        bytes32 structHash = keccak256(\n', '            abi.encode(\n', '                TRANSFER_PRESIGNED_TYPEHASH,\n', '                sender,\n', '                recipient,\n', '                amount,\n', '                nonce,\n', '                deadline\n', '            )\n', '        );\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        _validateSignature(sender, digest, v, r, s, deadline, "transferPresigned");\n', '\n', '        _transferPresignedNonces[sender][nonce] = true;\n', '        _transferTaxable(sender, recipient, amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Validates a signature\n', '     *\n', '     * Given a signature (made up of the (v, r, s) tuple) and the original message digest, this function recovers the\n', '     * address of the original signatory. The address of the original signatory is compared against the given signatory\n', '     * and the deadline is checked to ensure that the signature has not expired. The validation fails if either\n', '     * condition is not fulfilled.\n', '     */\n', '    function _validateSignature(\n', '        address sender,\n', '        bytes32 digest,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint256 deadline,\n', '        string memory caller\n', '    ) internal view returns (address) {\n', '        require(block.timestamp <= deadline, string(abi.encodePacked(caller, ": signature expired")));\n', '\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), string(abi.encodePacked(caller, ": invalid signature")));\n', '        require(signatory == sender, string(abi.encodePacked(caller, ": unauthorized")));\n', '\n', '        return signatory;\n', '    }\n', '}']