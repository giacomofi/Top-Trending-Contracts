['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-18\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n', ' */\n', 'contract Ownable {\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    address payable public owner;\n', '\n', '    /**\n', '     * @dev Returns the address of the current pending owner.\n', '     */\n', '    address payable public pendingOwner;\n', '\n', '    event NewOwner(address indexed previousOwner, address indexed newOwner);\n', '    event NewPendingOwner(\n', '        address indexed oldPendingOwner,\n', '        address indexed newPendingOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "onlyOwner: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal {\n', '        owner = msg.sender;\n', '        emit NewOwner(address(0), msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n', '     * @param newPendingOwner New pending owner.\n', '     *\n', '     * TODO: Maybe the new pending owenr should not be the current owner at the same time.\n', '     */\n', '    function _setPendingOwner(address payable newPendingOwner)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            newPendingOwner != address(0),\n', '            "_setPendingOwner: New owenr can not be zero address!"\n', '        );\n', '        require(\n', '            newPendingOwner != pendingOwner,\n', '            "_setPendingOwner: This owner has been set!"\n', '        );\n', '\n', '        // Gets current owner.\n', '        address oldPendingOwner = pendingOwner;\n', '\n', '        // Sets new pending owner.\n', '        pendingOwner = newPendingOwner;\n', '\n', '        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Accepts the admin rights, but only for pendingOwenr.\n', '     */\n', '    function _acceptOwner() external {\n', '        require(\n', '            msg.sender == pendingOwner,\n', '            "_acceptOwner: Only for pending owner!"\n', '        );\n', '\n', '        // Gets current values for events.\n', '        address oldOwner = owner;\n', '        address oldPendingOwner = pendingOwner;\n', '\n', '        // Set the new contract owner.\n', '        owner = pendingOwner;\n', '\n', '        // Clear the pendingOwner.\n', '        pendingOwner = address(0);\n', '\n', '        emit NewOwner(oldOwner, owner);\n', '        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "ds-math-div-overflow");\n', '        z = x / y;\n', '    }\n', '}\n', '\n', 'library SafeRatioMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant BASE = 10**18;\n', '\n', '    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x.mul(y).div(BASE);\n', '    }\n', '\n', '    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x.mul(BASE).div(y);\n', '    }\n', '\n', '    function rpow(\n', '        uint256 x,\n', '        uint256 n,\n', '        uint256 base\n', '    ) internal pure returns (uint256 z) {\n', '        assembly {\n', '            switch x\n', '                case 0 {\n', '                    switch n\n', '                        case 0 {\n', '                            z := base\n', '                        }\n', '                        default {\n', '                            z := 0\n', '                        }\n', '                }\n', '                default {\n', '                    switch mod(n, 2)\n', '                        case 0 {\n', '                            z := base\n', '                        }\n', '                        default {\n', '                            z := x\n', '                        }\n', '                    let half := div(base, 2) // for rounding.\n', '\n', '                    for {\n', '                        n := div(n, 2)\n', '                    } n {\n', '                        n := div(n, 2)\n', '                    } {\n', '                        let xx := mul(x, x)\n', '                        if iszero(eq(div(xx, x), x)) {\n', '                            revert(0, 0)\n', '                        }\n', '                        let xxRound := add(xx, half)\n', '                        if lt(xxRound, xx) {\n', '                            revert(0, 0)\n', '                        }\n', '                        x := div(xxRound, base)\n', '                        if mod(n, 2) {\n', '                            let zx := mul(z, x)\n', '                            if and(\n', '                                iszero(iszero(x)),\n', '                                iszero(eq(div(zx, x), z))\n', '                            ) {\n', '                                revert(0, 0)\n', '                            }\n', '                            let zxRound := add(zx, half)\n', '                            if lt(zxRound, zx) {\n', '                                revert(0, 0)\n', '                            }\n', '                            z := div(zxRound, base)\n', '                        }\n', '                    }\n', '                }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external;\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    // This function is not a standard ERC20 interface, just for compitable with market.\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'interface IInterestRateModel {\n', '    function blocksPerYear() external view returns (uint256);\n', '}\n', '\n', 'interface IPriceOracle {\n', '    /**\n', '     * @notice Get the underlying price of a iToken asset\n', '     * @param _iToken The iToken to get the underlying price of\n', '     * @return The underlying asset price mantissa (scaled by 1e18).\n', '     *  Zero means the price is unavailable.\n', '     */\n', '    function getUnderlyingPrice(IiToken _iToken)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', '     * @notice Get the price of a underlying asset\n', '     * @param _iToken The iToken to get the underlying price of\n', '     * @return The underlying asset price mantissa (scaled by 1e18).\n', '     *  Zero means the price is unavailable and whether the price is valid.\n', '     */\n', '    function getUnderlyingPriceAndStatus(IiToken _iToken)\n', '        external\n', '        view\n', '        returns (uint256, bool);\n', '    function getAssetPriceStatus(IiToken _iToken) external view returns (bool);\n', '}\n', '\n', 'interface IRewardDistributor {\n', '    function updateDistributionState(IiToken _iToken, bool _isBorrow) external;\n', '\n', '    function updateReward(\n', '        IiToken _iToken,\n', '        address _account,\n', '        bool _isBorrow\n', '    ) external;\n', '\n', '    function updateRewardBatch(\n', '        address[] memory _holders,\n', '        IiToken[] memory _iTokens\n', '    ) external;\n', '\n', '    function reward(address _account) external view returns (uint256);\n', '}\n', '\n', 'interface IController {\n', '    function getAlliTokens() external view returns (IiToken[] memory);\n', '\n', '    function getEnteredMarkets(address _account)\n', '        external\n', '        view\n', '        returns (IiToken[] memory);\n', '    \n', '    function getBorrowedAssets(address _account) external view returns (IiToken[] memory);\n', '\n', '    function hasEnteredMarket(address _account, IiToken _iToken)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function hasBorrowed(address _account, IiToken _iToken)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function priceOracle() external view returns (IPriceOracle);\n', '\n', '    function markets(IiToken _asset)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool,\n', '            bool,\n', '            bool\n', '        );\n', '\n', '    function calcAccountEquity(address _account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function beforeRedeem(\n', '        address iToken,\n', '        address redeemer,\n', '        uint256 redeemAmount\n', '    ) external returns (bool);\n', '\n', '    function closeFactorMantissa() external view returns (uint256);\n', '\n', '    function liquidationIncentiveMantissa() external view returns (uint256);\n', '\n', '    function rewardDistributor() external view returns (address);\n', '}\n', '\n', 'interface IiToken {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function balanceOf(address _account) external view returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function isSupported() external view returns (bool);\n', '    \n', '    function isiToken() external view returns (bool);\n', '\n', '    function underlying() external view returns (IERC20);\n', '\n', '    function getCash() external view returns (uint256);\n', '\n', '    function supplyRatePerBlock() external view returns (uint256);\n', '\n', '    function borrowRatePerBlock() external view returns (uint256);\n', '\n', '    function balanceOfUnderlying(address _account) external returns (uint256);\n', '\n', '    function borrowBalanceStored(address _account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function borrowBalanceCurrent(address _account) external returns (uint256);\n', '\n', '    function totalBorrowsCurrent() external returns (uint256);\n', '\n', '    function totalBorrows() external view returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256);\n', '\n', '    function exchangeRateCurrent() external returns (uint256);\n', '\n', '    function updateInterest() external returns (bool);\n', '\n', '    function interestRateModel() external view returns (IInterestRateModel);\n', '}\n', '\n', 'contract LendingDataV2 is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeRatioMath for uint256;\n', '    bool private initialized;\n', '\n', '    uint256 constant BASE = 1e18;\n', '\n', '    uint256 public blocksPerYear;\n', '    uint256 constant daysPerYear = 365;\n', '\n', '    IController public controller;\n', '    IiToken public priceToken;\n', '\n', '    IiToken[] public tokens;\n', '    uint256[] public amounts;\n', '    uint8[] public decimals;\n', '\n', '    constructor(\n', '        address _controller,\n', '        IiToken _priceToken\n', '    ) public {\n', '        initialize(_controller, _priceToken);\n', '    }\n', '\n', '    function initialize(\n', '        address _controller,\n', '        IiToken _priceToken\n', '    ) public {\n', '        require(!initialized, "initialize: Already initialized!");\n', '        __Ownable_init();\n', '        controller = IController(_controller);\n', '        priceToken = _priceToken;\n', '        initialized = true;\n', '    }\n', '\n', '    function setController(IController _newController) external onlyOwner {\n', '        // Sets to new controller.\n', '        controller = _newController;\n', '    }\n', '\n', '    function setPriceToken(IiToken _newAsset) external onlyOwner {\n', '        priceToken = _newAsset;\n', '    }\n', '\n', '    struct totalValueLocalVars {\n', '        IiToken[] iTokens;\n', '        IController controller;\n', '        IPriceOracle priceOracle;\n', '        uint256 assetPrice;\n', '        uint256 collateralFactor;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 supplyValue;\n', '        uint256 collateralVaule;\n', '        uint256 borrowValue;\n', '    }\n', '\n', '    function getAccountTotalValue(address _account)\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        totalValueLocalVars memory _var;\n', '        _var.controller = controller;\n', '        _var.iTokens = _var.controller.getAlliTokens();\n', '        _var.priceOracle = _var.controller.priceOracle();\n', '        for (uint256 i = 0; i < _var.iTokens.length; i++) {\n', '            _var.assetPrice = _var.priceOracle.getUnderlyingPrice(\n', '                _var.iTokens[i]\n', '            );\n', '            _var.supplyValue = _var.supplyValue.add(\n', '                _var.iTokens[i].balanceOfUnderlying(_account).mul(\n', '                    _var.assetPrice\n', '                )\n', '            );\n', '            (_var.collateralFactor, , , , , , ) = controller.markets(_var.iTokens[i]);\n', '            if (\n', '                _var.controller.hasEnteredMarket(_account, _var.iTokens[i]) &&\n', '                _var.collateralFactor > 0\n', '            )\n', '                _var.collateralVaule = _var.collateralVaule.add(\n', '                    _var.iTokens[i].balanceOfUnderlying(_account).mul(\n', '                        _var.assetPrice\n', '                    )\n', '                );\n', '\n', '            if (_var.controller.hasBorrowed(_account, _var.iTokens[i]))\n', '                _var.borrowValue = _var.borrowValue.add(\n', '                    _var.iTokens[i].borrowBalanceCurrent(_account).mul(\n', '                        _var.assetPrice\n', '                    )\n', '                );\n', '        }\n', '        _var.assetPrice = getAssetUSDPrice(priceToken);\n', '        if (_var.assetPrice == 0) return (0, 0, 0, 0);\n', '\n', '        _var.supplyValue = _var.supplyValue.div(_var.assetPrice);\n', '        _var.collateralVaule = _var.collateralVaule.div(_var.assetPrice);\n', '        _var.borrowValue = _var.borrowValue.div(_var.assetPrice);\n', '        (, , _var.sumCollateral, _var.sumBorrowed) = calcAccountEquity(_account);\n', '        return (\n', '            _var.supplyValue,\n', '            _var.collateralVaule,\n', '            _var.borrowValue,\n', '            _var.sumBorrowed == 0 ? 0 : _var.sumCollateral.rdiv(_var.sumBorrowed)\n', '        );\n', '    }\n', '\n', '    function getAccountAssetStatus(IiToken _asset, address _account, uint256 _type) internal returns (bool, uint256) {\n', '        uint256 _balance;\n', '        if (_type == 0) {\n', '            _balance = _asset.balanceOfUnderlying(_account);\n', '            return ( _balance == 0 ? false : true, _balance);\n', '        }\n', '\n', '        bool _isiToken = _asset.isiToken();\n', '        if ((_type & 1 > 0 && _isiToken) || (_type & 2 > 0 && !_isiToken))\n', '            _balance = _asset.borrowBalanceCurrent(_account);\n', '\n', '        return ( _balance == 0 ? false : true, _balance);\n', '    }\n', '\n', '    function getAccountAssets(address _account, uint256 _type)\n', '        internal\n', '        returns (\n', '            IiToken[] memory,\n', '            uint256[] memory,\n', '            uint8[] memory\n', '        )\n', '    {\n', '        delete tokens;\n', '        delete amounts;\n', '        delete decimals;\n', '        uint256 _balance;\n', '        bool _status;\n', '        IiToken[] memory _iTokens = controller.getAlliTokens();\n', '        for (uint256 i = 0; i < _iTokens.length; i++) {\n', '            (_status, _balance) = getAccountAssetStatus(_iTokens[i], _account, _type);\n', '            if (_status) {\n', '                tokens.push(_iTokens[i]);\n', '                amounts.push(_balance);\n', '                decimals.push(_iTokens[i].decimals());\n', '            }\n', '        }\n', '\n', '        return (tokens, amounts, decimals);\n', '    }\n', '\n', '    \n', '    function getAccountSupplyTokens(address _account)\n', '        public\n', '        returns (\n', '            IiToken[] memory,\n', '            uint256[] memory,\n', '            uint8[] memory\n', '        )\n', '    {\n', '        return getAccountAssets(_account, 0);\n', '    }\n', '\n', '    function getAccountBorrowTokens(address _account)\n', '        public\n', '        returns (\n', '            IiToken[] memory,\n', '            uint256[] memory,\n', '            uint8[] memory\n', '        )\n', '    {\n', '        return getAccountAssets(_account, 1);\n', '    }\n', '\n', '    function getAccountMSDTokens(address _account)\n', '        public\n', '        returns (\n', '            IiToken[] memory,\n', '            uint256[] memory,\n', '            uint8[] memory\n', '        )\n', '    {\n', '        return getAccountAssets(_account, 2);\n', '    }\n', '\n', '    function getAccountTokens(address _account)\n', '        external\n', '        returns (\n', '            IiToken[] memory _supplyTokens,\n', '            uint256[] memory _supplyAmounts,\n', '            uint8[] memory _supplyDecimals,\n', '            IiToken[] memory _borrowTokens,\n', '            uint256[] memory _borrowAmounts,\n', '            uint8[] memory _borrowDecimals\n', '        )\n', '    {\n', '        (\n', '            _supplyTokens,\n', '            _supplyAmounts,\n', '            _supplyDecimals\n', '        ) = getAccountAssets(_account, 0);\n', '        (\n', '            _borrowTokens,\n', '            _borrowAmounts,\n', '            _borrowDecimals\n', '        ) = getAccountAssets(_account, 3);\n', '    }\n', '\n', '    function getAssetUSDPrice(IiToken _asset) public view returns (uint256) {\n', '        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(\n', '                priceToken\n', '            );\n', '        if (_USDPrice == 0) return 0;\n', '\n', '        uint256 _assetUSDPrice = controller.priceOracle()\n', '                .getUnderlyingPrice(_asset)\n', '                .rdiv(_USDPrice);\n', '        uint8 _assetDecimals = _asset.decimals();\n', '        uint8 _priceTokenDecimals = priceToken.decimals();\n', '\n', '        return\n', '            _assetDecimals > _priceTokenDecimals\n', '                ? _assetUSDPrice.mul(\n', '                    10**(uint256(_assetDecimals - _priceTokenDecimals))\n', '                )\n', '                : _assetUSDPrice.div(\n', '                    10**(uint256(_priceTokenDecimals - _assetDecimals))\n', '                );\n', '    }\n', '\n', '    function getSupplyTokenData(IiToken _asset)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\n', '        if (_asset.isiToken()) {\n', '            uint256 _blocksPerDay = _asset.supplyRatePerBlock() * _asset.interestRateModel().blocksPerYear() / daysPerYear;\n', '            return (\n', '                (_blocksPerDay + BASE).rpow(\n', '                    daysPerYear,\n', '                    BASE\n', '                ) - BASE,\n', '                _collateralFactor,\n', '                getAssetUSDPrice(_asset)\n', '            );\n', '        }\n', '        return (0, _collateralFactor, getAssetUSDPrice(_asset));\n', '    }\n', '\n', '    function getAccountSupplyInfo(\n', '        IiToken _asset,\n', '        address _account,\n', '        uint256 _safeMaxFactor\n', '    )\n', '        public\n', '        returns (\n', '            uint256 _assetPrice,\n', '            bool _asCollateral,\n', '            bool _executed,\n', '            bool _accountAvailable\n', '        )\n', '    {\n', '        _asCollateral = controller.hasEnteredMarket(_account, _asset);\n', '        if (!_asCollateral) {\n', '            (uint256 _collateralFactor, , , , , , ) = controller.markets(_asset);\n', '            _executed = _collateralFactor > 0 ? true : false;\n', '            _accountAvailable = true;\n', '        } else {\n', '            _executed = canAccountRemoveFromCollateral(\n', '                _asset,\n', '                _account,\n', '                _safeMaxFactor\n', '            );\n', '            _accountAvailable = getAccountAvailable(_account);\n', '        }\n', '        \n', '        uint256 _USDPrice = controller.priceOracle().getUnderlyingPrice(priceToken);\n', '        _assetPrice = _USDPrice == 0 ? 0 : getBalance(_asset, _account).mul(controller.priceOracle().getUnderlyingPrice(_asset)).div(_USDPrice);\n', '    }\n', '\n', '    struct removeFromCollateralLocalVars {\n', '        uint256 assetPrice;\n', '        uint256 collateralFactor;\n', '        uint256 accountEquity;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 safeAvailableToken;\n', '    }\n', '\n', '    function canAccountRemoveFromCollateral(\n', '        IiToken _asset,\n', '        address _account,\n', '        uint256 _safeMaxFactor\n', '    ) public returns (bool) {\n', '        if (getAccountBorrowStatus(_account)) {\n', '            removeFromCollateralLocalVars memory _var;\n', '\n', '            (_var.collateralFactor, , , , , , ) = controller.markets(_asset);\n', '            (\n', '                _var.accountEquity,\n', '                ,\n', '                _var.sumCollateral,\n', '                _var.sumBorrowed\n', '            ) = calcAccountEquity(_account);\n', '            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\n', '                return true;\n', '\n', '            _var.assetPrice = controller.priceOracle()\n', '                .getUnderlyingPrice(_asset);\n', '            if (\n', '                _var.assetPrice == 0 ||\n', '                _var.collateralFactor == 0 ||\n', '                _var.accountEquity == 0\n', '            ) return false;\n', '\n', '            _var.safeAvailableToken = _var.sumCollateral >\n', '                _var.sumBorrowed.rdiv(_safeMaxFactor)\n', '                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\n', '                : 0;\n', '            _var.safeAvailableToken = _var\n', '                .safeAvailableToken\n', '                .div(_var.assetPrice)\n', '                .rdiv(_var.collateralFactor);\n', '\n', '            return\n', '                _var.safeAvailableToken >=\n', '                IiToken(_asset).balanceOfUnderlying(_account);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    struct supplyLocalVars {\n', '        uint256 cash;\n', '        uint256 assetPrice;\n', '        uint256 collateralFactor;\n', '        uint256 supplyCapacity;\n', '        uint256 totalUnderlying;\n', '        uint256 accountEquity;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 availableToken;\n', '        uint256 safeAvailableToken;\n', '        uint256 suppliedBalance;\n', '        uint256 accountBalance;\n', '        uint256 maxMintAmount;\n', '        uint256 availableToWithdraw;\n', '        uint256 safeAvailableToWithdraw;\n', '        uint256 iTokenBalance;\n', '        uint8 decimals;\n', '    }\n', '\n', '    function getAccountSupplyData(\n', '        IiToken _asset,\n', '        address _account,\n', '        uint256 _safeMaxFactor\n', '    )\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint8\n', '        )\n', '    {\n', '        supplyLocalVars memory _var;\n', '        _var.suppliedBalance = _asset.balanceOfUnderlying(_account);\n', '        _var.accountBalance = getBalance(_asset, _account);\n', '        _var.iTokenBalance = _asset.balanceOf(_account);\n', '        _var.decimals = _asset.decimals();\n', '\n', '        _var.maxMintAmount = 0;\n', '        (_var.collateralFactor, , , _var.supplyCapacity, , ,) = controller.markets(\n', '            _asset\n', '        );\n', '        _var.totalUnderlying = _asset.totalSupply().rmul(\n', '            _asset.exchangeRateStored()\n', '        );\n', '        if (_var.supplyCapacity > _var.totalUnderlying) {\n', '            _var.maxMintAmount = _var.supplyCapacity.sub(_var.totalUnderlying);\n', '            _var.maxMintAmount = _var.maxMintAmount > _var.accountBalance\n', '                ? _var.accountBalance\n', '                : _var.maxMintAmount;\n', '        }\n', '\n', '        if (_asset.isiToken()) {\n', '            _var.cash = _asset.getCash();\n', '            _var.availableToWithdraw = _var.cash > _var.suppliedBalance\n', '                ? _var.suppliedBalance\n', '                : _var.cash;\n', '        }\n', '        _var.safeAvailableToWithdraw = _var.availableToWithdraw;\n', '\n', '        if (\n', '            controller.hasEnteredMarket(_account, _asset) &&\n', '            getAccountBorrowStatus(_account)\n', '        ) {\n', '            (\n', '                _var.accountEquity,\n', '                ,\n', '                _var.sumCollateral,\n', '                _var.sumBorrowed\n', '            ) = calcAccountEquity(_account);\n', '            if (_var.collateralFactor == 0 && _var.accountEquity > 0)\n', '                return (\n', '                    _var.suppliedBalance,\n', '                    _var.accountBalance,\n', '                    _var.maxMintAmount,\n', '                    _var.availableToWithdraw,\n', '                    _var.safeAvailableToWithdraw,\n', '                    _var.iTokenBalance,\n', '                    _var.decimals\n', '                );\n', '\n', '            _var.assetPrice = controller.priceOracle()\n', '                .getUnderlyingPrice(_asset);\n', '            if (\n', '                _var.assetPrice == 0 ||\n', '                _var.collateralFactor == 0 ||\n', '                _var.accountEquity == 0\n', '            )\n', '                return (\n', '                    _var.suppliedBalance,\n', '                    _var.accountBalance,\n', '                    _var.maxMintAmount,\n', '                    0,\n', '                    0,\n', '                    0,\n', '                    _var.decimals\n', '                );\n', '\n', '            _var.availableToken = _var.accountEquity.div(_var.assetPrice).rdiv(\n', '                _var.collateralFactor\n', '            );\n', '            _var.availableToWithdraw = _var.availableToWithdraw >\n', '                _var.availableToken\n', '                ? _var.availableToken\n', '                : _var.availableToWithdraw;\n', '\n', '            _var.safeAvailableToken = _var.sumCollateral >\n', '                _var.sumBorrowed.rdiv(_safeMaxFactor)\n', '                ? _var.sumCollateral.sub(_var.sumBorrowed.rdiv(_safeMaxFactor))\n', '                : 0;\n', '            _var.safeAvailableToken = _var\n', '                .safeAvailableToken\n', '                .div(_var.assetPrice)\n', '                .rdiv(_var.collateralFactor);\n', '            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\n', '                _var.safeAvailableToken\n', '                ? _var.safeAvailableToken\n', '                : _var.safeAvailableToWithdraw;\n', '\n', '            _var.safeAvailableToWithdraw = _var.safeAvailableToWithdraw >\n', '                _var.availableToWithdraw\n', '                ? _var.availableToWithdraw\n', '                : _var.safeAvailableToWithdraw;\n', '        }\n', '\n', '        return (\n', '            _var.suppliedBalance,\n', '            _var.accountBalance,\n', '            _var.maxMintAmount,\n', '            _var.availableToWithdraw,\n', '            _var.safeAvailableToWithdraw,\n', '            _var.iTokenBalance,\n', '            _var.decimals\n', '        );\n', '    }\n', '\n', '    function getAccountBorrowValue(address _account) public returns (uint256 _borrowValue) {\n', '        IiToken[] memory _iTokens = controller.getAlliTokens();\n', '        IPriceOracle _priceOracle = controller.priceOracle();\n', '        for (uint256 i = 0; i < _iTokens.length; i++) {\n', '            if (controller.hasBorrowed(_account, _iTokens[i]))\n', '                _borrowValue = _borrowValue.add(\n', '                    _iTokens[i].borrowBalanceCurrent(_account).mul(_priceOracle.getUnderlyingPrice(_iTokens[i]))\n', '                );\n', '        }\n', '        return _borrowValue;\n', '    }\n', '\n', '    function getAccountBorrowStatus(address _account)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        IiToken[] memory _iTokens = controller.getAlliTokens();\n', '        for (uint256 i = 0; i < _iTokens.length; i++)\n', '            if (_iTokens[i].borrowBalanceStored(_account) > 0)\n', '                return true;\n', '\n', '        return false;\n', '    }\n', '\n', '    function getBorrowTokenData(IiToken _asset)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        if (_asset.isSupported()) {\n', '            (, uint256 _borrowFactor, , , , , ) = controller.markets(_asset);\n', '            return (\n', '                _asset.getCash(),\n', '                _borrowFactor,\n', '                (_asset.borrowRatePerBlock() * _asset.interestRateModel().blocksPerYear() / daysPerYear + BASE).rpow(\n', '                    daysPerYear,\n', '                    BASE\n', '                ) - BASE,\n', '                getAssetUSDPrice(_asset)\n', '            );\n', '        }\n', '        return (0, 0, 0, 0);\n', '    }\n', '\n', '    struct borrowInfoLocalVars {\n', '        IPriceOracle oracle;\n', '        uint256 assetPrice;\n', '        uint256 USDPrice;\n', '        uint256 accountEquity;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 borrowFactor;\n', '        uint256 maxBorrowValue;\n', '        uint256 safeBorrowValue;\n', '        bool accountAvailable;\n', '    }\n', '\n', '    function getAccountBorrowInfo(\n', '        IiToken _asset,\n', '        address _account,\n', '        uint256 _safeMaxFactor\n', '    )\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        )\n', '    {\n', '        borrowInfoLocalVars memory _var;\n', '        _var.oracle = controller.priceOracle();\n', '        _var.USDPrice = _var.oracle.getUnderlyingPrice(priceToken);\n', '        if (_var.oracle.getAssetPriceStatus(_asset))\n', '            _var.accountAvailable = getAccountAvailable(_account);\n', '\n', '        if (_var.USDPrice == 0) return (0, 0, 0, _var.accountAvailable);\n', '\n', '        IiToken(_asset).updateInterest();\n', '        (\n', '            _var.accountEquity,\n', '            ,\n', '            _var.sumCollateral,\n', '            _var.sumBorrowed\n', '        ) = calcAccountEquity(_account);\n', '        (, _var.borrowFactor, , , , , ) = controller.markets(_asset);\n', '\n', '        _var.maxBorrowValue = _var.accountEquity.rmul(_var.borrowFactor).div(\n', '            _var.USDPrice\n', '        );\n', '        _var.safeBorrowValue = _var.sumCollateral.rmul(_safeMaxFactor) >\n', '            _var.sumBorrowed\n', '            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\n', '            : 0;\n', '        _var.safeBorrowValue = _var.safeBorrowValue.rmul(_var.borrowFactor).div(\n', '            _var.USDPrice\n', '        );\n', '\n', '        _var.assetPrice = _var.oracle.getUnderlyingPrice(_asset);\n', '        return (\n', '            _var.maxBorrowValue,\n', '            _var.safeBorrowValue,\n', '            getBalance(_asset, _account).mul(_var.assetPrice).div(_var.USDPrice),\n', '            _var.accountAvailable\n', '        );\n', '    }\n', '\n', '    struct borrowLocalVars {\n', '        uint256 cash;\n', '        uint256 assetPrice;\n', '        uint256 borrowCapacity;\n', '        uint256 accountEquity;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 borrowFactor;\n', '        uint256 totalBorrows;\n', '        uint256 canBorrows;\n', '        uint256 borrowedBalance;\n', '        uint256 availableToBorrow;\n', '        uint256 safeAvailableToBorrow;\n', '        uint256 accountBalance;\n', '        uint256 maxRepay;\n', '    }\n', '\n', '    function getAccountBorrowData(\n', '        IiToken _asset,\n', '        address _account,\n', '        uint256 _safeMaxFactor\n', '    )\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint8\n', '        )\n', '    {\n', '        borrowLocalVars memory _var;\n', '        _var.borrowedBalance = _asset.borrowBalanceCurrent(_account);\n', '        _var.accountBalance = getBalance(_asset, _account);\n', '        _var.maxRepay = _var.borrowedBalance > _var.accountBalance\n', '            ? _var.accountBalance\n', '            : _var.borrowedBalance;\n', '\n', '        _var.assetPrice = controller.priceOracle()\n', '            .getUnderlyingPrice(_asset);\n', '        (, _var.borrowFactor, _var.borrowCapacity, , , , ) = controller.markets(\n', '            _asset\n', '        );\n', '        if (\n', '            _var.assetPrice == 0 ||\n', '            _var.borrowCapacity == 0 ||\n', '            _var.borrowFactor == 0\n', '        )\n', '            return (\n', '                _var.borrowedBalance,\n', '                0,\n', '                0,\n', '                _var.accountBalance,\n', '                _var.maxRepay,\n', '                _asset.decimals()\n', '            );\n', '\n', '        (\n', '            _var.accountEquity,\n', '            ,\n', '            _var.sumCollateral,\n', '            _var.sumBorrowed\n', '        ) = calcAccountEquity(_account);\n', '        _var.availableToBorrow = _var.accountEquity.rmul(_var.borrowFactor).div(\n', '            _var.assetPrice\n', '        );\n', '\n', '        _var.safeAvailableToBorrow = _var.sumCollateral.rmul(_safeMaxFactor) >\n', '            _var.sumBorrowed\n', '            ? _var.sumCollateral.rmul(_safeMaxFactor).sub(_var.sumBorrowed)\n', '            : 0;\n', '        _var.safeAvailableToBorrow = _var\n', '            .safeAvailableToBorrow\n', '            .rmul(_var.borrowFactor)\n', '            .div(_var.assetPrice);\n', '\n', '        if (_asset.isiToken()) {\n', '            _var.cash = _asset.getCash();\n', '            _var.availableToBorrow = _var.availableToBorrow > _var.cash\n', '                ? _var.cash\n', '                : _var.availableToBorrow;\n', '\n', '            _var.safeAvailableToBorrow = _var.safeAvailableToBorrow > _var.cash\n', '                ? _var.cash\n', '                : _var.safeAvailableToBorrow;\n', '        }\n', '\n', '        _var.totalBorrows = _asset.totalBorrowsCurrent();\n', '        _var.canBorrows = _var.totalBorrows >= _var.borrowCapacity\n', '            ? 0\n', '            : _var.borrowCapacity.sub(_var.totalBorrows);\n', '\n', '        _var.availableToBorrow = _var.availableToBorrow > _var.canBorrows\n', '            ? _var.canBorrows\n', '            : _var.availableToBorrow;\n', '\n', '        _var.safeAvailableToBorrow = _var.safeAvailableToBorrow >\n', '            _var.canBorrows\n', '            ? _var.canBorrows\n', '            : _var.safeAvailableToBorrow;\n', '\n', '        return (\n', '            _var.borrowedBalance,\n', '            _var.canBorrows,\n', '            _var.safeAvailableToBorrow,\n', '            _var.accountBalance,\n', '            _var.maxRepay,\n', '            _asset.decimals()\n', '        );\n', '    }\n', '\n', '    struct availableToBorrowLocalVars {\n', '        uint256 borrowFactor;\n', '        uint256 accountEquity;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '        uint256 availableToBorrow;\n', '        uint256 safeAvailableToBorrow;\n', '    }\n', '\n', '    function getBalance(IiToken _asset, address _account)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            _asset.underlying() == IERC20(0)\n', '                ? _account.balance\n', '                : _asset.underlying().balanceOf(_account);\n', '    }\n', '\n', '    struct liquidateLocalVars {\n', '        IPriceOracle oracle;\n', '        uint256 priceBorrowed;\n', '        uint256 priceCollateral;\n', '        uint256 liquidatorBalance;\n', '        uint256 borrowerCollateralBalance;\n', '        uint256 shortfall;\n', '        uint256 exchangeRateCollateral;\n', '        uint256 maxRepay;\n', '        uint256 maxSeizediToken;\n', '        uint256 maxRepayByCollateral;\n', '        bool available;\n', '    }\n', '\n', '    function getLiquidationInfo(\n', '        address _borrower,\n', '        address _liquidator,\n', '        IiToken _assetBorrowed,\n', '        IiToken _assetCollateral\n', '    )\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        )\n', '    {\n', '        liquidateLocalVars memory _var;\n', '\n', '        _var.oracle = controller.priceOracle();\n', '        if (_var.oracle.getAssetPriceStatus(_assetCollateral))\n', '            _var.available = getAccountAvailable(_borrower);\n', '\n', '        _var.maxRepay = _assetBorrowed.borrowBalanceCurrent(_borrower)\n', '            .rmul(controller.closeFactorMantissa());\n', '        _var.exchangeRateCollateral = _assetCollateral.exchangeRateCurrent();\n', '\n', '        _var.liquidatorBalance = getBalance(_assetBorrowed, _liquidator);\n', '        (, _var.shortfall, , ) = calcAccountEquity(_borrower);\n', '        if (_var.shortfall == 0 || _borrower == _liquidator)\n', '            return (0, 0, _var.liquidatorBalance, _var.available);\n', '\n', '        _var.priceBorrowed = _var.oracle.getUnderlyingPrice(_assetBorrowed);\n', '        _var.priceCollateral = _var.oracle.getUnderlyingPrice(_assetCollateral);\n', '\n', '        _var.maxSeizediToken = _var\n', '            .maxRepay\n', '            .mul(_var.priceBorrowed)\n', '            .rmul(controller.liquidationIncentiveMantissa())\n', '            .rdiv(_var.exchangeRateCollateral)\n', '            .div(_var.priceCollateral);\n', '        _var.borrowerCollateralBalance = _assetCollateral.balanceOf(\n', '            _borrower\n', '        );\n', '        if (_var.maxSeizediToken < _var.borrowerCollateralBalance)\n', '            return (\n', '                _var.maxRepay,\n', '                _var.maxRepay,\n', '                _var.liquidatorBalance,\n', '                _var.available\n', '            );\n', '\n', '        _var.maxRepayByCollateral = _var\n', '            .borrowerCollateralBalance\n', '            .rmul(_var.exchangeRateCollateral)\n', '            .mul(_var.priceCollateral)\n', '            .div(_var.priceBorrowed)\n', '            .rdiv(controller.liquidationIncentiveMantissa());\n', '        return (\n', '            _var.maxRepay,\n', '            _var.maxRepayByCollateral,\n', '            _var.liquidatorBalance,\n', '            _var.available\n', '        );\n', '    }\n', '\n', '    function getAccountRewardAmount(address _account) external returns (uint256) {\n', '\n', '        IRewardDistributor _rewardDistributor = IRewardDistributor(controller.rewardDistributor());\n', '        address[] memory _accounts = new address[](1);\n', '        _accounts[0] = _account;\n', '        _rewardDistributor.updateRewardBatch(_accounts ,controller.getAlliTokens());\n', '        return _rewardDistributor.reward(_account);\n', '    }\n', '\n', '    struct AccountEquityLocalVars {\n', '        IiToken[] collateralITokens;\n', '        IiToken[] borrowedITokens;\n', '        uint256 collateralFactor;\n', '        uint256 borrowFactor;\n', '        uint256 sumCollateral;\n', '        uint256 sumBorrowed;\n', '    }\n', '\n', '    function calcAccountEquity(address _account) public view returns (uint256, uint256, uint256, uint256) {\n', '        AccountEquityLocalVars memory _var;\n', '        _var.collateralITokens = controller.getEnteredMarkets(_account);\n', '        for (uint256 i = 0; i < _var.collateralITokens.length; i++) {\n', '            (_var.collateralFactor, , , , , , ) = controller.markets(_var.collateralITokens[i]);\n', '            _var.sumCollateral = _var.sumCollateral.add(\n', '                _var.collateralITokens[i].balanceOf(_account)\n', '                .mul(controller.priceOracle().getUnderlyingPrice(_var.collateralITokens[i]))\n', '                .rmul(_var.collateralITokens[i].exchangeRateStored())\n', '                .rmul(_var.collateralFactor)\n', '            );\n', '        }\n', '        _var.borrowedITokens = controller.getBorrowedAssets(_account);\n', '        for (uint256 i = 0; i < _var.borrowedITokens.length; i++) {\n', '            (, _var.borrowFactor, , , , , ) = controller.markets(_var.borrowedITokens[i]);\n', '            _var.sumBorrowed = _var.sumBorrowed.add(\n', '                _var.borrowedITokens[i].borrowBalanceStored(_account)\n', '                .mul(controller.priceOracle().getUnderlyingPrice(_var.borrowedITokens[i]))\n', '                .rdiv(_var.borrowFactor)\n', '            );\n', '        }\n', '        return\n', '            _var.sumCollateral > _var.sumBorrowed\n', '                ? (\n', '                    _var.sumCollateral - _var.sumBorrowed,\n', '                    uint256(0),\n', '                    _var.sumCollateral,\n', '                    _var.sumBorrowed\n', '                )\n', '                : (\n', '                    uint256(0),\n', '                    _var.sumBorrowed - _var.sumCollateral,\n', '                    _var.sumCollateral,\n', '                    _var.sumBorrowed\n', '                );\n', '    }\n', '\n', '    function getAccountAvailable(address _account) public view returns (bool) {\n', '        \n', '        IiToken[] memory _collateralITokens = controller.getEnteredMarkets(_account);\n', '        for (uint256 i = 0; i < _collateralITokens.length; i++) {\n', '            if (!controller.priceOracle().getAssetPriceStatus(_collateralITokens[i]))\n', '                return false;\n', '        }\n', '        IiToken[] memory _borrowedITokens = controller.getBorrowedAssets(_account);\n', '        for (uint256 i = 0; i < _borrowedITokens.length; i++) {\n', '            if (!controller.priceOracle().getAssetPriceStatus(_borrowedITokens[i]))\n', '                return false;\n', '        }\n', '        return true;\n', '    }\n', '}']