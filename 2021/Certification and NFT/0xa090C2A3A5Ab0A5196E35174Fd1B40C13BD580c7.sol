['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-12\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract Constant {\n', '    string constant ERR_CONTRACT_SELF_ADDRESS = "ERR_CONTRACT_SELF_ADDRESS";\n', '    string constant ERR_ZERO_ADDRESS = "ERR_ZERO_ADDRESS";\n', '    string constant ERR_NOT_OWN_ADDRESS = "ERR_NOT_OWN_ADDRESS";\n', '    string constant ERR_VALUE_IS_ZERO = "ERR_VALUE_IS_ZERO";\n', '    string constant ERR_AUTHORIZED_ADDRESS_ONLY = "ERR_AUTHORIZED_ADDRESS_ONLY";\n', '    string constant ERR_NOT_ENOUGH_BALANCE = "ERR_NOT_ENOUGH_BALANCE";\n', '\n', '    modifier notOwnAddress(address _which) {\n', '        require(msg.sender != _which, ERR_NOT_OWN_ADDRESS);\n', '        _;\n', '    }\n', '\n', '    // validates an address is not zero\n', '    modifier notZeroAddress(address _which) {\n', '        require(_which != address(0), ERR_ZERO_ADDRESS);\n', '        _;\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThisAddress(address _which) {\n', '        require(_which != address(this), ERR_CONTRACT_SELF_ADDRESS);\n', '        _;\n', '    }\n', '\n', '    modifier notZeroValue(uint256 _value) {\n', '        require(_value > 0, ERR_VALUE_IS_ZERO);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract Ownable is Constant {\n', '\n', '    address payable public owner;\n', '    address payable public newOwner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _transferOwnership(msg.sender);\n', '    }\n', '\n', '    function _transferOwnership(address payable _whom) internal {\n', '        emit OwnershipTransferred(owner,_whom);\n', '        owner = _whom;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, ERR_AUTHORIZED_ADDRESS_ONLY);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address payable _newOwner)\n', '    external\n', '    virtual\n', '    notZeroAddress(_newOwner)\n', '    onlyOwner\n', '    {\n', '        // emit OwnershipTransferred(owner, newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() external\n', '    virtual\n', '    returns (bool){\n', '        require(msg.sender == newOwner,"ERR_ONLY_NEW_OWNER");\n', '        owner = newOwner;\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        newOwner = address(0);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    /**\n', '      * @dev Returns the subtraction of two unsigned integers, reverting on\n', '      * overflow (when the result is negative).\n', '      *\n', "      * Counterpart to Solidity's `-` operator.\n", '      *\n', '      * Requirements:\n', '      *\n', '      * - Subtraction cannot overflow.\n', '      */\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return safeSub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n', '        require(b <= a, error);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return safeDiv(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n', '        require(b > 0, error);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\n', '        uint256 result;\n', '        assembly {\n', '            result:=exp(a, b)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', 'interface ERC20Interface\n', '{\n', '    function totalSupply() external view returns(uint256);\n', '\n', '    function balanceOf(address _tokenOwner)external view returns(uint balance );\n', '\n', '    function allowance(address _tokenOwner, address _spender)external view returns (uint supply);\n', '\n', '    function transfer(address _to,uint _tokens)external returns(bool success);\n', '\n', '    function approve(address _spender,uint _tokens)external returns(bool success);\n', '\n', '    function transferFrom(address _from,address _to,uint _tokens)external returns(bool success);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _tokens);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _tokens);\n', '}\n', '\n', 'contract StakeStorage {\n', '\n', '    /**\n', '    * @dev check if token is listed\n', '   **/\n', '    mapping(address => bool) public listedToken;\n', '\n', '    /**\n', '     * @dev list of tokens\n', '    **/\n', '    address[] public tokens;\n', '\n', '    mapping(address => uint256)public tokenIndex;\n', '    mapping(address => mapping(address => uint256)) public stakeBalance;\n', '    mapping(address => mapping(address => uint256)) public lastStakeClaimed;\n', '    mapping(address => uint256)public totalTokens;\n', '\n', '    /**\n', '     * @dev annual mint percent of a token\n', '     **/\n', '    mapping(address => uint256) public annualMintPercentage;\n', '    /**\n', "    * @dev list of particular token's paynoder\n", '    **/\n', '    mapping(address => address[])public payNoders;\n', '    /**\n', '     * @dev check if address is in paynode\n', '     **/\n', '    mapping(address => mapping(address => bool)) public isPayNoder;\n', '    /**\n', '     * @dev maintain array index for addresses\n', '     **/\n', '    mapping(address => mapping(address => uint256)) public payNoderIndex;\n', '    /**\n', "     * @dev token's  paynode slot\n", '    **/\n', '    mapping(address => uint256)public tokenPayNoderSlot;\n', '\n', '    /**\n', '     * @dev minimum balance require for be in paynode\n', '    **/\n', '    mapping(address => uint256)public tokenMinimumBalance;\n', '    mapping(address => uint256)public tokenExtraMintForPayNodes;\n', '\n', '    event Stake(\n', '        uint256 indexed _stakeTimestamp,\n', '        address indexed _token,\n', '        address indexed _whom,\n', '        uint256 _amount\n', '    );\n', '\n', '    event StakeClaimed(\n', '        uint256 indexed _stakeClaimedTimestamp,\n', '        address indexed _token,\n', '        address indexed _whom,\n', '        uint256 _amount\n', '    );\n', '\n', '    event UnStake(\n', '        uint256 indexed _unstakeTimestamp,\n', '        address indexed _token,\n', '        address indexed _whom,\n', '        uint256 _amount\n', '    );\n', '}\n', '\n', 'contract Paynodes is Ownable, SafeMath, StakeStorage {\n', '\n', '    /**\n', '     * @dev adding paynode account\n', '    **/\n', '    function addaccountToPayNode(address _token, address _whom)\n', '    external\n', '    onlyOwner()\n', '    returns (bool)\n', '    {\n', '        require(isPayNoder[_token][_whom] == false, "ERR_ALREADY_IN_PAYNODE_LIST");\n', '\n', '        require(payNoders[_token].length < tokenPayNoderSlot[_token], "ERR_PAYNODE_LIST_FULL");\n', '\n', '        require(stakeBalance[_token][_whom] >= tokenMinimumBalance[_token], "ERR_PAYNODE_MINIMUM_BALANCE");\n', '\n', '        isPayNoder[_token][_whom] = true;\n', '        payNoderIndex[_token][_whom] = payNoders[_token].length;\n', '        payNoders[_token].push(_whom);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev removing paynode account\n', '     **/\n', '    function _removeaccountToPayNode(address _token, address _whom) internal returns (bool) {\n', '\n', '        require(isPayNoder[_token][_whom], "ERR_ONLY_PAYNODER");\n', '        uint256 _payNoderIndex = payNoderIndex[_token][_whom];\n', '\n', '        address _lastAddress = payNoders[_token][safeSub(payNoders[_token].length, 1)];\n', '        payNoders[_token][_payNoderIndex] = _lastAddress;\n', '        payNoderIndex[_token][_lastAddress] = _payNoderIndex;\n', '        delete isPayNoder[_token][_whom];\n', '        payNoders[_token].pop();\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove account from paynode\n', '     **/\n', '    function removeaccountToPayNode(address _token, address _whom)\n', '    external\n', '    onlyOwner()\n', '    returns (bool)\n', '    {\n', '        return _removeaccountToPayNode(_token, _whom);\n', '    }\n', '\n', '    /**\n', '     * @dev owner can change minimum balance requirement\n', '     **/\n', '    function setMinimumBalanceForPayNoder(address _token, uint256 _minimumBalance)\n', '    external\n', '    onlyOwner()\n', '    returns (bool)\n', '    {\n', '        tokenMinimumBalance[_token] = _minimumBalance;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev owner can change extra mint percent for paynoder\n', '     * _extraMintForPayNodes is set in percent with mulitply 100\n', '     * if owner want to set 1.25% then value is 125\n', '     **/\n', '    function setExtraMintingForNodes(address _token, uint256 _extraMintForPayNodes)\n', '    external\n', '    onlyOwner()\n', '    returns (bool)\n', '    {\n', '        tokenExtraMintForPayNodes[_token] = _extraMintForPayNodes;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev owner can set paynoder slots\n', '     **/\n', '    function setPayNoderSlot(address _token, uint256 _payNoderSlot)\n', '    external\n', '    onlyOwner()\n', '    returns (bool)\n', '    {\n', '        tokenPayNoderSlot[_token] = _payNoderSlot;\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract Staking is Paynodes {\n', '\n', '    constructor(address[] memory _token) public {\n', '        for (uint8 i = 0; i < _token.length; i++) {\n', '            listedToken[_token[i]] = true;\n', '            tokens.push(_token[i]);\n', '            tokenIndex[_token[i]] = i;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev stake token\n', '    **/\n', '    function stake(address _token, uint256 _amount) external returns (bool){\n', '\n', '        require(listedToken[_token], "ERR_TOKEN_IS_NOT_LISTED");\n', '\n', '        ERC20Interface(_token).transferFrom(msg.sender, address(this), _amount);\n', '\n', '        if (lastStakeClaimed[_token][msg.sender] == 0) {\n', '            lastStakeClaimed[_token][msg.sender] = now;\n', '        } else {\n', '            uint256 _stakeReward = _calculateStake(_token, msg.sender);\n', '            lastStakeClaimed[_token][msg.sender] = now;\n', '            stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\n', '        }\n', '\n', '        totalTokens[_token] = safeAdd(totalTokens[_token], _amount);\n', '        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _amount);\n', '        emit Stake(now, _token, msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev stake token\n', '     **/\n', '    function unStake(address _token) external returns (bool){\n', '\n', '        require(listedToken[_token], "ERR_TOKEN_IS_NOT_LISTED");\n', '\n', '        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\n', '        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n', '        ERC20Interface(_token).transfer(msg.sender, safeAdd(userTokenBalance, _stakeReward));\n', '        emit UnStake(now, _token, msg.sender, safeAdd(userTokenBalance, _stakeReward));\n', '        totalTokens[_token] = safeSub(totalTokens[_token], userTokenBalance);\n', '        stakeBalance[_token][msg.sender] = 0;\n', '        lastStakeClaimed[_token][msg.sender] = 0;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw token\n', '     **/\n', '    function withdrawToken(address _token) external returns (bool){\n', '        require(listedToken[_token], "ERR_TOKEN_IS_NOT_LISTED");\n', '        uint256 userTokenBalance = stakeBalance[_token][msg.sender];\n', '        stakeBalance[_token][msg.sender] = 0;\n', '        lastStakeClaimed[_token][msg.sender] = 0;\n', '        ERC20Interface(_token).transfer(msg.sender, userTokenBalance);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw token by owner\n', '     **/\n', '    function withdrawToken(address _token, uint256 _amount) external onlyOwner() returns (bool) {\n', '        require(listedToken[_token], "ERR_TOKEN_IS_NOT_LISTED");\n', '        require(totalTokens[_token] == 0, "ERR_TOTAL_TOKENS_NEEDS_TO_BE_0_FOR_WITHDRAWL");\n', '        ERC20Interface(_token).transfer(msg.sender, _amount);\n', '        return true;\n', '    }\n', '\n', '    // we calculate daily basis stake amount\n', '    function _calculateStake(address _token, address _whom) internal view returns (uint256) {\n', '        uint256 _lastRound = lastStakeClaimed[_token][_whom];\n', '        uint256 totalStakeDays = safeDiv(safeSub(now, _lastRound), 86400);\n', '        uint256 userTokenBalance = stakeBalance[_token][_whom];\n', '        uint256 tokenPercentage = annualMintPercentage[_token];\n', '        if (totalStakeDays > 0) {\n', '            uint256 stakeAmount = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), totalStakeDays), 3650000);\n', '            if (isPayNoder[_token][_whom]) {\n', '                if (stakeBalance[_token][_whom] >= tokenMinimumBalance[_token]) {\n', '                    uint256 extraPayNode = safeDiv(safeMul(safeMul(userTokenBalance, tokenPercentage), tokenExtraMintForPayNodes[_token]), 3650000);\n', '                    stakeAmount = safeAdd(stakeAmount, extraPayNode);\n', '                }\n', '            }\n', '            return stakeAmount;\n', '        }\n', '        return 0;\n', '\n', '    }\n', '\n', '    // show stake balance with what user get\n', '    function balanceOf(address _token, address _whom) external view returns (uint256) {\n', '        uint256 _stakeReward = _calculateStake(_token, _whom);\n', '        return safeAdd(stakeBalance[_token][_whom], _stakeReward);\n', '    }\n', '\n', '    // show stake balance with what user get\n', '    function getOnlyRewards(address _token, address _whom) external view returns (uint256) {\n', '        return _calculateStake(_token, _whom);\n', '    }\n', '\n', '    // claim only rewards and withdraw it\n', '    function claimRewardsOnlyAndWithDraw(address _token) external returns (bool) {\n', '        require(lastStakeClaimed[_token][msg.sender] != 0, "ERR_TOKEN_IS_NOT_STAKED");\n', '        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n', '        ERC20Interface(_token).transfer(msg.sender, _stakeReward);\n', '        lastStakeClaimed[_token][msg.sender] = now;\n', '        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\n', '        return true;\n', '    }\n', '\n', '    // claim only rewards and restake it\n', '    function claimRewardsOnlyAndStake(address _token) external returns (bool) {\n', '        require(lastStakeClaimed[_token][msg.sender] != 0, "ERR_TOKEN_IS_NOT_STAKED");\n', '        uint256 _stakeReward = _calculateStake(_token, msg.sender);\n', '\n', '        lastStakeClaimed[_token][msg.sender] = now;\n', '        stakeBalance[_token][msg.sender] = safeAdd(stakeBalance[_token][msg.sender], _stakeReward);\n', '        emit StakeClaimed(now, _token, msg.sender, _stakeReward);\n', '        emit Stake(now, _token, msg.sender, stakeBalance[_token][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    // _percent should be mulitplied by 100\n', '    function setAnnualMintPercentage(address _token, uint256 _percent) external onlyOwner() returns (bool) {\n', '        require(listedToken[_token], "ERR_TOKEN_IS_NOT_LISTED");\n', '        annualMintPercentage[_token] = _percent;\n', '        return true;\n', '    }\n', '\n', '    // to add new token\n', '    function addToken(address _token) external onlyOwner() {\n', '        require(!listedToken[_token], "ERR_TOKEN_ALREADY_EXISTS");\n', '        tokens.push(_token);\n', '        listedToken[_token] = true;\n', '        tokenIndex[_token] = tokens.length;\n', '    }\n', '\n', '    // to remove the token\n', '    function removeToken(address _token) external onlyOwner() {\n', '        require(listedToken[_token], "ERR_TOKEN_DOESNOT_EXISTS");\n', '        uint256 _lastindex = tokenIndex[_token];\n', '        address _lastaddress = tokens[safeSub(tokens.length, 1)];\n', '        tokenIndex[_lastaddress] = _lastindex;\n', '        tokens[_lastindex] = _lastaddress;\n', '        tokens.pop();\n', '        delete tokenIndex[_lastaddress];\n', '        listedToken[_token] = false;\n', '    }\n', '\n', '    function availabletokens() public view returns (uint){\n', '        return tokens.length;\n', '    }\n', '\n', '}']