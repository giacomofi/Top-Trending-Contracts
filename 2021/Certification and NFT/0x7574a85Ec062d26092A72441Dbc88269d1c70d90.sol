['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../utils/Context.sol";\n', 'import "../utils/introspection/ERC165.sol";\n', '\n', '/**\n', ' * @dev External interface of AccessControl declared to support ERC165 detection.\n', ' */\n', 'interface IAccessControl {\n', '    function hasRole(bytes32 role, address account) external view returns (bool);\n', '    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n', '    function grantRole(bytes32 role, address account) external;\n', '    function revokeRole(bytes32 role, address account) external;\n', '    function renounceRole(bytes32 role, address account) external;\n', '}\n', '\n', '/**\n', ' * @dev Contract module that allows children to implement role-based access\n', " * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n", ' * members except through off-chain means by accessing the contract event logs. Some\n', ' * applications may benefit from on-chain enumerability, for those cases see\n', ' * {AccessControlEnumerable}.\n', ' *\n', ' * Roles are referred to by their `bytes32` identifier. These should be exposed\n', ' * in the external API and be unique. The best way to achieve this is by\n', ' * using `public constant` hash digests:\n', ' *\n', ' * ```\n', ' * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");\n', ' * ```\n', ' *\n', ' * Roles can be used to represent a set of permissions. To restrict access to a\n', ' * function call, use {hasRole}:\n', ' *\n', ' * ```\n', ' * function foo() public {\n', ' *     require(hasRole(MY_ROLE, msg.sender));\n', ' *     ...\n', ' * }\n', ' * ```\n', ' *\n', ' * Roles can be granted and revoked dynamically via the {grantRole} and\n', ' * {revokeRole} functions. Each role has an associated admin role, and only\n', " * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n", ' *\n', ' * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n', ' * that only accounts with this role will be able to grant or revoke other\n', ' * roles. More complex role relationships can be created by using\n', ' * {_setRoleAdmin}.\n', ' *\n', ' * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n', ' * grant and revoke this role. Extra precautions should be taken to secure\n', ' * accounts that have been granted it.\n', ' */\n', 'abstract contract AccessControl is Context, IAccessControl, ERC165 {\n', '    struct RoleData {\n', '        mapping (address => bool) members;\n', '        bytes32 adminRole;\n', '    }\n', '\n', '    mapping (bytes32 => RoleData) private _roles;\n', '\n', '    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n', '\n', '    /**\n', "     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n", '     *\n', '     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n', '     * {RoleAdminChanged} not being emitted signaling this.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is granted `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call, an admin role\n', '     * bearer except when using {_setupRole}.\n', '     */\n', '    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is revoked `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call:\n', '     *   - if using `revokeRole`, it is the admin role bearer\n', '     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n', '     */\n', '    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IAccessControl).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns `true` if `account` has been granted `role`.\n', '     */\n', '    function hasRole(bytes32 role, address account) public view override returns (bool) {\n', '        return _roles[role].members[account];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the admin role that controls `role`. See {grantRole} and\n', '     * {revokeRole}.\n', '     *\n', "     * To change a role's admin, use {_setRoleAdmin}.\n", '     */\n', '    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n', '        return _roles[role].adminRole;\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function grantRole(bytes32 role, address account) public virtual override {\n', '        require(hasRole(getRoleAdmin(role), _msgSender()), "AccessControl: sender must be an admin to grant");\n', '\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from `account`.\n', '     *\n', '     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function revokeRole(bytes32 role, address account) public virtual override {\n', '        require(hasRole(getRoleAdmin(role), _msgSender()), "AccessControl: sender must be an admin to revoke");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from the calling account.\n', '     *\n', "     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n", '     * purpose is to provide a mechanism for accounts to lose their privileges\n', '     * if they are compromised (such as when a trusted device is misplaced).\n', '     *\n', '     * If the calling account had been granted `role`, emits a {RoleRevoked}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be `account`.\n', '     */\n', '    function renounceRole(bytes32 role, address account) public virtual override {\n', '        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', "     * event. Note that unlike {grantRole}, this function doesn't perform any\n", '     * checks on the calling account.\n', '     *\n', '     * [WARNING]\n', '     * ====\n', '     * This function should only be called from the constructor when setting\n', '     * up the initial roles for the system.\n', '     *\n', '     * Using this function in any other way is effectively circumventing the admin\n', '     * system imposed by {AccessControl}.\n', '     * ====\n', '     */\n', '    function _setupRole(bytes32 role, address account) internal virtual {\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', "     * @dev Sets `adminRole` as ``role``'s admin role.\n", '     *\n', '     * Emits a {RoleAdminChanged} event.\n', '     */\n', '    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n', '        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n', '        _roles[role].adminRole = adminRole;\n', '    }\n', '\n', '    function _grantRole(bytes32 role, address account) private {\n', '        if (!hasRole(role, account)) {\n', '            _roles[role].members[account] = true;\n', '            emit RoleGranted(role, account, _msgSender());\n', '        }\n', '    }\n', '\n', '    function _revokeRole(bytes32 role, address account) private {\n', '        if (hasRole(role, account)) {\n', '            _roles[role].members[account] = false;\n', '            emit RoleRevoked(role, account, _msgSender());\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC165.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20/ERC20.sol";\n', 'import "./ERC20/ERC20Burnable.sol";\n', 'import "./access/AccessControl.sol";\n', 'import "./utils/Context.sol";\n', '\n', 'contract BoughtTheTopTokenRoot is Context, AccessControl, ERC20Burnable {\n', '    /// @notice Role identifer for minter\n', '    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");\n', '\n', '    /**\n', '     * @dev Grants `DEFAULT_ADMIN_ROLE` and `MINTER_ROLE` to the\n', '     * account that deploys the contract.\n', '     *\n', '     * See {ERC20-constructor}.\n', '     */\n', '    constructor() ERC20("BoughtThe.top", "BTT") {\n', '        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n', '        _setupRole(MINTER_ROLE, _msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Creates `amount` new tokens for `to`.\n', '     *\n', '     * See {ERC20-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `MINTER_ROLE`.\n', '     */\n', '    function mint(address to, uint256 amount) public virtual {\n', '        require(hasRole(MINTER_ROLE, _msgSender()), "BoughtTheTopToken: must have minter role to mint");\n', '        _mint(to, amount);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "../utils/Context.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}.\n', '     *\n', '     * The defaut value of {decimals} is 18. To select a different value for\n', '     * {decimals} you should overload it.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n', '     * overloaded;\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20.sol";\n', 'import "../utils/Context.sol";\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'abstract contract ERC20Burnable is Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public virtual {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n", '     * allowance.\n', '     *\n', '     * See {ERC20-_burn} and {ERC20-allowance}.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have allowance for ``accounts``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public virtual {\n', '        uint256 currentAllowance = allowance(account, _msgSender());\n', '        require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance");\n', '        _approve(account, _msgSender(), currentAllowance - amount);\n', '        _burn(account, amount);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20/IERC20.sol";\n', 'import "./access/Ownable.sol";\n', 'import "./utils/math/SafeMath.sol";\n', 'import "./utils/math/Math.sol";\n', 'import "./IOnMint.sol";\n', '\n', '/**\n', ' * @title RewardVesting\n', ' * @dev The vesting contract for the initial mint rewards\n', ' */\n', 'contract RewardVesting is Ownable, IOnMint {\n', '    using SafeMath for uint256;\n', '    /// @notice Start block of rewards\n', '    uint256 public rewardEarnStartBlock;\n', '\n', '    /// @notice End block of rewards\n', '    uint256 public rewardEarnEndBlock;\n', '\n', '    /// @notice Reward vesting duration in days\n', '    uint16 public rewardVestingDuration;\n', '\n', '    /// @notice Start block of NFTs eligible for rewards\n', '    uint256 public rewardEligibleStartBlock;\n', '\n', '    /// @notice End block of NFTs eligibile for rewards\n', '    uint256 public rewardEligibleEndBlock;\n', '\n', '    /// @notice Total rewards per mint\n', '    uint256 public rewardAmount;\n', '\n', '    /// @notice Address of reward token\n', '    IERC20 public rewardToken;\n', '\n', '    /// @notice Grant definition\n', '    struct Grant {\n', '        uint256 startTime;\n', '        uint256 amount;\n', '        uint16 vestingDuration;\n', '        uint16 vestingCliff;\n', '        uint256 totalClaimed;\n', '    }\n', '\n', '    /// @notice Mapping of address to grants\n', '    mapping (address => Grant) public tokenGrants;\n', '\n', '    /// @notice Caller address that is allowed to add grants (in addition to owner)\n', '    address public caller;\n', '\n', '    /// @dev Used to translate vesting periods specified in days to seconds\n', '    uint256 constant internal SECONDS_PER_DAY = 86400;\n', '\n', '    /**\n', '     * @notice Construct a new Vesting contract\n', '     * @param _rewardToken Address of reward token\n', '     * @param _caller Address of an additional allowed caller of addTokenGrant\n', '     */\n', '    constructor(address _rewardToken, address _caller) {\n', '        require(_rewardToken != address(0), "RewardVesting::constructor: must be valid token address");\n', '        require(_caller != address(0), "RewardVesting::constructor: must be valid address");\n', '        rewardToken = IERC20(_rewardToken);\n', '        caller = _caller;\n', '        rewardToken.approve(owner(), type(uint256).max);\n', '    }\n', '\n', '    /**\n', '     * @notice Emitted when reward parameters ({rewardEarnStartBlock}, rewardEarnEndBlock}, {rewardEligibleStartBlock},\n', '     * {rewardEligibleEndBlock}, {rewardVestingDuration}, {rewardAmount}) are changed\n', '     */\n', '    event RewardParametersChanged(uint256 startBlock, uint256 endBlock, uint256 eligibleStartBlock,\n', '        uint256 eligibleEndBlock, uint16 vestingDuration, uint256 amount);\n', '\n', '    /// @notice Event emitted when a new grant is created\n', '    event GrantAdded(address indexed recipient, uint256 indexed amount, uint256 startTime, uint16 vestingDurationInDays, uint16 vestingCliffInDays);\n', '    \n', '    /// @notice Event emitted when tokens are claimed by a recipient from a grant\n', '    event GrantTokensClaimed(address indexed recipient, uint256 indexed amountClaimed);\n', '\n', '    /**\n', '     * @dev Sets current reward parameters\n', '     * Requirements:\n', '     *\n', '     * - the caller must be owner\n', '     */\n', '    function setRewardParameters(uint256 startBlock, uint256 endBlock, uint256 eligibleStartBlock,\n', '        uint256 eligibleEndBlock, uint16 vestingDuration, uint256 amount) public onlyOwner {\n', '\n', '        require(endBlock >= startBlock, "RewardVesting: startBlock less than endBlock");\n', '        require(eligibleEndBlock >= eligibleStartBlock, "RewardVesting: eligibleEndBlock less than eligibleStartBlock");\n', '        require(vestingDuration > 0, "RewardVesting: duration must be > 0");\n', '        require(vestingDuration <= 25*365, "RewardVesting: duration more than 25 years");\n', '\n', '        rewardEarnStartBlock = startBlock;\n', '        rewardEarnEndBlock = endBlock;\n', '        rewardEligibleStartBlock = eligibleStartBlock;\n', '        rewardEligibleEndBlock = eligibleEndBlock;\n', '        rewardVestingDuration = vestingDuration;\n', '        rewardAmount = amount;\n', '\n', '        emit RewardParametersChanged(startBlock, endBlock, eligibleStartBlock, eligibleEndBlock,\n', '            vestingDuration, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Rescue any ERC-20 token the contract may hold\n', '     *\n', '     * @param _token ERC-20 token address\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be owner\n', '     */\n', '    function rescue(address _token) public onlyOwner {\n', '        IERC20 token = IERC20(_token);\n', '        token.transfer(msg.sender, token.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '     * @notice Add a new token grant\n', '     * @param recipient The address that is receiving the grant\n', '     * @param startTime The unix timestamp when the grant will start\n', '     * @param amount The amount of tokens being granted\n', '     * @param vestingDurationInDays The vesting period in days\n', '     * @param vestingCliffInDays The vesting cliff duration in days\n', '     */\n', '    function addTokenGrant(\n', '        address recipient,\n', '        uint256 startTime,\n', '        uint256 amount,\n', '        uint16 vestingDurationInDays,\n', '        uint16 vestingCliffInDays\n', '    ) \n', '        public\n', '    {\n', '        require(msg.sender == owner() || msg.sender == caller, "RewardVesting::addTokenGrant: not owner or caller");\n', '        require(vestingCliffInDays <= 10*365, "RewardVesting::addTokenGrant: cliff more than 10 years");\n', '        require(vestingDurationInDays > 0, "RewardVesting::addTokenGrant: duration must be > 0");\n', '        require(vestingDurationInDays <= 25*365, "RewardVesting::addTokenGrant: duration more than 25 years");\n', '        require(vestingDurationInDays >= vestingCliffInDays, "RewardVesting::addTokenGrant: duration < cliff");\n', '        require(tokenGrants[recipient].amount == 0, "RewardVesting::addTokenGrant: grant already exists for account");\n', '        \n', '        uint256 amountVestedPerDay = amount.div(vestingDurationInDays);\n', '        require(amountVestedPerDay > 0, "RewardVesting::addTokenGrant: amountVestedPerDay > 0");\n', '\n', '        uint256 grantStartTime = startTime == 0 ? block.timestamp : startTime;\n', '\n', '        Grant memory grant = Grant({\n', '            startTime: grantStartTime,\n', '            amount: amount,\n', '            vestingDuration: vestingDurationInDays,\n', '            vestingCliff: vestingCliffInDays,\n', '            totalClaimed: 0\n', '        });\n', '        tokenGrants[recipient] = grant;\n', '        emit GrantAdded(recipient, amount, grantStartTime, vestingDurationInDays, vestingCliffInDays);\n', '    }\n', '\n', '    /**\n', '     * @notice Get token grant for recipient\n', '     * @param recipient The address that has a grant\n', '     * @return the grant\n', '     */\n', '    function getTokenGrant(address recipient) public view returns(Grant memory){\n', '        return tokenGrants[recipient];\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the vested and unclaimed tokens available for `recipient` to claim\n', '     * @dev Due to rounding errors once grant duration is reached, returns the entire left grant amount\n', '     * @dev Returns 0 if cliff has not been reached\n', '     * @param recipient The address that has a grant\n', '     * @return The amount recipient can claim\n', '     */\n', '    function calculateGrantClaim(address recipient) public view returns (uint256) {\n', '        Grant storage tokenGrant = tokenGrants[recipient];\n', '\n', "        // For grants created with a future start date, that hasn't been reached, return 0, 0\n", '        if (block.timestamp < tokenGrant.startTime) {\n', '            return 0;\n', '        }\n', '\n', '        // Check cliff was reached\n', '        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);\n', '        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);\n', '        \n', '        if (elapsedDays < tokenGrant.vestingCliff) {\n', '            return 0;\n', '        }\n', '\n', '        // If over vesting duration, all tokens vested\n', '        if (elapsedDays >= tokenGrant.vestingDuration) {\n', '            uint256 remainingGrant = tokenGrant.amount.sub(tokenGrant.totalClaimed);\n', '            return remainingGrant;\n', '        } else {\n', '            uint256 vestingDurationInSecs = uint256(tokenGrant.vestingDuration).mul(SECONDS_PER_DAY);\n', '            uint256 vestingAmountPerSec = tokenGrant.amount.div(vestingDurationInSecs);\n', '            uint256 amountVested = vestingAmountPerSec.mul(elapsedTime);\n', '            uint256 claimableAmount = amountVested.sub(tokenGrant.totalClaimed);\n', '            return claimableAmount;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the vested (claimed + unclaimed) tokens for `recipient`\n', '     * @dev Returns 0 if cliff has not been reached\n', '     * @param recipient The address that has a grant\n', '     * @return Total vested balance (claimed + unclaimed)\n', '     */\n', '    function vestedBalance(address recipient) external view returns (uint256) {\n', '        Grant storage tokenGrant = tokenGrants[recipient];\n', '\n', "        // For grants created with a future start date, that hasn't been reached, return 0, 0\n", '        if (block.timestamp < tokenGrant.startTime) {\n', '            return 0;\n', '        }\n', '\n', '        // Check cliff was reached\n', '        uint256 elapsedTime = block.timestamp.sub(tokenGrant.startTime);\n', '        uint256 elapsedDays = elapsedTime.div(SECONDS_PER_DAY);\n', '        \n', '        if (elapsedDays < tokenGrant.vestingCliff) {\n', '            return 0;\n', '        }\n', '\n', '        // If over vesting duration, all tokens vested\n', '        if (elapsedDays >= tokenGrant.vestingDuration) {\n', '            return tokenGrant.amount;\n', '        } else {\n', '            uint256 vestingDurationInSecs = uint256(tokenGrant.vestingDuration).mul(SECONDS_PER_DAY);\n', '            uint256 vestingAmountPerSec = tokenGrant.amount.div(vestingDurationInSecs);\n', '            uint256 amountVested = vestingAmountPerSec.mul(elapsedTime);\n', '            return amountVested;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice The balance claimed by `recipient`\n', '     * @param recipient The address that has a grant\n', '     * @return the number of claimed tokens by `recipient`\n', '     */\n', '    function claimedBalance(address recipient) external view returns (uint256) {\n', '        Grant storage tokenGrant = tokenGrants[recipient];\n', '        return tokenGrant.totalClaimed;\n', '    }\n', '\n', '    /**\n', '     * @notice Allows a grant recipient to claim their vested tokens\n', '     * @dev Errors if no tokens have vested\n', '     * @dev It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\n', '     * @param recipient The address that has a grant\n', '     */\n', '    function claimVestedTokens(address recipient) external {\n', '        uint256 amountVested = calculateGrantClaim(recipient);\n', '        require(amountVested > 0, "RewardVesting::claimVested: amountVested is 0");\n', '\n', '        Grant storage tokenGrant = tokenGrants[recipient];\n', '        tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed.add(amountVested));\n', '        \n', '        require(rewardToken.transfer(recipient, amountVested), "RewardVesting::claimVested: transfer failed");\n', '        emit GrantTokensClaimed(recipient, amountVested);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate the number of tokens that will vest per day for the given recipient\n', '     * @param recipient The address that has a grant\n', '     * @return Number of tokens that will vest per day\n', '     */\n', '    function tokensVestedPerDay(address recipient) public view returns(uint256) {\n', '        Grant storage tokenGrant = tokenGrants[recipient];\n', '        return tokenGrant.amount.div(uint256(tokenGrant.vestingDuration));\n', '    }\n', '\n', '    /**\n', '     * @dev Check if a reward has been earned and if so start vesting\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be {caller}\n', '     */\n', '    function onMint(address minter, address to, uint256, uint256 extra) public override {\n', '        require(msg.sender == caller, "RewardVesting::onMint: not caller");\n', '        \n', '        if (minter == to && block.number >= rewardEarnStartBlock && block.number <= rewardEarnEndBlock &&\n', '            extra >= rewardEligibleStartBlock && extra <= rewardEligibleEndBlock) {\n', '            \n', '            if (tokenGrants[to].amount == 0)\n', '                addTokenGrant(to, 0, rewardAmount, rewardVestingDuration, 0);\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../utils/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '// CAUTION\n', '// This version of SafeMath should only be used with Solidity 0.8 or later,\n', "// because it relies on the compiler's built in overflow checks.\n", '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations.\n", ' *\n', ' * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n', ' * now has built in overflow checking.\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            uint256 c = a + b;\n', '            if (c < a) return (false, 0);\n', '            return (true, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b > a) return (false, 0);\n', '            return (true, a - b);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', "            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "            // benefit is lost if 'b' is also tested.\n", '            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '            if (a == 0) return (true, 0);\n', '            uint256 c = a * b;\n', '            if (c / a != b) return (false, 0);\n', '            return (true, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b == 0) return (false, 0);\n', '            return (true, a / b);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b == 0) return (false, 0);\n', '            return (true, a % b);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a + b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a * b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b <= a, errorMessage);\n', '            return a - b;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b > 0, errorMessage);\n', '            return a / b;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b > 0, errorMessage);\n', '            return a % b;\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IOnMint {\n', '    function onMint(address minter, address to, uint256 tokenId, uint256 extra) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../IOnMint.sol";\n', '\n', 'contract OnMintMock is IOnMint {\n', '\n', '    event MockMintEvent(address minter, address to, uint256 tokenId, uint256 extra);\n', '\n', '    function onMint(address minter, address to, uint256 tokenId, uint256 extra) public override {\n', '        emit MockMintEvent(minter, to, tokenId, extra);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC721/ERC721.sol";\n', 'import "./ERC721/ERC721Enumerable.sol";\n', 'import "./ERC20/IERC20.sol";\n', 'import "./access/AccessControl.sol";\n', 'import "./utils/Context.sol";\n', 'import "./utils/cryptography/EIP712.sol";\n', 'import "./child/IChildToken.sol";\n', 'import "./IOnMint.sol";\n', 'import "./IOnBurn.sol";\n', 'import "./IOnTransfer.sol";\n', '\n', 'contract BoughtTheTopNFTChild is Context, AccessControl, ERC721Enumerable, EIP712, IChildToken {\n', '\n', '    /// @notice Base of metdata URI\n', '    string public baseTokenURI;\n', '\n', '    /// @notice Ether fee to mint a new NFT\n', '    uint256 public mintFee;\n', '\n', '    /// @notice Contract to handle extra mint logic\n', '    address public onMint;\n', '\n', '    /// @notice Contract to handle extra burn logic\n', '    address public onBurn;\n', '\n', '    /// @notice Contract to handle extra transfer logic\n', '    address public onTransfer;\n', '\n', '    /// @notice NFTs that have been withdrawn to the root chain\n', '    mapping (uint256 => bool) public withdrawnTokens;\n', '\n', '    /// @notice Maxmimum number of NFTs that can be transferred in a batch due to gas limit restrictions\n', '    uint256 public constant BATCH_LIMIT = 20;\n', '\n', '    /// @notice EIP-712 typehash for mint\n', '    bytes32 public constant MINT_TYPEHASH = keccak256("Mint(address to,uint256 tokenId,uint256 extra)");\n', '\n', '    /// @notice Role identifer for minter\n', '    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");\n', '\n', '    /// @notice Role identifier for fee withdrawer\n', '    bytes32 public constant WITHDRAW_ROLE = keccak256("WITHDRAW_ROLE");\n', '\n', '    /// @notice Role identifier for cross-chain depositor\n', '    bytes32 public constant DEPOSITOR_ROLE = keccak256("DEPOSITOR_ROLE");\n', '    \n', '    /// @notice Emitted when the base token URI changes\n', '    event BaseTokenURIChanged(string uri);\n', '\n', '    /// @notice Emitted when fees are withdrawn\n', '    event FeesWithdrawn(uint256 amount);\n', '\n', '    /// @notice Emitted when the {mintFee} changes\n', '    event MintFeeChanged(uint256 fee);\n', '\n', '    /// @notice Emitted when {onMint} changes\n', '    event OnMintChanged(address set);\n', '\n', '    /// @notice Emitted when {onBurn} changes\n', '    event OnBurnChanged(address set);\n', '\n', '    /// @notice Emitted when {onTransfer} changes\n', '    event OnTransferChanged(address set);\n', '\n', '    /// @notice Emitted when multiple NFTs are withdrawn\n', '    event WithdrawnBatch(address indexed user, uint256[] tokenIds);\n', '\n', '    /// @notice Emitted when an NFT is withdrawn\n', '    event TransferWithMetadata(address indexed from, address indexed to, uint256 indexed tokenId, bytes metaData);\n', '\n', '    /**\n', '     * @dev Initialize contract, owner will be set to the\n', '     * account that deploys the contract.\n', '     */\n', '    constructor() ERC721("BoughtThe.top NFT", "BTT") EIP712("BoughtThe.top NFT", "1") {\n', '        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n', '\n', '        mintFee = 0.01 ether;\n', '    }\n', '\n', '    function _baseURI() internal view virtual override returns (string memory) {\n', '        return baseTokenURI;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the base URI for all tokens.\n', '     *\n', '     * See {ERC721-tokenURI}\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setBaseTokenURI(string calldata uri) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        baseTokenURI = uri;\n', '        emit BaseTokenURIChanged(uri);\n', '    }\n', '\n', '    /**\n', '     * @dev Set the fee to mint a new token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setMintFee(uint256 fee) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        mintFee = fee;\n', '        emit MintFeeChanged(fee);\n', '    }\n', '\n', '    /**\n', '     * @dev Set mint extra logic cotnract\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setOnMint(address set) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        onMint = set;\n', '        emit OnMintChanged(set);\n', '    }\n', '\n', '    /**\n', '     * @dev Set burn extra logic cotnract\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setOnBurn(address set) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        onBurn = set;\n', '        emit OnBurnChanged(set);\n', '    }\n', '\n', '    /**\n', '     * @dev Set transfer extra logic contract\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setOnTransfer(address set) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        onTransfer = set;\n', '        emit OnTransferChanged(set);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw all accumulated ether from the contract\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `WITHDRAW_ROLE`.\n', '     */\n', '    function withdrawFees() public {\n', '        require(hasRole(WITHDRAW_ROLE, _msgSender()), "BoughtTheTopNFT: must have withdraw role");\n', '\n', '        uint256 amount = address(this).balance;\n', '        payable(_msgSender()).transfer(amount);\n', '        emit FeesWithdrawn(amount);\n', '    }\n', '\n', '    function _mintBySignature(address to, uint256 tokenId, uint256 extra, uint8 v, bytes32 r, bytes32 s) internal {\n', '        require(!withdrawnTokens[tokenId], "BoughtTheTopNFT: token exists on root chain");\n', '\n', '        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n', '            MINT_TYPEHASH,\n', '            to,\n', '            tokenId,\n', '            extra\n', '        )));\n', '        address signer = ECDSA.recover(digest, v, r, s);\n', '        require(hasRole(MINTER_ROLE, signer), "BoughtTheTopNFT: must have minter role");\n', '\n', '        // minters may mint for free\n', '        if (!hasRole(MINTER_ROLE, _msgSender())) {\n', '            require(msg.value == mintFee, "BoughtTheTopNFT: incorrect mint fee provided");\n', '        }\n', '\n', '        if (onMint != address(0))\n', '            IOnMint(onMint).onMint(_msgSender(), to, tokenId, extra);\n', '\n', '        _mint(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Creates a new token for `to` with ID `tokenId` using an off-chain signature\n', '     *\n', '     * See {ERC721-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - {mintFee} wei sent with call if caller does not have `MINTER_ROLE`\n', '     * - signature v, r, s must be signed by account with `MINTER_ROLE`\n', '     */\n', '    function mintTo(address to, uint256 tokenId, uint256 extra, uint8 v, bytes32 r, bytes32 s) public payable {\n', '        _mintBySignature(to, tokenId, extra, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Creates a new token for caller with ID `tokenId` using an off-chain signature \n', '     *\n', '     * See {ERC721-_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - caller is owner of token\n', '     * - {mintFee} wei sent with call if caller does not have `MINTER_ROLE`\n', '     * - signature v, r, s must be signed by account with `MINTER_ROLE`\n', '     */\n', '    function mint(uint256 tokenId, uint256 extra, uint8 v, bytes32 r, bytes32 s) public payable {\n', '        _mintBySignature(_msgSender(), tokenId, extra, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Burns `tokenId`. See {ERC721-_burn}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own `tokenId` or be an approved operator.\n', '     * - {burnAllowed} must be true\n', '     */\n', '    function burn(uint256 tokenId) public virtual {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved");\n', '\n', '        if (onBurn != address(0))\n', '            IOnBurn(onBurn).onBurn(tokenId);\n', '\n', '        _burn(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControl, ERC721Enumerable) returns (bool) {\n', '        return super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Enumerable) {\n', '        super._beforeTokenTransfer(from, to, tokenId);\n', '\n', '        if (onTransfer != address(0))\n', '            IOnTransfer(onTransfer).onTransfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Rescue any ERC-20 token the contract may hold\n', '     *\n', '     * @param _token ERC-20 token address\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `WITHDRAW_ROLE`.\n', '     */\n', '    function rescue(address _token) public {\n', '        require(hasRole(WITHDRAW_ROLE, _msgSender()), "BoughtTheTopNFT: must have withdraw role");\n', '        IERC20 token = IERC20(_token);\n', '        token.transfer(_msgSender(), token.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '     * @notice called when token is deposited on root chain\n', '     * @dev Should be callable only by ChildChainManager\n', '     * Should handle deposit by minting the required tokenId(s) for user\n', '     * Should set `withdrawnTokens` mapping to `false` for the tokenId being deposited\n', '     * Minting can also be done by other functions\n', '     * @param user user address for whom deposit is being done\n', '     * @param depositData abi encoded tokenIds. Batch deposit also supported.\n', '     */\n', '    function deposit(address user, bytes calldata depositData) external override {\n', '        require(hasRole(DEPOSITOR_ROLE, _msgSender()), "BoughtTheTopNFT: must have depositor role");\n', '        // deposit single\n', '        if (depositData.length == 32) {\n', '            uint256 tokenId = abi.decode(depositData, (uint256));\n', '            withdrawnTokens[tokenId] = false;\n', '            _mint(user, tokenId);\n', '\n', '        // deposit batch\n', '        } else {\n', '            uint256[] memory tokenIds = abi.decode(depositData, (uint256[]));\n', '            uint256 length = tokenIds.length;\n', '            for (uint256 i; i < length; i++) {\n', '                withdrawnTokens[tokenIds[i]] = false;\n', '                _mint(user, tokenIds[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice called when user wants to withdraw token back to root chain\n', "     * @dev Should handle withraw by burning user's token.\n", '     * Should set `withdrawnTokens` mapping to `true` for the tokenId being withdrawn\n', '     * This transaction will be verified when exiting on root chain\n', '     * @param tokenId tokenId to withdraw\n', '     */\n', '    function withdraw(uint256 tokenId) external {\n', '        require(_msgSender() == ownerOf(tokenId), "BoughtTheTopNFT: invalid token owner");\n', '        withdrawnTokens[tokenId] = true;\n', '        _burn(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @notice called when user wants to withdraw multiple tokens back to root chain\n', "     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n", '     * @param tokenIds tokenId list to withdraw\n', '     */\n', '    function withdrawBatch(uint256[] calldata tokenIds) external {\n', '\n', '        uint256 length = tokenIds.length;\n', '        require(length <= BATCH_LIMIT, "BoughtTheTopNFT: exceeds batch limit");\n', '\n', '        // Iteratively burn ERC721 tokens, for performing\n', '        // batch withdraw\n', '        for (uint256 i; i < length; i++) {\n', '\n', '            uint256 tokenId = tokenIds[i];\n', '\n', '            require(_msgSender() == ownerOf(tokenId), string(abi.encodePacked("BoughtTheTopNFT: invalid token owner ", tokenId)));\n', '            withdrawnTokens[tokenId] = true;\n', '            _burn(tokenId);\n', '        }\n', '\n', '        // At last emit this event, which will be used\n', '        // in MintableERC721 predicate contract on L1\n', '        // while verifying burn proof\n', '        emit WithdrawnBatch(_msgSender(), tokenIds);\n', '    }\n', '\n', '    /**\n', '     * @notice called when user wants to withdraw token back to root chain with token URI\n', "     * @dev Should handle withraw by burning user's token.\n", '     * Should set `withdrawnTokens` mapping to `true` for the tokenId being withdrawn\n', '     * This transaction will be verified when exiting on root chain\n', '     *\n', '     * @param tokenId tokenId to withdraw\n', '     */\n', '    function withdrawWithMetadata(uint256 tokenId) external {\n', '\n', '        require(_msgSender() == ownerOf(tokenId), "BoughtTheTopNFT: invalid token owner");\n', '        withdrawnTokens[tokenId] = true;\n', '\n', '        // Encoding metadata associated with tokenId & emitting event\n', '        emit TransferWithMetadata(ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId));\n', '\n', '        _burn(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @notice This method is supposed to be called by client when withdrawing token with metadata\n', '     * and pass return value of this function as second paramter of `withdrawWithMetadata` method\n', '     *\n', '     * It can be overridden by clients to encode data in a different form, which needs to\n', '     * be decoded back by them correctly during exiting\n', '     *\n', '     */\n', '    function encodeTokenMetadata(uint256) external view virtual returns (bytes memory) {\n', '        bytes memory empty;\n', '        return empty;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC721.sol";\n', 'import "./IERC721Receiver.sol";\n', 'import "./IERC721Metadata.sol";\n', 'import "./IERC721Enumerable.sol";\n', 'import "../utils/Address.sol";\n', 'import "../utils/Context.sol";\n', 'import "../utils/Strings.sol";\n', 'import "../utils/introspection/ERC165.sol";\n', '\n', '/**\n', ' * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n', ' * the Metadata extension, but not including the Enumerable extension, which is available separately as\n', ' * {ERC721Enumerable}.\n', ' */\n', 'contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n', '    using Address for address;\n', '    using Strings for uint256;\n', '\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Mapping from token ID to owner address\n', '    mapping (uint256 => address) private _owners;\n', '\n', '    // Mapping owner address to token count\n', '    mapping (address => uint256) private _balances;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n', '        return interfaceId == type(IERC721).interfaceId\n', '            || interfaceId == type(IERC721Metadata).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-balanceOf}.\n', '     */\n', '    function balanceOf(address owner) public view virtual override returns (uint256) {\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-ownerOf}.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n', '        address owner = _owners[tokenId];\n', '        require(owner != address(0), "ERC721: owner query for nonexistent token");\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-name}.\n', '     */\n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-symbol}.\n', '     */\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-tokenURI}.\n', '     */\n', '    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        string memory baseURI = _baseURI();\n', '        return bytes(baseURI).length > 0\n', '            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n', "            : '';\n", '    }\n', '\n', '    /**\n', '     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n', '     * in child contracts.\n', '     */\n', '    function _baseURI() internal view virtual returns (string memory) {\n', '        return "";\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) public virtual override {\n', '        address owner = ERC721.ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(operator != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mechanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `tokenId` exists.\n', '     *\n', '     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n', '     *\n', '     * Tokens start existing when they are minted (`_mint`),\n', '     * and stop existing when they are burned (`_burn`).\n', '     */\n', '    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n', '        return _owners[tokenId] != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ERC721.ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Safely mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must not exist.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeMint(address to, uint256 tokenId) internal virtual {\n', '        _safeMint(to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n', '     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n', '     */\n', '    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n', '        _mint(to, tokenId);\n', '        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must not exist.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal virtual {\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '\n', '        _beforeTokenTransfer(address(0), to, tokenId);\n', '\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `tokenId`.\n', '     * The approval is cleared when the token is burned.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _burn(uint256 tokenId) internal virtual {\n', '        address owner = ERC721.ownerOf(tokenId);\n', '\n', '        _beforeTokenTransfer(owner, address(0), tokenId);\n', '\n', '        // Clear approvals\n', '        _approve(address(0), tokenId);\n', '\n', '        _balances[owner] -= 1;\n', '        delete _owners[tokenId];\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n', '        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        // Clear approvals from the previous owner\n', '        _approve(address(0), tokenId);\n', '\n', '        _balances[from] -= 1;\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve `to` to operate on `tokenId`\n', '     *\n', '     * Emits a {Approval} event.\n', '     */\n', '    function _approve(address to, uint256 tokenId) internal virtual {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        private returns (bool)\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n', '                return retval == IERC721Receiver(to).onERC721Received.selector;\n', '            } catch (bytes memory reason) {\n', '                if (reason.length == 0) {\n', '                    revert("ERC721: transfer to non ERC721Receiver implementer");\n', '                } else {\n', '                    // solhint-disable-next-line no-inline-assembly\n', '                    assembly {\n', '                        revert(add(32, reason), mload(reason))\n', '                    }\n', '                }\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC721.sol";\n', 'import "./IERC721Enumerable.sol";\n', '\n', '/**\n', ' * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n', ' * enumerability of all the token ids in the contract as well as all token ids owned by each\n', ' * account.\n', ' */\n', 'abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n', '        return interfaceId == type(IERC721Enumerable).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n', '        require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenByIndex}.\n', '     */\n', '    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n', '        require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, tokenId);\n', '\n', '        if (from == address(0)) {\n', '            _addTokenToAllTokensEnumeration(tokenId);\n', '        } else if (from != to) {\n', '            _removeTokenFromOwnerEnumeration(from, tokenId);\n', '        }\n', '        if (to == address(0)) {\n', '            _removeTokenFromAllTokensEnumeration(tokenId);\n', '        } else if (to != from) {\n', '            _addTokenToOwnerEnumeration(to, tokenId);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        uint256 length = ERC721.balanceOf(to);\n', '        _ownedTokens[to][length] = tokenId;\n', '        _ownedTokensIndex[tokenId] = length;\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        delete _ownedTokensIndex[tokenId];\n', '        delete _ownedTokens[from][lastTokenIndex];\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length - 1;\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        delete _allTokensIndex[tokenId];\n', '        _allTokens.pop();\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ECDSA.sol";\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n', ' *\n', ' * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n', ' * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n', ' * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n', ' *\n', ' * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n', ' * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n', ' * ({_hashTypedDataV4}).\n', ' *\n', ' * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n', ' * the chain id to protect against replay attacks on an eventual fork of the chain.\n', ' *\n', ' * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method\n', ' * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'abstract contract EIP712 {\n', '    /* solhint-disable var-name-mixedcase */\n', '    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n', '    // invalidate the cached domain separator if the chain id changes.\n', '    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n', '    uint256 private immutable _CACHED_CHAIN_ID;\n', '\n', '    bytes32 private immutable _HASHED_NAME;\n', '    bytes32 private immutable _HASHED_VERSION;\n', '    bytes32 private immutable _TYPE_HASH;\n', '    /* solhint-enable var-name-mixedcase */\n', '\n', '    /**\n', '     * @dev Initializes the domain separator and parameter caches.\n', '     *\n', '     * The meaning of `name` and `version` is specified in\n', '     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n', '     *\n', '     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n', '     * - `version`: the current major version of the signing domain.\n', '     *\n', '     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n', '     * contract upgrade].\n', '     */\n', '    constructor(string memory name, string memory version) {\n', '        bytes32 hashedName = keccak256(bytes(name));\n', '        bytes32 hashedVersion = keccak256(bytes(version));\n', '        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '        _HASHED_NAME = hashedName;\n', '        _HASHED_VERSION = hashedVersion;\n', '        _CACHED_CHAIN_ID = block.chainid;\n', '        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n', '        _TYPE_HASH = typeHash;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the domain separator for the current chain.\n', '     */\n', '    function _domainSeparatorV4() internal view returns (bytes32) {\n', '        if (block.chainid == _CACHED_CHAIN_ID) {\n', '            return _CACHED_DOMAIN_SEPARATOR;\n', '        } else {\n', '            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n', '        }\n', '    }\n', '\n', '    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n', '        return keccak256(\n', '            abi.encode(\n', '                typeHash,\n', '                name,\n', '                version,\n', '                block.chainid,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n', '     * function returns the hash of the fully encoded EIP712 message for this domain.\n', '     *\n', '     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n', '     *\n', '     * ```solidity\n', '     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n', '     *     keccak256("Mail(address to,string contents)"),\n', '     *     mailTo,\n', '     *     keccak256(bytes(mailContents))\n', '     * )));\n', '     * address signer = ECDSA.recover(digest, signature);\n', '     * ```\n', '     */\n', '    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n', '        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IChildToken {\n', '    function deposit(address user, bytes calldata depositData) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IOnBurn {\n', '    function onBurn(uint256 tokenId) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IOnTransfer {\n', '    function onTransfer(address from, address to, uint256 tokenId) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../utils/introspection/IERC165.sol";\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC721.sol";\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the token collection name.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC721.sol";\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the total amount of tokens stored by the contract.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n', "     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n", '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n', '     * Use along with {totalSupply} to enumerate all tokens.\n', '     */\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev String operations.\n', ' */\n', 'library Strings {\n', '    bytes16 private constant alphabet = "0123456789abcdef";\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n', '     */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        while (value != 0) {\n', '            digits -= 1;\n', '            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n', '            value /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n', '     */\n', '    function toHexString(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0x00";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 length = 0;\n', '        while (temp != 0) {\n', '            length++;\n', '            temp >>= 8;\n', '        }\n', '        return toHexString(value, length);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n', '     */\n', '    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n', '        bytes memory buffer = new bytes(2 * length + 2);\n', '        buffer[0] = "0";\n', '        buffer[1] = "x";\n', '        for (uint256 i = 2 * length + 1; i > 1; --i) {\n', '            buffer[i] = alphabet[value & 0xf];\n', '            value >>= 4;\n', '        }\n', '        require(value == 0, "Strings: hex length insufficient");\n', '        return string(buffer);\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Returns the address that signed a hashed message (`hash`) with\n', '     * `signature`. This address can then be used for verification purposes.\n', '     *\n', '     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n', '     * this function rejects them by requiring the `s` value to be in the lower\n', '     * half order, and the `v` value to be either 27 or 28.\n', '     *\n', '     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n', '     * verification to be secure: it is possible to craft signatures that\n', '     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n', '     * this is by receiving a hash of the original message (which may otherwise\n', '     * be too long), and then calling {toEthSignedMessageHash} on it.\n', '     */\n', '    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n', '        // Check the signature length\n', '        if (signature.length != 65) {\n', '            revert("ECDSA: invalid signature length");\n', '        }\n', '\n', '        // Divide the signature in r, s and v variables\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := byte(0, mload(add(signature, 0x60)))\n', '        }\n', '\n', '        return recover(hash, v, r, s);\n', '    }\n', '\n', '    /**\n', '     * @dev Overload of {ECDSA-recover} that receives the `v`,\n', '     * `r` and `s` signature fields separately.\n', '     */\n', '    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n', '        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer != address(0), "ECDSA: invalid signature");\n', '\n', '        return signer;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n', '     * produces hash corresponding to the one signed with the\n', '     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n', '     * JSON-RPC method as part of EIP-191.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n', '        // 32 is the length in bytes of hash,\n', '        // enforced by the type signature above\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Typed Data, created from a\n', '     * `domainSeparator` and a `structHash`. This produces hash corresponding\n', '     * to the one signed with the\n', '     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n', '     * JSON-RPC method as part of EIP-712.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../IOnTransfer.sol";\n', '\n', 'contract OnTransferMock is IOnTransfer {\n', '\n', '    event MockTransferEvent(address from, address to, uint256 tokenId);\n', '\n', '    function onTransfer(address from, address to, uint256 tokenId) public override {\n', '        emit MockTransferEvent(from, to, tokenId);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../IOnBurn.sol";\n', '\n', 'contract OnBurnMock is IOnBurn {\n', '\n', '    event MockBurnEvent(uint256 tokenId);\n', '\n', '    function onBurn(uint256 tokenId) public override {\n', '        emit MockBurnEvent(tokenId);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20/ERC20.sol";\n', 'import "./access/AccessControl.sol";\n', 'import "./utils/Context.sol";\n', 'import "./child/IChildToken.sol";\n', '\n', 'contract BoughtTheTopTokenChild is Context, AccessControl, IChildToken, ERC20 {\n', '    /// @notice Role identifer for off-chain depositor\n', '    bytes32 public constant DEPOSITOR_ROLE = keccak256("DEPOSITOR_ROLE");\n', '\n', '    /**\n', '     * @dev Grants `DEFAULT_ADMIN_ROLE` to the account that deploys the contract.\n', '     *\n', '     * See {ERC20-constructor}.\n', '     */\n', '    constructor() ERC20("BoughtThe.top", "BTT") {\n', '        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n', '    }\n', '\n', '    /**\n', '     * @notice called when token is deposited on root chain\n', '     * @dev Should be callable only by ChildChainManager\n', '     * Should handle deposit by minting the required amount for user\n', '     * Make sure minting is done only by this function\n', '     * @param user user address for whom deposit is being done\n', '     * @param depositData abi encoded amount\n', '     */\n', '    function deposit(address user, bytes calldata depositData) external override {\n', '        require(hasRole(DEPOSITOR_ROLE, _msgSender()), "BoughtTheTopToken: must have depositor role");\n', '        uint256 amount = abi.decode(depositData, (uint256));\n', '        _mint(user, amount);\n', '    }\n', '\n', '    /**\n', '     * @notice called when user wants to withdraw tokens back to root chain\n', "     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n", '     * @param amount amount of tokens to withdraw\n', '     */\n', '    function withdraw(uint256 amount) external {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC721/ERC721.sol";\n', 'import "./ERC721/ERC721Enumerable.sol";\n', 'import "./ERC721/IMintableERC721.sol";\n', 'import "./ERC20/IERC20.sol";\n', 'import "./access/AccessControl.sol";\n', 'import "./utils/Context.sol";\n', '\n', 'contract BoughtTheTopNFTRoot is Context, AccessControl, ERC721Enumerable, IMintableERC721  {\n', '\n', '    /// @notice Base of metdata URI\n', '    string public baseTokenURI;\n', '\n', '    /// @notice Role identifer for cross-chain minter\n', '    bytes32 public constant PREDICATE_ROLE = keccak256("PREDICATE_ROLE");\n', '    \n', '    /// @notice Emitted when the base token URI changes\n', '    event BaseTokenURIChanged(string uri);\n', '\n', '    /**\n', '     * @dev Initialize contract, owner will be set to the\n', '     * account that deploys the contract.\n', '     */\n', '    constructor() ERC721("BoughtThe.top NFT", "BTT") {\n', '        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n', '    }\n', '\n', '    function _baseURI() internal view virtual override returns (string memory) {\n', '        return baseTokenURI;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the base URI for all tokens.\n', '     *\n', '     * See {ERC721-tokenURI}\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `DEFAULT_ADMIN_ROLE`.\n', '     */\n', '    function setBaseTokenURI(string calldata uri) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have admin role");\n', '\n', '        baseTokenURI = uri;\n', '        emit BaseTokenURIChanged(uri);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IMintableERC721-mint}.\n', '     */\n', '    function mint(address user, uint256 tokenId) external override {\n', '        require(hasRole(PREDICATE_ROLE, _msgSender()), "BoughtTheTopNFT: must have predicate role");\n', '        _mint(user, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IMintableERC721-mint}.\n', '     * \n', '     */\n', '    function mint(address user, uint256 tokenId, bytes calldata) external override {\n', '        require(hasRole(PREDICATE_ROLE, _msgSender()), "BoughtTheTopNFT: must have predicate role");\n', '        _mint(user, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IMintableERC721-exists}.\n', '     */\n', '    function exists(uint256 tokenId) external view override returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControl, ERC721Enumerable) returns (bool) {\n', '        return super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev Rescue any ERC-20 token the contract may hold\n', '     *\n', '     * @param _token ERC-20 token address\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must have the `WITHDRAW_ROLE`.\n', '     */\n', '    function rescue(address _token) public {\n', '        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "BoughtTheTopNFT: must have withdraw role");\n', '        IERC20 token = IERC20(_token);\n', '        token.transfer(_msgSender(), token.balanceOf(address(this)));\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IMintableERC721 {\n', '    /**\n', '     * @notice called by predicate contract to mint tokens while withdrawing\n', '     * @dev Should be callable only by MintableERC721Predicate\n', '     * Make sure minting is done only by this function\n', '     * @param user user address for whom token is being minted\n', '     * @param tokenId tokenId being minted\n', '     */\n', '    function mint(address user, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @notice called by predicate contract to mint tokens while withdrawing with metadata from L2\n', '     * @dev Should be callable only by MintableERC721Predicate\n', '     * Make sure minting is only done either by this function/ 👆\n', '     * @param user user address for whom token is being minted\n', '     * @param tokenId tokenId being minted\n', '     * @param metaData Associated token metadata, to be decoded & set using `setTokenMetadata`\n', '     *\n', "     * Note : If you're interested in taking token metadata from L2 to L1 during exit, you must\n", '     * implement this method\n', '     */\n', '    function mint(address user, uint256 tokenId, bytes calldata metaData) external;\n', '\n', '    /**\n', '     * @notice check if token already exists, return true if it does exist\n', '     * @dev this check will be used by the predicate to determine if the token needs to be minted or transfered\n', '     * @param tokenId tokenId being checked\n', '     */\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "../utils/Address.sol";\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender) + value;\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        unchecked {\n', '            uint256 oldAllowance = token.allowance(address(this), spender);\n', '            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n', '            uint256 newAllowance = oldAllowance - value;\n', '            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20/IERC20.sol";\n', 'import "./ERC20/SafeERC20.sol";\n', 'import "./utils/structs/EnumerableSet.sol";\n', 'import "./utils/math/SafeMath.sol";\n', 'import "./access/Ownable.sol";\n', '\n', 'interface IMigrator {\n', '    // Perform LP token migration.\n', '    // Take the current LP token address and return the new LP token address.\n', "    // Migrator should have full access to the caller's LP token.\n", '    // Return the new LP token address.\n', '    //\n', '    // XXX Migrator must have allowance access to LP tokens.\n', '    // Must mint EXACTLY the same amount of SushiSwap LP tokens or\n', '    // else something bad will happen. Traditional UniswapV2 does not\n', '    // do that so be careful!\n', '    function migrate(IERC20 token) external returns (IERC20);\n', '}\n', '\n', '/**\n', ' * @title LPStaking\n', ' * @dev The LP staking contract (forked from SushiSwap MasterChef)\n', ' */\n', 'contract LPStaking is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount; // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '        //\n', '        // We do some fancy math here. Basically, any point in time, the amount of tokens\n', '        // entitled to a user but is pending to be distributed is:\n', '        //\n', '        //   pending reward = (user.amount * pool.accTokenPerShare) - user.rewardDebt\n', '        //\n', "        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n", "        //   1. The pool's `accTokenPerShare` (and `lastRewardBlock`) gets updated.\n", '        //   2. User receives the pending reward sent to his/her address.\n', "        //   3. User's `amount` gets updated.\n", "        //   4. User's `rewardDebt` gets updated.\n", '    }\n', '    // Info of each pool.\n', '    struct PoolInfo {\n', '        IERC20 lpToken; // Address of LP token contract.\n', '        uint256 allocPoint; // How many allocation points assigned to this pool. TOKENs to distribute per block.\n', '        uint256 lastRewardBlock; // Last block number that TOKENs distribution occurs.\n', '        uint256 accTokenPerShare; // Accumulated TOKENs per share, times 1e12. See below.\n', '    }\n', '    // The TOKEN!\n', '    IERC20 public token;\n', '    // Dev address.\n', '    address public devaddr;\n', '    // Block number when bonus token period ends.\n', '    uint256 public bonusEndBlock;\n', '    // TOKEN tokens created per block.\n', '    uint256 public tokenPerBlock;\n', '    // Bonus muliplier for early token makers.\n', '    uint256 public constant BONUS_MULTIPLIER = 5;\n', '    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n', '    IMigrator public migrator;\n', '    // Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '    // Info of each user that stakes LP tokens.\n', '    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n', '    // Total allocation poitns. Must be the sum of all allocation points in all pools.\n', '    uint256 public totalAllocPoint = 0;\n', '    // The block number when TOKEN mining starts.\n', '    uint256 public startBlock;\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(\n', '        address indexed user,\n', '        uint256 indexed pid,\n', '        uint256 amount\n', '    );\n', '\n', '    constructor(\n', '        IERC20 _token,\n', '        address _devaddr,\n', '        uint256 _tokenPerBlock,\n', '        uint256 _startBlock,\n', '        uint256 _bonusEndBlock\n', '    ) {\n', '        token = _token;\n', '        devaddr = _devaddr;\n', '        tokenPerBlock = _tokenPerBlock;\n', '        bonusEndBlock = _bonusEndBlock;\n', '        startBlock = _startBlock;\n', '    }\n', '\n', '    function poolLength() external view returns (uint256) {\n', '        return poolInfo.length;\n', '    }\n', '\n', '    // Add a new lp to the pool. Can only be called by the owner.\n', '    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n', '    function add(\n', '        uint256 _allocPoint,\n', '        IERC20 _lpToken,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        uint256 lastRewardBlock =\n', '            block.number > startBlock ? block.number : startBlock;\n', '        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '        poolInfo.push(\n', '            PoolInfo({\n', '                lpToken: _lpToken,\n', '                allocPoint: _allocPoint,\n', '                lastRewardBlock: lastRewardBlock,\n', '                accTokenPerShare: 0\n', '            })\n', '        );\n', '    }\n', '\n', "    // Update the given pool's TOKEN allocation point. Can only be called by the owner.\n", '    function set(\n', '        uint256 _pid,\n', '        uint256 _allocPoint,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n', '            _allocPoint\n', '        );\n', '        poolInfo[_pid].allocPoint = _allocPoint;\n', '    }\n', '\n', '    // Set the migrator contract. Can only be called by the owner.\n', '    function setMigrator(IMigrator _migrator) public onlyOwner {\n', '        migrator = _migrator;\n', '    }\n', '\n', '    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\n', '    function migrate(uint256 _pid) public {\n', '        require(address(migrator) != address(0), "migrate: no migrator");\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        IERC20 lpToken = pool.lpToken;\n', '        uint256 bal = lpToken.balanceOf(address(this));\n', '        lpToken.safeApprove(address(migrator), bal);\n', '        IERC20 newLpToken = migrator.migrate(lpToken);\n', '        require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");\n', '        pool.lpToken = newLpToken;\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getMultiplier(uint256 _from, uint256 _to)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (_to <= bonusEndBlock) {\n', '            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n', '        } else if (_from >= bonusEndBlock) {\n', '            return _to.sub(_from);\n', '        } else {\n', '            return\n', '                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\n', '                    _to.sub(bonusEndBlock)\n', '                );\n', '        }\n', '    }\n', '\n', '    // View function to see pending TOKENs on frontend.\n', '    function pendingToken(uint256 _pid, address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][_user];\n', '        uint256 accTokenPerShare = pool.accTokenPerShare;\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n', '            uint256 multiplier =\n', '                getMultiplier(pool.lastRewardBlock, block.number);\n', '            uint256 tokenReward =\n', '                multiplier.mul(tokenPerBlock).mul(pool.allocPoint).div(\n', '                    totalAllocPoint\n', '                );\n', '            accTokenPerShare = accTokenPerShare.add(\n', '                tokenReward.mul(1e12).div(lpSupply)\n', '            );\n', '        }\n', '        return user.amount.mul(accTokenPerShare).div(1e12).sub(user.rewardDebt);\n', '    }\n', '\n', '    // Update reward vairables for all pools. Be careful of gas spending!\n', '    function massUpdatePools() public {\n', '        uint256 length = poolInfo.length;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            updatePool(pid);\n', '        }\n', '    }\n', '\n', '    // Update reward variables of the given pool to be up-to-date.\n', '    function updatePool(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        if (block.number <= pool.lastRewardBlock) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (lpSupply == 0) {\n', '            pool.lastRewardBlock = block.number;\n', '            return;\n', '        }\n', '        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n', '        uint256 tokenReward =\n', '            multiplier.mul(tokenPerBlock).mul(pool.allocPoint).div(\n', '                totalAllocPoint\n', '            );\n', '\n', '        pool.accTokenPerShare = pool.accTokenPerShare.add(\n', '            tokenReward.mul(1e12).div(lpSupply)\n', '        );\n', '        pool.lastRewardBlock = block.number;\n', '    }\n', '\n', '    // Deposit LP tokens to MasterChef for TOKEN allocation.\n', '    function deposit(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        updatePool(_pid);\n', '        if (user.amount > 0) {\n', '            uint256 pending =\n', '                user.amount.mul(pool.accTokenPerShare).div(1e12).sub(\n', '                    user.rewardDebt\n', '                );\n', '            safeTokenTransfer(msg.sender, pending);\n', '        }\n', '        pool.lpToken.safeTransferFrom(\n', '            address(msg.sender),\n', '            address(this),\n', '            _amount\n', '        );\n', '        user.amount = user.amount.add(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);\n', '        emit Deposit(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw LP tokens from MasterChef.\n', '    function withdraw(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        require(user.amount >= _amount, "withdraw: not good");\n', '        updatePool(_pid);\n', '        uint256 pending =\n', '            user.amount.mul(pool.accTokenPerShare).div(1e12).sub(\n', '                user.rewardDebt\n', '            );\n', '        safeTokenTransfer(msg.sender, pending);\n', '        user.amount = user.amount.sub(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12);\n', '        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n', '        emit Withdraw(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n', '        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '    }\n', '\n', '    // Safe token transfer function, just in case if rounding error causes pool to not have enough TOKENs.\n', '    function safeTokenTransfer(address _to, uint256 _amount) internal {\n', '        uint256 tokenBal = token.balanceOf(address(this));\n', '        if (_amount > tokenBal) {\n', '            token.transfer(_to, tokenBal);\n', '        } else {\n', '            token.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '    // Update dev address by the previous dev.\n', '    function dev(address _devaddr) public {\n', '        require(msg.sender == devaddr, "dev: wut?");\n', '        devaddr = _devaddr;\n', '    }\n', '\n', '    /**\n', '     * @dev Rescue any ERC-20 token the contract may hold\n', '     *\n', '     * @param _token ERC-20 token address\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be owner\n', '     */\n', '    function rescue(address _token) public onlyOwner {\n', '        IERC20 rescuing = IERC20(_token);\n', '        rescuing.transfer(msg.sender, rescuing.balanceOf(address(this)));\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Library for managing\n', ' * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', ' * types.\n', ' *\n', ' * Sets have the following properties:\n', ' *\n', ' * - Elements are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableSet for EnumerableSet.AddressSet;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableSet.AddressSet private mySet;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n', ' * and `uint256` (`UintSet`) are supported.\n', ' */\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // Bytes32Set\n', '\n', '    struct Bytes32Set {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _add(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _remove(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n', '        return _contains(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(Bytes32Set storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n', '        return _at(set._inner, index);\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint160(uint256(_at(set._inner, index))));\n', '    }\n', '\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 9999\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "metadata": {\n', '    "useLiteralContent": true\n', '  }\n', '}']