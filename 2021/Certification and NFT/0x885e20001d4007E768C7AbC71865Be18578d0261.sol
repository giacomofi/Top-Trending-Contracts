['//SPDX-License-Identifier: Unlicense\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./ServiceInterface.sol";\n', 'import "./IERC1155Preset.sol";\n', 'import "./StrongNFTBonusLegacyInterface.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Context.sol";\n', 'import "./ERC1155Receiver.sol";\n', '\n', 'contract StrongNFTBonusV5 is Context {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\n', '  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\n', '\n', '  ServiceInterface public CService;\n', '  IERC1155Preset public CERC1155;\n', '  StrongNFTBonusLegacyInterface public CStrongNFTBonus;\n', '\n', '  bool public initDone;\n', '\n', '  address public serviceAdmin;\n', '  address public superAdmin;\n', '\n', '  string[] public nftBonusNames;\n', '  mapping(string => uint256) public nftBonusLowerBound;\n', '  mapping(string => uint256) public nftBonusUpperBound;\n', '  mapping(string => uint256) public nftBonusValue;\n', '  mapping(string => uint256) public nftBonusEffectiveBlock;\n', '\n', '  mapping(uint256 => address) public nftIdStakedToEntity;\n', '  mapping(uint256 => uint128) public nftIdStakedToNodeId;\n', '  mapping(uint256 => uint256) public nftIdStakedAtBlock;\n', '  mapping(address => mapping(uint128 => uint256)) public entityNodeStakedNftId;\n', '\n', '  mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '  mapping(string => uint8) public nftBonusNodesLimit;\n', '  mapping(uint256 => uint8) public nftIdStakedToNodesCount;\n', '  mapping(uint128 => uint256) public nodeIdStakedAtBlock;\n', '  mapping(address => uint256[]) public entityStakedNftIds;\n', '\n', '  mapping(address => mapping(uint128 => uint256)) public entityNodeStakedAtBlock;\n', '\n', '  function init(address serviceContract, address nftContract, address strongNFTBonusContract, address serviceAdminAddress, address superAdminAddress) public {\n', '    require(initDone == false, "init done");\n', '\n', '    _registerInterface(0x01ffc9a7);\n', '    _registerInterface(\n', '      ERC1155Receiver(0).onERC1155Received.selector ^\n', '      ERC1155Receiver(0).onERC1155BatchReceived.selector\n', '    );\n', '\n', '    serviceAdmin = serviceAdminAddress;\n', '    superAdmin = superAdminAddress;\n', '    CService = ServiceInterface(serviceContract);\n', '    CERC1155 = IERC1155Preset(nftContract);\n', '    CStrongNFTBonus = StrongNFTBonusLegacyInterface(strongNFTBonusContract);\n', '    initDone = true;\n', '  }\n', '\n', '  //\n', '  // Getters\n', '  // -------------------------------------------------------------------------------------------------------------------\n', '\n', '  function isNftStaked(uint256 _nftId) public view returns (bool) {\n', '    return nftIdStakedToNodeId[_nftId] != 0 || nftIdStakedToNodesCount[_nftId] > 0;\n', '  }\n', '\n', '  function isNftStakedLegacy(uint256 _nftId) public view returns (bool) {\n', '    return CStrongNFTBonus.isNftStaked(_nftId);\n', '  }\n', '\n', '  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\n', '    uint256 stakedNftId = entityNodeStakedNftId[_entity][_nodeId];\n', '    uint256 stakedNftIdLegacy = CStrongNFTBonus.getStakedNftId(_entity, _nodeId);\n', '    return stakedNftId != 0 ? stakedNftId : stakedNftIdLegacy;\n', '  }\n', '\n', '  function getStakedNftIds(address _entity) public view returns (uint256[] memory) {\n', '    return entityStakedNftIds[_entity];\n', '  }\n', '\n', '  function getNftBonusNames() public view returns (string[] memory) {\n', '    return nftBonusNames;\n', '  }\n', '\n', '  function getNftNodesLeft(uint256 _nftId) public view returns (uint256) {\n', '    return nftBonusNodesLimit[getNftBonusName(_nftId)] - nftIdStakedToNodesCount[_nftId];\n', '  }\n', '\n', '  function getNftBonusName(uint256 _nftId) public view returns (string memory) {\n', '    for (uint8 i = 0; i < nftBonusNames.length; i++) {\n', '      if (_nftId >= nftBonusLowerBound[nftBonusNames[i]] && _nftId <= nftBonusUpperBound[nftBonusNames[i]]) {\n', '        return nftBonusNames[i];\n', '      }\n', '    }\n', '\n', '    return "";\n', '  }\n', '\n', '  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\n', '    uint256 nftId = getStakedNftId(_entity, _nodeId);\n', '    string memory bonusName = getNftBonusName(nftId);\n', '    if (keccak256(abi.encode(bonusName)) == keccak256(abi.encode(""))) return 0;\n', '\n', '    uint256 stakedAtBlock = entityNodeStakedAtBlock[_entity][_nodeId] > 0\n', '    ? entityNodeStakedAtBlock[_entity][_nodeId] : nftIdStakedAtBlock[nftId];\n', '    uint256 effectiveBlock = nftBonusEffectiveBlock[bonusName];\n', '    uint256 startFromBlock = stakedAtBlock > _fromBlock ? stakedAtBlock : _fromBlock;\n', '    if (startFromBlock < effectiveBlock) {\n', '      startFromBlock = effectiveBlock;\n', '    }\n', '\n', '    if (stakedAtBlock == 0 && keccak256(abi.encode(bonusName)) == keccak256(abi.encode("BRONZE"))) {\n', '      return CStrongNFTBonus.getBonus(_entity, _nodeId, startFromBlock, _toBlock);\n', '    }\n', '\n', '    if (nftId == 0) return 0;\n', '    if (stakedAtBlock == 0) return 0;\n', '    if (effectiveBlock == 0) return 0;\n', '    if (startFromBlock >= _toBlock) return 0;\n', '    if (CERC1155.balanceOf(address(this), nftId) == 0) return 0;\n', '\n', '    return _toBlock.sub(startFromBlock).mul(nftBonusValue[bonusName]);\n', '  }\n', '\n', '  //\n', '  // Staking\n', '  // -------------------------------------------------------------------------------------------------------------------\n', '\n', '  function stakeNFT(uint256 _nftId, uint128 _nodeId) public payable {\n', '    string memory bonusName = getNftBonusName(_nftId);\n', '    require(keccak256(abi.encode(bonusName)) != keccak256(abi.encode("")), "not eligible");\n', '    require(CERC1155.balanceOf(_msgSender(), _nftId) != 0\n', '      || (CERC1155.balanceOf(address(this), _nftId) != 0 && nftIdStakedToEntity[_nftId] == _msgSender()), "not enough");\n', '    require(nftIdStakedToNodesCount[_nftId] < nftBonusNodesLimit[bonusName], "over limit");\n', '    require(entityNodeStakedNftId[_msgSender()][_nodeId] == 0, "already staked");\n', '    require(CService.doesNodeExist(_msgSender(), _nodeId), "node doesnt exist");\n', '\n', '    entityNodeStakedNftId[_msgSender()][_nodeId] = _nftId;\n', '    nftIdStakedToEntity[_nftId] = _msgSender();\n', '    entityNodeStakedAtBlock[_msgSender()][_nodeId] = block.number;\n', '    nftIdStakedToNodesCount[_nftId] += 1;\n', '\n', '    bool alreadyExists = false;\n', '    for (uint8 i = 0; i < entityStakedNftIds[_msgSender()].length; i++) {\n', '      if (entityStakedNftIds[_msgSender()][i] == _nftId) {\n', '        alreadyExists = true;\n', '        break;\n', '      }\n', '    }\n', '    if (!alreadyExists) {\n', '      entityStakedNftIds[_msgSender()].push(_nftId);\n', '    }\n', '\n', '    if (CERC1155.balanceOf(address(this), _nftId) == 0) {\n', '      CERC1155.safeTransferFrom(_msgSender(), address(this), _nftId, 1, bytes(""));\n', '    }\n', '\n', '    emit Staked(_msgSender(), _nftId, _nodeId, block.number);\n', '  }\n', '\n', '  function unStakeNFT(uint256 _nftId, uint128 _nodeId, uint256 _blockNumber) public payable {\n', '    require(entityNodeStakedNftId[_msgSender()][_nodeId] == _nftId, "wrong node");\n', '    require(nftIdStakedToEntity[_nftId] != address(0), "not staked");\n', '    require(nftIdStakedToEntity[_nftId] == _msgSender(), "not staker");\n', '\n', '    CService.claim{value : msg.value}(_nodeId, _blockNumber, false);\n', '\n', '    entityNodeStakedNftId[_msgSender()][_nodeId] = 0;\n', '    nftIdStakedToNodeId[_nftId] = 0;\n', '\n', '    if (nftIdStakedToNodesCount[_nftId] > 0) {\n', '      nftIdStakedToNodesCount[_nftId] -= 1;\n', '    }\n', '\n', '    if (nftIdStakedToNodesCount[_nftId] == 0) {\n', '      nftIdStakedToEntity[_nftId] = address(0);\n', '\n', '      uint256 index;\n', '      bool exists = false;\n', '      for (uint8 i = 0; i < entityStakedNftIds[_msgSender()].length; i++) {\n', '        if (entityStakedNftIds[_msgSender()][i] == _nftId) {\n', '          exists = true;\n', '          index = i;\n', '          break;\n', '        }\n', '      }\n', '      if (exists) {\n', '        _deleteIndex(entityStakedNftIds[_msgSender()], index);\n', '      }\n', '\n', '      CERC1155.safeTransferFrom(address(this), _msgSender(), _nftId, 1, bytes(""));\n', '    }\n', '\n', '    emit Unstaked(_msgSender(), _nftId, _nodeId, _blockNumber);\n', '  }\n', '\n', '  //\n', '  // Admin\n', '  // -------------------------------------------------------------------------------------------------------------------\n', '\n', '  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value, uint256 _block, uint8 _nodesLimit) public {\n', '    require(_msgSender() == serviceAdmin || _msgSender() == superAdmin, "not admin");\n', '\n', '    bool alreadyExists = false;\n', '    for (uint8 i = 0; i < nftBonusNames.length; i++) {\n', '      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\n', '        alreadyExists = true;\n', '      }\n', '    }\n', '\n', '    if (!alreadyExists) {\n', '      nftBonusNames.push(_name);\n', '    }\n', '\n', '    nftBonusLowerBound[_name] = _lowerBound;\n', '    nftBonusUpperBound[_name] = _upperBound;\n', '    nftBonusValue[_name] = _value;\n', '    nftBonusEffectiveBlock[_name] = _block != 0 ? _block : block.number;\n', '    nftBonusNodesLimit[_name] = _nodesLimit;\n', '  }\n', '\n', '  function updateContracts(address serviceContract, address nftContract) public {\n', '    require(_msgSender() == superAdmin, "not admin");\n', '    CService = ServiceInterface(serviceContract);\n', '    CERC1155 = IERC1155Preset(nftContract);\n', '  }\n', '\n', '  function updateServiceAdmin(address newServiceAdmin) public {\n', '    require(_msgSender() == superAdmin, "not admin");\n', '    serviceAdmin = newServiceAdmin;\n', '  }\n', '\n', '  function updateEntityNodeStakedAtBlock(address _entity, uint128 _nodeId, uint256 _block) public {\n', '    require(_msgSender() == serviceAdmin || _msgSender() == superAdmin, "not admin");\n', '\n', '    entityNodeStakedAtBlock[_entity][_nodeId] = _block;\n', '  }\n', '\n', '  //\n', '  // ERC1155 support\n', '  // -------------------------------------------------------------------------------------------------------------------\n', '\n', '  function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n', '    return this.onERC1155Received.selector;\n', '  }\n', '\n', '  function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual returns (bytes4) {\n', '    return this.onERC1155BatchReceived.selector;\n', '  }\n', '\n', '  function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n', '    return _supportedInterfaces[interfaceId];\n', '  }\n', '\n', '  function _registerInterface(bytes4 interfaceId) internal virtual {\n', '    require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '    _supportedInterfaces[interfaceId] = true;\n', '  }\n', '\n', '  function _deleteIndex(uint256[] storage array, uint256 index) internal {\n', '    uint256 lastIndex = array.length.sub(1);\n', '    uint256 lastEntry = array[lastIndex];\n', '    if (index == lastIndex) {\n', '      array.pop();\n', '    } else {\n', '      array[index] = lastEntry;\n', '      array.pop();\n', '    }\n', '  }\n', '}']