['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.1;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' *\n', ' * In order to transfer ownership, a recipient must be specified, at which point\n', ' * the specified recipient can call `acceptOwnership` and take ownership.\n', ' */\n', '\n', 'contract TwoStepOwnable {\n', '  address private _owner;\n', '\n', '  address private _newPotentialOwner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Initialize contract by setting transaction submitter as initial owner.\n', '   */\n', '  constructor() {\n', '    _owner = tx.origin;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "TwoStepOwnable: caller is not the owner.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if the caller is the current owner.\n', '   */\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows a new account (`newOwner`) to accept ownership.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(\n', '      newOwner != address(0),\n', '      "TwoStepOwnable: new potential owner is the zero address."\n', '    );\n', '\n', '    _newPotentialOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Cancel a transfer of ownership to a new account.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function cancelOwnershipTransfer() public onlyOwner {\n', '    delete _newPotentialOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to the caller.\n', '   * Can only be called by a new potential owner set by the current owner.\n', '   */\n', '  function acceptOwnership() public {\n', '    require(\n', '      msg.sender == _newPotentialOwner,\n', '      "TwoStepOwnable: current owner must set caller as new potential owner."\n', '    );\n', '\n', '    delete _newPotentialOwner;\n', '\n', '    emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '    _owner = msg.sender;\n', '  }\n', '}\n', '\n', 'interface IReserveRoleV1 {\n', '  // events\n', '  event AddedAccount(address account);\n', '  event RemovedAccount(address account);\n', '  event CallTradeReserve(bytes data, bool ok, bytes returnData);\n', '  event Call(address target, uint256 amount, bytes data, bool ok, bytes returnData);\n', '\n', '\n', '  // callable by accounts\n', '  function callTradeReserve(\n', '    bytes calldata data\n', '  ) external returns (bool ok, bytes memory returnData);\n', '\n', '  // only callable by owner\n', '  function addAccount(address account) external;\n', '  function removeAccount(address account) external;\n', '  function callAny(\n', '    address payable target, uint256 amount, bytes calldata data\n', '  ) external returns (bool ok, bytes memory returnData);\n', '\n', '  // view functions\n', '  function getAccounts() external view returns (address[] memory);\n', '  function getTradeReserve() external view returns (address tradeReserve);\n', '}\n', '\n', '\n', 'contract ReserveActionerStaging is TwoStepOwnable, IReserveRoleV1 {\n', '  // Track all authorized accounts.\n', '  address[] private _accounts;\n', '\n', '  // Indexes start at 1, as 0 signifies non-inclusion\n', '  mapping (address => uint256) private _accountIndices;\n', '\n', '  address private immutable _TRADE_RESERVE;\n', '\n', '  constructor(address tradeReserve, address[] memory initialAccounts) {\n', '    _TRADE_RESERVE = tradeReserve;\n', '    for (uint256 i; i < initialAccounts.length; i++) {\n', '      address account = initialAccounts[i];\n', '      _addAccount(account);\n', '    }\n', '  }\n', '\n', '  function addAccount(address account) external override onlyOwner {\n', '    _addAccount(account);\n', '  }\n', '\n', '  function removeAccount(address account) external override onlyOwner {\n', '    _removeAccount(account);\n', '  }\n', '\n', '  function callTradeReserve(\n', '    bytes calldata data\n', '  ) external override returns (bool ok, bytes memory returnData) {\n', '    require(\n', '    _accountIndices[msg.sender] != 0,\n', '      "Only authorized accounts may trigger calls."\n', '    );\n', '\n', '    // Call the Trade Serve and supply the specified amount and data.\n', '    (ok, returnData) = _TRADE_RESERVE.call(data);\n', '\n', '    if (!ok) {\n', '      assembly {\n', '        revert(add(returnData, 32), returndatasize())\n', '      }\n', '    }\n', '\n', '    emit CallTradeReserve(data, ok, returnData);\n', '  }\n', '\n', '  function callAny(\n', '    address payable target, uint256 amount, bytes calldata data\n', '  ) external override onlyOwner returns (bool ok, bytes memory returnData) {\n', '    // Call the specified target and supply the specified amount and data.\n', '    (ok, returnData) = target.call{value: amount}(data);\n', '\n', '    emit Call(target, amount, data, ok, returnData);\n', '  }\n', '\n', '  function getAccounts() external view override returns (address[] memory) {\n', '    return _accounts;\n', '  }\n', '\n', '  function getTradeReserve() external view override returns (address tradeReserve) {\n', '    return _TRADE_RESERVE;\n', '  }\n', '\n', '  function _addAccount(address account) internal {\n', '    require(\n', '    _accountIndices[account] == 0,\n', '      "Account matching the provided account already exists."\n', '    );\n', '    _accounts.push(account);\n', '    _accountIndices[account] = _accounts.length;\n', '\n', '    emit AddedAccount(account);\n', '  }\n', '\n', '  function _removeAccount(address account) internal {\n', '    uint256 removedAccountIndex = _accountIndices[account];\n', '    require(\n', '      removedAccountIndex != 0,\n', '      "No account found matching the provided account."\n', '    );\n', '\n', '    // swap account to remove with the last one then pop from the array.\n', '    address lastAccount = _accounts[_accounts.length - 1];\n', '    _accounts[removedAccountIndex - 1] = lastAccount;\n', '    _accountIndices[lastAccount] = removedAccountIndex;\n', '    _accounts.pop();\n', '    delete _accountIndices[account];\n', '\n', '    emit RemovedAccount(account);\n', '  }\n', '}']