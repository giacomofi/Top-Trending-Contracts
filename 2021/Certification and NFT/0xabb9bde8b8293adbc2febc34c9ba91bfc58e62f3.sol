['pragma solidity ^0.6.2;\n', '\n', 'import "./IERC1155-0.6.sol";\n', 'import "./ERC1155Holder.sol";\n', 'import "./Ownable.sol";\n', '\n', '/**\n', ' * @title BlueKirbyRedeemer\n', ' */\n', 'contract BlueKirbyRedeemer is Ownable, ERC1155Holder {\n', '    IERC1155 private _collectible;\n', '    address _owner;\n', '    uint256 public nextRedeemableTokenIndex = 0;\n', '    uint256 public nextAdditionalTokenIndex = 0;\n', '    mapping(uint256 => uint256) public tokenIDs; \n', '    mapping(address => bool) public vouchers;\n', '\n', '    event RedeemedBlueKirby(uint256 tokenID, address redeemer);\n', '\n', '    constructor (address collectible) public {\n', '        _collectible = IERC1155(collectible);\n', '    }\n', '\n', '    function _setCollectibleAddr(address _address) public onlyOwner {\n', '        _collectible = IERC1155(_address);\n', '    }\n', '\n', '    function makeAddressesRedeemable(address[] calldata validAddrs) external onlyOwner {\n', '        for (uint256 i = 0; i < validAddrs.length; i++) {\n', '            vouchers[validAddrs[i]] = true;\n', '        }\n', '    }\n', '\n', '    function revokeAddressVoucher(address _address) public onlyOwner {\n', '        delete vouchers[_address];\n', '    }\n', '    \n', '    function redeemAtIndex(uint256 index, address redeemer) public onlyOwner {\n', '        uint256 tokenID = tokenIDs[index];\n', '        require(tokenID > 0, "BlueKirbyRedeemer: No token at supplied index!");\n', '        _collectible.safeTransferFrom(address(this), redeemer, tokenID, 1, "");\n', '        emit RedeemedBlueKirby(tokenID, redeemer);\n', '    }\n', '\n', '    function redeem(address redeemer) public {\n', '        require(vouchers[redeemer], "BlueKirbyRedeemer: Address does not have a voucher.");\n', '        // require tokens are left to redeem\n', '        require(nextRedeemableTokenIndex < nextAdditionalTokenIndex, "BlueKirbyRedeemer: No more tokens left to redeem!");\n', '        uint256 tokenID = tokenIDs[nextRedeemableTokenIndex];\n', '        nextRedeemableTokenIndex++;\n', '        _collectible.safeTransferFrom(address(this), redeemer, tokenID, 1, "");\n', '        emit RedeemedBlueKirby(tokenID, redeemer);\n', '        delete vouchers[redeemer];\n', '    }\n', '\n', '    function setOwnedTokenIDs(uint256[] calldata _tokenIDs) external onlyOwner {\n', '        for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '            require(_collectible.balanceOf(address(this), _tokenIDs[i]) == 1, "BlueKirbyRedeemer: Not an owner of token");\n', '            tokenIDs[nextAdditionalTokenIndex] = _tokenIDs[i];\n', '            nextAdditionalTokenIndex++;\n', '        }\n', '    }\n', '\n', '    function resetTokenIDs(uint256 _fromIdx, uint256 _toIdx) public onlyOwner {\n', '        for (uint256 i = _fromIdx; i < _toIdx; i++) {\n', '            delete tokenIDs[i];\n', '        }\n', '    }\n', '\n', '    function resetPointers(uint256 _nextRedeemableTokenIndex, uint256 _nextAdditionalTokenIndex) public onlyOwner {\n', '        nextRedeemableTokenIndex = _nextRedeemableTokenIndex;\n', '        nextAdditionalTokenIndex = _nextAdditionalTokenIndex;\n', '    }\n', '}']