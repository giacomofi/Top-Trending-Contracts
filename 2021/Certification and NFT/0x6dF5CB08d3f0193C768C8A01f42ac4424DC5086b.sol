['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-26\n', '*/\n', '\n', '// File: contracts/common/misc/ERCProxy.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\n', '\n', 'interface ERCProxy {\n', '    function proxyType() external pure returns (uint256 proxyTypeId);\n', '    function implementation() external view returns (address codeAddr);\n', '}\n', '\n', '// File: contracts/common/misc/DelegateProxyForwarder.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract DelegateProxyForwarder {\n', '    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let result := delegatecall(\n', '                sub(gas, 10000),\n', '                _dst,\n', '                add(_calldata, 0x20),\n', '                mload(_calldata),\n', '                0,\n', '                0\n', '            )\n', '            let size := returndatasize\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, size)\n', '                }\n', '                default {\n', '                    return(ptr, size)\n', '                }\n', '        }\n', '    }\n', '    \n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(_target)\n', '        }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/common/misc/DelegateProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract DelegateProxy is ERCProxy, DelegateProxyForwarder {\n', '    function proxyType() external pure returns (uint256 proxyTypeId) {\n', '        // Upgradeable proxy\n', '        proxyTypeId = 2;\n', '    }\n', '\n', '    function implementation() external view returns (address);\n', '}\n', '\n', '// File: contracts/common/misc/UpgradableProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract UpgradableProxy is DelegateProxy {\n', '    event ProxyUpdated(address indexed _new, address indexed _old);\n', '    event OwnerUpdate(address _new, address _old);\n', '\n', '    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");\n', '    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");\n', '\n', '    constructor(address _proxyTo) public {\n', '        setOwner(msg.sender);\n', '        setImplementation(_proxyTo);\n', '    }\n', '\n', '    function() external payable {\n', '        // require(currentContract != 0, "If app code has not been set yet, do not call");\n', '        // Todo: filter out some calls or handle in the end fallback\n', '        delegatedFwd(loadImplementation(), msg.data);\n', '    }\n', '\n', '    modifier onlyProxyOwner() {\n', '        require(loadOwner() == msg.sender, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function owner() external view returns(address) {\n', '        return loadOwner();\n', '    }\n', '\n', '    function loadOwner() internal view returns(address) {\n', '        address _owner;\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            _owner := sload(position)\n', '        }\n', '        return _owner;\n', '    }\n', '\n', '    function implementation() external view returns (address) {\n', '        return loadImplementation();\n', '    }\n', '\n', '    function loadImplementation() internal view returns(address) {\n', '        address _impl;\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            _impl := sload(position)\n', '        }\n', '        return _impl;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyProxyOwner {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnerUpdate(newOwner, loadOwner());\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    function setOwner(address newOwner) private {\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            sstore(position, newOwner)\n', '        }\n', '    }\n', '\n', '    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\n', '        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");\n', '        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");\n', '\n', '        emit ProxyUpdated(_newProxyTo, loadImplementation());\n', '        \n', '        setImplementation(_newProxyTo);\n', '    }\n', '\n', '    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\n', '        updateImplementation(_newProxyTo);\n', '\n', '        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\n', '        require(success, string(returnData));\n', '    }\n', '\n', '    function setImplementation(address _newProxyTo) private {\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(position, _newProxyTo)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/staking/EventsHubProxy.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'contract EventsHubProxy is UpgradableProxy {\n', '    constructor(address _proxyTo) public UpgradableProxy(_proxyTo) {}\n', '}']