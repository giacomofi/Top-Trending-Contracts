['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-18\n', '*/\n', '\n', '// File: contracts\\fixed-inflation\\FixedInflationData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct FixedInflationEntry {\n', '    string name;\n', '    uint256 blockInterval;\n', '    uint256 lastBlock;\n', '    uint256 callerRewardPercentage;\n', '}\n', '\n', 'struct FixedInflationOperation {\n', '\n', '    address inputTokenAddress;\n', '    uint256 inputTokenAmount;\n', '    bool inputTokenAmountIsPercentage;\n', '    bool inputTokenAmountIsByMint;\n', '\n', '    address ammPlugin;\n', '    address[] liquidityPoolAddresses;\n', '    address[] swapPath;\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '\n', '    address[] receivers;\n', '    uint256[] receiversPercentages;\n', '}\n', '\n', '// File: contracts\\fixed-inflation\\IFixedInflationExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IFixedInflationExtension {\n', '\n', '    function init(address host) external;\n', '\n', '    function setHost(address host) external;\n', '\n', '    function data() external view returns(address fixedInflationContract, address host);\n', '\n', '    function receiveTokens(address[] memory tokenAddresses, uint256[] memory transferAmounts, uint256[] memory amountsToMint) external;\n', '\n', '    function flushBack(address[] memory tokenAddresses) external;\n', '\n', '    function deactivationByFailure() external;\n', '\n', '    function setEntry(FixedInflationEntry memory entryData, FixedInflationOperation[] memory operations) external;\n', '\n', '    function active() external view returns(bool);\n', '\n', '    function setActive(bool _active) external;\n', '}\n', '\n', '// File: contracts\\fixed-inflation\\util\\IERC20.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\fixed-inflation\\util\\IERC20Mintable.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20Mintable {\n', '    function mint(address wallet, uint256 amount) external returns (bool);\n', '    function burn(address wallet, uint256 amount) external returns (bool);\n', '}\n', '\n', '// File: contracts\\fixed-inflation\\IFixedInflation.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IFixedInflation {\n', '\n', '    function setEntry(FixedInflationEntry memory entryData, FixedInflationOperation[] memory operations) external;\n', '\n', '    function flushBack(address[] memory tokenAddresses) external;\n', '}\n', '\n', '// File: contracts\\fixed-inflation\\FixedInflationExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FixedInflationExtension is IFixedInflationExtension {\n', '\n', '    address private _host;\n', '\n', '    address private _fixedInflationContract;\n', '\n', '    bool public override active;\n', '\n', '    modifier fixedInflationOnly() {\n', '        require(_fixedInflationContract == msg.sender, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    modifier hostOnly() {\n', '        require(_host == msg.sender, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {\n', '    }\n', '\n', '    function init(address host) override public {\n', '        require(_host == address(0), "Already init");\n', '        require((_host = host) != address(0), "blank host");\n', '        _fixedInflationContract = msg.sender;\n', '    }\n', '\n', '    function setHost(address host) public virtual override hostOnly {\n', '        _host = host;\n', '    }\n', '\n', '    function data() view public override returns(address fixedInflationContract, address host) {\n', '        return(_fixedInflationContract, _host);\n', '    }\n', '\n', '    function setActive(bool _active) public override virtual hostOnly {\n', '        active = _active;\n', '    }\n', '\n', '    function receiveTokens(address[] memory tokenAddresses, uint256[] memory transferAmounts, uint256[] memory amountsToMint) public override fixedInflationOnly {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            if(transferAmounts[i] > 0) {\n', '                if(tokenAddresses[i] == address(0)) {\n', '                    payable(msg.sender).transfer(transferAmounts[i]);\n', '                    continue;\n', '                }\n', '                _safeTransfer(tokenAddresses[i], msg.sender, transferAmounts[i]);\n', '            }\n', '            if(amountsToMint[i] > 0) {\n', '                _mintAndTransfer(tokenAddresses[i], msg.sender, amountsToMint[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setEntry(FixedInflationEntry memory newEntry, FixedInflationOperation[] memory newOperations) public override hostOnly {\n', '        IFixedInflation(_fixedInflationContract).setEntry(newEntry, newOperations);\n', '    }\n', '\n', '    function flushBack(address[] memory tokenAddresses) public override hostOnly {\n', '        IFixedInflation(_fixedInflationContract).flushBack(tokenAddresses);\n', '    }\n', '\n', '    function deactivationByFailure() public override fixedInflationOnly {\n', '        active = false;\n', '    }\n', '\n', '    /** INTERNAL METHODS */\n', '\n', '    function _mintAndTransfer(address erc20TokenAddress, address recipient, uint256 value) internal virtual {\n', '        IERC20Mintable(erc20TokenAddress).mint(recipient, value);\n', '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}']