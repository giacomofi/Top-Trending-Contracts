['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-06\n', '*/\n', '\n', '// File: node_modules\\@openzeppelin\\contracts\\GSN\\Context.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\access\\Ownable.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\interfaces\\WarpVaultSCI.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title WarpVaultSCI\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'The WarpVaultSCI contract an abstract contract the WarpControl contract uses to interface\n', '    with a WarpVaultSC contract.\n', '**/\n', '\n', 'abstract contract WarpVaultSCI {\n', '    uint256 public totalReserves;\n', '\n', '    function borrowBalanceCurrent(address account)\n', '        public\n', '        virtual\n', '        returns (uint256);\n', '\n', '    function borrowBalancePrior(address account)\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    function exchangeRateCurrent() public virtual returns (uint256);\n', '\n', '    function _borrow(uint256 _borrowAmount, address _borrower) external virtual;\n', '\n', '    function _repayLiquidatedLoan(\n', '        address _borrower,\n', '        address _liquidator,\n', '        uint256 _amount\n', '    ) public virtual;\n', '\n', '    function setNewInterestModel(address _newModel) public virtual;\n', '\n', '    function getSCDecimals() public virtual view returns (uint8);\n', '\n', '    function getSCAddress() public virtual view returns (address);\n', '\n', '    function updateWarpControl(address _warpControl) public virtual;\n', '\n', '    function updateTeam(address _warpTeam) public virtual;\n', '\n', '    function viewAccountBalance(address _account)\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// File: contracts\\interfaces\\WarpVaultLPI.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title WarpVaultLPI\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'The WarpVaultLPI contract an abstract contract the WarpControl contract uses to interface\n', '    with a WarpVaultLP contract.\n', '**/\n', '\n', 'abstract contract WarpVaultLPI {\n', '    function getAssetAdd() public virtual view returns (address);\n', '\n', '    function collateralOfAccount(address _account)\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    function _liquidateAccount(address _account, address _liquidator)\n', '        public\n', '        virtual;\n', '\n', '    function updateWarpControl(address _warpControl) public virtual;\n', '}\n', '\n', '// File: contracts\\interfaces\\WarpVaultLPFactoryI.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title WarpVaultLPFactoryI\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'The WarpVaultLPFactory contract is designed to produce individual WarpVaultLP contracts\n', '**/\n', '\n', 'abstract contract WarpVaultLPFactoryI {\n', '    function createWarpVaultLP(\n', '        uint256 _timelock,\n', '        address _lp\n', '    ) public virtual returns (address);\n', '}\n', '\n', '// File: contracts\\interfaces\\WarpVaultSCFactoryI.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title WarpVaultSCFactoryI\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'The WarpVaultSCFactoryI contract is used by the Warp Control contract to interface with the WarpVaultSCFactory contract\n', '**/\n', '\n', 'abstract contract WarpVaultSCFactoryI {\n', '    function createNewWarpVaultSC(\n', '        address _InterestRate,\n', '        address _StableCoin,\n', '        address _warpTeam,\n', '        uint256 _initialExchangeRate,\n', '        uint256 _timelock,\n', '        uint256 _reserveFactorMantissa\n', '    ) public virtual returns (address);\n', '}\n', '\n', '// File: contracts\\interfaces\\SwapLPOracleI.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title SwapLPOracleI\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'The SwapLPOracleI contract an abstract contract the Warp platform uses to interface\n', '    With the SwapOracle to retrieve token prices.\n', '**/\n', '\n', 'abstract contract SwapLPOracleI {\n', '    function addChainlinkETHOracle(\n', '                                   address oracle, address token\n', '    ) public virtual;\n', '\n', '    function OneUSDC() public virtual view returns (uint256);\n', '    function OneWETH() public virtual view returns (uint256);\n', '\n', '    function getUnderlyingPrice(address _MMI) public virtual returns (uint256);\n', '\n', '    function getPriceOfToken(address _token, uint256 _amount)\n', '        public\n', '        virtual\n', '        returns (uint256);\n', '\n', '    function transferOwnership(address _newOwner) public virtual;\n', '\n', '    function _calculatePriceOfLP(\n', '        uint256 supply,\n', '        uint256 value0,\n', '        uint256 value1,\n', '        uint256 reserve0,\n', '        uint256 reserve1\n', '    ) public virtual pure returns (uint256);\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\math\\SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\compound\\BaseJumpRateModelV2.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', " * @title Logic for Compound's JumpRateModel Contract V2.\n", ' * @author Compound (modified by Dharma Labs, refactored by Arr00)\n', ' * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n', ' */\n', 'contract BaseJumpRateModelV2 {\n', '    using SafeMath for uint256;\n', '\n', '    event NewInterestParams(\n', '        uint256 baseRatePerBlock,\n', '        uint256 multiplierPerBlock,\n', '        uint256 jumpMultiplierPerBlock,\n', '        uint256 kink\n', '    );\n', '\n', '    /**\n', '     * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n', '     */\n', '    address public owner;\n', '\n', '    /**\n', '     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n', '     */\n', '    uint256 public constant blocksPerYear = 2102400;\n', '\n', '    /**\n', '     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n', '     */\n', '    uint256 public multiplierPerBlock;\n', '\n', '    /**\n', '     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n', '     */\n', '    uint256 public baseRatePerBlock;\n', '\n', '    /**\n', '     * @notice The multiplierPerBlock after hitting a specified utilization point\n', '     */\n', '    uint256 public jumpMultiplierPerBlock;\n', '\n', '    /**\n', '     * @notice The utilization point at which the jump multiplier is applied\n', '     */\n', '    uint256 public kink;\n', '\n', '    /**\n', '     * @notice Construct an interest rate model\n', '     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n', '     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n', '     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n', '     * @param kink_ The utilization point at which the jump multiplier is applied\n', '     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n', '     */\n', '    constructor(\n', '        uint256 baseRatePerYear,\n', '        uint256 multiplierPerYear,\n', '        uint256 jumpMultiplierPerYear,\n', '        uint256 kink_,\n', '        address owner_\n', '    ) internal {\n', '        owner = owner_;\n', '\n', '        updateJumpRateModelInternal(\n', '            baseRatePerYear,\n', '            multiplierPerYear,\n', '            jumpMultiplierPerYear,\n', '            kink_\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n', '     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n', '     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n', '     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n', '     * @param kink_ The utilization point at which the jump multiplier is applied\n', '     */\n', '    function updateJumpRateModel(\n', '        uint256 baseRatePerYear,\n', '        uint256 multiplierPerYear,\n', '        uint256 jumpMultiplierPerYear,\n', '        uint256 kink_\n', '    ) external {\n', '        require(msg.sender == owner, "only the owner may call this function.");\n', '\n', '        updateJumpRateModelInternal(\n', '            baseRatePerYear,\n', '            multiplierPerYear,\n', '            jumpMultiplierPerYear,\n', '            kink_\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n', '     * @param cash The amount of cash in the market\n', '     * @param borrows The amount of borrows in the market\n', '     * @param reserves The amount of reserves in the market (currently unused)\n', '     * @return The utilization rate as a mantissa between [0, 1e18]\n', '     */\n', '    function utilizationRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) public pure returns (uint256) {\n', '        // Utilization rate is 0 when there are no borrows\n', '        if (borrows == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates the current borrow rate per block, with the error code expected by the market\n', '     * @param cash The amount of cash in the market\n', '     * @param borrows The amount of borrows in the market\n', '     * @param reserves The amount of reserves in the market\n', '     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n', '     */\n', '    function getBorrowRateInternal(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves\n', '    ) internal view returns (uint256) {\n', '        uint256 util = utilizationRate(cash, borrows, reserves);\n', '\n', '        if (util <= kink) {\n', '            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n', '        } else {\n', '            uint256 normalRate =\n', '                kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n', '            uint256 excessUtil = util.sub(kink);\n', '            return\n', '                excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(\n', '                    normalRate\n', '                );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates the current supply rate per block\n', '     * @param cash The amount of cash in the market\n', '     * @param borrows The amount of borrows in the market\n', '     * @param reserves The amount of reserves in the market\n', '     * @param reserveFactorMantissa The current reserve factor for the market\n', '     * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n', '     */\n', '    function getSupplyRate(\n', '        uint256 cash,\n', '        uint256 borrows,\n', '        uint256 reserves,\n', '        uint256 reserveFactorMantissa\n', '    ) public view returns (uint256) {\n', '        uint256 oneMinusReserveFactor =\n', '            uint256(1e18).sub(reserveFactorMantissa);\n', '        uint256 borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n', '        uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n', '        return\n', '            utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function to update the parameters of the interest rate model\n', '     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n', '     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n', '     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n', '     * @param kink_ The utilization point at which the jump multiplier is applied\n', '     */\n', '    function updateJumpRateModelInternal(\n', '        uint256 baseRatePerYear,\n', '        uint256 multiplierPerYear,\n', '        uint256 jumpMultiplierPerYear,\n', '        uint256 kink_\n', '    ) internal {\n', '        baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n', '        multiplierPerBlock = (multiplierPerYear.mul(1e18)).div(\n', '            blocksPerYear.mul(kink_)\n', '        );\n', '        jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n', '        kink = kink_;\n', '\n', '        emit NewInterestParams(\n', '            baseRatePerBlock,\n', '            multiplierPerBlock,\n', '            jumpMultiplierPerBlock,\n', '            kink\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts\\compound\\JumpRateModelV2.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', "  * @title Compound's JumpRateModel Contract V2 for V2 cTokens\n", '  * @author Arr00\n', '  * @notice Supports only for V2 cTokens\n', '  */\n', 'contract JumpRateModelV2 is  BaseJumpRateModelV2  {\n', '\n', '\t/**\n', '     * @notice Calculates the current borrow rate per block\n', '     * @param cash The amount of cash in the market\n', '     * @param borrows The amount of borrows in the market\n', '     * @param reserves The amount of reserves in the market\n', '     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n', '     */\n', '    function getBorrowRate(uint cash, uint borrows, uint reserves) external  view returns (uint) {\n', '        return getBorrowRateInternal(cash, borrows, reserves);\n', '    }\n', '\n', '    constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\n', '    \tBaseJumpRateModelV2(baseRatePerYear,multiplierPerYear,jumpMultiplierPerYear,kink_,owner_) public {}\n', '}\n', '\n', '// File: contracts\\compound\\CarefulMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', '  * @title Careful Math\n', '  * @author Compound\n', '\n', '/blob/master/contracts/math/SafeMath.sol\n', '  */\n', 'contract CarefulMath {\n', '\n', '    /**\n', '     * @dev Possible error codes that we can return\n', '     */\n', '    enum MathError {\n', '        NO_ERROR,\n', '        DIVISION_BY_ZERO,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, returns an error on overflow.\n', '    */\n', '    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (a == 0) {\n', '            return (MathError.NO_ERROR, 0);\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (MathError.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (b == 0) {\n', '            return (MathError.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, a / b);\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (b <= a) {\n', '            return (MathError.NO_ERROR, a - b);\n', '        } else {\n', '            return (MathError.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, returns an error on overflow.\n', '    */\n', '    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        uint c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (MathError.NO_ERROR, c);\n', '        } else {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev add a and b and then subtract c\n', '    */\n', '    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n', '        (MathError err0, uint sum) = addUInt(a, b);\n', '\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return subUInt(sum, c);\n', '    }\n', '}\n', '\n', '// File: contracts\\compound\\Exponential.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @title Exponential module for storing fixed-precision decimals\n', ' * @author Compound\n', ' * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n', ' *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n', ' *         `Exp({mantissa: 5100000000000000000})`.\n', ' */\n', 'contract Exponential is CarefulMath {\n', '    uint constant expScale = 1e18;\n', '    uint constant doubleScale = 1e36;\n', '    uint constant halfExpScale = expScale/2;\n', '    uint constant mantissaOne = expScale;\n', '\n', '    struct Exp {\n', '        uint mantissa;\n', '    }\n', '\n', '    struct Double {\n', '        uint mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates an exponential from numerator and denominator values.\n', '     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '     *            or if `denom` is zero.\n', '     */\n', '    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two exponentials, returning a new exponential.\n', '     */\n', '    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n', '        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two exponentials, returning a new exponential.\n', '     */\n', '    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n', '        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n', '     */\n', '    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(product));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n', '     */\n', '    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return addUInt(truncate(product), addend);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, returning a new Exp.\n', '     */\n', '    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n', '        /*\n', '          We are doing this as:\n', '          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n', '\n', '          How it works:\n', '          Exp = a / b;\n', '          Scalar = s;\n', '          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n', '     */\n', '    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(fraction));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials, returning a new exponential.\n', '     */\n', '    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n', '\n', '        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n', '        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == MathError.NO_ERROR);\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n', '     */\n', '    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n', '        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies three exponentials, returning a new exponential.\n', '     */\n', '    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n', '        (MathError err, Exp memory ab) = mulExp(a, b);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, ab);\n', '        }\n', '        return mulExp(ab, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two exponentials, returning a new exponential.\n', '     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n', '     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n', '     */\n', '    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n', '        return getExp(a.mantissa, b.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Truncates the given exp to a whole number value.\n', '     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n', '     */\n', '    function truncate(Exp memory exp) pure internal returns (uint) {\n', "        // Note: We are not using careful math here as we're performing a division that cannot fail\n", '        return exp.mantissa / expScale;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if first Exp is less than second Exp.\n', '     */\n', '    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa < right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if left Exp <= right Exp.\n', '     */\n', '    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa <= right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if left Exp > right Exp.\n', '     */\n', '    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa > right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev returns true if Exp is exactly zero\n', '     */\n', '    function isZeroExp(Exp memory value) pure internal returns (bool) {\n', '        return value.mantissa == 0;\n', '    }\n', '\n', '    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n', '        require(n < 2**224, errorMessage);\n', '        return uint224(n);\n', '    }\n', '\n', '    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n', '        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function add_(uint a, uint b) pure internal returns (uint) {\n', '        return add_(a, b, "addition overflow");\n', '    }\n', '\n', '    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n', '        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n', '    }\n', '\n', '    function sub_(uint a, uint b) pure internal returns (uint) {\n', '        return sub_(a, b, "subtraction underflow");\n', '    }\n', '\n', '    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n', '    }\n', '\n', '    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: mul_(a.mantissa, b)});\n', '    }\n', '\n', '    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n', '        return mul_(a, b.mantissa) / expScale;\n', '    }\n', '\n', '    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n', '        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n', '    }\n', '\n', '    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n', '        return Double({mantissa: mul_(a.mantissa, b)});\n', '    }\n', '\n', '    function mul_(uint a, Double memory b) pure internal returns (uint) {\n', '        return mul_(a, b.mantissa) / doubleScale;\n', '    }\n', '\n', '    function mul_(uint a, uint b) pure internal returns (uint) {\n', '        return mul_(a, b, "multiplication overflow");\n', '    }\n', '\n', '    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n', '        if (a == 0 || b == 0) {\n', '            return 0;\n', '        }\n', '        uint c = a * b;\n', '        require(c / a == b, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n', '    }\n', '\n', '    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n', '        return Exp({mantissa: div_(a.mantissa, b)});\n', '    }\n', '\n', '    function div_(uint a, Exp memory b) pure internal returns (uint) {\n', '        return div_(mul_(a, expScale), b.mantissa);\n', '    }\n', '\n', '    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n', '        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n', '    }\n', '\n', '    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n', '        return Double({mantissa: div_(a.mantissa, b)});\n', '    }\n', '\n', '    function div_(uint a, Double memory b) pure internal returns (uint) {\n', '        return div_(mul_(a, doubleScale), b.mantissa);\n', '    }\n', '\n', '    function div_(uint a, uint b) pure internal returns (uint) {\n', '        return div_(a, b, "divide by zero");\n', '    }\n', '\n', '    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    function fraction(uint a, uint b) pure internal returns (Double memory) {\n', '        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n', '    }\n', '}\n', '\n', '// File: @uniswap\\v2-core\\contracts\\interfaces\\IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: contracts\\WarpControl.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '//import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/// @title WarpControl\n', '/// @author Christopher Dixon\n', '////////////////////////////////////////////////////////////////////////////////////////////\n', '/**\n', 'WarpControl is designed to coordinate Warp Vaults\n', 'This contract uses the OpenZeppelin contract Library to inherit functions from\n', '  Ownable.sol\n', '**/\n', '\n', 'contract WarpControl is Ownable, Exponential {\n', '    using SafeMath for uint256;\n', '\n', '    SwapLPOracleI public oracle; //oracle contract \n', '    WarpVaultLPFactoryI public WVLPF;\n', '    WarpVaultSCFactoryI public WVSCF;\n', '\n', '    address public warpTeam;\n', '    address public newWarpControl;\n', '    uint256 public graceSpace;\n', '\n', '    address[] public lpVaults;\n', '    address[] public scVaults;\n', '\n', '    mapping(address => address) public instanceLPTracker; //maps LP token address to the assets WarpVault\n', '    mapping(address => address) public instanceSCTracker;\n', '    mapping(address => address) public getAssetByVault;\n', '    mapping(address => bool) public isVault;\n', '\n', '    uint256 public borrowLimitPercentage = 66 ether;  // max percentage of collateral value allowed to borrow, with 18 decimals\n', '    uint256 public liquidateLimitPercentage = 75 ether; // max percentage of collateral value before liquidation can occur\n', '    uint256 public liquidationFee = 15 ether; // percentage of LP tokens to give to warp team upon liquidation\n', '\n', '    event LogEvent2(uint256 lnum);\n', '    event NewLPVault(address _newVault);\n', '    event ImportedLPVault(address _vault);\n', '    event NewSCVault(address _newVault, address _interestRateModel);\n', '    event ImportedSCVault(address _vault);\n', '    event NewBorrow(\n', '        address _borrower,\n', '        address _StableCoin,\n', '        uint256 _amountBorrowed\n', '    );\n', '    event Liquidation(address _account, address liquidator);\n', '    event NewInterestRateModelCreated(\n', '      address _token,\n', '      uint256 _baseRatePerYear,\n', '      uint256 _multiplierPerYear,\n', '      uint256 _jumpMultiplierPerYear,\n', '      uint256 _optimal\n', '    );\n', '\n', '    /**\n', '      @dev Throws if called by any account other than a warp vault\n', '     */\n', '    modifier onlyVault() {\n', '        require(isVault[msg.sender] == true, "Only a vault may call this");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    @notice the constructor function is fired during the contract deployment process. The constructor can only be fired once and\n', '            is used to set up OracleFactory variables for the MoneyMarketFactory contract.\n', '    @param _oracle is the address for the UniswapOracleFactorycontract\n', '    @param _WVLPF is the address for the WarpVaultLPFactory used to produce LP Warp Vaults\n', '    @param _WVSCF is the address for the WarpVaultSCFactory used to produce Stable Coin Warp Vaults\n', '    @dev These factories are split into seperate contracts to avoid hitting the block gas limit\n', '    **/\n', '    constructor(\n', '        address _oracle,\n', '        address _WVLPF,\n', '        address _WVSCF,\n', '        address _warpTeam\n', '    ) public {\n', '        //instantiate the contracts\n', '        oracle = SwapLPOracleI(_oracle);\n', '        WVLPF = WarpVaultLPFactoryI(_WVLPF);\n', '        WVSCF = WarpVaultSCFactoryI(_WVSCF);\n', '        warpTeam = _warpTeam;\n', '    }\n', '\n', '    /**\n', '    @notice viewNumLPVaults returns the number of lp vaults on the warp platform\n', '    **/\n', '    function viewNumLPVaults() external view returns (uint256) {\n', '        return lpVaults.length;\n', '    }\n', '\n', '    /**\n', '    @notice viewNumSCVaults returns the number of stablecoin vaults on the warp platform\n', '    **/\n', '    function viewNumSCVaults() external view returns (uint256) {\n', '        return scVaults.length;\n', '    }\n', '     /**\n', '    @notice createNewLPVault allows the contract owner to create a new WarpVaultLP contract for a specific LP token\n', '    @param _timelock is a variable representing the number of seconds the timeWizard will prevent withdraws and borrows from a contracts(one week is 605800 seconds)\n', '    @param _lp is the address for the LP token this Warp Vault will manage\n', '    **/\n', '    function createNewLPVault( \n', '        uint256 _timelock,\n', '        address _lp\n', '    ) public onlyOwner {\n', ' \n', '        require(instanceLPTracker[_lp] == address(0), "LP vault already exists");\n', '\n', '        //create new Warp LP Vault\n', '        address _WarpVault = WVLPF.createWarpVaultLP(_timelock, _lp);\n', '        //track the warp vault lp instance by the address of the LP it represents\n', '        instanceLPTracker[_lp] = _WarpVault;\n', '        //add new LP Vault to the array of all LP vaults\n', '        lpVaults.push(_WarpVault);\n', '        //set Warp vault address as an approved vault\n', '        isVault[_WarpVault] = true;\n', '        //track vault to asset\n', '        getAssetByVault[_WarpVault] = _lp;\n', '        emit NewLPVault(_WarpVault);\n', '    }\n', '\n', '    function importLPVault(address _lpVault) public onlyOwner {\n', '      require(isVault[_lpVault] == false);\n', '        WarpVaultLPI _vault = WarpVaultLPI(_lpVault);\n', '        address _lp = _vault.getAssetAdd();\n', '\n', '        instanceLPTracker[_lp] = _lpVault;\n', '        lpVaults.push(_lpVault);\n', '        isVault[_lpVault] = true;\n', '        getAssetByVault[_lpVault] = _lp;\n', '        emit ImportedLPVault(_lpVault);\n', '    }\n', '\n', '\n', '    /**\n', '    @notice createNewSCVault allows the contract owner to create a new WarpVaultLP contract for a specific LP token\n', '    @param _timelock is a variable representing the number of seconds the timeWizard will prevent withdraws and borrows from a contracts(one week is 605800 seconds)\n', '    @param _baseRatePerYear is the base rate per year(approx target base APR)\n', '    @param _multiplierPerYear is the multiplier per year(rate of increase in interest w/ utilizastion)\n', '    @param _jumpMultiplierPerYear is the Jump Multiplier Per Year(the multiplier per block after hitting a specific utilizastion point)\n', '    @param _optimal is the this is the utilizastion point or "kink" at which the jump multiplier is applied\n', '    @param _initialExchangeRate is the intitial exchange rate(the rate at which the initial exchange of asset/ART is set)\n', '    @param _StableCoin is the address of the StableCoin this Warp Vault will manage\n', '    **/\n', '    function createNewSCVault(\n', '        uint256 _timelock,\n', '        uint256 _baseRatePerYear,\n', '        uint256 _multiplierPerYear,\n', '        uint256 _jumpMultiplierPerYear,\n', '        uint256 _optimal,\n', '        uint256 _initialExchangeRate,\n', '        uint256 _reserveFactorMantissa,\n', '        address _StableCoin\n', '    ) public onlyOwner {\n', '        //create the interest rate model for this stablecoin\n', '        address IR = address(\n', '            new JumpRateModelV2(\n', '                _baseRatePerYear,\n', '                _multiplierPerYear,\n', '                _jumpMultiplierPerYear,\n', '                _optimal,\n', '                address(this)\n', '            )\n', '        );\n', '        //create the SC Warp vault\n', '        address _WarpVault = WVSCF.createNewWarpVaultSC(\n', '            IR,\n', '            _StableCoin,\n', '            warpTeam,\n', '            _initialExchangeRate,\n', '            _timelock,\n', '            _reserveFactorMantissa\n', '        );\n', '        //track the warp vault sc instance by the address of the stablecoin it represents\n', '        instanceSCTracker[_StableCoin] = _WarpVault;\n', '        //add new SC Vault to the array of all SC vaults\n', '        scVaults.push(_WarpVault);\n', '        //set Warp vault address as an approved vault\n', '        isVault[_WarpVault] = true;\n', '        //track vault to asset\n', '        getAssetByVault[_WarpVault] = _StableCoin;\n', '        emit NewSCVault(_WarpVault, IR);\n', '    }\n', '\n', '    function importSCVault(address _scVault) public onlyOwner {\n', '      require(isVault[_scVault] == false);\n', '\n', '        WarpVaultSCI _vault = WarpVaultSCI(_scVault);\n', '        address _token = _vault.getSCAddress();\n', '\n', '        // track token -> vault\n', '        instanceSCTracker[_token] = _scVault;\n', '        // vault list\n', '        scVaults.push(_scVault);\n', '        // register vault in mapping\n', '        isVault[_scVault] = true;\n', '        // track vault -> token\n', '        getAssetByVault[_scVault] = _token;\n', '        emit ImportedSCVault(_scVault);\n', '    }\n', '\n', '    function setBorrowThreshold(uint256 _borrowLimitPercentage) public onlyOwner {\n', '        borrowLimitPercentage = _borrowLimitPercentage;\n', '    }\n', '\n', '    function setLiquidateThreshold(uint256 _liquidateimitPercentage) public onlyOwner{\n', '        liquidateLimitPercentage = _liquidateimitPercentage;\n', '    }\n', '\n', '    function setLiquidationFee(uint256 _liquidationFee) public onlyOwner {\n', '        liquidationFee = _liquidationFee;\n', '    }\n', '\n', '    /**\n', '    @notice Figures out how much of a given LP token an account is allowed to withdraw\n', '    @param account is the account being checked\n', '    @param lpToken is the address of the lpToken the user wishes to withdraw\n', '    @dev this function runs calculations to accrue interest for an up to date amount\n', '     */\n', '    function getMaxWithdrawAllowed(address account, address lpToken)\n', '        public\n', '        returns (uint256)\n', '    {\n', '        uint256 borrowedTotal = getTotalBorrowedValue(account);\n', '        uint256 collateralValue = getTotalAvailableCollateralValue(account);\n', '        uint256 requiredCollateral = calcCollateralRequired(borrowedTotal);\n', '        if (collateralValue < requiredCollateral) {\n', '            return 0;\n', '        }\n', '        uint256 leftoverCollateral = collateralValue.sub(requiredCollateral);\n', '        uint256 lpValue = oracle.getUnderlyingPrice(lpToken);\n', '        return leftoverCollateral.mul(1e18).div(lpValue);\n', '    }\n', '\n', '\n', '    /**\n', '    @notice getTotalAvailableCollateralValue returns the total availible collaeral value for an account in USDC\n', '    @param _account is the address whos collateral is being retreived\n', '    @dev this function runs calculations to accrue interest for an up to date amount\n', '    **/\n', '    function getTotalAvailableCollateralValue(address _account)\n', '        public\n', '        returns (uint256)\n', '    {\n', '        //get the number of LP vaults the platform has\n', '        uint256 numVaults = lpVaults.length;\n', '        //initialize the totalCollateral variable to zero\n', '        uint256 totalCollateral = 0;\n', '        //loop through each lp wapr vault\n', '        for (uint256 i = 0; i < numVaults; ++i) {\n', '            //instantiate warp vault at that position\n', '            WarpVaultLPI vault = WarpVaultLPI(lpVaults[i]);\n', '            //retreive the address of its asset\n', '            address asset = vault.getAssetAdd();\n', '            //retrieve USD price of this asset\n', '            uint256 assetPrice = oracle.getUnderlyingPrice(asset);\n', '\n', '            uint256 accountCollateral = vault.collateralOfAccount(_account);\n', '            //emit DebugValues(accountCollateral, assetPrice);\n', '\n', '            //multiply the amount of collateral by the asset price and return it\n', '            uint256 accountAssetsValue = accountCollateral.mul(assetPrice);\n', '            //add value to total collateral\n', '            totalCollateral = totalCollateral.add(accountAssetsValue);\n', '        }\n', '        //return total USDC value of all collateral\n', '        return totalCollateral.div(1e18);\n', '    }\n', '\n', '    /**\n', '    @notice getPriceOfCollateral returns the price of an lpToken\n', '    @param lpToken is the address of the lp token\n', '    @dev this function does not run calculations amd returns the previously calculated price\n', '    **/\n', '    function getPriceOfCollateral(address lpToken) public returns (uint256) {\n', '        return oracle.getUnderlyingPrice(lpToken);\n', '    }\n', '\n', '    /**\n', '    @notice viewPriceOfToken retrieves the price of a stablecoin\n', '    @param token is the address of the stablecoin\n', '    @param amount is the amount of stablecoin\n', '    @dev this function does not run calculations amd returns the previously calculated price\n', '    **/\n', '    function getPriceOfToken(address token, uint256 amount)\n', '        public\n', '        returns (uint256)\n', '    {\n', '        return oracle.getPriceOfToken(token, amount);\n', '    }\n', '\n', '    /**\n', '    @notice getTotalLentValue returns the total lent value for an account in USDC\n', '    @param _account is the account whos lent value we are calculating\n', '    **/\n', '    function getTotalLentValue(address _account)\n', '        public\n', '        //view\n', '        returns (uint256)\n', '    {\n', '        uint256 numSCVaults = scVaults.length;\n', '        uint256 totalValue = 0;\n', '\n', '        // Add up each stable coin vaults value\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            //instantiate each LP warp vault\n', '            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\n', '            //retreive the amount user has borrowed from each stablecoin vault\n', '            uint256 lentBalanceInStable = WVSC.viewAccountBalance(_account);\n', '            if (lentBalanceInStable == 0) {\n', '                continue;\n', '            }\n', '            uint256 usdcLentAmount = getPriceOfToken(\n', '                WVSC.getSCAddress(),\n', '                lentBalanceInStable\n', '            );\n', '            totalValue = totalValue.add(usdcLentAmount);\n', '        }\n', '\n', '        return totalValue;\n', '    }\n', '\n', '    /**\n', '    @notice viewTotalBorrowedValue returns the total borrowed value for an account in USDC\n', '    @param _account is the account whos borrowed value we are calculating\n', '    @dev this function returns newly calculated values\n', '    **/\n', '    function getTotalBorrowedValue(address _account) public returns (uint256) {\n', '        uint256 numSCVaults = scVaults.length;\n', '        //initialize the totalBorrowedValue variable to zero\n', '        uint256 totalBorrowedValue = 0;\n', '        //loop through all stable coin vaults\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            //instantiate each LP warp vault\n', '            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\n', '            //retreive the amount user has borrowed from each stablecoin vault\n', '            uint256 borrowBalanceInStable = WVSC.borrowBalanceCurrent(_account);\n', '            if (borrowBalanceInStable == 0) {\n', '                continue;\n', '            }\n', '            uint256 usdcBorrowedAmount = getPriceOfToken(\n', '                WVSC.getSCAddress(),\n', '                borrowBalanceInStable\n', '            );\n', '            totalBorrowedValue = totalBorrowedValue.add(usdcBorrowedAmount);\n', '        }\n', '        //return total Borrowed Value\n', '        return totalBorrowedValue;\n', '    }\n', '\n', '    function calcBorrowLimit(uint256 _collateralValue)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _collateralValue.mul(borrowLimitPercentage).div(100 ether);\n', '    }\n', '\n', '    function calcLiquidationLimit(uint256 _collateralValue)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _collateralValue.mul(liquidateLimitPercentage).div(100 ether);\n', '    }\n', '\n', '    /**\n', '    @notice calcCollateralRequired returns the amount of collateral needed for an input borrow value\n', '    liquidatteLimitPercentage\n', '    @param _borrowAmount is the input borrow amount\n', '    **/\n', '    function calcCollateralRequired(uint256 _borrowAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _borrowAmount.mul(100 ether).div(borrowLimitPercentage);\n', '    }\n', '\n', '    /**\n', '    @notice getBorrowLimit returns the borrow limit for an account\n', '    @param _account is the input account address\n', '    @dev this calculation uses current values for calculations\n', '    **/\n', '    function getBorrowLimit(address _account) public returns (uint256) {\n', '        uint256 availibleCollateralValue = getTotalAvailableCollateralValue(\n', '            _account\n', '        );\n', '\n', '        return calcBorrowLimit(availibleCollateralValue);\n', '    }\n', '\n', '    function getLiquidationLimit(address _account) public returns (uint256) {\n', '        uint256 availibleCollateralValue = getTotalAvailableCollateralValue(\n', '            _account\n', '        );\n', '\n', '        return calcLiquidationLimit(availibleCollateralValue);\n', '    }\n', '\n', '    /**\n', '    @notice borrowSC is the function an end user will call when they wish to borrow a stablecoin from the warp platform\n', '    @param _StableCoin is the address of the stablecoin the user wishes to borrow\n', '    @param _amount is the amount of that stablecoin the user wants to borrow\n', '    **/\n', '    function borrowSC(address _StableCoin, uint256 _amount) public {\n', '        uint256 borrowedTotalInUSDC = getTotalBorrowedValue(msg.sender);\n', '        uint256 borrowLimitInUSDC = getBorrowLimit(msg.sender);\n', '        uint256 borrowAmountAllowedInUSDC = borrowLimitInUSDC.sub(\n', '            borrowedTotalInUSDC\n', '        );\n', '\n', '        uint256 borrowAmountInUSDC = getPriceOfToken(_StableCoin, _amount);\n', '\n', '        //require the amount being borrowed is less than or equal to the amount they are aloud to borrow\n', '        require(\n', '            borrowAmountAllowedInUSDC >= borrowAmountInUSDC,\n', '            "Borrowing more than allowed"\n', '        );\n', '\n', '        //retreive stablecoin vault address being borrowed from and instantiate it\n', '        WarpVaultSCI WV = WarpVaultSCI(instanceSCTracker[_StableCoin]);\n', '        //call _borrow function on the stablecoin warp vault\n', '        WV._borrow(_amount, msg.sender);\n', '        emit NewBorrow(msg.sender, _StableCoin, _amount);\n', '    }\n', '\n', '    /**\n', '    @notice liquidateAccount is used to liquidate a non-compliant loan after it has reached its 30 minute grace period\n', '    @param _borrower is the address of the borrower whos loan is non-compliant\n', '    **/\n', '    function liquidateAccount(address _borrower) public {\n', '        //require the liquidator is not also the borrower\n', '        require(msg.sender != _borrower, "you cant liquidate yourself");\n', '        //retreive the number of stablecoin vaults in the warp platform\n', '        uint256 numSCVaults = scVaults.length;\n', '        //retreive the number of LP vaults in the warp platform\n', '        uint256 numLPVaults = lpVaults.length;\n', '        // This is how much USDC worth of Stablecoin the user has borrowed\n', '        uint256 borrowedAmount = 0;\n', '        //initialize the stable coin balances array\n', '        uint256[] memory scBalances = new uint256[](numSCVaults);\n', '        // loop through and retreive the Borrowed Amount From All Vaults\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            //instantiate the vault at the current  position in the array\n', '            WarpVaultSCI scVault = WarpVaultSCI(scVaults[i]);\n', '            //retreive the borrowers borrow balance from this vault and add it to the scBalances array\n', '            scBalances[i] = scVault.borrowBalanceCurrent(_borrower);\n', '            uint256 borrowedAmountInUSDC = getPriceOfToken(\n', '                getAssetByVault[address(scVault)],\n', '                scBalances[i]\n', '            );\n', '\n', '            //add the borrowed amount to the total borrowed balance\n', '            borrowedAmount = borrowedAmount.add(borrowedAmountInUSDC);\n', '        }\n', '        //retreve the USDC borrow limit for the borrower\n', '        uint256 liquidationLimit = getLiquidationLimit(_borrower);\n', '        \n', '        //check if the borrow is less than the borrowed amount\n', '        require(borrowedAmount > liquidationLimit, "Loan is still valid");\n', '\n', '        // If it is Liquidate the account\n', '        //loop through each SC vault so the  Liquidator can pay off Stable Coin loans\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            //instantiate the Warp SC Vault at the current position\n', '            WarpVaultSCI scVault = WarpVaultSCI(scVaults[i]);\n', '            //call repayLiquidatedLoan function to repay the loan\n', '            scVault._repayLiquidatedLoan(\n', '                _borrower,\n', '                msg.sender,\n', '                scBalances[i]\n', '            );\n', '        }\n', '        //loop through each LP vault so the Liquidator gets the LP tokens the borrower had\n', '        for (uint256 i = 0; i < numLPVaults; ++i) {\n', '            //instantiate the Warp LP Vault at the current position\n', '            WarpVaultLPI lpVault = WarpVaultLPI(lpVaults[i]);\n', '            \n', '            //call liquidateAccount function on that LP vault and transfer LP tokens to warp control\n', '            lpVault._liquidateAccount(_borrower, address(this));\n', '\n', '            IUniswapV2Pair lpToken = IUniswapV2Pair(lpVault.getAssetAdd());\n', '\n', '            // transfer 15% of those tokens to the warp team\n', '            lpToken.transfer(warpTeam, lpToken.balanceOf(address(this)) * liquidationFee / 100 ether);\n', '\n', '            // transfer the remaining to liquidator\n', '            lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\n', '        }\n', '        emit Liquidation(_borrower, msg.sender);\n', '    }\n', '\n', '    /**\n', '    @notice updateInterestRateModel allows the warp team to update the interest rate model for a stablecoin\n', '    @param _token is the address of the stablecoin whos vault is having its interest rate updated\n', '    @param _baseRatePerYear is the base rate per year(approx target base APR)\n', '    @param _multiplierPerYear is the multiplier per year(rate of increase in interest w/ utilizastion)\n', '    @param _jumpMultiplierPerYear is the Jump Multiplier Per Year(the multiplier per block after hitting a specific utilizastion point)\n', '    @param _optimal is the this is the utilizastion point or "kink" at which the jump multiplier is applied\n', '    **/\n', '    function updateInterestRateModel(\n', '        address _token,\n', '        uint256 _baseRatePerYear,\n', '        uint256 _multiplierPerYear,\n', '        uint256 _jumpMultiplierPerYear,\n', '        uint256 _optimal\n', '    ) public onlyOwner {\n', '        address IR = address(\n', '            new JumpRateModelV2(\n', '                _baseRatePerYear,\n', '                _multiplierPerYear,\n', '                _jumpMultiplierPerYear,\n', '                _optimal,\n', '                address(this)\n', '            )\n', '        );\n', '        address vault = instanceSCTracker[_token];\n', '        WarpVaultSCI WV = WarpVaultSCI(vault);\n', '        WV.setNewInterestModel(IR);\n', '        emit NewInterestRateModelCreated(\n', '          _token,\n', '           _baseRatePerYear,\n', '          _multiplierPerYear,\n', '          _jumpMultiplierPerYear,\n', '          _optimal\n', '        );\n', '    }\n', '\n', '    /**\n', '    @notice startUpgradeTimer starts a two day timer signaling that this contract will soon be updated to a new version\n', '    @param _newWarpControl is the address of the new Warp control contract being upgraded to\n', '    **/\n', '    function startUpgradeTimer(address _newWarpControl) public onlyOwner {\n', '        newWarpControl = _newWarpControl;\n', '        graceSpace = now.add(172800);\n', '    }\n', '\n', '    /**\n', '    @notice upgradeWarp is used to upgrade the Warp platform to use a new version of the WarpControl contract\n', '    **/\n', '    function upgradeWarp() public onlyOwner {\n', '        require(now >= graceSpace, "you cant ugrade yet, less than two days");\n', '        require(newWarpControl != address(0), "no new warp control set");\n', '\n', '        oracle.transferOwnership(newWarpControl);\n', '\n', '        uint256 numVaults = lpVaults.length;\n', '        uint256 numSCVaults = scVaults.length;\n', '\n', '        for (uint256 i = 0; i < numVaults; ++i) {\n', '            WarpVaultLPI vault = WarpVaultLPI(lpVaults[i]);\n', '            vault.updateWarpControl(newWarpControl);\n', '        }\n', '\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            WarpVaultSCI vault = WarpVaultSCI(scVaults[i]);\n', '            vault.updateWarpControl(newWarpControl);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice transferWarpTeam allows the wapr team address to be changed by the owner account\n', '    @param _newWarp is the address of the new warp team\n', '    **/\n', '    function transferWarpTeam(address _newWarp) public onlyOwner {\n', '        uint256 numSCVaults = scVaults.length;\n', '        warpTeam = _newWarp;\n', '        for (uint256 i = 0; i < numSCVaults; ++i) {\n', '            WarpVaultSCI WVSC = WarpVaultSCI(scVaults[i]);\n', '            WVSC.updateTeam(_newWarp);\n', '        }\n', '    }\n', '}']