['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-22\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IERC20Token {\n', '    function balanceOf(address owner) external returns (uint256);\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function decimals() external returns (uint256);\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address payable public owner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address payable _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0), "ERC20: sending to the zero address");\n', '        owner = _newOwner;\n', '        emit OwnershipTransferred(msg.sender, _newOwner);\n', '    }\n', '}\n', '\n', '\n', 'contract TokenSale is Owned{\n', '    IERC20Token public tokenContract;  // the token being sold\n', '    uint256 public price = 625;              // 1eth = 62.5 tokens\n', '    uint256 public decimals = 18;\n', '    \n', '    uint256 public tokensSold;\n', '    uint256 public ethRaised;\n', '    uint256 public MaxETHAmount;\n', '    \n', '    bool public PresaleStarted = false;\n', '    \n', '    address[] internal buyers;\n', '    mapping (address => uint256) public _balances;\n', '\n', '    event Sold(address buyer, uint256 amount);\n', '    event DistributedTokens(uint256 tokensSold);\n', '\n', '    constructor(IERC20Token _tokenContract, uint256 _maxEthAmount) {\n', '        owner = msg.sender;\n', '        tokenContract = _tokenContract;\n', '        MaxETHAmount = _maxEthAmount;\n', '    }\n', '    \n', '    fallback() external payable {\n', '        buyTokensWithETH(msg.sender);\n', '    }\n', '    \n', '    receive() external payable{ buyTokensWithETH(msg.sender); }\n', '\n', '    // Guards against integer overflows\n', '    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        } else {\n', '            uint256 c = a * b;\n', '            assert(c / a == b);\n', '            return c;\n', '        }\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '    \n', '    function multiply(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '    \n', '    function setPrice(uint256 price_) external onlyOwner{\n', '        price = price_;\n', '    }\n', '    \n', '    function isBuyer(address _address)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        for (uint256 s = 0; s < buyers.length; s += 1) {\n', '            if (_address == buyers[s]) return (true);\n', '        }\n', '        return (false);\n', '    }\n', '\n', '    function addbuyer(address _buyer, uint256 _amount) internal {\n', '        bool _isbuyer = isBuyer(_buyer);\n', '        if (!_isbuyer) buyers.push(_buyer);\n', '        \n', '        _balances[_buyer] = add(_balances[_buyer], _amount);\n', '    }\n', '    \n', '    function togglePresale() public onlyOwner{\n', '        PresaleStarted = !PresaleStarted;\n', '    }\n', '    \n', '    function changeToken(IERC20Token newToken) external onlyOwner{\n', '        tokenContract = newToken;\n', '    }\n', '\n', '\n', '    function buyTokensWithETH(address _receiver) public payable {\n', '        require(PresaleStarted, "Presale not started yet!");\n', '        require(ethRaised < MaxETHAmount, "Presale finished");\n', '        uint _amount = msg.value;\n', '        require(ethRaised+_amount <= MaxETHAmount, "Remaining Limit not Enough");\n', '        require(_receiver != address(0), "Can\'t send to 0x00 address"); \n', '        require(_amount > 0, "Can\'t buy with 0 eth"); \n', '        \n', '        require(owner.send(_amount), "Unable to transfer eth to owner");\n', '        ethRaised += _amount;\n', '        \n', '        addbuyer(msg.sender, _amount);\n', '        \n', '    }\n', '    \n', '    function airDrop() public onlyOwner{\n', "        require(multiply(ethRaised, div(price, 10)) <= tokenContract.balanceOf(address(this)), 'Error: Contract dont have Enough tokens');\n", '        for (uint256 s = 0; s < buyers.length; s += 1) {\n', '            uint256 gBalance = _balances[buyers[s]];\n', '            \n', '            if(gBalance > 0) {\n', '                _balances[buyers[s]] = 0;\n', '                \n', '                uint tokensToBuy = multiply(div(gBalance, 10), (price));\n', '                require(tokenContract.transfer( buyers[s], tokensToBuy), "Unable to transfer token to user");\n', '                \n', '                tokensSold += tokensToBuy;\n', '                \n', '                emit Sold(msg.sender, tokensToBuy);\n', '            }\n', '        }\n', '        \n', '        ethRaised = 0;\n', '        emit DistributedTokens(tokensSold);\n', '    }\n', '    \n', '\n', '    function endSale() public {\n', '        require(msg.sender == owner);\n', '\n', '        // Send unsold tokens to the owner.\n', '        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))));\n', '\n', '        msg.sender.transfer(address(this).balance);\n', '    }\n', '}']