['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'interface IndexInterface {\n', '    function master() external view returns (address);\n', '}\n', '\n', 'contract Setup {\n', '    address public defaultImplementation;\n', '\n', '    mapping (bytes4 => address) internal sigImplementations;\n', '\n', '    mapping (address => bytes4[]) internal implementationSigs;\n', '}\n', '\n', 'contract Implementations is Setup {\n', '    event LogSetDefaultImplementation(address indexed oldImplementation, address indexed newImplementation);\n', '    event LogAddImplementation(address indexed implementation, bytes4[] sigs);\n', '    event LogRemoveImplementation(address indexed implementation, bytes4[] sigs);\n', '\n', '    IndexInterface constant public instaIndex = IndexInterface(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\n', '\n', '    modifier isMaster() {\n', '        require(msg.sender == instaIndex.master(), "Implementations: not-master");\n', '        _;\n', '    }\n', '\n', '    function setDefaultImplementation(address _defaultImplementation) external isMaster {\n', '        require(_defaultImplementation != address(0), "Implementations: _defaultImplementation address not valid");\n', '        require(_defaultImplementation != defaultImplementation, "Implementations: _defaultImplementation cannot be same");\n', '        emit LogSetDefaultImplementation(defaultImplementation, _defaultImplementation);\n', '        defaultImplementation = _defaultImplementation;\n', '    }\n', '\n', '    function addImplementation(address _implementation, bytes4[] calldata _sigs) external isMaster {\n', '        require(_implementation != address(0), "Implementations: _implementation not valid.");\n', '        require(implementationSigs[_implementation].length == 0, "Implementations: _implementation already added.");\n', '        for (uint i = 0; i < _sigs.length; i++) {\n', '            bytes4 _sig = _sigs[i];\n', '            require(sigImplementations[_sig] == address(0), "Implementations: _sig already added");\n', '            sigImplementations[_sig] = _implementation;\n', '        }\n', '        implementationSigs[_implementation] = _sigs;\n', '        emit LogAddImplementation(_implementation, _sigs);\n', '    }\n', '\n', '    function removeImplementation(address _implementation) external isMaster {\n', '        require(_implementation != address(0), "Implementations: _implementation not valid.");\n', '        require(implementationSigs[_implementation].length != 0, "Implementations: _implementation not found.");\n', '        bytes4[] memory sigs = implementationSigs[_implementation];\n', '        for (uint i = 0; i < sigs.length; i++) {\n', '            bytes4 sig = sigs[i];\n', '            delete sigImplementations[sig];\n', '        }\n', '        delete implementationSigs[_implementation];\n', '        emit LogRemoveImplementation(_implementation, sigs);\n', '\n', '    }\n', '}\n', '\n', 'contract InstaImplementations is Implementations {\n', '    function getImplementation(bytes4 _sig) external view returns (address) {\n', '        address _implementation = sigImplementations[_sig];\n', '        return _implementation == address(0) ? defaultImplementation : _implementation;\n', '    }\n', '\n', '    function getImplementationSigs(address _impl) external view returns (bytes4[] memory) {\n', '        return implementationSigs[_impl];\n', '    }\n', '\n', '    function getSigImplementation(bytes4 _sig) external view returns (address) {\n', '        return sigImplementations[_sig];\n', '    }\n', '}']