['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-31\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function decimals() external pure returns (uint);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface INimbusPair is IERC20 {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '}\n', '\n', 'interface INimbusRouter {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Ownable: Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address transferOwner) public onlyOwner {\n', '        require(transferOwner != newOwner);\n', '        newOwner = transferOwner;\n', '    }\n', '\n', '    function acceptOwnership() virtual public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Math {\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in construction, \n', '        // since the code is only stored at the end of the constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { \n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', 'interface IStakingRewards {\n', '    function earned(address account) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function stake(uint256 amount) external;\n', '    function stakeFor(uint256 amount, address user) external;\n', '    function getReward() external;\n', '    function withdraw(uint256 nonce) external;\n', '    function withdrawAndGetReward(uint256 nonce) external;\n', '}\n', '\n', 'interface IERC20Permit {\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'contract StakingLPRewardFixedAPY is IStakingRewards, ReentrancyGuard, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IERC20 public immutable rewardsToken;\n', '    INimbusPair public immutable stakingLPToken;\n', '    INimbusRouter public swapRouter;\n', '    address public immutable lPPairTokenA;\n', '    address public immutable lPPairTokenB;\n', '    uint256 public rewardRate; \n', '    uint256 public constant rewardDuration = 365 days; \n', '\n', '    mapping(address => uint256) public weightedStakeDate;\n', '    mapping(address => mapping(uint256 => uint256)) public stakeAmounts;\n', '    mapping(address => mapping(uint256 => uint256)) public stakeAmountsRewardEquivalent;\n', '    mapping(address => uint256) public stakeNonces;\n', '\n', '    uint256 private _totalSupply;\n', '    uint256 private _totalSupplyRewardEquivalent;\n', '    uint256 private immutable _tokenADecimalCompensate;\n', '    uint256 private immutable _tokenBDecimalCompensate;\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => uint256) private _balancesRewardEquivalent;\n', '\n', '    event RewardUpdated(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event Rescue(address to, uint256 amount);\n', '    event RescueToken(address to, address token, uint256 amount);\n', '\n', '    constructor(\n', '        address _rewardsToken,\n', '        address _stakingLPToken,\n', '        address _lPPairTokenA,\n', '        address _lPPairTokenB,\n', '        address _swapRouter,\n', '        uint _rewardRate\n', '    ) {\n', '        rewardsToken = IERC20(_rewardsToken);\n', '        stakingLPToken = INimbusPair(_stakingLPToken);\n', '        swapRouter = INimbusRouter(_swapRouter);\n', '        rewardRate = _rewardRate;\n', '        lPPairTokenA = _lPPairTokenA;\n', '        lPPairTokenB = _lPPairTokenB;\n', '        uint tokenADecimals = IERC20(_lPPairTokenA).decimals();\n', '        require(tokenADecimals >= 6, "StakingLPRewardFixedAPY: small amount of decimals");\n', '        _tokenADecimalCompensate = tokenADecimals.sub(6);\n', '        uint tokenBDecimals = IERC20(_lPPairTokenB).decimals();\n', '        require(tokenBDecimals >= 6, "StakingLPRewardFixedAPY: small amount of decimals");\n', '        _tokenBDecimalCompensate = tokenBDecimals.sub(6);\n', '    }\n', '\n', '    function totalSupply() external view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function totalSupplyRewardEquivalent() external view returns (uint256) {\n', '        return _totalSupplyRewardEquivalent;\n', '    }\n', '\n', '    function getDecimalPriceCalculationCompensate() external view returns (uint tokenADecimalCompensate, uint tokenBDecimalCompensate) { \n', '        tokenADecimalCompensate = _tokenADecimalCompensate;\n', '        tokenBDecimalCompensate = _tokenBDecimalCompensate;\n', '    }\n', '\n', '    function balanceOf(address account) external view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '    \n', '    function balanceOfRewardEquivalent(address account) external view returns (uint256) {\n', '        return _balancesRewardEquivalent[account];\n', '    }\n', '\n', '    function earned(address account) public view override returns (uint256) {\n', '        return (_balancesRewardEquivalent[account].mul(block.timestamp.sub(weightedStakeDate[account])).mul(rewardRate)) / (100 * rewardDuration);\n', '    }\n', '\n', '    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {\n', '        require(amount > 0, "StakingLPRewardFixedAPY: Cannot stake 0");\n', '        // permit\n', '        IERC20Permit(address(stakingLPToken)).permit(msg.sender, address(this), amount, deadline, v, r, s);\n', '        _stake(amount, msg.sender);\n', '    }\n', '\n', '    function stake(uint256 amount) external override nonReentrant {\n', '        require(amount > 0, "StakingLPRewardFixedAPY: Cannot stake 0");\n', '        _stake(amount, msg.sender);\n', '    }\n', '\n', '    function stakeFor(uint256 amount, address user) external override nonReentrant {\n', '        require(amount > 0, "StakingLPRewardFixedAPY: Cannot stake 0");\n', '        _stake(amount, user);\n', '    }\n', '\n', '    function _stake(uint256 amount, address user) private {\n', '        IERC20(stakingLPToken).safeTransferFrom(msg.sender, address(this), amount);\n', '        uint amountRewardEquivalent = getCurrentLPPrice().mul(amount) / 10 ** 18;\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _totalSupplyRewardEquivalent = _totalSupplyRewardEquivalent.add(amountRewardEquivalent);\n', '        uint previousAmount = _balances[user];\n', '        uint newAmount = previousAmount.add(amount);\n', '        weightedStakeDate[user] = (weightedStakeDate[user].mul(previousAmount) / newAmount).add(block.timestamp.mul(amount) / newAmount);\n', '        _balances[user] = newAmount;\n', '\n', '        uint stakeNonce = stakeNonces[user]++;\n', '        stakeAmounts[user][stakeNonce] = amount;\n', '        \n', '        stakeAmountsRewardEquivalent[user][stakeNonce] = amountRewardEquivalent;\n', '        _balancesRewardEquivalent[user] = _balancesRewardEquivalent[user].add(amountRewardEquivalent);\n', '        emit Staked(user, amount);\n', '    }\n', '\n', '\n', '    //A user can withdraw its staking tokens even if there is no rewards tokens on the contract account\n', '    function withdraw(uint256 nonce) public override nonReentrant {\n', '        require(stakeAmounts[msg.sender][nonce] > 0, "StakingLPRewardFixedAPY: This stake nonce was withdrawn");\n', '        uint amount = stakeAmounts[msg.sender][nonce];\n', '        uint amountRewardEquivalent = stakeAmountsRewardEquivalent[msg.sender][nonce];\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _totalSupplyRewardEquivalent = _totalSupplyRewardEquivalent.sub(amountRewardEquivalent);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        _balancesRewardEquivalent[msg.sender] = _balancesRewardEquivalent[msg.sender].sub(amountRewardEquivalent);\n', '        IERC20(stakingLPToken).safeTransfer(msg.sender, amount);\n', '        stakeAmounts[msg.sender][nonce] = 0;\n', '        stakeAmountsRewardEquivalent[msg.sender][nonce] = 0;\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function getReward() public override nonReentrant {\n', '        uint256 reward = earned(msg.sender);\n', '        if (reward > 0) {\n', '            weightedStakeDate[msg.sender] = block.timestamp;\n', '            rewardsToken.safeTransfer(msg.sender, reward);\n', '            emit RewardPaid(msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function withdrawAndGetReward(uint256 nonce) external override {\n', '        getReward();\n', '        withdraw(nonce);\n', '    }\n', '\n', '    function getCurrentLPPrice() public view returns (uint) {\n', '        // LP PRICE = 2 * SQRT(reserveA * reaserveB ) * SQRT(token1/RewardTokenPrice * token2/RewardTokenPrice) / LPTotalSupply\n', '        uint tokenAToRewardPrice;\n', '        uint tokenBToRewardPrice;\n', '        address rewardToken = address(rewardsToken);    \n', '        address[] memory path = new address[](2);\n', '        path[1] = address(rewardToken);\n', '\n', '        if (lPPairTokenA != rewardToken) {\n', '            path[0] = lPPairTokenA;\n', '            tokenAToRewardPrice = swapRouter.getAmountsOut(10 ** 6, path)[1];\n', '            if (_tokenADecimalCompensate > 0) \n', '                tokenAToRewardPrice = tokenAToRewardPrice.mul(10 ** _tokenADecimalCompensate);\n', '        } else {\n', '            tokenAToRewardPrice = 10 ** 18;\n', '        }\n', '        \n', '        if (lPPairTokenB != rewardToken) {\n', '            path[0] = lPPairTokenB;\n', '            tokenBToRewardPrice = swapRouter.getAmountsOut(10 ** 6, path)[1];\n', '            if (_tokenBDecimalCompensate > 0)\n', '                tokenBToRewardPrice = tokenBToRewardPrice.mul(10 ** _tokenBDecimalCompensate);\n', '        } else {\n', '            tokenBToRewardPrice = 10 ** 18;\n', '        }\n', '\n', '        uint totalLpSupply = IERC20(stakingLPToken).totalSupply();\n', '        require(totalLpSupply > 0, "StakingLPRewardFixedAPY: No liquidity for pair");\n', '        (uint reserveA, uint reaserveB,) = stakingLPToken.getReserves();\n', '        uint price = \n', '            uint(2).mul(Math.sqrt(reserveA.mul(reaserveB))\n', '            .mul(Math.sqrt(tokenAToRewardPrice.mul(tokenBToRewardPrice)))) / totalLpSupply;\n', '        \n', '        return price;\n', '    }\n', '\n', '\n', '    function updateRewardAmount(uint256 reward) external onlyOwner {\n', '        rewardRate = reward;\n', '        emit RewardUpdated(reward);\n', '    }\n', '\n', '    function updateSwapRouter(address newSwapRouter) external onlyOwner {\n', '        require(newSwapRouter != address(0), "StakingLPRewardFixedAPY: Address is zero");\n', '        swapRouter = INimbusRouter(newSwapRouter);\n', '    }\n', '\n', '    function rescue(address to, IERC20 token, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "StakingLPRewardFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "StakingLPRewardFixedAPY: Cannot rescue 0");\n', '        require(token != stakingLPToken, "StakingLPRewardFixedAPY: Cannot rescue staking token");\n', '        //owner can rescue rewardsToken if there is spare unused tokens on staking contract balance\n', '\n', '        token.safeTransfer(to, amount);\n', '        emit RescueToken(to, address(token), amount);\n', '    }\n', '\n', '    function rescue(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "StakingLPRewardFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "StakingLPRewardFixedAPY: Cannot rescue 0");\n', '\n', '        to.transfer(amount);\n', '        emit Rescue(to, amount);\n', '    }\n', '}']