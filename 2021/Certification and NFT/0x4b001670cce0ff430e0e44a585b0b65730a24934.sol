['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./ERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'contract ESSToken is ERC20("Essential Shelf", "ESS") {\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '\n', '    uint8 public constant DECIMALS=8;\n', '    uint256 public constant INITIAL_SUPPLY=180000000*(10**uint256(DECIMALS));\n', '    address public project=msg.sender;\n', '    bool public mintingFinished=false;\n', '    uint256 public deposit;\n', '    mapping (address=>uint256) private deposit_amount;\n', '\n', '    constructor () {\n', '        _mint(msg.sender, INITIAL_SUPPLY);\n', '    }\n', '\n', '    function changeDeposit(uint256 ndeposit) public onlyOwner{\n', '        deposit=ndeposit;\n', '    }\n', '\n', '    function mint(uint256 amount) onlyOwner canMint public{\n', '        uint256 amount2=amount*(10**uint256(DECIMALS));\n', '        _mint(msg.sender,amount2);\n', '    }\n', '\n', '    function burn(uint256 amount) onlyOwner public {\n', '        uint256 amount2=amount*(10**uint256(DECIMALS));\n', '        _burn(msg.sender,amount2);\n', '    }\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender==project);\n', '        _;\n', '    }\n', '\n', '    function finishingMinting() onlyOwner canMint public returns (bool) {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '        return true;\n', '    }\n', '\n', '    function createStoreFactory(uint256 minimum) public returns(Store Store_address) {\n', '        require(balanceOf(msg.sender)>=deposit*(10**uint256(DECIMALS)));\n', '        uint256 _deposit=deposit*(10**uint256(DECIMALS));\n', '        deposit_amount[msg.sender]=deposit;\n', '        transfer(project, _deposit);\n', '        return new Store(minimum, msg.sender);\n', '    }\n', '\n', '    function getDeposit(address user) public view returns (uint256) {\n', '        return deposit_amount[user];\n', '    }\n', '\n', '}\n', '\n', 'contract Store {\n', '    struct Request {\n', '        string description;\n', '        uint256 value;\n', '        address payable recipient;\n', '        bool complete;\n', '        uint256 approvalCount;\n', '        mapping(address => bool) approvals;\n', '    }\n', '\n', '    address public manager;\n', '    uint256 public minimumContribution;\n', '    mapping(address => bool) public approvers;\n', '    uint256 public approversCount;\n', '    uint256 public numRequests;\n', '    mapping (uint256=>Request) public request;\n', '\n', '    modifier restricted() {\n', '        require(msg.sender == manager);\n', '        _;\n', '    }\n', '\n', '    constructor (uint256 minimum, address creator) {\n', '        manager = creator;\n', '        minimumContribution = minimum;\n', '    }\n', '\n', '    function contribute() public payable {\n', '        require(msg.value > minimumContribution);\n', '\n', '        approvers[msg.sender] = true;\n', '        approversCount++;\n', '    }\n', '\n', '    function CreatRequest(string memory description, uint256 value, address payable recipient) public restricted returns (uint256 IDRequest) {\n', '        IDRequest=numRequests++;\n', '        Request storage c = request[IDRequest];\n', '        c.description=description;\n', '        c.value=value;\n', '        c.recipient=recipient;\n', '        c.complete=false;\n', '        c.approvalCount=0;\n', '    }\n', '\n', '    function approveRequest(uint256 index) public {\n', '        Request storage c = request[index];\n', '\n', '        require(approvers[msg.sender]);\n', '        require(!c.approvals[msg.sender]);\n', '\n', '        c.approvals[msg.sender] = true;\n', '        c.approvalCount++;\n', '    }\n', '\n', '    function finalizeRequest(uint256 index) public restricted {\n', '        Request storage c = request[index];\n', '\n', '        require(c.approvalCount > (approversCount / 2));\n', '        require(!c.complete);\n', '\n', '        c.recipient.transfer(c.value);\n', '        c.complete = true;\n', '    }\n', '}']