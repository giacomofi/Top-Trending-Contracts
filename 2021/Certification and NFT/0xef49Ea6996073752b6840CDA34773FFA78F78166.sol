['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-26\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/common/governance/IGovernance.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'interface IGovernance {\n', '    function update(address target, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/common/governance/Governable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract Governable {\n', '    IGovernance public governance;\n', '\n', '    constructor(address _governance) public {\n', '        governance = IGovernance(_governance);\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        _assertGovernance();\n', '        _;\n', '    }\n', '\n', '    function _assertGovernance() private view {\n', '        require(\n', '            msg.sender == address(governance),\n', '            "Only governance contract is authorized"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/root/withdrawManager/IWithdrawManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract IWithdrawManager {\n', '    function createExitQueue(address token) external;\n', '\n', '    function verifyInclusion(\n', '        bytes calldata data,\n', '        uint8 offset,\n', '        bool verifyTxInclusion\n', '    ) external view returns (uint256 age);\n', '\n', '    function addExitToQueue(\n', '        address exitor,\n', '        address childToken,\n', '        address rootToken,\n', '        uint256 exitAmountOrTokenId,\n', '        bytes32 txHash,\n', '        bool isRegularExit,\n', '        uint256 priority\n', '    ) external;\n', '\n', '    function addInput(\n', '        uint256 exitId,\n', '        uint256 age,\n', '        address utxoOwner,\n', '        address token\n', '    ) external;\n', '\n', '    function challengeExit(\n', '        uint256 exitId,\n', '        uint256 inputId,\n', '        bytes calldata challengeData,\n', '        address adjudicatorPredicate\n', '    ) external;\n', '}\n', '\n', '// File: contracts/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract Registry is Governable {\n', '    // @todo hardcode constants\n', '    bytes32 private constant WETH_TOKEN = keccak256("wethToken");\n', '    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");\n', '    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");\n', '    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");\n', '    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");\n', '    bytes32 private constant CHILD_CHAIN = keccak256("childChain");\n', '    bytes32 private constant STATE_SENDER = keccak256("stateSender");\n', '    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");\n', '\n', '    address public erc20Predicate;\n', '    address public erc721Predicate;\n', '\n', '    mapping(bytes32 => address) public contractMap;\n', '    mapping(address => address) public rootToChildToken;\n', '    mapping(address => address) public childToRootToken;\n', '    mapping(address => bool) public proofValidatorContracts;\n', '    mapping(address => bool) public isERC721;\n', '\n', '    enum Type {Invalid, ERC20, ERC721, Custom}\n', '    struct Predicate {\n', '        Type _type;\n', '    }\n', '    mapping(address => Predicate) public predicates;\n', '\n', '    event TokenMapped(address indexed rootToken, address indexed childToken);\n', '    event ProofValidatorAdded(address indexed validator, address indexed from);\n', '    event ProofValidatorRemoved(address indexed validator, address indexed from);\n', '    event PredicateAdded(address indexed predicate, address indexed from);\n', '    event PredicateRemoved(address indexed predicate, address indexed from);\n', '    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\n', '\n', '    constructor(address _governance) public Governable(_governance) {}\n', '\n', '    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\n', '        emit ContractMapUpdated(_key, contractMap[_key], _address);\n', '        contractMap[_key] = _address;\n', '    }\n', '\n', '    /**\n', '     * @dev Map root token to child token\n', '     * @param _rootToken Token address on the root chain\n', '     * @param _childToken Token address on the child chain\n', '     * @param _isERC721 Is the token being mapped ERC721\n', '     */\n', '    function mapToken(\n', '        address _rootToken,\n', '        address _childToken,\n', '        bool _isERC721\n', '    ) external onlyGovernance {\n', '        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");\n', '        rootToChildToken[_rootToken] = _childToken;\n', '        childToRootToken[_childToken] = _rootToken;\n', '        isERC721[_rootToken] = _isERC721;\n', '        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\n', '        emit TokenMapped(_rootToken, _childToken);\n', '    }\n', '\n', '    function addErc20Predicate(address predicate) public onlyGovernance {\n', '        require(predicate != address(0x0), "Can not add null address as predicate");\n', '        erc20Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC20);\n', '    }\n', '\n', '    function addErc721Predicate(address predicate) public onlyGovernance {\n', '        erc721Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC721);\n', '    }\n', '\n', '    function addPredicate(address predicate, Type _type) public onlyGovernance {\n', '        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");\n', '        predicates[predicate]._type = _type;\n', '        emit PredicateAdded(predicate, msg.sender);\n', '    }\n', '\n', '    function removePredicate(address predicate) public onlyGovernance {\n', '        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");\n', '        delete predicates[predicate];\n', '        emit PredicateRemoved(predicate, msg.sender);\n', '    }\n', '\n', '    function getValidatorShareAddress() public view returns (address) {\n', '        return contractMap[VALIDATOR_SHARE];\n', '    }\n', '\n', '    function getWethTokenAddress() public view returns (address) {\n', '        return contractMap[WETH_TOKEN];\n', '    }\n', '\n', '    function getDepositManagerAddress() public view returns (address) {\n', '        return contractMap[DEPOSIT_MANAGER];\n', '    }\n', '\n', '    function getStakeManagerAddress() public view returns (address) {\n', '        return contractMap[STAKE_MANAGER];\n', '    }\n', '\n', '    function getSlashingManagerAddress() public view returns (address) {\n', '        return contractMap[SLASHING_MANAGER];\n', '    }\n', '\n', '    function getWithdrawManagerAddress() public view returns (address) {\n', '        return contractMap[WITHDRAW_MANAGER];\n', '    }\n', '\n', '    function getChildChainAndStateSender() public view returns (address, address) {\n', '        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\n', '    }\n', '\n', '    function isTokenMapped(address _token) public view returns (bool) {\n', '        return rootToChildToken[_token] != address(0x0);\n', '    }\n', '\n', '    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\n', '        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");\n', '        return isERC721[_token];\n', '    }\n', '\n', '    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\n', '        if (isTokenMappedAndIsErc721(_token)) {\n', '            return erc721Predicate;\n', '        }\n', '        return erc20Predicate;\n', '    }\n', '\n', '    function isChildTokenErc721(address childToken) public view returns (bool) {\n', '        address rootToken = childToRootToken[childToken];\n', '        require(rootToken != address(0x0), "Child token is not mapped");\n', '        return isERC721[rootToken];\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Lockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Lockable {\n', '    bool public locked;\n', '\n', '    modifier onlyWhenUnlocked() {\n', '        _assertUnlocked();\n', '        _;\n', '    }\n', '\n', '    function _assertUnlocked() private view {\n', '        require(!locked, "locked");\n', '    }\n', '\n', '    function lock() public {\n', '        locked = true;\n', '    }\n', '\n', '    function unlock() public {\n', '        locked = false;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/GovernanceLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract GovernanceLockable is Lockable, Governable {\n', '    constructor(address governance) public Governable(governance) {}\n', '\n', '    function lock() public onlyGovernance {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyGovernance {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/IStakeManager.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract IStakeManager {\n', '    // validator replacement\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\n', '\n', '    function transferFunds(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function delegationDeposit(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function unstake(uint256 validatorId) external;\n', '\n', '    function totalStakedFor(address addr) external view returns (uint256);\n', '\n', '    function stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) public;\n', '\n', '    function checkSignatures(\n', '        uint256 blockInterval,\n', '        bytes32 voteHash,\n', '        bytes32 stateRoot,\n', '        address proposer,\n', '        uint[3][] calldata sigs\n', '    ) external returns (uint256);\n', '\n', '    function updateValidatorState(uint256 validatorId, int256 amount) public;\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address);\n', '\n', '    function slash(bytes calldata slashingInfoList) external returns (uint256);\n', '\n', '    function validatorStake(uint256 validatorId) public view returns (uint256);\n', '\n', '    function epoch() public view returns (uint256);\n', '\n', '    function getRegistry() public view returns (address);\n', '\n', '    function withdrawalDelay() public view returns (uint256);\n', '\n', '    function delegatedAmount(uint256 validatorId) public view returns(uint256);\n', '\n', '    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\n', '\n', '    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\n', '\n', '    function delegatorsReward(uint256 validatorId) public view returns(uint256);\n', '\n', '    function dethroneAndStake(\n', '        address auctionUser,\n', '        uint256 heimdallFee,\n', '        uint256 validatorId,\n', '        uint256 auctionAmount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/RootChainable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title RootChainable\n', ' */\n', 'contract RootChainable is Ownable {\n', '    address public rootChain;\n', '\n', '    // Rootchain changed\n', '    event RootChainChanged(\n', '        address indexed previousRootChain,\n', '        address indexed newRootChain\n', '    );\n', '\n', '    // only root chain\n', '    modifier onlyRootChain() {\n', '        require(msg.sender == rootChain);\n', '        _;\n', '    }\n', '\n', '    /**\n', '   * @dev Allows the current owner to change root chain address.\n', '   * @param newRootChain The address to new rootchain.\n', '   */\n', '    function changeRootChain(address newRootChain) public onlyOwner {\n', '        require(newRootChain != address(0));\n', '        emit RootChainChanged(rootChain, newRootChain);\n', '        rootChain = newRootChain;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/StakingInfo.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '// dummy interface to avoid cyclic dependency\n', 'contract IStakeManagerLocal {\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    bytes32 public accountStateRoot;\n', '    uint256 public activeAmount; // delegation amount from validator contract\n', '    uint256 public validatorRewards;\n', '\n', '    function currentValidatorSetTotalStake() public view returns (uint256);\n', '\n', '    // signer to Validator mapping\n', '    function signerToValidator(address validatorAddress)\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function isValidator(uint256 validatorId) public view returns (bool);\n', '}\n', '\n', 'contract StakingInfo is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(uint256 => uint256) public validatorNonce;\n', '\n', "    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\n", '    /// @param signer validator address.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', "    /// @param activationEpoch validator's first epoch as proposer.\n", '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    /// @param signerPubkey public key of the validator\n', '    event Staked(\n', '        address indexed signer,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 indexed activationEpoch,\n', '        uint256 amount,\n', '        uint256 total,\n', '        bytes signerPubkey\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    event Unstaked(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in '_unstake()'.\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param deactivationEpoch last epoch for validator.\n', '    /// @param amount staking amount.\n', '    event UnstakeInit(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 deactivationEpoch,\n', '        uint256 indexed amount\n', '    );\n', '\n', "    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\n", '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param oldSigner old address of the validator.\n', '    /// @param newSigner new address of the validator.\n', '    /// @param signerPubkey public key of the validator.\n', '    event SignerChange(\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        address indexed oldSigner,\n', '        address indexed newSigner,\n', '        bytes signerPubkey\n', '    );\n', '    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\n', '    event Jailed(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed exitEpoch,\n', '        address indexed signer\n', '    );\n', '    event UnJailed(uint256 indexed validatorId, address indexed signer);\n', '    event Slashed(uint256 indexed nonce, uint256 indexed amount);\n', '    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\n', '    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\n', '    event ProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    );\n', '\n', '    event RewardUpdate(uint256 newReward, uint256 oldReward);\n', '\n', '    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param newAmount the updated stake amount.\n', '    event StakeUpdate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed nonce,\n', '        uint256 indexed newAmount\n', '    );\n', '    event ClaimRewards(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed totalAmount\n', '    );\n', '    event StartAuction(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed auctionAmount\n', '    );\n', '    event ConfirmAuction(\n', '        uint256 indexed newValidatorId,\n', '        uint256 indexed oldValidatorId,\n', '        uint256 indexed amount\n', '    );\n', '    event TopUpFee(address indexed user, uint256 indexed fee);\n', '    event ClaimFee(address indexed user, uint256 indexed fee);\n', '    // Delegator events\n', '    event ShareMinted(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event ShareBurned(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event DelegatorClaimedRewards(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed rewards\n', '    );\n', '    event DelegatorRestaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed totalStaked\n', '    );\n', '    event DelegatorUnstaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        require(_contract == msg.sender,\n', '        "Invalid sender, not validator");\n', '        _;\n', '    }\n', '\n', '    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        address _stakeManager = registry.getStakeManagerAddress();\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\n', '            validatorId\n', '        );\n', '        require(_contract == msg.sender || _stakeManager == msg.sender,\n', '        "Invalid sender, not stake manager or validator contract");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '    modifier onlySlashingManager() {\n', '        require(registry.getSlashingManagerAddress() == msg.sender,\n', '        "Invalid sender, not slashing manager");\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry) public {\n', '        registry = Registry(_registry);\n', '    }\n', '\n', '    function updateNonce(\n', '        uint256[] calldata validatorIds,\n', '        uint256[] calldata nonces\n', '    ) external onlyOwner {\n', '        require(validatorIds.length == nonces.length, "args length mismatch");\n', '\n', '        for (uint256 i = 0; i < validatorIds.length; ++i) {\n', '            validatorNonce[validatorIds[i]] = nonces[i];\n', '        }\n', '    } \n', '\n', '    function logStaked(\n', '        address signer,\n', '        bytes memory signerPubkey,\n', '        uint256 validatorId,\n', '        uint256 activationEpoch,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit Staked(\n', '            signer,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            activationEpoch,\n', '            amount,\n', '            total,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logUnstaked(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        emit Unstaked(user, validatorId, amount, total);\n', '    }\n', '\n', '    function logUnstakeInit(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 deactivationEpoch,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit UnstakeInit(\n', '            user,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            deactivationEpoch,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function logSignerChange(\n', '        uint256 validatorId,\n', '        address oldSigner,\n', '        address newSigner,\n', '        bytes memory signerPubkey\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit SignerChange(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            oldSigner,\n', '            newSigner,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Restaked(validatorId, amount, total);\n', '    }\n', '\n', '    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Jailed(validatorId, exitEpoch, signer);\n', '    }\n', '\n', '    function logUnjailed(uint256 validatorId, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit UnJailed(validatorId, signer);\n', '    }\n', '\n', '    function logSlashed(uint256 nonce, uint256 amount)\n', '        public\n', '        onlySlashingManager\n', '    {\n', '        emit Slashed(nonce, amount);\n', '    }\n', '\n', '    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit ThresholdChange(newThreshold, oldThreshold);\n', '    }\n', '\n', '    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit DynastyValueChange(newDynasty, oldDynasty);\n', '    }\n', '\n', '    function logProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    ) public onlyStakeManager {\n', '        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\n', '    }\n', '\n', '    function logRewardUpdate(uint256 newReward, uint256 oldReward)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit RewardUpdate(newReward, oldReward);\n', '    }\n', '\n', '    function logStakeUpdate(uint256 validatorId)\n', '        public\n', '        StakeManagerOrValidatorContract(validatorId)\n', '    {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit StakeUpdate(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            totalValidatorStake(validatorId)\n', '        );\n', '    }\n', '\n', '    function logClaimRewards(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 totalAmount\n', '    ) public onlyStakeManager {\n', '        emit ClaimRewards(validatorId, amount, totalAmount);\n', '    }\n', '\n', '    function logStartAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 auctionAmount\n', '    ) public onlyStakeManager {\n', '        emit StartAuction(validatorId, amount, auctionAmount);\n', '    }\n', '\n', '    function logConfirmAuction(\n', '        uint256 newValidatorId,\n', '        uint256 oldValidatorId,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\n', '    }\n', '\n', '    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit TopUpFee(user, fee);\n', '    }\n', '\n', '    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit ClaimFee(user, fee);\n', '    }\n', '\n', '    function getStakerDetails(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 reward,\n', '            uint256 activationEpoch,\n', '            uint256 deactivationEpoch,\n', '            address signer,\n', '            uint256 _status\n', '        )\n', '    {\n', '        IStakeManagerLocal stakeManager = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        );\n', '        address _contract;\n', '        IStakeManagerLocal.Status status;\n', '        (\n', '            amount,\n', '            reward,\n', '            activationEpoch,\n', '            deactivationEpoch,\n', '            ,\n', '            signer,\n', '            _contract,\n', '            status\n', '        ) = stakeManager.validators(validatorId);\n', '        _status = uint256(status);\n', '        if (_contract != address(0x0)) {\n', '            reward += IStakeManagerLocal(_contract).validatorRewards();\n', '        }\n', '    }\n', '\n', '    function totalValidatorStake(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (uint256 validatorStake)\n', '    {\n', '        address contractAddress;\n', '        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        if (contractAddress != address(0x0)) {\n', '            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\n', '        }\n', '    }\n', '\n', '    function getAccountStateRoot()\n', '        public\n', '        view\n', '        returns (bytes32 accountStateRoot)\n', '    {\n', '        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\n', '            .accountStateRoot();\n', '    }\n', '\n', '    function getValidatorContractAddress(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (address ValidatorContract)\n', '    {\n', '        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '    }\n', '\n', '    // validator Share contract logging func\n', '    function logShareMinted(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareMinted(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logShareBurned(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurned(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logDelegatorClaimRewards(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 rewards\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorClaimedRewards(validatorId, user, rewards);\n', '    }\n', '\n', '    function logDelegatorRestaked(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 totalStaked\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorRestaked(validatorId, user, totalStaked);\n', '    }\n', '\n', '    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\n', '        public\n', '        onlyValidatorContract(validatorId)\n', '    {\n', '        emit DelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    // deprecated\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://eips.ethereum.org/EIPS/eip-165\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/drafts/Counters.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title Counters\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', ' * of elements in a mapping, issuing ERC721 ids, or counting request ids\n', ' *\n', ' * Include with `using Counters for Counters.Counter;`\n', ' * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n', ' * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', ' * directly accessed.\n', ' */\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /*\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using Counters for Counters.Counter;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => Counters.Counter) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner].current();\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg.sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return bool whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     * is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to].increment();\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner);\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner].decrement();\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from].decrement();\n', '        _ownedTokensCount[to].increment();\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Enumerable is IERC721 {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '    /*\n', '     * 0x780e9d63 ===\n', "     *     bytes4(keccak256('totalSupply()')) ^\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "     *     bytes4(keccak256('tokenByIndex(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721Enumerable via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '     * @param owner address owning the tokens list to be accessed\n', '     * @param index uint256 representing the index to be accessed of the requested tokens list\n', '     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner));\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the total amount of tokens stored by the contract\n', '     * @return uint256 representing the total amount of tokens\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of all the tokens in this contract\n', '     * Reverts if the index is greater or equal to the total number of tokens\n', '     * @param index uint256 representing the index to be accessed of the tokens list\n', '     * @return uint256 token ID at the given index of the tokens list\n', '     */\n', '    function tokenByIndex(uint256 index) public view returns (uint256) {\n', '        require(index < totalSupply());\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to address the beneficiary that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the list of token IDs of the requested owner\n', '     * @param owner address owning the tokens\n', '     * @return uint256[] List of token IDs owned by the requested address\n', '     */\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        _ownedTokens[from].length--;\n', '\n', "        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n", '        // lastTokenId, or just over the end of the array if the token was the last one).\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        _allTokens.length--;\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) private _tokenURIs;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '    /*\n', '     * 0x5b5e139f ===\n', "     *     bytes4(keccak256('name()')) ^\n", "     *     bytes4(keccak256('symbol()')) ^\n", "     *     bytes4(keccak256('tokenURI(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId));\n', '        return _tokenURIs[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the token URI for a given token\n', '     * Reverts if the token ID does not exist\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param uri string URI to assign\n', '     */\n', '    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n', '        require(_exists(tokenId));\n', '        _tokenURIs[tokenId] = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned by the msg.sender\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakingNFT.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract StakingNFT is ERC721Full, Ownable {\n', '    constructor(string memory name, string memory symbol)\n', '        public\n', '        ERC721Full(name, symbol)\n', '    {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '\n', '    function mint(address to, uint256 tokenId) public onlyOwner {\n', '        require(\n', '            balanceOf(to) == 0,\n', '            "Validators MUST NOT own multiple stake position"\n', '        );\n', '        _mint(to, tokenId);\n', '    }\n', '\n', '    function burn(uint256 tokenId) public onlyOwner {\n', '        _burn(tokenId);\n', '    }\n', '\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(\n', '            balanceOf(to) == 0,\n', '            "Validators MUST NOT own multiple stake position"\n', '        );\n', '        super._transferFrom(from, to, tokenId);\n', '    }\n', '}\n', '\n', '// File: contracts/common/misc/ERCProxy.sol\n', '\n', '/*\n', ' * SPDX-License-Identitifer:    MIT\n', ' */\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\n', '\n', 'interface ERCProxy {\n', '    function proxyType() external pure returns (uint256 proxyTypeId);\n', '    function implementation() external view returns (address codeAddr);\n', '}\n', '\n', '// File: contracts/common/misc/DelegateProxyForwarder.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract DelegateProxyForwarder {\n', '    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let result := delegatecall(\n', '                sub(gas, 10000),\n', '                _dst,\n', '                add(_calldata, 0x20),\n', '                mload(_calldata),\n', '                0,\n', '                0\n', '            )\n', '            let size := returndatasize\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, size)\n', '                }\n', '                default {\n', '                    return(ptr, size)\n', '                }\n', '        }\n', '    }\n', '    \n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(_target)\n', '        }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/common/misc/DelegateProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract DelegateProxy is ERCProxy, DelegateProxyForwarder {\n', '    function proxyType() external pure returns (uint256 proxyTypeId) {\n', '        // Upgradeable proxy\n', '        proxyTypeId = 2;\n', '    }\n', '\n', '    function implementation() external view returns (address);\n', '}\n', '\n', '// File: contracts/common/misc/UpgradableProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract UpgradableProxy is DelegateProxy {\n', '    event ProxyUpdated(address indexed _new, address indexed _old);\n', '    event OwnerUpdate(address _new, address _old);\n', '\n', '    bytes32 constant IMPLEMENTATION_SLOT = keccak256("matic.network.proxy.implementation");\n', '    bytes32 constant OWNER_SLOT = keccak256("matic.network.proxy.owner");\n', '\n', '    constructor(address _proxyTo) public {\n', '        setOwner(msg.sender);\n', '        setImplementation(_proxyTo);\n', '    }\n', '\n', '    function() external payable {\n', '        // require(currentContract != 0, "If app code has not been set yet, do not call");\n', '        // Todo: filter out some calls or handle in the end fallback\n', '        delegatedFwd(loadImplementation(), msg.data);\n', '    }\n', '\n', '    modifier onlyProxyOwner() {\n', '        require(loadOwner() == msg.sender, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function owner() external view returns(address) {\n', '        return loadOwner();\n', '    }\n', '\n', '    function loadOwner() internal view returns(address) {\n', '        address _owner;\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            _owner := sload(position)\n', '        }\n', '        return _owner;\n', '    }\n', '\n', '    function implementation() external view returns (address) {\n', '        return loadImplementation();\n', '    }\n', '\n', '    function loadImplementation() internal view returns(address) {\n', '        address _impl;\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            _impl := sload(position)\n', '        }\n', '        return _impl;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyProxyOwner {\n', '        require(newOwner != address(0), "ZERO_ADDRESS");\n', '        emit OwnerUpdate(newOwner, loadOwner());\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    function setOwner(address newOwner) private {\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            sstore(position, newOwner)\n', '        }\n', '    }\n', '\n', '    function updateImplementation(address _newProxyTo) public onlyProxyOwner {\n', '        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");\n', '        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");\n', '\n', '        emit ProxyUpdated(_newProxyTo, loadImplementation());\n', '        \n', '        setImplementation(_newProxyTo);\n', '    }\n', '\n', '    function updateAndCall(address _newProxyTo, bytes memory data) payable public onlyProxyOwner {\n', '        updateImplementation(_newProxyTo);\n', '\n', '        (bool success, bytes memory returnData) = address(this).call.value(msg.value)(data);\n', '        require(success, string(returnData));\n', '    }\n', '\n', '    function setImplementation(address _newProxyTo) private {\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(position, _newProxyTo)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShareProxy.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract ValidatorShareProxy is UpgradableProxy {\n', '    constructor(address _registry) public UpgradableProxy(_registry) {}\n', '\n', '    function loadImplementation() internal view returns (address) {\n', '        return Registry(super.loadImplementation()).getValidatorShareAddress();\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://eips.ethereum.org/EIPS/eip-20\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to tr vbmansfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', "     * @dev Approve an address to spend another addresses' tokens.\n", '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '\n', '// File: contracts/common/tokens/ERC20NonTradable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract ERC20NonTradable is ERC20 {\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        revert("disabled");\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Initializable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Initializable {\n', '    bool inited = false;\n', '\n', '    modifier initializer() {\n', '        require(!inited, "already inited");\n', '        inited = true;\n', '        \n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/EventsHub.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract IStakeManagerEventsHub {\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '}\n', '\n', 'contract EventsHub is Initializable {\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);\n', '        require(_contract == msg.sender, "not validator");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '\n', '    function initialize(Registry _registry) external initializer {\n', '        registry = _registry;\n', '    }\n', '\n', '    event ShareBurnedWithId(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens,\n', '        uint256 nonce\n', '    );\n', '\n', '    function logShareBurnedWithId(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens,\n', '        uint256 nonce\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);\n', '    }\n', '\n', '    event DelegatorUnstakeWithId(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 nonce\n', '    );\n', '\n', '    function logDelegatorUnstakedWithId(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 nonce\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);\n', '    }\n', '\n', '    event RewardParams(\n', '        uint256 rewardDecreasePerCheckpoint,\n', '        uint256 maxRewardedCheckpoints,\n', '        uint256 checkpointRewardDelta\n', '    );\n', '\n', '    function logRewardParams(\n', '        uint256 rewardDecreasePerCheckpoint,\n', '        uint256 maxRewardedCheckpoints,\n', '        uint256 checkpointRewardDelta\n', '    ) public onlyStakeManager {\n', '        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);\n', '    }\n', '\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyStakeManager {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/OwnableLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract OwnableLockable is Lockable, Ownable {\n', '    function lock() public onlyOwner {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyOwner {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/IValidatorShare.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '// note this contract interface is only for stakeManager use\n', 'contract IValidatorShare {\n', '    function withdrawRewards() public;\n', '\n', '    function unstakeClaimTokens() public;\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256);\n', '    \n', '    function owner() public view returns (address);\n', '\n', '    function restake() public returns(uint256, uint256);\n', '\n', '    function unlock() external;\n', '\n', '    function lock() external;\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);\n', '\n', '    function updateDelegation(bool delegation) external;\n', '\n', '    function migrateOut(address user, uint256 amount) external;\n', '\n', '    function migrateIn(address user, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShare.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {\n', '    struct DelegatorUnbond {\n', '        uint256 shares;\n', '        uint256 withdrawEpoch;\n', '    }\n', '\n', '    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n', '    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\n', '    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;\n', '    uint256 constant MAX_COMMISION_RATE = 100;\n', '    uint256 constant REWARD_PRECISION = 10**25;\n', '\n', '    StakingInfo public stakingLogger;\n', '    IStakeManager public stakeManager;\n', '    uint256 public validatorId;\n', '    uint256 public validatorRewards_deprecated;\n', '    uint256 public commissionRate_deprecated;\n', '    uint256 public lastCommissionUpdate_deprecated;\n', '    uint256 public minAmount;\n', '\n', '    uint256 public totalStake_deprecated;\n', '    uint256 public rewardPerShare;\n', '    uint256 public activeAmount;\n', '\n', '    bool public delegation;\n', '\n', '    uint256 public withdrawPool;\n', '    uint256 public withdrawShares;\n', '\n', '    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators\n', '    mapping(address => DelegatorUnbond) public unbonds;\n', '    mapping(address => uint256) public initalRewardPerShare;\n', '\n', '    mapping(address => uint256) public unbondNonces;\n', '    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;\n', '\n', '    EventsHub public eventsHub;\n', '\n', "    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\n", '    function initialize(\n', '        uint256 _validatorId,\n', '        address _stakingLogger,\n', '        address _stakeManager\n', '    ) external initializer {\n', '        validatorId = _validatorId;\n', '        stakingLogger = StakingInfo(_stakingLogger);\n', '        stakeManager = IStakeManager(_stakeManager);\n', '        _transferOwnership(_stakeManager);\n', '        _getOrCacheEventsHub();\n', '\n', '        minAmount = 10**18;\n', '        delegation = true;\n', '    }\n', '\n', '    /**\n', '        Public View Methods\n', '    */\n', '\n', '    function exchangeRate() public view returns (uint256) {\n', '        uint256 totalShares = totalSupply();\n', '        uint256 precision = _getRatePrecision();\n', '        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);\n', '    }\n', '\n', '    function getTotalStake(address user) public view returns (uint256, uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        uint256 rate = exchangeRate();\n', '        if (shares == 0) {\n', '            return (0, rate);\n', '        }\n', '\n', '        return (rate.mul(shares).div(_getRatePrecision()), rate);\n', '    }\n', '\n', '    function withdrawExchangeRate() public view returns (uint256) {\n', '        uint256 precision = _getRatePrecision();\n', '        if (validatorId < 8) {\n', '            // fix of potentially broken withdrawals for future unbonding\n', '            // foundation validators have no slashing enabled and thus we can return default exchange rate\n', '            // because without slashing rate will stay constant\n', '            return precision;\n', '        }\n', '\n', '        uint256 _withdrawShares = withdrawShares;\n', '        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);\n', '    }\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256) {\n', '        return _calculateReward(user, getRewardPerShare());\n', '    }\n', '\n', '    function getRewardPerShare() public view returns (uint256) {\n', '        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));\n', '    }\n', '\n', '    /**\n', '        Public Methods\n', '     */\n', '\n', '    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {\n', '        _withdrawAndTransferReward(msg.sender);\n', '        \n', '        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\n', '        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");\n', '        \n', '        return amountToDeposit;\n', '    }\n', '\n', '    function restake() public returns(uint256, uint256) {\n', '        address user = msg.sender;\n', '        uint256 liquidReward = _withdrawReward(user);\n', '        uint256 amountRestaked;\n', '\n', '        require(liquidReward >= minAmount, "Too small rewards to restake");\n', '\n', '        if (liquidReward != 0) {\n', '            amountRestaked = _buyShares(liquidReward, 0, user);\n', '\n', '            if (liquidReward > amountRestaked) {\n', '                // return change to the user\n', '                require(\n', '                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),\n', '                    "Insufficent rewards"\n', '                );\n', '                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);\n', '            }\n', '\n', '            (uint256 totalStaked, ) = getTotalStake(user);\n', '            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);\n', '        }\n', '        \n', '        return (amountRestaked, liquidReward);\n', '    }\n', '\n', '    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\n', '\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        unbond.shares = unbond.shares.add(_withdrawPoolShare);\n', '        // refresh undond period\n', '        unbond.withdrawEpoch = stakeManager.epoch();\n', '        unbonds[msg.sender] = unbond;\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function withdrawRewards() public {\n', '        uint256 rewards = _withdrawAndTransferReward(msg.sender);\n', '        require(rewards >= minAmount, "Too small rewards amount");\n', '    }\n', '\n', '    function migrateOut(address user, uint256 amount) external onlyOwner {\n', '        _withdrawAndTransferReward(user);\n', '        (uint256 totalStaked, uint256 rate) = getTotalStake(user);\n', '        require(totalStaked >= amount, "Migrating too much");\n', '\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = amount.mul(precision).div(rate);\n', '        _burn(user, shares);\n', '\n', '        stakeManager.updateValidatorState(validatorId, -int256(amount));\n', '        activeAmount = activeAmount.sub(amount);\n', '\n', '        stakingLogger.logShareBurned(validatorId, user, amount, shares);\n', '        stakingLogger.logStakeUpdate(validatorId);\n', '        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    function migrateIn(address user, uint256 amount) external onlyOwner {\n', '        _withdrawAndTransferReward(user);\n', '        _buyShares(amount, 0, user);\n', '    }\n', '\n', '    function unstakeClaimTokens() public {\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        uint256 amount = _unstakeClaimTokens(unbond);\n', '        delete unbonds[msg.sender];\n', '        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);\n', '    }\n', '\n', '    function slash(\n', '        uint256 validatorStake,\n', '        uint256 delegatedAmount,\n', '        uint256 totalAmountToSlash\n', '    ) external onlyOwner returns (uint256) {\n', '        uint256 _withdrawPool = withdrawPool;\n', '        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);\n', '        if (delegationAmount == 0) {\n', '            return 0;\n', '        }\n', '        // total amount to be slashed from delegation pool (active + inactive)\n', '        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));\n', '        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\n', '\n', '        // slash inactive pool\n', '        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);\n', '        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);\n', '        activeAmount = activeAmount.sub(stakeSlashed);\n', '\n', '        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);\n', '        return _amountToSlash;\n', '    }\n', '\n', '    function updateDelegation(bool _delegation) external onlyOwner {\n', '        delegation = _delegation;\n', '    }\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external onlyOwner {\n', '        if (token == address(0x0)) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(ERC20(token).transfer(destination, amount), "Drain failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '        New shares exit API\n', '     */\n', '\n', '    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\n', '\n', '        uint256 unbondNonce = unbondNonces[msg.sender].add(1);\n', '\n', '        DelegatorUnbond memory unbond = DelegatorUnbond({\n', '            shares: _withdrawPoolShare,\n', '            withdrawEpoch: stakeManager.epoch()\n', '        });\n', '        unbonds_new[msg.sender][unbondNonce] = unbond;\n', '        unbondNonces[msg.sender] = unbondNonce;\n', '\n', '        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);\n', '        stakingLogger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function unstakeClaimTokens_new(uint256 unbondNonce) public {\n', '        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];\n', '        uint256 amount = _unstakeClaimTokens(unbond);\n', '        delete unbonds_new[msg.sender][unbondNonce];\n', '        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);\n', '    }\n', '\n', '    /**\n', '        Private Methods\n', '     */\n', '\n', '    function _getOrCacheEventsHub() private returns(EventsHub) {\n', '        EventsHub _eventsHub = eventsHub;\n', '        if (_eventsHub == EventsHub(0x0)) {\n', '            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256("eventsHub")));\n', '            eventsHub = _eventsHub;\n', '        }\n', '        return _eventsHub;\n', '    }\n', '\n', '    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {\n', '        // first get how much staked in total and compare to target unstake amount\n', '        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);\n', '        require(totalStaked != 0 && totalStaked >= claimAmount, "Too much requested");\n', '\n', '        // convert requested amount back to shares\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = claimAmount.mul(precision).div(rate);\n', '        require(shares <= maximumSharesToBurn, "too much slippage");\n', '\n', '        _withdrawAndTransferReward(msg.sender);\n', '\n', '        _burn(msg.sender, shares);\n', '        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\n', '        activeAmount = activeAmount.sub(claimAmount);\n', '\n', '        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\n', '        withdrawPool = withdrawPool.add(claimAmount);\n', '        withdrawShares = withdrawShares.add(_withdrawPoolShare);\n', '\n', '        return (shares, _withdrawPoolShare);\n', '    }\n', '\n', '    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {\n', '        uint256 shares = unbond.shares;\n', '        require(\n', '            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\n', '            "Incomplete withdrawal period"\n', '        );\n', '\n', '        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\n', '        withdrawShares = withdrawShares.sub(shares);\n', '        withdrawPool = withdrawPool.sub(_amount);\n', '\n', '        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _getRatePrecision() private view returns (uint256) {\n', '        // if foundation validator, use old precision\n', '        if (validatorId < 8) {\n', '            return EXCHANGE_RATE_PRECISION;\n', '        }\n', '\n', '        return EXCHANGE_RATE_HIGH_PRECISION;\n', '    }\n', '\n', '    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {\n', '        uint256 _rewardPerShare = rewardPerShare;\n', '        if (accumulatedReward != 0) {\n', '            uint256 totalShares = totalSupply();\n', '            \n', '            if (totalShares != 0) {\n', '                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));\n', '            }\n', '        }\n', '\n', '        return _rewardPerShare;\n', '    }\n', '\n', '    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        if (shares == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _initialRewardPerShare = initalRewardPerShare[user];\n', '\n', '        if (_initialRewardPerShare == _rewardPerShare) {\n', '            return 0;\n', '        }\n', '\n', '        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);\n', '    }\n', '\n', '    function _withdrawReward(address user) private returns (uint256) {\n', '        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(\n', '            stakeManager.withdrawDelegatorsReward(validatorId)\n', '        );\n', '        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);\n', '        \n', '        rewardPerShare = _rewardPerShare;\n', '        initalRewardPerShare[user] = _rewardPerShare;\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _withdrawAndTransferReward(address user) private returns (uint256) {\n', '        uint256 liquidRewards = _withdrawReward(user);\n', '        if (liquidRewards != 0) {\n', '            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\n', '        }\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _buyShares(\n', '        uint256 _amount,\n', '        uint256 _minSharesToMint,\n', '        address user\n', '    ) private onlyWhenUnlocked returns (uint256) {\n', '        require(delegation, "Delegation is disabled");\n', '\n', '        uint256 rate = exchangeRate();\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = _amount.mul(precision).div(rate);\n', '        require(shares >= _minSharesToMint, "Too much slippage");\n', '        require(unbonds[user].shares == 0, "Ongoing exit");\n', '\n', '        _mint(user, shares);\n', '\n', '        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\n', '        _amount = rate.mul(shares).div(precision);\n', '\n', '        stakeManager.updateValidatorState(validatorId, int256(_amount));\n', '        activeAmount = activeAmount.add(_amount);\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareMinted(validatorId, user, _amount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        // get rewards for recipient \n', '        _withdrawAndTransferReward(to);\n', '        // convert rewards to shares\n', '        _withdrawAndTransferReward(from);\n', '        // move shares to recipient\n', '        super._transfer(from, to, value);\n', '    }\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShareFactory.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract ValidatorShareFactory {\n', '    /**\n', '    - factory to create new validatorShare contracts\n', '   */\n', '    function create(uint256 validatorId, address loggerAddress, address registry) public returns (address) {\n', '        ValidatorShareProxy proxy = new ValidatorShareProxy(registry);\n', '\n', '        proxy.transferOwnership(msg.sender);\n', '\n', '        address proxyAddr = address(proxy);\n', '        (bool success, bytes memory data) = proxyAddr.call.gas(gasleft())(\n', '            abi.encodeWithSelector(\n', '                ValidatorShare(proxyAddr).initialize.selector, \n', '                validatorId, \n', '                loggerAddress, \n', '                msg.sender\n', '            )\n', '        );\n', '        require(success, string(data));\n', '\n', '        return proxyAddr;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakeManagerStorage.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StakeManagerStorage is GovernanceLockable, RootChainable {\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '\n', '    struct Auction {\n', '        uint256 amount;\n', '        uint256 startEpoch;\n', '        address user;\n', '        bool acceptDelegation;\n', '        bytes signerPubkey;\n', '    }\n', '\n', '    struct State {\n', '        uint256 amount;\n', '        uint256 stakerCount;\n', '    }\n', '\n', '    struct StateChange {\n', '        int256 amount;\n', '        int256 stakerCount;\n', '    }\n', '\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '        uint256 commissionRate;\n', '        uint256 lastCommissionUpdate;\n', '        uint256 delegatorsReward;\n', '        uint256 delegatedAmount;\n', '        uint256 initialRewardPerStake;\n', '    }\n', '\n', '    uint256 constant MAX_COMMISION_RATE = 100;\n', '    uint256 constant MAX_PROPOSER_BONUS = 100;\n', '    uint256 constant REWARD_PRECISION = 10**25;\n', '    uint256 internal constant INCORRECT_VALIDATOR_ID = 2**256 - 1;\n', '    uint256 internal constant INITIALIZED_AMOUNT = 1;\n', '\n', '    IERC20 public token;\n', '    address public registry;\n', '    StakingInfo public logger;\n', '    StakingNFT public NFTContract;\n', '    ValidatorShareFactory public validatorShareFactory;\n', '    uint256 public WITHDRAWAL_DELAY; // unit: epoch\n', '    uint256 public currentEpoch;\n', '\n', '    // genesis/governance variables\n', '    uint256 public dynasty; // unit: epoch 50 days\n', '    uint256 public CHECKPOINT_REWARD; // update via governance\n', '    uint256 public minDeposit; // in ERC20 token\n', '    uint256 public minHeimdallFee; // in ERC20 token\n', '    uint256 public checkPointBlockInterval;\n', '    uint256 public signerUpdateLimit;\n', '\n', '    uint256 public validatorThreshold; //128\n', '    uint256 public totalStaked;\n', '    uint256 public NFTCounter;\n', '    uint256 public totalRewards;\n', '    uint256 public totalRewardsLiquidated;\n', '    uint256 public auctionPeriod; // 1 week in epochs\n', '    uint256 public proposerBonus; // 10 % of total rewards\n', '    bytes32 public accountStateRoot;\n', '    // Stop validator auction for some time when updating dynasty value\n', '    uint256 public replacementCoolDown;\n', '    bool public delegationEnabled;\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    mapping(address => uint256) public signerToValidator;\n', '    // current epoch stake power and stakers count\n', '    State public validatorState;\n', '    mapping(uint256 => StateChange) public validatorStateChanges;\n', '\n', '    mapping(address => uint256) public userFeeExit;\n', '    //Ongoing auctions for validatorId\n', '    mapping(uint256 => Auction) public validatorAuction;\n', '    // validatorId to last signer update epoch\n', '    mapping(uint256 => uint256) public latestSignerUpdateEpoch;\n', '\n', '    uint256 public totalHeimdallFee;\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakeManagerStorageExtension.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract StakeManagerStorageExtension {\n', '    address public eventsHub;\n', '    uint256 public rewardPerStake;\n', '    address public extensionCode;\n', '    address[] public signers;\n', '\n', '    uint256 constant CHK_REWARD_PRECISION = 100;\n', '    uint256 public prevBlockInterval;\n', '    // how much less reward per skipped checkpoint, 0 - 100%\n', '    uint256 public rewardDecreasePerCheckpoint;\n', '    // how many checkpoints to reward\n', '    uint256 public maxRewardedCheckpoints;\n', '    // increase / decrease value for faster or slower checkpoints, 0 - 100%\n', '    uint256 public checkpointRewardDelta;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/Math.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Math\n', ' * @dev Assorted math operations\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the average of two numbers. Since these are integers,\n', '     * averages of an even and odd number cannot be represented, and will be\n', '     * rounded down.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/StakeManagerExtension.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract StakeManagerExtension is StakeManagerStorage, Initializable, StakeManagerStorageExtension {\n', '    using SafeMath for uint256;\n', '\n', '    constructor() public GovernanceLockable(address(0x0)) {}\n', '\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool _acceptDelegation,\n', '        bytes calldata _signerPubkey\n', '    ) external {\n', '        uint256 currentValidatorAmount = validators[validatorId].amount;\n', '\n', '        require(\n', '            validators[validatorId].deactivationEpoch == 0 && currentValidatorAmount != 0,\n', '            "Invalid validator for an auction"\n', '        );\n', '        uint256 senderValidatorId = signerToValidator[msg.sender];\n', "        // make sure that signer wasn't used already\n", '        require(\n', "            NFTContract.balanceOf(msg.sender) == 0 && // existing validators can't bid\n", '                senderValidatorId != INCORRECT_VALIDATOR_ID,\n', '            "Already used address"\n', '        );\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        uint256 _replacementCoolDown = replacementCoolDown;\n', '        // when dynasty period is updated validators are in cooldown period\n', '        require(_replacementCoolDown == 0 || _replacementCoolDown <= _currentEpoch, "Cooldown period");\n', '        // (auctionPeriod--dynasty)--(auctionPeriod--dynasty)--(auctionPeriod--dynasty)\n', "        // if it's auctionPeriod then will get residue smaller then auctionPeriod\n", '        // from (CurrentPeriod of validator )%(auctionPeriod--dynasty)\n', '        // make sure that its `auctionPeriod` window\n', '        // dynasty = 30, auctionPeriod = 7, activationEpoch = 1, currentEpoch = 39\n', "        // residue 1 = (39-1)% (7+30), if residue <= auctionPeriod it's `auctionPeriod`\n", '\n', '        require(\n', '            (_currentEpoch.sub(validators[validatorId].activationEpoch) % dynasty.add(auctionPeriod)) < auctionPeriod,\n', '            "Invalid auction period"\n', '        );\n', '\n', '        uint256 perceivedStake = currentValidatorAmount;\n', '        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);\n', '\n', '        Auction storage auction = validatorAuction[validatorId];\n', '        uint256 currentAuctionAmount = auction.amount;\n', '\n', '        perceivedStake = Math.max(perceivedStake, currentAuctionAmount);\n', '\n', '        require(perceivedStake < amount, "Must bid higher");\n', '        require(token.transferFrom(msg.sender, address(this), amount), "Transfer failed");\n', '\n', '        //replace prev auction\n', '        if (currentAuctionAmount != 0) {\n', '            require(token.transfer(auction.user, currentAuctionAmount), "Bid return failed");\n', '        }\n', '\n', '        // create new auction\n', '        auction.amount = amount;\n', '        auction.user = msg.sender;\n', '        auction.acceptDelegation = _acceptDelegation;\n', '        auction.signerPubkey = _signerPubkey;\n', '\n', '        logger.logStartAuction(validatorId, currentValidatorAmount, amount);\n', '    }\n', '\n', '    function confirmAuctionBid(\n', '        uint256 validatorId,\n', '        uint256 heimdallFee, /** for new validator */\n', '        IStakeManager stakeManager\n', '    ) external {\n', '        Auction storage auction = validatorAuction[validatorId];\n', '        address auctionUser = auction.user;\n', '\n', '        require(\n', '            msg.sender == auctionUser || NFTContract.tokenOfOwnerByIndex(msg.sender, 0) == validatorId,\n', '            "Only bidder can confirm"\n', '        );\n', '\n', '        uint256 _currentEpoch = currentEpoch;\n', '        require(\n', '            _currentEpoch.sub(auction.startEpoch) % auctionPeriod.add(dynasty) >= auctionPeriod,\n', '            "Not allowed before auctionPeriod"\n', '        );\n', '        require(auction.user != address(0x0), "Invalid auction");\n', '\n', '        uint256 validatorAmount = validators[validatorId].amount;\n', '        uint256 perceivedStake = validatorAmount;\n', '        uint256 auctionAmount = auction.amount;\n', '\n', '        perceivedStake = perceivedStake.add(validators[validatorId].delegatedAmount);\n', '\n', '        // validator is last auctioner\n', '        if (perceivedStake >= auctionAmount && validators[validatorId].deactivationEpoch == 0) {\n', '            require(token.transfer(auctionUser, auctionAmount), "Bid return failed");\n', '            //cleanup auction data\n', '            auction.startEpoch = _currentEpoch;\n', '            logger.logConfirmAuction(validatorId, validatorId, validatorAmount);\n', '        } else {\n', '            stakeManager.dethroneAndStake(\n', '                auctionUser, \n', '                heimdallFee,\n', '                validatorId,\n', '                auctionAmount,\n', '                auction.acceptDelegation,\n', '                auction.signerPubkey\n', '            );\n', '        }\n', '        uint256 startEpoch = auction.startEpoch;\n', '        delete validatorAuction[validatorId];\n', '        validatorAuction[validatorId].startEpoch = startEpoch;\n', '    }\n', '\n', '    function migrateValidatorsData(uint256 validatorIdFrom, uint256 validatorIdTo) external {       \n', '        for (uint256 i = validatorIdFrom; i < validatorIdTo; ++i) {\n', '            ValidatorShare contractAddress = ValidatorShare(validators[i].contractAddress);\n', '            if (contractAddress != ValidatorShare(0)) {\n', '                // move validator rewards out from ValidatorShare contract\n', '                validators[i].reward = contractAddress.validatorRewards_deprecated().add(INITIALIZED_AMOUNT);\n', '                validators[i].delegatedAmount = contractAddress.activeAmount();\n', '                validators[i].commissionRate = contractAddress.commissionRate_deprecated();\n', '            } else {\n', '                validators[i].reward = validators[i].reward.add(INITIALIZED_AMOUNT);\n', '            }\n', '\n', '            validators[i].delegatorsReward = INITIALIZED_AMOUNT;\n', '        }\n', '    }\n', '\n', '    function updateCheckpointRewardParams(\n', '        uint256 _rewardDecreasePerCheckpoint,\n', '        uint256 _maxRewardedCheckpoints,\n', '        uint256 _checkpointRewardDelta\n', '    ) external {\n', '        require(_maxRewardedCheckpoints.mul(_rewardDecreasePerCheckpoint) <= CHK_REWARD_PRECISION);\n', '        require(_checkpointRewardDelta <= CHK_REWARD_PRECISION);\n', '\n', '        rewardDecreasePerCheckpoint = _rewardDecreasePerCheckpoint;\n', '        maxRewardedCheckpoints = _maxRewardedCheckpoints;\n', '        checkpointRewardDelta = _checkpointRewardDelta;\n', '\n', '        _getOrCacheEventsHub().logRewardParams(_rewardDecreasePerCheckpoint, _maxRewardedCheckpoints, _checkpointRewardDelta);\n', '    }\n', '\n', '    function updateCommissionRate(uint256 validatorId, uint256 newCommissionRate) external {\n', '        uint256 _epoch = currentEpoch;\n', '        uint256 _lastCommissionUpdate = validators[validatorId].lastCommissionUpdate;\n', '\n', '        require( // withdrawalDelay == dynasty\n', '            (_lastCommissionUpdate.add(WITHDRAWAL_DELAY) <= _epoch) || _lastCommissionUpdate == 0, // For initial setting of commission rate\n', '            "Cooldown"\n', '        );\n', '\n', '        require(newCommissionRate <= MAX_COMMISION_RATE, "Incorrect value");\n', '        _getOrCacheEventsHub().logUpdateCommissionRate(validatorId, newCommissionRate, validators[validatorId].commissionRate);\n', '        validators[validatorId].commissionRate = newCommissionRate;\n', '        validators[validatorId].lastCommissionUpdate = _epoch;\n', '    }\n', '\n', '    function _getOrCacheEventsHub() private returns(EventsHub) {\n', '        EventsHub _eventsHub = EventsHub(eventsHub);\n', '        if (_eventsHub == EventsHub(0x0)) {\n', '            _eventsHub = EventsHub(Registry(registry).contractMap(keccak256("eventsHub")));\n', '            eventsHub = address(_eventsHub);\n', '        }\n', '        return _eventsHub;\n', '    }\n', '}']