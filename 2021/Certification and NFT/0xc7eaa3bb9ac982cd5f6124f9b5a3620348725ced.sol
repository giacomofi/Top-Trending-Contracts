['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/*\n', '  ___                      _   _\n', ' | _ )_  _ _ _  _ _ _  _  | | | |\n', " | _ \\ || | ' \\| ' \\ || | |_| |_|\n", ' |___/\\_,_|_||_|_||_\\_, | (_) (_)\n', '                    |__/\n', '\n', '*\n', '* MIT License\n', '* ===========\n', '*\n', '* Copyright (c) 2020 BunnyFinance\n', '*\n', '* Permission is hereby granted, free of charge, to any person obtaining a copy\n', '* of this software and associated documentation files (the "Software"), to deal\n', '* in the Software without restriction, including without limitation the rights\n', '* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n', '* copies of the Software, and to permit persons to whom the Software is\n', '* furnished to do so, subject to the following conditions:\n', '*\n', '* The above copyright notice and this permission notice shall be included in all\n', '* copies or substantial portions of the Software.\n', '*\n', '* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '*/\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Math.sol";\n', 'import "./OwnableUpgradeable.sol";\n', '\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./ICVaultETHLP.sol";\n', 'import "./ICVaultRelayer.sol";\n', 'import "./IZap.sol";\n', 'import "./Whitelist.sol";\n', 'import "./CVaultETHLPState.sol";\n', 'import "./CVaultETHLPStorage.sol";\n', '\n', '\n', 'contract CVaultETHLP is ICVaultETHLP, CVaultETHLPStorage, Whitelist {\n', '    using SafeMath for uint;\n', '    using SafeERC20 for IERC20;\n', '\n', '    uint8 private constant SIG_DEPOSIT = 10;\n', '    uint8 private constant SIG_LEVERAGE = 20;\n', '    uint8 private constant SIG_WITHDRAW = 30;\n', '    uint8 private constant SIG_LIQUIDATE = 40;\n', '    uint8 private constant SIG_EMERGENCY = 50;\n', '    uint8 private constant SIG_CLEAR = 63;          // only owner can execute if state is idle but the BSC position remains.\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    IZap public zap;\n', '    address public treasury;\n', '\n', '    uint public relayerCost;\n', '    uint public minimumDepositValue;\n', '    uint public liquidationCollateralRatio;\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    // Relay Request Events\n', '    event DepositRequested(address indexed lp, address indexed account, uint indexed eventId, uint lpAmount, uint leverage);\n', '    event UpdateLeverageRequested(address indexed lp, address indexed account, uint indexed eventId, uint leverage, uint collateral);\n', '    event WithdrawRequested(address indexed lp, address indexed account, uint indexed eventId, uint lpAmount);\n', '    event WithdrawAllRequested(address indexed lp, address indexed account, uint indexed eventId);\n', '    event LiquidateRequested(address indexed lp, address indexed account, uint indexed eventId, uint lpAmount, address liquidator);\n', '    event EmergencyExitRequested(address indexed lp, address indexed account, uint indexed eventId, uint lpAmount);\n', '\n', '    // Impossible Situation: only owner can execute if state is idle but the BSC position remains.\n', '    event ClearBSCState(address indexed lp, address indexed account, uint indexed eventId);\n', '\n', '    // Relay Response Events\n', '    event NotifyDeposited(address indexed lp, address indexed account, uint indexed eventId, uint bscBNBDebtShare, uint bscFlipBalance);\n', '    event NotifyUpdatedLeverage(address indexed lp, address indexed account, uint indexed eventId, uint bscBNBDebtShare, uint bscFlipBalance);\n', '    event NotifyWithdrawnAll(address indexed lp, address indexed account, uint indexed eventId, uint lpAmount, uint ethProfit, uint ethLoss);\n', '    event NotifyLiquidated(address indexed lp, address indexed account, uint indexed eventId, uint ethProfit, uint ethLoss, uint penaltyLPAmount, address liquidator);\n', '    event NotifyResolvedEmergency(address indexed lp, address indexed account, uint indexed eventId);\n', '\n', '    // User Events\n', '    event CollateralAdded(address indexed lp, address indexed account, uint lpAmount);\n', '    event CollateralRemoved(address indexed lp, address indexed account, uint lpAmount);\n', '    event UnpaidProfitClaimed(address indexed account, uint ethValue);\n', '    event LossRealized(address indexed lp, address indexed account, uint indexed eventId, uint soldLPAmount, uint ethValue);\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier onlyCVaultRelayer() {\n', '        require(address(relayer) != address(0) && msg.sender == address(relayer), "CVaultETHLP: caller is not the relayer");\n', '        _;\n', '    }\n', '\n', '    modifier canRemoveCollateral(address lp, address _account, uint amount) {\n', '        Account memory account = accountOf(lp, msg.sender);\n', '        uint ratio = relayer.collateralRatioOnETH(lp, account.collateral.sub(amount), bscFlipOf(lp), account.bscFlipBalance, account.bscBNBDebt);\n', '        require(ratio >= COLLATERAL_RATIO_MIN, "CVaultETHLP: can withdraw only up to 180% of the collateral ratio");\n', '        _;\n', '    }\n', '\n', '    modifier hasEnoughBalance(uint value) {\n', '        require(address(this).balance >= value, "CVaultETHLP: not enough balance, please try after UTC 00:00");\n', '        _;\n', '    }\n', '\n', '    modifier costs {\n', '        uint txFee = relayerCost;\n', '        require(msg.value >= txFee, "CVaultETHLP: Not enough ether provided");\n', '        _;\n', '        if (msg.value > txFee) {\n', '            msg.sender.transfer(msg.value.sub(txFee));\n', '        }\n', '    }\n', '\n', '    /* ========== INITIALIZER ========== */\n', '\n', '    function initialize() external initializer {\n', '        __CVaultETHLPStorage_init();\n', '        __Whitelist_init();\n', '\n', '        relayerCost = 0.015 ether;\n', '        minimumDepositValue = 100e18;\n', '        liquidationCollateralRatio = 125e16;        // 125% == debt ratio 80%\n', '    }\n', '\n', '    /* ========== RESTRICTED FUNCTIONS ========== */\n', '\n', '    function setZap(address newZap) external onlyOwner {\n', '        zap = IZap(newZap);\n', '    }\n', '\n', '    function setPool(address lp, address bscFlip) external onlyOwner {\n', '        _setPool(lp, bscFlip);\n', '        IERC20(lp).safeApprove(address(zap), uint(- 1));\n', '    }\n', '\n', '    function recoverToken(address token, uint amount) external onlyOwner {\n', '        require(bscFlipOf(token) == address(0), "CVaultETHLP: lp token can\'t be recovered");\n', '        IERC20(token).safeTransfer(owner(), amount);\n', '    }\n', '\n', '    function setTreasury(address newTreasury) external onlyOwner {\n', '        require(newTreasury != address(0), "CVaultETHLP: invalid treasury address");\n', '        treasury = newTreasury;\n', '    }\n', '\n', '    function setRelayerCost(uint newValue) external onlyOwner {\n', '        relayerCost = newValue;\n', '    }\n', '\n', '    function setMinimumDepositValue(uint newValue) external onlyOwner {\n', '        require(newValue > 0, "CVaultETHLP: minimum deposit value is zero");\n', '        minimumDepositValue = newValue;\n', '    }\n', '\n', '    function updateLiquidationCollateralRatio(uint newCollateralRatio) external onlyOwner {\n', '        require(newCollateralRatio < COLLATERAL_RATIO_MIN, "CVaultETHLP: liquidation collateral ratio must be lower than COLLATERAL_RATIO_MIN");\n', '        liquidationCollateralRatio = newCollateralRatio;\n', '    }\n', '\n', '    function clearBSCState(address lp, address _account) external onlyOwner {\n', '        require(stateOf(lp, _account) == State.Idle, "CVaultETHLP: account should be idle state");\n', '\n', '        uint eventId = relayer.requestRelayOnETH(lp, _account, SIG_CLEAR, 0, 0, 0);\n', '        emit ClearBSCState(lp, _account, eventId);\n', '    }\n', '\n', '    /* ========== VIEW FUNCTIONS ========== */\n', '\n', '    function validateRequest(uint8 signature, address _lp, address _account, uint128 _leverage, uint _collateral) external override view returns (uint8 validation, uint112 nonce) {\n', '        Account memory account = accountOf(_lp, _account);\n', '        bool isValid = false;\n', '        if (signature == SIG_DEPOSIT) {\n', '            isValid =\n', '            account.state == State.Depositing\n', '            && account.collateral > 0\n', '            && account.collateral == _collateral\n', '            && account.leverage == _leverage\n', '            && account.updatedAt + EMERGENCY_EXIT_TIMELOCK - 10 minutes > block.timestamp;\n', '        }\n', '        else if (signature == SIG_LEVERAGE) {\n', '            isValid =\n', '            account.state == State.UpdatingLeverage\n', '            && account.collateral > 0\n', '            && account.collateral == _collateral\n', '            && account.leverage == _leverage\n', '            && account.updatedAt + EMERGENCY_EXIT_TIMELOCK - 10 minutes > block.timestamp;\n', '        }\n', '        else if (signature == SIG_WITHDRAW) {\n', '            isValid =\n', '            account.state == State.Withdrawing\n', '            && account.collateral > 0\n', '            && account.leverage == 0\n', '            && account.updatedAt + EMERGENCY_EXIT_TIMELOCK - 10 minutes > block.timestamp;\n', '        }\n', '        else if (signature == SIG_EMERGENCY) {\n', '            isValid =\n', '            account.state == State.EmergencyExited\n', '            && account.collateral == 0\n', '            && account.leverage == 0;\n', '        }\n', '        else if (signature == SIG_LIQUIDATE) {\n', '            isValid =\n', '            account.state == State.Liquidating\n', '            && account.liquidator != address(0);\n', '        }\n', '        else if (signature == SIG_CLEAR) {\n', '            isValid = account.state == State.Idle && account.collateral == 0;\n', '        }\n', '\n', '        validation = isValid ? uint8(1) : uint8(0);\n', '        nonce = account.nonce;\n', '    }\n', '\n', '    function canLiquidate(address lp, address _account) public override view returns (bool) {\n', '        Account memory account = accountOf(lp, _account);\n', '        return account.state == State.Farming && collateralRatioOf(lp, _account) < liquidationCollateralRatio;\n', '    }\n', '\n', '    function collateralRatioOf(address lp, address _account) public view returns (uint) {\n', '        Account memory account = accountOf(lp, _account);\n', '        return relayer.collateralRatioOnETH(lp, account.collateral, bscFlipOf(lp), account.bscFlipBalance, account.bscBNBDebt);\n', '    }\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    function deposit(address lp, uint amount, uint128 leverage) external notPaused notPausedPool(lp) validLeverage(leverage) onlyWhitelisted payable costs {\n', '        require(relayer.isUtilizable(lp, amount, leverage), "CVaultETHLP: not enough balance to loan in the bank");\n', '        require(relayer.valueOfAsset(lp, amount) >= minimumDepositValue, "CVaultETHLP: less than minimum deposit");\n', '\n', '        convertState(lp, msg.sender, State.Depositing);\n', '\n', '        uint collateral = _addCollateral(lp, msg.sender, amount);\n', '        setLeverage(lp, msg.sender, leverage);\n', '\n', '        uint eventId = relayer.requestRelayOnETH(lp, msg.sender, SIG_DEPOSIT, leverage, collateral, amount);\n', '        emit DepositRequested(lp, msg.sender, eventId, amount, leverage);\n', '    }\n', '\n', '    function updateLeverage(address lp, uint128 leverage) external notPaused notPausedPool(lp) validLeverage(leverage) payable costs {\n', '        convertState(lp, msg.sender, State.UpdatingLeverage);\n', '        Account memory account = accountOf(lp, msg.sender);\n', '        uint leverageDiff = Math.max(account.leverage, leverage).sub(Math.min(account.leverage, leverage));\n', '\n', '        setLeverage(lp, msg.sender, leverage);\n', '\n', '        uint eventId = relayer.requestRelayOnETH(lp, msg.sender, SIG_LEVERAGE, leverage, account.collateral, account.collateral.mul(leverageDiff).div(UNIT));\n', '        emit UpdateLeverageRequested(lp, msg.sender, eventId, leverage, accountOf(lp, msg.sender).collateral);\n', '    }\n', '\n', '    function withdraw(address lp, uint amount) external payable costs {\n', '        convertState(lp, msg.sender, State.UpdatingLeverage);\n', '\n', '        Account memory account = accountOf(lp, msg.sender);\n', '        uint targetCollateral = account.collateral.sub(amount);\n', '        uint leverage = uint(account.leverage).mul(targetCollateral).div(account.collateral);\n', '        require(LEVERAGE_MIN <= leverage && leverage <= LEVERAGE_MAX, "CVaultETHLP: leverage range should be [10%-150%]");\n', '\n', '        setLeverage(lp, msg.sender, uint128(leverage));\n', '        setWithdrawalRequestAmount(lp, msg.sender, amount);\n', '\n', '        uint eventId = relayer.requestRelayOnETH(lp, msg.sender, SIG_LEVERAGE, uint128(leverage), account.collateral, amount);\n', '        emit UpdateLeverageRequested(lp, msg.sender, eventId, leverage, accountOf(lp, msg.sender).collateral);\n', '        emit WithdrawRequested(lp, msg.sender, eventId, amount);\n', '    }\n', '\n', '    function withdrawAll(address lp) external payable costs {\n', '        convertState(lp, msg.sender, State.Withdrawing);\n', '        setLeverage(lp, msg.sender, 0);\n', '\n', '        Account memory account = accountOf(lp, msg.sender);\n', '        uint eventId = relayer.requestRelayOnETH(lp, msg.sender, SIG_WITHDRAW, account.leverage, account.collateral, account.collateral);\n', '        emit WithdrawAllRequested(lp, msg.sender, eventId);\n', '    }\n', '\n', '    function claimUnpaidETH(uint value) external hasEnoughBalance(value) {\n', '        decreaseUnpaidETHValue(msg.sender, value);\n', '        payable(msg.sender).transfer(value);\n', '        emit UnpaidProfitClaimed(msg.sender, value);\n', '    }\n', '\n', '    function emergencyExit(address lp) external {\n', '        convertState(lp, msg.sender, State.EmergencyExited);\n', '        setLeverage(lp, msg.sender, 0);\n', '\n', '        Account memory account = accountOf(lp, msg.sender);\n', '        _removeCollateral(lp, msg.sender, account.collateral);\n', '\n', '        uint eventId = relayer.requestRelayOnETH(lp, msg.sender, SIG_EMERGENCY, 0, account.collateral, account.collateral);\n', '        emit EmergencyExitRequested(lp, msg.sender, eventId, account.collateral);\n', '    }\n', '\n', '    function addCollateral(address lp, uint amount) external onlyStateFarming(lp) {\n', '        _addCollateral(lp, msg.sender, amount);\n', '        emit CollateralAdded(lp, msg.sender, amount);\n', '    }\n', '\n', '    function removeCollateral(address lp, uint amount) external onlyStateFarming(lp) canRemoveCollateral(lp, msg.sender, amount) {\n', '        _removeCollateral(lp, msg.sender, amount);\n', '        emit CollateralRemoved(lp, msg.sender, amount);\n', '    }\n', '\n', '    function askLiquidation(address lp, address account) external payable costs {\n', '        relayer.askLiquidationFromCVaultETH(lp, account, msg.sender);\n', '    }\n', '\n', '    function executeLiquidation(address lp, address _account, address _liquidator) external override onlyCVaultRelayer {\n', '        if (!canLiquidate(lp, _account)) return;\n', '\n', '        setLiquidator(lp, _account, _liquidator);\n', '        convertState(lp, _account, State.Liquidating);\n', '\n', '        Account memory account = accountOf(lp, _account);\n', '        uint eventId = relayer.requestRelayOnETH(lp, _account, SIG_LIQUIDATE, account.leverage, account.collateral, account.collateral);\n', '        emit LiquidateRequested(lp, _account, eventId, account.collateral, _liquidator);\n', '    }\n', '\n', '    /* ========== RELAYER FUNCTIONS ========== */\n', '\n', '    function notifyDeposited(address lp, address _account, uint128 eventId, uint112 nonce, uint bscBNBDebt, uint bscFlipBalance) external override increaseNonceOnlyRelayers(lp, _account, nonce) {\n', '        _notifyDeposited(lp, _account, bscBNBDebt, bscFlipBalance);\n', '        emit NotifyDeposited(lp, _account, eventId, bscBNBDebt, bscFlipBalance);\n', '    }\n', '\n', '    function notifyUpdatedLeverage(address lp, address _account, uint128 eventId, uint112 nonce, uint bscBNBDebt, uint bscFlipBalance) external override increaseNonceOnlyRelayers(lp, _account, nonce) {\n', '        _notifyDeposited(lp, _account, bscBNBDebt, bscFlipBalance);\n', '        emit NotifyUpdatedLeverage(lp, _account, eventId, bscBNBDebt, bscFlipBalance);\n', '\n', '        uint withdrawalRequestAmount = accountOf(lp, _account).withdrawalRequestAmount;\n', '        if (withdrawalRequestAmount > 0) {\n', '            setWithdrawalRequestAmount(lp, _account, 0);\n', '            _removeCollateral(lp, _account, withdrawalRequestAmount);\n', '            emit CollateralRemoved(lp, _account, withdrawalRequestAmount);\n', '        }\n', '    }\n', '\n', '    function notifyWithdrawnAll(address lp, address _account, uint128 eventId, uint112 nonce, uint ethProfit, uint ethLoss) external override increaseNonceOnlyRelayers(lp, _account, nonce) {\n', '        require(stateOf(lp, _account) == State.Withdrawing, "CVaultETHLP: state not Withdrawing");\n', '        if (ethLoss > 0) {\n', '            _repayLoss(lp, _account, eventId, ethLoss);\n', '        }\n', '\n', '        uint lpAmount = accountOf(lp, _account).collateral;\n', '        _removeCollateral(lp, _account, lpAmount);\n', '\n', '        if (ethProfit > 0) {\n', '            _payProfit(_account, ethProfit);\n', '        }\n', '\n', '        convertState(lp, _account, State.Idle);\n', '        emit NotifyWithdrawnAll(lp, _account, eventId, lpAmount, ethProfit, ethLoss);\n', '    }\n', '\n', '    function notifyLiquidated(address lp, address _account, uint128 eventId, uint112 nonce, uint ethProfit, uint ethLoss) external override increaseNonceOnlyRelayers(lp, _account, nonce) {\n', '        require(stateOf(lp, _account) == State.Liquidating, "CVaultETHLP: state not Liquidating");\n', '        if (ethLoss > 0) {\n', '            _repayLoss(lp, _account, eventId, ethLoss);\n', '        }\n', '\n', '        Account memory account = accountOf(lp, _account);\n', '        address liquidator = account.liquidator;\n', '\n', '        uint penalty = account.collateral.mul(LIQUIDATION_PENALTY).div(UNIT);\n', '        _payLiquidationPenalty(lp, _account, penalty, account.liquidator);\n', '        _removeCollateral(lp, _account, account.collateral.sub(penalty));\n', '\n', '        if (ethProfit > 0) {\n', '            _payProfit(_account, ethProfit);\n', '        }\n', '        convertState(lp, _account, State.Idle);\n', '        emit NotifyLiquidated(lp, _account, eventId, ethProfit, ethLoss, penalty, liquidator);\n', '    }\n', '\n', '    function notifyResolvedEmergency(address lp, address _account, uint128 eventId, uint112 nonce) external override increaseNonceOnlyRelayers(lp, _account, nonce) {\n', '        require(stateOf(lp, _account) == State.EmergencyExited, "CVaultETHLP: state not EmergencyExited");\n', '        convertState(lp, _account, State.Idle);\n', '\n', '        emit NotifyResolvedEmergency(lp, _account, eventId);\n', '    }\n', '\n', '    /* ========== PRIVATE FUNCTIONS ========== */\n', '\n', '    function _addCollateral(address lp, address _account, uint amount) private returns (uint collateral) {\n', '        IERC20(lp).transferFrom(_account, address(this), amount);\n', '        collateral = increaseCollateral(lp, _account, amount);\n', '    }\n', '\n', '    function _removeCollateral(address lp, address _account, uint amount) private returns (uint collateral) {\n', '        collateral = decreaseCollateral(lp, _account, amount);\n', '\n', '        uint _fee = withdrawalFee(lp, _account, amount);\n', '        if (_fee > 0) {\n', '            _zapOutAll(lp, _fee);\n', '        }\n', '        IERC20(lp).safeTransfer(_account, amount.sub(_fee));\n', '    }\n', '\n', '    function _notifyDeposited(address lp, address _account, uint bscBNBDebt, uint bscFlipBalance) private {\n', '        convertState(lp, _account, State.Farming);\n', '\n', '        setBSCBNBDebt(lp, _account, bscBNBDebt);\n', '        setBSCFlipBalance(lp, _account, bscFlipBalance);\n', '    }\n', '\n', '    function _payProfit(address _account, uint value) private {\n', '        uint transfer;\n', '        uint balance = address(this).balance;\n', '        if (balance >= value) {\n', '            transfer = value;\n', '        } else {\n', '            transfer = balance;\n', '            increaseUnpaidETHValue(_account, value.sub(balance));\n', '        }\n', '\n', '        if (transfer > 0) {\n', '            payable(_account).transfer(transfer);\n', '        }\n', '    }\n', '\n', '    function _repayLoss(address lp, address _account, uint128 eventId, uint value) private {\n', '        if (unpaidETH(_account) >= value) {\n', '            decreaseUnpaidETHValue(_account, value);\n', '            return;\n', '        }\n', '\n', '        Account memory account = accountOf(lp, _account);\n', '        uint price = relayer.priceOf(lp);\n', '        uint amount = Math.min(value.mul(1e18).div(price).mul(1000).div(997), account.collateral);\n', '        uint before = address(this).balance;\n', '        _zapOutAll(lp, amount);\n', '        uint soldValue = address(this).balance.sub(before);\n', '        decreaseCollateral(lp, _account, amount);\n', '\n', '        emit LossRealized(lp, _account, eventId, amount, soldValue);\n', '    }\n', '\n', '    function _payLiquidationPenalty(address lp, address _account, uint penalty, address liquidator) private {\n', '        require(liquidator != address(0), "CVaultETHLP: liquidator should not be zero");\n', '        decreaseCollateral(lp, _account, penalty);\n', '\n', '        uint fee = penalty.mul(LIQUIDATION_FEE).div(UNIT);\n', '        IERC20(lp).safeTransfer(treasury, fee);\n', '        IERC20(lp).safeTransfer(liquidator, penalty.sub(fee));\n', '    }\n', '\n', '    function _zapOutAll(address lp, uint amount) private {\n', '        zap.zapOut(lp, amount);\n', '\n', '        address token0 = IUniswapV2Pair(lp).token0();\n', '        address token1 = IUniswapV2Pair(lp).token1();\n', '        if (token0 != WETH) {\n', '            _approveZap(token0);\n', '            zap.zapOut(token0, IERC20(token0).balanceOf(address(this)));\n', '        }\n', '        if (token1 != WETH) {\n', '            _approveZap(token1);\n', '            zap.zapOut(token1, IERC20(token1).balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    function _approveZap(address token) private {\n', '        if (IERC20(token).allowance(address(this), address(zap)) == 0) {\n', '            IERC20(token).safeApprove(address(zap), uint(-1));\n', '        }\n', '    }\n', '}']