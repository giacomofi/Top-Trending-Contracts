['//SPDX-License-Identifier: Unlicense\n', 'pragma solidity ^0.6.8;\n', '\n', 'import "./ServiceInterfaceV10.sol";\n', 'import "./IERC1155Preset.sol";\n', '\n', 'import "./Context.sol";\n', 'import "./Counters.sol";\n', '\n', 'contract StrongNFTClaimerV2 is Context {\n', '  using Counters for Counters.Counter;\n', '\n', '  IERC1155Preset public token;\n', '  ServiceInterfaceV10 public service;\n', '\n', '  bool public initDone;\n', '\n', '  address public serviceAdmin;\n', '  address public superAdmin;\n', '\n', '  address payable public feeCollector;\n', '  uint256 public claimingFeeInWei;\n', '\n', '  string[] public tokenNames;\n', '  mapping(string => uint256) public tokenNameIndex;\n', '  mapping(string => bool) public tokenNameExists;\n', '  mapping(string => Counters.Counter) public tokenNameCounter;\n', '  mapping(string => mapping(address => bool)) public tokenNameAddressClaimed;\n', '\n', '  function init(address tokenContract, address serviceContract, address serviceAdminAddress, address superAdminAddress) public {\n', '    require(initDone == false, "init done");\n', '\n', '    serviceAdmin = serviceAdminAddress;\n', '    superAdmin = superAdminAddress;\n', '    token = IERC1155Preset(tokenContract);\n', '    service = ServiceInterfaceV10(serviceContract);\n', '    initDone = true;\n', '  }\n', '\n', '  function isEligible(string memory tokenName, address claimer) public view returns (bool) {\n', '    if (keccak256(abi.encode(tokenName)) == keccak256(abi.encode("BRONZE"))) {\n', '      return\n', '        tokenNameExists[tokenName] &&\n', '        !tokenNameAddressClaimed[tokenName][claimer] &&\n', '        service.isEntityActive(claimer) &&\n', '        service.traunch(claimer) == 0;\n', '    }\n', '\n', '    return false;\n', '  }\n', '\n', '  function claim(string memory tokenName) public payable {\n', '    require(tokenNameExists[tokenName], "invalid token");\n', '    require(msg.value == claimingFeeInWei, "invalid fee");\n', '    require(tokenNameAddressClaimed[tokenName][_msgSender()] == false, "already claimed");\n', '\n', '    if (keccak256(abi.encode(tokenName)) == keccak256(abi.encode("BRONZE"))) {\n', '      require(service.isEntityActive(_msgSender()), "not active");\n', '      require(service.traunch(_msgSender()) == 0, "wrong traunch");\n', '\n', '      token.mint(_msgSender(), tokenNameCounter[tokenName].current(), 1, "");\n', '      tokenNameCounter[tokenName].increment();\n', '      tokenNameAddressClaimed[tokenName][_msgSender()] = true;\n', '\n', '      feeCollector.transfer(msg.value);\n', '    } else {\n', '      return;\n', '    }\n', '  }\n', '\n', '  function updateFeeCollector(address payable newFeeCollector) public {\n', '    require(newFeeCollector != address(0), "zero");\n', '    require(msg.sender == serviceAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    feeCollector = newFeeCollector;\n', '  }\n', '\n', '  function updateClaimingFee(uint256 feeInWei) public {\n', '    require(msg.sender == serviceAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    claimingFeeInWei = feeInWei;\n', '  }\n', '\n', '  function addTokenName(string memory tokenName, uint256 counterValue) public {\n', '    require(msg.sender == serviceAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    if (tokenNames.length != 0) {\n', '      uint256 index = tokenNameIndex[tokenName];\n', '      require(keccak256(abi.encode(tokenNames[index])) != keccak256(abi.encode(tokenName)), "exists");\n', '    }\n', '    uint256 len = tokenNames.length;\n', '    tokenNameIndex[tokenName] = len;\n', '    tokenNameExists[tokenName] = true;\n', '    tokenNameCounter[tokenName] = Counters.Counter(counterValue);\n', '    tokenNames.push(tokenName);\n', '  }\n', '\n', '  function updateTokenCounter(string memory tokenName, uint256 counterValue) public {\n', '    require(msg.sender == serviceAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    tokenNameCounter[tokenName] = Counters.Counter(counterValue);\n', '  }\n', '}']