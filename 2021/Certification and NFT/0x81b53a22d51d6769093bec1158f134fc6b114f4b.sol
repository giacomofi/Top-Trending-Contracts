['pragma solidity 0.6.11;\n', '\n', 'import {Proxy} from "./Proxy.sol";\n', 'import {GovernableProxy} from "./GovernableProxy.sol";\n', '\n', 'contract UpgradableProxy is GovernableProxy, Proxy {\n', '    bytes32 constant IMPLEMENTATION_SLOT = keccak256("proxy.implementation");\n', '\n', '    event ProxyUpdated(address indexed previousImpl, address indexed newImpl);\n', '\n', '    fallback() external {\n', '        delegatedFwd(implementation(), msg.data);\n', '    }\n', '\n', '    function implementation() override public view returns(address _impl) {\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            _impl := sload(position)\n', '        }\n', '    }\n', '\n', '    function updateImplementation(address _newProxyTo) public onlyOwner {\n', '        require(_newProxyTo != address(0x0), "INVALID_PROXY_ADDRESS");\n', '        require(isContract(_newProxyTo), "DESTINATION_ADDRESS_IS_NOT_A_CONTRACT");\n', '        emit ProxyUpdated(implementation(), _newProxyTo);\n', '        setImplementation(_newProxyTo);\n', '    }\n', '\n', '    function setImplementation(address _newProxyTo) private {\n', '        bytes32 position = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            sstore(position, _newProxyTo)\n', '        }\n', '    }\n', '\n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '        uint size;\n', '        assembly {\n', '            size := extcodesize(_target)\n', '        }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.6.11;\n', '\n', 'import {IERCProxy} from "./IERCProxy.sol";\n', '\n', 'abstract contract Proxy is IERCProxy {\n', '    function delegatedFwd(address _dst, bytes memory _calldata) internal {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            let result := delegatecall(\n', '                sub(gas(), 10000),\n', '                _dst,\n', '                add(_calldata, 0x20),\n', '                mload(_calldata),\n', '                0,\n', '                0\n', '            )\n', '            let size := returndatasize()\n', '\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n', '            // if the call returned error data, forward it\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, size)\n', '                }\n', '                default {\n', '                    return(ptr, size)\n', '                }\n', '        }\n', '    }\n', '\n', '    function proxyType() override external pure returns (uint proxyTypeId) {\n', '        // Upgradeable proxy\n', '        proxyTypeId = 2;\n', '    }\n', '\n', '    function implementation() override virtual public view returns (address);\n', '}\n', '\n', 'pragma solidity 0.6.11;\n', '\n', 'contract GovernableProxy {\n', '    bytes32 constant OWNER_SLOT = keccak256("proxy.owner");\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor() internal {\n', '        _transferOwnership(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns(address _owner) {\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            _owner := sload(position)\n', '        }\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return owner() == msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "OwnableProxy: new owner is the zero address");\n', '        emit OwnershipTransferred(owner(), newOwner);\n', '        bytes32 position = OWNER_SLOT;\n', '        assembly {\n', '            sstore(position, newOwner)\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity 0.6.11;\n', '\n', 'interface IERCProxy {\n', '    function proxyType() external pure returns (uint proxyTypeId);\n', '    function implementation() external view returns (address codeAddr);\n', '}']