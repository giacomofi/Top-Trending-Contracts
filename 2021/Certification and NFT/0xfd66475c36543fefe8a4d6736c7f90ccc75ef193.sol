['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-05\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', 'pragma solidity >=0.8;\n', '\n', '\n', 'contract ElBote {\n', '    \n', '    //propietario\n', '    address private owner;\n', '    \n', '    //####\n', '    constructor(){\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function changeOwner(address newOwner) public payable {\n', '        require(msg.value >= min_ether);\n', '        payable(owner).transfer(msg.value);\n', '        require(msg.sender == owner);\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //-----------------------------\n', '    \n', '    \n', '    //afiliados\n', '    struct Afiliado{\n', '        uint conversiones;\n', '        uint ingresos;\n', '        bool joined;\n', '    }\n', '    \n', '    mapping(address => Afiliado) private afiliados;\n', '    \n', '    uint constant N = 20;\n', '    address[N] private topIngresos;\n', '    address[N] private topConversiones;\n', '    \n', '    //####\n', '    function getAfiliadoInfo () public view returns (uint, uint, bool) {\n', '        return (afiliados[msg.sender].conversiones, afiliados[msg.sender].ingresos, afiliados[msg.sender].joined);\n', '    }\n', '    \n', '    function pushAfiliado () public payable {\n', '        require(msg.sender != owner);\n', '        require(msg.value >= min_ether);\n', '        require(afiliados[msg.sender].joined==false);\n', '        afiliados[msg.sender]=Afiliado(0,0, true);\n', '        payable(owner).transfer(msg.value);\n', '    }\n', '    //------------------------------\n', '    \n', '    \n', '    //EL BOTE - ¡¡¡HAGAN SUS APUESTAS!!!\n', '    uint public balanceTotal;\n', '    address private winner;\n', '    uint private winnerValue;\n', '    uint private winnerBlock;\n', '    uint private winnerDificulty;\n', '    uint private winnerTimespam;\n', '    uint private rand;\n', '    uint constant MAX_INT = 2**256 - 1; //115792089237316195423570985008687907853269984665640564039457584007913129639935\n', '    uint constant min_ether = 0.01 ether;\n', '    uint constant lotes = 0.001 ether; // calcularemos la probabilidad en n uinidades de 0.001 ethers\n', '    uint constant n_MAX_INT=MAX_INT/lotes;\n', '    uint constant TIME = 1 days;\n', '    uint private bonus;\n', '    uint public level;\n', '    uint public start;\n', '    uint public end;\n', '    uint public bote;\n', '    uint private apuesta;\n', '    \n', '    struct winners_info{\n', '        address winner;\n', '        uint start;\n', '        uint end;\n', '        uint premio;\n', '    }\n', '    \n', '    winners_info[] private winners;\n', '    \n', '    modifier minEther {require(msg.value >= min_ether);_;}\n', '    \n', '    modifier onlyOwner {payable(owner).transfer(msg.value * 20 / 100);_;}\n', '    \n', '    modifier noEsAfiliadoOwner {require(afiliados[msg.sender].joined==false);require(msg.sender != owner);_;}\n', '    \n', '    receive() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\n', '    \n', '    fallback() external payable minEther onlyOwner noEsAfiliadoOwner {jugar();}\n', '    \n', '    event showWinner(address, uint, uint, uint);\n', '    \n', '    event showBote(uint, uint, uint);\n', '    \n', '    function setAfiliado(address addr_afiliado) external payable minEther noEsAfiliadoOwner {\n', '        require(afiliados[addr_afiliado].joined==true);\n', '        uint balance = msg.value * 10 / 100;\n', '        afiliados[addr_afiliado].conversiones++;\n', '        afiliados[addr_afiliado].ingresos+=balance;\n', '        if(afiliados[addr_afiliado].conversiones==5)\n', '            payable(addr_afiliado).transfer(afiliados[addr_afiliado].ingresos);\n', '        else if(afiliados[addr_afiliado].conversiones>5)\n', '            payable(addr_afiliado).transfer(balance);\n', '        payable(owner).transfer(balance);\n', '        //actualizar topIngresos\n', '        for(uint i=0; i<topIngresos.length; i++){\n', '            if(topIngresos[i]==addr_afiliado){\n', '                for(uint j=i; j<topIngresos.length-1; j++){\n', '                    topIngresos[j]=topIngresos[j+1];\n', '                }\n', '            }\n', '        }\n', '        for(uint i=0; i<topIngresos.length; i++){\n', '            bool insertar= false;\n', '            if(afiliados[topIngresos[i]].ingresos<afiliados[addr_afiliado].ingresos){\n', '                insertar= true;\n', '                for(uint j=topIngresos.length-1; j>i; j--){\n', '                    topIngresos[j]=topIngresos[j-1];\n', '                }\n', '                topIngresos[i]=addr_afiliado;\n', '            }\n', '            if(insertar)\n', '                break;\n', '        }\n', '        //actualizar topConversiones\n', '        for(uint i=0; i<topConversiones.length; i++){\n', '            if(topConversiones[i]==addr_afiliado){\n', '                for(uint j=i; j<topConversiones.length-1; j++){\n', '                    topConversiones[j]=topConversiones[j+1];\n', '                }\n', '            }\n', '        }\n', '        for(uint i=0; i<topConversiones.length; i++){\n', '            bool insertar= false;\n', '            if(afiliados[topConversiones[i]].conversiones<afiliados[addr_afiliado].conversiones){\n', '                insertar= true;\n', '                for(uint j=topConversiones.length-1; j>i; j--){\n', '                    topConversiones[j]=topConversiones[j-1];\n', '                }\n', '                topConversiones[i]=addr_afiliado;\n', '            }\n', '            if(insertar)\n', '                break;\n', '        }\n', '        //jugar\n', '        jugar();\n', '    }\n', '    \n', '    function jugar() private {\n', '        apuesta = msg.value - (msg.value * 20 / 100);\n', '        if(balanceTotal==0){\n', '            sumarApuesta();\n', '            setWinner();\n', '            bote = 1 ether; //bote inicial\n', '            calcularBonus();\n', '            level = bonus + 1;\n', '            start = block.timestamp;\n', '            end = block.timestamp + (level * TIME);\n', '            setBote();\n', '        }else{\n', '            sumarApuesta();\n', '            uint randHash = uint(blockhash(rand));\n', '            rand = uint(keccak256(abi.encodePacked(randHash, msg.sender, msg.value, block.number-1, block.difficulty, block.timestamp, winner, winnerValue, winnerBlock, winnerDificulty, winnerTimespam)));\n', '            uint n_apuesta=apuesta/lotes;\n', '            uint n_balance=balanceTotal/lotes;\n', '            uint probabilidad = n_apuesta * n_MAX_INT / n_balance;// no poner n_apuesta / n_balance * n_MAX_INT porque dará 0 siempre\n', '            uint n_rand = rand/lotes;\n', '            if(n_rand<=probabilidad)\n', '                setWinner();\n', '            calcularBonus();\n', '            if(bonus > 0){\n', '                level += bonus;\n', '                end += bonus * TIME;\n', '                setBote();\n', '            }\n', '            else if(block.timestamp > end){\n', '                winners.push(winners_info(winner, start, block.timestamp, balanceTotal));\n', '                uint amount = balanceTotal;\n', '                balanceTotal=0;\n', '                level=0;\n', '                bonus=0;\n', '                start=0;\n', '                end=0;\n', '                bote=0;\n', '                payable(winner).transfer(amount);\n', '                emit showWinner(winner, start, block.timestamp, amount);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function setWinner() private {\n', '        winner=msg.sender;\n', '        winnerBlock=block.number-1;\n', '        winnerDificulty=block.difficulty;\n', '        winnerTimespam=block.timestamp;\n', '    }\n', '    \n', '    function setBote() private {\n', '        bote = 1 ether * (2**(level-1));\n', '        emit showBote(bote, start, end);\n', '    }\n', '    \n', '    function calcularBonus() private {\n', '        bonus = balanceTotal / bote;\n', '    }\n', '    \n', '    function sumarApuesta() private {\n', '        balanceTotal+=apuesta;\n', '    }\n', '    \n', '    function verBonus() public view returns ( uint _balanceTotal,  uint _bote,   uint _bonus, uint _level){\n', '        return (balanceTotal, bote, bonus, level);\n', '    }\n', '    \n', '    function tiempo() public view returns (uint inicio, uint _final, uint ahora){\n', '        return (start, end, block.timestamp);\n', '    }\n', '    \n', '    function verGanadores(uint n) public view returns (address _winner, uint _start, uint _end, uint _premio){\n', '        return (winners[n].winner, winners[n].start, winners[n].end, winners[n].premio);\n', '    }\n', '    \n', '    function verGanadoresLenght() public view returns (uint n){\n', '        return winners.length;\n', '    }\n', '    \n', '    function returnAfiliadoListaIngresos(uint n) public view returns (address, uint, uint){\n', '        return (topIngresos[n], afiliados[topIngresos[n]].conversiones, afiliados[topIngresos[n]].ingresos);\n', '    }\n', '    \n', '    function returnAfiliadoListaConversiones(uint n) public view returns (address, uint, uint){\n', '        return (topConversiones[n], afiliados[topConversiones[n]].conversiones, afiliados[topConversiones[n]].ingresos);\n', '    }\n', '    \n', '}']