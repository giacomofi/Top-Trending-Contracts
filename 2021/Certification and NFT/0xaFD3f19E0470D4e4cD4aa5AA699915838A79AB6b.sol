['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// solhint-disable avoid-low-level-calls\n', '// solhint-disable not-rely-on-time\n', '\n', '// File contracts/interfaces/IStrategy.sol\n', '// License-Identifier: MIT\n', '\n', 'interface IStrategy {\n', '    /// @notice Send the assets to the Strategy and call skim to invest them.\n', '    /// @param amount The amount of tokens to invest.\n', '    function skim(uint256 amount) external;\n', '\n', '    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\n', '    /// @param balance The amount of tokens the caller thinks it has invested.\n', '    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\n', '    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n', '    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n', '\n', '    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n', '    /// @dev The `actualAmount` should be very close to the amount.\n', "    /// The difference should NOT be used to report a loss. That's what harvest is for.\n", '    /// @param amount The requested amount the caller wants to withdraw.\n', '    /// @return actualAmount The real amount that is withdrawn.\n', '    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n', '\n', "    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    /// @param balance The amount of tokens the caller thinks it has invested.\n', '    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n', '    function exit(uint256 balance) external returns (int256 amountAdded);\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '// Audit on 5-Jan-2021 by Keno and BoringCrypto\n', '// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n', '// Edited by BoringCrypto\n', '\n', 'contract BoringOwnableData {\n', '    address public owner;\n', '    address public pendingOwner;\n', '}\n', '\n', 'contract BoringOwnable is BoringOwnableData {\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice `owner` defaults to msg.sender on construction.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n', '    /// Can only be invoked by the current `owner`.\n', '    /// @param newOwner Address of the new owner.\n', '    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n', '    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) public onlyOwner {\n', '        if (direct) {\n', '            // Checks\n', '            require(newOwner != address(0) || renounce, "Ownable: zero address");\n', '\n', '            // Effects\n', '            emit OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '            pendingOwner = address(0);\n', '        } else {\n', '            // Effects\n', '            pendingOwner = newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n', '    function claimOwnership() public {\n', '        address _pendingOwner = pendingOwner;\n', '\n', '        // Checks\n', '        require(msg.sender == _pendingOwner, "Ownable: caller != pending owner");\n', '\n', '        // Effects\n', '        emit OwnershipTransferred(owner, _pendingOwner);\n', '        owner = _pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /// @notice Only allows the `owner` to execute the function.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\n', 'library BoringMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\n', 'library BoringMath64 {\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\n', 'library BoringMath32 {\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', 'library BoringERC20 {\n', '    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n', '    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n', '    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n', '    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n', '    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n', '\n', '    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n', '        if (data.length >= 64) {\n', '            return abi.decode(data, (string));\n', '        } else if (data.length == 32) {\n', '            uint8 i = 0;\n', '            while(i < 32 && data[i] != 0) {\n', '                i++;\n', '            }\n', '            bytes memory bytesArray = new bytes(i);\n', '            for (i = 0; i < 32 && data[i] != 0; i++) {\n', '                bytesArray[i] = data[i];\n', '            }\n', '            return string(bytesArray);\n', '        } else {\n', '            return "???";\n', '        }\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token symbol.\n', '    function safeSymbol(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token name.\n', '    function safeName(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (uint8) Token decimals.\n', '    function safeDecimals(IERC20 token) internal view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param from Transfer tokens from.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// File contracts/strategies/SushiStrategy.sol\n', '// License-Identifier: MIT\n', '\n', 'interface ISushiBar is IERC20 {\n', '    function enter(uint256 _amount) external;\n', '    function leave(uint256 _share) external;\n', '}\n', '\n', 'contract SushiStrategy is IStrategy, BoringOwnable {\n', '    using BoringMath for uint256;\n', '    using BoringERC20 for IERC20;\n', '\n', '    IERC20 private immutable sushi;\n', '    ISushiBar private immutable bar;\n', '\n', '    constructor(ISushiBar bar_, IERC20 sushi_) public {\n', '        bar = bar_;\n', '        sushi = sushi_;\n', '    }\n', '\n', '    // Send the assets to the Strategy and call skim to invest them\n', '    /// @inheritdoc IStrategy\n', '    function skim(uint256 amount) external override {\n', '        sushi.approve(address(bar), amount);\n', '        bar.enter(amount);\n', '    }\n', '\n', '    // Harvest any profits made converted to the asset and pass them to the caller\n', '    /// @inheritdoc IStrategy\n', '    function harvest(uint256 balance, address) external override onlyOwner returns (int256 amountAdded) {\n', '        uint256 share = bar.balanceOf(address(this));\n', '        uint256 totalShares = bar.totalSupply();\n', '        uint256 totalSushi = sushi.balanceOf(address(bar));\n', '        uint256 keepShare = balance.mul(totalShares) / totalSushi;\n', '        uint256 harvestShare = share.sub(keepShare);\n', '        bar.leave(harvestShare);\n', '        amountAdded = int256(sushi.balanceOf(address(this)));\n', '        sushi.safeTransfer(owner, uint256(amountAdded)); // Add as profit\n', '    }\n', '\n', '    // Withdraw assets. The returned amount can differ from the requested amount due to rounding or if the request was more than there is.\n', '    /// @inheritdoc IStrategy\n', '    function withdraw(uint256 amount) external override onlyOwner returns (uint256 actualAmount) {\n', '        uint256 totalShares = bar.totalSupply();\n', '        uint256 totalSushi = sushi.balanceOf(address(bar));\n', '        uint256 withdrawShare = amount.mul(totalShares) / totalSushi;\n', '        uint256 share = bar.balanceOf(address(this));\n', '        if (withdrawShare > share) {\n', '            withdrawShare = share;\n', '        }\n', '        bar.leave(withdrawShare);\n', '        actualAmount = sushi.balanceOf(address(this));\n', '        sushi.safeTransfer(owner, actualAmount);\n', '    }\n', '\n', "    // Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    /// @inheritdoc IStrategy\n', '    function exit(uint256 balance) external override onlyOwner returns (int256 amountAdded) {\n', '        uint256 share = bar.balanceOf(address(this));\n', '        bar.leave(share);\n', '        uint256 amount = sushi.balanceOf(address(this));\n', '        amountAdded = int256(amount - balance);\n', '        sushi.safeTransfer(owner, amount);\n', '    }\n', '}']