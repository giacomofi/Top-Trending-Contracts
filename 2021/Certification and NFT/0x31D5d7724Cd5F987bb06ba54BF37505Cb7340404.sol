['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-14\n', '*/\n', '\n', '// File: contracts\\farming\\FarmData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct FarmingPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount0; // amount of main token or liquidity pool token.\n', '    uint256 amount1; // amount of other token or liquidity pool token. Needed for gen2\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', 'struct FarmingSetupConfiguration {\n', "    bool add; // true if we're adding a new setup, false we're updating it.\n", '    bool disable;\n', "    uint256 index; // index of the setup we're updating.\n", '    FarmingSetupInfo info; // data of the new or updated setup\n', '}\n', '\n', 'struct FarmingSetupInfo {\n', '    uint256 blockDuration; // duration of setup\n', '    uint256 startBlock; // optional start block used for the delayed activation of the first setup\n', '    uint256 originalRewardPerBlock;\n', '    uint256 minStakeable; // minimum amount of staking tokens.\n', "    uint256 renewTimes; // if the setup is renewable or if it's one time.\n", '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '    uint256 setupsCount; // number of setups created by this info.\n', '    uint256 lastSetupIndex; // index of last setup;\n', '    int24 tickLower; // Gen2 Only - tickLower of the UniswapV3 pool\n', '    int24 tickUpper; // Gen 2 Only - tickUpper of the UniswapV3 pool\n', '}\n', '\n', 'struct FarmingSetup {\n', '    uint256 infoIndex; // setup info\n', '    bool active; // if the setup is active or not.\n', '    uint256 startBlock; // farming setup start block.\n', '    uint256 endBlock; // farming setup end block.\n', '    uint256 lastUpdateBlock; // number of the block where an update was triggered.\n', '    uint256 objectId; // need for gen2. uniswapV3 NFT position Id\n', '    uint256 rewardPerBlock; // farming setup reward per single block.\n', '    uint128 totalSupply; // Total LP token liquidity of all the positions of this setup\n', '}\n', '\n', 'struct FarmingPosition {\n', '    address uniqueOwner; // address representing the owner of the position.\n', '    uint256 setupIndex; // the setup index related to this position.\n', '    uint256 creationBlock; // block when this position was created.\n', '    uint128 liquidityPoolTokenAmount; // amount of liquidity pool token in the position.\n', '    uint256 reward; // position reward.\n', '}\n', '\n', '// File: contracts\\farming\\IFarmMain.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IFarmMain {\n', '\n', '    function ONE_HUNDRED() external view returns(uint256);\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function position(uint256 positionId) external view returns (FarmingPosition memory);\n', '    function setups() external view returns (FarmingSetup[] memory);\n', '    function setup(uint256 setupIndex) external view returns (FarmingSetup memory, FarmingSetupInfo memory);\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '    function openPosition(FarmingPositionRequest calldata request) external payable returns(uint256 positionId);\n', '    function addLiquidity(uint256 positionId, FarmingPositionRequest calldata request) external payable;\n', '}\n', '\n', '// File: contracts\\farming\\IFarmExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IFarmExtension {\n', '\n', '    function init(bool byMint, address host, address treasury) external;\n', '\n', '    function setHost(address host) external;\n', '    function setTreasury(address treasury) external;\n', '\n', '    function data() external view returns(address farmMainContract, bool byMint, address host, address treasury, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '}\n', '\n', '// File: contracts\\farming\\IFarmFactory.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IFarmFactory {\n', '\n', '    event ExtensionCloned(address indexed);\n', '\n', '    function feePercentageInfo() external view returns (uint256, address);\n', '    function farmDefaultExtension() external view returns(address);\n', '    function cloneFarmDefaultExtension() external returns(address);\n', '    function getFarmTokenCollectionURI() external view returns (string memory);\n', '    function getFarmTokenURI() external view returns (string memory);\n', '}\n', '\n', '// File: contracts\\farming\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function safeApprove(address spender, uint256 amount) external;\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolImmutables.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n', '    /// @return The contract address\n', '    function factory() external view returns (address);\n', '\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '\n', "    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n", '    /// @return The fee\n', '    function fee() external view returns (uint24);\n', '\n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '\n', '    /// @notice The maximum amount of position liquidity that can use any tick in the range\n', '    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n', '    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n', '    /// @return The max amount of liquidity per tick\n', '    function maxLiquidityPerTick() external view returns (uint128);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that can change\n', "/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n", '/// per transaction\n', 'interface IUniswapV3PoolState {\n', '    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n', '    /// when accessed externally.\n', '    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n', '    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n', '    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n', '    /// boundary.\n', '    /// observationIndex The index of the last oracle observation that was written,\n', '    /// observationCardinality The current maximum number of observations stored in the pool,\n', '    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n', '    /// feeProtocol The protocol fee for both tokens of the pool.\n', '    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n', '    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n', '    /// unlocked Whether the pool is currently locked to reentrancy\n', '    function slot0()\n', '        external\n', '        view\n', '        returns (\n', '            uint160 sqrtPriceX96,\n', '            int24 tick,\n', '            uint16 observationIndex,\n', '            uint16 observationCardinality,\n', '            uint16 observationCardinalityNext,\n', '            uint8 feeProtocol,\n', '            bool unlocked\n', '        );\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal0X128() external view returns (uint256);\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal1X128() external view returns (uint256);\n', '\n', '    /// @notice The amounts of token0 and token1 that are owed to the protocol\n', '    /// @dev Protocol fees will never exceed uint128 max in either token\n', '    function protocolFees() external view returns (uint128 token0, uint128 token1);\n', '\n', '    /// @notice The currently in range liquidity available to the pool\n', '    /// @dev This value has no relationship to the total liquidity across all ticks\n', '    function liquidity() external view returns (uint128);\n', '\n', '    /// @notice Look up information about a specific tick in the pool\n', '    /// @param tick The tick to look up\n', '    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n', '    /// tick upper,\n', '    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n', '    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n', '    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n', '    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n', '    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n', '    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n', '    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n', '    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n', '    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n', '    /// a specific position.\n', '    function ticks(int24 tick)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 liquidityGross,\n', '            int128 liquidityNet,\n', '            uint256 feeGrowthOutside0X128,\n', '            uint256 feeGrowthOutside1X128,\n', '            int56 tickCumulativeOutside,\n', '            uint160 secondsPerLiquidityOutsideX128,\n', '            uint32 secondsOutside,\n', '            bool initialized\n', '        );\n', '\n', '    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n', '    function tickBitmap(int16 wordPosition) external view returns (uint256);\n', '\n', "    /// @notice Returns the information about a position by the position's key\n", "    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n", '    /// @return _liquidity The amount of liquidity in the position,\n', '    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n', '    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n', '    function positions(bytes32 key)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 _liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '\n', '    /// @notice Returns data about a specific observation index\n', '    /// @param index The element of the observations array to fetch\n', '    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n', '    /// ago, rather than at a specific index in the array.\n', '    /// @return blockTimestamp The timestamp of the observation,\n', '    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n', '    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n', '    /// Returns initialized whether the observation has been initialized and the values are safe to use\n', '    function observations(uint256 index)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 blockTimestamp,\n', '            int56 tickCumulative,\n', '            uint160 secondsPerLiquidityCumulativeX128,\n', '            bool initialized\n', '        );\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolDerivedState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '    /// you must call it with secondsAgos = [3600, 0].\n', '    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '    /// timestamp\n', '    function observe(uint32[] calldata secondsAgos)\n', '        external\n', '        view\n', '        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n', '\n', '    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n', '    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n', '    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n', '    /// snapshot is taken and the second snapshot is taken.\n', '    /// @param tickLower The lower tick of the range\n', '    /// @param tickUpper The upper tick of the range\n', '    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n', '    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n', '    /// @return secondsInside The snapshot of seconds per liquidity for the range\n', '    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n', '        external\n', '        view\n', '        returns (\n', '            int56 tickCumulativeInside,\n', '            uint160 secondsPerLiquidityInsideX128,\n', '            uint32 secondsInside\n', '        );\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolActions.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissionless pool actions\n', '/// @notice Contains pool methods that can be called by anyone\n', 'interface IUniswapV3PoolActions {\n', '    /// @notice Sets the initial price for the pool\n', '    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n', '    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n', '    function initialize(uint160 sqrtPriceX96) external;\n', '\n', '    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n', '    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n', '    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n', '    /// @param recipient The address for which the liquidity will be created\n', '    /// @param tickLower The lower tick of the position in which to add liquidity\n', '    /// @param tickUpper The upper tick of the position in which to add liquidity\n', '    /// @param amount The amount of liquidity to mint\n', '    /// @param data Any data that should be passed through to the callback\n', '    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    function mint(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount,\n', '        bytes calldata data\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Collects tokens owed to a position\n', '    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n', '    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n', '    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n', '    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n', '    /// @param recipient The address which should receive the fees collected\n', '    /// @param tickLower The lower tick of the position for which to collect fees\n', '    /// @param tickUpper The upper tick of the position for which to collect fees\n', '    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n', '    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '\n', '    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n', '    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n', '    /// @dev Fees must be collected separately via a call to #collect\n', '    /// @param tickLower The lower tick of the position for which to burn liquidity\n', '    /// @param tickUpper The upper tick of the position for which to burn liquidity\n', '    /// @param amount How much liquidity to burn\n', '    /// @return amount0 The amount of token0 sent to the recipient\n', '    /// @return amount1 The amount of token1 sent to the recipient\n', '    function burn(\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Swap token0 for token1, or token1 for token0\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n', '    /// @param recipient The address to receive the output of the swap\n', '    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n', '    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n', '    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n', '    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n', '    /// @param data Any data to be passed through to the callback\n', '    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n', '    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n', '    function swap(\n', '        address recipient,\n', '        bool zeroForOne,\n', '        int256 amountSpecified,\n', '        uint160 sqrtPriceLimitX96,\n', '        bytes calldata data\n', '    ) external returns (int256 amount0, int256 amount1);\n', '\n', '    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n', '    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n', '    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n', '    /// @param recipient The address which will receive the token0 and token1 amounts\n', '    /// @param amount0 The amount of token0 to send\n', '    /// @param amount1 The amount of token1 to send\n', '    /// @param data Any data to be passed through to the callback\n', '    function flash(\n', '        address recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n', '    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n', '    /// the input observationCardinalityNext.\n', '    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n', '    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolOwnerActions.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissioned pool actions\n', '/// @notice Contains pool methods that may only be called by the factory owner\n', 'interface IUniswapV3PoolOwnerActions {\n', "    /// @notice Set the denominator of the protocol's % share of the fees\n", '    /// @param feeProtocol0 new protocol fee for token0 of the pool\n', '    /// @param feeProtocol1 new protocol fee for token1 of the pool\n', '    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n', '\n', '    /// @notice Collect the protocol fee accrued to the pool\n', '    /// @param recipient The address to which collected protocol fees should be sent\n', '    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n', '    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n', '    /// @return amount0 The protocol fee collected in token0\n', '    /// @return amount1 The protocol fee collected in token1\n', '    function collectProtocol(\n', '        address recipient,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolEvents.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Events emitted by a pool\n', '/// @notice Contains all events emitted by the pool\n', 'interface IUniswapV3PoolEvents {\n', '    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n', '    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n', '    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n', '    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n', '    event Initialize(uint160 sqrtPriceX96, int24 tick);\n', '\n', '    /// @notice Emitted when liquidity is minted for a given position\n', '    /// @param sender The address that minted the liquidity\n', '    /// @param owner The owner of the position and recipient of any minted liquidity\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity minted to the position range\n', '    /// @param amount0 How much token0 was required for the minted liquidity\n', '    /// @param amount1 How much token1 was required for the minted liquidity\n', '    event Mint(\n', '        address sender,\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted when fees are collected by the owner of a position\n', '    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n', '    /// @param owner The owner of the position for which fees are collected\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount0 The amount of token0 fees collected\n', '    /// @param amount1 The amount of token1 fees collected\n', '    event Collect(\n', '        address indexed owner,\n', '        address recipient,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount0,\n', '        uint128 amount1\n', '    );\n', '\n', "    /// @notice Emitted when a position's liquidity is removed\n", '    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n', '    /// @param owner The owner of the position for which liquidity is removed\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity to remove\n', '    /// @param amount0 The amount of token0 withdrawn\n', '    /// @param amount1 The amount of token1 withdrawn\n', '    event Burn(\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any swaps between token0 and token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the output of the swap\n', '    /// @param amount0 The delta of the token0 balance of the pool\n', '    /// @param amount1 The delta of the token1 balance of the pool\n', '    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n', '    /// @param liquidity The liquidity of the pool after the swap\n', '    /// @param tick The log base 1.0001 of price of the pool after the swap\n', '    event Swap(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        int256 amount0,\n', '        int256 amount1,\n', '        uint160 sqrtPriceX96,\n', '        uint128 liquidity,\n', '        int24 tick\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any flashes of token0/token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the tokens from flash\n', '    /// @param amount0 The amount of token0 that was flashed\n', '    /// @param amount1 The amount of token1 that was flashed\n', '    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n', '    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n', '    event Flash(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        uint256 paid0,\n', '        uint256 paid1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n', '    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n', '    /// just before a mint/swap/burn.\n', '    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n', '    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n', '    event IncreaseObservationCardinalityNext(\n', '        uint16 observationCardinalityNextOld,\n', '        uint16 observationCardinalityNextNew\n', '    );\n', '\n', '    /// @notice Emitted when the protocol fee is changed by the pool\n', '    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n', '    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n', '    /// @param feeProtocol0New The updated value of the token0 protocol fee\n', '    /// @param feeProtocol1New The updated value of the token1 protocol fee\n', '    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n', '\n', '    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n', '    /// @param sender The address that collects the protocol fees\n', '    /// @param recipient The address that receives the collected protocol fees\n', '    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n', '    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n', '    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: @uniswap\\v3-core\\contracts\\interfaces\\IUniswapV3Pool.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title The interface for a Uniswap V3 Pool\n', '/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '/// to the ERC20 specification\n', '/// @dev The pool interface is broken up into many smaller pieces\n', 'interface IUniswapV3Pool is\n', '    IUniswapV3PoolImmutables,\n', '    IUniswapV3PoolState,\n', '    IUniswapV3PoolDerivedState,\n', '    IUniswapV3PoolActions,\n', '    IUniswapV3PoolOwnerActions,\n', '    IUniswapV3PoolEvents\n', '{\n', '\n', '}\n', '\n', '// File: @uniswap\\v3-core\\contracts\\libraries\\TickMath.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Math library for computing sqrt prices from ticks and vice versa\n', '/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n', '/// prices between 2**-128 and 2**128\n', 'library TickMath {\n', '    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n', '    int24 internal constant MIN_TICK = -887272;\n', '    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n', '    int24 internal constant MAX_TICK = -MIN_TICK;\n', '\n', '    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n', '    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n', '    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n', '    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n', '\n', '    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n', '    /// @dev Throws if |tick| > max tick\n', '    /// @param tick The input tick for the above formula\n', '    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n', '    /// at the given tick\n', '    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n', '        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n', "        require(absTick <= uint256(MAX_TICK), 'T');\n", '\n', '        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n', '        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n', '        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n', '        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n', '        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n', '        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n', '        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n', '        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n', '        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n', '        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n', '        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n', '        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n', '        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n', '        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n', '        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n', '        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n', '        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n', '        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n', '        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n', '        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n', '\n', '        if (tick > 0) ratio = type(uint256).max / ratio;\n', '\n', '        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n', '        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n', '        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n', '        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n', '    }\n', '\n', '    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n', '    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n', '    /// ever return.\n', '    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n', '    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n', '    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n', '        // second inequality must be < because the price can never reach the price at the max tick\n', "        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n", '        uint256 ratio = uint256(sqrtPriceX96) << 32;\n', '\n', '        uint256 r = ratio;\n', '        uint256 msb = 0;\n', '\n', '        assembly {\n', '            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(5, gt(r, 0xFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(4, gt(r, 0xFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(3, gt(r, 0xFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(2, gt(r, 0xF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(1, gt(r, 0x3))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := gt(r, 0x1)\n', '            msb := or(msb, f)\n', '        }\n', '\n', '        if (msb >= 128) r = ratio >> (msb - 127);\n', '        else r = ratio << (127 - msb);\n', '\n', '        int256 log_2 = (int256(msb) - 128) << 64;\n', '\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(63, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(62, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(61, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(60, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(59, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(58, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(57, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(56, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(55, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(54, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(53, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(52, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(51, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(50, f))\n', '        }\n', '\n', '        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n', '\n', '        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n', '        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n', '\n', '        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n', '    }\n', '}\n', '\n', '// File: node_modules\\@openzeppelin\\contracts\\introspection\\IERC165.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: node_modules\\@openzeppelin\\contracts\\token\\ERC721\\IERC721.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\token\\ERC721\\IERC721Metadata.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the token collection name.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\token\\ERC721\\IERC721Enumerable.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the total amount of tokens stored by the contract.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n', "     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n", '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n', '     * Use along with {totalSupply} to enumerate all tokens.\n', '     */\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPoolInitializer.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '/// @title Creates and initializes V3 Pools\n', '/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n', '/// require the pool to exist.\n', 'interface IPoolInitializer {\n', '    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n', '    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n', '    /// @param token0 The contract address of token0 of the pool\n', '    /// @param token1 The contract address of token1 of the pool\n', '    /// @param fee The fee amount of the v3 pool for the specified token pair\n', '    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n', '    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n', '    function createAndInitializePoolIfNecessary(\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        uint160 sqrtPriceX96\n', '    ) external payable returns (address pool);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IERC721Permit.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '\n', '\n', '/// @title ERC721 with permit\n', '/// @notice Extension to ERC721 that includes a permit function for signature based approvals\n', 'interface IERC721Permit is IERC721 {\n', '    /// @notice The permit typehash used in the permit signature\n', '    /// @return The typehash for the permit\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    /// @notice The domain separator used in the permit signature\n', '    /// @return The domain seperator used in encoding of permit signature\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    /// @notice Approve of a specific token ID for spending by spender via signature\n', '    /// @param spender The account that is being approved\n', '    /// @param tokenId The ID of the token that is being approved for spending\n', '    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n', '    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n', '    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n', '    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n', '    function permit(\n', '        address spender,\n', '        uint256 tokenId,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPeripheryPayments.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '\n', '/// @title Periphery Payments\n', '/// @notice Functions to ease deposits and withdrawals of ETH\n', 'interface IPeripheryPayments {\n', "    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n", '    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n', '    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n', '    /// @param recipient The address receiving ETH\n', '    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n', '\n', '    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n', '    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n', '    /// that use ether for the input amount\n', '    function refundETH() external payable;\n', '\n', '    /// @notice Transfers the full amount of a token held by this contract to recipient\n', '    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n', '    /// @param token The contract address of the token which will be transferred to `recipient`\n', '    /// @param amountMinimum The minimum amount of token required for a transfer\n', '    /// @param recipient The destination address of the token\n', '    function sweepToken(\n', '        address token,\n', '        uint256 amountMinimum,\n', '        address recipient\n', '    ) external payable;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPeripheryImmutableState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Immutable state\n', '/// @notice Functions that return immutable state of the router\n', 'interface IPeripheryImmutableState {\n', '    /// @return Returns the address of the Uniswap V3 factory\n', '    function factory() external view returns (address);\n', '\n', '    /// @return Returns the address of WETH9\n', '    function WETH9() external view returns (address);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\libraries\\PoolAddress.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\n', 'library PoolAddress {\n', '    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n', '\n', '    /// @notice The identifying key of the pool\n', '    struct PoolKey {\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '    }\n', '\n', '    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n', '    /// @param tokenA The first token of a pool, unsorted\n', '    /// @param tokenB The second token of a pool, unsorted\n', '    /// @param fee The fee level of the pool\n', '    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n', '    function getPoolKey(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) internal pure returns (PoolKey memory) {\n', '        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n', '        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n', '    }\n', '\n', '    /// @notice Deterministically computes the pool address given the factory and PoolKey\n', '    /// @param factory The Uniswap V3 factory contract address\n', '    /// @param key The PoolKey\n', '    /// @return pool The contract address of the V3 pool\n', '    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n', '        require(key.token0 < key.token1);\n', '        pool = address(\n', '            uint256(\n', '                keccak256(\n', '                    abi.encodePacked(\n', "                        hex'ff',\n", '                        factory,\n', '                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n', '                        POOL_INIT_CODE_HASH\n', '                    )\n', '                )\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: @uniswap\\v3-periphery\\contracts\\interfaces\\INonfungiblePositionManager.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Non-fungible token for positions\n', '/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n', '/// and authorized.\n', 'interface INonfungiblePositionManager is\n', '    IPoolInitializer,\n', '    IPeripheryPayments,\n', '    IPeripheryImmutableState,\n', '    IERC721Metadata,\n', '    IERC721Enumerable,\n', '    IERC721Permit\n', '{\n', '    /// @notice Emitted when liquidity is increased for a position NFT\n', '    /// @dev Also emitted when a token is minted\n', '    /// @param tokenId The ID of the token for which liquidity was increased\n', '    /// @param liquidity The amount by which liquidity for the NFT position was increased\n', '    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n', '    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n', '    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n', '    /// @notice Emitted when liquidity is decreased for a position NFT\n', '    /// @param tokenId The ID of the token for which liquidity was decreased\n', '    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n', '    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n', '    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n', '    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n', '    /// @notice Emitted when tokens are collected for a position NFT\n', '    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n', '    /// @param tokenId The ID of the token for which underlying tokens were collected\n', '    /// @param recipient The address of the account that received the collected tokens\n', '    /// @param amount0 The amount of token0 owed to the position that was collected\n', '    /// @param amount1 The amount of token1 owed to the position that was collected\n', '    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Returns the position information associated with a given token ID.\n', '    /// @dev Throws if the token ID is not valid.\n', '    /// @param tokenId The ID of the token that represents the position\n', '    /// @return nonce The nonce for permits\n', '    /// @return operator The address that is approved for spending\n', '    /// @return token0 The address of the token0 for a specific pool\n', '    /// @return token1 The address of the token1 for a specific pool\n', '    /// @return fee The fee associated with the pool\n', '    /// @return tickLower The lower end of the tick range for the position\n', '    /// @return tickUpper The higher end of the tick range for the position\n', '    /// @return liquidity The liquidity of the position\n', '    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n', '    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n', '    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n', '    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n', '    function positions(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (\n', '            uint96 nonce,\n', '            address operator,\n', '            address token0,\n', '            address token1,\n', '            uint24 fee,\n', '            int24 tickLower,\n', '            int24 tickUpper,\n', '            uint128 liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '\n', '    struct MintParams {\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '        int24 tickLower;\n', '        int24 tickUpper;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        address recipient;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Creates a new position wrapped in a NFT\n', '    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n', '    /// a method does not exist, i.e. the pool is assumed to be initialized.\n', '    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n', '    /// @return tokenId The ID of the token that represents the minted position\n', '    /// @return liquidity The amount of liquidity for this position\n', '    /// @return amount0 The amount of token0\n', '    /// @return amount1 The amount of token1\n', '    function mint(MintParams calldata params)\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 tokenId,\n', '            uint128 liquidity,\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        );\n', '\n', '    struct IncreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n', '    /// @param params tokenId The ID of the token for which liquidity is being increased,\n', '    /// amount0Desired The desired amount of token0 to be spent,\n', '    /// amount1Desired The desired amount of token1 to be spent,\n', '    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n', '    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n', '    /// deadline The time by which the transaction must be included to effect the change\n', '    /// @return liquidity The new liquidity amount as a result of the increase\n', '    /// @return amount0 The amount of token0 to acheive resulting liquidity\n', '    /// @return amount1 The amount of token1 to acheive resulting liquidity\n', '    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n', '        external\n', '        payable\n', '        returns (\n', '            uint128 liquidity,\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        );\n', '\n', '    struct DecreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint128 liquidity;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n', '    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n', '    /// amount The amount by which liquidity will be decreased,\n', '    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n', '    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n', '    /// deadline The time by which the transaction must be included to effect the change\n', "    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n", "    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n", '    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n', '        external\n', '        payable\n', '        returns (uint256 amount0, uint256 amount1);\n', '\n', '    struct CollectParams {\n', '        uint256 tokenId;\n', '        address recipient;\n', '        uint128 amount0Max;\n', '        uint128 amount1Max;\n', '    }\n', '\n', '    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n', '    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n', '    /// recipient The account that should receive the tokens,\n', '    /// amount0Max The maximum amount of token0 to collect,\n', '    /// amount1Max The maximum amount of token1 to collect\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n', '    /// must be collected first.\n', '    /// @param tokenId The ID of the token that is being burned\n', '    function burn(uint256 tokenId) external payable;\n', '}\n', '\n', '// File: @uniswap\\v3-periphery\\contracts\\interfaces\\IMulticall.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '/// @title Multicall interface\n', '/// @notice Enables calling multiple methods in a single call to the contract\n', 'interface IMulticall {\n', '    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n', '    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n', '    /// @param data The encoded function data for each of the calls to make to this contract\n', '    /// @return results The results from each of the calls passed in via data\n', '    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n', '}\n', '\n', '// File: contracts\\farming\\FarmMain.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FarmMain is IFarmMain {\n', '\n', '    // percentage\n', '    uint256 public override constant ONE_HUNDRED = 1e18;\n', '    // event that tracks contracts deployed for the given reward token\n', '    event RewardToken(address indexed rewardTokenAddress);\n', '    // new or transferred farming position event\n', '    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\n', '    // event that tracks involved tokens for this contract\n', '    event SetupToken(address indexed mainToken, address indexed involvedToken);\n', '    // factory address that will create clones of this contract\n', '    address public _factory;\n', '    // address of the extension of this contract\n', '    address public _extension;\n', '    // address of the reward token\n', '    address public override _rewardTokenAddress;\n', '    // address of the NonfungblePositionManager used for gen2\n', '    INonfungiblePositionManager public nonfungiblePositionManager;\n', '    // mapping containing all the currently available farming setups info\n', '    mapping(uint256 => FarmingSetupInfo) private _setupsInfo;\n', '    // counter for the farming setup info\n', '    uint256 public _farmingSetupsInfoCount;\n', '    // mapping containing all the currently available farming setups\n', '    mapping(uint256 => FarmingSetup) private _setups;\n', '    // counter for the farming setups\n', '    uint256 public _farmingSetupsCount;\n', '    // mapping containing all the positions\n', '    mapping(uint256 => FarmingPosition) private _positions;\n', '    // mapping containing the reward per token per setup per block\n', '    mapping(uint256 => uint256) private _rewardPerTokenPerSetup;\n', '    // mapping containing the reward per token paid per position\n', '    mapping(uint256 => uint256) private _rewardPerTokenPaid;\n', '    // mapping containing all the number of opened positions for each setups\n', '    mapping(uint256 => uint256) private _setupPositionsCount;\n', '    // mapping containing all the reward received/paid per setup\n', '    mapping(uint256 => uint256) public _rewardReceived;\n', '    mapping(uint256 => uint256) public _rewardPaid;\n', '\n', '    address private _WETH;\n', '\n', '    /** Modifiers. */\n', '\n', '    /** @dev byExtension modifier used to check for unauthorized changes. */\n', '    modifier byExtension() {\n', '        require(msg.sender == _extension, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\n', '    modifier byPositionOwner(uint256 positionId) {\n', '        require(_positions[positionId].uniqueOwner == msg.sender && _positions[positionId].creationBlock != 0, "Not owned");\n', '        _;\n', '    }\n', '\n', '    /** @dev activeSetupOnly modifier used to check for function calls only if the setup is active. */\n', '    modifier activeSetupOnly(uint256 setupIndex) {\n', '        require(_setups[setupIndex].active, "Setup not active");\n', '        require(_setups[setupIndex].startBlock <= block.number && _setups[setupIndex].endBlock > block.number, "Invalid setup");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    /** Extension methods */\n', '\n', '    /** @dev initializes the farming contract.\n', '      * @param extension extension address.\n', '      * @param extensionInitData lm extension init payload.\n', '      * @param uniswapV3NonfungiblePositionManager Uniswap V3 Nonfungible Position Manager address.\n', '      * @param rewardTokenAddress address of the reward token.\n', '      * @param farmingSetupInfosBytes optional initial farming Setup Info\n', '      * @return extensionReturnCall result of the extension initialization function, if it was called.\n', '     */\n', '    function init(address extension, bytes memory extensionInitData, address uniswapV3NonfungiblePositionManager, address rewardTokenAddress, bytes memory farmingSetupInfosBytes) public returns(bytes memory extensionReturnCall) {\n', '        require(_factory == address(0), "Already initialized");\n', '        require((_extension = extension) != address(0), "extension");\n', '        _factory = msg.sender;\n', '        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\n', '        if (keccak256(extensionInitData) != keccak256("")) {\n', '            extensionReturnCall = _call(_extension, extensionInitData);\n', '        }\n', '        _WETH = (nonfungiblePositionManager = INonfungiblePositionManager(uniswapV3NonfungiblePositionManager)).WETH9();\n', '        if(farmingSetupInfosBytes.length > 0) {\n', '            FarmingSetupInfo[] memory farmingSetupInfos = abi.decode(farmingSetupInfosBytes, (FarmingSetupInfo[]));\n', '            for(uint256 i = 0; i < farmingSetupInfos.length; i++) {\n', '                _setOrAddFarmingSetupInfo(farmingSetupInfos[i], true, false, 0);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) public override byExtension {\n', '        for (uint256 i = 0; i < farmingSetups.length; i++) {\n', '            _setOrAddFarmingSetupInfo(farmingSetups[i].info, farmingSetups[i].add, farmingSetups[i].disable, farmingSetups[i].index);\n', '        }\n', '    }\n', '\n', '    function finalFlush(address[] calldata tokens, uint256[] calldata amounts) public {\n', '        for(uint256 i = 0; i < _farmingSetupsCount; i++) {\n', '            require(_setupPositionsCount[i] == 0 && !_setups[i].active && _setups[i].totalSupply == 0, "Not Empty");\n', '        }\n', '        (,,, address receiver,) = IFarmExtension(_extension).data();\n', '        require(tokens.length == amounts.length, "length");\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            uint256 amount = amounts[i];\n', '            require(receiver != address(0));\n', '            if(token == address(0)) {\n', '                (bool result,) = receiver.call{value : amount}("");\n', '                require(result, "ETH");\n', '            } else {\n', '                _safeTransfer(token, receiver, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** Public methods */\n', '\n', '    /** @dev returns the position with the given id.\n', '      * @param positionId id of the position.\n', '      * @return farming position with the given id.\n', '     */\n', '    function position(uint256 positionId) public override view returns (FarmingPosition memory) {\n', '        return _positions[positionId];\n', '    }\n', '\n', '    function setup(uint256 setupIndex) public override view returns (FarmingSetup memory, FarmingSetupInfo memory) {\n', '        return (_setups[setupIndex], _setupsInfo[_setups[setupIndex].infoIndex]);\n', '    }\n', '\n', '    function setups() public override view returns (FarmingSetup[] memory) {\n', '        FarmingSetup[] memory farmingSetups = new FarmingSetup[](_farmingSetupsCount);\n', '        for (uint256 i = 0; i < _farmingSetupsCount; i++) {\n', '            farmingSetups[i] = _setups[i];\n', '        }\n', '        return farmingSetups;\n', '    }\n', '\n', '    function activateSetup(uint256 setupInfoIndex) public {\n', '        require(_setupsInfo[setupInfoIndex].renewTimes > 0 && !_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active, "Invalid toggle.");\n', '        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\n', '    }\n', '\n', '    function toggleSetup(uint256 setupInfoIndex) public {\n', '        uint256 setupIndex = _setupsInfo[setupInfoIndex].lastSetupIndex;\n', '        require(_setups[setupIndex].active && block.number > _setups[setupIndex].endBlock, "Invalid toggle.");\n', '        _toggleSetup(setupIndex);\n', '        _tryClearSetup(setupIndex);\n', '    }\n', '\n', '    function openPosition(FarmingPositionRequest memory request) public override payable returns(uint256 positionId) {\n', '        if(!_setups[request.setupIndex].active) {\n', '            activateSetup(_setups[request.setupIndex].infoIndex);\n', '        }\n', '        require(_setups[request.setupIndex].active, "Setup not active");\n', '        require(_setups[request.setupIndex].startBlock <= block.number && _setups[request.setupIndex].endBlock > block.number, "Invalid setup");\n', '        // retrieve the unique owner\n', '        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\n', '        // create the position id\n', '        positionId = uint256(keccak256(abi.encode(uniqueOwner, request.setupIndex)));\n', '        require(_positions[positionId].creationBlock == 0, "Invalid open");\n', '        uint128 liquidityAmount = _addLiquidity(request.setupIndex, request);\n', '        _updateFreeSetup(request.setupIndex, liquidityAmount, positionId, false);\n', '        _positions[positionId] = FarmingPosition({\n', '            uniqueOwner: uniqueOwner,\n', '            setupIndex : request.setupIndex,\n', '            liquidityPoolTokenAmount: liquidityAmount,\n', '            reward: 0,\n', '            creationBlock: block.number\n', '        });\n', '        _setupPositionsCount[request.setupIndex] += 1;\n', '        emit Transfer(positionId, address(0), uniqueOwner);\n', '    }\n', '\n', '    function addLiquidity(uint256 positionId, FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) byPositionOwner(positionId) {\n', '        // retrieve farming position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        FarmingSetup storage chosenSetup = _setups[farmingPosition.setupIndex];\n', '        uint128 liquidityAmount = _addLiquidity(farmingPosition.setupIndex, request);\n', '        // rebalance the reward per token\n', '        _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((block.number - chosenSetup.lastUpdateBlock) * chosenSetup.rewardPerBlock) * 1e18) / chosenSetup.totalSupply;\n', '        farmingPosition.reward = calculateFreeFarmingReward(positionId, false);\n', '        _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\n', '        farmingPosition.liquidityPoolTokenAmount += liquidityAmount;\n', '        // update the last block update variablex\n', '        chosenSetup.lastUpdateBlock = block.number;\n', '        chosenSetup.totalSupply += liquidityAmount;\n', '    }\n', '\n', '\n', '    /** @dev this function allows a user to withdraw the reward.\n', '      * @param positionId farming position id.\n', '     */\n', '    function withdrawReward(uint256 positionId) external byPositionOwner(positionId) {\n', '        _withdrawReward(positionId, 0);\n', '    }\n', '\n', '    function _withdrawReward(uint256 positionId, uint128 liquidityToRemove) private {\n', '        // retrieve farming position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        FarmingSetup storage farmingSetup = _setups[farmingPosition.setupIndex];\n', '        uint256 reward = farmingPosition.reward;\n', '        uint256 currentBlock = block.number;\n', '        // rebalance setup\n', '        currentBlock = currentBlock > farmingSetup.endBlock ? farmingSetup.endBlock : currentBlock;\n', '        _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((currentBlock - farmingSetup.lastUpdateBlock) * farmingSetup.rewardPerBlock) * 1e18) / farmingSetup.totalSupply;\n', '        reward = calculateFreeFarmingReward(positionId, false);\n', '        _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\n', '        farmingPosition.reward = 0;\n', '        // update the last block update variable\n', '        farmingSetup.lastUpdateBlock = currentBlock;\n', '        _safeTransfer(_rewardTokenAddress, farmingPosition.uniqueOwner, reward);\n', '\n', '        _retrieveGen2LiquidityAndFees(positionId, farmingSetup.objectId, reward, farmingPosition.uniqueOwner, liquidityToRemove);\n', '\n', '        _rewardPaid[farmingPosition.setupIndex] += reward;\n', '        if (farmingSetup.endBlock <= block.number && farmingSetup.active) {\n', '            _toggleSetup(farmingPosition.setupIndex);\n', '        }\n', '    }\n', '\n', '    function withdrawLiquidity(uint256 positionId, uint128 removedLiquidity) byPositionOwner(positionId) public {\n', '        // retrieve farming position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        // current owned liquidity\n', '        require(\n', '            farmingPosition.creationBlock != 0 &&\n', '            removedLiquidity <= farmingPosition.liquidityPoolTokenAmount &&\n', '            farmingPosition.uniqueOwner == msg.sender,\n', '            "Invalid withdraw"\n', '        );\n', '        _withdrawReward(positionId, removedLiquidity);\n', '        _setups[farmingPosition.setupIndex].totalSupply -= removedLiquidity;\n', '        farmingPosition.liquidityPoolTokenAmount -= removedLiquidity;\n', '        // delete the farming position after the withdraw\n', '        if (farmingPosition.liquidityPoolTokenAmount == 0) {\n', '            _setupPositionsCount[farmingPosition.setupIndex] -= 1;\n', '            _tryClearSetup(farmingPosition.setupIndex);\n', '            delete _positions[positionId];\n', '        }\n', '    }\n', '\n', '    function _tryClearSetup(uint256 setupIndex) private {\n', '        if (_setupPositionsCount[setupIndex] == 0 && !_setups[setupIndex].active && _setups[setupIndex].objectId != 0) {\n', '            uint256 objectId = _setups[setupIndex].objectId;\n', '            address(nonfungiblePositionManager).call(abi.encodeWithSelector(nonfungiblePositionManager.collect.selector, INonfungiblePositionManager.CollectParams({\n', '                tokenId: objectId,\n', '                recipient: address(this),\n', '                amount0Max: 0xffffffffffffffffffffffffffffffff,\n', '                amount1Max: 0xffffffffffffffffffffffffffffffff\n', '            })));\n', '            nonfungiblePositionManager.burn(objectId);\n', '            delete _setups[setupIndex];\n', '        }\n', '    }\n', '\n', '    function calculateFreeFarmingReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\n', '        FarmingPosition memory farmingPosition = _positions[positionId];\n', '        reward = ((_rewardPerTokenPerSetup[farmingPosition.setupIndex] - _rewardPerTokenPaid[positionId]) * farmingPosition.liquidityPoolTokenAmount) / 1e18;\n', '        if (isExt) {\n', '            uint256 currentBlock = block.number < _setups[farmingPosition.setupIndex].endBlock ? block.number : _setups[farmingPosition.setupIndex].endBlock;\n', '            uint256 lastUpdateBlock = _setups[farmingPosition.setupIndex].lastUpdateBlock < _setups[farmingPosition.setupIndex].startBlock ? _setups[farmingPosition.setupIndex].startBlock : _setups[farmingPosition.setupIndex].lastUpdateBlock;\n', '            uint256 rpt = (((currentBlock - lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\n', '            reward += (rpt * farmingPosition.liquidityPoolTokenAmount) / 1e18;\n', '        }\n', '        reward += farmingPosition.reward;\n', '    }\n', '\n', '    /// @dev only for gen2, where fees are taken out from the nft. \n', '    /// @notice calculates the amount of unclaimed fees of a FarmingPosition\n', '    function calculateTradingFees(uint256 positionId, uint256 reward, uint128 tokensOwed0, uint128 tokensOwed1) public view returns (uint256 token0Fees, uint256 token1Fees) {\n', '        FarmingPosition memory farmingPosition = _positions[positionId];\n', '        FarmingSetup memory chosenSetup = _setups[farmingPosition.setupIndex];\n', '\n', '        uint256 lastRedeemeableBlock = block.number > chosenSetup.endBlock ? chosenSetup.endBlock : block.number;\n', '        uint256 percentageOfFeesOwnedByPosition = \n', '        reward * ONE_HUNDRED / (((chosenSetup.rewardPerBlock * (lastRedeemeableBlock - chosenSetup.startBlock)) - _rewardPaid[farmingPosition.setupIndex]));\n', '\n', '        // the following needs to be done as to fetch up to date fees information from the NFT\n', '        // tokensOwed0 and 1 represent fees owed for that NFT\n', '        if(tokensOwed0 == 0 && tokensOwed1 == 0) {\n', '            (,,,,,,,,,, tokensOwed0, tokensOwed1) = INonfungiblePositionManager(nonfungiblePositionManager).positions(_setups[_positions[positionId].setupIndex].objectId);\n', '        }\n', '        token0Fees = (tokensOwed0 * percentageOfFeesOwnedByPosition) / ONE_HUNDRED;\n', '        token1Fees = (tokensOwed1 * percentageOfFeesOwnedByPosition) / ONE_HUNDRED;\n', '    }\n', '\n', '    /** Private methods */\n', '\n', '    function _setOrAddFarmingSetupInfo(FarmingSetupInfo memory info, bool add, bool disable, uint256 setupIndex) private {\n', '        FarmingSetupInfo memory farmingSetupInfo = info;\n', '\n', '        if(add || !disable) {\n', '            farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes + 1;\n', '            if(farmingSetupInfo.renewTimes == 0) {\n', '                farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes - 1;\n', '            }\n', '        }\n', '\n', '        if (add) {\n', '            require(\n', '                farmingSetupInfo.liquidityPoolTokenAddress != address(0) &&\n', '                farmingSetupInfo.originalRewardPerBlock > 0,\n', '                "Invalid setup configuration"\n', '            );\n', '            _checkTicks(farmingSetupInfo.tickLower, farmingSetupInfo.tickUpper);\n', '            address[] memory tokenAddresses = new address[](2);\n', '            tokenAddresses[0] = IUniswapV3Pool(info.liquidityPoolTokenAddress).token0();\n', '            tokenAddresses[1] = IUniswapV3Pool(info.liquidityPoolTokenAddress).token1();\n', '            bool mainTokenFound = false;\n', '            bool ethTokenFound = false;\n', '            for(uint256 z = 0; z < tokenAddresses.length; z++) {\n', '                if(tokenAddresses[z] == _WETH) {\n', '                    ethTokenFound = true;\n', '                }\n', '                if(tokenAddresses[z] == farmingSetupInfo.mainTokenAddress) {\n', '                    mainTokenFound = true;\n', '                } else {\n', '                    emit SetupToken(farmingSetupInfo.mainTokenAddress, tokenAddresses[z]);\n', '                }\n', '            }\n', '            require(mainTokenFound, "No main token");\n', '            require(!farmingSetupInfo.involvingETH || ethTokenFound, "No ETH token");\n', '            farmingSetupInfo.setupsCount = 0;\n', '            _setupsInfo[_farmingSetupsInfoCount] = farmingSetupInfo;\n', '            _setups[_farmingSetupsCount] = FarmingSetup(_farmingSetupsInfoCount, false, 0, 0, 0, 0, farmingSetupInfo.originalRewardPerBlock, 0);\n', '            _setupsInfo[_farmingSetupsInfoCount].lastSetupIndex = _farmingSetupsCount;\n', '            _farmingSetupsInfoCount += 1;\n', '            _farmingSetupsCount += 1;\n', '            return;\n', '        }\n', '\n', '        FarmingSetup storage setup = _setups[setupIndex];\n', '        farmingSetupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\n', '\n', '        if(disable) {\n', '            require(setup.active, "Not possible");\n', '            _toggleSetup(setupIndex);\n', '            return;\n', '        }\n', '\n', '        info.renewTimes -= 1;\n', '\n', '        if (setup.active) {\n', '            setup = _setups[setupIndex];\n', '            if(block.number < setup.endBlock) {\n', '                uint256 difference = info.originalRewardPerBlock < farmingSetupInfo.originalRewardPerBlock ? farmingSetupInfo.originalRewardPerBlock - info.originalRewardPerBlock : info.originalRewardPerBlock - farmingSetupInfo.originalRewardPerBlock;\n', '                uint256 duration = setup.endBlock - block.number;\n', '                uint256 amount = difference * duration;\n', '                if (amount > 0) {\n', '                    if (info.originalRewardPerBlock > farmingSetupInfo.originalRewardPerBlock) {\n', '                        require(_ensureTransfer(amount), "Insufficient reward in extension.");\n', '                        _rewardReceived[setupIndex] += amount;\n', '                    }\n', '                    _updateFreeSetup(setupIndex, 0, 0, false);\n', '                    setup.rewardPerBlock = info.originalRewardPerBlock;\n', '                }\n', '            }\n', '            _setupsInfo[_setups[setupIndex].infoIndex].originalRewardPerBlock = info.originalRewardPerBlock;\n', '        }\n', '        if(_setupsInfo[_setups[setupIndex].infoIndex].renewTimes > 0) {\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = info.renewTimes;\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(FarmingSetup memory setup, FarmingPositionRequest memory request) private {\n', '        address[] memory tokens = new address[](2);\n', '        tokens[0] = IUniswapV3Pool(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress).token0();\n', '        tokens[1] = IUniswapV3Pool(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress).token1();\n', '        uint256[] memory tokenAmounts = new uint256[](2);\n', '        tokenAmounts[0] = request.amount0;\n', '        tokenAmounts[1] = request.amount1;\n', '        require((_setupsInfo[setup.infoIndex].mainTokenAddress == tokens[0] ? tokenAmounts[0] : tokenAmounts[1]) >= _setupsInfo[setup.infoIndex].minStakeable, "Invalid liquidity.");\n', '        // iterate the tokens and perform the transferFrom and the approve\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            if(_setupsInfo[setup.infoIndex].involvingETH && _WETH == tokens[i]) {\n', '                require(msg.value == tokenAmounts[i], "Incorrect eth value");\n', '            } else {\n', '                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\n', '                _safeApprove(tokens[i], address(nonfungiblePositionManager), tokenAmounts[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @dev addliquidity only for gen2\n', '    function _addLiquidity(uint256 setupIndex, FarmingPositionRequest memory request) private returns(uint128 liquidityAmount) {\n', '        _transferToMeAndCheckAllowance(_setups[setupIndex], request);\n', '\n', '        FarmingSetupInfo memory setupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\n', '        bytes[] memory data = new bytes[](setupInfo.involvingETH ? 2 : 1);\n', '\n', '        address token0 = IUniswapV3Pool(setupInfo.liquidityPoolTokenAddress).token0();\n', '        address token1 = IUniswapV3Pool(setupInfo.liquidityPoolTokenAddress).token1();\n', '        uint256 ethValue = setupInfo.involvingETH ? token0 == _WETH ? request.amount0 : request.amount1 : 0;\n', '        uint256 amount0;\n', '        uint256 amount1;\n', '\n', '        if(setupInfo.involvingETH) {\n', '            data[1] = abi.encodeWithSelector(nonfungiblePositionManager.refundETH.selector);\n', '        }\n', '        if(_setupPositionsCount[setupIndex] == 0 && _setups[setupIndex].objectId == 0) {\n', '            data[0] = abi.encodeWithSelector(nonfungiblePositionManager.mint.selector, INonfungiblePositionManager.MintParams({\n', '                token0: token0, \n', '                token1: token1,\n', '                fee: IUniswapV3Pool(setupInfo.liquidityPoolTokenAddress).fee(),\n', '                tickLower: setupInfo.tickLower, \n', '                tickUpper: setupInfo.tickUpper,\n', '                amount0Desired: request.amount0, \n', '                amount1Desired: request.amount1,\n', '                amount0Min: 0,\n', '                amount1Min: 0,\n', '                recipient: address(this),\n', '                deadline: block.timestamp + 10000\n', '            }));\n', '            (_setups[setupIndex].objectId, liquidityAmount, amount0, amount1) = abi.decode(IMulticall(address(nonfungiblePositionManager)).multicall{ value: ethValue }(data)[0], (uint256, uint128, uint256, uint256));\n', '        } else {\n', '            data[0] = abi.encodeWithSelector(nonfungiblePositionManager.increaseLiquidity.selector, INonfungiblePositionManager.IncreaseLiquidityParams({\n', '                tokenId: _setups[request.setupIndex].objectId, \n', '                amount0Desired: request.amount0, \n', '                amount1Desired: request.amount1,\n', '                amount0Min: 0,\n', '                amount1Min: 0,\n', '                deadline: block.timestamp + 10000\n', '            }));\n', '            (liquidityAmount, amount0, amount1) = abi.decode(IMulticall(address(nonfungiblePositionManager)).multicall{ value : ethValue }(data)[0], (uint128, uint256, uint256));\n', '        }\n', '\n', '        if(amount0 < request.amount0){\n', '            _safeTransfer(setupInfo.involvingETH && token0 == _WETH ? address(0) : token0, msg.sender, request.amount0 - amount0);\n', '        }\n', '\n', '        if(amount1 < request.amount1){\n', '            _safeTransfer(setupInfo.involvingETH && token1 == _WETH ? address(0) : token1, msg.sender, request.amount1 - amount1);\n', '        }\n', '    }\n', '\n', '    /** @dev updates the free setup with the given index.\n', "      * @param setupIndex index of the setup that we're updating.\n", "      * @param amount amount of liquidity that we're adding/removeing.\n", '      * @param positionId position id.\n', "      * @param fromExit if it's from an exit or not.\n", '     */\n', '    function _updateFreeSetup(uint256 setupIndex, uint128 amount, uint256 positionId, bool fromExit) private {\n', '        uint256 currentBlock = block.number < _setups[setupIndex].endBlock ? block.number : _setups[setupIndex].endBlock;\n', '        if (_setups[setupIndex].totalSupply != 0) {\n', '            uint256 lastUpdateBlock = _setups[setupIndex].lastUpdateBlock < _setups[setupIndex].startBlock ? _setups[setupIndex].startBlock : _setups[setupIndex].lastUpdateBlock;\n', '            _rewardPerTokenPerSetup[setupIndex] += (((currentBlock - lastUpdateBlock) * _setups[setupIndex].rewardPerBlock) * 1e18) / _setups[setupIndex].totalSupply;\n', '        }\n', '        // update the last block update variable\n', '        _setups[setupIndex].lastUpdateBlock = currentBlock;\n', '        if (positionId != 0) {\n', '            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[setupIndex];\n', '        }\n', '        if (amount > 0) {\n', '            fromExit ? _setups[setupIndex].totalSupply -= amount : _setups[setupIndex].totalSupply += amount;\n', '        }\n', '    }\n', '\n', '    function _toggleSetup(uint256 setupIndex) private {\n', '        FarmingSetup storage setup = _setups[setupIndex];\n', '        // require(!setup.active || block.number >= setup.endBlock, "Not valid activation");\n', '\n', '        require(block.number > _setupsInfo[setup.infoIndex].startBlock, "Too early for this setup");\n', '\n', '        if (setup.active && block.number >= setup.endBlock && _setupsInfo[setup.infoIndex].renewTimes == 0) {\n', '            setup.active = false;\n', '            return;\n', '        } else if (block.number >= setup.startBlock && block.number < setup.endBlock && setup.active) {\n', '            setup.active = false;\n', '            _setupsInfo[setup.infoIndex].renewTimes = 0;\n', '            uint256 amount = (setup.endBlock - block.number) * setup.rewardPerBlock;\n', '            setup.endBlock = block.number;\n', '            _updateFreeSetup(setupIndex, 0, 0, false);\n', '            _rewardReceived[setupIndex] -= amount;\n', '            _giveBack(amount);\n', '            return;\n', '        }\n', '\n', '        bool wasActive = setup.active;\n', '        setup.active = _ensureTransfer(setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration);\n', '\n', '        if (setup.active && wasActive) {\n', '            _rewardReceived[_farmingSetupsCount] = setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration;\n', '            // set new setup\n', '            _setups[_farmingSetupsCount] = abi.decode(abi.encode(setup), (FarmingSetup));\n', '            // update old setup\n', '            _setups[setupIndex].active = false;\n', '            // update new setup\n', '            _setupsInfo[setup.infoIndex].renewTimes -= 1;\n', '            _setupsInfo[setup.infoIndex].setupsCount += 1;\n', '            _setupsInfo[setup.infoIndex].lastSetupIndex = _farmingSetupsCount;\n', '            _setups[_farmingSetupsCount].startBlock = block.number;\n', '            _setups[_farmingSetupsCount].endBlock = block.number + _setupsInfo[_setups[_farmingSetupsCount].infoIndex].blockDuration;\n', '            _setups[_farmingSetupsCount].objectId = 0;\n', '            _setups[_farmingSetupsCount].totalSupply = 0;\n', '            _farmingSetupsCount += 1;\n', '        } else if (setup.active && !wasActive) {\n', '            _rewardReceived[setupIndex] = setup.rewardPerBlock * _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\n', '            // update new setup\n', '            _setups[setupIndex].startBlock = block.number;\n', '            _setups[setupIndex].endBlock = block.number + _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\n', '            _setups[setupIndex].totalSupply = 0;\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes -= 1;\n', '        } else {\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = 0;\n', '        }\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        if(value == 0) {\n', '            return;\n', '        }\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        if(value == 0) {\n', '            return;\n', '        }\n', '        if(erc20TokenAddress == address(0)) {\n', '            (bool result,) = to.call{value : value}("");\n', '            require(result, "TRANSFER_FAILED");\n', '            return;\n', '        }\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        if(value == 0) {\n', '            return;\n', '        }\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    /** @dev calls the contract at the given location using the given payload and returns the returnData.\n', '      * @param location location to call.\n', '      * @param payload call payload.\n', '      * @return returnData call return data.\n', '     */\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '\n', '    /** @dev gives back the reward to the extension.\n', '      * @param amount to give back.\n', '     */\n', '    function _giveBack(uint256 amount) private {\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if (_rewardTokenAddress == address(0)) {\n', '            IFarmExtension(_extension).backToYou{value : amount}(amount);\n', '        } else {\n', '            _safeApprove(_rewardTokenAddress, _extension, amount);\n', '            IFarmExtension(_extension).backToYou(amount);\n', '        }\n', '    }\n', '\n', '    /** @dev ensures the transfer from the contract to the extension.\n', '      * @param amount amount to transfer.\n', '     */\n', '    function _ensureTransfer(uint256 amount) private returns(bool) {\n', '        uint256 initialBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\n', '        uint256 expectedBalance = initialBalance + amount;\n', '        try IFarmExtension(_extension).transferTo(amount) {} catch {}\n', '        uint256 actualBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\n', '        if(actualBalance == expectedBalance) {\n', '            return true;\n', '        }\n', '        _giveBack(actualBalance - initialBalance);\n', '        return false;\n', '    }\n', '\n', '    /// @dev Common checks for valid tick inputs.\n', '    function _checkTicks(int24 tickLower, int24 tickUpper) private pure {\n', "        require(tickLower < tickUpper, 'TLU');\n", "        require(tickLower >= TickMath.MIN_TICK, 'TLM');\n", "        require(tickUpper <= TickMath.MAX_TICK, 'TUM');\n", '    }\n', '\n', '    // only called from gen2 code\n', '    function _retrieveGen2LiquidityAndFees(uint256 positionId, uint256 objectId, uint256 reward, address recipient, uint128 liquidityToRemove) private {\n', '        uint256 collectedAmount0 = 0;\n', '        uint256 collectedAmount1 = 0;\n', '\n', '        (uint256 wei0, uint256 wei1) = nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\n', '            tokenId: objectId,\n', '            recipient: address(0),\n', '            amount0Max: 1,\n', '            amount1Max: 1\n', '        }));\n', '\n', '        (uint256 feeAmount0, uint256 feeAmount1) = (0, 0);\n', '        if(reward > 0) {\n', '            (feeAmount0, feeAmount1) = calculateTradingFees(positionId, reward, 0, 0);\n', '        }\n', '        if(liquidityToRemove > 0) {\n', '            (collectedAmount0, collectedAmount1) = nonfungiblePositionManager.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams(\n', '                objectId,\n', '                liquidityToRemove,\n', '                0,\n', '                0,\n', '                block.timestamp + 10000\n', '            ));\n', '        }\n', '        collectedAmount0 += feeAmount0;\n', '        collectedAmount1 += feeAmount1;\n', '        (collectedAmount0, collectedAmount1) = _checkLastPosition(positionId, liquidityToRemove, collectedAmount0, collectedAmount1);\n', '        if (collectedAmount0 > 0 || collectedAmount1 > 0) {\n', '            address token0;\n', '            address token1;\n', '            (token0, token1, collectedAmount0, collectedAmount1) = _collect(positionId, collectedAmount0, collectedAmount1);\n', '            uint256 dfoFee0 = 0;\n', '            uint256 dfoFee1 = 0;\n', '            (uint256 exitFeePercentage, address exitFeeWallet) = IFarmFactory(_factory).feePercentageInfo();\n', '            if (exitFeePercentage > 0) {\n', '                dfoFee0 = (feeAmount0 * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '                dfoFee1 = (feeAmount1 * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '                _safeTransfer(token0, exitFeeWallet, dfoFee0);\n', '                _safeTransfer(token1, exitFeeWallet, dfoFee1);\n', '            }\n', '            _safeTransfer(token0, recipient, collectedAmount0 - dfoFee0);\n', '            _safeTransfer(token1, recipient, collectedAmount1 - dfoFee1);\n', '        }\n', '    }\n', '\n', '    function _checkLastPosition(uint256 positionId, uint128 liquidityToRemove, uint256 collectedAmount0, uint256 collectedAmount1) private view returns(uint256, uint256) {\n', '        FarmingPosition memory farmingPosition = _positions[positionId];\n', '        FarmingSetup memory farmingSetup = _setups[farmingPosition.setupIndex];\n', '        if(liquidityToRemove > 0 && liquidityToRemove == farmingPosition.liquidityPoolTokenAmount && (!farmingSetup.active || block.number > farmingSetup.endBlock) && _setupPositionsCount[farmingPosition.setupIndex] == 1) {\n', '            return (\n', '                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,\n', '                0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n', '            );\n', '        }\n', '        return (collectedAmount0, collectedAmount1);\n', '    }\n', '\n', '    function _collect(uint256 positionId, uint256 collectedAmount0, uint256 collectedAmount1) private returns (address token0, address token1, uint256 amount0, uint256 amount1) {\n', '        require(collectedAmount0 > 0 || collectedAmount1 > 0, "0 amount");\n', '        bool involvingETH = _setupsInfo[_setups[_positions[positionId].setupIndex].infoIndex].involvingETH;\n', '        bytes[] memory data = new bytes[](involvingETH ? 3 : 1);\n', '        data[0] = abi.encodeWithSelector(nonfungiblePositionManager.collect.selector, INonfungiblePositionManager.CollectParams({\n', '            tokenId: _setups[_positions[positionId].setupIndex].objectId,\n', '            recipient: involvingETH ? address(0) : address(this),\n', '            amount0Max: uint128(collectedAmount0),\n', '            amount1Max: uint128(collectedAmount1)\n', '        }));\n', '        (,, token0, token1, , , , , , , , ) = nonfungiblePositionManager.positions(_setups[_positions[positionId].setupIndex].objectId);\n', '        if(involvingETH) {\n', '            data[1] = abi.encodeWithSelector(nonfungiblePositionManager.unwrapWETH9.selector, 0, address(this));\n', '            data[2] = abi.encodeWithSelector(nonfungiblePositionManager.sweepToken.selector, token0 == _WETH ? token1 : token0, 0, address(this));\n', '            token0 = token0 == _WETH ? address(0) : token0;\n', '            token1 = token1 == _WETH ? address(0) : token1;\n', '        }\n', '        (amount0, amount1) = abi.decode(IMulticall(address(nonfungiblePositionManager)).multicall(data)[0], (uint256, uint256));\n', '    }\n', '}']