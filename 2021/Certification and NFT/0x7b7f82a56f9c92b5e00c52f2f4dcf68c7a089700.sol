['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'abstract contract IERC721 {\n', '    // Required methods\n', '    function totalSupply() public view virtual returns (uint256 total);\n', '\n', '    function balanceOf(address _owner)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint256 balance);\n', '\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        virtual\n', '        returns (address owner);\n', '\n', '    function approve(address _to, uint256 _tokenId) external virtual;\n', '\n', '    function transfer(address _to, uint256 _tokenId) external virtual;\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    ) external virtual;\n', '\n', '    // Events\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '    event Approval(address owner, address approved, uint256 tokenId);\n', '\n', '    // Optional\n', '    // function name() public view returns (string name);\n', '    // function symbol() public view returns (string symbol);\n', '    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n', '    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n', '\n', '    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n', '    function supportsInterface(bytes4 _interfaceID)\n', '        external\n', '        view\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', 'contract KanamitCore is IERC721, Ownable {\n', '    /*** EVENTS ***/\n', '    event Create(address owner, uint256 AssetId, uint256 hashUri, string uri);\n', '    event Transfer(address from, address to, uint256 tokenId);\n', '\n', '    struct Asset {\n', '        uint256 hashUri;\n', '    }\n', '\n', '    /*** STORAGE ***/\n', '    Asset[] assets;\n', '    mapping(uint256 => address) private AssetIndexToOwner; // map<assetId , addrOwner>\n', '    mapping(address => uint256) private OwnerAssetCount; // map<addrOwner, uintCount>\n', '    mapping(address => mapping(uint256 => uint256)) private OwnerAssets; // map<addrOwner, map<hashUri, assetId> >\n', '    mapping(uint256 => address) private AssetIndexToApproved; //map<assetId, addrApproved>\n', '    mapping(uint256 => uint256) private mapUriAssetId; //map<hashUri, AssetId>\n', '\n', '    constructor() public {\n', '        //初始化第一个元素；addressOwner 为address(0)， uri为空字符""，对应的AssetId为0；\n', '        uint256 hashUri = uint256(keccak256(abi.encodePacked("")));\n', '        Asset memory currAsset = Asset({hashUri: hashUri});\n', '        assets.push(currAsset);\n', '    }\n', '\n', '    /// @dev Assigns ownership of a specific Asset to an address.\n', '    function _transfer(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    ) internal {\n', '        uint256 hashUri = assets[_tokenId].hashUri;\n', "        // Since the number of Assets is capped to 2^32 we can't overflow this\n", '        OwnerAssetCount[_to]++;\n', '        OwnerAssets[_to][hashUri] = _tokenId;\n', '        mapUriAssetId[hashUri] = _tokenId;\n', '        // transfer ownership\n', '        AssetIndexToOwner[_tokenId] = _to;\n', "        // When creating new Assets _from is 0x0, but we can't account that address.\n", '        if (_from != address(0)) {\n', '            OwnerAssetCount[_from]--;\n', '            delete OwnerAssets[_from][hashUri];\n', '            // clear any previously approved ownership exchange\n', '            delete AssetIndexToApproved[_tokenId];\n', '        }\n', '        // Emit the transfer event.\n', '        Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function createAsset(address _owner, string memory _uri)\n', '        public\n', '        onlyOwner()\n', '        returns (uint256)\n', '    {\n', '        uint256 hashUri = uint256(keccak256(abi.encodePacked(_uri)));\n', '        uint256 assetId = getAssetId(_uri);\n', '        address currOwner = getUriOwner(_uri);\n', '\n', "        require(currOwner == address(0), 'asset already mint, found by owner');\n", "        require(assetId == 0, 'asset already mint, found by assetId');\n", '\n', '        Asset memory currAsset = Asset({hashUri: hashUri});\n', '        assets.push(currAsset);\n', '        uint256 newAssetId = assets.length - 1;\n', '\n', "        // It's probably never going to happen, 4 billion cats is A LOT, but\n", "        // let's just be 100% sure we never let this happen.\n", '        require(newAssetId == uint256(uint32(newAssetId)));\n', '\n', '        // emit the create event\n', '        Create(_owner, newAssetId, hashUri, _uri);\n', '\n', '        // This will assign ownership, and also emit the Transfer event as\n', '        // per ERC721 draft\n', '        _transfer(address(0), _owner, newAssetId);\n', '\n', '        return newAssetId;\n', '    }\n', '\n', '    bytes4 constant InterfaceSignature_ERC165 =\n', '        bytes4(keccak256("supportsInterface(bytes4)"));\n', '\n', '    bytes4 constant InterfaceSignature_ERC721 =\n', '        bytes4(keccak256("name()")) ^\n', '            bytes4(keccak256("symbol()")) ^\n', '            bytes4(keccak256("totalSupply()")) ^\n', '            bytes4(keccak256("balanceOf(address)")) ^\n', '            bytes4(keccak256("ownerOf(uint256)")) ^\n', '            bytes4(keccak256("approve(address,uint256)")) ^\n', '            bytes4(keccak256("transfer(address,uint256)")) ^\n', '            bytes4(keccak256("transferFrom(address,address,uint256)")) ^\n', '            bytes4(keccak256("tokensOfOwner(address)")) ^\n', '            bytes4(keccak256("tokenMetadata(uint256,string)"));\n', '\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return assets.length;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256 count)\n', '    {\n', '        return OwnerAssetCount[_owner];\n', '    }\n', '\n', '    function getAssetId(string memory uri)\n', '        public\n', '        view\n', '        returns (uint256 assetId)\n', '    {\n', '        uint256 hashUri = uint256(keccak256(abi.encodePacked(uri)));\n', '        assetId = mapUriAssetId[hashUri];\n', '    }\n', '\n', '    function getUriOwner(string memory uri)\n', '        public\n', '        view\n', '        returns (address addressOwner)\n', '    {\n', '        uint256 hashUri = uint256(keccak256(abi.encodePacked(uri)));\n', '        uint256 assetId = mapUriAssetId[hashUri];\n', '\n', '        if (assetId == 0) return address(0);\n', '\n', '        return AssetIndexToOwner[assetId];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId)\n', '        external\n', '        view\n', '        virtual\n', '        override\n', '        returns (address owner)\n', '    {\n', '        owner = AssetIndexToOwner[_tokenId];\n', '\n', '        require(owner != address(0));\n', '    }\n', '\n', '    function approve(address _to, uint256 _tokenId) external virtual override {\n', '        // Only an owner can grant transfer approval.\n', '        require(_owns(msg.sender, _tokenId));\n', '\n', '        // Register the approval (replacing any previous approval).\n', '        _approve(_tokenId, _to);\n', '\n', '        // Emit approval event.\n', '        Approval(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transfer(address _to, uint256 _tokenId) external virtual override {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any kitties (except very briefly\n', '        // after a gen0 cat is created and before it goes on auction).\n', '        require(_to != address(this));\n', '\n', '        // You can only send your own cat.\n', "        require(_owns(msg.sender, _tokenId), 'only owner can transfer');\n", '\n', '        // Reassign ownership, clear pending approvals, emit Transfer event.\n', '        _transfer(msg.sender, _to, _tokenId);\n', '    }\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _tokenId\n', '    ) external virtual override {\n', '        // Safety check to prevent against an unexpected 0x0 default.\n', '        require(_to != address(0));\n', '        // Disallow transfers to this contract to prevent accidental misuse.\n', '        // The contract should never own any kitties (except very briefly\n', '        // after a gen0 cat is created and before it goes on auction).\n', '        require(_to != address(this));\n', '        // Check for approval and valid ownership\n', '        require(_approvedFor(msg.sender, _tokenId));\n', '        require(_owns(_from, _tokenId));\n', '\n', '        // Reassign ownership (also clears pending approvals and emits Transfer event).\n', '        _transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function _owns(address _claimant, uint256 _tokenId)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return AssetIndexToOwner[_tokenId] == _claimant;\n', '    }\n', '\n', '    function _approve(uint256 _tokenId, address _approved) internal {\n', '        AssetIndexToApproved[_tokenId] = _approved;\n', '    }\n', '\n', '    function _approvedFor(address _claimant, uint256 _tokenId)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return AssetIndexToApproved[_tokenId] == _claimant;\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceID)\n', '        external\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        // DEBUG ONLY\n', '        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n', '\n', '        return ((_interfaceID == InterfaceSignature_ERC165) ||\n', '            (_interfaceID == InterfaceSignature_ERC721));\n', '    }\n', '\n', '    function getAssetById(uint256 _id) external view returns (uint256 hashUri) {\n', '        Asset storage asset = assets[_id];\n', '\n', '        hashUri = asset.hashUri;\n', '    }\n', '\n', '    function getAsset(address owner, uint256 hashUri)\n', '        external\n', '        view\n', '        returns (uint256 assetId)\n', '    {\n', '        assetId = OwnerAssets[owner][hashUri];\n', '    }\n', '}']