['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./vendors/contracts/AbstractGovernor.sol";\n', 'import "./vendors/contracts/access/GovernanceOwnable.sol";\n', 'import "./vendors/libraries/SafeMath.sol";\n', '\n', 'contract GovernorPACT is AbstractGovernor, GovernanceOwnable {\n', '    enum VotingSettingsKeys {\n', '        DefaultPropose,\n', '        FastPropose,\n', '        MultiExecutable\n', '    }\n', '\n', '    // etherium - block_generation_frequency_ ~ 15s\n', '    // binance smart chain - block_generation_frequency_ ~ 4s\n', '    constructor(\n', '        address pact_,\n', '        uint256 block_generation_frequency_\n', '    ) AbstractGovernor("Governor PACT", pact_) GovernanceOwnable(address(this)) public {\n', '        _addAllowedTarget(address(this));\n', '        _addAllowedTarget(pact_);\n', '\n', '        _setVotingSettings(\n', '            uint(VotingSettingsKeys.DefaultPropose), // votingSettingsId\n', '            SafeMath.div(3 days, block_generation_frequency_),// votingPeriod\n', '            SafeMath.div(15 days, block_generation_frequency_),// expirationPeriod\n', '            10,// proposalMaxOperations\n', '            25,// quorumVotesDelimiter 4% of total PACTs\n', '            100// proposalThresholdDelimiter 1% of total PACTs\n', '        );\n', '        _setVotingSettings(\n', '            uint(VotingSettingsKeys.FastPropose), // votingSettingsId\n', '            SafeMath.div(1 hours, block_generation_frequency_),// votingPeriod\n', '            SafeMath.div(2 hours, block_generation_frequency_),// expirationPeriod\n', '            40,// proposalMaxOperations\n', '            5,// quorumVotesDelimiter 20% of total PACTs\n', '            20// proposalThresholdDelimiter 5% of total PACTs\n', '        );\n', '        _setVotingSettings(\n', '            uint(VotingSettingsKeys.MultiExecutable), // votingSettingsId\n', '            SafeMath.div(1 hours, block_generation_frequency_),// votingPeriod\n', '            SafeMath.div(365 days, block_generation_frequency_),// expirationPeriod\n', '            2,// proposalMaxOperations\n', '            5,// quorumVotesDelimiter 20% of total PACTs\n', '            20// proposalThresholdDelimiter 5% of total PACTs\n', '        );\n', '    }\n', '\n', '    function createDefaultPropose(\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas,\n', '        string memory description\n', '    ) public returns (uint) {\n', '        for (uint i = 0; i < targets.length; i++) {\n', '            require(allowedTargets[targets[i]], "GovernorPACT::createFastPropose: targets - supports only allowedTargets");\n', '        }\n', '        return _propose(\n', '            uint(VotingSettingsKeys.DefaultPropose),\n', '            targets,\n', '            values,\n', '            signatures,\n', '            calldatas,\n', '            description,\n', '            false\n', '        );\n', '    }\n', '\n', '    function createFastPropose(\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas,\n', '        string memory description\n', '    ) public returns (uint) {\n', '        for (uint i = 0; i < targets.length; i++) {\n', '            require(allowedTargets[targets[i]], "GovernorPACT::createFastPropose: targets - supports only allowedTargets");\n', '        }\n', '        return _propose(\n', '            uint(VotingSettingsKeys.FastPropose),\n', '            targets,\n', '            values,\n', '            signatures,\n', '            calldatas,\n', '            description,\n', '            false\n', '        );\n', '    }\n', '\n', '    function createMultiExecutablePropose(\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas,\n', '        string memory description\n', '    ) public returns (uint) {\n', '        for (uint i = 0; i < targets.length; i++) {\n', '            require(allowedTargets[targets[i]], "GovernorPACT::createMultiExecutablePropose: targets - supports only allowedTargets");\n', '        }\n', '        return _propose(\n', '            uint(VotingSettingsKeys.MultiExecutable),\n', '            targets,\n', '            values,\n', '            signatures,\n', '            calldatas,\n', '            description,\n', '            true\n', '        );\n', '    }\n', '\n', '    address[] internal allowedTargetsList;\n', '    mapping (address => bool) public allowedTargets;\n', '\n', '    function addAllowedTarget(address target) public onlyGovernance {\n', '        _addAllowedTarget(target);\n', '    }\n', '    function _addAllowedTarget(address target) internal {\n', '        if (allowedTargets[target] == false) {\n', '            allowedTargets[target] = true;\n', '            allowedTargetsList.push(target);\n', '        }\n', '    }\n', '\n', '    function getAllowedTargets() public view returns(address[] memory) {\n', '        return allowedTargetsList;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../interfaces/IDelegableERC20.sol";\n', 'import "./utils/Context.sol";\n', '\n', 'import "../libraries/SafeMath.sol";\n', '\n', '// Copied and modified from Compound code:\n', '// https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\n', 'abstract contract AbstractGovernor is Context {\n', '    using SafeMath for uint256;\n', '\n', '    string _name;\n', '    IDelegableERC20 public _token;\n', '\n', '    constructor(\n', '        string memory name_,\n', '        address token_\n', '    ) public {\n', '        _name = name_;\n', '        _token = IDelegableERC20(token_);\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /// @notice all VotingSettings\n', '    mapping (uint => VotingSettings) public _votingSettings;\n', '\n', '    /// @notice votingPeriod - The duration of voting on a proposal, in blocks\n', '    /// @notice expirationPeriod - The duration of execution on a proposal after voting, in blocks\n', '    /// @notice proposalMaxOperations - The maximum number of actions that can be included in a proposal\n', '    /// @notice quorumVotesDelimiter - Number for calculate count of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    /// @notice proposalThresholdDelimiter - Number for calculate count of votes required in order for a voter to become a proposer\n', '    struct VotingSettings {\n', '        bool isValue;\n', '        uint256 votingPeriod;\n', '        uint256 expirationPeriod;\n', '        uint256 proposalMaxOperations;\n', '        uint256 quorumVotesDelimiter;\n', '        uint256 proposalThresholdDelimiter;\n', '    }\n', '\n', '    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    function quorumVotes(uint256 votingSettingsId) public view returns (uint) {\n', '        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\n', '        require(votingSettings.isValue, "Governor::quorumVotes: incorrect votingSettingsId");\n', '        return _token.totalSupply() / votingSettings.quorumVotesDelimiter;\n', '    }\n', '\n', '    /// @notice The number of votes required in order for a voter to become a proposer\n', '    function proposalThreshold(uint256 votingSettingsId) public view returns (uint) {\n', '        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\n', '        require(votingSettings.isValue, "Governor::proposalThreshold: incorrect votingSettingsId");\n', '        return _token.totalSupply() / votingSettings.proposalThresholdDelimiter;\n', '    }\n', '\n', '    /// @notice The delay before voting on a proposal may take place, once proposed\n', '    function _setVotingSettings(\n', '        uint256 votingSettingsId,\n', '        uint256 votingPeriod,\n', '        uint256 expirationPeriod,\n', '        uint256 proposalMaxOperations,\n', '        uint256 quorumVotesDelimiter,\n', '        uint256 proposalThresholdDelimiter\n', '    ) internal {\n', '        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\n', '        require(votingSettings.isValue == false, "Governor::setVotingSettings: incorrect votingSettingsId");\n', '\n', '        require(votingPeriod > 0, "Governor::setVotingSettings: shoud be more then 0");\n', '        require(expirationPeriod > 0, "Governor::setVotingSettings: shoud be more then 0");\n', '        require(proposalMaxOperations > 0, "Governor::setVotingSettings: shoud be more then 0");\n', '        require(quorumVotesDelimiter > 0, "Governor::setVotingSettings: shoud be more then 0");\n', '        require(proposalThresholdDelimiter > 0, "Governor::setVotingSettings: shoud be more then 0");\n', '\n', '        VotingSettings memory newVotingSettings = VotingSettings({\n', '            isValue: true,\n', '            votingPeriod: votingPeriod,\n', '            expirationPeriod: expirationPeriod,\n', '            proposalMaxOperations: proposalMaxOperations,\n', '            quorumVotesDelimiter: quorumVotesDelimiter,\n', '            proposalThresholdDelimiter: proposalThresholdDelimiter\n', '        });\n', '\n', '        _votingSettings[votingSettingsId] = newVotingSettings;\n', '    }\n', '\n', '    function getVotingSettings(uint256 votingSettingsId) public view returns (VotingSettings memory) {\n', '        return _votingSettings[votingSettingsId];\n', '    }\n', '\n', '    /// @notice The total number of proposals\n', '    uint public _proposalCount;\n', '\n', '    /// @notice id -  Unique id for looking up a proposal\n', '    /// @notice proposer -  Creator of the proposal\n', '    /// @notice targets -  the ordered list of target addresses for calls to be made\n', '    /// @notice values -  The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n', '    /// @notice signatures -  The ordered list of function signatures to be called\n', '    /// @notice calldatas -  The ordered list of calldata to be passed to each call\n', '    /// @notice startBlock -  The block at which voting begins: holders must delegate their votes prior to this block\n', '    /// @notice endBlock -  The block at which voting ends: votes must be cast prior to this block\n', '    /// @notice expiredBlock -  The block at which successful, but not executed transactions is expired\n', '    /// @notice forVotes -  Current number of votes in favor of this proposal\n', '    /// @notice againstVotes -  Current number of votes in opposition to this proposal\n', '    /// @notice canceled -  Flag marking whether the proposal has been canceled\n', '    /// @notice executed -  Flag marking whether the proposal has been executed\n', '    /// @notice receipts -  Receipts of ballots for the entire set of voters\n', '    struct Proposal {\n', '        uint256 votingSettingsId;\n', '        uint id;\n', '        address proposer;\n', '        address[] targets;\n', '        uint[] values;\n', '        string[] signatures;\n', '        bytes[] calldatas;\n', '        uint startBlock;\n', '        uint endBlock;\n', '        uint expiredBlock;\n', '        uint forVotes;\n', '        uint againstVotes;\n', '        bool canceled;\n', '        bool executed;\n', '        mapping (address => Receipt) receipts;\n', '        bool isMultiExecutable;\n', '    }\n', '\n', '    /// @notice Ballot receipt record for a voter\n', '    /// @notice hasVoted - Whether or not a vote has been cast\n', '    /// @notice support - Whether or not the voter supports the proposal\n', '    /// @notice votes - The number of votes the voter had, which were cast\n', '    struct Receipt {\n', '        bool hasVoted;\n', '        bool support;\n', '        uint256 votes;\n', '    }\n', '\n', '    /// @notice Possible states that a proposal may be in\n', '    enum ProposalState {\n', '        Active,\n', '        Canceled,\n', '        Defeated,\n', '        Succeeded,\n', '        Expired,\n', '        Executed\n', '    }\n', '\n', '    /// @notice The official record of all proposals ever proposed\n', '    mapping (uint => Proposal) public _proposals;\n', '    /// @notice The official records of all proposals executions\n', '    mapping (uint => uint[]) public _proposalsExecutionBlocks;\n', '    /// @notice The latest proposal for each proposer\n', '    mapping (address => uint) public _latestProposalIds;\n', '\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\n', '    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n', '    bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,bool support)");\n', '\n', '    /// @notice An event emitted when a new proposal is created\n', '    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n', '\n', '    /// @notice An event emitted when a vote has been cast on a proposal\n', '    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n', '\n', '    /// @notice An event emitted when a proposal has been canceled\n', '    event ProposalCanceled(uint id);\n', '\n', '    /// @notice An event emitted when a proposal has been executed\n', '    event ProposalExecuted(uint id);\n', '\n', '    /// @notice An event emitted when a some proposals transaction has been executed\n', '    event ExecuteTransaction(address indexed target, uint value, string signature, bytes data);\n', '\n', '    /// @notice The delay before voting on a proposal may take place, once proposed\n', '    function _propose(\n', '        uint256 votingSettingsId,\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas,\n', '        string memory description,\n', '        bool isMultiExecutable\n', '    ) internal returns (uint) {\n', '        VotingSettings storage votingSettings = _votingSettings[votingSettingsId];\n', '        require(votingSettings.isValue, "Governor::propose: incorrect votingSettingsId");\n', '\n', '        require(\n', '            _token.getPriorVotes(\n', '                _msgSender(),\n', '                block.number.sub(1, "Governor::propose: block.number - Underflow")\n', '            ) > proposalThreshold(votingSettingsId),\n', '            "Governor::propose: proposer votes below proposal threshold"\n', '        );\n', '        require(\n', '            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n', '            "Governor::propose: proposal function information arity mismatch"\n', '        );\n', '        require(\n', '            targets.length != 0,\n', '            "Governor::propose: must provide actions"\n', '        );\n', '        require(\n', '            targets.length <= votingSettings.proposalMaxOperations,\n', '            "Governor::propose: too many actions"\n', '        );\n', '\n', '        uint startBlock = block.number;\n', '        uint endBlock = startBlock.add(votingSettings.votingPeriod, "Governor::propose: endBlock - Add Overflow");\n', '\n', '        _proposalCount++;\n', '        Proposal memory newProposal = Proposal({\n', '            votingSettingsId: votingSettingsId,\n', '            id: _proposalCount,\n', '            proposer: _msgSender(),\n', '            targets: targets,\n', '            values: values,\n', '            signatures: signatures,\n', '            calldatas: calldatas,\n', '            startBlock: startBlock,\n', '            endBlock: endBlock,\n', '            expiredBlock: endBlock.add(votingSettings.expirationPeriod, "Governor::propose: expiredBlock - Add Overflow"),\n', '            //forVotes: _token.getPriorVotes(_msgSender(), 0),\n', '            forVotes: 0,\n', '            againstVotes: 0,\n', '            canceled: false,\n', '            executed: false,\n', '            isMultiExecutable: isMultiExecutable\n', '        });\n', '\n', '        _proposals[newProposal.id] = newProposal;\n', '        _latestProposalIds[newProposal.proposer] = newProposal.id;\n', '        _castVote(newProposal.proposer, newProposal.id, true);\n', '\n', '        emit ProposalCreated(newProposal.id, _msgSender(), targets, values, signatures, calldatas, startBlock, endBlock, description);\n', '        return newProposal.id;\n', '    }\n', '\n', '    function execute(uint proposalId) public payable {\n', '        require(\n', '            state(proposalId) == ProposalState.Succeeded,\n', '            "Governor::execute: proposal can only be executed if it is Succeeded"\n', '        );\n', '        Proposal storage proposal = _proposals[proposalId];\n', '        _proposalsExecutionBlocks[proposalId].push(block.number);\n', '        if (!proposal.isMultiExecutable) {\n', '            proposal.executed = true;\n', '        }\n', '\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            _executeTransaction(\n', '                proposal.targets[i],\n', '                proposal.values[i],\n', '                proposal.signatures[i],\n', '                proposal.calldatas[i]\n', '            );\n', '        }\n', '        emit ProposalExecuted(proposalId);\n', '    }\n', '\n', '    function _executeTransaction(\n', '        address target,\n', '        uint value,\n', '        string memory signature,\n', '        bytes memory data\n', '    ) internal returns (\n', '        bytes memory\n', '    ) {\n', '        bytes memory callData;\n', '        if (bytes(signature).length == 0) {\n', '            callData = data;\n', '        } else {\n', '            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n', '        require(success, "Governor::_executeTransaction: Transaction execution reverted.");\n', '\n', '        emit ExecuteTransaction(target, value, signature, data);\n', '\n', '        return returnData;\n', '    }\n', '\n', '    function cancel(uint proposalId) public {\n', '        ProposalState state = state(proposalId);\n', '        require(state != ProposalState.Executed, "Governor::cancel: cannot cancel executed proposal");\n', '\n', '        Proposal storage proposal = _proposals[proposalId];\n', '\n', '        require(\n', '            _token.getPriorVotes(\n', '                proposal.proposer,\n', '                block.number.sub(1, "Governor::cancel: block.number - Underflow")\n', '            ) < proposalThreshold(proposal.votingSettingsId),\n', '            "Governor::cancel: proposer above threshold"\n', '        );\n', '\n', '        proposal.canceled = true;\n', '\n', '        emit ProposalCanceled(proposalId);\n', '    }\n', '\n', '    function getActions(\n', '        uint proposalId\n', '    ) public view returns (\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas\n', '    ) {\n', '        Proposal storage p = _proposals[proposalId];\n', '        return (p.targets, p.values, p.signatures, p.calldatas);\n', '    }\n', '\n', '    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\n', '        return _proposals[proposalId].receipts[voter];\n', '    }\n', '\n', '    function state(uint proposalId) public view returns (ProposalState) {\n', '        require(\n', '            _proposalCount >= proposalId && proposalId > 0,\n', '            "Governor::state: invalid proposal id"\n', '        );\n', '        Proposal storage proposal = _proposals[proposalId];\n', '\n', '        if (proposal.canceled) {\n', '            return ProposalState.Canceled;\n', '        } else if (proposal.executed) {\n', '            return ProposalState.Executed;\n', '        } else if (block.number <= proposal.endBlock) {\n', '            return ProposalState.Active;\n', '        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.votingSettingsId)) {\n', '            return ProposalState.Defeated;\n', '        } else if (block.number < proposal.expiredBlock) {\n', '            return ProposalState.Succeeded;\n', '        } else {\n', '            return ProposalState.Expired;\n', '        }\n', '    }\n', '\n', '    function castVote(uint proposalId, bool support) public {\n', '        return _castVote(_msgSender(), proposalId, support);\n', '    }\n', '\n', '    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(_name)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "Governor::castVoteBySig: invalid signature");\n', '        return _castVote(signatory, proposalId, support);\n', '    }\n', '\n', '    function _castVote(address voter, uint proposalId, bool support) internal {\n', '        require(state(proposalId) == ProposalState.Active, "Governor::_castVote: voting is closed");\n', '        Proposal storage proposal = _proposals[proposalId];\n', '        Receipt storage receipt = proposal.receipts[voter];\n', '        require(receipt.hasVoted == false, "Governor::_castVote: voter already voted");\n', '        uint256 votes = _token.getPriorVotes(voter, proposal.startBlock);\n', '\n', '        if (support) {\n', '            proposal.forVotes = proposal.forVotes.add(votes, "Governor::_castVote: votes - Add Overflow");\n', '        } else {\n', '            proposal.againstVotes = proposal.againstVotes.add(votes, "Governor::_castVote: votes - Add Overflow");\n', '        }\n', '\n', '        receipt.hasVoted = true;\n', '        receipt.support = support;\n', '        receipt.votes = votes;\n', '\n', '        emit VoteCast(voter, proposalId, support, votes);\n', '    }\n', '\n', '    function getChainId() internal pure returns (uint) {\n', '        uint chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../../interfaces/IGovernanceOwnable.sol";\n', '\n', 'abstract contract GovernanceOwnable is IGovernanceOwnable {\n', '    address private _governanceAddress;\n', '\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    constructor (address governance_) public {\n', '        require(governance_ != address(0), "Governance address should be not null");\n', '        _governanceAddress = governance_;\n', '        emit GovernanceSetTransferred(address(0), governance_);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current governanceAddress.\n', '     */\n', '    function governance() public view override returns (address) {\n', '        return _governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the governanceAddress.\n', '     */\n', '    modifier onlyGovernance() {\n', '        require(_governanceAddress == msg.sender, "Governance: caller is not the governance");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev SetGovernance of the contract to a new account (`newGovernance`).\n', '     * Can only be called by the current onlyGovernance.\n', '     */\n', '    function setGovernance(address newGovernance) public virtual override onlyGovernance {\n', '        require(newGovernance != address(0), "GovernanceOwnable: new governance is the zero address");\n', '        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\n', '        _governanceAddress = newGovernance;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// Copied from OpenZeppelin code:\n', '// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IDelegable {\n', '    function delegate(address delegatee) external;\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n', '    function getCurrentVotes(address account) external view returns (uint256);\n', '    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\n', '\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IDelegable.sol";\n', 'import "./IERC20WithMaxTotalSupply.sol";\n', '\n', 'interface IDelegableERC20 is IDelegable, IERC20WithMaxTotalSupply {}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IERC20.sol";\n', '\n', 'interface IERC20WithMaxTotalSupply is IERC20 {\n', '    event Mint(address indexed account, uint tokens);\n', '    event Burn(address indexed account, uint tokens);\n', '    function maxTotalSupply() external view returns (uint);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IGovernanceOwnable {\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    function governance() external view returns (address);\n', '    function setGovernance(address newGovernance) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return add(a, b, "SafeMath: Add Overflow");\n', '    }\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);// "SafeMath: Add Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: Underflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;// "SafeMath: Underflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mul(a, b, "SafeMath: Mul Overflow");\n', '    }\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);// "SafeMath: Mul Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']