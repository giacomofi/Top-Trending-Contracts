['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'import "./ERC721OZ.sol";\n', '\n', '/**\n', ' * @title ERC721 Printable Token\n', ' * @dev ERC721 Token that can be be printed before being sold and not incur high gas fees \n', ' */\n', ' contract JetCoinNFT is ERC721 {\n', '   \n', '  //total number of series made \n', '  uint256 public totalSeries;\n', '  // tracks the ids being used by series \n', '  uint256 public SeriesIDs;\n', '  address payable public MintableAddress;\n', '  mapping(uint256 => PreMint) public PreMintData;\n', '  mapping(uint256 => bool) public PrintSeries;\n', '  struct PreMint {\n', '      uint256 amount_of_tokens_left;\n', '      uint256 total_in_series;\n', '      uint256 starting_id;\n', '      uint256 price;\n', '      address payable creator;\n', '      string url;\n', '      \n', '    }  \n', '  event SeriesMade(address indexed creator, uint256 indexed price, uint256 indexed amount_made);\n', '  event SeriesPurchased(address indexed buyer, uint256 indexed token_id, uint256 indexed price); \n', '  event TransferPayment(address indexed to, uint256 indexed amount); \n', '  \n', '  \n', '   constructor(\n', '        string memory name,\n', '        string memory symbol,\n', '        string memory baseURI\n', '    ) public  ERC721(name, symbol, baseURI) {\n', '        MintableAddress = msg.sender;\n', '        SeriesIDs = 1;\n', '    }\n', '    \n', '    function _fetchCurrentTokenID(uint256 _seriesID) internal view returns (uint256){\n', '     uint256 tokenID = PreMintData[_seriesID].total_in_series.sub(PreMintData[_seriesID].amount_of_tokens_left);\n', '     tokenID = tokenID.add(PreMintData[_seriesID].starting_id);\n', '     return tokenID;\n', '    }\n', '    \n', '    function _processTransfer(uint256 _seriesID) internal returns (bool){\n', '    //calculate fees to be removed\n', '     uint256 fee = (msg.value.mul(10)).div(100);\n', '     uint256 creatorsPayment = msg.value.sub(fee);\n', "     //transfer payment to creator's address\n", '     PreMintData[_seriesID].creator.transfer(creatorsPayment);\n', '    require(address(this).balance >= fee, "Not enough balance to send fee");\n', '    MintableAddress.transfer(fee);\n', '    emit TransferPayment( PreMintData[_seriesID].creator,  creatorsPayment);\n', '    return true;\n', '    }\n', '   function _createPrintSeries(uint256 _totalAmount, uint256 _price, string memory _url) internal returns (bool){\n', '        totalSeries = totalSeries.add(1);\n', '     \n', '        PrintSeries[totalSeries] = true;\n', '           PreMint memory newSeries = PreMint({\n', '               amount_of_tokens_left: _totalAmount,\n', '               total_in_series: _totalAmount,\n', '               starting_id: SeriesIDs,\n', '               price:_price,\n', '               creator: msg.sender,\n', '               url: _url\n', '        });       \n', '        PreMintData[totalSeries] = newSeries;   \n', '        SeriesIDs = SeriesIDs.add(_totalAmount);\n', '                emit SeriesMade(msg.sender, _price, _totalAmount);\n', '                return true;\n', ' }\n', ' \n', '   \n', '    function createPrintSeries(uint256 _amount, uint256 _price, string memory _url) public returns (bool){\n', '        require(hasRole(MINTER, msg.sender), "Not authorized");\n', '        return _createPrintSeries(_amount, _price, _url);\n', '        \n', '    }\n', '    function mintSeries(uint256 _seriesID, address _to) public payable returns (bool){\n', '     require(PrintSeries[_seriesID], "Not a valid series");\n', '     require(PreMintData[_seriesID].amount_of_tokens_left >= 1, "Series is SOLD OUT!");\n', '     require(msg.value >= PreMintData[_seriesID].price, "Invalid amount sent to purchase this NFT");\n', '     //get total supply\n', '     uint256 tokenID = _fetchCurrentTokenID(_seriesID);\n', '     \n', '     //change the amount of tokens left to be one less\n', '     PreMintData[_seriesID].amount_of_tokens_left =  PreMintData[_seriesID].amount_of_tokens_left.sub(1);\n', '     uint256 metadataID  = PreMintData[_seriesID].total_in_series.sub(PreMintData[_seriesID].amount_of_tokens_left);\n', '     //check if tokens left are 0 if so, set to sold out\n', '     if(PreMintData[_seriesID].amount_of_tokens_left == 0){\n', '         PrintSeries[_seriesID] = false;\n', '     }\n', '     emit SeriesPurchased( msg.sender, tokenID, msg.value); \n', '     //mint tokens and send to buyer\n', '    \n', '     super._mintWithURI(_to,  string(abi.encodePacked(PreMintData[_seriesID].url, metadataID.toString())), tokenID);\n', '     //calculate fees to be removed\n', '    require(_processTransfer(_seriesID), "Transfer failed");\n', '    return true;\n', ' }\n', ' \n', '}']