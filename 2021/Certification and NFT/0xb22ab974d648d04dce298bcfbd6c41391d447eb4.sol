['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', 'pragma solidity ^0.5;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '// File: contracts/ExternalTokenSale.sol\n', '\n', 'pragma solidity ^0.5;\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    /**\n', '     * @dev Modifier to restrict owner access only.\n', '     */\n', '     \n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"Invalid Owner");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Transfer ownership to new owner, can only be called by existing owner.\n', '     */\n', '     \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '  uint256 public totalSupply;\n', '  uint256 public decimals;\n', '  function balanceOf(address who) public view returns (uint);\n', '  function allowance(address owner, address spender) public view returns (uint);\n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public;\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '}\n', '\n', '\n', 'contract ExternalTokenSale is Owned {\n', '\n', '    using SafeMath for uint;\n', '    \n', '    struct TokenArtifact {\n', '        uint256 totalSold;\n', '        uint256 exchangeRate; /* per Token in terms of base token (FTB) */\n', '        ERC20 targetToken;\n', '        uint256 pledgedFeePercent;\n', '        uint256 pledgedFeeDivisor;\n', '    }\n', '    \n', '    /* Seller => Token Address */\n', '    mapping(address => mapping(address => TokenArtifact)) public tokenLedger;\n', '    mapping(address => bool) authorizedCaller;\n', '\n', '    // Base Seller Fee;\n', '    uint256 baseFeePercent;\n', '    uint256 baseFeeDivisor;\n', '    \n', '    \n', '    /* Referral Commision Config */\n', '    uint256 referralCommissionChargePercent;\n', '    uint256 referralCommissionChargeDivisor;\n', '    address payable referralChargeReceiver;\n', '    \n', '    // Transaction Config \n', '    uint256 transactionChargePercent;\n', '    uint256 transactionChargeDivisor;\n', '    address payable transactionChargeReceiver;\n', '    \n', '    event ConfigUpdated(\n', '        address payable _transactionChargeReceiver,\n', '        uint256 _transactionChargePercent,\n', '        uint256 _transactionChargeDivisor,\n', '        address payable _referralChargeReceiver,\n', '        uint256 _referralCommissionChargePercent,\n', '        uint256 _referralCommissionChargeDivisor,\n', '        uint256 _baseFeePercent,\n', '        uint256 _baseFeeDivisor\n', '    );\n', '    \n', '    /**\n', '     * @dev Modifier to restrict access to authorized caller.\n', '     */\n', '    modifier onlyAuthCaller(){\n', '        require(authorizedCaller[msg.sender] == true || msg.sender == owner,"Only Authorized and Owner can perform this action");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Modifier to make sure contribution satisfies condition of being non zero and Funding is enabled.\n', '     */\n', '    modifier onlyValidContribution(uint _value){\n', '        require(_value > 0 ,"Value should be greater than zero");\n', '        _;\n', '    }\n', '\n', '    /* Events */\n', '    event AuthorizedCaller(address _caller);\n', '    event DeAuthorizedCaller(address _caller);\n', '    \n', '    event PurchaseToken(address indexed _buyerAddress,\n', '                        address indexed _sellerAddress, \n', '                        address indexed _tokenAddress, \n', '                        uint256 _amount,\n', '                        uint256 _feeAmount);\n', '    \n', '    event AddTokenArtifact(address indexed _sellerAddress, \n', '                        address indexed _tokenAddress, \n', '                        uint256 _amount,\n', '                        uint256 _pledgedFeePercent,\n', '                        uint256 _pledgedFeeDivisor);\n', '                        \n', '    event TransactionConfigUpdated(uint _transactionChargePercent, uint _transactionChargeDivisor);\n', '    event ReferralCommissionConfigUpdated(uint _referralCommissionChargePercent, uint _referralCommissionChargeDivisor);\n', '\n', '    \n', '    constructor(address payable _transactionChargeReceiver, address payable _referralChargeReceiver) public {\n', '        \n', '        owner = msg.sender;\n', '        transactionChargeReceiver = _transactionChargeReceiver;\n', '        referralChargeReceiver = _referralChargeReceiver;\n', '    }\n', '    \n', '   \n', '     \n', '\n', '    \n', '    /**\n', '     * @dev Can be called to authorize address which can perform operation requiring elevated privileges \n', '     */\n', '    function authorizeCaller(address _caller) public onlyOwner returns(bool){\n', '        authorizedCaller[_caller] = true;\n', '        emit AuthorizedCaller(_caller);\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Can be called to de-authorize address which can perform operation requiring elevated privileges\n', '     */\n', '    function deAuthorizeCaller(address _caller) public onlyOwner returns(bool){\n', '        authorizedCaller[_caller] = false;\n', '        emit DeAuthorizedCaller(_caller);\n', '        return true;\n', '    }   \n', '    \n', '    function getConfig()\n', '        public\n', '        view\n', '        returns (\n', '            address _transactionChargeReceiver,\n', '            uint256 _transactionChargePercent,\n', '            uint256 _transactionChargeDivisor,\n', '            address _referralChargeReceiver,\n', '            uint256 _referralCommissionChargePercent,\n', '            uint256 _referralCommissionChargeDivisor,\n', '            uint256 _baseFeePercent,\n', '            uint256 _baseFeeDivisor\n', '        )\n', '    {\n', '        return (\n', '            transactionChargeReceiver,\n', '            transactionChargePercent,\n', '            transactionChargeDivisor,\n', '            referralChargeReceiver,\n', '            referralCommissionChargePercent,\n', '            referralCommissionChargeDivisor,\n', '            baseFeePercent,\n', '            baseFeeDivisor\n', '        );\n', '    }\n', '\n', '    function updateConfig(\n', '        address payable _transactionChargeReceiver,\n', '        uint256 _transactionChargePercent,\n', '        uint256 _transactionChargeDivisor,\n', '        address payable _referralChargeReceiver,\n', '        uint256 _referralCommissionChargePercent,\n', '        uint256 _referralCommissionChargeDivisor,\n', '        uint256 _baseFeePercent,\n', '        uint256 _baseFeeDivisor\n', '    ) public onlyAuthCaller returns (bool) {\n', '        \n', '        // Base Fee \n', '        baseFeePercent = _baseFeePercent;\n', '        baseFeeDivisor = _baseFeeDivisor;\n', '        \n', '        // Transaction \n', '        transactionChargeReceiver = _transactionChargeReceiver;\n', '        transactionChargePercent = _transactionChargePercent;\n', '        transactionChargeDivisor = _transactionChargeDivisor;\n', '    \n', '        // Referral \n', '        referralChargeReceiver = _referralChargeReceiver;\n', '        referralCommissionChargePercent = _referralCommissionChargePercent;\n', '        referralCommissionChargeDivisor = _referralCommissionChargeDivisor;\n', '        \n', '        emit ConfigUpdated(\n', '            _transactionChargeReceiver,\n', '            _transactionChargePercent,\n', '            _transactionChargeDivisor,\n', '            _referralChargeReceiver,\n', '            _referralCommissionChargePercent,\n', '            _referralCommissionChargeDivisor,\n', '            _baseFeePercent,\n', '            _baseFeeDivisor\n', '        );\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev addTokenArtifact function need to be called to add the ERC20 Token artifact\n', '     * by providing ERC20 token contract address, Exchange Rate with respect to base token (FTB)\n', '    */\n', '    \n', '    function addTokenArtifact(\n', '        address _tokenAddress, \n', '        uint256 _exchangeRate,\n', '        uint256 _pledgedFeePercent,\n', '        uint256 _pledgedFeeDivisor) public returns(bool)\n', '    {\n', '        tokenLedger[msg.sender][_tokenAddress].totalSold =  0 ;\n', '        tokenLedger[msg.sender][_tokenAddress].exchangeRate =  _exchangeRate ;\n', '        tokenLedger[msg.sender][_tokenAddress].targetToken =  ERC20(_tokenAddress) ;\n', '        \n', '        tokenLedger[msg.sender][_tokenAddress].pledgedFeePercent = _pledgedFeePercent;\n', '        tokenLedger[msg.sender][_tokenAddress].pledgedFeeDivisor = _pledgedFeeDivisor;\n', '        \n', '        emit AddTokenArtifact(\n', '            msg.sender, \n', '            _tokenAddress, \n', '            _exchangeRate,\n', '            _pledgedFeePercent,\n', '            _pledgedFeeDivisor\n', '        );\n', '        return true;\n', '    }\n', '    \n', '\n', '    \n', '    \n', '    function purchaseToken(\n', '        address payable _sellerAddress, \n', '        address _tokenAddress, \n', '        bool _isReferredBuyer) public payable returns(bool)\n', '    { \n', '        \n', '        TokenArtifact memory _activeTokenArtifact = tokenLedger[_sellerAddress][_tokenAddress];\n', '        \n', '        require(_activeTokenArtifact.exchangeRate > 0, "Exchange Rate should greater than zero ");\n', '        \n', '        /* Calculate Conversion in terms of target token decimals */\n', '        uint256 _targetTokenDecimalBase = uint256(_activeTokenArtifact.targetToken.decimals());\n', '        uint256 _finalAmount = 0;\n', '  \n', '       \n', '        \n', '        /* Msg Value  */\n', '        uint256 _depositedAmt = msg.value;\n', '  \n', '        uint256 _baseRecievableAmt = 0;\n', '        uint256 _baseFeeAmt = 0;\n', '        \n', '        uint256 _adminFeeAmt = 0;\n', '        uint256 _referralFeeAmt = 0;\n', '        \n', '   \n', '        // Get Product Pledged Fee\n', '   \n', '        _baseFeeAmt = _activeTokenArtifact.pledgedFeePercent.mul(_depositedAmt).div(_activeTokenArtifact.pledgedFeeDivisor.mul(100));\n', '        _baseRecievableAmt = _depositedAmt.sub(_baseFeeAmt);\n', '        \n', '        \n', '        if (transactionChargeDivisor > 0 && transactionChargePercent > 0) {\n', '            /* Calculate Transaction Fee */\n', '            \n', '            _adminFeeAmt = transactionChargePercent.mul(_baseFeeAmt).div(\n', '                transactionChargeDivisor.mul(100)\n', '            );\n', '         \n', '        }\n', '\n', '        if(referralCommissionChargeDivisor > 0 &&\n', '            referralCommissionChargePercent > 0){\n', '            _referralFeeAmt = referralCommissionChargePercent\n', '                .mul(_baseFeeAmt)\n', '                .div(referralCommissionChargeDivisor.mul(100));\n', '            }\n', '        \n', '\n', '        /* Debit Referral Commision Fee if set */\n', '        if (\n', '            _isReferredBuyer == false            \n', '        ) {\n', '            /* Calculate Referral Commision Fee */\n', '            _adminFeeAmt = _adminFeeAmt.add(_referralFeeAmt);                     \n', '        } \n', '\n', '        /* Send Transaction Receiver their share */\n', '        if (_adminFeeAmt > 0) {\n', '            transactionChargeReceiver.transfer(_adminFeeAmt);\n', '        }\n', '\n', '        /* Send Referral Receiver their share */\n', '        if (_referralFeeAmt > 0) {\n', '            referralChargeReceiver.transfer(_referralFeeAmt);\n', '        }\n', '        \n', '        \n', '        /* Transfer Leftover amount to product owner */\n', '        _sellerAddress.transfer(_baseRecievableAmt);\n', '\n', '        /* Transfer Final target Token from Seller to Buyer */\n', '        _finalAmount = _depositedAmt.mul(10 ** _targetTokenDecimalBase).div(_activeTokenArtifact.exchangeRate);\n', '        \n', '        /* Transfer Calculated token to investor */\n', '        _activeTokenArtifact.targetToken.transferFrom(_sellerAddress,msg.sender,_finalAmount);\n', '        \n', '        /* Update Sold */\n', '        _activeTokenArtifact.totalSold = tokenLedger[msg.sender][_tokenAddress].totalSold.add(_finalAmount);\n', '        \n', '        \n', '        \n', '        emit PurchaseToken(msg.sender, _sellerAddress, _tokenAddress, _finalAmount, _baseFeeAmt);\n', '        return true;   \n', '    }\n', '\n', '    \n', '    /**\n', '     * @dev Fallback function configured to accept any ether sent to smart contract\n', '     */\n', '    function () external onlyValidContribution(msg.value) payable {\n', '\n', '       revert();\n', '    }\n', '\n', '\n', '}']