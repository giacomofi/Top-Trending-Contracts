['pragma solidity ^0.6.0;\n', '\n', 'import "./ERC1155.sol";\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', '    @dev Mintable form of ERC1155\n', '    Shows how easy it is to mint new items.\n', '*/\n', 'contract ERC1155Mintable is ERC1155 ,Ownable{\n', '\n', '    bytes4 constant private INTERFACE_SIGNATURE_URI = 0x0e89341c;\n', '    \n', '    // id => creators\n', '    mapping (uint256 => address) public creators;\n', '    mapping(uint256 => string) public tokenUris;\n', '\n', '    // A nonce to ensure we have a unique id each time we mint.\n', '    uint256 public nonce;\n', '\n', '    modifier creatorOnly(uint256 _id) {\n', '        require(creators[_id] == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceId) override\n', '    public\n', '    view\n', '    returns (bool) {\n', '        if (_interfaceId == INTERFACE_SIGNATURE_URI) {\n', '            return true;\n', '        } else {\n', '            return super.supportsInterface(_interfaceId);\n', '        }\n', '    }\n', '\n', '    // Creates a new token type and assings _initialSupply to minter\n', '    function create(uint256 _initialSupply, string calldata _uri) external onlyOwner returns(uint256 _id) {\n', '        \n', '        _id = ++nonce;\n', '        creators[_id] = msg.sender;\n', '        balances[_id][msg.sender] = _initialSupply;\n', '        tokenUris[_id] = _uri;\n', '\n', '        // Transfer event with mint semantic\n', '        emit TransferSingle(msg.sender, address(0x0), msg.sender, _id, _initialSupply);\n', '\n', '        if (bytes(_uri).length > 0)\n', '            emit URI(_uri, _id);\n', '    }\n', '\n', '    // Batch mint tokens. Assign directly to _to[].\n', '    function mint(uint256 _id, address[] calldata _to, uint256[] calldata _quantities) external onlyOwner{\n', '        require(msg.sender == creators[_id]);\n', '        for (uint256 i = 0; i < _to.length; ++i) {\n', '\n', '            address to = _to[i];\n', '            uint256 quantity = _quantities[i];\n', '\n', '            // Grant the items to the caller\n', '            balances[_id][to] = quantity.add(balances[_id][to]);\n', '\n', '            // Emit the Transfer/Mint event.\n', '            // the 0x0 source address implies a mint\n', '            // It will also provide the circulating supply info.\n', '            emit TransferSingle(msg.sender, address(0x0), to, _id, quantity);\n', '\n', '            if (to.isContract()) {\n', "                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, to, _id, quantity, '');\n", '            }\n', '        }\n', '    }\n', '    \n', '    //mint tokens. Assign directly to _to[].\n', '    function mintSingle(uint256 _id, address _to, uint256 _quantities) external onlyOwner {\n', '        require(msg.sender == creators[_id]);\n', '        // Grant the items to the caller\n', '        balances[_id][_to] = _quantities.add(balances[_id][_to]);\n', '\n', '        // Emit the Transfer/Mint event.\n', '        // the 0x0 source address implies a mint\n', '        // It will also provide the circulating supply info.\n', '        emit TransferSingle(msg.sender, address(0x0), _to, _id, _quantities);\n', '\n', '        if (_to.isContract()) {\n', "            _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, _to, _id, _quantities, '');\n", '        }\n', '    }\n', '\n', '    function setURI(string calldata _uri, uint256 _id) external onlyOwner {\n', '        require(msg.sender == creators[_id]);\n', '        tokenUris[_id] = _uri;\n', '        emit URI(_uri, _id);\n', '    }\n', '    \n', '   \n', '    function uri(uint256 _id) public view returns (string memory uri) {\n', '        return tokenUris[_id];\n', '    }\n', '}']