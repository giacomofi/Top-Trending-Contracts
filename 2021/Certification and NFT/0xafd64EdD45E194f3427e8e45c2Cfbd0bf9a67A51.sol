['// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";\n', 'import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@openzeppelin/contracts/math/Math.sol";\n', 'import "./libraries/SafeERC20.sol";\n', 'import "./interfaces/IMlp.sol";\n', 'import "./interfaces/IFeesController.sol";\n', 'import "./interfaces/IRewardManager.sol";\n', '\n', 'contract MLP is IMlp {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public endDate;\n', '    address public submitter;\n', '    uint256 public exceedingLiquidity;\n', '    uint256 public bonusToken0;\n', '    uint256 public reward0Rate;\n', '    uint256 public reward0PerTokenStored;\n', '    uint256 public bonusToken1;\n', '    uint256 public reward1Rate;\n', '    uint256 public reward1PerTokenStored;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public pendingOfferCount;\n', '    uint256 public activeOfferCount;\n', '\n', '    IRewardManager public rewardManager;\n', '    IUniswapV2Pair public uniswapPair;\n', '    IFeesController public feesController;\n', '    IUniswapV2Router02 public uniswapRouter;\n', '\n', '    mapping(address => uint256) public userReward0PerTokenPaid;\n', '    mapping(address => uint256) public userRewards0;\n', '    mapping(address => uint256) public userReward1PerTokenPaid;\n', '    mapping(address => uint256) public userRewards1;\n', '    mapping(address => uint256) public directStakeBalances;\n', '    mapping(uint256 => PendingOffer) public getPendingOffer;\n', '    mapping(uint256 => ActiveOffer) public getActiveOffer;\n', '\n', '    enum OfferStatus {PENDING, TAKEN, CANCELED}\n', '\n', '    event OfferMade(uint256 id);\n', '    event OfferTaken(uint256 pendingOfferId, uint256 activeOfferId);\n', '    event OfferCanceled(uint256 id);\n', '    event OfferReleased(uint256 offerId);\n', '\n', '    struct PendingOffer {\n', '        address owner;\n', '        address token;\n', '        uint256 amount;\n', '        uint256 unlockDate;\n', '        uint256 endDate;\n', '        OfferStatus status;\n', '        uint256 slippageTolerancePpm;\n', '        uint256 maxPriceVariationPpm;\n', '    }\n', '\n', '    struct ActiveOffer {\n', '        address user0;\n', '        uint256 originalAmount0;\n', '        address user1;\n', '        uint256 originalAmount1;\n', '        uint256 unlockDate;\n', '        uint256 liquidity;\n', '        bool released;\n', '        uint256 maxPriceVariationPpm;\n', '    }\n', '\n', '    constructor(\n', '        address _uniswapPair,\n', '        address _submitter,\n', '        uint256 _endDate,\n', '        address _uniswapRouter,\n', '        address _feesController,\n', '        IRewardManager _rewardManager,\n', '        uint256 _bonusToken0,\n', '        uint256 _bonusToken1\n', '    ) public {\n', '        feesController = IFeesController(_feesController);\n', '        uniswapPair = IUniswapV2Pair(_uniswapPair);\n', '        endDate = _endDate;\n', '        submitter = _submitter;\n', '        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n', '        rewardManager = _rewardManager;\n', '\n', '        uint256 remainingTime = _endDate.sub(block.timestamp);\n', '        bonusToken0 = _bonusToken0;\n', '        reward0Rate = _bonusToken0 / remainingTime;\n', '        bonusToken1 = _bonusToken1;\n', '        reward1Rate = _bonusToken1 / remainingTime;\n', '        lastUpdateTime = block.timestamp;\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, endDate);\n', '    }\n', '\n', '    function reward0PerToken() public view returns (uint256) {\n', '        uint256 totalSupply = rewardManager.getPoolSupply(address(this));\n', '        if (totalSupply == 0) {\n', '            return reward0PerTokenStored;\n', '        }\n', '        return\n', '            reward0PerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(reward0Rate)\n', '                    .mul(1e18) / totalSupply\n', '            );\n', '    }\n', '\n', '    function reward1PerToken() public view returns (uint256) {\n', '        uint256 totalSupply = rewardManager.getPoolSupply(address(this));\n', '        if (totalSupply == 0) {\n', '            return reward1PerTokenStored;\n', '        }\n', '        return\n', '            reward1PerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(reward1Rate)\n', '                    .mul(1e18) / totalSupply\n', '            );\n', '    }\n', '\n', '    function rewardEarned(address account)\n', '        public\n', '        view\n', '        returns (uint256 reward0Earned, uint256 reward1Earned)\n', '    {\n', '        uint256 balance = rewardManager.getUserAmount(address(this), account);\n', '        reward0Earned = (balance.mul(\n', '            reward0PerToken().sub(userReward0PerTokenPaid[account])\n', '        ) / 1e18)\n', '            .add(userRewards0[account]);\n', '        reward1Earned = (balance.mul(\n', '            reward1PerToken().sub(userReward1PerTokenPaid[account])\n', '        ) / 1e18)\n', '            .add(userRewards1[account]);\n', '    }\n', '\n', '    function updateRewards(address account) internal {\n', '        reward0PerTokenStored = reward0PerToken();\n', '        reward1PerTokenStored = reward1PerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            (uint256 earned0, uint256 earned1) = rewardEarned(account);\n', '            userRewards0[account] = earned0;\n', '            userRewards1[account] = earned1;\n', '            userReward0PerTokenPaid[account] = reward0PerTokenStored;\n', '            userReward1PerTokenPaid[account] = reward1PerTokenStored;\n', '        }\n', '    }\n', '\n', '    function payRewards(address account) public {\n', '        updateRewards(account);\n', '        (uint256 reward0, uint256 reward1) = rewardEarned(account);\n', '        if (reward0 > 0) {\n', '            userRewards0[account] = 0;\n', '            IERC20(uniswapPair.token0()).safeTransfer(account, reward0);\n', '        }\n', '        if (reward1 > 0) {\n', '            userRewards1[account] = 0;\n', '            IERC20(uniswapPair.token1()).safeTransfer(account, reward1);\n', '        }\n', '    }\n', '\n', '    function _notifyDeposit(address account, uint256 amount) internal {\n', '        updateRewards(account);\n', '        rewardManager.notifyDeposit(account, amount);\n', '    }\n', '\n', '    function _notifyWithdraw(address account, uint256 amount) internal {\n', '        updateRewards(account);\n', '        rewardManager.notifyWithdraw(account, amount);\n', '    }\n', '\n', '    function makeOffer(\n', '        address _token,\n', '        uint256 _amount,\n', '        uint256 _unlockDate,\n', '        uint256 _endDate,\n', '        uint256 _slippageTolerancePpm,\n', '        uint256 _maxPriceVariationPpm\n', '    ) external override returns (uint256 offerId) {\n', '        require(_amount > 0);\n', '        require(_endDate > now);\n', '        require(_endDate <= _unlockDate);\n', '        offerId = pendingOfferCount;\n', '        pendingOfferCount++;\n', '        getPendingOffer[offerId] = PendingOffer(\n', '            msg.sender,\n', '            _token,\n', '            _amount,\n', '            _unlockDate,\n', '            _endDate,\n', '            OfferStatus.PENDING,\n', '            _slippageTolerancePpm,\n', '            _maxPriceVariationPpm\n', '        );\n', '        IERC20 token;\n', '        if (_token == address(uniswapPair.token0())) {\n', '            token = IERC20(uniswapPair.token0());\n', '        } else if (_token == address(uniswapPair.token1())) {\n', '            token = IERC20(uniswapPair.token1());\n', '        } else {\n', '            require(false, "unknown token");\n', '        }\n', '\n', '        token.safeTransferFrom(msg.sender, address(this), _amount);\n', '        emit OfferMade(offerId);\n', '    }\n', '\n', '    struct ProviderInfo {\n', '        address user;\n', '        uint256 amount;\n', '        IERC20 token;\n', '    }\n', '\n', '    struct OfferInfo {\n', '        uint256 deadline;\n', '        uint256 slippageTolerancePpm;\n', '    }\n', '\n', '    function takeOffer(\n', '        uint256 _pendingOfferId,\n', '        uint256 _amount,\n', '        uint256 _deadline\n', '    ) external override returns (uint256 activeOfferId) {\n', '        PendingOffer storage pendingOffer = getPendingOffer[_pendingOfferId];\n', '        require(pendingOffer.status == OfferStatus.PENDING);\n', '        require(pendingOffer.endDate > now);\n', '        pendingOffer.status = OfferStatus.TAKEN;\n', '\n', '        // Sort the users, tokens, and amount\n', '        ProviderInfo memory provider0;\n', '        ProviderInfo memory provider1;\n', '\n', '        if (pendingOffer.token == uniswapPair.token0()) {\n', '            provider0 = ProviderInfo(\n', '                pendingOffer.owner,\n', '                pendingOffer.amount,\n', '                IERC20(uniswapPair.token0())\n', '            );\n', '            provider1 = ProviderInfo(\n', '                msg.sender,\n', '                _amount,\n', '                IERC20(uniswapPair.token1())\n', '            );\n', '\n', '            provider1.token.safeTransferFrom(\n', '                provider1.user,\n', '                address(this),\n', '                provider1.amount\n', '            );\n', '        } else {\n', '            provider0 = ProviderInfo(\n', '                msg.sender,\n', '                _amount,\n', '                IERC20(uniswapPair.token0())\n', '            );\n', '            provider1 = ProviderInfo(\n', '                pendingOffer.owner,\n', '                pendingOffer.amount,\n', '                IERC20(uniswapPair.token1())\n', '            );\n', '\n', '            provider0.token.safeTransferFrom(\n', '                provider0.user,\n', '                address(this),\n', '                provider0.amount\n', '            );\n', '        }\n', '\n', '        // calculate fees\n', '        uint256 feesAmount0 =\n', '            provider0.amount.mul(feesController.feesPpm()) / 1000;\n', '        uint256 feesAmount1 =\n', '            provider1.amount.mul(feesController.feesPpm()) / 1000;\n', '\n', '        // take fees\n', '        provider0.amount = provider0.amount.sub(feesAmount0);\n', '        provider1.amount = provider1.amount.sub(feesAmount1);\n', '\n', '        // send fees\n', '        provider0.token.safeTransfer(feesController.feesTo(), feesAmount0);\n', '        provider1.token.safeTransfer(feesController.feesTo(), feesAmount1);\n', '\n', '        // send tokens to uniswap\n', '        uint256 liquidity =\n', '            _provideLiquidity(\n', '                provider0,\n', '                provider1,\n', '                OfferInfo(_deadline, pendingOffer.slippageTolerancePpm)\n', '            );\n', '\n', '        // stake liquidity\n', '        _notifyDeposit(provider0.user, liquidity / 2);\n', '        _notifyDeposit(provider1.user, liquidity / 2);\n', '\n', '        if (liquidity % 2 != 0) {\n', '            exceedingLiquidity = exceedingLiquidity.add(1);\n', '        }\n', '\n', '        // Record the active offer\n', '        activeOfferId = activeOfferCount;\n', '        activeOfferCount++;\n', '\n', '        getActiveOffer[activeOfferId] = ActiveOffer(\n', '            provider0.user,\n', '            provider0.amount,\n', '            provider1.user,\n', '            provider1.amount,\n', '            pendingOffer.unlockDate,\n', '            liquidity,\n', '            false,\n', '            pendingOffer.maxPriceVariationPpm\n', '        );\n', '\n', '        emit OfferTaken(_pendingOfferId, activeOfferId);\n', '\n', '        return activeOfferId;\n', '    }\n', '\n', '    function _provideLiquidity(\n', '        ProviderInfo memory _provider0,\n', '        ProviderInfo memory _provider1,\n', '        OfferInfo memory _info\n', '    ) internal returns (uint256) {\n', '        _provider0.token.safeApprove(address(uniswapRouter), _provider0.amount);\n', '        _provider1.token.safeApprove(address(uniswapRouter), _provider1.amount);\n', '\n', '        uint256 amountMin0 =\n', '            _provider0.amount.sub(\n', '                _provider0.amount.mul(_info.slippageTolerancePpm) / 1000\n', '            );\n', '        uint256 amountMin1 =\n', '            _provider1.amount.sub(\n', '                _provider1.amount.mul(_info.slippageTolerancePpm) / 1000\n', '            );\n', '\n', '        // Add the liquidity to Uniswap\n', '        (uint256 spentAmount0, uint256 spentAmount1, uint256 liquidity) =\n', '            uniswapRouter.addLiquidity(\n', '                address(_provider0.token),\n', '                address(_provider1.token),\n', '                _provider0.amount,\n', '                _provider1.amount,\n', '                amountMin0,\n', '                amountMin1,\n', '                address(this),\n', '                _info.deadline\n', '            );\n', '\n', '        // Give back the exceeding tokens\n', '        if (spentAmount0 < _provider0.amount) {\n', '            _provider0.token.safeTransfer(\n', '                _provider0.user,\n', '                _provider0.amount - spentAmount0\n', '            );\n', '        }\n', '        if (spentAmount1 < _provider1.amount) {\n', '            _provider1.token.safeTransfer(\n', '                _provider1.user,\n', '                _provider1.amount - spentAmount1\n', '            );\n', '        }\n', '\n', '        return liquidity;\n', '    }\n', '\n', '    function cancelOffer(uint256 _offerId) external override {\n', '        PendingOffer storage pendingOffer = getPendingOffer[_offerId];\n', '        require(pendingOffer.status == OfferStatus.PENDING);\n', '        pendingOffer.status = OfferStatus.CANCELED;\n', '        IERC20(pendingOffer.token).safeTransfer(\n', '            pendingOffer.owner,\n', '            pendingOffer.amount\n', '        );\n', '        emit OfferCanceled(_offerId);\n', '    }\n', '\n', '    function release(uint256 _offerId, uint256 _deadline) external override {\n', '        ActiveOffer storage offer = getActiveOffer[_offerId];\n', '\n', '        require(\n', '            msg.sender == offer.user0 || msg.sender == offer.user1,\n', '            "unauthorized"\n', '        );\n', '        require(now > offer.unlockDate, "locked");\n', '        require(!offer.released, "already released");\n', '\n', '        IERC20 token0 = IERC20(uniswapPair.token0());\n', '        IERC20 token1 = IERC20(uniswapPair.token1());\n', '\n', '        IERC20(address(uniswapPair)).safeApprove(\n', '            address(uniswapRouter),\n', '            offer.liquidity\n', '        );\n', '        (uint256 amount0, uint256 amount1) =\n', '            uniswapRouter.removeLiquidity(\n', '                address(token0),\n', '                address(token1),\n', '                offer.liquidity,\n', '                0,\n', '                0,\n', '                address(this),\n', '                _deadline\n', '            );\n', '\n', '        _notifyWithdraw(offer.user0, offer.liquidity / 2);\n', '        _notifyWithdraw(offer.user1, offer.liquidity / 2);\n', '\n', '        if (\n', '            _getPriceVariation(offer.originalAmount0, amount0) >\n', '            offer.maxPriceVariationPpm\n', '        ) {\n', '            if (amount0 > offer.originalAmount0) {\n', '                uint256 toSwap = amount0.sub(offer.originalAmount0);\n', '                address[] memory path = new address[](2);\n', '                path[0] = uniswapPair.token0();\n', '                path[1] = uniswapPair.token1();\n', '                token0.safeApprove(address(uniswapRouter), toSwap);\n', '                uint256[] memory newAmounts =\n', '                    uniswapRouter.swapExactTokensForTokens(\n', '                        toSwap,\n', '                        0,\n', '                        path,\n', '                        address(this),\n', '                        _deadline\n', '                    );\n', '                amount0 = amount0.sub(toSwap);\n', '                amount1 = amount1.add(newAmounts[1]);\n', '            }\n', '        }\n', '        if (\n', '            _getPriceVariation(offer.originalAmount1, amount1) >\n', '            offer.maxPriceVariationPpm\n', '        ) {\n', '            if (amount1 > offer.originalAmount1) {\n', '                uint256 toSwap = amount1.sub(offer.originalAmount1);\n', '                address[] memory path = new address[](2);\n', '                path[0] = uniswapPair.token1();\n', '                path[1] = uniswapPair.token0();\n', '                token1.safeApprove(address(uniswapRouter), toSwap);\n', '                uint256[] memory newAmounts =\n', '                    uniswapRouter.swapExactTokensForTokens(\n', '                        toSwap,\n', '                        0,\n', '                        path,\n', '                        address(this),\n', '                        _deadline\n', '                    );\n', '                amount1 = amount1.sub(toSwap);\n', '                amount0 = amount0.add(newAmounts[1]);\n', '            }\n', '        }\n', '\n', '        token0.safeTransfer(offer.user0, amount0);\n', '        payRewards(offer.user0);\n', '        token1.safeTransfer(offer.user1, amount1);\n', '        payRewards(offer.user1);\n', '\n', '        offer.released = true;\n', '        emit OfferReleased(_offerId);\n', '    }\n', '\n', '    function _getPriceVariation(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint256 sub;\n', '        if (a > b) {\n', '            sub = a.sub(b);\n', '            return sub.mul(1000) / a;\n', '        } else {\n', '            sub = b.sub(a);\n', '            return sub.mul(1000) / b;\n', '        }\n', '    }\n', '\n', '    function directStake(uint256 _amount) external {\n', '        require(_amount > 0, "cannot stake 0");\n', '        _notifyDeposit(msg.sender, _amount);\n', '        directStakeBalances[msg.sender] = directStakeBalances[msg.sender].add(\n', '            _amount\n', '        );\n', '        IERC20(address(uniswapPair)).safeTransferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            _amount\n', '        );\n', '    }\n', '\n', '    function directWithdraw(uint256 _amount) external {\n', '        require(_amount > 0, "cannot withdraw 0");\n', '        _notifyWithdraw(msg.sender, _amount);\n', '        directStakeBalances[msg.sender] = directStakeBalances[msg.sender].sub(\n', '            _amount\n', '        );\n', '        IERC20(address(uniswapPair)).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    function transferExceedingLiquidity() external {\n', '        require(exceedingLiquidity != 0);\n', '        exceedingLiquidity = 0;\n', '        IERC20(address(uniswapPair)).safeTransfer(\n', '            feesController.feesTo(),\n', '            exceedingLiquidity\n', '        );\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'import "@openzeppelin/contracts/access/Ownable.sol";\n', 'import "@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol";\n', 'import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";\n', 'import "./Mlp.sol";\n', 'import "./interfaces/IMintableERC20.sol";\n', 'import "./interfaces/IRewardManager.sol";\n', 'import "./interfaces/IPopMarketplace.sol";\n', 'import "./libraries/SafeERC20.sol";\n', '\n', 'contract PopMarketplace is IFeesController, IPopMarketplace, Ownable {\n', '    using SafeERC20 for IERC20;\n', '    address public uniswapFactory;\n', '    address public uniswapRouter;\n', '    address[] public allMlp;\n', '    address private _feesTo = msg.sender;\n', '    uint256 private _feesPpm;\n', '    uint256 public pendingMlpCount;\n', '    IRewardManager public rewardManager;\n', '    IMintableERC20 public popToken;\n', '\n', '    mapping(uint256 => PendingMlp) public getMlp;\n', '\n', '    enum MlpStatus {PENDING, APPROVED, CANCELED, ENDED}\n', '\n', '    struct PendingMlp {\n', '        address uniswapPair;\n', '        address submitter;\n', '        uint256 liquidity;\n', '        uint256 endDate;\n', '        MlpStatus status;\n', '        uint256 bonusToken0;\n', '        uint256 bonusToken1;\n', '    }\n', '\n', '    event MlpCreated(address indexed mlp);\n', '    event MlpSubmitted(uint256 id);\n', '    event MlpCanceled(uint256 id);\n', '    event MlpEnded(uint256 id);\n', '\n', '    constructor(\n', '        address _popToken,\n', '        address _uniswapFactory,\n', '        address _uniswapRouter,\n', '        address _rewardManager\n', '    ) public {\n', '        popToken = IMintableERC20(_popToken);\n', '        uniswapFactory = _uniswapFactory;\n', '        uniswapRouter = _uniswapRouter;\n', '        rewardManager = IRewardManager(_rewardManager);\n', '    }\n', '\n', '    function submitMlp(\n', '        address _token0,\n', '        address _token1,\n', '        uint256 _liquidity,\n', '        uint256 _endDate,\n', '        uint256 _bonusToken0,\n', '        uint256 _bonusToken1\n', '    ) public override {\n', '        require(_endDate > now, "!datenow");\n', '\n', '        IUniswapV2Pair pair =\n', '            IUniswapV2Pair(\n', '                UniswapV2Library.pairFor(uniswapFactory, _token0, _token1)\n', '            );\n', '        require(address(pair) != address(0), "!address0");\n', '\n', '        if (_liquidity > 0) {\n', '            IERC20(address(pair)).safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                _liquidity\n', '            );\n', '        }\n', '        if (_bonusToken0 > 0) {\n', '            IERC20(_token0).safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                _bonusToken0\n', '            );\n', '        }\n', '        if (_bonusToken1 > 0) {\n', '            IERC20(_token1).safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                _bonusToken1\n', '            );\n', '        }\n', '\n', '        if (_token0 != pair.token0()) {\n', '            uint256 tmp = _bonusToken0;\n', '            _bonusToken0 = _bonusToken1;\n', '            _bonusToken1 = tmp;\n', '        }\n', '\n', '        getMlp[pendingMlpCount++] = PendingMlp({\n', '            uniswapPair: address(pair),\n', '            submitter: msg.sender,\n', '            liquidity: _liquidity,\n', '            endDate: _endDate,\n', '            status: MlpStatus.PENDING,\n', '            bonusToken0: _bonusToken0,\n', '            bonusToken1: _bonusToken1\n', '        });\n', '        emit MlpSubmitted(pendingMlpCount - 1);\n', '    }\n', '\n', '    function approveMlp(uint256 _mlpId, uint256 _allocPoint)\n', '        external\n', '        onlyOwner()\n', '        returns (address mlpAddress)\n', '    {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '        require(pendingMlp.status == MlpStatus.PENDING);\n', '\n', '        MLP newMlp =\n', '            new MLP(\n', '                pendingMlp.uniswapPair,\n', '                pendingMlp.submitter,\n', '                pendingMlp.endDate,\n', '                uniswapRouter,\n', '                address(this),\n', '                rewardManager,\n', '                pendingMlp.bonusToken0,\n', '                pendingMlp.bonusToken1\n', '            );\n', '        mlpAddress = address(newMlp);\n', '        rewardManager.add(_allocPoint, mlpAddress);\n', '        popToken.setMinter(address(newMlp), true);\n', '        allMlp.push(mlpAddress);\n', '        IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token0()).safeTransfer(\n', '            mlpAddress,\n', '            pendingMlp.bonusToken0\n', '        );\n', '        IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token1()).safeTransfer(\n', '            mlpAddress,\n', '            pendingMlp.bonusToken1\n', '        );\n', '\n', '        pendingMlp.status = MlpStatus.APPROVED;\n', '        emit MlpCreated(mlpAddress);\n', '\n', '        return mlpAddress;\n', '    }\n', '\n', '    function cancelMlp(uint256 _mlpId) public override {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '\n', '        require(pendingMlp.submitter == msg.sender, "!submitter");\n', '        require(pendingMlp.status == MlpStatus.PENDING, "!pending");\n', '\n', '        if (pendingMlp.liquidity > 0) {\n', '            IUniswapV2Pair pair = IUniswapV2Pair(pendingMlp.uniswapPair);\n', '            IERC20(address(pair)).safeTransfer(\n', '                pendingMlp.submitter,\n', '                pendingMlp.liquidity\n', '            );\n', '        }\n', '\n', '        if (pendingMlp.bonusToken0 > 0) {\n', '            IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token0())\n', '                .safeTransfer(pendingMlp.submitter, pendingMlp.bonusToken0);\n', '        }\n', '        if (pendingMlp.bonusToken1 > 0) {\n', '            IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token1())\n', '                .safeTransfer(pendingMlp.submitter, pendingMlp.bonusToken1);\n', '        }\n', '\n', '        pendingMlp.status = MlpStatus.CANCELED;\n', '        emit MlpCanceled(_mlpId);\n', '    }\n', '\n', '    function setFeesTo(address _newFeesTo) public override onlyOwner {\n', '        require(_newFeesTo != address(0), "!address0");\n', '        _feesTo = _newFeesTo;\n', '    }\n', '\n', '    function feesTo() public override returns (address) {\n', '        return _feesTo;\n', '    }\n', '\n', '    function feesPpm() public override returns (uint256) {\n', '        return _feesPpm;\n', '    }\n', '\n', '    function setFeesPpm(uint256 _newFeesPpm) public override onlyOwner {\n', '        require(_newFeesPpm > 0, "!<0");\n', '        _feesPpm = _newFeesPpm;\n', '    }\n', '\n', '    function endMlp(uint256 _mlpId) public override returns (uint256) {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '\n', '        require(pendingMlp.submitter == msg.sender, "!submitter");\n', '        require(pendingMlp.status == MlpStatus.APPROVED, "!approved");\n', '        require(block.timestamp >= pendingMlp.endDate, "not yet ended");\n', '\n', '        if (pendingMlp.liquidity > 0) {\n', '            IUniswapV2Pair pair = IUniswapV2Pair(pendingMlp.uniswapPair);\n', '            IERC20(address(pair)).safeTransfer(\n', '                pendingMlp.submitter,\n', '                pendingMlp.liquidity\n', '            );\n', '        }\n', '\n', '        pendingMlp.status = MlpStatus.ENDED;\n', '        emit MlpEnded(_mlpId);\n', '        return pendingMlp.liquidity;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'abstract contract IFeesController {\n', '    function feesTo() public virtual returns (address);\n', '    function setFeesTo(address) public virtual;\n', '\n', '    function feesPpm() public virtual returns (uint);\n', '    function setFeesPpm(uint) public virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', 'abstract contract IMintableERC20 is IERC20 {\n', '    function mint(uint amount) public virtual;\n', '    function mintTo(address account, uint amount) public virtual;\n', '    function burn(uint amount) public virtual;\n', '    function setMinter(address account, bool isMinter) public virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'abstract contract IMlp {\n', '    function makeOffer(address _token, uint _amount, uint _unlockDate, uint _endDate, uint _slippageTolerancePpm, uint _maxPriceVariationPpm) external virtual returns (uint offerId);\n', '\n', '    function takeOffer(uint _pendingOfferId, uint _amount, uint _deadline) external virtual returns (uint activeOfferId);\n', '\n', '    function cancelOffer(uint _offerId) external virtual;\n', '\n', '    function release(uint _offerId, uint _deadline) external virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'abstract contract IPopMarketplace {\n', '    function submitMlp(address _token0, address _token1, uint _liquidity, uint _endDate, uint _bonusToken0, uint _bonusToken1) public virtual;\n', '    function endMlp(uint _mlpId) public virtual returns(uint);\n', '    function cancelMlp(uint256 _mlpId) public virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'abstract contract IRewardManager {\n', '    function add(uint256 _allocPoint, address _newMlp) public virtual;\n', '    function notifyDeposit(address _account, uint256 _amount) public virtual;\n', '    function notifyWithdraw(address _account, uint256 _amount) public virtual;\n', '    function getPoolSupply(address pool) public view virtual returns(uint);\n', '    function getUserAmount(address pool, address user) public view virtual returns(uint);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol";\n', 'import "@openzeppelin/contracts/utils/Address.sol";\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../utils/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'pragma solidity >=0.6.2;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'pragma solidity >=0.6.2;\n', '\n', "import './IUniswapV2Router01.sol';\n", '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'pragma solidity =0.6.6;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', "import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n", '\n', 'import "./SafeMath.sol";\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 600\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']