['// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', "import '@solidstate/contracts/contracts/token/ERC20/ERC20.sol';\n", "import '@solidstate/contracts/contracts/token/ERC20/ERC20MetadataStorage.sol';\n", '\n', "import './AutoRewardTokenStorage.sol';\n", '\n', '/**\n', ' * @title Fee-on-transfer token with frictionless distribution to holders\n', ' * @author Nick Barry\n', ' */\n', 'contract AutoRewardToken is ERC20 {\n', '  using ERC20MetadataStorage for ERC20MetadataStorage.Layout;\n', '\n', '  uint private constant BP_DIVISOR = 10000;\n', '  uint private constant REWARD_SCALAR = 1e36;\n', '\n', '  constructor (\n', '    string memory name,\n', '    string memory symbol,\n', '    uint supply,\n', '    uint fee\n', '  ) {\n', "    require(fee <= BP_DIVISOR, 'AutoRewardToken: fee must not exceed 10000 bp');\n", '\n', '    {\n', '      ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\n', '      l.setName(name);\n', '      l.setSymbol(symbol);\n', '      l.setDecimals(18);\n', '    }\n', '\n', '    AutoRewardTokenStorage.layout().fee = fee;\n', '\n', '    _mint(msg.sender, supply);\n', '  }\n', '\n', '  /**\n', '   * @notice return network fee\n', '   * @return fee in basis points\n', '   */\n', '  function getFee () external view returns (uint) {\n', '    return AutoRewardTokenStorage.layout().fee;\n', '  }\n', '\n', '  /**\n', '   * @inheritdoc ERC20Base\n', '   */\n', '  function balanceOf (\n', '    address account\n', '  ) override public view returns (uint) {\n', '    return super.balanceOf(account) + rewardsOf(account);\n', '  }\n', '\n', '  /**\n', '   * @notice get pending rewards pending distribution to given account\n', '   * @param account owner of rewards\n', '   * @return quantity of rewards\n', '   */\n', '  function rewardsOf (\n', '    address account\n', '  ) public view returns (uint) {\n', '    AutoRewardTokenStorage.Layout storage l = AutoRewardTokenStorage.layout();\n', '    return (\n', '      super.balanceOf(account) * l.cumulativeRewardPerToken\n', '      + l.rewardsReserved[account]\n', '      - l.rewardsExcluded[account]\n', '    ) / REWARD_SCALAR;\n', '  }\n', '\n', '  /**\n', '   * @inheritdoc ERC20Base\n', '   * @notice override of _transfer function to include call to _afterTokenTransfer\n', '   */\n', '  function _transfer (\n', '    address sender,\n', '    address recipient,\n', '    uint amount\n', '  ) override internal {\n', '    super._transfer(sender, recipient, amount);\n', '    _afterTokenTransfer(sender, recipient, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice ERC20 hook: apply fees and distribute rewards on transfer\n', '   * @inheritdoc ERC20Base\n', '   */\n', '  function _beforeTokenTransfer (\n', '    address from,\n', '    address to,\n', '    uint amount\n', '  ) override internal {\n', '    super._beforeTokenTransfer(from, to, amount);\n', '\n', '    if (from == address(0) || to == address(0)) {\n', '      return;\n', '    }\n', '\n', '    AutoRewardTokenStorage.Layout storage l = AutoRewardTokenStorage.layout();\n', '\n', '    uint fee = amount * l.fee / BP_DIVISOR;\n', '\n', '    // update internal balances to include rewards\n', '\n', '    uint rewardsFrom = rewardsOf(from);\n', '    ERC20BaseStorage.layout().balances[from] += rewardsFrom;\n', '    delete l.rewardsReserved[from];\n', '\n', '    uint rewardsTo = rewardsOf(to);    \n', '    ERC20BaseStorage.layout().balances[to] += rewardsTo;\n', '    \n', '    delete l.rewardsReserved[to];\n', '\n', '    // track exclusions from future rewards\n', '\n', '    l.rewardsExcluded[from] = (super.balanceOf(from) - amount) * l.cumulativeRewardPerToken;\n', '    l.rewardsExcluded[to] = (super.balanceOf(to) + amount - fee) * l.cumulativeRewardPerToken;\n', '    \n', '    // distribute rewards globally\n', '\n', '    l.cumulativeRewardPerToken += (fee * REWARD_SCALAR) / (totalSupply() - fee);\n', '\n', '    // simulate transfers\n', '    emit Transfer(from, address(0), fee);\n', '    emit Transfer(address(0), from, rewardsFrom);\n', '    emit Transfer(address(0), to, rewardsTo);\n', '  }\n', '\n', '  /**\n', '   * @notice ERC20 hook: remove fee from recipient\n', '   * @param to recipient address\n', '   * @param amount quantity transferred\n', '   */\n', '  function _afterTokenTransfer (\n', '    address,\n', '    address to,\n', '    uint amount\n', '  ) private {\n', '    _burnFee(to, amount * AutoRewardTokenStorage.layout().fee / BP_DIVISOR);\n', '\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', "import './ERC20Base.sol';\n", "import './ERC20Extended.sol';\n", "import './ERC20Metadata.sol';\n", '\n', 'abstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library ERC20MetadataStorage {\n', '  bytes32 internal constant STORAGE_SLOT = keccak256(\n', "    'solidstate.contracts.storage.ERC20Metadata'\n", '  );\n', '\n', '  struct Layout {\n', '    string name;\n', '    string symbol;\n', '    uint8 decimals;\n', '  }\n', '\n', '  function layout () internal pure returns (Layout storage l) {\n', '    bytes32 slot = STORAGE_SLOT;\n', '    assembly { l.slot := slot }\n', '  }\n', '\n', '  function setName (\n', '    Layout storage l,\n', '    string memory name\n', '  ) internal {\n', '    l.name = name;\n', '  }\n', '\n', '  function setSymbol (\n', '    Layout storage l,\n', '    string memory symbol\n', '  ) internal {\n', '    l.symbol = symbol;\n', '  }\n', '\n', '  function setDecimals (\n', '    Layout storage l,\n', '    uint8 decimals\n', '  ) internal {\n', '    l.decimals = decimals;\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library AutoRewardTokenStorage {\n', '  bytes32 internal constant STORAGE_SLOT = keccak256(\n', "    'solidstate.contracts.storage.AutoRewardToken'\n", '  );\n', '\n', '  struct Layout {\n', '    uint fee;\n', '    uint cumulativeRewardPerToken;\n', '    mapping (address => uint) rewardsExcluded;\n', '    mapping (address => uint) rewardsReserved;\n', '  }\n', '\n', '  function layout () internal pure returns (Layout storage l) {\n', '    bytes32 slot = STORAGE_SLOT;\n', '    assembly { l.slot := slot }\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', "import '../../utils/SafeMath.sol';\n", "import './IERC20.sol';\n", "import './ERC20BaseStorage.sol';\n", '\n', 'abstract contract ERC20Base is IERC20 {\n', '  using SafeMath for uint;\n', '\n', '  function totalSupply () override virtual public view returns (uint) {\n', '    return ERC20BaseStorage.layout().totalSupply;\n', '  }\n', '\n', '  function balanceOf (\n', '    address account\n', '  ) override virtual public view returns (uint) {\n', '    return ERC20BaseStorage.layout().balances[account];\n', '  }\n', '\n', '  function allowance (\n', '    address holder,\n', '    address spender\n', '  ) override virtual public view returns (uint) {\n', '    return ERC20BaseStorage.layout().allowances[holder][spender];\n', '  }\n', '\n', '  function transfer (\n', '    address recipient,\n', '    uint amount\n', '  ) override virtual public returns (bool) {\n', '    _transfer(msg.sender, recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom (\n', '    address sender,\n', '    address recipient,\n', '    uint amount\n', '  ) override virtual public returns (bool) {\n', "    _approve(sender, msg.sender, ERC20BaseStorage.layout().allowances[sender][msg.sender].sub(amount, 'ERC20: transfer amount exceeds allowance'));\n", '    _transfer(sender, recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  function approve (\n', '    address spender,\n', '    uint amount\n', '  ) override virtual public returns (bool) {\n', '    _approve(msg.sender, spender, amount);\n', '    return true;\n', '  }\n', '\n', '  function _mint (\n', '    address account,\n', '    uint amount\n', '  ) virtual internal {\n', "    require(account != address(0), 'ERC20: mint to the zero address');\n", '\n', '    _beforeTokenTransfer(address(0), account, amount);\n', '\n', '    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n', '    l.totalSupply = l.totalSupply.add(amount);\n', '    l.balances[account] = l.balances[account].add(amount);\n', '\n', '    emit Transfer(address(0), account, amount);\n', '  }\n', '\n', '  function _burn (\n', '    address account,\n', '    uint amount\n', '  ) virtual internal {\n', "    require(account != address(0), 'ERC20: burn from the zero address');\n", '\n', '    _beforeTokenTransfer(account, address(0), amount);\n', '\n', '    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n', '    l.balances[account] = l.balances[account].sub(amount);\n', '    l.totalSupply = l.totalSupply.sub(amount);\n', '\n', '    emit Transfer(account, address(0), amount);\n', '  }\n', '\n', '   function _burnFee (\n', '    address account,\n', '    uint amount\n', '  ) virtual internal {\n', "    require(account != address(0), 'ERC20: burn from the zero address');\n", '\n', '    _beforeTokenTransfer(account, address(0), amount);\n', '\n', '    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n', '    l.balances[account] = l.balances[account].sub(amount);\n', '    //l.totalSupply = l.totalSupply.sub(amount);\n', '\n', '    //emit Transfer(account, address(0), amount);\n', '  }\n', '\n', '  function _transfer (\n', '    address sender,\n', '    address recipient,\n', '    uint amount\n', '  ) virtual internal {\n', "    require(sender != address(0), 'ERC20: transfer from the zero address');\n", "    require(recipient != address(0), 'ERC20: transfer to the zero address');\n", '\n', '    _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n', "    l.balances[sender] = l.balances[sender].sub(amount, 'ERC20: transfer amount exceeds balance');\n", '    l.balances[recipient] = l.balances[recipient].add(amount);\n', '\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '  function _approve (\n', '    address holder,\n', '    address spender,\n', '    uint amount\n', '  ) virtual internal {\n', "    require(holder != address(0), 'ERC20: approve from the zero address');\n", "    require(spender != address(0), 'ERC20: approve to the zero address');\n", '\n', '    ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n', '\n', '    emit Approval(holder, spender, amount);\n', '  }\n', '\n', '  function _beforeTokenTransfer (\n', '    address from,\n', '    address to,\n', '    uint amount\n', '  ) virtual internal {}\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', "import '../../utils/SafeMath.sol';\n", "import './ERC20Base.sol';\n", '\n', 'abstract contract ERC20Extended is ERC20Base {\n', '  using SafeMath for uint;\n', '\n', '  function increaseAllowance (address spender, uint amount) virtual public returns (bool) {\n', '    _approve(msg.sender, spender, ERC20BaseStorage.layout().allowances[msg.sender][spender].add(amount));\n', '    return true;\n', '  }\n', '\n', '  function decreaseAllowance (address spender, uint amount) virtual public returns (bool) {\n', '    _approve(msg.sender, spender, ERC20BaseStorage.layout().allowances[msg.sender][spender].sub(amount));\n', '    return true;\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', "import './ERC20Base.sol';\n", "import './ERC20MetadataStorage.sol';\n", '\n', 'abstract contract ERC20Metadata is ERC20Base {\n', '  function name () virtual public view returns (string memory) {\n', '    return ERC20MetadataStorage.layout().name;\n', '  }\n', '\n', '  function symbol () virtual public view returns (string memory) {\n', '    return ERC20MetadataStorage.layout().symbol;\n', '  }\n', '\n', '  function decimals () virtual public view returns (uint8) {\n', '    return ERC20MetadataStorage.layout().decimals;\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n', ' */\n', 'library SafeMath {\n', '  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    uint256 c = a + b;\n', '    if (c < a) return (false, 0);\n', '    return (true, c);\n', '  }\n', '\n', '  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    if (b > a) return (false, 0);\n', '    return (true, a - b);\n', '  }\n', '\n', '  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    if (a == 0) return (true, 0);\n', '    uint256 c = a * b;\n', '    if (c / a != b) return (false, 0);\n', '    return (true, c);\n', '  }\n', '\n', '  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    if (b == 0) return (false, 0);\n', '    return (true, a / b);\n', '  }\n', '\n', '  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    if (b == 0) return (false, 0);\n', '    return (true, a % b);\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath: subtraction overflow");\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) return 0;\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0, "SafeMath: division by zero");\n', '    return a / b;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      require(b > 0, "SafeMath: modulo by zero");\n', '    return a % b;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '      require(b <= a, errorMessage);\n', '    return a - b;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '      require(b > 0, errorMessage);\n', '    return a / b;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '      require(b > 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'interface IERC20 {\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint256 value\n', '  );\n', '\n', '  event Approval(\n', '    address indexed owner,\n', '    address indexed spender,\n', '    uint256 value\n', '  );\n', '\n', '  function totalSupply () external view returns (uint256);\n', '\n', '  function balanceOf (\n', '    address account\n', '  ) external view returns (uint256);\n', '\n', '  function transfer (\n', '    address recipient,\n', '    uint256 amount\n', '  ) external returns (bool);\n', '\n', '  function allowance (\n', '    address owner,\n', '    address spender\n', '  ) external view returns (uint256);\n', '\n', '  function approve (\n', '    address spender,\n', '    uint256 amount\n', '  ) external returns (bool);\n', '\n', '  function transferFrom (\n', '    address sender,\n', '    address recipient,\n', '    uint256 amount\n', '  ) external returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library ERC20BaseStorage {\n', '  bytes32 internal constant STORAGE_SLOT = keccak256(\n', "    'solidstate.contracts.storage.ERC20Base'\n", '  );\n', '\n', '  struct Layout {\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowances;\n', '    uint totalSupply;\n', '  }\n', '\n', '  function layout () internal pure returns (Layout storage l) {\n', '    bytes32 slot = STORAGE_SLOT;\n', '    assembly { l.slot := slot }\n', '  }\n', '}']