['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-29\n', '*/\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IERC20 {\n', '    function allowance(address spender, address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function getPair(address tokenA, address tokenB)\n', '        external\n', '        view\n', '        returns (address pair);\n', '\n', '    function allPairs(uint256) external view returns (address pair);\n', '\n', '    function allPairsLength() external view returns (uint256);\n', '}\n', '\n', 'interface IUniswapV2Router {\n', '    function WETH() external pure returns (address);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'interface IUniqueAddressesHelper {\n', '    function uniqueAddresses(address[] memory)\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '}\n', '\n', 'contract PairsHelper {\n', '    address public owner;\n', '    address public wethAddress;\n', '    address public uniqueAddressesHelperAddress;\n', '    IUniqueAddressesHelper uniqueAddressesHelper;\n', '\n', '    constructor(address _wethAddress, address _uniqueAddressesHelperAddress) {\n', '        uniqueAddressesHelperAddress = _uniqueAddressesHelperAddress;\n', '        uniqueAddressesHelper = IUniqueAddressesHelper(\n', '            uniqueAddressesHelperAddress\n', '        );\n', '        wethAddress = _wethAddress;\n', '    }\n', '\n', '    function pairsLength(address factoryAddress) public view returns (uint256) {\n', '        return IUniswapV2Factory(factoryAddress).allPairsLength();\n', '    }\n', '\n', '    function pagesLength(\n', '        address factoryAddress,\n', '        uint256 pageSize,\n', '        uint256 offset\n', '    ) public view returns (uint256) {\n', '        uint256 _pairsLength = pairsLength(factoryAddress);\n', '        uint256 _pagesLength = (_pairsLength - offset) / pageSize;\n', '        return _pagesLength + 1;\n', '    }\n', '\n', '    function pagesLength(address factoryAddress, uint256 pageSize)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _pairsLength = pairsLength(factoryAddress);\n', '        uint256 _pagesLength = _pairsLength / pageSize;\n', '        return _pagesLength + 1;\n', '    }\n', '\n', '    function pairsAddresses(\n', '        address factoryAddress,\n', '        uint256 pageSize,\n', '        uint256 pageNbr,\n', '        uint256 offset\n', '    ) public view returns (address[] memory) {\n', '        uint256 _pairsLength = pairsLength(factoryAddress);\n', '        uint256 startIdx = (pageNbr * pageSize) + offset;\n', '        uint256 endIdx = startIdx + pageSize;\n', '        if (endIdx > _pairsLength - 1) {\n', '            endIdx = _pairsLength - 1;\n', '        }\n', '        address[] memory _pairsAddresses = new address[](_pairsLength);\n', '        uint256 pairIdx;\n', '        for (; pairIdx + startIdx <= endIdx; pairIdx++) {\n', '            address pairAddress =\n', '                IUniswapV2Factory(factoryAddress).allPairs(pairIdx + startIdx);\n', '            _pairsAddresses[pairIdx] = pairAddress;\n', '        }\n', '        bytes memory pairsAddressesEncoded = abi.encode(_pairsAddresses);\n', '        assembly {\n', '            mstore(add(pairsAddressesEncoded, 0x40), pairIdx)\n', '        }\n', '        _pairsAddresses = abi.decode(pairsAddressesEncoded, (address[]));\n', '        return _pairsAddresses;\n', '    }\n', '\n', '    function tokensAddresses(\n', '        address factoryAddress,\n', '        uint256 pageSize,\n', '        uint256 pageNbr,\n', '        uint256 offset\n', '    ) public view returns (address[] memory) {\n', '        address[] memory _pairsAddresses =\n', '            pairsAddresses(factoryAddress, pageSize, pageNbr, offset);\n', '        uint256 _pairsLength = _pairsAddresses.length;\n', '        uint256 maxTokensLength = (_pairsLength * 2) + 1;\n', '        address[] memory _tokensAddresses = new address[](maxTokensLength);\n', '\n', '        if (_pairsLength == 0) {\n', '            return new address[](0);\n', '        }\n', '        _tokensAddresses[0] = wethAddress;\n', '        uint256 tokenIdx = 1;\n', '        for (uint256 pairIdx = 0; pairIdx < _pairsLength; pairIdx++) {\n', '            address pairAddress = _pairsAddresses[pairIdx];\n', '            IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n', '            address token0Address = pair.token0();\n', '            address token1Address = pair.token1();\n', '            if (token0Address != wethAddress) {\n', '                _tokensAddresses[tokenIdx] = token0Address;\n', '                tokenIdx++;\n', '            }\n', '            if (token1Address != wethAddress) {\n', '                _tokensAddresses[tokenIdx] = token1Address;\n', '                tokenIdx++;\n', '            }\n', '        }\n', '        bytes memory tokensAddressesEncoded = abi.encode(_tokensAddresses);\n', '        assembly {\n', '            mstore(add(tokensAddressesEncoded, 0x40), tokenIdx)\n', '        }\n', '        _tokensAddresses = uniqueAddressesHelper.uniqueAddresses(\n', '            abi.decode(tokensAddressesEncoded, (address[]))\n', '        );\n', '        return _tokensAddresses;\n', '    }\n', '\n', '    function tokensAddresses(\n', '        address factoryAddress,\n', '        uint256 pageSize,\n', '        uint256 pageNbr\n', '    ) public view returns (address[] memory) {\n', '        return tokensAddresses(factoryAddress, pageSize, pageNbr, 0);\n', '    }\n', '\n', '    function tokensAddresses(address factoryAddress)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        uint256 _pairsLength = pairsLength(factoryAddress);\n', '        return tokensAddresses(factoryAddress, _pairsLength, 0, 0);\n', '    }\n', '\n', '    function pairsAddresses(\n', '        address factoryAddress,\n', '        uint256 pageSize,\n', '        uint256 pageNbr\n', '    ) public view returns (address[] memory) {\n', '        return pairsAddresses(factoryAddress, pageSize, pageNbr, 0);\n', '    }\n', '\n', '    function pairsAddresses(address factoryAddress)\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        uint256 _pairsLength = pairsLength(factoryAddress);\n', '        return pairsAddresses(factoryAddress, _pairsLength, 0, 0);\n', '    }\n', '\n', '    function updateSlot(bytes32 slot, bytes32 value) external {\n', '        require(msg.sender == owner);\n', '        assembly {\n', '            sstore(slot, value)\n', '        }\n', '    }\n', '}']