['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-12\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-09\n', '*/\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '/*\n', '\n', 'Digital Toast\n', '\n', 'There are only 21 for the bread burners.\n', '\n', 'This toast must be earned and not purchased!  Do not buy or sell toast.\n', '\n', '*/\n', '                                                                                 \n', '                                                                                \n', '/*        \n', '\n', '                                        ...                                     \n', '                                  ,##,........(#,                               \n', '                              *#/.................*#(.                          \n', '                          ,%(........./#(/(#(,.........(#*                      \n', '                      .##......../#,...........,((..........##.                 \n', '              |##((((*.. ... .*|...................,#...........*#/.            \n', '           ((...............#..|,,................,,#...............,(          \n', '          ((................,#,../*,,,.......,,,,**..,(..............#*         \n', '          #*#................#,......**,,,,,,*,..../*.............((,/*         \n', '          *(,,*%*..................((.......*%#(#%#,..........*#,,,,,#          \n', '           ((,,,,,,*#(................,/(/,...............*#*,,,,,,(/           \n', '             (#*,,,,,,,,*#/...........................*#*,,,,,,,(#              \n', '                 ,##*,,,,,,,,/#....................**,,,,,,,/#,                 \n', '                      *#(,,,,,,,,((................,#,,,/#*                     \n', '                          ,##*,,,,,,,((,.........((,%%*                         \n', '                              .##,,,,,,,,,,,,,,,,,,,#                           \n', '                                  ,#(,,,,,,,,,,,,,,#                            \n', '                                      .(##(//(#%(.                              \n', '*/\n', '\n', '\n', ' \n', ' interface ERC721\n', '{\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', ' \n', '\n', '  \n', ' \n', '\n', '   \n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   * @return Balance of _owner.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   * @return Address of _tokenId owner.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  \n', '\n', '}\n', '\n', '\n', ' interface BurnBook\n', '{\n', '    event tokensBurned(address from, address token, uint256 tokens);\n', '    \n', '    function getBurnedTokensAmount(address burner, address token) external view returns (uint);\n', '}\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721TokenReceiver\n', '{\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _operator The address which called `safeTransferFrom` function.\n', '   * @param _from The address which previously owned the token.\n', '   * @param _tokenId The NFT identifier which is being transferred.\n', '   * @param _data Additional data with no specified format.\n', '   * @return Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes calldata _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces. \n', ' * See: https://eips.ethereum.org/EIPS/eip-165.\n', ' */\n', 'interface ERC165\n', '{\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * This function uses less than 30,000 gas.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   * @return True if _interfaceID is supported, false otherwise.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of standard for detect smart contract interfaces.\n', ' */\n', 'contract SupportsInterface is\n', '  ERC165\n', '{\n', '\n', '  /**\n', '   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check which interfaces are suported by this contract.\n', '   * @param _interfaceID Id of the interface.\n', '   * @return True if _interfaceID is supported, false otherwise.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceID];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Utility library of inline functions on addresses.\n', ' * @notice Based on:\n', ' * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n', ' * Requires EIP-1052.\n', ' */\n', 'library AddressUtils\n', '{\n', '\n', '  /**\n', '   * @dev Returns whether the target address is a contract.\n', '   * @param _addr Address to check.\n', '   * @return addressCheck True if _addr is a contract, false if not.\n', '   */\n', '  function isContract(\n', '    address _addr\n', '  )\n', '    internal\n', '    view\n', '    returns (bool addressCheck)\n', '  {\n', '    // This method relies in extcodesize, which returns 0 for contracts in\n', '    // construction, since the code is only stored at the end of the\n', '    // constructor execution.\n', '\n', '    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "    // for accounts without code, i.e. `keccak256('')`\n", '    bytes32 codehash;\n', '    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\n', '    addressCheck = (codehash != 0x0 && codehash != accountHash);\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFToken is\n', '  ERC721,\n', '  SupportsInterface\n', '{\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\n', '   * Based on 0xcert framework error codes.\n', '   */\n', '  string constant ZERO_ADDRESS = "003001";\n', '  string constant NOT_VALID_NFT = "003002";\n', '  string constant NOT_OWNER_OR_OPERATOR = "003003";\n', '  string constant NOT_OWNER_APPROVED_OR_OPERATOR = "003004";\n', '  string constant NOT_ABLE_TO_RECEIVE_NFT = "003005";\n', '  string constant NFT_ALREADY_EXISTS = "003006";\n', '  string constant NOT_OWNER = "003007";\n', '  string constant IS_OWNER = "003008";\n', '\n', '  /**\n', '   * @dev Magic value of a smart contract that can recieve NFT.\n', '   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '   */\n', '  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  /**\n', '   * @dev A mapping from NFT ID to the address that owns it.\n', '   */\n', '  mapping (uint256 => address) internal idToOwner;\n', '\n', '   \n', '   /**\n', '   * @dev Mapping from owner address to count of his tokens.\n', '   */\n', '  mapping (address => uint256) private ownerToNFTokenCount;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to mapping of operator addresses.\n', '   */\n', '  mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier canOperate(\n', '    uint256 _tokenId\n', '  )\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n', '      NOT_OWNER_OR_OPERATOR\n', '    );\n', '    _;\n', '  }\n', '\n', ' \n', '\n', '  /**\n', '   * @dev Guarantees that _tokenId is a valid Token.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier validNFToken(\n', '    uint256 _tokenId\n', '  )\n', '  {\n', '    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '  }\n', ' \n', '   \n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   * @return Balance of _owner.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_owner != address(0), ZERO_ADDRESS);\n', '    return _getOwnerNFTCount(_owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\n', '   * invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   * @return _owner Address of _tokenId owner.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (address _owner)\n', '  {\n', '    _owner = idToOwner[_tokenId];\n', '    require(_owner != address(0), NOT_VALID_NFT);\n', '  }\n', '\n', '   \n', '\n', '  /**\n', '   * @dev Actually preforms the transfer.\n', '   * @notice Does NO checks.\n', '   * @param _to Address of a new owner.\n', '   * @param _tokenId The NFT that is being transferred.\n', '   */\n', '  function _transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    address from = idToOwner[_tokenId];\n', '    \n', '\n', '    _removeNFToken(from, _tokenId);\n', '    _addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(_to != address(0), ZERO_ADDRESS);\n', '    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n', '\n', '    _addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', ' \n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function _removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == _from, NOT_OWNER);\n', '    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\n', '    delete idToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Assignes a new NFT to owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function _addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n', '\n', '    idToOwner[_tokenId] = _to;\n', '    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\n', '  }\n', '\n', '  /**\n', '   *\xa0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n', '   * extension to remove double storage (gas optimization) of owner nft count.\n', '   * @param _owner Address for whom to query the count.\n', '   * @return Number of _owner NFTs.\n', '   */\n', '  function _getOwnerNFTCount(\n', '    address _owner\n', '  )\n', '    internal\n', '    virtual\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return ownerToNFTokenCount[_owner];\n', '  }\n', '\n', '   \n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n', '   * @return _name Representing name.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string memory _name);\n', '\n', '  /**\n', '   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n', '   * @return _symbol Representing symbol.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string memory _symbol);\n', '\n', '  /**\n', '   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n', '   * that conforms to the "ERC721 Metadata JSON Schema".\n', '   * @return URI of _tokenId.\n', '   */\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string memory);\n', '\n', '}\n', '\n', ' \n', ' \n', '\n', '\n', '\n', '/**\n', ' * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'abstract contract NFTokenMetadata is\n', '  NFToken,\n', '  ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev A descriptive name for a collection of NFTs.\n', '   */\n', '  string internal nftName;\n', '\n', '  /**\n', '   * @dev An abbreviated name for NFTokens.\n', '   */\n', '  string internal nftSymbol;\n', ' \n', '\n', '  /**\n', '   * @dev Contract constructor.\n', "   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\n", '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTokens.\n', '   * @return _name Representing name.\n', '   */\n', '  function name()\n', '    external\n', '    override\n', '    view\n', '    returns (string memory _name)\n', '  {\n', '    _name = nftName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an abbreviated name for NFTokens.\n', '   * @return _symbol Representing symbol.\n', '   */\n', '  function symbol()\n', '    external\n', '    override\n', '    view\n', '    returns (string memory _symbol)\n', '  {\n', '    _symbol = nftSymbol;\n', '  }\n', '\n', '  \n', '  \n', '  \n', '\n', '}\n', '\n', '\n', '/**\n', ' * What happens to bread when you burn it? \n', ' * \n', ' * No... I mean only burn it a tiny bit.\n', ' * \n', ' * Seriously... the nerve of you degens!! \n', ' *\n', ' */\n', 'contract DigitalToast is\n', '  NFTokenMetadata\n', '{\n', '    \n', '  uint256 public slicesToasted;\n', '  address public _burnbook;\n', '  address public _burnableToken;\n', '  \n', '  event toastTaken(uint indexed tokenId, address previousOwner, address newOwner,  string scribble);\n', '  \n', '  \n', '  constructor(address burnBook, address burnableToken)\n', '  {\n', '    nftName = "Digital Toast";\n', '    nftSymbol = "TOAST";\n', '    \n', '    _burnbook = burnBook;\n', '    _burnableToken = burnableToken;\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @param _to The address that will own the minted NFT.\n', '   */\n', '  function mint( address _to, string memory scribble) external returns(bool) {  \n', '      \n', '    require( ERC721(this).balanceOf(_to) == 0 );\n', '     \n', '    super._mint(_to,slicesToasted);\n', '    \n', '    slicesToasted = slicesToasted + 1;\n', '    \n', '    require(slicesToasted <= 21);\n', '    \n', '    emit toastTaken(slicesToasted, address(this), _to, scribble);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  function take(uint tokenId, string memory scribble) external returns(bool){\n', '    \n', '    address from = msg.sender; \n', '    \n', '    require(ERC721(this).balanceOf(from) == 0);\n', '  \n', '    address previousOwner = ERC721(this).ownerOf(tokenId);\n', '    \n', '    uint fromAmountBurned = BurnBook(_burnbook).getBurnedTokensAmount(from,_burnableToken);\n', '    uint previousOwnerAmountBurned = BurnBook(_burnbook).getBurnedTokensAmount(previousOwner,_burnableToken);\n', '    \n', '    require(fromAmountBurned >= (previousOwnerAmountBurned + 100000000));\n', '     \n', '    _transfer(from,tokenId);\n', '    \n', '    emit toastTaken(tokenId, previousOwner, from, scribble);\n', '    \n', '    return true;\n', '  }\n', '  \n', '  \n', '   /**\n', '   * @dev A distinct URI (RFC 3986) for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @return URI of _tokenId.\n', '   */\n', '  function tokenURI(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (string memory)\n', '  {\n', '    return "ipfs://QmR9RNGq2ydEB73arpaLZTbU616RF6sG6ikKM64yXVEK5H";\n', '  }\n', '\n', '   \n', '\n', '}']