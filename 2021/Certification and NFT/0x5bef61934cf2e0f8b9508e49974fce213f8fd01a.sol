['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-21\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.3;\n', '\n', 'interface ERC165 {\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '}\n', 'interface ERC721 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata) external;\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '    function approve(address _approved, uint256 _tokenId) external;\n', '    function setApprovalForAll(address _operator, bool _approved) external;\n', '    function getApproved(uint256 _tokenId) external view returns (address);\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '}\n', 'interface ERC721Metadata {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 _tokenId) external view returns (string memory);\n', '}\n', 'interface ERC721Enumerable {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 _index) external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n', '}\n', 'interface ERC721TokenReceiver {\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata) external returns (bytes4);\n', '}\n', '\n', 'contract IDS_LR_MARS is ERC721, ERC721Metadata, ERC721Enumerable, ERC165 {\n', '    address payable private IDS;\n', '    bool private __OTC = true;\n', '    uint256 private __transactionFeePerMil = 1;\n', '\n', '    mapping (uint256 => address) private __owners;\n', '    mapping (address => uint256) private __balances;\n', '    mapping (uint256 => address) private __tokenApprovals;\n', '    mapping (address => mapping (address => bool)) private __operatorApprovals;\n', '    uint256[] private __allTokens;\n', '    mapping(uint256 => uint256) private __allTokensIndex;\n', '    mapping(address => mapping(uint256 => uint256)) private __ownedTokens;\n', '    mapping(uint256 => uint256) private __ownedTokensIndex;\n', '\n', '    struct __trade {\n', '        address seller;\n', '        uint256 price;\n', '        bytes16 status;\n', '    }\n', '    mapping (uint256 => __trade) private __trades;\n', '    event TradeStatusChange(uint256 indexed _tokenId, address _from, address _to, uint256 _price, bytes16 _status);\n', '\n', '    constructor() {\n', '        IDS = payable(msg.sender);\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n', '        return interfaceID == type(ERC721).interfaceId || interfaceID == type(ERC721Metadata).interfaceId || interfaceID == type(ERC721Enumerable).interfaceId || interfaceID == type(ERC165).interfaceId;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view override returns (uint256) {\n', '        require(_owner != address(0), "ERC721: balance query for the zero address");\n', '\n', '        return __balances[_owner];\n', '    }\n', '    function ownerOf(uint256 _tokenId) public view override returns (address) {\n', '        address owner = __owners[_tokenId];\n', '        require(owner != address(0), "ERC721: owner query for unregistered token");\n', '\n', '        return owner;\n', '    }\n', '    function name() external pure override returns (string memory) {\n', '        return "IDS-LR-MARS";\n', '    }\n', '    function symbol() external pure override returns (string memory) {\n', '        return "MARS";\n', '    }\n', '    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n', '        require(__isRegistered(_tokenId), "ERC721Metadata: URI query for unregistered token");\n', '\n', '        return string(abi.encodePacked("https://mars.departmentofspace.org/tokens/", __tokenString(_tokenId)));\n', '    }\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return __allTokens.length;\n', '    }\n', '    function tokenByIndex(uint256 _index) public view virtual override returns (uint256) {\n', '        require(_index < totalSupply(), "ERC721Enumerable: global index out of bounds");\n', '\n', '        return __allTokens[_index];\n', '    }\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view virtual override returns (uint256) {\n', '        require(_index < balanceOf(_owner), "ERC721Enumerable: owner index out of bounds");\n', '\n', '        return __ownedTokens[_owner][_index];\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public override {\n', '        transferFrom(_from, _to, _tokenId);\n', '\n', '        require(__checkOnERC721Received(_from, _to, _tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\n', '        safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public override {\n', '        address owner = ownerOf(_tokenId);\n', '\n', '        require(__OTC, "IDS_LR_MARS: over-the-counter trading is currently prohibited");\n', '        require(__trades[_tokenId].status != "Opened", "IDS_LR_MARS: token on sale");\n', '        require(owner == msg.sender || __tokenApprovals[_tokenId] == msg.sender || __operatorApprovals[owner][msg.sender], "ERC721: transfer caller is not owner nor approved");\n', '        require(owner == _from, "ERC721: transfer of token that is not own");\n', '        require(_to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        __tokenApprovals[_tokenId] = address(0);\n', '        emit Approval(owner, address(0), _tokenId);\n', '\n', '        uint256 lastTokenIndex = balanceOf(_from) - 1;\n', '        uint256 tokenIndex = __ownedTokensIndex[_tokenId];\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = __ownedTokens[_from][lastTokenIndex];\n', '            __ownedTokens[_from][tokenIndex] = lastTokenId;\n', '            __ownedTokensIndex[lastTokenId] = tokenIndex;\n', '        }\n', '        delete __ownedTokensIndex[_tokenId];\n', '        delete __ownedTokens[_from][lastTokenIndex];\n', '        uint256 length = balanceOf(_to);\n', '        __ownedTokens[_to][length] = _tokenId;\n', '        __ownedTokensIndex[_tokenId] = length;\n', '\n', '        __owners[_tokenId] = _to;\n', '        __balances[_from]--;\n', '        __balances[_to]++;\n', '        emit Transfer(_from, _to, _tokenId);\n', '    }\n', '\n', '    function approve(address _approved, uint256 _tokenId) external override {\n', '        address owner = ownerOf(_tokenId);\n', '\n', '        require(_approved != owner, "ERC721: approval to current owner");\n', '        require(msg.sender == owner || __operatorApprovals[owner][msg.sender], "ERC721: approve caller is not owner nor approved for all");\n', '\n', '        __tokenApprovals[_tokenId] = _approved;\n', '        emit Approval(owner, _approved, _tokenId);\n', '    }\n', '    function setApprovalForAll(address _operator, bool _approved) external override {\n', '        require(_operator != msg.sender, "ERC721: approve to caller");\n', '\n', '        __operatorApprovals[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '    function getApproved(uint256 _tokenId) external view override returns (address) {\n', '        require(__isRegistered(_tokenId), "ERC721: approved query for unregistered token");\n', '\n', '        return __tokenApprovals[_tokenId];\n', '    }\n', '    function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n', '        return __operatorApprovals[_owner][_operator];\n', '    }\n', '\n', '    \n', '    function register(uint256 _tokenId) external payable {\n', '        require(msg.sender != address(0), "ERC721: registration to the zero address");\n', '        require(!__isRegistered(_tokenId), "ERC721: token already registered");\n', '        require(__isValidToken(_tokenId), "IDS_LR_MARS: invalid token");\n', '        require(msg.value == __registrationFeeOf(_tokenId), "IDS_LR_MARS: incorrect registration fee");\n', '\n', '        __allTokensIndex[_tokenId] = __allTokens.length;\n', '        __allTokens.push(_tokenId);\n', '        uint256 length = balanceOf(msg.sender);\n', '        __ownedTokens[msg.sender][length] = _tokenId;\n', '        __ownedTokensIndex[_tokenId] = length;\n', '\n', '        IDS.transfer(msg.value);\n', '        __balances[msg.sender]++;\n', '        __owners[_tokenId] = msg.sender;\n', '        emit Transfer(address(0), msg.sender, _tokenId);\n', '\n', '        require(__checkOnERC721Received(address(0), msg.sender, _tokenId, ""), "ERC721: transfer to non ERC721Receiver implementer");\n', '\n', '        __trades[_tokenId] = __trade({\n', '            seller: address(0),\n', '            price: 0,\n', '            status: "Registered"\n', '        });\n', '        emit TradeStatusChange(_tokenId, address(0), msg.sender, 0, "Registered");\n', '    }\n', '    function sell(uint256 _tokenId, uint256 _price) external {\n', '        address owner = ownerOf(_tokenId);\n', '        require(msg.sender == owner || __operatorApprovals[owner][msg.sender], "ERC721: sell caller is not owner nor approved for all");\n', '        require(__trades[_tokenId].status != "Opened", "IDS_LR_MARS: token already on sale");\n', '\n', '        __trades[_tokenId] = __trade({\n', '            seller: msg.sender,\n', '            price: _price,\n', '            status: "Opened"\n', '        });\n', '        emit TradeStatusChange(_tokenId, owner, address(0), _price, "Opened");\n', '    }\n', '    function cancelTrade(uint256 _tokenId) external {\n', '        address owner = ownerOf(_tokenId);\n', '        __trade memory trade = __trades[_tokenId];\n', '        require(msg.sender == owner || __operatorApprovals[owner][msg.sender], "ERC721: cancle caller is not owner nor approved for all");\n', '        require(trade.status == "Opened", "IDS_LR_MARS: token not for sale");\n', '\n', '        __trades[_tokenId].status = "Canceled";\n', '        emit TradeStatusChange(_tokenId, owner, owner, trade.price, "Canceled");\n', '    }\n', '    function buy(uint256 _tokenId) external payable {\n', '        address owner = ownerOf(_tokenId);\n', '        __trade memory trade = __trades[_tokenId];\n', '        require(trade.status == "Opened", "IDS_LR_MARS: token not for sale");\n', '        require(msg.value == trade.price, "IDS_LR_MARS: incorrect price");\n', '        require(msg.sender != address(0), "ERC721: transfer to the zero address");\n', '\n', '        __tokenApprovals[_tokenId] = address(0);\n', '        emit Approval(owner, address(0), _tokenId);\n', '\n', '        uint256 lastTokenIndex = balanceOf(owner) - 1;\n', '        uint256 tokenIndex = __ownedTokensIndex[_tokenId];\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = __ownedTokens[owner][lastTokenIndex];\n', '            __ownedTokens[owner][tokenIndex] = lastTokenId;\n', '            __ownedTokensIndex[lastTokenId] = tokenIndex;\n', '        }\n', '        delete __ownedTokensIndex[_tokenId];\n', '        delete __ownedTokens[owner][lastTokenIndex];\n', '        uint256 length = balanceOf(msg.sender);\n', '        __ownedTokens[msg.sender][length] = _tokenId;\n', '        __ownedTokensIndex[_tokenId] = length;\n', '\n', '        uint256 transactionFee = msg.value * __transactionFeePerMil / 1000;\n', '        IDS.transfer(transactionFee);\n', '\n', '        payable(owner).transfer(msg.value - transactionFee);\n', '        __owners[_tokenId] = msg.sender;\n', '        __balances[owner]--;\n', '        __balances[msg.sender]++;\n', '        emit Transfer(owner, msg.sender, _tokenId);\n', '\n', '        require(__checkOnERC721Received(owner, msg.sender, _tokenId, ""), "ERC721: transfer to non ERC721Receiver implementer");\n', '\n', '        __trades[_tokenId].status = "Settled";\n', '        emit TradeStatusChange(_tokenId, owner, msg.sender, trade.price, "Settled");\n', '    }\n', '\n', '    function __registrationFeeOf(uint256 _tokenId) public pure returns (uint256) {\n', '        require(__isValidToken(_tokenId), "IDS_LR_MARS: invalid token");\n', '\n', '        uint256 section = (_tokenId / 100000000) % 10;\n', '        if (section == 4) return   12500000000000000;\n', '        if (section == 3) return  625000000000000000;\n', '        if (section == 2) return 1250000000000000000;\n', '        else              return 2500000000000000000;\n', '    }\n', '    function __dataOf(uint256 _tokenId) external view returns (address, bytes16, uint256) {\n', '        address owner = ownerOf(_tokenId);\n', '        __trade memory trade = __trades[_tokenId];\n', '        return (owner, trade.status, trade.price);\n', '    }\n', '    function __delegate(address _to) external {\n', '        require(msg.sender == IDS);\n', '\n', '        IDS = payable(_to);\n', '    }\n', '    function __setOTC(bool _permission) external {\n', '        require(msg.sender == IDS);\n', '\n', '        __OTC = _permission;\n', '    }\n', '    function __setTransactionFee(uint256 _feePerMil) external {\n', '        require(msg.sender == IDS);\n', '        require(_feePerMil < 1000);\n', '\n', '        __transactionFeePerMil = _feePerMil;\n', '    }\n', '\n', '    function __isRegistered(uint256 _tokenId) private view returns (bool) {\n', '        return __owners[_tokenId] != address(0);\n', '    }\n', '    function __tokenString(uint256 _tokenId) private pure returns (string memory) {\n', '        if (_tokenId == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = _tokenId;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        while (_tokenId != 0) {\n', '            digits -= 1;\n', '            buffer[digits] = bytes1(uint8(48 + uint256(_tokenId % 10)));\n', '            _tokenId /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '    function __checkOnERC721Received(address _from, address _to, uint256 _tokenId, bytes memory data) private returns (bool) {\n', '        uint32 size;\n', '        assembly {\n', '            size := extcodesize(_to)\n', '        }\n', '        if (size > 0) {\n', '            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\n', '            return receiver.onERC721Received(msg.sender, _from, _tokenId, data) == bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '    function __isValidToken(uint256 _tokenId) internal pure returns (bool) {\n', '        uint256 section = _tokenId / 100000000;\n', '        uint256 NS = (_tokenId / 10000000) % 10;\n', '        uint256 lat = (_tokenId / 10000) % 1000;\n', '        uint256 lng = _tokenId % 10000;\n', '\n', '        return NS < 2 && ((section == 1 && lat > 80 && lat <= 90 && lng > 0 && lng <= 45)\n', '                       || (section == 2 && lat > 70 && lat <= 80 && lng > 0 && lng <= 90)\n', '                       || (section == 3 && lat > 60 && lat <= 70 && lng > 0 && lng <= 180)\n', '                       || (section == 4 && lat > 0 && lat <= 300 && lng > 0 && lng <= 1800));\n', '    }\n', '}\n', '\n', '// Copyright © 2021 INTERNATIONAL DEPARTMENT OF SPACE. All rights reserved.']