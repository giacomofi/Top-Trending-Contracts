['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.4;\n', '// pragma experimental SMTChecker;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IERC20Metadata is IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract ERC20 is Context, IERC20, IERC20Metadata {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view virtual override returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', 'contract DiamondHandsToken is ERC20("DiamondHands", unicode"ðŸ’ŽðŸ™Œ") {\n', '    //// constants\n', '\n', '    // balance has to be 100 tokens to become a diamond member who can:\n', '    // - invite people and get bonus from their purchases\n', '    // - buy extra tokens cheaper\n', '    uint256 constant MINIMUM_DIAMOND_MEMBER_BALANCE = 100 * 1e18;\n', '    // diamond members get 20% discount on purchases above 100 tokens\n', '    uint256 constant DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 200;\n', '    // diamond members get 10% extra bonus tokens from people they invited, \n', '    // until those become diamond members themselves\n', '    uint256 constant DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND = 100;\n', '    // invited people get 10% discount on purchases,\n', '    // until they become diamond members and get 20% diamond discount\n', '    uint256 constant INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND = 100;\n', '\n', '    // Price growth\n', '    // - the price grows 5% upon every iteration\n', '    // - new iteration lasts 30-90 minutes and starts:\n', '    //   * either after 100 tokens were bought in the current iteration (fast growth due to popularity),\n', '    //   * or, if somebody buys or sells tokens after 90 minutes of no growth (slow growth)\n', '\n', '    // initial token price is 0.001 ETH per token\n', '    uint256 constant INITIAL_PRICE_ETH_WEI = 1e15;\n', '    // for non-diamond and non-invited members the purchase price is sell price + 80%\n', '    uint256 constant PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND = 1800;\n', '    // price grows 5% each iteration\n', '    uint256 constant PRICE_GROWTH_MULTIPLIER_PER_THOUSAND = 1050;\n', '    // maximum speed that the price can grow is once per 30 minutes\n', '    uint256 constant MINIMUM_GROWTH_ITERATION_PERIOD = 30 minutes;\n', '    // after 90 minutes of no growth (low activity), the price will still grow\n', '    uint256 constant SLOW_GROWTH_ITERATION_PERIOD = 90 minutes;\n', '    // at least 100 tokens have to be sold for fast growth\n', '    uint256 constant FAST_GROWTH_THRESHOLD = 100 * 1e18;\n', '    \n', '    //// events\n', '    event NewPrice(uint256 timestamp, uint256 newPrice);\n', '\n', '    //// state\n', '    mapping (address => address) private _introducers;\n', '    uint256 private _sellPriceEthWei;\n', '    uint256 private _lastPriceGrowthTimestamp;\n', '    uint256 private _purchasedTokensForFastGrowthSoFar = 0;\n', '    \n', '    //// private\n', '    constructor() payable {\n', '        emit NewPrice(\n', '            _lastPriceGrowthTimestamp = block.timestamp,\n', '            _sellPriceEthWei = INITIAL_PRICE_ETH_WEI\n', '            );\n', '        // no pre-mine\n', '    }\n', '\n', '    function _isDiamondMember(address member) private view returns(bool) {\n', '        return balanceOf(member) >= MINIMUM_DIAMOND_MEMBER_BALANCE;\n', '    }\n', '    function _registerUnderIntroducer(address introducer) private {\n', '        require(msg.sender != introducer,\n', '            "Members cannot introduce themselves");\n', '        require(_introducers[msg.sender] == address(0) || _introducers[msg.sender] == introducer, \n', '            "Introducer cannot be changed later");\n', '        require(_isDiamondMember(introducer), \n', '            "Provided introducer address is not a Diamond member at this moment");\n', '        _introducers[msg.sender] = introducer;\n', '    }\n', '    function _growIfAccumulatedEnough(uint256 amountBought) private {\n', '        // check if we should make the price grow\n', '        uint256 accumulated = _purchasedTokensForFastGrowthSoFar + amountBought;\n', '        uint256 lastPriceGrowthTimestamp = _lastPriceGrowthTimestamp;\n', '        uint256 blockTimestamp = block.timestamp;\n', '        if (\n', '            // fast growth condition\n', '            (accumulated > FAST_GROWTH_THRESHOLD\n', '            && (lastPriceGrowthTimestamp + MINIMUM_GROWTH_ITERATION_PERIOD) <= blockTimestamp)\n', '            ||\n', '            // slow growth condition\n', '            (lastPriceGrowthTimestamp + SLOW_GROWTH_ITERATION_PERIOD) <= blockTimestamp\n', '            ) {\n', '            // start new iteration with new price\n', '            _purchasedTokensForFastGrowthSoFar = 0;\n', '            emit NewPrice(\n', '                _lastPriceGrowthTimestamp = blockTimestamp,\n', '                _sellPriceEthWei = _sellPriceEthWei * PRICE_GROWTH_MULTIPLIER_PER_THOUSAND / 1000\n', '                );\n', '        }\n', '        else {\n', '            _purchasedTokensForFastGrowthSoFar = accumulated;\n', '        }\n', '    }\n', '    function _sell(uint256 amount) private {\n', '        uint256 sellPriceEthWei = _sellPriceEthWei;\n', '        _growIfAccumulatedEnough(0);\n', '        _burn(msg.sender, amount);\n', '        payable(msg.sender).transfer(amount * sellPriceEthWei / 1e18);\n', '    }\n', '    function _buy(uint256 ethWeiAmount) private {\n', '        uint256 sellPriceEthWei = _sellPriceEthWei;\n', '        uint256 amountBought = 0;\n', '        uint256 myBalance = balanceOf(msg.sender);\n', '        address introducer = _introducers[msg.sender];\n', '\n', '        // if not a diamond member yet, buy at non-diamond price\n', '        if (myBalance < MINIMUM_DIAMOND_MEMBER_BALANCE) {\n', '            uint256 nonDiamondBuyPriceInEthWei = \n', '                introducer != address(0) \n', '                    // if we have an introducer, get a discounted price\n', '                    ? (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n', '                        / (1000 * 1000))\n', '                    // else get a normal price\n', '                    : (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000);\n', '            uint256 amountAtThisPrice = ethWeiAmount * 1e18 / nonDiamondBuyPriceInEthWei;\n', '\n', "            // if didn't become a diamond member while buying\n", '            if (myBalance + amountAtThisPrice <= MINIMUM_DIAMOND_MEMBER_BALANCE) {\n', '                // buy the whole amount\n', '                amountBought = amountAtThisPrice;\n', '                ethWeiAmount = 0;\n', '            }\n', '            else {\n', '                // buy just enough to become a diamond member, and buy the rest at diamond price\n', '                amountBought = MINIMUM_DIAMOND_MEMBER_BALANCE - myBalance;\n', '                ethWeiAmount -= amountBought * nonDiamondBuyPriceInEthWei / 1e18;\n', '            }\n', '        }\n', '\n', '        // if still have money at this point, buy at diamond price\n', '        if (ethWeiAmount > 0) {\n', '            uint256 diamondBuyPriceInEthWei = \n', '                (sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n', '                        / (1000 * 1000));\n', '            amountBought += ethWeiAmount * 1e18 / diamondBuyPriceInEthWei;\n', '        }\n', '\n', '        // grow the price\n', '        _growIfAccumulatedEnough(amountBought);\n', '        // mint the tokens\n', '        _mint(msg.sender, amountBought);\n', '        // mint tokens for the introducer\n', '        if (introducer != address(0)) {\n', '            _mint(introducer, amountBought * DIAMOND_MEMBER_INTRODUCER_BONUS_TOKENS_PER_THOUSAND / 1000);\n', '        }\n', '    }\n', '\n', '    //// view\n', '    function haveIntroducer() public view returns(bool) { return _introducers[msg.sender] != address(0); }\n', '    function amDiamondMember() public view returns(bool) { return _isDiamondMember(msg.sender); }\n', '    function getSellPrice() public view returns(uint256) { return _sellPriceEthWei; }\n', '    function getBasicBuyPrice() public view returns(uint256) {\n', '        return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\n', '    }\n', '    function getBuyPriceWithMyDiscounts() public view returns(uint256) {\n', '        if (_isDiamondMember(msg.sender)) {\n', '            return \n', '                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - DIAMOND_MEMBER_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n', '                / (1000 * 1000);\n', '        }\n', '        else if (_introducers[msg.sender] != address(0)) {\n', '            return\n', '                _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND * (1000 - INVITED_PURCHASE_PRICE_DISCOUNT_PER_THOUSAND) \n', '                / (1000 * 1000);\n', '        }\n', '        else {\n', '            return _sellPriceEthWei * PURCHASE_PRICE_MILTIPLIER_PER_THOUSAND / 1000;\n', '        }\n', '    }\n', '    function getTokensBoughtAfterLastGrowth() public view returns(uint256) { return _purchasedTokensForFastGrowthSoFar; }\n', '    function getUiState() public view returns(\n', '        uint256 secondsElapsed, \n', '        uint256 tokensSold, \n', '        uint256 sellPrice, \n', '        uint256 buyPriceBasic, \n', '        uint256 buyPricePersonal, \n', '        uint256 balance, \n', '        bool invited, \n', '        bool diamond) {\n', '        return (\n', '            block.timestamp - _lastPriceGrowthTimestamp,\n', '            _purchasedTokensForFastGrowthSoFar,\n', '            _sellPriceEthWei,\n', '            getBasicBuyPrice(),\n', '            getBuyPriceWithMyDiscounts(),\n', '            balanceOf(msg.sender),\n', '            haveIntroducer(),\n', '            amDiamondMember()\n', '            );\n', '    }\n', '\n', '    //// callable from outside\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return address(this).balance * 1e18 / _sellPriceEthWei;\n', '    }\n', '    function buy() external payable {\n', '        require(msg.value > 0,\n', '            "Please send ETH to purchase tokens");\n', '        _buy(msg.value);\n', '    }\n', '    function buyAndRegisterUnderIntroducer(address introducer) external payable {\n', '        require(msg.value > 0,\n', '            "Please send ETH to purchase tokens");\n', '        require(introducer != address(0),\n', '            "Please specify an introducer to register under");\n', '        _registerUnderIntroducer(introducer);\n', '        _buy(msg.value);\n', '    }\n', '    function sell(uint256 amount) external {\n', '        require(amount > 0,\n', '            "Please provide the amount of tokens to sell");\n', '        _sell(amount);\n', '    }\n', '    function sellAll() external {\n', '        uint256 balance = balanceOf(msg.sender);\n', '        require(balance > 0,\n', '            "You don\'t have any tokens to sell");\n', '        _sell(balance);\n', '    }\n', '}']