['# @version 0.2.12\n', '"""\n', '@title Yearn Token Vault\n', '@license GNU AGPLv3\n', '@author yearn.finance\n', '@notice\n', '    Yearn Token Vault. Holds an underlying token, and allows users to interact\n', '    with the Yearn ecosystem through Strategies connected to the Vault.\n', '    Vaults are not limited to a single Strategy, they can have as many Strategies\n', '    as can be designed (however the withdrawal queue is capped at 20.)\n', '\n', '    Deposited funds are moved into the most impactful strategy that has not\n', '    already reached its limit for assets under management, regardless of which\n', "    Strategy a user's funds end up in, they receive their portion of yields\n", '    generated across all Strategies.\n', '\n', '    When a user withdraws, if there are no funds sitting undeployed in the\n', '    Vault, the Vault withdraws funds from Strategies in the order of least\n', "    impact. (Funds are taken from the Strategy that will disturb everyone's\n", '    gains the least, then the next least, etc.) In order to achieve this, the\n', "    withdrawal queue's order must be properly set and managed by the community\n", '    (through governance).\n', '\n', '    Vault Strategies are parameterized to pursue the highest risk-adjusted yield.\n', '\n', '    There is an "Emergency Shutdown" mode. When the Vault is put into emergency\n', '    shutdown, assets will be recalled from the Strategies as quickly as is\n', '    practical (given on-chain conditions), minimizing loss. Deposits are\n', '    halted, new Strategies may not be added, and each Strategy exits with the\n', '    minimum possible damage to position, while opening up deposits to be\n', '    withdrawn by users. There are no restrictions on withdrawals above what is\n', '    expected under Normal Operation.\n', '\n', '    For further details, please refer to the specification:\n', '    https://github.com/iearn-finance/yearn-vaults/blob/master/SPECIFICATION.md\n', '"""\n', '\n', 'API_VERSION: constant(String[28]) = "0.4.2"\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', '\n', 'interface DetailedERC20:\n', '    def name() -> String[42]: view\n', '    def symbol() -> String[20]: view\n', '    def decimals() -> uint256: view\n', '\n', '\n', 'interface Strategy:\n', '    def want() -> address: view\n', '    def vault() -> address: view\n', '    def isActive() -> bool: view\n', '    def delegatedAssets() -> uint256: view\n', '    def estimatedTotalAssets() -> uint256: view\n', '    def withdraw(_amount: uint256) -> uint256: nonpayable\n', '    def migrate(_newStrategy: address): nonpayable\n', '\n', '\n', 'event Transfer:\n', '    sender: indexed(address)\n', '    receiver: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'event Approval:\n', '    owner: indexed(address)\n', '    spender: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'decimals: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'allowance: public(HashMap[address, HashMap[address, uint256]])\n', 'totalSupply: public(uint256)\n', '\n', 'token: public(ERC20)\n', 'governance: public(address)\n', 'management: public(address)\n', 'guardian: public(address)\n', 'pendingGovernance: address\n', '\n', 'struct StrategyParams:\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '    activation: uint256  # Activation block.timestamp\n', '    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n', '    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n', '    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n', '    lastReport: uint256  # block.timestamp of the last time a report occured\n', '    totalDebt: uint256  # Total outstanding debt that Strategy has\n', '    totalGain: uint256  # Total returns that Strategy has realized for Vault\n', '    totalLoss: uint256  # Total losses that Strategy has realized for Vault\n', '\n', '\n', 'event StrategyAdded:\n', '    strategy: indexed(address)\n', '    debtRatio: uint256  # Maximum borrow amount (in BPS of total assets)\n', '    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n', '    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n', "    performanceFee: uint256  # Strategist's fee (basis points)\n", '\n', '\n', 'event StrategyReported:\n', '    strategy: indexed(address)\n', '    gain: uint256\n', '    loss: uint256\n', '    debtPaid: uint256\n', '    totalGain: uint256\n', '    totalLoss: uint256\n', '    totalDebt: uint256\n', '    debtAdded: uint256\n', '    debtRatio: uint256\n', '\n', '\n', 'event UpdateGovernance:\n', '    governance: address # New active governance\n', '\n', '\n', 'event UpdateManagement:\n', '    management: address # New active manager\n', '\n', 'event UpdateRewards:\n', '    rewards: address # New active rewards recipient\n', '\n', '\n', 'event UpdateDepositLimit:\n', '    depositLimit: uint256 # New active deposit limit\n', '\n', '\n', 'event UpdatePerformanceFee:\n', '    performanceFee: uint256 # New active performance fee\n', '\n', '\n', 'event UpdateManagementFee:\n', '    managementFee: uint256 # New active management fee\n', '\n', '\n', 'event UpdateGuardian:\n', '    guardian: address # Address of the active guardian\n', '\n', '\n', 'event EmergencyShutdown:\n', '    active: bool # New emergency shutdown state (if false, normal operation enabled)\n', '\n', '\n', 'event UpdateWithdrawalQueue:\n', '    queue: address[MAXIMUM_STRATEGIES] # New active withdrawal queue\n', '\n', '\n', 'event StrategyUpdateDebtRatio:\n', '    strategy: indexed(address) # Address of the strategy for the debt ratio adjustment\n', '    debtRatio: uint256 # The new debt limit for the strategy (in BPS of total assets)\n', '\n', '\n', 'event StrategyUpdateMinDebtPerHarvest:\n', '    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n', '    minDebtPerHarvest: uint256  # Lower limit on the increase of debt since last harvest\n', '\n', '\n', 'event StrategyUpdateMaxDebtPerHarvest:\n', '    strategy: indexed(address) # Address of the strategy for the rate limit adjustment\n', '    maxDebtPerHarvest: uint256  # Upper limit on the increase of debt since last harvest\n', '\n', '\n', 'event StrategyUpdatePerformanceFee:\n', '    strategy: indexed(address) # Address of the strategy for the performance fee adjustment\n', '    performanceFee: uint256 # The new performance fee for the strategy\n', '\n', '\n', 'event StrategyMigrated:\n', '    oldVersion: indexed(address) # Old version of the strategy to be migrated\n', '    newVersion: indexed(address) # New version of the strategy\n', '\n', '\n', 'event StrategyRevoked:\n', '    strategy: indexed(address) # Address of the strategy that is revoked\n', '\n', '\n', 'event StrategyRemovedFromQueue:\n', '    strategy: indexed(address) # Address of the strategy that is removed from the withdrawal queue\n', '\n', '\n', 'event StrategyAddedToQueue:\n', '    strategy: indexed(address) # Address of the strategy that is added to the withdrawal queue\n', '\n', '\n', '# NOTE: Track the total for overhead targeting purposes\n', 'strategies: public(HashMap[address, StrategyParams])\n', 'MAXIMUM_STRATEGIES: constant(uint256) = 20\n', 'DEGRADATION_COEFFICIENT: constant(uint256) = 10 ** 18\n', '\n', '# Ordering that `withdraw` uses to determine which strategies to pull funds from\n', '# NOTE: Does *NOT* have to match the ordering of all the current strategies that\n', '#       exist, but it is recommended that it does or else withdrawal depth is\n', '#       limited to only those inside the queue.\n', '# NOTE: Ordering is determined by governance, and should be balanced according\n', '#       to risk, slippage, and/or volatility. Can also be ordered to increase the\n', '#       withdrawal speed of a particular Strategy.\n', '# NOTE: The first time a ZERO_ADDRESS is encountered, it stops withdrawing\n', 'withdrawalQueue: public(address[MAXIMUM_STRATEGIES])\n', '\n', 'emergencyShutdown: public(bool)\n', '\n', 'depositLimit: public(uint256)  # Limit for totalAssets the Vault can hold\n', 'debtRatio: public(uint256)  # Debt ratio for the Vault across all strategies (in BPS, <= 10k)\n', 'totalDebt: public(uint256)  # Amount of tokens that all strategies have borrowed\n', 'lastReport: public(uint256)  # block.timestamp of last report\n', 'activation: public(uint256)  # block.timestamp of contract deployment\n', 'lockedProfit: public(uint256) # how much profit is locked and cant be withdrawn\n', 'lockedProfitDegradation: public(uint256) # rate per block of degradation. DEGRADATION_COEFFICIENT is 100% per block\n', 'rewards: public(address)  # Rewards contract where Governance fees are sent to\n', '# Governance Fee for management of Vault (given to `rewards`)\n', 'managementFee: public(uint256)\n', '# Governance Fee for performance of Vault (given to `rewards`)\n', 'performanceFee: public(uint256)\n', 'MAX_BPS: constant(uint256) = 10_000  # 100%, or 10k basis points\n', '# NOTE: A four-century period will be missing 3 of its 100 Julian leap years, leaving 97.\n', '#       So the average year has 365 + 97/400 = 365.2425 days\n', '#       ERROR(Julian): -0.0078\n', '#       ERROR(Gregorian): -0.0003\n', 'SECS_PER_YEAR: constant(uint256) = 31_556_952  # 365.2425 days\n', '# `nonces` track `permit` approvals with signature.\n', 'nonces: public(HashMap[address, uint256])\n', 'DOMAIN_SEPARATOR: public(bytes32)\n', "DOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n", 'PERMIT_TYPE_HASH: constant(bytes32) = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n', '\n', '\n', '@external\n', 'def initialize(\n', '    token: address,\n', '    governance: address,\n', '    rewards: address,\n', '    nameOverride: String[64],\n', '    symbolOverride: String[32],\n', '    guardian: address = msg.sender,\n', '    management: address =  msg.sender,\n', '):\n', '    """\n', '    @notice\n', '        Initializes the Vault, this is called only once, when the contract is\n', '        deployed.\n', '        The performance fee is set to 10% of yield, per Strategy.\n', '        The management fee is set to 2%, per year.\n', '        The initial deposit limit is set to 0 (deposits disabled); it must be\n', '        updated after initialization.\n', '    @dev\n', "        If `nameOverride` is not specified, the name will be 'yearn'\n", '        combined with the name of `token`.\n', '\n', "        If `symbolOverride` is not specified, the symbol will be 'yv'\n", '        combined with the symbol of `token`.\n', '\n', '        The token used by the vault should not change balances outside transfers and \n', '        it must transfer the exact amount requested. Fee on transfer and rebasing are not supported.\n', '    @param token The token that may be deposited into this Vault.\n', '    @param governance The address authorized for governance interactions.\n', '    @param rewards The address to distribute rewards to.\n', '    @param management The address of the vault manager.\n', '    @param nameOverride Specify a custom Vault name. Leave empty for default choice.\n', '    @param symbolOverride Specify a custom Vault symbol name. Leave empty for default choice.\n', '    @param guardian The address authorized for guardian interactions. Defaults to caller.\n', '    """\n', '    assert self.activation == 0  # dev: no devops199\n', '    self.token = ERC20(token)\n', '    if nameOverride == "":\n', '        self.name = concat(DetailedERC20(token).symbol(), " yVault")\n', '    else:\n', '        self.name = nameOverride\n', '    if symbolOverride == "":\n', '        self.symbol = concat("yv", DetailedERC20(token).symbol())\n', '    else:\n', '        self.symbol = symbolOverride\n', '    decimals: uint256 = DetailedERC20(token).decimals()\n', '    self.decimals = decimals\n', '    assert decimals < 256 # dev: see VVE-2020-0001\n', '\n', '    self.governance = governance\n', '    log UpdateGovernance(governance)\n', '    self.management = management\n', '    log UpdateManagement(management)\n', '    self.rewards = rewards\n', '    log UpdateRewards(rewards)\n', '    self.guardian = guardian\n', '    log UpdateGuardian(guardian)\n', '    self.performanceFee = 1000  # 10% of yield (per Strategy)\n', '    log UpdatePerformanceFee(convert(1000, uint256))\n', '    self.managementFee = 200  # 2% per year\n', '    log UpdateManagementFee(convert(200, uint256))\n', '    self.lastReport = block.timestamp\n', '    self.activation = block.timestamp\n', '    self.lockedProfitDegradation = convert(DEGRADATION_COEFFICIENT * 46 / 10 ** 6 , uint256) # 6 hours in blocks\n', '    # EIP-712\n', '    self.DOMAIN_SEPARATOR = keccak256(\n', '        concat(\n', '            DOMAIN_TYPE_HASH,\n', '            keccak256(convert("Yearn Vault", Bytes[11])),\n', '            keccak256(convert(API_VERSION, Bytes[28])),\n', '            convert(chain.id, bytes32),\n', '            convert(self, bytes32)\n', '        )\n', '    )\n', '\n', '\n', '@pure\n', '@external\n', 'def apiVersion() -> String[28]:\n', '    """\n', '    @notice\n', '        Used to track the deployed version of this contract. In practice you\n', "        can use this version number to compare with Yearn's GitHub and\n", '        determine which version of the source matches this deployed contract.\n', '    @dev\n', "        All strategies must have an `apiVersion()` that matches the Vault's\n", '        `API_VERSION`.\n', '    @return API_VERSION which holds the current version of this contract.\n', '    """\n', '    return API_VERSION\n', '\n', '\n', '@external\n', 'def setName(name: String[42]):\n', '    """\n', '    @notice\n', '        Used to change the value of `name`.\n', '\n', '        This may only be called by governance.\n', '    @param name The new name to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.name = name\n', '\n', '\n', '@external\n', 'def setSymbol(symbol: String[20]):\n', '    """\n', '    @notice\n', '        Used to change the value of `symbol`.\n', '\n', '        This may only be called by governance.\n', '    @param symbol The new symbol to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.symbol = symbol\n', '\n', '\n', '# 2-phase commit for a change in governance\n', '@external\n', 'def setGovernance(governance: address):\n', '    """\n', '    @notice\n', '        Nominate a new address to use as governance.\n', '\n', '        The change does not go into effect immediately. This function sets a\n', '        pending change, and the governance address is not updated until\n', '        the proposed governance address has accepted the responsibility.\n', '\n', '        This may only be called by the current governance address.\n', '    @param governance The address requested to take over Vault governance.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.pendingGovernance = governance\n', '\n', '\n', '@external\n', 'def acceptGovernance():\n', '    """\n', '    @notice\n', '        Once a new governance address has been proposed using setGovernance(),\n', '        this function may be called by the proposed address to accept the\n', '        responsibility of taking over governance for this contract.\n', '\n', '        This may only be called by the proposed governance address.\n', '    @dev\n', '        setGovernance() should be called by the existing governance address,\n', '        prior to calling this function.\n', '    """\n', '    assert msg.sender == self.pendingGovernance\n', '    self.governance = msg.sender\n', '    log UpdateGovernance(msg.sender)\n', '\n', '\n', '@external\n', 'def setManagement(management: address):\n', '    """\n', '    @notice\n', '        Changes the management address.\n', '        Management is able to make some investment decisions adjusting parameters.\n', '\n', '        This may only be called by governance.\n', '    @param management The address to use for managing.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.management = management\n', '    log UpdateManagement(management)\n', '\n', '\n', '@external\n', 'def setRewards(rewards: address):\n', '    """\n', '    @notice\n', '        Changes the rewards address. Any distributed rewards\n', '        will cease flowing to the old address and begin flowing\n', '        to this address once the change is in effect.\n', '\n', '        This will not change any Strategy reports in progress, only\n', '        new reports made after this change goes into effect.\n', '\n', '        This may only be called by governance.\n', '    @param rewards The address to use for collecting rewards.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert not (rewards in [self, ZERO_ADDRESS])\n', '    self.rewards = rewards\n', '    log UpdateRewards(rewards)\n', '\n', '\n', '@external\n', 'def setLockedProfitDegradation(degradation: uint256):\n', '    """\n', '    @notice\n', '        Changes the locked profit degradation.\n', '    @param degradation The rate of degradation in percent per second scaled to 1e18.\n', '    """\n', '    assert msg.sender == self.governance\n', '    # Since "degradation" is of type uint256 it can never be less than zero\n', '    assert degradation <= DEGRADATION_COEFFICIENT\n', '    self.lockedProfitDegradation = degradation\n', '\n', '\n', '@external\n', 'def setDepositLimit(limit: uint256):\n', '    """\n', '    @notice\n', '        Changes the maximum amount of tokens that can be deposited in this Vault.\n', '\n', '        Note, this is not how much may be deposited by a single depositor,\n', '        but the maximum amount that may be deposited across all depositors.\n', '\n', '        This may only be called by governance.\n', '    @param limit The new deposit limit to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    self.depositLimit = limit\n', '    log UpdateDepositLimit(limit)\n', '\n', '\n', '@external\n', 'def setPerformanceFee(fee: uint256):\n', '    """\n', '    @notice\n', '        Used to change the value of `performanceFee`.\n', '\n', '        Should set this value below the maximum strategist performance fee.\n', '\n', '        This may only be called by governance.\n', '    @param fee The new performance fee to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert fee <= MAX_BPS / 2\n', '    self.performanceFee = fee\n', '    log UpdatePerformanceFee(fee)\n', '\n', '\n', '@external\n', 'def setManagementFee(fee: uint256):\n', '    """\n', '    @notice\n', '        Used to change the value of `managementFee`.\n', '\n', '        This may only be called by governance.\n', '    @param fee The new management fee to use.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert fee <= MAX_BPS\n', '    self.managementFee = fee\n', '    log UpdateManagementFee(fee)\n', '\n', '\n', '@external\n', 'def setGuardian(guardian: address):\n', '    """\n', '    @notice\n', '        Used to change the address of `guardian`.\n', '\n', '        This may only be called by governance or the existing guardian.\n', '    @param guardian The new guardian address to use.\n', '    """\n', '    assert msg.sender in [self.guardian, self.governance]\n', '    self.guardian = guardian\n', '    log UpdateGuardian(guardian)\n', '\n', '\n', '@external\n', 'def setEmergencyShutdown(active: bool):\n', '    """\n', '    @notice\n', '        Activates or deactivates Vault mode where all Strategies go into full\n', '        withdrawal.\n', '\n', '        During Emergency Shutdown:\n', '        1. No Users may deposit into the Vault (but may withdraw as usual.)\n', '        2. Governance may not add new Strategies.\n', '        3. Each Strategy must pay back their debt as quickly as reasonable to\n', '            minimally affect their position.\n', '        4. Only Governance may undo Emergency Shutdown.\n', '\n', '        See contract level note for further details.\n', '\n', '        This may only be called by governance or the guardian.\n', '    @param active\n', '        If true, the Vault goes into Emergency Shutdown. If false, the Vault\n', '        goes back into Normal Operation.\n', '    """\n', '    if active:\n', '        assert msg.sender in [self.guardian, self.governance]\n', '    else:\n', '        assert msg.sender == self.governance\n', '    self.emergencyShutdown = active\n', '    log EmergencyShutdown(active)\n', '\n', '\n', '@external\n', 'def setWithdrawalQueue(queue: address[MAXIMUM_STRATEGIES]):\n', '    """\n', '    @notice\n', '        Updates the withdrawalQueue to match the addresses and order specified\n', '        by `queue`.\n', '\n', '        There can be fewer strategies than the maximum, as well as fewer than\n', '        the total number of strategies active in the vault. `withdrawalQueue`\n', '        will be updated in a gas-efficient manner, assuming the input is well-\n', '        ordered with 0x0 only at the end.\n', '\n', '        This may only be called by governance or management.\n', '    @dev\n', '        This is order sensitive, specify the addresses in the order in which\n', '        funds should be withdrawn (so `queue`[0] is the first Strategy withdrawn\n', '        from, `queue`[1] is the second, etc.)\n', '\n', '        This means that the least impactful Strategy (the Strategy that will have\n', '        its core positions impacted the least by having funds removed) should be\n', '        at `queue`[0], then the next least impactful at `queue`[1], and so on.\n', '    @param queue\n', '        The array of addresses to use as the new withdrawal queue. This is\n', '        order sensitive.\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '\n', '    # HACK: Temporary until Vyper adds support for Dynamic arrays\n', '    old_queue: address[MAXIMUM_STRATEGIES] = empty(address[MAXIMUM_STRATEGIES])\n', '    for i in range(MAXIMUM_STRATEGIES):\n', '        old_queue[i] = self.withdrawalQueue[i] \n', '        if queue[i] == ZERO_ADDRESS:\n', '            # NOTE: Cannot use this method to remove entries from the queue\n', '            assert old_queue[i] == ZERO_ADDRESS\n', '            break\n', '        # NOTE: Cannot use this method to add more entries to the queue\n', '        assert old_queue[i] != ZERO_ADDRESS\n', '\n', '        assert self.strategies[queue[i]].activation > 0\n', '\n', '        existsInOldQueue: bool = False\n', '        for j in range(MAXIMUM_STRATEGIES):\n', '            if queue[j] == ZERO_ADDRESS:\n', '                existsInOldQueue = True\n', '                break\n', '            if queue[i] == old_queue[j]:\n', '                # NOTE: Ensure that every entry in queue prior to reordering exists now\n', '                existsInOldQueue = True\n', '\n', '            if j <= i:\n', '                # NOTE: This will only check for duplicate entries in queue after `i`\n', '                continue\n', '            assert queue[i] != queue[j]  # dev: do not add duplicate strategies\n', '\n', '        assert existsInOldQueue # dev: do not add new strategies\n', '\n', '        self.withdrawalQueue[i] = queue[i]\n', '    log UpdateWithdrawalQueue(queue)\n', '\n', '\n', '@internal\n', 'def erc20_safe_transfer(token: address, receiver: address, amount: uint256):\n', '    # Used only to send tokens that are not the type managed by this Vault.\n', '    # HACK: Used to handle non-compliant tokens like USDT\n', '    response: Bytes[32] = raw_call(\n', '        token,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(receiver, bytes32),\n', '            convert(amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(response) > 0:\n', '        assert convert(response, bool), "Transfer failed!"\n', '\n', '\n', '@internal\n', 'def erc20_safe_transferFrom(token: address, sender: address, receiver: address, amount: uint256):\n', '    # Used only to send tokens that are not the type managed by this Vault.\n', '    # HACK: Used to handle non-compliant tokens like USDT\n', '    response: Bytes[32] = raw_call(\n', '        token,\n', '        concat(\n', '            method_id("transferFrom(address,address,uint256)"),\n', '            convert(sender, bytes32),\n', '            convert(receiver, bytes32),\n', '            convert(amount, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(response) > 0:\n', '        assert convert(response, bool), "Transfer failed!"\n', '\n', '\n', '@internal\n', 'def _transfer(sender: address, receiver: address, amount: uint256):\n', '    # See note on `transfer()`.\n', '\n', '    # Protect people from accidentally sending their shares to bad places\n', '    assert receiver not in [self, ZERO_ADDRESS]\n', '    self.balanceOf[sender] -= amount\n', '    self.balanceOf[receiver] += amount\n', '    log Transfer(sender, receiver, amount)\n', '\n', '\n', '@external\n', 'def transfer(receiver: address, amount: uint256) -> bool:\n', '    """\n', '    @notice\n', "        Transfers shares from the caller's address to `receiver`. This function\n", '        will always return true, unless the user is attempting to transfer\n', "        shares to this contract's address, or to 0x0.\n", '    @param receiver\n', "        The address shares are being transferred to. Must not be this contract's\n", '        address, must not be 0x0.\n', '    @param amount The quantity of shares to transfer.\n', '    @return\n', "        True if transfer is sent to an address other than this contract's or\n", '        0x0, otherwise the transaction will fail.\n', '    """\n', '    self._transfer(msg.sender, receiver, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\n', '    """\n', '    @notice\n', '        Transfers `amount` shares from `sender` to `receiver`. This operation will\n', '        always return true, unless the user is attempting to transfer shares\n', "        to this contract's address, or to 0x0.\n", '\n', '        Unless the caller has given this contract unlimited approval,\n', "        transfering shares will decrement the caller's `allowance` by `amount`.\n", '    @param sender The address shares are being transferred from.\n', '    @param receiver\n', "        The address shares are being transferred to. Must not be this contract's\n", '        address, must not be 0x0.\n', '    @param amount The quantity of shares to transfer.\n', '    @return\n', "        True if transfer is sent to an address other than this contract's or\n", '        0x0, otherwise the transaction will fail.\n', '    """\n', '    # Unlimited approval (saves an SSTORE)\n', '    if (self.allowance[sender][msg.sender] < MAX_UINT256):\n', '        allowance: uint256 = self.allowance[sender][msg.sender] - amount\n', '        self.allowance[sender][msg.sender] = allowance\n', '        # NOTE: Allows log filters to have a full accounting of allowance changes\n', '        log Approval(sender, msg.sender, allowance)\n', '    self._transfer(sender, receiver, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(spender: address, amount: uint256) -> bool:\n', '    """\n', '    @dev Approve the passed address to spend the specified amount of tokens on behalf of\n', '         `msg.sender`. Beware that changing an allowance with this method brings the risk\n', '         that someone may use both the old and the new allowance by unfortunate transaction\n', '         ordering. See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param spender The address which will spend the funds.\n', '    @param amount The amount of tokens to be spent.\n', '    """\n', '    self.allowance[msg.sender][spender] = amount\n', '    log Approval(msg.sender, spender, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def increaseAllowance(spender: address, amount: uint256) -> bool:\n', '    """\n', '    @dev Increase the allowance of the passed address to spend the total amount of tokens\n', '         on behalf of msg.sender. This method mitigates the risk that someone may use both\n', '         the old and the new allowance by unfortunate transaction ordering.\n', '         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param spender The address which will spend the funds.\n', '    @param amount The amount of tokens to increase the allowance by.\n', '    """\n', '    self.allowance[msg.sender][spender] += amount\n', '    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n', '    return True\n', '\n', '\n', '@external\n', 'def decreaseAllowance(spender: address, amount: uint256) -> bool:\n', '    """\n', '    @dev Decrease the allowance of the passed address to spend the total amount of tokens\n', '         on behalf of msg.sender. This method mitigates the risk that someone may use both\n', '         the old and the new allowance by unfortunate transaction ordering.\n', '         See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param spender The address which will spend the funds.\n', '    @param amount The amount of tokens to decrease the allowance by.\n', '    """\n', '    self.allowance[msg.sender][spender] -= amount\n', '    log Approval(msg.sender, spender, self.allowance[msg.sender][spender])\n', '    return True\n', '\n', '\n', '@external\n', 'def permit(owner: address, spender: address, amount: uint256, expiry: uint256, signature: Bytes[65]) -> bool:\n', '    """\n', '    @notice\n', "        Approves spender by owner's signature to expend owner's tokens.\n", '        See https://eips.ethereum.org/EIPS/eip-2612.\n', '\n', '    @param owner The address which is a source of funds and has signed the Permit.\n', '    @param spender The address which is allowed to spend the funds.\n', '    @param amount The amount of tokens to be spent.\n', '    @param expiry The timestamp after which the Permit is no longer valid.\n', '    @param signature A valid secp256k1 signature of Permit by owner encoded as r, s, v.\n', '    @return True, if transaction completes successfully\n', '    """\n', '    assert owner != ZERO_ADDRESS  # dev: invalid owner\n', '    assert expiry == 0 or expiry >= block.timestamp  # dev: permit expired\n', '    nonce: uint256 = self.nonces[owner]\n', '    digest: bytes32 = keccak256(\n', '        concat(\n', "            b'\\x19\\x01',\n", '            self.DOMAIN_SEPARATOR,\n', '            keccak256(\n', '                concat(\n', '                    PERMIT_TYPE_HASH,\n', '                    convert(owner, bytes32),\n', '                    convert(spender, bytes32),\n', '                    convert(amount, bytes32),\n', '                    convert(nonce, bytes32),\n', '                    convert(expiry, bytes32),\n', '                )\n', '            )\n', '        )\n', '    )\n', '    # NOTE: signature is packed as r, s, v\n', '    r: uint256 = convert(slice(signature, 0, 32), uint256)\n', '    s: uint256 = convert(slice(signature, 32, 32), uint256)\n', '    v: uint256 = convert(slice(signature, 64, 1), uint256)\n', '    assert ecrecover(digest, v, r, s) == owner  # dev: invalid signature\n', '    self.allowance[owner][spender] = amount\n', '    self.nonces[owner] = nonce + 1\n', '    log Approval(owner, spender, amount)\n', '    return True\n', '\n', '\n', '@view\n', '@internal\n', 'def _totalAssets() -> uint256:\n', '    # See note on `totalAssets()`.\n', '    return self.token.balanceOf(self) + self.totalDebt\n', '\n', '\n', '@view\n', '@external\n', 'def totalAssets() -> uint256:\n', '    """\n', '    @notice\n', '        Returns the total quantity of all assets under control of this\n', "        Vault, whether they're loaned out to a Strategy, or currently held in\n", '        the Vault.\n', '    @return The total assets under control of this Vault.\n', '    """\n', '    return self._totalAssets()\n', '\n', '\n', '@view\n', '@internal\n', 'def _calculateLockedProfit() -> uint256:\n', '    lockedFundsRatio: uint256 = (block.timestamp - self.lastReport) * self.lockedProfitDegradation\n', '\n', '    if(lockedFundsRatio < DEGRADATION_COEFFICIENT):\n', '        lockedProfit: uint256 = self.lockedProfit\n', '        return lockedProfit - (\n', '                lockedFundsRatio\n', '                * lockedProfit\n', '                / DEGRADATION_COEFFICIENT\n', '            )\n', '    else:        \n', '        return 0\n', '\n', '@internal\n', 'def _issueSharesForAmount(to: address, amount: uint256) -> uint256:\n', '    # Issues `amount` Vault shares to `to`.\n', '    # Shares must be issued prior to taking on new collateral, or\n', '    # calculation will be wrong. This means that only *trusted* tokens\n', '    # (with no capability for exploitative behavior) can be used.\n', '    shares: uint256 = 0\n', '    # HACK: Saves 2 SLOADs (~200 gas, post-Berlin)\n', '    totalSupply: uint256 = self.totalSupply\n', '    if totalSupply > 0:\n', '        # Mint amount of shares based on what the Vault is managing overall\n', '        # NOTE: if sqrt(token.totalSupply()) > 1e39, this could potentially revert\n', '        freeFunds: uint256 = self._totalAssets() - self._calculateLockedProfit()\n', '        shares =  amount * totalSupply / freeFunds  # dev: no free funds\n', '    else:\n', '        # No existing shares, so mint 1:1\n', '        shares = amount\n', '    assert shares != 0 # dev: division rounding resulted in zero\n', '\n', '    # Mint new shares\n', '    self.totalSupply = totalSupply + shares\n', '    self.balanceOf[to] += shares\n', '    log Transfer(ZERO_ADDRESS, to, shares)\n', '\n', '    return shares\n', '\n', '\n', '@external\n', '@nonreentrant("withdraw")\n', 'def deposit(_amount: uint256 = MAX_UINT256, recipient: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Deposits `_amount` `token`, issuing shares to `recipient`. If the\n', '        Vault is in Emergency Shutdown, deposits will not be accepted and this\n', '        call will fail.\n', '    @dev\n', '        Measuring quantity of shares to issues is based on the total\n', '        outstanding debt that this contract has ("expected value") instead\n', '        of the total balance sheet it has ("estimated value") has important\n', '        security considerations, and is done intentionally. If this value were\n', '        measured against external systems, it could be purposely manipulated by\n', '        an attacker to withdraw more assets than they otherwise should be able\n', '        to claim by redeeming their shares.\n', '\n', '        On deposit, this means that shares are issued against the total amount\n', '        that the deposited capital can be given in service of the debt that\n', '        Strategies assume. If that number were to be lower than the "expected\n', '        value" at some future point, depositing shares via this method could\n', '        entitle the depositor to *less* than the deposited value once the\n', '        "realized value" is updated from further reports by the Strategies\n', '        to the Vaults.\n', '\n', '        Care should be taken by integrators to account for this discrepancy,\n', '        by using the view-only methods of this contract (both off-chain and\n', '        on-chain) to determine if depositing into the Vault is a "good idea".\n', '    @param _amount The quantity of tokens to deposit, defaults to all.\n', '    @param recipient\n', '        The address to issue the shares in this Vault to. Defaults to the\n', "        caller's address.\n", '    @return The issued Vault shares.\n', '    """\n', '    assert not self.emergencyShutdown  # Deposits are locked out\n', '    assert recipient not in [self, ZERO_ADDRESS]\n', '\n', '    amount: uint256 = _amount\n', '\n', '    # If _amount not specified, transfer the full token balance,\n', '    # up to deposit limit\n', '    if amount == MAX_UINT256:\n', '        amount = min(\n', '            self.depositLimit - self._totalAssets(),\n', '            self.token.balanceOf(msg.sender),\n', '        )\n', '    else:\n', '        # Ensure deposit limit is respected\n', '        assert self._totalAssets() + amount <= self.depositLimit\n', '\n', '    # Ensure we are depositing something\n', '    assert amount > 0\n', '\n', '    # Issue new shares (needs to be done before taking deposit to be accurate)\n', '    # Shares are issued to recipient (may be different from msg.sender)\n', '    # See @dev note, above.\n', '    shares: uint256 = self._issueSharesForAmount(recipient, amount)\n', '\n', '    # Tokens are transferred from msg.sender (may be different from _recipient)\n', '    self.erc20_safe_transferFrom(self.token.address, msg.sender, self, amount)\n', '\n', '    return shares  # Just in case someone wants them\n', '\n', '\n', '@view\n', '@internal\n', 'def _shareValue(shares: uint256) -> uint256:\n', '    # Returns price = 1:1 if vault is empty\n', '    if self.totalSupply == 0:\n', '        return shares\n', '\n', '    # Determines the current value of `shares`.\n', '    # NOTE: if sqrt(Vault.totalAssets()) >>> 1e39, this could potentially revert\n', '    freeFunds: uint256 = self._totalAssets() - self._calculateLockedProfit()\n', '\n', '    return (\n', '        shares\n', '        * freeFunds\n', '        / self.totalSupply\n', '    )\n', '\n', '\n', '@view\n', '@internal\n', 'def _sharesForAmount(amount: uint256) -> uint256:\n', '    # Determines how many shares `amount` of token would receive.\n', '    # See dev note on `deposit`.\n', '    if self._totalAssets() > 0:\n', '        # NOTE: if sqrt(token.totalSupply()) > 1e37, this could potentially revert\n', '        return  (\n', '            amount\n', '            * self.totalSupply\n', '            / self._totalAssets()\n', '        )\n', '    else:\n', '        return 0\n', '\n', '\n', '@view\n', '@external\n', 'def maxAvailableShares() -> uint256:\n', '    """\n', '    @notice\n', '        Determines the maximum quantity of shares this Vault can facilitate a\n', '        withdrawal for, factoring in assets currently residing in the Vault,\n', "        as well as those deployed to strategies on the Vault's balance sheet.\n", '    @dev\n', '        Regarding how shares are calculated, see dev note on `deposit`.\n', '\n', '        If you want to calculated the maximum a user could withdraw up to,\n', '        you want to use this function.\n', '\n', '        Note that the amount provided by this function is the theoretical\n', '        maximum possible from withdrawing, the real amount depends on the\n', '        realized losses incurred during withdrawal.\n', '    @return The total quantity of shares this Vault can provide.\n', '    """\n', '    shares: uint256 = self._sharesForAmount(self.token.balanceOf(self))\n', '\n', '    for strategy in self.withdrawalQueue:\n', '        if strategy == ZERO_ADDRESS:\n', '            break\n', '        shares += self._sharesForAmount(self.strategies[strategy].totalDebt)\n', '\n', '    return shares\n', '\n', '\n', '@internal\n', 'def _reportLoss(strategy: address, loss: uint256):\n', '    # Loss can only be up the amount of debt issued to strategy\n', '    totalDebt: uint256 = self.strategies[strategy].totalDebt\n', '    assert totalDebt >= loss\n', '\n', '    # Also, make sure we reduce our trust with the strategy by the amount of loss\n', '    if self.debtRatio != 0: # if vault with single strategy that is set to EmergencyOne\n', '        # NOTE: The context to this calculation is different than the calculation in `_reportLoss`,\n', '        # this calculation intentionally approximates via `totalDebt` to avoid manipulatable results\n', '        ratio_change: uint256 = min(\n', "            # NOTE: This calculation isn't 100% precise, the adjustment is ~10%-20% more severe due to EVM math\n", '            loss * self.debtRatio / self.totalDebt,\n', '            self.strategies[strategy].debtRatio,\n', '        )\n', '        self.strategies[strategy].debtRatio -= ratio_change\n', '        self.debtRatio -= ratio_change\n', "    # Finally, adjust our strategy's parameters by the loss\n", '    self.strategies[strategy].totalLoss += loss\n', '    self.strategies[strategy].totalDebt = totalDebt - loss\n', '    self.totalDebt -= loss\n', '\n', '\n', '@external\n', '@nonreentrant("withdraw")\n', 'def withdraw(\n', '    maxShares: uint256 = MAX_UINT256,\n', '    recipient: address = msg.sender,\n', '    maxLoss: uint256 = 1,  # 0.01% [BPS]\n', ') -> uint256:\n', '    """\n', '    @notice\n', "        Withdraws the calling account's tokens from this Vault, redeeming\n", '        amount `_shares` for an appropriate amount of tokens.\n', '\n', '        See note on `setWithdrawalQueue` for further details of withdrawal\n', '        ordering and behavior.\n', '    @dev\n', '        Measuring the value of shares is based on the total outstanding debt\n', '        that this contract has ("expected value") instead of the total balance\n', '        sheet it has ("estimated value") has important security considerations,\n', '        and is done intentionally. If this value were measured against external\n', '        systems, it could be purposely manipulated by an attacker to withdraw\n', '        more assets than they otherwise should be able to claim by redeeming\n', '        their shares.\n', '\n', '        On withdrawal, this means that shares are redeemed against the total\n', '        amount that the deposited capital had "realized" since the point it\n', '        was deposited, up until the point it was withdrawn. If that number\n', '        were to be higher than the "expected value" at some future point,\n', '        withdrawing shares via this method could entitle the depositor to\n', '        *more* than the expected value once the "realized value" is updated\n', '        from further reports by the Strategies to the Vaults.\n', '\n', '        Under exceptional scenarios, this could cause earlier withdrawals to\n', '        earn "more" of the underlying assets than Users might otherwise be\n', "        entitled to, if the Vault's estimated value were otherwise measured\n", '        through external means, accounting for whatever exceptional scenarios\n', "        exist for the Vault (that aren't covered by the Vault's own design.)\n", '\n', '        In the situation where a large withdrawal happens, it can empty the \n', '        vault balance and the strategies in the withdrawal queue. \n', '        Strategies not in the withdrawal queue will have to be harvested to \n', '        rebalance the funds and make the funds available again to withdraw.\n', '    @param maxShares\n', '        How many shares to try and redeem for tokens, defaults to all.\n', '    @param recipient\n', '        The address to issue the shares in this Vault to. Defaults to the\n', "        caller's address.\n", '    @param maxLoss\n', '        The maximum acceptable loss to sustain on withdrawal. Defaults to 0.01%.\n', '    @return The quantity of tokens redeemed for `_shares`.\n', '    """\n', '    shares: uint256 = maxShares  # May reduce this number below\n', '\n', '    # Max Loss is <=100%, revert otherwise\n', '    assert maxLoss <= MAX_BPS\n', '\n', '    # If _shares not specified, transfer full share balance\n', '    if shares == MAX_UINT256:\n', '        shares = self.balanceOf[msg.sender]\n', '\n', '    # Limit to only the shares they own\n', '    assert shares <= self.balanceOf[msg.sender]\n', '\n', '    # Ensure we are withdrawing something\n', '    assert shares > 0\n', '\n', '    # See @dev note, above.\n', '    value: uint256 = self._shareValue(shares)\n', '\n', '    totalLoss: uint256 = 0\n', '    if value > self.token.balanceOf(self):\n', '        # We need to go get some from our strategies in the withdrawal queue\n', '        # NOTE: This performs forced withdrawals from each Strategy. During\n', '        #       forced withdrawal, a Strategy may realize a loss. That loss\n', '        #       is reported back to the Vault, and the will affect the amount\n', '        #       of tokens that the withdrawer receives for their shares. They\n', '        #       can optionally specify the maximum acceptable loss (in BPS)\n', '        #       to prevent excessive losses on their withdrawals (which may\n', '        #       happen in certain edge cases where Strategies realize a loss)\n', '        for strategy in self.withdrawalQueue:\n', '            if strategy == ZERO_ADDRESS:\n', "                break  # We've exhausted the queue\n", '\n', '            vault_balance: uint256 = self.token.balanceOf(self)\n', '            if value <= vault_balance:\n', "                break  # We're done withdrawing\n", '\n', '            amountNeeded: uint256 = value - vault_balance\n', '\n', "            # NOTE: Don't withdraw more than the debt so that Strategy can still\n", '            #       continue to work based on the profits it has\n', '            # NOTE: This means that user will lose out on any profits that each\n', '            #       Strategy in the queue would return on next harvest, benefiting others\n', '            amountNeeded = min(amountNeeded, self.strategies[strategy].totalDebt)\n', '            if amountNeeded == 0:\n', '                continue  # Nothing to withdraw from this Strategy, try the next one\n', '\n', '            # Force withdraw amount from each Strategy in the order set by governance\n', '            loss: uint256 = Strategy(strategy).withdraw(amountNeeded)\n', '            withdrawn: uint256 = self.token.balanceOf(self) - vault_balance\n', '\n', '            # NOTE: Withdrawer incurs any losses from liquidation\n', '            if loss > 0:\n', '                value -= loss\n', '                totalLoss += loss\n', '                self._reportLoss(strategy, loss)\n', '\n', '            # Reduce the Strategy\'s debt by the amount withdrawn ("realized returns")\n', '            # NOTE: This doesn\'t add to returns as it\'s not earned by "normal means"\n', '            self.strategies[strategy].totalDebt -= withdrawn\n', '            self.totalDebt -= withdrawn\n', '\n', '        # NOTE: We have withdrawn everything possible out of the withdrawal queue\n', "        #       but we still don't have enough to fully pay them back, so adjust\n", "        #       to the total amount we've freed up through forced withdrawals\n", '        vault_balance: uint256 = self.token.balanceOf(self)\n', '        if value > vault_balance:\n', '            value = vault_balance\n', '            # NOTE: Burn # of shares that corresponds to what Vault has on-hand,\n', '            #       including the losses that were incurred above during withdrawals\n', '            shares = self._sharesForAmount(value + totalLoss)\n', '\n', '    # NOTE: This loss protection is put in place to revert if losses from\n', '    #       withdrawing are more than what is considered acceptable.\n', '    assert totalLoss <= maxLoss * (value + totalLoss) / MAX_BPS \n', '\n', '    # Burn shares (full value of what is being withdrawn)\n', '    self.totalSupply -= shares\n', '    self.balanceOf[msg.sender] -= shares\n', '    log Transfer(msg.sender, ZERO_ADDRESS, shares)\n', '\n', '    # Withdraw remaining balance to _recipient (may be different to msg.sender) (minus fee)\n', '    self.erc20_safe_transfer(self.token.address, recipient, value)\n', '\n', '    return value\n', '\n', '\n', '@view\n', '@external\n', 'def pricePerShare() -> uint256:\n', '    """\n', '    @notice Gives the price for a single Vault share.\n', '    @dev See dev note on `withdraw`.\n', '    @return The value of a single share.\n', '    """\n', '    return self._shareValue(10 ** self.decimals)\n', '\n', '\n', '@internal\n', 'def _organizeWithdrawalQueue():\n', '    # Reorganize `withdrawalQueue` based on premise that if there is an\n', '    # empty value between two actual values, then the empty value should be\n', '    # replaced by the later value.\n', '    # NOTE: Relative ordering of non-zero values is maintained.\n', '    offset: uint256 = 0\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        strategy: address = self.withdrawalQueue[idx]\n', '        if strategy == ZERO_ADDRESS:\n', '            offset += 1  # how many values we need to shift, always `<= idx`\n', '        elif offset > 0:\n', '            self.withdrawalQueue[idx - offset] = strategy\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '\n', '\n', '@external\n', 'def addStrategy(\n', '    strategy: address,\n', '    debtRatio: uint256,\n', '    minDebtPerHarvest: uint256,\n', '    maxDebtPerHarvest: uint256,\n', '    performanceFee: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Add a Strategy to the Vault.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        The Strategy will be appended to `withdrawalQueue`, call\n', '        `setWithdrawalQueue` to change the order.\n', '    @param strategy The address of the Strategy to add.\n', '    @param debtRatio\n', '        The share of the total assets in the `vault that the `strategy` has access to.\n', '    @param minDebtPerHarvest\n', '        Lower limit on the increase of debt since last harvest\n', '    @param maxDebtPerHarvest\n', '        Upper limit on the increase of debt since last harvest\n', '    @param performanceFee\n', "        The fee the strategist will receive based on this Vault's performance.\n", '    """\n', '    # Check if queue is full\n', '    assert self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] == ZERO_ADDRESS\n', '\n', '    # Check calling conditions\n', '    assert not self.emergencyShutdown\n', '    assert msg.sender == self.governance\n', '\n', '    # Check strategy configuration\n', '    assert strategy != ZERO_ADDRESS\n', '    assert self.strategies[strategy].activation == 0\n', '    assert self == Strategy(strategy).vault()\n', '    assert self.token.address == Strategy(strategy).want()\n', '\n', '    # Check strategy parameters\n', '    assert self.debtRatio + debtRatio <= MAX_BPS\n', '    assert minDebtPerHarvest <= maxDebtPerHarvest\n', '    assert performanceFee <= MAX_BPS / 2 \n', '\n', '    # Add strategy to approved strategies\n', '    self.strategies[strategy] = StrategyParams({\n', '        performanceFee: performanceFee,\n', '        activation: block.timestamp,\n', '        debtRatio: debtRatio,\n', '        minDebtPerHarvest: minDebtPerHarvest,\n', '        maxDebtPerHarvest: maxDebtPerHarvest,\n', '        lastReport: block.timestamp,\n', '        totalDebt: 0,\n', '        totalGain: 0,\n', '        totalLoss: 0,\n', '    })\n', '    log StrategyAdded(strategy, debtRatio, minDebtPerHarvest, maxDebtPerHarvest, performanceFee)\n', '\n', '    # Update Vault parameters\n', '    self.debtRatio += debtRatio\n', '\n', '    # Add strategy to the end of the withdrawal queue\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy\n', '    self._organizeWithdrawalQueue()\n', '\n', '\n', '@external\n', 'def updateStrategyDebtRatio(\n', '    strategy: address,\n', '    debtRatio: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Change the quantity of assets `strategy` may manage.\n', '\n', '        This may be called by governance or management.\n', '    @param strategy The Strategy to update.\n', '    @param debtRatio The quantity of assets `strategy` may now manage.\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '    assert self.strategies[strategy].activation > 0\n', '    self.debtRatio -= self.strategies[strategy].debtRatio\n', '    self.strategies[strategy].debtRatio = debtRatio\n', '    self.debtRatio += debtRatio\n', '    assert self.debtRatio <= MAX_BPS\n', '    log StrategyUpdateDebtRatio(strategy, debtRatio)\n', '\n', '\n', '@external\n', 'def updateStrategyMinDebtPerHarvest(\n', '    strategy: address,\n', '    minDebtPerHarvest: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Change the quantity assets per block this Vault may deposit to or\n', '        withdraw from `strategy`.\n', '\n', '        This may only be called by governance or management.\n', '    @param strategy The Strategy to update.\n', '    @param minDebtPerHarvest\n', '        Lower limit on the increase of debt since last harvest\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '    assert self.strategies[strategy].activation > 0\n', '    assert self.strategies[strategy].maxDebtPerHarvest >= minDebtPerHarvest\n', '    self.strategies[strategy].minDebtPerHarvest = minDebtPerHarvest\n', '    log StrategyUpdateMinDebtPerHarvest(strategy, minDebtPerHarvest)\n', '\n', '\n', '@external\n', 'def updateStrategyMaxDebtPerHarvest(\n', '    strategy: address,\n', '    maxDebtPerHarvest: uint256,\n', '):\n', '    """\n', '    @notice\n', '        Change the quantity assets per block this Vault may deposit to or\n', '        withdraw from `strategy`.\n', '\n', '        This may only be called by governance or management.\n', '    @param strategy The Strategy to update.\n', '    @param maxDebtPerHarvest\n', '        Upper limit on the increase of debt since last harvest\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '    assert self.strategies[strategy].activation > 0\n', '    assert self.strategies[strategy].minDebtPerHarvest <= maxDebtPerHarvest\n', '    self.strategies[strategy].maxDebtPerHarvest = maxDebtPerHarvest\n', '    log StrategyUpdateMaxDebtPerHarvest(strategy, maxDebtPerHarvest)\n', '\n', '\n', '@external\n', 'def updateStrategyPerformanceFee(\n', '    strategy: address,\n', '    performanceFee: uint256,\n', '):\n', '    """\n', '    @notice\n', "        Change the fee the strategist will receive based on this Vault's\n", '        performance.\n', '\n', '        This may only be called by governance.\n', '    @param strategy The Strategy to update.\n', '    @param performanceFee The new fee the strategist will receive.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert performanceFee <= MAX_BPS / 2\n', '    assert self.strategies[strategy].activation > 0\n', '    self.strategies[strategy].performanceFee = performanceFee\n', '    log StrategyUpdatePerformanceFee(strategy, performanceFee)\n', '\n', '\n', '@internal\n', 'def _revokeStrategy(strategy: address):\n', '    self.debtRatio -= self.strategies[strategy].debtRatio\n', '    self.strategies[strategy].debtRatio = 0\n', '    log StrategyRevoked(strategy)\n', '\n', '\n', '@external\n', 'def migrateStrategy(oldVersion: address, newVersion: address):\n', '    """\n', '    @notice\n', '        Migrates a Strategy, including all assets from `oldVersion` to\n', '        `newVersion`.\n', '\n', '        This may only be called by governance.\n', '    @dev\n', '        Strategy must successfully migrate all capital and positions to new\n', '        Strategy, or else this will upset the balance of the Vault.\n', '\n', '        The new Strategy should be "empty" e.g. have no prior commitments to\n', '        this Vault, otherwise it could have issues.\n', '    @param oldVersion The existing Strategy to migrate from.\n', '    @param newVersion The new Strategy to migrate to.\n', '    """\n', '    assert msg.sender == self.governance\n', '    assert newVersion != ZERO_ADDRESS\n', '    assert self.strategies[oldVersion].activation > 0\n', '    assert self.strategies[newVersion].activation == 0\n', '\n', '    strategy: StrategyParams = self.strategies[oldVersion]\n', '\n', '    self._revokeStrategy(oldVersion)\n', '    # _revokeStrategy will lower the debtRatio\n', '    self.debtRatio += strategy.debtRatio\n', '    # Debt is migrated to new strategy\n', '    self.strategies[oldVersion].totalDebt = 0\n', '\n', '    self.strategies[newVersion] = StrategyParams({\n', '        performanceFee: strategy.performanceFee,\n', '        # NOTE: use last report for activation time, so E[R] calc works\n', '        activation: strategy.lastReport,\n', '        debtRatio: strategy.debtRatio,\n', '        minDebtPerHarvest: strategy.minDebtPerHarvest,\n', '        maxDebtPerHarvest: strategy.maxDebtPerHarvest,\n', '        lastReport: strategy.lastReport,\n', '        totalDebt: strategy.totalDebt,\n', '        totalGain: 0,\n', '        totalLoss: 0,\n', '    })\n', '\n', '    Strategy(oldVersion).migrate(newVersion)\n', '    log StrategyMigrated(oldVersion, newVersion)\n', '\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == oldVersion:\n', '            self.withdrawalQueue[idx] = newVersion\n', "            return  # Don't need to reorder anything because we swapped\n", '\n', '\n', '@external\n', 'def revokeStrategy(strategy: address = msg.sender):\n', '    """\n', '    @notice\n', '        Revoke a Strategy, setting its debt limit to 0 and preventing any\n', '        future deposits.\n', '\n', '        This function should only be used in the scenario where the Strategy is\n', '        being retired but no migration of the positions are possible, or in the\n', '        extreme scenario that the Strategy needs to be put into "Emergency Exit"\n', '        mode in order for it to exit as quickly as possible. The latter scenario\n', '        could be for any reason that is considered "critical" that the Strategy\n', '        exits its position as fast as possible, such as a sudden change in market\n', '        conditions leading to losses, or an imminent failure in an external\n', '        dependency.\n', '\n', '        This may only be called by governance, the guardian, or the Strategy\n', '        itself. Note that a Strategy will only revoke itself during emergency\n', '        shutdown.\n', '    @param strategy The Strategy to revoke.\n', '    """\n', '    assert msg.sender in [strategy, self.governance, self.guardian]\n', '    assert self.strategies[strategy].debtRatio != 0 # dev: already zero\n', '\n', '    self._revokeStrategy(strategy)\n', '\n', '\n', '@external\n', 'def addStrategyToQueue(strategy: address):\n', '    """\n', '    @notice\n', '        Adds `strategy` to `withdrawalQueue`.\n', '\n', '        This may only be called by governance or management.\n', '    @dev\n', '        The Strategy will be appended to `withdrawalQueue`, call\n', '        `setWithdrawalQueue` to change the order.\n', '    @param strategy The Strategy to add.\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '    # Must be a current Strategy\n', '    assert self.strategies[strategy].activation > 0\n', "    # Can't already be in the queue\n", '    last_idx: uint256 = 0\n', '    for s in self.withdrawalQueue:\n', '        if s == ZERO_ADDRESS:\n', '            break\n', '        assert s != strategy\n', '        last_idx += 1\n', '    # Check if queue is full\n', '    assert last_idx < MAXIMUM_STRATEGIES\n', '\n', '    self.withdrawalQueue[MAXIMUM_STRATEGIES - 1] = strategy\n', '    self._organizeWithdrawalQueue()\n', '    log StrategyAddedToQueue(strategy)\n', '\n', '\n', '@external\n', 'def removeStrategyFromQueue(strategy: address):\n', '    """\n', '    @notice\n', '        Remove `strategy` from `withdrawalQueue`.\n', '\n', '        This may only be called by governance or management.\n', '    @dev\n', "        We don't do this with revokeStrategy because it should still\n", "        be possible to withdraw from the Strategy if it's unwinding.\n", '    @param strategy The Strategy to remove.\n', '    """\n', '    assert msg.sender in [self.management, self.governance]\n', '    for idx in range(MAXIMUM_STRATEGIES):\n', '        if self.withdrawalQueue[idx] == strategy:\n', '            self.withdrawalQueue[idx] = ZERO_ADDRESS\n', '            self._organizeWithdrawalQueue()\n', '            log StrategyRemovedFromQueue(strategy)\n', '            return  # We found the right location and cleared it\n', "    raise  # We didn't find the Strategy in the queue\n", '\n', '\n', '@view\n', '@internal\n', 'def _debtOutstanding(strategy: address) -> uint256:\n', '    # See note on `debtOutstanding()`.\n', '    if self.debtRatio == 0:\n', '        return self.strategies[strategy].totalDebt\n', '\n', '    strategy_debtLimit: uint256 = (\n', '        self.strategies[strategy].debtRatio\n', '        * self._totalAssets()\n', '        / MAX_BPS\n', '    )\n', '    strategy_totalDebt: uint256 = self.strategies[strategy].totalDebt\n', '\n', '    if self.emergencyShutdown:\n', '        return strategy_totalDebt\n', '    elif strategy_totalDebt <= strategy_debtLimit:\n', '        return 0\n', '    else:\n', '        return strategy_totalDebt - strategy_debtLimit\n', '\n', '\n', '@view\n', '@external\n', 'def debtOutstanding(strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Determines if `strategy` is past its debt limit and if any tokens\n', '        should be withdrawn to the Vault.\n', '    @param strategy The Strategy to check. Defaults to the caller.\n', '    @return The quantity of tokens to withdraw.\n', '    """\n', '    return self._debtOutstanding(strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _creditAvailable(strategy: address) -> uint256:\n', '    # See note on `creditAvailable()`.\n', '    if self.emergencyShutdown:\n', '        return 0\n', '    vault_totalAssets: uint256 = self._totalAssets()\n', '    vault_debtLimit: uint256 =  self.debtRatio * vault_totalAssets / MAX_BPS \n', '    vault_totalDebt: uint256 = self.totalDebt\n', '    strategy_debtLimit: uint256 = self.strategies[strategy].debtRatio * vault_totalAssets / MAX_BPS\n', '    strategy_totalDebt: uint256 = self.strategies[strategy].totalDebt\n', '    strategy_minDebtPerHarvest: uint256 = self.strategies[strategy].minDebtPerHarvest\n', '    strategy_maxDebtPerHarvest: uint256 = self.strategies[strategy].maxDebtPerHarvest\n', '\n', '    # Exhausted credit line\n', '    if strategy_debtLimit <= strategy_totalDebt or vault_debtLimit <= vault_totalDebt:\n', '        return 0\n', '\n', '    # Start with debt limit left for the Strategy\n', '    available: uint256 = strategy_debtLimit - strategy_totalDebt\n', '\n', '    # Adjust by the global debt limit left\n', '    available = min(available, vault_debtLimit - vault_totalDebt)\n', '\n', '    # Can only borrow up to what the contract has in reserve\n', '    # NOTE: Running near 100% is discouraged\n', '    available = min(available, self.token.balanceOf(self))\n', '\n', '    # Adjust by min and max borrow limits (per harvest)\n', '    # NOTE: min increase can be used to ensure that if a strategy has a minimum\n', "    #       amount of capital needed to purchase a position, it's not given capital\n", "    #       it can't make use of yet.\n", "    # NOTE: max increase is used to make sure each harvest isn't bigger than what\n", '    #       is authorized. This combined with adjusting min and max periods in\n', '    #       `BaseStrategy` can be used to effect a "rate limit" on capital increase.\n', '    if available < strategy_minDebtPerHarvest:\n', '        return 0\n', '    else:\n', '        return min(available, strategy_maxDebtPerHarvest)\n', '\n', '@view\n', '@external\n', 'def creditAvailable(strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Amount of tokens in Vault a Strategy has access to as a credit line.\n', '\n', "        This will check the Strategy's debt limit, as well as the tokens\n", '        available in the Vault, and determine the maximum amount of tokens\n', '        (if any) the Strategy may draw on.\n', '\n', '        In the rare case the Vault is in emergency shutdown this will return 0.\n', '    @param strategy The Strategy to check. Defaults to caller.\n', '    @return The quantity of tokens available for the Strategy to draw on.\n', '    """\n', '    return self._creditAvailable(strategy)\n', '\n', '\n', '@view\n', '@internal\n', 'def _expectedReturn(strategy: address) -> uint256:\n', '    # See note on `expectedReturn()`.\n', '    strategy_lastReport: uint256 = self.strategies[strategy].lastReport\n', '    timeSinceLastHarvest: uint256 = block.timestamp - strategy_lastReport\n', '    totalHarvestTime: uint256 = strategy_lastReport - self.strategies[strategy].activation\n', '\n', '    # NOTE: If either `timeSinceLastHarvest` or `totalHarvestTime` is 0, we can short-circuit to `0`\n', '    if timeSinceLastHarvest > 0 and totalHarvestTime > 0 and Strategy(strategy).isActive():\n', '        # NOTE: Unlikely to throw unless strategy accumalates >1e68 returns\n', '        # NOTE: Calculate average over period of time where harvests have occured in the past\n', '        return (\n', '            self.strategies[strategy].totalGain\n', '            * timeSinceLastHarvest\n', '            / totalHarvestTime\n', '        )\n', '    else:\n', '        return 0  # Covers the scenario when block.timestamp == activation\n', '\n', '\n', '@view\n', '@external\n', 'def availableDepositLimit() -> uint256:\n', '    if self.depositLimit > self._totalAssets():\n', '        return self.depositLimit - self._totalAssets()\n', '    else:\n', '        return 0\n', '\n', '\n', '@view\n', '@external\n', 'def expectedReturn(strategy: address = msg.sender) -> uint256:\n', '    """\n', '    @notice\n', '        Provide an accurate expected value for the return this `strategy`\n', '        would provide to the Vault the next time `report()` is called\n', '        (since the last time it was called).\n', '    @param strategy The Strategy to determine the expected return for. Defaults to caller.\n', '    @return\n', '        The anticipated amount `strategy` should make on its investment\n', '        since its last report.\n', '    """\n', '    return self._expectedReturn(strategy)\n', '\n', '\n', '@internal\n', 'def _assessFees(strategy: address, gain: uint256) -> uint256:\n', '    # Issue new shares to cover fees\n', '    # NOTE: In effect, this reduces overall share price by the combined fee\n', '    # NOTE: may throw if Vault.totalAssets() > 1e64, or not called for more than a year\n', '    duration: uint256 = block.timestamp - self.strategies[strategy].lastReport\n', "    assert duration != 0 # can't assessFees twice within the same block\n", '\n', '    if gain == 0:\n', "        # NOTE: The fees are not charged if there hasn't been any gains reported\n", '        return 0\n', '\n', '    management_fee: uint256 = (\n', '        (\n', '            (self.strategies[strategy].totalDebt - Strategy(strategy).delegatedAssets())\n', '            * duration \n', '            * self.managementFee\n', '        )\n', '        / MAX_BPS\n', '        / SECS_PER_YEAR\n', '    )\n', '\n', '    # NOTE: Applies if Strategy is not shutting down, or it is but all debt paid off\n', "    # NOTE: No fee is taken when a Strategy is unwinding it's position, until all debt is paid\n", '    strategist_fee: uint256 = (\n', '        gain\n', '        * self.strategies[strategy].performanceFee\n', '        / MAX_BPS\n', '    )\n', '    # NOTE: Unlikely to throw unless strategy reports >1e72 harvest profit\n', '    performance_fee: uint256 = gain * self.performanceFee / MAX_BPS\n', '\n', '    # NOTE: This must be called prior to taking new collateral,\n', '    #       or the calculation will be wrong!\n', '    # NOTE: This must be done at the same time, to ensure the relative\n', '    #       ratio of governance_fee : strategist_fee is kept intact\n', '    total_fee: uint256 = performance_fee + strategist_fee + management_fee\n', '    # ensure total_fee is not more than gain\n', '    if total_fee > gain:\n', '        total_fee = gain\n', '    if total_fee > 0:  # NOTE: If mgmt fee is 0% and no gains were realized, skip\n', '        reward: uint256 = self._issueSharesForAmount(self, total_fee)\n', '\n', '        # Send the rewards out as new shares in this Vault\n', '        if strategist_fee > 0:  # NOTE: Guard against DIV/0 fault\n', '            # NOTE: Unlikely to throw unless sqrt(reward) >>> 1e39\n', '            strategist_reward: uint256 = (\n', '                strategist_fee\n', '                * reward\n', '                / total_fee\n', '            )\n', '            self._transfer(self, strategy, strategist_reward)\n', '            # NOTE: Strategy distributes rewards at the end of harvest()\n', '        # NOTE: Governance earns any dust leftover from flooring math above\n', '        if self.balanceOf[self] > 0:\n', '            self._transfer(self, self.rewards, self.balanceOf[self])\n', '    return total_fee\n', '\n', '\n', '@external\n', 'def report(gain: uint256, loss: uint256, _debtPayment: uint256) -> uint256:\n', '    """\n', '    @notice\n', '        Reports the amount of assets the calling Strategy has free (usually in\n', '        terms of ROI).\n', '\n', "        The performance fee is determined here, off of the strategy's profits\n", '        (if any), and sent to governance.\n', '\n', "        The strategist's fee is also determined here (off of profits), to be\n", '        handled according to the strategist on the next harvest.\n', '\n', '        This may only be called by a Strategy managed by this Vault.\n', '    @dev\n', '        For approved strategies, this is the most efficient behavior.\n', '        The Strategy reports back what it has free, then Vault "decides"\n', '        whether to take some back or give it more. Note that the most it can\n', '        take is `gain + _debtPayment`, and the most it can give is all of the\n', '        remaining reserves. Anything outside of those bounds is abnormal behavior.\n', '\n', '        All approved strategies must have increased diligence around\n', '        calling this function, as abnormal behavior could become catastrophic.\n', '    @param gain\n', "        Amount Strategy has realized as a gain on it's investment since its\n", '        last report, and is free to be given back to Vault as earnings\n', '    @param loss\n', "        Amount Strategy has realized as a loss on it's investment since its\n", "        last report, and should be accounted for on the Vault's balance sheet.\n", '        The loss will reduce the debtRatio. The next time the strategy will harvest,\n', '        it will pay back the debt in an attempt to adjust to the new debt limit.\n', '    @param _debtPayment\n', '        Amount Strategy has made available to cover outstanding debt\n', '    @return Amount of debt outstanding (if totalDebt > debtLimit or emergency shutdown).\n', '    """\n', '\n', '    # Only approved strategies can call this function\n', '    assert self.strategies[msg.sender].activation > 0\n', '    # No lying about total available to withdraw!\n', '    assert self.token.balanceOf(msg.sender) >= gain + _debtPayment\n', '\n', '    # We have a loss to report, do it before the rest of the calculations\n', '    if loss > 0:\n', '        self._reportLoss(msg.sender, loss)\n', '\n', '    # Assess both management fee and performance fee, and issue both as shares of the vault\n', '    totalFees: uint256 = self._assessFees(msg.sender, gain)\n', '\n', '    # Returns are always "realized gains"\n', '    self.strategies[msg.sender].totalGain += gain\n', '\n', '    # Compute the line of credit the Vault is able to offer the Strategy (if any)\n', '    credit: uint256 = self._creditAvailable(msg.sender)\n', '\n', '    # Outstanding debt the Strategy wants to take back from the Vault (if any)\n', '    # NOTE: debtOutstanding <= StrategyParams.totalDebt\n', '    debt: uint256 = self._debtOutstanding(msg.sender)\n', '    debtPayment: uint256 = min(_debtPayment, debt)\n', '\n', '    if debtPayment > 0:\n', '        self.strategies[msg.sender].totalDebt -= debtPayment\n', '        self.totalDebt -= debtPayment\n', '        debt -= debtPayment\n', '        # NOTE: `debt` is being tracked for later\n', '\n', '    # Update the actual debt based on the full credit we are extending to the Strategy\n', '    # or the returns if we are taking funds back\n', '    # NOTE: credit + self.strategies[msg.sender].totalDebt is always < self.debtLimit\n', '    # NOTE: At least one of `credit` or `debt` is always 0 (both can be 0)\n', '    if credit > 0:\n', '        self.strategies[msg.sender].totalDebt += credit\n', '        self.totalDebt += credit\n', '\n', '    # Give/take balance to Strategy, based on the difference between the reported gains\n', '    # (if any), the debt payment (if any), the credit increase we are offering (if any),\n', '    # and the debt needed to be paid off (if any)\n', '    # NOTE: This is just used to adjust the balance of tokens between the Strategy and\n', "    #       the Vault based on the Strategy's debt limit (as well as the Vault's).\n", '    totalAvail: uint256 = gain + debtPayment\n', '    if totalAvail < credit:  # credit surplus, give to Strategy\n', '        self.erc20_safe_transfer(self.token.address, msg.sender, credit - totalAvail)\n', '    elif totalAvail > credit:  # credit deficit, take from Strategy\n', '        self.erc20_safe_transferFrom(self.token.address, msg.sender, self, totalAvail - credit)\n', "    # else, don't do anything because it is balanced\n", '\n', '    # Profit is locked and gradually released per block\n', '    # NOTE: compute current locked profit and replace with sum of current and new\n', '    lockedProfitBeforeLoss: uint256 = self._calculateLockedProfit() + gain - totalFees\n', '    if lockedProfitBeforeLoss > loss: \n', '        self.lockedProfit = lockedProfitBeforeLoss - loss\n', '    else:\n', '        self.lockedProfit = 0\n', '\n', '    # Update reporting time\n', '    self.strategies[msg.sender].lastReport = block.timestamp\n', '    self.lastReport = block.timestamp\n', '\n', '    log StrategyReported(\n', '        msg.sender,\n', '        gain,\n', '        loss,\n', '        debtPayment,\n', '        self.strategies[msg.sender].totalGain,\n', '        self.strategies[msg.sender].totalLoss,\n', '        self.strategies[msg.sender].totalDebt,\n', '        credit,\n', '        self.strategies[msg.sender].debtRatio,\n', '    )\n', '\n', '    if self.strategies[msg.sender].debtRatio == 0 or self.emergencyShutdown:\n', '        # Take every last penny the Strategy has (Emergency Exit/revokeStrategy)\n', '        # NOTE: This is different than `debt` in order to extract *all* of the returns\n', '        return Strategy(msg.sender).estimatedTotalAssets()\n', '    else:\n', '        # Otherwise, just return what we have as debt outstanding\n', '        return debt\n', '\n', '\n', '@external\n', 'def sweep(token: address, amount: uint256 = MAX_UINT256):\n', '    """\n', '    @notice\n', '        Removes tokens from this Vault that are not the type of token managed\n', '        by this Vault. This may be used in case of accidentally sending the\n', '        wrong kind of token to this Vault.\n', '\n', '        Tokens will be sent to `governance`.\n', '\n', '        This will fail if an attempt is made to sweep the tokens that this\n', '        Vault manages.\n', '\n', '        This may only be called by governance.\n', '    @param token The token to transfer out of this vault.\n', '    @param amount The quantity or tokenId to transfer out.\n', '    """\n', '    assert msg.sender == self.governance\n', "    # Can't be used to steal what this Vault is protecting\n", '    assert token != self.token.address\n', '    value: uint256 = amount\n', '    if value == MAX_UINT256:\n', '        value = ERC20(token).balanceOf(self)\n', '    self.erc20_safe_transfer(token, self.governance, value)']