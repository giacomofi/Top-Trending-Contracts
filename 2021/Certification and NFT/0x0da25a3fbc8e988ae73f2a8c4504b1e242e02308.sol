['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.6;\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract ContextUpgradeSafe is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {}\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external pure returns (string memory);\n', '\n', '    function symbol() external pure returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function kLast() external view returns (uint256);\n', '\n', '    function mint(address to) external returns (uint256 liquidity);\n', '\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function skim(address to) external;\n', '\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '}\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint256;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', '        require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");\n', '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");\n', '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(\n', '        address factory,\n', '        address tokenA,\n', '        address tokenB\n', '    ) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(\n', '            uint256(\n', '                keccak256(\n', '                    abi.encodePacked(\n', '                        hex"ff",\n', '                        factory,\n', '                        keccak256(abi.encodePacked(token0, token1)),\n', '                        hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f" // init code hash\n', '                    )\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(\n', '        address factory,\n', '        address tokenA,\n', '        address tokenB\n', '    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n', '        (address token0, ) = sortTokens(tokenA, tokenB);\n', '        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) internal pure returns (uint256 amountB) {\n', '        require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");\n', '        require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");\n', '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) internal pure returns (uint256 amountOut) {\n', '        require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");\n', '        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");\n', '        uint256 amountInWithFee = amountIn.mul(997);\n', '        uint256 numerator = amountInWithFee.mul(reserveOut);\n', '        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) internal pure returns (uint256 amountIn) {\n', '        require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");\n', '        require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");\n', '        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(\n', '        address factory,\n', '        uint256 amountIn,\n', '        address[] memory path\n', '    ) internal view returns (uint256[] memory amounts) {\n', '        require(path.length >= 2, "UniswapV2Library: INVALID_PATH");\n', '        amounts = new uint256[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint256 i; i < path.length - 1; i++) {\n', '            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(\n', '        address factory,\n', '        uint256 amountOut,\n', '        address[] memory path\n', '    ) internal view returns (uint256[] memory amounts) {\n', '        require(path.length >= 2, "UniswapV2Library: INVALID_PATH");\n', '        amounts = new uint256[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint256 i = path.length - 1; i > 0; i--) {\n', '            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) external pure returns (uint256 amountB);\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{value: value}(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(\n', '        bool success,\n', '        bytes memory returndata,\n', '        string memory errorMessage\n', '    ) private pure returns (bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract IMlp {\n', '    function makeOffer(\n', '        address _token,\n', '        uint256 _amount,\n', '        uint256 _unlockDate,\n', '        uint256 _endDate,\n', '        uint256 _slippageTolerancePpm,\n', '        uint256 _maxPriceVariationPpm\n', '    ) external virtual returns (uint256 offerId);\n', '\n', '    function takeOffer(\n', '        uint256 _pendingOfferId,\n', '        uint256 _amount,\n', '        uint256 _deadline\n', '    ) external virtual returns (uint256 activeOfferId);\n', '\n', '    function cancelOffer(uint256 _offerId) external virtual;\n', '\n', '    function release(uint256 _offerId, uint256 _deadline) external virtual;\n', '}\n', '\n', 'abstract contract IFeesController {\n', '    function feesTo() public virtual returns (address);\n', '\n', '    function setFeesTo(address) public virtual;\n', '\n', '    function feesPpm() public virtual returns (uint256);\n', '\n', '    function setFeesPpm(uint256) public virtual;\n', '}\n', '\n', 'abstract contract IRewardManager {\n', '    function add(uint256 _allocPoint, address _newMlp) public virtual;\n', '\n', '    function notifyDeposit(address _account, uint256 _amount) public virtual;\n', '\n', '    function notifyWithdraw(address _account, uint256 _amount) public virtual;\n', '\n', '    function getPoolSupply(address pool) public view virtual returns (uint256);\n', '\n', '    function getUserAmount(address pool, address user) public view virtual returns (uint256);\n', '}\n', '\n', 'contract MLP is IMlp {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public endDate;\n', '    address public submitter;\n', '    uint256 public exceedingLiquidity;\n', '    uint256 public bonusToken0;\n', '    uint256 public reward0Rate;\n', '    uint256 public reward0PerTokenStored;\n', '    uint256 public bonusToken1;\n', '    uint256 public reward1Rate;\n', '    uint256 public reward1PerTokenStored;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public pendingOfferCount;\n', '    uint256 public activeOfferCount;\n', '\n', '    IRewardManager public rewardManager;\n', '    IUniswapV2Pair public uniswapPair;\n', '    IFeesController public feesController;\n', '    IUniswapV2Router02 public uniswapRouter;\n', '\n', '    mapping(address => uint256) public userReward0PerTokenPaid;\n', '    mapping(address => uint256) public userRewards0;\n', '    mapping(address => uint256) public userReward1PerTokenPaid;\n', '    mapping(address => uint256) public userRewards1;\n', '    mapping(address => uint256) public directStakeBalances;\n', '    mapping(uint256 => PendingOffer) public getPendingOffer;\n', '    mapping(uint256 => ActiveOffer) public getActiveOffer;\n', '\n', '    enum OfferStatus {PENDING, TAKEN, CANCELED}\n', '\n', '    event OfferMade(uint256 id);\n', '    event OfferTaken(uint256 pendingOfferId, uint256 activeOfferId);\n', '    event OfferCanceled(uint256 id);\n', '    event OfferReleased(uint256 offerId);\n', '\n', '    struct PendingOffer {\n', '        address owner;\n', '        address token;\n', '        uint256 amount;\n', '        uint256 unlockDate;\n', '        uint256 endDate;\n', '        OfferStatus status;\n', '        uint256 slippageTolerancePpm;\n', '        uint256 maxPriceVariationPpm;\n', '    }\n', '\n', '    struct ActiveOffer {\n', '        address user0;\n', '        uint256 originalAmount0;\n', '        address user1;\n', '        uint256 originalAmount1;\n', '        uint256 unlockDate;\n', '        uint256 liquidity;\n', '        bool released;\n', '        uint256 maxPriceVariationPpm;\n', '    }\n', '\n', '    constructor(\n', '        address _uniswapPair,\n', '        address _submitter,\n', '        uint256 _endDate,\n', '        address _uniswapRouter,\n', '        address _feesController,\n', '        IRewardManager _rewardManager,\n', '        uint256 _bonusToken0,\n', '        uint256 _bonusToken1\n', '    ) public {\n', '        feesController = IFeesController(_feesController);\n', '        uniswapPair = IUniswapV2Pair(_uniswapPair);\n', '        endDate = _endDate;\n', '        submitter = _submitter;\n', '        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n', '        rewardManager = _rewardManager;\n', '\n', '        uint256 remainingTime = _endDate.sub(block.timestamp);\n', '        bonusToken0 = _bonusToken0;\n', '        reward0Rate = _bonusToken0 / remainingTime;\n', '        bonusToken1 = _bonusToken1;\n', '        reward1Rate = _bonusToken1 / remainingTime;\n', '        lastUpdateTime = block.timestamp;\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, endDate);\n', '    }\n', '\n', '    function reward0PerToken() public view returns (uint256) {\n', '        uint256 totalSupply = rewardManager.getPoolSupply(address(this));\n', '        if (totalSupply == 0) {\n', '            return reward0PerTokenStored;\n', '        }\n', '        return reward0PerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(reward0Rate).mul(1e18) / totalSupply);\n', '    }\n', '\n', '    function reward1PerToken() public view returns (uint256) {\n', '        uint256 totalSupply = rewardManager.getPoolSupply(address(this));\n', '        if (totalSupply == 0) {\n', '            return reward1PerTokenStored;\n', '        }\n', '        return reward1PerTokenStored.add(lastTimeRewardApplicable().sub(lastUpdateTime).mul(reward1Rate).mul(1e18) / totalSupply);\n', '    }\n', '\n', '    function rewardEarned(address account) public view returns (uint256 reward0Earned, uint256 reward1Earned) {\n', '        uint256 balance = rewardManager.getUserAmount(address(this), account);\n', '        reward0Earned = (balance.mul(reward0PerToken().sub(userReward0PerTokenPaid[account])) / 1e18).add(userRewards0[account]);\n', '        reward1Earned = (balance.mul(reward1PerToken().sub(userReward1PerTokenPaid[account])) / 1e18).add(userRewards1[account]);\n', '    }\n', '\n', '    function updateRewards(address account) internal {\n', '        reward0PerTokenStored = reward0PerToken();\n', '        reward1PerTokenStored = reward1PerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            (uint256 earned0, uint256 earned1) = rewardEarned(account);\n', '            userRewards0[account] = earned0;\n', '            userRewards1[account] = earned1;\n', '            userReward0PerTokenPaid[account] = reward0PerTokenStored;\n', '            userReward1PerTokenPaid[account] = reward1PerTokenStored;\n', '        }\n', '    }\n', '\n', '    function payRewards(address account) public {\n', '        updateRewards(account);\n', '        (uint256 reward0, uint256 reward1) = rewardEarned(account);\n', '        if (reward0 > 0) {\n', '            userRewards0[account] = 0;\n', '            IERC20(uniswapPair.token0()).safeTransfer(account, reward0);\n', '        }\n', '        if (reward1 > 0) {\n', '            userRewards1[account] = 0;\n', '            IERC20(uniswapPair.token1()).safeTransfer(account, reward1);\n', '        }\n', '    }\n', '\n', '    function _notifyDeposit(address account, uint256 amount) internal {\n', '        updateRewards(account);\n', '        rewardManager.notifyDeposit(account, amount);\n', '    }\n', '\n', '    function _notifyWithdraw(address account, uint256 amount) internal {\n', '        updateRewards(account);\n', '        rewardManager.notifyWithdraw(account, amount);\n', '    }\n', '\n', '    function makeOffer(\n', '        address _token,\n', '        uint256 _amount,\n', '        uint256 _unlockDate,\n', '        uint256 _endDate,\n', '        uint256 _slippageTolerancePpm,\n', '        uint256 _maxPriceVariationPpm\n', '    ) external override returns (uint256 offerId) {\n', '        require(_amount > 0);\n', '        require(_endDate > now);\n', '        require(_endDate <= _unlockDate);\n', '        offerId = pendingOfferCount;\n', '        pendingOfferCount++;\n', '        getPendingOffer[offerId] = PendingOffer(\n', '            msg.sender,\n', '            _token,\n', '            _amount,\n', '            _unlockDate,\n', '            _endDate,\n', '            OfferStatus.PENDING,\n', '            _slippageTolerancePpm,\n', '            _maxPriceVariationPpm\n', '        );\n', '        IERC20 token;\n', '        if (_token == address(uniswapPair.token0())) {\n', '            token = IERC20(uniswapPair.token0());\n', '        } else if (_token == address(uniswapPair.token1())) {\n', '            token = IERC20(uniswapPair.token1());\n', '        } else {\n', '            require(false, "unknown token");\n', '        }\n', '\n', '        token.safeTransferFrom(msg.sender, address(this), _amount);\n', '        emit OfferMade(offerId);\n', '    }\n', '\n', '    struct ProviderInfo {\n', '        address user;\n', '        uint256 amount;\n', '        IERC20 token;\n', '    }\n', '\n', '    struct OfferInfo {\n', '        uint256 deadline;\n', '        uint256 slippageTolerancePpm;\n', '    }\n', '\n', '    function takeOffer(\n', '        uint256 _pendingOfferId,\n', '        uint256 _amount,\n', '        uint256 _deadline\n', '    ) external override returns (uint256 activeOfferId) {\n', '        PendingOffer storage pendingOffer = getPendingOffer[_pendingOfferId];\n', '        require(pendingOffer.status == OfferStatus.PENDING);\n', '        require(pendingOffer.endDate > now);\n', '        pendingOffer.status = OfferStatus.TAKEN;\n', '\n', '        // Sort the users, tokens, and amount\n', '        ProviderInfo memory provider0;\n', '        ProviderInfo memory provider1;\n', '        {\n', '            if (pendingOffer.token == uniswapPair.token0()) {\n', '                provider0 = ProviderInfo(pendingOffer.owner, pendingOffer.amount, IERC20(uniswapPair.token0()));\n', '                provider1 = ProviderInfo(msg.sender, _amount, IERC20(uniswapPair.token1()));\n', '\n', '                provider1.token.safeTransferFrom(provider1.user, address(this), provider1.amount);\n', '            } else {\n', '                provider0 = ProviderInfo(msg.sender, _amount, IERC20(uniswapPair.token0()));\n', '                provider1 = ProviderInfo(pendingOffer.owner, pendingOffer.amount, IERC20(uniswapPair.token1()));\n', '\n', '                provider0.token.safeTransferFrom(provider0.user, address(this), provider0.amount);\n', '            }\n', '        }\n', '\n', '        // calculate fees\n', '        uint256 feesAmount0 = provider0.amount.mul(feesController.feesPpm()) / 1000;\n', '        uint256 feesAmount1 = provider1.amount.mul(feesController.feesPpm()) / 1000;\n', '\n', '        // take fees\n', '        provider0.amount = provider0.amount.sub(feesAmount0);\n', '        provider1.amount = provider1.amount.sub(feesAmount1);\n', '\n', '        // send fees\n', '        provider0.token.safeTransfer(feesController.feesTo(), feesAmount0);\n', '        provider1.token.safeTransfer(feesController.feesTo(), feesAmount1);\n', '\n', '        uint256 spentAmount0;\n', '        uint256 spentAmount1;\n', '        uint256 liquidity;\n', '        uint256[] memory returnedValues = new uint256[](3);\n', '\n', '        // send tokens to uniswap\n', '        {\n', '            returnedValues = _provideLiquidity(provider0, provider1, OfferInfo(_deadline, pendingOffer.slippageTolerancePpm));\n', '            liquidity = returnedValues[0];\n', '            spentAmount0 = returnedValues[1];\n', '            spentAmount1 = returnedValues[2];\n', '        }\n', '\n', '        // stake liquidity\n', '        _notifyDeposit(provider0.user, liquidity / 2);\n', '        _notifyDeposit(provider1.user, liquidity / 2);\n', '\n', '        if (liquidity % 2 != 0) {\n', '            exceedingLiquidity = exceedingLiquidity.add(1);\n', '        }\n', '\n', '        // Record the active offer\n', '        activeOfferId = activeOfferCount;\n', '        activeOfferCount++;\n', '\n', '        getActiveOffer[activeOfferId] = ActiveOffer(\n', '            provider0.user,\n', '            spentAmount0,\n', '            provider1.user,\n', '            spentAmount1,\n', '            pendingOffer.unlockDate,\n', '            liquidity,\n', '            false,\n', '            pendingOffer.maxPriceVariationPpm\n', '        );\n', '\n', '        emit OfferTaken(_pendingOfferId, activeOfferId);\n', '\n', '        return activeOfferId;\n', '    }\n', '\n', '    function _provideLiquidity(\n', '        ProviderInfo memory _provider0,\n', '        ProviderInfo memory _provider1,\n', '        OfferInfo memory _info\n', '    ) internal returns (uint256[] memory) {\n', '        _provider0.token.safeApprove(address(uniswapRouter), 0);\n', '        _provider1.token.safeApprove(address(uniswapRouter), 0);\n', '\n', '        _provider0.token.safeApprove(address(uniswapRouter), _provider0.amount);\n', '        _provider1.token.safeApprove(address(uniswapRouter), _provider1.amount);\n', '\n', '        uint256 amountMin0 = _provider0.amount.sub(_provider0.amount.mul(_info.slippageTolerancePpm) / 1000);\n', '        uint256 amountMin1 = _provider1.amount.sub(_provider1.amount.mul(_info.slippageTolerancePpm) / 1000);\n', '\n', '        // Add the liquidity to Uniswap\n', '        uint256 spentAmount0;\n', '        uint256 spentAmount1;\n', '        uint256 liquidity;\n', '        {\n', '            (spentAmount0, spentAmount1, liquidity) = uniswapRouter.addLiquidity(\n', '                address(_provider0.token),\n', '                address(_provider1.token),\n', '                _provider0.amount,\n', '                _provider1.amount,\n', '                amountMin0,\n', '                amountMin1,\n', '                address(this),\n', '                _info.deadline\n', '            );\n', '        }\n', '        // Give back the exceeding tokens\n', '        if (spentAmount0 < _provider0.amount) {\n', '            _provider0.token.safeTransfer(_provider0.user, _provider0.amount - spentAmount0);\n', '        }\n', '        if (spentAmount1 < _provider1.amount) {\n', '            _provider1.token.safeTransfer(_provider1.user, _provider1.amount - spentAmount1);\n', '        }\n', '        uint256[] memory liq = new uint256[](3);\n', '        liq[0] = liquidity;\n', '        liq[1] = spentAmount0;\n', '        liq[2] = spentAmount1;\n', '        return (liq);\n', '    }\n', '\n', '    function cancelOffer(uint256 _offerId) external override {\n', '        PendingOffer storage pendingOffer = getPendingOffer[_offerId];\n', '        require(pendingOffer.status == OfferStatus.PENDING);\n', '        pendingOffer.status = OfferStatus.CANCELED;\n', '        IERC20(pendingOffer.token).safeTransfer(pendingOffer.owner, pendingOffer.amount);\n', '        emit OfferCanceled(_offerId);\n', '    }\n', '\n', '    function release(uint256 _offerId, uint256 _deadline) external override {\n', '        ActiveOffer storage offer = getActiveOffer[_offerId];\n', '\n', '        require(msg.sender == offer.user0 || msg.sender == offer.user1, "unauthorized");\n', '        require(now > offer.unlockDate, "locked");\n', '        require(!offer.released, "already released");\n', '        offer.released = true;\n', '\n', '        IERC20 token0 = IERC20(uniswapPair.token0());\n', '        IERC20 token1 = IERC20(uniswapPair.token1());\n', '\n', '        IERC20(address(uniswapPair)).safeApprove(address(uniswapRouter), 0);\n', '\n', '        IERC20(address(uniswapPair)).safeApprove(address(uniswapRouter), offer.liquidity);\n', '        (uint256 amount0, uint256 amount1) = uniswapRouter.removeLiquidity(address(token0), address(token1), offer.liquidity, 0, 0, address(this), _deadline);\n', '\n', '        _notifyWithdraw(offer.user0, offer.liquidity / 2);\n', '        _notifyWithdraw(offer.user1, offer.liquidity / 2);\n', '\n', '        if (_getPriceVariation(offer.originalAmount0, amount0) > offer.maxPriceVariationPpm) {\n', '            if (amount0 > offer.originalAmount0) {\n', '                uint256 toSwap = amount0.sub(offer.originalAmount0);\n', '                address[] memory path = new address[](2);\n', '                path[0] = uniswapPair.token0();\n', '                path[1] = uniswapPair.token1();\n', '                token0.safeApprove(address(uniswapRouter), 0);\n', '                token0.safeApprove(address(uniswapRouter), toSwap);\n', '                uint256[] memory newAmounts = uniswapRouter.swapExactTokensForTokens(toSwap, 0, path, address(this), _deadline);\n', '                amount0 = amount0.sub(toSwap);\n', '                amount1 = amount1.add(newAmounts[1]);\n', '            }\n', '        }\n', '        if (_getPriceVariation(offer.originalAmount1, amount1) > offer.maxPriceVariationPpm) {\n', '            if (amount1 > offer.originalAmount1) {\n', '                uint256 toSwap = amount1.sub(offer.originalAmount1);\n', '                address[] memory path = new address[](2);\n', '                path[0] = uniswapPair.token1();\n', '                path[1] = uniswapPair.token0();\n', '                token1.safeApprove(address(uniswapRouter), 0);\n', '                token1.safeApprove(address(uniswapRouter), toSwap);\n', '                uint256[] memory newAmounts = uniswapRouter.swapExactTokensForTokens(toSwap, 0, path, address(this), _deadline);\n', '                amount1 = amount1.sub(toSwap);\n', '                amount0 = amount0.add(newAmounts[1]);\n', '            }\n', '        }\n', '\n', '        token0.safeTransfer(offer.user0, amount0);\n', '        payRewards(offer.user0);\n', '        token1.safeTransfer(offer.user1, amount1);\n', '        payRewards(offer.user1);\n', '\n', '        emit OfferReleased(_offerId);\n', '    }\n', '\n', '    function _getPriceVariation(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 sub;\n', '        if (a > b) {\n', '            sub = a.sub(b);\n', '            return sub.mul(1000) / a;\n', '        } else {\n', '            sub = b.sub(a);\n', '            return sub.mul(1000) / b;\n', '        }\n', '    }\n', '\n', '    function directStake(uint256 _amount) external {\n', '        require(_amount > 0, "cannot stake 0");\n', '        _notifyDeposit(msg.sender, _amount);\n', '        directStakeBalances[msg.sender] = directStakeBalances[msg.sender].add(_amount);\n', '        IERC20(address(uniswapPair)).safeTransferFrom(msg.sender, address(this), _amount);\n', '    }\n', '\n', '    function directWithdraw(uint256 _amount) external {\n', '        require(_amount > 0, "cannot withdraw 0");\n', '        _notifyWithdraw(msg.sender, _amount);\n', '        directStakeBalances[msg.sender] = directStakeBalances[msg.sender].sub(_amount);\n', '        IERC20(address(uniswapPair)).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    function transferExceedingLiquidity() external {\n', '        require(exceedingLiquidity != 0);\n', '        IERC20(address(uniswapPair)).safeTransfer(feesController.feesTo(), exceedingLiquidity);\n', '        exceedingLiquidity = 0;\n', '    }\n', '}\n', '\n', 'abstract contract IMintableERC20 is IERC20 {\n', '    function mint(uint256 amount) public virtual;\n', '\n', '    function mintTo(address account, uint256 amount) public virtual;\n', '\n', '    function burn(uint256 amount) public virtual;\n', '\n', '    function setMinter(address account, bool isMinter) public virtual;\n', '}\n', '\n', 'abstract contract IPopMarketplace {\n', '    function submitMlp(\n', '        address _token0,\n', '        address _token1,\n', '        uint256 _liquidity,\n', '        uint256 _endDate,\n', '        uint256 _bonusToken0,\n', '        uint256 _bonusToken1\n', '    ) public virtual returns (uint256);\n', '\n', '    function endMlp(uint256 _mlpId) public virtual returns (uint256);\n', '\n', '    function cancelMlp(uint256 _mlpId) public virtual;\n', '}\n', '\n', 'contract PopMarketplace is IFeesController, IPopMarketplace, Initializable, OwnableUpgradeSafe {\n', '    using SafeERC20 for IERC20;\n', '    address public uniswapFactory;\n', '    address public uniswapRouter;\n', '    address[] public allMlp;\n', '    address private _feesTo = msg.sender;\n', '    uint256 private _feesPpm;\n', '    uint256 public pendingMlpCount;\n', '    IRewardManager public rewardManager;\n', '    IMintableERC20 public popToken;\n', '\n', '    mapping(uint256 => PendingMlp) public getMlp;\n', '\n', '    enum MlpStatus {PENDING, APPROVED, CANCELED, ENDED}\n', '\n', '    struct PendingMlp {\n', '        address uniswapPair;\n', '        address submitter;\n', '        uint256 liquidity;\n', '        uint256 endDate;\n', '        MlpStatus status;\n', '        uint256 bonusToken0;\n', '        uint256 bonusToken1;\n', '    }\n', '\n', '    event MlpCreated(uint256 id, address indexed mlp);\n', '    event MlpSubmitted(uint256 id);\n', '    event MlpCanceled(uint256 id);\n', '    event ChangeFeesPpm(uint256 id);\n', '    event ChangeFeesTo(address indexed feeTo);\n', '    event MlpEnded(uint256 id);\n', '\n', '    function initialize(\n', '        address _popToken,\n', '        address _uniswapFactory,\n', '        address _uniswapRouter,\n', '        address _rewardManager\n', '    ) public initializer {\n', '        OwnableUpgradeSafe.__Ownable_init();\n', '        popToken = IMintableERC20(_popToken);\n', '        uniswapFactory = _uniswapFactory;\n', '        uniswapRouter = _uniswapRouter;\n', '        rewardManager = IRewardManager(_rewardManager);\n', '    }\n', '\n', '    function submitMlp(\n', '        address _token0,\n', '        address _token1,\n', '        uint256 _liquidity,\n', '        uint256 _endDate,\n', '        uint256 _bonusToken0,\n', '        uint256 _bonusToken1\n', '    ) public override returns (uint256) {\n', '        require(_endDate > now, "!datenow");\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(uniswapFactory, _token0, _token1));\n', '        require(address(pair) != address(0), "!address0");\n', '\n', '        if (_liquidity > 0) {\n', '            IERC20(address(pair)).safeTransferFrom(msg.sender, address(this), _liquidity);\n', '        }\n', '        if (_bonusToken0 > 0) {\n', '            IERC20(_token0).safeTransferFrom(msg.sender, address(this), _bonusToken0);\n', '        }\n', '        if (_bonusToken1 > 0) {\n', '            IERC20(_token1).safeTransferFrom(msg.sender, address(this), _bonusToken1);\n', '        }\n', '\n', '        if (_token0 != pair.token0()) {\n', '            uint256 tmp = _bonusToken0;\n', '            _bonusToken0 = _bonusToken1;\n', '            _bonusToken1 = tmp;\n', '        }\n', '\n', '        getMlp[pendingMlpCount++] = PendingMlp({\n', '            uniswapPair: address(pair),\n', '            submitter: msg.sender,\n', '            liquidity: _liquidity,\n', '            endDate: _endDate,\n', '            status: MlpStatus.PENDING,\n', '            bonusToken0: _bonusToken0,\n', '            bonusToken1: _bonusToken1\n', '        });\n', '        uint256 mlpId = pendingMlpCount - 1;\n', '        emit MlpSubmitted(mlpId);\n', '        return mlpId;\n', '    }\n', '\n', '    function approveMlp(uint256 _mlpId, uint256 _allocPoint) external onlyOwner() returns (address mlpAddress) {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '        require(pendingMlp.status == MlpStatus.PENDING);\n', '\n', '        MLP newMlp =\n', '            new MLP(\n', '                pendingMlp.uniswapPair,\n', '                pendingMlp.submitter,\n', '                pendingMlp.endDate,\n', '                uniswapRouter,\n', '                address(this),\n', '                rewardManager,\n', '                pendingMlp.bonusToken0,\n', '                pendingMlp.bonusToken1\n', '            );\n', '        mlpAddress = address(newMlp);\n', '        rewardManager.add(_allocPoint, mlpAddress);\n', '        allMlp.push(mlpAddress);\n', '        IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token0()).safeTransfer(mlpAddress, pendingMlp.bonusToken0);\n', '        IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token1()).safeTransfer(mlpAddress, pendingMlp.bonusToken1);\n', '\n', '        pendingMlp.status = MlpStatus.APPROVED;\n', '        emit MlpCreated(_mlpId, mlpAddress);\n', '\n', '        return mlpAddress;\n', '    }\n', '\n', '    function cancelMlp(uint256 _mlpId) public override {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '\n', '        require(pendingMlp.submitter == msg.sender, "!submitter");\n', '        require(pendingMlp.status == MlpStatus.PENDING, "!pending");\n', '\n', '        if (pendingMlp.liquidity > 0) {\n', '            IUniswapV2Pair pair = IUniswapV2Pair(pendingMlp.uniswapPair);\n', '            IERC20(address(pair)).safeTransfer(pendingMlp.submitter, pendingMlp.liquidity);\n', '        }\n', '\n', '        if (pendingMlp.bonusToken0 > 0) {\n', '            IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token0()).safeTransfer(pendingMlp.submitter, pendingMlp.bonusToken0);\n', '        }\n', '        if (pendingMlp.bonusToken1 > 0) {\n', '            IERC20(IUniswapV2Pair(pendingMlp.uniswapPair).token1()).safeTransfer(pendingMlp.submitter, pendingMlp.bonusToken1);\n', '        }\n', '\n', '        pendingMlp.status = MlpStatus.CANCELED;\n', '        emit MlpCanceled(_mlpId);\n', '    }\n', '\n', '    function setFeesTo(address _newFeesTo) public override onlyOwner {\n', '        require(_newFeesTo != address(0), "!address0");\n', '        _feesTo = _newFeesTo;\n', '        emit ChangeFeesTo(_newFeesTo);\n', '    }\n', '\n', '    function feesTo() public override returns (address) {\n', '        return _feesTo;\n', '    }\n', '\n', '    function feesPpm() public override returns (uint256) {\n', '        return _feesPpm;\n', '    }\n', '\n', '    function setFeesPpm(uint256 _newFeesPpm) public override onlyOwner {\n', '        require(_newFeesPpm > 0, "!<0");\n', '        _feesPpm = _newFeesPpm;\n', '        emit ChangeFeesPpm(_newFeesPpm);\n', '    }\n', '\n', '    function endMlp(uint256 _mlpId) public override returns (uint256) {\n', '        PendingMlp storage pendingMlp = getMlp[_mlpId];\n', '\n', '        require(pendingMlp.submitter == msg.sender, "!submitter");\n', '        require(pendingMlp.status == MlpStatus.APPROVED, "!approved");\n', '        require(block.timestamp >= pendingMlp.endDate, "not yet ended");\n', '\n', '        if (pendingMlp.liquidity > 0) {\n', '            IUniswapV2Pair pair = IUniswapV2Pair(pendingMlp.uniswapPair);\n', '            IERC20(address(pair)).safeTransfer(pendingMlp.submitter, pendingMlp.liquidity);\n', '        }\n', '\n', '        pendingMlp.status = MlpStatus.ENDED;\n', '        emit MlpEnded(_mlpId);\n', '        return pendingMlp.liquidity;\n', '    }\n', '}']