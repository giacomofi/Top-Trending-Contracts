['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.5.17;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./ERC721Full.sol";\n', 'import "./IKlein.sol";\n', 'import "./ProxyRegistry.sol";\n', '\n', 'contract WrappedIKB is ERC721Full, Ownable {\n', '\n', '  // `baseURI` is an IPFS folder with a trailing slash\n', '  \n', '  string private _baseURI = "https://ipfs.io/ipfs/QmQ5yApMr1thk5gkFakFeJpSvKBPKbTAfkVG9FHpo2zuSY/";\n', '  string private constant _contractURI = "https://ipfs.io/ipfs/Qmf2pwtBCsnWaFrtKq1RG3fod4iH66vfeoQdJifmmLm9TN";\n', '\n', '  IKlein public Klein;\n', '\n', '  address public proxyRegistryAddress;\n', '\n', '  constructor(address _IKBAddress, address _proxyRegistryAddress)\n', '    ERC721Full("IKB Cachet de Garantie", "wIKB")\n', '    Ownable()\n', '    public\n', '  {\n', '    Klein = IKlein(_IKBAddress);\n', '    proxyRegistryAddress = _proxyRegistryAddress;\n', '\n', '  }\n', '\n', '  /**************************************************************************\n', '   * Opensea-specific methods\n', '   *************************************************************************/\n', '\n', '  function contractURI() external pure returns (string memory) {\n', '      return _contractURI;\n', '  }\n', '\n', '  /**\n', "   * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n", '   */\n', '  function isApprovedForAll(address owner, address operator)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    // Whitelist OpenSea proxy contract for easy trading.\n', '    ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n', '    if (address(proxyRegistry.proxies(owner)) == operator) {\n', '        return true;\n', '    }\n', '\n', '    return super.isApprovedForAll(owner, operator);\n', '  }\n', '\n', '  /**************************************************************************\n', '    * ERC721 methods\n', '    *************************************************************************/\n', '\n', '  /**\n', '  * @dev Returns the base URI set via {_setBaseURI}. This will be\n', "  * automatically added as a prefix in {tokenURI} to each token's URI, or\n", '  * to the token ID if no specific URI is set for that token ID.\n', '  */\n', '  function baseURI() public view returns (string memory) {\n', '      return _baseURI;\n', '  }\n', '\n', '\n', '  /**\n', '    * @dev `baseURI` is a folder with a trailing slash.\n', '    * The JSON metadata for `tokenId` can be found at `baseURI` + `tokenId` + .json\n', '  */\n', '  function tokenURI(uint256 tokenId) public view returns (string memory) {\n', '    require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', "    return string(abi.encodePacked(baseURI(), uint2str(tokenId), '.json'));\n", '  }\n', '\n', '\n', '  /**************************************************************************\n', '   * WrappedIKB-specific methods\n', '   *************************************************************************/\n', '\n', '  /**\n', '   * @dev Uses `transferFrom` to transer all IKB Tokens from `msg.sender` to\n', '   * this wrapper. Once the wrapper owns all editions, it mints new tokens with\n', '   * the same `id` and sets `msg.sender` as the owner.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - All IKB tokens owned by `msg.sender` must be allowed to be transfered by WrappedIKB.\n', '   *   To do this, call `approve()` with the address of WrappedIKB and the current\n', '   *   balance of the owner\n', '  */\n', '  function mint() public returns (bool){\n', '    uint256[] memory ownedRecords = Klein.getHolderEditions(_msgSender());\n', '    uint ownedRecordsLength = ownedRecords.length;\n', '\n', '    require(Klein.allowance(_msgSender(),address(this)) >= ownedRecordsLength, "WrappedIKB: must approve all IKB tokens to be transfered");\n', '\n', '    require(Klein.transferFrom(_msgSender(),address(this), ownedRecordsLength), "WrappedIKB: IKB Token did not transferFrom");\n', '\n', '    for (uint i = 0; i < ownedRecordsLength; i++){\n', '      _safeMint(_msgSender(), ownedRecords[i]);\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Uses `specificTransferFrom` to transer specific a IKB Token edition from\n', '   * `msg.sender` to this wrapper. Once the wrapper owns the specified edition,\n', '   *  it mints new tokens with\n', '   * the same `id` and sets `msg.sender` as the owner.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - None. There is no way to check if the IKB contract allows a specific transfer.\n', '   *   The transfer will fail on the IKB contract `specificApprove()` is not called\n', '   *   with the correct edition.\n', '  */\n', '  function mint(uint edition) public {\n', '    require(Klein.specificTransferFrom(_msgSender(), address(this), edition), "WrappedIKB: IKB Token did not specificTransferFrom");\n', '    _safeMint(_msgSender(), edition);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the specified IKB token editions back to `msg.sender`\n', '   * and burns the corresponding WrappedIKB tokens\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `msg.sender` must be the owner of the WrappedIKB tokens\n', '  */\n', '  function unwrapSpecific(uint tokenId) public{\n', '    require(ownerOf(tokenId) == _msgSender(), "WrappedIKB: Token not owned by sender");\n', '    require(Klein.specificTransfer(_msgSender(), tokenId), "WrappedIKB: Token transfer failed");\n', '    _burn(tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Convenience function transfers all IKB token editions back to\n', '   * `msg.sender` and burns the corresponding WrappedIKB tokens.\n', '   * See `unwrapSpecific()` for implementation.\n', '  */\n', '  function unwrapAll() public{\n', '    uint256 balance = balanceOf(_msgSender());\n', '\n', '    uint[] memory tokenIds = new uint[](balance);\n', '\n', '    for (uint256 i = 0; i < balance; i++){\n', '      tokenIds[i] = (tokenOfOwnerByIndex(_msgSender(), i));\n', '    }\n', '    for (uint256 i = 0; i < balance; i++){\n', '      unwrapSpecific(tokenIds[i]);\n', '    }\n', '  }\n', '\n', '  /**************************************************************************\n', '   * Utility methods\n', '   *************************************************************************/\n', '\n', '  // via https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/Strings.sol\n', '  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '      if (_i == 0) {\n', '          return "0";\n', '      }\n', '      uint j = _i;\n', '      uint len;\n', '      while (j != 0) {\n', '          len++;\n', '          j /= 10;\n', '      }\n', '      bytes memory bstr = new bytes(len);\n', '      uint k = len - 1;\n', '      while (_i != 0) {\n', '          bstr[k--] = byte(uint8(48 + _i % 10));\n', '          _i /= 10;\n', '      }\n', '      return string(bstr);\n', '  }\n', '\n', '}']