['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '/// LiquidationEngine.sol\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'abstract contract CollateralAuctionHouseLike {\n', '    function startAuction(\n', '      address forgoneCollateralReceiver,\n', '      address initialBidder,\n', '      uint256 amountToRaise,\n', '      uint256 collateralToSell,\n', '      uint256 initialBid\n', '    ) virtual public returns (uint256);\n', '}\n', 'abstract contract SAFESaviourLike {\n', '    function saveSAFE(address,bytes32,address) virtual external returns (bool,uint256,uint256);\n', '}\n', 'abstract contract SAFEEngineLike {\n', '    function collateralTypes(bytes32) virtual public view returns (\n', '        uint256 debtAmount,        // [wad]\n', '        uint256 accumulatedRate,   // [ray]\n', '        uint256 safetyPrice,       // [ray]\n', '        uint256 debtCeiling,       // [rad]\n', '        uint256 debtFloor,         // [rad]\n', '        uint256 liquidationPrice   // [ray]\n', '    );\n', '    function safes(bytes32,address) virtual public view returns (\n', '        uint256 lockedCollateral,  // [wad]\n', '        uint256 generatedDebt      // [wad]\n', '    );\n', '    function confiscateSAFECollateralAndDebt(bytes32,address,address,address,int256,int256) virtual external;\n', '    function canModifySAFE(address, address) virtual public view returns (bool);\n', '    function approveSAFEModification(address) virtual external;\n', '    function denySAFEModification(address) virtual external;\n', '}\n', 'abstract contract AccountingEngineLike {\n', '    function pushDebtToQueue(uint256) virtual external;\n', '}\n', '\n', 'contract LiquidationEngine {\n', '    // --- Auth ---\n', '    mapping (address => uint256) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "LiquidationEngine/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- SAFE Saviours ---\n', '    // Contracts that can save SAFEs from liquidation\n', '    mapping (address => uint256) public safeSaviours;\n', '    /**\n', '    * @notice Authed function to add contracts that can save SAFEs from liquidation\n', '    * @param saviour SAFE saviour contract to be whitelisted\n', '    **/\n', '    function connectSAFESaviour(address saviour) external isAuthorized {\n', '        (bool ok, uint256 collateralAdded, uint256 liquidatorReward) =\n', '          SAFESaviourLike(saviour).saveSAFE(address(this), "", address(0));\n', '        require(ok, "LiquidationEngine/saviour-not-ok");\n', '        require(both(collateralAdded == uint256(-1), liquidatorReward == uint256(-1)), "LiquidationEngine/invalid-amounts");\n', '        safeSaviours[saviour] = 1;\n', '        emit ConnectSAFESaviour(saviour);\n', '    }\n', '    /**\n', '    * @notice Governance used function to remove contracts that can save SAFEs from liquidation\n', '    * @param saviour SAFE saviour contract to be removed\n', '    **/\n', '    function disconnectSAFESaviour(address saviour) external isAuthorized {\n', '        safeSaviours[saviour] = 0;\n', '        emit DisconnectSAFESaviour(saviour);\n', '    }\n', '\n', '    // --- Data ---\n', '    struct CollateralType {\n', '        // Address of the collateral auction house handling liquidations for this collateral type\n', '        address collateralAuctionHouse;\n', '        // Penalty applied to every liquidation involving this collateral type. Discourages SAFE users from bidding on their own SAFEs\n', '        uint256 liquidationPenalty;                                                                                                   // [wad]\n', '        // Max amount of system coins to request in one auction\n', '        uint256 liquidationQuantity;                                                                                                  // [rad]\n', '    }\n', '\n', '    // Collateral types included in the system\n', '    mapping (bytes32 => CollateralType)              public collateralTypes;\n', '    // Saviour contract chosen for each SAFE by its creator\n', '    mapping (bytes32 => mapping(address => address)) public chosenSAFESaviour;\n', "    // Mutex used to block against re-entrancy when 'liquidateSAFE' passes execution to a saviour\n", '    mapping (bytes32 => mapping(address => uint8))   public mutex;\n', '\n', '    // Max amount of system coins that can be on liquidation at any time\n', '    uint256 public onAuctionSystemCoinLimit;                                // [rad]\n', '    // Current amount of system coins out for liquidation\n', '    uint256 public currentOnAuctionSystemCoins;                             // [rad]\n', '    // Whether this contract is enabled\n', '    uint256 public contractEnabled;\n', '\n', '    SAFEEngineLike       public safeEngine;\n', '    AccountingEngineLike public accountingEngine;\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ConnectSAFESaviour(address saviour);\n', '    event DisconnectSAFESaviour(address saviour);\n', '    event UpdateCurrentOnAuctionSystemCoins(uint256 currentOnAuctionSystemCoins);\n', '    event ModifyParameters(bytes32 parameter, uint256 data);\n', '    event ModifyParameters(bytes32 parameter, address data);\n', '    event ModifyParameters(\n', '      bytes32 collateralType,\n', '      bytes32 parameter,\n', '      uint256 data\n', '    );\n', '    event ModifyParameters(\n', '      bytes32 collateralType,\n', '      bytes32 parameter,\n', '      address data\n', '    );\n', '    event DisableContract();\n', '    event Liquidate(\n', '      bytes32 indexed collateralType,\n', '      address indexed safe,\n', '      uint256 collateralAmount,\n', '      uint256 debtAmount,\n', '      uint256 amountToRaise,\n', '      address collateralAuctioneer,\n', '      uint256 auctionId\n', '    );\n', '    event SaveSAFE(\n', '      bytes32 indexed collateralType,\n', '      address indexed safe,\n', '      uint256 collateralAddedOrDebtRepaid\n', '    );\n', '    event FailedSAFESave(bytes failReason);\n', '    event ProtectSAFE(\n', '      bytes32 indexed collateralType,\n', '      address indexed safe,\n', '      address saviour\n', '    );\n', '\n', '    // --- Init ---\n', '    constructor(address safeEngine_) public {\n', '        authorizedAccounts[msg.sender] = 1;\n', '        safeEngine = SAFEEngineLike(safeEngine_);\n', '        onAuctionSystemCoinLimit = uint256(-1);\n', '        contractEnabled = 1;\n', '        emit AddAuthorization(msg.sender);\n', '        emit ModifyParameters("onAuctionSystemCoinLimit", uint256(-1));\n', '    }\n', '\n', '    // --- Math ---\n', '    uint256 constant WAD = 10 ** 18;\n', '    uint256 constant RAY = 10 ** 27;\n', '    uint256 constant MAX_LIQUIDATION_QUANTITY = uint256(-1) / RAY;\n', '\n', '    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "LiquidationEngine/add-overflow");\n', '    }\n', '    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "LiquidationEngine/sub-underflow");\n', '    }\n', '    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "LiquidationEngine/mul-overflow");\n', '    }\n', '    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        if (x > y) { z = y; } else { z = x; }\n', '    }\n', '\n', '    // --- Utils ---\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '\n', '    // --- Administration ---\n', '    /*\n', '    * @notice Modify uint256 parameters\n', '    * @param paramter The name of the parameter modified\n', '    * @param data Value for the new parameter\n', '    */\n', '    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n', '        if (parameter == "onAuctionSystemCoinLimit") onAuctionSystemCoinLimit = data;\n', '        else revert("LiquidationEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    /**\n', '     * @notice Modify contract integrations\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New address for the parameter\n', '     */\n', '    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n', '        if (parameter == "accountingEngine") accountingEngine = AccountingEngineLike(data);\n', '        else revert("LiquidationEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    /**\n', '     * @notice Modify liquidation params\n', '     * @param collateralType The collateral type we change parameters for\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(\n', '        bytes32 collateralType,\n', '        bytes32 parameter,\n', '        uint256 data\n', '    ) external isAuthorized {\n', '        if (parameter == "liquidationPenalty") collateralTypes[collateralType].liquidationPenalty = data;\n', '        else if (parameter == "liquidationQuantity") {\n', '          require(data <= MAX_LIQUIDATION_QUANTITY, "LiquidationEngine/liquidation-quantity-overflow");\n', '          collateralTypes[collateralType].liquidationQuantity = data;\n', '        }\n', '        else revert("LiquidationEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(\n', '          collateralType,\n', '          parameter,\n', '          data\n', '        );\n', '    }\n', '    /**\n', '     * @notice Modify collateral auction integration\n', '     * @param collateralType The collateral type we change parameters for\n', '     * @param parameter The name of the integration modified\n', '     * @param data New address for the integration contract\n', '     */\n', '    function modifyParameters(\n', '        bytes32 collateralType,\n', '        bytes32 parameter,\n', '        address data\n', '    ) external isAuthorized {\n', '        if (parameter == "collateralAuctionHouse") {\n', '            safeEngine.denySAFEModification(collateralTypes[collateralType].collateralAuctionHouse);\n', '            collateralTypes[collateralType].collateralAuctionHouse = data;\n', '            safeEngine.approveSAFEModification(data);\n', '        }\n', '        else revert("LiquidationEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(\n', '            collateralType,\n', '            parameter,\n', '            data\n', '        );\n', '    }\n', '    /**\n', '     * @notice Disable this contract (normally called by GlobalSettlement)\n', '     */\n', '    function disableContract() external isAuthorized {\n', '        contractEnabled = 0;\n', '        emit DisableContract();\n', '    }\n', '\n', '    // --- SAFE Liquidation ---\n', '    /**\n', '     * @notice Choose a saviour contract for your SAFE\n', "     * @param collateralType The SAFE's collateral type\n", "     * @param safe The SAFE's address\n", '     * @param saviour The chosen saviour\n', '     */\n', '    function protectSAFE(\n', '        bytes32 collateralType,\n', '        address safe,\n', '        address saviour\n', '    ) external {\n', '        require(safeEngine.canModifySAFE(safe, msg.sender), "LiquidationEngine/cannot-modify-safe");\n', '        require(saviour == address(0) || safeSaviours[saviour] == 1, "LiquidationEngine/saviour-not-authorized");\n', '        chosenSAFESaviour[collateralType][safe] = saviour;\n', '        emit ProtectSAFE(\n', '            collateralType,\n', '            safe,\n', '            saviour\n', '        );\n', '    }\n', '    /**\n', '     * @notice Liquidate a SAFE\n', "     * @param collateralType The SAFE's collateral type\n", "     * @param safe The SAFE's address\n", '     */\n', '    function liquidateSAFE(bytes32 collateralType, address safe) external returns (uint256 auctionId) {\n', '        require(mutex[collateralType][safe] == 0, "LiquidationEngine/non-null-mutex");\n', '        mutex[collateralType][safe] = 1;\n', '\n', '        (, uint256 accumulatedRate, , , uint256 debtFloor, uint256 liquidationPrice) = safeEngine.collateralTypes(collateralType);\n', '        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, safe);\n', '\n', '        require(contractEnabled == 1, "LiquidationEngine/contract-not-enabled");\n', '        require(both(\n', '          liquidationPrice > 0,\n', '          multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate)\n', '        ), "LiquidationEngine/safe-not-unsafe");\n', '        require(\n', '          both(currentOnAuctionSystemCoins < onAuctionSystemCoinLimit,\n', '          subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins) >= debtFloor),\n', '          "LiquidationEngine/liquidation-limit-hit"\n', '        );\n', '\n', '        if (chosenSAFESaviour[collateralType][safe] != address(0) &&\n', '            safeSaviours[chosenSAFESaviour[collateralType][safe]] == 1) {\n', '          try SAFESaviourLike(chosenSAFESaviour[collateralType][safe]).saveSAFE(msg.sender, collateralType, safe)\n', '            returns (bool ok, uint256 collateralAddedOrDebtRepaid, uint256) {\n', '            if (both(ok, collateralAddedOrDebtRepaid > 0)) {\n', '              emit SaveSAFE(collateralType, safe, collateralAddedOrDebtRepaid);\n', '            }\n', '          } catch (bytes memory revertReason) {\n', '            emit FailedSAFESave(revertReason);\n', '          }\n', '        }\n', '\n', "        // Checks that the saviour didn't take collateral or add more debt to the SAFE\n", '        {\n', '          (uint256 newSafeCollateral, uint256 newSafeDebt) = safeEngine.safes(collateralType, safe);\n', '          require(both(newSafeCollateral >= safeCollateral, newSafeDebt <= safeDebt), "LiquidationEngine/invalid-safe-saviour-operation");\n', '        }\n', '\n', '        (, accumulatedRate, , , , liquidationPrice) = safeEngine.collateralTypes(collateralType);\n', '        (safeCollateral, safeDebt) = safeEngine.safes(collateralType, safe);\n', '\n', '        if (both(liquidationPrice > 0, multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate))) {\n', '          CollateralType memory collateralData = collateralTypes[collateralType];\n', '\n', '          uint256 limitAdjustedDebt = minimum(\n', '            safeDebt,\n', '            multiply(minimum(collateralData.liquidationQuantity, subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins)), WAD) / accumulatedRate / collateralData.liquidationPenalty\n', '          );\n', '          require(limitAdjustedDebt > 0, "LiquidationEngine/null-auction");\n', '          require(either(limitAdjustedDebt == safeDebt, multiply(subtract(safeDebt, limitAdjustedDebt), accumulatedRate) >= debtFloor), "LiquidationEngine/dusty-safe");\n', '\n', '          uint256 collateralToSell = minimum(safeCollateral, multiply(safeCollateral, limitAdjustedDebt) / safeDebt);\n', '\n', '          require(collateralToSell > 0, "LiquidationEngine/null-collateral-to-sell");\n', '          require(both(collateralToSell <= 2**255, limitAdjustedDebt <= 2**255), "LiquidationEngine/collateral-or-debt-overflow");\n', '\n', '          safeEngine.confiscateSAFECollateralAndDebt(\n', '            collateralType, safe, address(this), address(accountingEngine), -int256(collateralToSell), -int256(limitAdjustedDebt)\n', '          );\n', '          accountingEngine.pushDebtToQueue(multiply(limitAdjustedDebt, accumulatedRate));\n', '\n', '          {\n', '            // This calcuation will overflow if multiply(limitAdjustedDebt, accumulatedRate) exceeds ~10^14,\n', '            // i.e. the maximum amountToRaise is roughly 100 trillion system coins.\n', '            uint256 amountToRaise_      = multiply(multiply(limitAdjustedDebt, accumulatedRate), collateralData.liquidationPenalty) / WAD;\n', '            currentOnAuctionSystemCoins = addition(currentOnAuctionSystemCoins, amountToRaise_);\n', '\n', '            auctionId = CollateralAuctionHouseLike(collateralData.collateralAuctionHouse).startAuction(\n', '              { forgoneCollateralReceiver: safe\n', '              , initialBidder: address(accountingEngine)\n', '              , amountToRaise: amountToRaise_\n', '              , collateralToSell: collateralToSell\n', '              , initialBid: 0\n', '             });\n', '\n', '             emit UpdateCurrentOnAuctionSystemCoins(currentOnAuctionSystemCoins);\n', '          }\n', '\n', '          emit Liquidate(collateralType, safe, collateralToSell, limitAdjustedDebt, multiply(limitAdjustedDebt, accumulatedRate), collateralData.collateralAuctionHouse, auctionId);\n', '        }\n', '\n', '        mutex[collateralType][safe] = 0;\n', '    }\n', '    /**\n', '     * @notice Remove debt that was currently being auctioned\n', '     * @param rad The amount of debt to withdraw from currentOnAuctionSystemCoins\n', '     */\n', '    function removeCoinsFromAuction(uint256 rad) public isAuthorized {\n', '        currentOnAuctionSystemCoins = subtract(currentOnAuctionSystemCoins, rad);\n', '        emit UpdateCurrentOnAuctionSystemCoins(currentOnAuctionSystemCoins);\n', '    }\n', '\n', '    // --- Getters ---\n', '    /*\n', '    * @notice Get the amount of debt that can currently be covered by a collateral auction for a specific safe\n', '    * @param collateralType The collateral type of the SAFE\n', "    * @param safe The SAFE's address\n", '    */\n', '    function getLimitAdjustedDebtToCover(bytes32 collateralType, address safe) external view returns (uint256) {\n', '        (, uint256 accumulatedRate,,,,)            = safeEngine.collateralTypes(collateralType);\n', '        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, safe);\n', '        CollateralType memory collateralData       = collateralTypes[collateralType];\n', '\n', '        return minimum(\n', '          safeDebt,\n', '          multiply(minimum(collateralData.liquidationQuantity, subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins)), WAD) / accumulatedRate / collateralData.liquidationPenalty\n', '        );\n', '    }\n', '}']