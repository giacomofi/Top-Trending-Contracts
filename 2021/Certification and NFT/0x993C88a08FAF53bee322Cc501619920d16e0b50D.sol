['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "IIdeaTokenVault.sol";\n', 'import "IIdeaTokenFactory.sol";\n', 'import "Ownable.sol";\n', 'import "Initializable.sol";\n', 'import "SafeMath.sol";\n', 'import "IERC20.sol";\n', '\n', '/**\n', ' * @title IdeaTokenVault\n', ' * @author Alexander Schlindwein\n', ' *\n', ' * Locks IdeaTokens for a given duration\n', ' * Sits behind an AdminUpgradabilityProxy\n', ' *\n', ' * This contract uses a doubly linked list to keep track of locked tokens and allow for iteration.\n', ' * For each (IdeaToken, owner) combination a linked list is stored where new entries to the list are inserted at the head:\n', ' * \n', ' * |-----------| --- next ---> |-----------|\n', ' * |  LLEntry  |\t\t\t   |  LLEntry  |  ---- > \n', ' * |-----------| <--- prev --- |-----------|\n', ' *       |\n', ' *       |\n', ' *       |\n', ' * _llHead[IdeaToken][owner]\n', ' *\n', " * Each LLEntry has an 'until' field which is the timestamp when the tokens in this entry will be unlocked.\n", " * A (IdeaToken, owner, until) combination uniquely identifies a LLEntry. Thus the 'until' also often serves as an ID.\n", ' *\n', ' * Since (IdeaToken, owner, until) is unique, the storage location of each LLEntry is calculated as keccak256(abi.encode(ideaToken, owner, until)).\n', ' *\n', ' */\n', 'contract IdeaTokenVault is IIdeaTokenVault, Initializable {\n', '    using SafeMath for uint256;\n', '\n', '    // LinkedList Entry\n', '    struct LLEntry {\n', '        // Timestamp when unlocked. Also serves as ID\n', '        uint until;\n', '        // Amount of locked tokens\n', '        uint amount;\n', '        // Previous LLEntry\n', '        bytes32 prev;\n', '        // Next LLEntry\n', '        bytes32 next;\n', '    }\n', '\n', '    IIdeaTokenFactory _ideaTokenFactory;\n', '\n', '    // IdeaToken address => owner address => storage location\n', '    mapping(address => mapping(address => bytes32)) public _llHead;\n', '\n', '    event Locked(address ideaToken, address owner, uint lockedAmount, uint lockedUntil, uint lockedDuration);\n', '\n', '    /**\n', '     * Initializes the contract\n', '     *\n', '     * @param ideaTokenFactory The address of the IdeaTokenFactory contract\n', '     */\n', '    function initialize(address ideaTokenFactory) external initializer {\n', '        require(ideaTokenFactory != address(0), "invalid-params");\n', '        _ideaTokenFactory = IIdeaTokenFactory(ideaTokenFactory);\n', '    }\n', '\n', '    /**\n', '     * Locks IdeaTokens for a given duration.\n', '     * Allowed durations are set by the owner.\n', '     *\n', '     * @param ideaToken The IdeaToken to be locked\n', '     * @param amount The amount of IdeaTokens to lock\n', '     * @param duration The duration in seconds to lock the tokens\n', '     * @param recipient The account which receives the locked tokens \n', '     */\n', '    function lock(address ideaToken, uint amount, uint duration, address recipient) external override {\n', '        require(duration > 0, "invalid-duration");\n', '        require(_ideaTokenFactory.getTokenIDPair(ideaToken).exists, "invalid-token");\n', '        require(amount > 0, "invalid-amount");\n', '        require(IERC20(ideaToken).allowance(msg.sender, address(this)) >= amount, "insufficient-allowance");\n', '        require(IERC20(ideaToken).transferFrom(msg.sender, address(this), amount), "transfer-failed");\n', '\n', '        uint lockedUntil = duration.add(now);\n', '        bytes32 location = getLLEntryStorageLocation(ideaToken, recipient, lockedUntil);\n', '\n', '        LLEntry storage entry = getLLEntry(location);\n', '        entry.amount = entry.amount.add(amount);\n', '\n', '        // If an entry with this `until` does not already exist,\n', '        // create a new one and add it the LL\n', '        if(entry.until == 0) {\n', '            entry.until = lockedUntil;\n', '            entry.prev = bytes32(0);\n', '            entry.next = _llHead[ideaToken][recipient];\n', '\n', '            bytes32 currentHeadID = _llHead[ideaToken][recipient];\n', '            if(currentHeadID != bytes32(0)) {\n', '                // Set `prev` of the old head to the new entry\n', '                LLEntry storage head = getLLEntry(currentHeadID);\n', '                head.prev = location;\n', '            } \n', '\n', '            _llHead[ideaToken][recipient] = location;\n', '        }\n', '\n', '        emit Locked(ideaToken, recipient, amount, lockedUntil, duration);\n', '    }\n', '\n', '    /**\n', '     * Withdraws a given list of locked tokens\n', '     *\n', '     * @param ideaToken The IdeaToken to withdraw\n', '     * @param untils List of timestamps until which tokens are locked\n', '     * @param recipient The account which will receive the IdeaTokens\n', '     */\n', '    function withdraw(address ideaToken, uint[] calldata untils, address recipient) external override {\n', '\n', '        uint ts = now;\n', '        uint total = 0;\n', '\n', '        for(uint i = 0; i < untils.length; i++) {\n', '            uint until = untils[i];\n', '            require(ts > until, "too-early");\n', '\n', '            bytes32 location = getLLEntryStorageLocation(ideaToken, msg.sender, until);\n', '            LLEntry storage entry = getLLEntry(location);\n', '\n', '            require(entry.until > 0, "invalid-until");\n', '            total = total.add(entry.amount);\n', '\n', '            if(entry.next != bytes32(0)) {\n', '                // Set `prev` of the next entry\n', '                LLEntry storage next = getLLEntry(entry.next);\n', '                next.prev = entry.prev;\n', '            }\n', '\n', '            if(entry.prev != bytes32(0)) {\n', '                // Set `next` of the prev entry\n', '                LLEntry storage prev = getLLEntry(entry.prev);\n', '                prev.next = entry.next;\n', '            } else {\n', '                // This was the first entry in the LL\n', '                // Update the head to the next entry\n', '                // If this was also the only entry in the list\n', '                // head will be set to 0\n', '                _llHead[ideaToken][msg.sender] = entry.next;\n', '            }\n', '\n', '            // Reset storage to 0, gas savings\n', '            clearEntry(entry);\n', '        }\n', '\n', '        if(total > 0) {\n', '            require(IERC20(ideaToken).transfer(recipient, total), "transfer-failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns all locked entries up to `maxEntries` for `user`\n', '     *\n', '     * @param ideaToken The IdeaToken for which to return the locked entries\n', '     * @param user The user for which to return the locked entries\n', '     * @param maxEntries The maximum amount of entries to return\n', '     *\n', '     * @return All locked entries up to `maxEntries` for `user`\n', '     */\n', '    function getLockedEntries(address ideaToken, address user, uint maxEntries) external view override returns (LockedEntry[] memory) {\n', '        // Calculate the required size of the returned array\n', '        bytes32 next = _llHead[ideaToken][user];\n', '        uint len = 0;\n', '        while(next != bytes32(0) && len < maxEntries) {\n', '            len += 1;\n', '            LLEntry storage entry = getLLEntry(next);\n', '            next = entry.next;\n', '        }\n', '\n', '        if(len == 0) {\n', '            LockedEntry[] memory empty;\n', '            return empty;\n', '        }\n', '\n', '        LockedEntry[] memory ret = new LockedEntry[](len);\n', '\n', '        uint index = 0;\n', '        next = _llHead[ideaToken][user];\n', '        while(next != bytes32(0)) {\n', '            LLEntry storage entry = getLLEntry(next);\n', '            \n', '            ret[index] = LockedEntry({lockedUntil: entry.until, lockedAmount: entry.amount});\n', '\n', '            index++;\n', '            next = entry.next;\n', '        }\n', '\n', '        return ret;\n', '    }\n', '\n', '    function clearEntry(LLEntry storage entry) internal {\n', '        entry.until = 0;\n', '        entry.amount = 0;\n', '        entry.prev = bytes32(0);\n', '        entry.next = bytes32(0);\n', '    }\n', '\n', '    function getLLEntryStorageLocation(address ideaToken, address owner, uint until) internal pure returns (bytes32) {\n', '        return keccak256(abi.encode(ideaToken, owner, until));\n', '    }\n', '\n', '    function getLLEntry(bytes32 location) internal pure returns (LLEntry storage) {\n', '        LLEntry storage entry;\n', '        assembly { entry_slot := location }\n', '        return entry;\n', '    } \n', '}']