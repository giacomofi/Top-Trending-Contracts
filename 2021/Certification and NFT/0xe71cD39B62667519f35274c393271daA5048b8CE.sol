['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./ERC721Enumerable.sol";\n', 'import "./IERC721Receiver.sol";\n', 'import "./IERC721.sol";\n', 'import "./ReentrancyGuard.sol";\n', '\n', '// previous contract\n', 'contract PreviousContract {\n', '    //function setApprovalForAll(address, uint256) public {}\n', '    function balanceOf(address) public returns (uint256) {}\n', '    function tokenOfOwnerByIndex(address, uint256) public returns (uint256) {}\n', '    function safeTransferFrom(address, address, uint256, bytes memory) public {}\n', '}\n', '\n', 'contract HSeedsRecurve is ERC721Enumerable, IERC721Receiver, Ownable, ReentrancyGuard {\n', '    // Previous contract we deployed. Respnsible for first sales.\n', '    PreviousContract private PREVIOUS_CONTRACT;\n', '\n', '    // The address of the previous contract.\n', '    string public constant PREVIOUS_CONTRACT_ADDR = "0xDc31e48b66A1364BFea922bfc2972AB5C286F9fe";\n', '    \n', '    // last token sold on previous contract.\n', '    uint256 public constant FINAL_TOKEN_ID = 1724;\n', '    \n', '    // indicies coverred by the first level [0-1499]\n', '    uint256 public constant LAST_TOKEN_ID_FIRST_LEVEL = 1499;\n', '\n', '    // indicies reserved from first sale. Do not resell these indicies [0-1949].\n', '    uint256 public constant RESERVED_TOKEN_ID = FINAL_TOKEN_ID + (FINAL_TOKEN_ID - LAST_TOKEN_ID_FIRST_LEVEL);\n', '    \n', '    // number of tokens we owe to those that bought in 0.6 range, our "airdrops".\n', '    uint256 private AIRDROPS_CLAIMED = FINAL_TOKEN_ID - LAST_TOKEN_ID_FIRST_LEVEL;\n', '\n', '    // track the total number of tokens claimed (included airdrops).\n', '    uint256 public TOTAL_CLAIMED = 0;\n', '    \n', '    // This is the provenance record of all artwork in existence\n', '    string public constant ENTROPYSEEDS_PROVENANCE = "51aab9a30a64f0b1f8325ccfa7e80cbcc20b9dbab4b4e6765c3e5178e507d210";\n', '\n', '    // opens Mar 11 2021 15:00:00 GMT+0000\n', '    uint256 public constant SALE_START_TIMESTAMP = 1615474800;\n', '\n', '    // Time after which we randomly assign and allotted (s*m*h*d)\n', '    // sale lasts for 21 days\n', '    uint256 public constant REVEAL_TIMESTAMP = SALE_START_TIMESTAMP + (60*60*24*21);\n', '\n', '    uint256 public constant MAX_NFT_SUPPLY = 8275;\n', '\n', '    uint256 public startingIndexBlock;\n', '\n', '    uint256 public startingIndex;\n', '\n', '    bool private halt_mint = false;\n', '    bool private halt_claim = false;\n', '\n', '    // Mapping from token ID to whether the Entropyseed was minted before reveal\n', '    mapping (uint256 => bool) private _mintedBeforeReveal;\n', '\n', '    /*================================================================================\n', '    //================================================================================\n', '    //================================================================================\n', '    //===============================================================================*/\n', '    \n', '    constructor(address previous) public ERC721("EntropySeeds", "HSEED") {\n', '        PREVIOUS_CONTRACT = PreviousContract(previous);\n', '    }\n', '    \n', '    /**\n', '     * @dev - we use this to compute the mintIndex. We reserve the token up to FINAL_TOKEN for\n', '     * buyers on the previous contract.\n', '     **/\n', '    function totalSupply() public view override returns (uint256) {\n', '        uint256 supply = super.totalSupply();\n', '        uint256 remaining_claims = (RESERVED_TOKEN_ID + 1) - TOTAL_CLAIMED;\n', '        return supply + remaining_claims; // so we mint after\n', '    }\n', '\n', '    /**\n', '    * @dev - Only accept if the tokenId is below the final one\n', '    * and it comes from the last contract.\n', '    **/\n', '    function onERC721Received(address, address, uint256 tokenId, bytes calldata) public override returns (bytes4) {\n', '            require(msg.sender == address(PREVIOUS_CONTRACT), "Request must come from previous contract address");\n', '            require(tokenId <= FINAL_TOKEN_ID, "We are not accepting tokens past the cutoff");\n', '            return IERC721Receiver.onERC721Received.selector;\n', '    }\n', '    \n', '    function claimMyTokens(uint256 numberOfNfts) public nonReentrant {\n', '        require(halt_claim == false, "Claims have been halted");\n', '        require(numberOfNfts <= 10, "Max of 10 at a time");\n', '        require(numberOfNfts > 0, "Need to claim something");\n', '\n', '        require(TOTAL_CLAIMED <= (RESERVED_TOKEN_ID+1), "All claims have been filled."); \n', '        require((TOTAL_CLAIMED + numberOfNfts) <= (RESERVED_TOKEN_ID+1), "Claimed exceeds reserved.");\n', '        \n', '        uint256 balance = PREVIOUS_CONTRACT.balanceOf(msg.sender);\n', '        require(balance > 0, "You own no tokens");\n', '        require(numberOfNfts <= balance, "Claiming too many tokens");\n', '\n', '        for (uint i = 0; i < numberOfNfts; ) {\n', '            // has to be 0 because as we transfer the tokens the next one becomes 0.\n', '            // need this info to understand how we handle the token (where it sold before).\n', '            uint256 tokenId = PREVIOUS_CONTRACT.tokenOfOwnerByIndex(msg.sender, 0); \n', '\n', '            // It *might* be out of order and they can still buy from the previous contract\n', '            // [0,1724] INCLUSIVE.\n', '            // Should be handled by the onERC721Received but should be fine doing it this way\n', '            if (tokenId > FINAL_TOKEN_ID) {\n', '                unchecked{i++;}\n', '                continue;\n', '            }\n', '            \n', '            // mint a new one under this smart contact\n', '            unchecked{TOTAL_CLAIMED = TOTAL_CLAIMED + 1;} // @dev save gas \n', '            if (block.timestamp < REVEAL_TIMESTAMP) {\n', '                _mintedBeforeReveal[tokenId] = true;\n', '            }\n', '            _safeMint(msg.sender, tokenId);\n', '\n', '            // if they bought after the 0.2 level, at 0.6, we want to airdrop them\n', '            // another token since this price level is now 0.3.\n', '            if (tokenId > LAST_TOKEN_ID_FIRST_LEVEL) {\n', '                // because we want to preserve the order for previous holders\n', '                // we mint after the FINAL_TOKEN.\n', '                uint256 mintIndex = FINAL_TOKEN_ID + AIRDROPS_CLAIMED;\n', '                unchecked{TOTAL_CLAIMED = TOTAL_CLAIMED + 1;} // @dev save gas\n', '                if (block.timestamp < REVEAL_TIMESTAMP) {\n', '                    _mintedBeforeReveal[mintIndex] = true;\n', '                }\n', '                AIRDROPS_CLAIMED = AIRDROPS_CLAIMED - 1;\n', '                require(AIRDROPS_CLAIMED >= 0, "Oversold.");\n', '\n', '                _safeMint(msg.sender, mintIndex);\n', '            }\n', '\n', '            // Here we are "burning" the old tokens. They will stay in this contract forever.\n', '            // stops ppl from using the old ones after.\n', '            PREVIOUS_CONTRACT.safeTransferFrom(msg.sender, address(this), tokenId, "");\n', '\n', '            unchecked{i++;} // @dev save gas\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if the NFT has been minted before reveal phase\n', '     */\n', '    function isMintedBeforeReveal(uint256 index) public view returns (bool) {\n', '        return _mintedBeforeReveal[index];\n', '    }\n', '    \n', '    /**\n', '     * @dev Gets current price level\n', '     */\n', '    function getNFTPrice() public view returns (uint256) {\n', '        require(block.timestamp >= SALE_START_TIMESTAMP, "Sale has not started");\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '\n', '        uint256 currentSupply = totalSupply();\n', '        if (currentSupply >= 8270) {\n', '            return 5000000000000000000; // 8270 - 8275 5 ETH\n', '        } else if (currentSupply >= 8250) {\n', '            return 3000000000000000000; // 8250 - 8269 3 ETH\n', '        } else if (currentSupply >= 8200) {\n', '            return 1000000000000000000; // 8200  - 8249  1 ETH\n', '        } else if (currentSupply >= 7000) {\n', '            return 500000000000000000; // 7000 - 8199 0.5 ETH\n', '        } else if (currentSupply >= 4500) {\n', '            return 400000000000000000; // 4500 - 6999 0.4 ETH\n', '        } else if (currentSupply >= 1500) {\n', '            return 300000000000000000; // 1500 - 4499 0.3 ETH\n', '        } else {\n', '            return 200000000000000000; // 0 - 1499 0.2 ETH \n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Mints numberOfNfts Entropyseeds\n', '    * Price slippage is okay between levels. Known "bug".\n', '    * Minting starts above RESERVED_TOKEN_ID \n', '    */\n', '    function mintNFT(uint256 numberOfNfts) public payable nonReentrant {\n', '        require(halt_mint == false, "Minting has been halted.");\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '        require(numberOfNfts > 0, "numberOfNfts cannot be 0");\n', '        require(numberOfNfts <= 10, "You may not buy more than 10 NFTs at once");\n', '        require((totalSupply() + numberOfNfts) <= MAX_NFT_SUPPLY, "Exceeds MAX_NFT_SUPPLY");\n', '        require((getNFTPrice() * numberOfNfts) == msg.value, "Ether value sent is not correct");\n', '\n', '        for (uint i = 0; i < numberOfNfts; i++) {\n', '            uint256 mintIndex = totalSupply(); \n', '            if (block.timestamp < REVEAL_TIMESTAMP) {\n', '                _mintedBeforeReveal[mintIndex] = true;\n', '            }\n', '            _safeMint(msg.sender, mintIndex);\n', '        }\n', '\n', '        /**\n', '        * Source of "randomness". Theoretically miners could influence this but not worried for the scope of this project\n', '        */\n', '        if (startingIndexBlock == 0 && (totalSupply() == MAX_NFT_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\n', '            startingIndexBlock = block.number;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Called after the sale ends or reveal period is over\n', '     */\n', '    function finalizeStartingIndex() public {\n', '        require(startingIndex == 0, "Starting index is already set");\n', '        require(startingIndexBlock != 0, "Starting index block must be set");\n', '        \n', '\n', '        uint256 _start = uint256(blockhash(startingIndexBlock)) % MAX_NFT_SUPPLY;\n', '        if ((block.number - _start) > 255) {\n', '            _start = uint256(blockhash(block.number-1)) % MAX_NFT_SUPPLY;\n', '        }\n', '        if (_start == 0) {\n', '            _start = _start + 1;\n', '        }\n', '        \n', '        startingIndex = _start;\n', '    }\n', '\n', '    /**\n', '     * @dev Admin only mint function. Last resort to fix any issues after deployment\n', '    **/\n', '    function mint(address to, uint256 idx) public onlyOwner nonReentrant {\n', '        _safeMint(to, idx);\n', '    }\n', '\n', '    /**\n', '     * @dev Admin only burn function. Last resort to fix any issues after deployment\n', '    **/\n', '    function burn(uint256 idx) public onlyOwner nonReentrant {\n', '        _burn(idx);\n', '    }\n', '    \n', '    /**\n', '     * @dev Withdraw ether from this contract (Callable by owner)\n', '    */\n', '    function withdraw() public onlyOwner {\n', '        uint balance = address(this).balance;\n', '        payable(msg.sender).transfer(balance);\n', '    }\n', '\n', '    /**\n', '     * @dev Halt minting \n', '    */\n', '    function setHaltMint(bool v) public onlyOwner {\n', '        halt_mint = v;\n', '    }\n', '\n', '    /**\n', '     * @dev Halt claims \n', '    */\n', '    function setHaltClaim(bool v) public onlyOwner {\n', '        halt_claim = v;\n', '    }\n', '}']