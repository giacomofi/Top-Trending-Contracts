['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', 'interface MassetStructs {\n', '    struct BassetPersonal {\n', '        // Address of the bAsset\n', '        address addr;\n', '        // Address of the bAsset\n', '        address integrator;\n', '        // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n', '        bool hasTxFee; // takes a byte in storage\n', '        // Status of the bAsset\n', '        BassetStatus status;\n', '    }\n', '\n', '    struct BassetData {\n', '        // 1 Basset * ratio / ratioScale == x Masset (relative value)\n', '        // If ratio == 10e8 then 1 bAsset = 10 mAssets\n', '        // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n', '        uint128 ratio;\n', '        // Amount of the Basset that is held in Collateral\n', '        uint128 vaultBalance;\n', '    }\n', '\n', '    // Status of the Basset - has it broken its peg?\n', '    enum BassetStatus {\n', '        Default,\n', '        Normal,\n', '        BrokenBelowPeg,\n', '        BrokenAbovePeg,\n', '        Blacklisted,\n', '        Liquidating,\n', '        Liquidated,\n', '        Failed\n', '    }\n', '\n', '    struct BasketState {\n', '        bool undergoingRecol;\n', '        bool failed;\n', '    }\n', '\n', '    struct InvariantConfig {\n', '        uint256 a;\n', '        WeightLimits limits;\n', '    }\n', '\n', '    struct WeightLimits {\n', '        uint128 min;\n', '        uint128 max;\n', '    }\n', '\n', '    struct AmpData {\n', '        uint64 initialA;\n', '        uint64 targetA;\n', '        uint64 rampStartTime;\n', '        uint64 rampEndTime;\n', '    }\n', '}\n', '\n', 'abstract contract IInvariantValidator is MassetStructs {\n', '    // Mint\n', '    function computeMint(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _i,\n', '        uint256 _rawInput,\n', '        InvariantConfig memory _config\n', '    ) external view virtual returns (uint256);\n', '\n', '    function computeMintMulti(\n', '        BassetData[] calldata _bAssets,\n', '        uint8[] calldata _indices,\n', '        uint256[] calldata _rawInputs,\n', '        InvariantConfig memory _config\n', '    ) external view virtual returns (uint256);\n', '\n', '    // Swap\n', '    function computeSwap(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _i,\n', '        uint8 _o,\n', '        uint256 _rawInput,\n', '        uint256 _feeRate,\n', '        InvariantConfig memory _config\n', '    ) external view virtual returns (uint256, uint256);\n', '\n', '    // Redeem\n', '    function computeRedeem(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _i,\n', '        uint256 _mAssetQuantity,\n', '        InvariantConfig memory _config\n', '    ) external view virtual returns (uint256);\n', '\n', '    function computeRedeemExact(\n', '        BassetData[] calldata _bAssets,\n', '        uint8[] calldata _indices,\n', '        uint256[] calldata _rawOutputs,\n', '        InvariantConfig memory _config\n', '    ) external view virtual returns (uint256);\n', '}\n', '\n', 'library Root {\n', '    /**\n', '     * @dev Returns the square root of a given number\n', '     * @param x Input\n', '     * @return y Square root of Input\n', '     */\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        if (x == 0) return 0;\n', '        else {\n', '            uint256 xx = x;\n', '            uint256 r = 1;\n', '            if (xx >= 0x100000000000000000000000000000000) {\n', '                xx >>= 128;\n', '                r <<= 64;\n', '            }\n', '            if (xx >= 0x10000000000000000) {\n', '                xx >>= 64;\n', '                r <<= 32;\n', '            }\n', '            if (xx >= 0x100000000) {\n', '                xx >>= 32;\n', '                r <<= 16;\n', '            }\n', '            if (xx >= 0x10000) {\n', '                xx >>= 16;\n', '                r <<= 8;\n', '            }\n', '            if (xx >= 0x100) {\n', '                xx >>= 8;\n', '                r <<= 4;\n', '            }\n', '            if (xx >= 0x10) {\n', '                xx >>= 4;\n', '                r <<= 2;\n', '            }\n', '            if (xx >= 0x8) {\n', '                r <<= 1;\n', '            }\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1; // Seven iterations should be enough\n', '            uint256 r1 = x / r;\n', '            return uint256(r < r1 ? r : r1);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title   InvariantValidator\n', ' * @author  mStable\n', ' * @notice  Builds on and enforces the StableSwap invariant conceived by Michael Egorov. (https://www.curve.fi/stableswap-paper.pdf)\n', ' *          Derived by mStable and adapted for the needs of an mAsset, as described in MIP-7 (http://mips.mstable.org/MIPS/mip-7)\n', ' *          Calculates and validates the result of Masset operations with respect to the invariant.\n', ' *          This supports low slippage swaps and applies penalties towards min and max regions.\n', ' * @dev     VERSION: 1.0\n', ' *          DATE:    2021-02-04\n', ' */\n', 'contract InvariantValidator is IInvariantValidator {\n', '    uint256 internal constant A_PRECISION = 100;\n', '\n', '    /***************************************\n', '                    EXTERNAL\n', '    ****************************************/\n', '\n', '    /**\n', '     * @notice Compute the amount of mAsset received for minting\n', '     * with `quantity` amount of bAsset index `i`.\n', '     * @param _bAssets      Array of all bAsset Data\n', '     * @param _i            Index of bAsset with which to mint\n', '     * @param _rawInput     Raw amount of bAsset to use in mint\n', '     * @param _config       Generalised invariantConfig stored externally\n', '     * @return mintAmount   Quantity of mAssets minted\n', '     */\n', '    function computeMint(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _i,\n', '        uint256 _rawInput,\n', '        InvariantConfig memory _config\n', '    ) external view override returns (uint256 mintAmount) {\n', '        // 1. Get raw reserves\n', '        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n', '        // 2. Get value of reserves according to invariant\n', '        uint256 k0 = _invariant(x, sum, _config.a);\n', '        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\n', '\n', '        // 3. Add deposit to x and sum\n', '        x[_i] += scaledInput;\n', '        sum += scaledInput;\n', '        // 4. Finalise mint\n', '        require(_inBounds(x, sum, _config.limits), "Exceeds weight limits");\n', '        mintAmount = _computeMintOutput(x, sum, k0, _config.a);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the amount of mAsset received for minting\n', '     * with the given array of inputs.\n', '     * @param _bAssets      Array of all bAsset Data\n', '     * @param _indices      Indexes of bAssets with which to mint\n', '     * @param _rawInputs    Raw amounts of bAssets to use in mint\n', '     * @param _config       Generalised invariantConfig stored externally\n', '     * @return mintAmount   Quantity of mAssets minted\n', '     */\n', '    function computeMintMulti(\n', '        BassetData[] calldata _bAssets,\n', '        uint8[] calldata _indices,\n', '        uint256[] calldata _rawInputs,\n', '        InvariantConfig memory _config\n', '    ) external view override returns (uint256 mintAmount) {\n', '        // 1. Get raw reserves\n', '        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n', '        // 2. Get value of reserves according to invariant\n', '        uint256 k0 = _invariant(x, sum, _config.a);\n', '\n', '        // 3. Add deposits to x and sum\n', '        uint256 len = _indices.length;\n', '        uint8 idx;\n', '        uint256 scaledInput;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            idx = _indices[i];\n', '            scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\n', '            x[idx] += scaledInput;\n', '            sum += scaledInput;\n', '        }\n', '        // 4. Finalise mint\n', '        require(_inBounds(x, sum, _config.limits), "Exceeds weight limits");\n', '        mintAmount = _computeMintOutput(x, sum, k0, _config.a);\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the amount of bAsset received for swapping\n', '     * `quantity` amount of index `input_idx` to index `output_idx`.\n', '     * @param _bAssets      Array of all bAsset Data\n', '     * @param _i            Index of bAsset to swap IN\n', '     * @param _o            Index of bAsset to swap OUT\n', '     * @param _rawInput     Raw amounts of input bAsset to input\n', '     * @param _feeRate      Swap fee rate to apply to output\n', '     * @param _config       Generalised invariantConfig stored externally\n', '     * @return bAssetOutputQuantity   Raw bAsset output quantity\n', '     * @return scaledSwapFee          Swap fee collected, in mAsset terms\n', '     */\n', '    function computeSwap(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _i,\n', '        uint8 _o,\n', '        uint256 _rawInput,\n', '        uint256 _feeRate,\n', '        InvariantConfig memory _config\n', '    ) external view override returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\n', '        // 1. Get raw reserves\n', '        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n', '        // 2. Get value of reserves according to invariant\n', '        uint256 k0 = _invariant(x, sum, _config.a);\n', '        // 3. Add deposits to x and sum\n', '        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\n', '        x[_i] += scaledInput;\n', '        sum += scaledInput;\n', '        // 4. Calc total mAsset q\n', '        uint256 k1 = _invariant(x, sum, _config.a);\n', '        scaledSwapFee = ((k1 - k0) * _feeRate) / 1e18;\n', '        // 5. Calc output bAsset\n', '        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 + scaledSwapFee);\n', '        uint256 output = x[_o] - newOutputReserve - 1;\n', '        bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\n', '        // 6. Check for bounds\n', '        x[_o] -= output;\n', '        sum -= output;\n', '        require(_inBounds(x, sum, _config.limits), "Exceeds weight limits");\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the amount of bAsset index `i` received for\n', '     * redeeming `quantity` amount of mAsset.\n', '     * @param _bAssets              Array of all bAsset Data\n', '     * @param _o                    Index of output bAsset\n', '     * @param _netMassetQuantity    Net amount of mAsset to redeem\n', '     * @param _config               Generalised invariantConfig stored externally\n', '     * @return rawOutputUnits       Raw bAsset output returned\n', '     */\n', '    function computeRedeem(\n', '        BassetData[] calldata _bAssets,\n', '        uint8 _o,\n', '        uint256 _netMassetQuantity,\n', '        InvariantConfig memory _config\n', '    ) external view override returns (uint256 rawOutputUnits) {\n', '        // 1. Get raw reserves\n', '        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n', '        // 2. Get value of reserves according to invariant\n', '        uint256 k0 = _invariant(x, sum, _config.a);\n', '        // 3. Compute bAsset output\n', '        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 - _netMassetQuantity);\n', '        uint256 output = x[_o] - newOutputReserve - 1;\n', '        rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\n', '        // 4. Check for max weight\n', '        x[_o] -= output;\n', '        sum -= output;\n', '        require(_inBounds(x, sum, _config.limits), "Exceeds weight limits");\n', '    }\n', '\n', '    /**\n', '     * @notice Compute the amount of mAsset required to redeem\n', '     * a given selection of bAssets.\n', '     * @param _bAssets          Array of all bAsset Data\n', '     * @param _indices          Indexes of output bAssets\n', '     * @param _rawOutputs       Desired raw bAsset outputs\n', '     * @param _config           Generalised invariantConfig stored externally\n', '     * @return totalmAssets     Amount of mAsset required to redeem bAssets\n', '     */\n', '    function computeRedeemExact(\n', '        BassetData[] calldata _bAssets,\n', '        uint8[] calldata _indices,\n', '        uint256[] calldata _rawOutputs,\n', '        InvariantConfig memory _config\n', '    ) external view override returns (uint256 totalmAssets) {\n', '        // 1. Get raw reserves\n', '        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\n', '        // 2. Get value of reserves according to invariant\n', '        uint256 k0 = _invariant(x, sum, _config.a);\n', '        // 3. Sub deposits from x and sum\n', '        uint256 len = _indices.length;\n', '        uint256 ratioed;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\n', '            x[_indices[i]] -= ratioed;\n', '            sum -= ratioed;\n', '        }\n', '        require(_inBounds(x, sum, _config.limits), "Exceeds weight limits");\n', '        // 4. Get new value of reserves according to invariant\n', '        uint256 k1 = _invariant(x, sum, _config.a);\n', '        // 5. Total mAsset is the difference between values\n', '        totalmAssets = k0 - k1;\n', '    }\n', '\n', '    /***************************************\n', '                    INTERNAL\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Computes the actual mint output after adding mint inputs\n', '     * to the vault balances.\n', '     * @param _x            Scaled vaultBalances\n', '     * @param _sum          Sum of vaultBalances, to avoid another loop\n', '     * @param _k            Previous value of invariant, k, before addition\n', '     * @param _a                Precise amplification coefficient\n', '     * @return mintAmount   Amount of value added to invariant, in mAsset terms\n', '     */\n', '    function _computeMintOutput(\n', '        uint256[] memory _x,\n', '        uint256 _sum,\n', '        uint256 _k,\n', '        uint256 _a\n', '    ) internal view returns (uint256 mintAmount) {\n', '        // 1. Get value of reserves according to invariant\n', '        uint256 kFinal = _invariant(_x, _sum, _a);\n', '        // 2. Total minted is the difference between values\n', '        mintAmount = kFinal - _k;\n', '    }\n', '\n', '    /**\n', '     * @dev Simply scaled raw reserve values and returns the sum\n', '     * @param _bAssets  All bAssets\n', '     * @return x        Scaled vault balances\n', '     * @return sum      Sum of scaled vault balances\n', '     */\n', '    function _getReserves(BassetData[] memory _bAssets)\n', '        internal\n', '        pure\n', '        returns (uint256[] memory x, uint256 sum)\n', '    {\n', '        uint256 len = _bAssets.length;\n', '        x = new uint256[](len);\n', '        uint256 r;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            BassetData memory bAsset = _bAssets[i];\n', '            r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\n', '            x[i] = r;\n', '            sum += r;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Checks that no bAsset reserves exceed max weight\n', '     * @param _x            Scaled bAsset reserves\n', '     * @param _sum          Sum of x, precomputed\n', '     * @param _limits       Config object containing max and min weights\n', '     * @return inBounds     Bool, true if all assets are within bounds\n', '     */\n', '    function _inBounds(\n', '        uint256[] memory _x,\n', '        uint256 _sum,\n', '        WeightLimits memory _limits\n', '    ) internal pure returns (bool inBounds) {\n', '        uint256 len = _x.length;\n', '        inBounds = true;\n', '        uint256 w;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            w = (_x[i] * 1e18) / _sum;\n', '            if (w > _limits.max || w < _limits.min) return false;\n', '        }\n', '    }\n', '\n', '    /***************************************\n', '                    INVARIANT\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Compute the invariant f(x) for a given array of supplies `x`.\n', '     * @param _x        Scaled vault balances\n', '     * @param _sum      Sum of scaled vault balances\n', '     * @param _a        Precise amplification coefficient\n', '     * @return k        Cumulative value of all assets according to the invariant\n', '     */\n', '    function _invariant(\n', '        uint256[] memory _x,\n', '        uint256 _sum,\n', '        uint256 _a\n', '    ) internal pure returns (uint256 k) {\n', '        uint256 len = _x.length;\n', '\n', '        if (_sum == 0) return 0;\n', '\n', '        uint256 nA = _a * len;\n', '        uint256 kPrev;\n', '        k = _sum;\n', '\n', '        for (uint256 i = 0; i < 256; i++) {\n', '            uint256 kP = k;\n', '            for (uint256 j = 0; j < len; j++) {\n', '                kP = (kP * k) / (_x[j] * len);\n', '            }\n', '            kPrev = k;\n', '            k =\n', '                (((nA * _sum) / A_PRECISION + (kP * len)) * k) /\n', '                (((nA - A_PRECISION) * k) / A_PRECISION + ((len + 1) * kP));\n', '            if (_hasConverged(k, kPrev)) {\n', '                return k;\n', '            }\n', '        }\n', '\n', '        revert("Invariant did not converge");\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if a given solution has converged within a factor of 1\n', '     * @param _k              Current solution k\n', '     * @param _kPrev          Previous iteration solution\n', '     * @return hasConverged   Bool, true if diff abs(k, kPrev) <= 1\n', '     */\n', '    function _hasConverged(uint256 _k, uint256 _kPrev) internal pure returns (bool) {\n', '        if (_kPrev > _k) {\n', '            return (_kPrev - _k) <= 1;\n', '        } else {\n', '            return (_k - _kPrev) <= 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\n', '     * @param _x        Scaled reserve balances\n', '     * @param _a        Precise amplification coefficient\n', '     * @param _idx      Index of asset for which to solve\n', '     * @param _targetK  Target invariant value K\n', '     * @return y        New reserve of _i\n', '     */\n', '    function _solveInvariant(\n', '        uint256[] memory _x,\n', '        uint256 _a,\n', '        uint8 _idx,\n', '        uint256 _targetK\n', '    ) internal pure returns (uint256 y) {\n', '        uint256 len = _x.length;\n', '        require(_idx >= 0 && _idx < len, "Invalid index");\n', '\n', '        (uint256 sum_, uint256 nA, uint256 kP) = (0, _a * len, _targetK);\n', '\n', '        for (uint256 i = 0; i < len; i++) {\n', '            if (i != _idx) {\n', '                sum_ += _x[i];\n', '                kP = (kP * _targetK) / (_x[i] * len);\n', '            }\n', '        }\n', '\n', '        uint256 c = (((kP * _targetK) * A_PRECISION) / nA) / len;\n', '        uint256 g = (_targetK * (nA - A_PRECISION)) / nA;\n', '        uint256 b = 0;\n', '\n', '        if (g > sum_) {\n', '            b = g - sum_;\n', '            y = (Root.sqrt((b**2) + (4 * c)) + b) / 2 + 1;\n', '        } else {\n', '            b = sum_ - g;\n', '            y = (Root.sqrt((b**2) + (4 * c)) - b) / 2 + 1;\n', '        }\n', '\n', '        if (y < 1e8) revert("Invalid solution");\n', '    }\n', '}']