['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// File: contracts/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '// File: contracts/multi-token-standard/contracts/interfaces/IERC1155.sol\n', 'pragma solidity 0.7.4;\n', '\n', '\n', 'interface IERC1155 {\n', '\n', '  /****************************************|\n', '  |                 Events                 |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n', '\n', '  /**\n', '   * @dev MUST emit when an approval is updated\n', '   */\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '\n', '  /****************************************|\n', '  |                Functions               |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '    * @notice Transfers amount of an _id from the _from address to the _to address specified\n', '    * @dev MUST emit TransferSingle event on success\n', "    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '    * MUST throw if `_to` is the zero address\n', '    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n', '    * MUST throw on any other error\n', '    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '    * @param _from    Source address\n', '    * @param _to      Target address\n', '    * @param _id      ID of the token type\n', '    * @param _amount  Transfered amount\n', '    * @param _data    Additional data with no specified format, sent in call to `_to`\n', '    */\n', '  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n', '\n', '  /**\n', '    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '    * @dev MUST emit TransferBatch event on success\n', "    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '    * MUST throw if `_to` is the zero address\n', '    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n', '    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n', '    * MUST throw on any other error\n', '    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n', '    * @param _from     Source addresses\n', '    * @param _to       Target addresses\n', '    * @param _ids      IDs of each token type\n', '    * @param _amounts  Transfer amounts per token type\n', '    * @param _data     Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n', '\n', '  /**\n', "   * @notice Get the balance of an account's Tokens\n", '   * @param _owner  The address of the token holder\n', '   * @param _id     ID of the Token\n', "   * @return        The _owner's balance of the Token type requested\n", '   */\n', '  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the balance of multiple account/token pairs\n', '   * @param _owners The addresses of the token holders\n', '   * @param _ids    ID of the Tokens\n', "   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n", '   */\n', '  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n', '\n', '  /**\n', '   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n', '   * @dev MUST emit the ApprovalForAll event on success\n', '   * @param _operator  Address to add to the set of authorized operators\n', '   * @param _approved  True if the operator is approved, false to revoke approval\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '  /**\n', '   * @notice Queries the approval status of an operator for a given owner\n', '   * @param _owner     The owner of the Tokens\n', '   * @param _operator  Address of authorized operator\n', '   * @return isOperator True if the operator is approved, false if not\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n', '}\n', '\n', '// File: contracts/multi-token-standard/contracts/interfaces/IERC1155TokenReceiver.sol\n', '\n', 'pragma solidity 0.7.4;\n', '\n', '/**\n', ' * @dev ERC-1155 interface for accepting safe transfers.\n', ' */\n', 'interface IERC1155TokenReceiver {\n', '\n', '  /**\n', '   * @notice Handle the receipt of a single ERC1155 token type\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value MUST result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _id        The id of the token being transferred\n', '   * @param _amount    The amount of tokens being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '   */\n', '  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n', '\n', '  /**\n', '   * @notice Handle the receipt of multiple ERC1155 token types\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value WILL result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeBatchTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _ids       An array containing ids of each token being transferred\n', '   * @param _amounts   An array containing amounts of each token being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '   */\n', '  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n', '}\n', '\n', '// File: contracts/PortionAuction.sol\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', 'contract PortionAuction is IERC721Receiver, IERC1155TokenReceiver {\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  address public owner;\n', '  address public controller;\n', '  address public beneficiary;\n', '  address public highestBidder;\n', '\n', '  uint public tokenId;\n', '  uint public quantity;\n', '  uint public highestBid;\n', '\n', '  bool public cancelled;\n', '  bool public itemClaimed;\n', '  bool public controllerClaimedFunds;\n', '  bool public beneficiaryClaimedFunds;\n', '  bool public acceptPRT;\n', '  bool public isErc1155;\n', '\n', '  IERC20 portionTokenContract;\n', '  IERC721 artTokenContract;\n', '  IERC1155 artToken1155Contract;\n', '\n', '  mapping(address => uint256) public fundsByBidder;\n', '\n', '  constructor(\n', '    address _controller,\n', '    address _beneficiary,\n', '    bool _acceptPRT,\n', '    bool _isErc1155,\n', '    uint _tokenId,\n', '    uint _quantity,\n', '    address portionTokenAddress,\n', '    address artTokenAddress,\n', '    address artToken1155Address\n', '  ) {\n', '    owner = msg.sender;\n', '    controller = _controller;\n', '    beneficiary = _beneficiary;\n', '    acceptPRT = _acceptPRT;\n', '    isErc1155 = _isErc1155;\n', '    tokenId = _tokenId;\n', '    quantity = _quantity;\n', '\n', '    if (acceptPRT) {\n', '      portionTokenContract = IERC20(portionTokenAddress);\n', '    }\n', '\n', '    if (isErc1155) {\n', '      artToken1155Contract = IERC1155(artToken1155Address);\n', '    } else {\n', '      artTokenContract = IERC721(artTokenAddress);\n', '    }\n', '  }\n', '\n', '  function placeBid(address bidder, uint totalAmount)\n', '  onlyOwner\n', '  external\n', '  {\n', '    fundsByBidder[bidder] = totalAmount;\n', '\n', '    if (bidder != highestBidder) {\n', '      highestBidder = bidder;\n', '    }\n', '\n', '    highestBid = totalAmount;\n', '  }\n', '\n', '  function handlePayment()\n', '  payable\n', '  onlyOwner\n', '  external\n', '  {}\n', '\n', '  function withdrawFunds(\n', '    address claimer,\n', '    address withdrawalAccount,\n', '    uint withdrawalAmount,\n', '    bool _beneficiaryClaimedFunds,\n', '    bool _controllerClaimedFunds\n', '  )\n', '  onlyOwner\n', '  external\n', '  {\n', '    // send the funds\n', '    if (acceptPRT) {\n', '      require(portionTokenContract.transfer(claimer, withdrawalAmount));\n', '    } else {\n', '      (bool sent, ) = claimer.call{value: withdrawalAmount}("");\n', '      require(sent);\n', '    }\n', '\n', '    fundsByBidder[withdrawalAccount] -= withdrawalAmount;\n', '    if (_beneficiaryClaimedFunds) {\n', '      beneficiaryClaimedFunds = true;\n', '    }\n', '    if (_controllerClaimedFunds) {\n', '      controllerClaimedFunds = true;\n', '    }\n', '  }\n', '\n', '  function transferItem(\n', '    address claimer\n', '  )\n', '  onlyOwner\n', '  external\n', '  {\n', '    if (isErc1155) {\n', '      artToken1155Contract.safeTransferFrom(address(this), claimer, tokenId, quantity, "");\n', '    } else {\n', '      artTokenContract.safeTransferFrom(address(this), claimer, tokenId);\n', '    }\n', '\n', '    itemClaimed = true;\n', '  }\n', '\n', '  function cancelAuction()\n', '  onlyOwner\n', '  external\n', '  {\n', '    cancelled = true;\n', '  }\n', '\n', '  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata data)\n', '  external\n', '  pure\n', '  override\n', '  returns (bytes4)\n', '  {\n', '    return this.onERC721Received.selector;\n', '  }\n', '\n', '  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data)\n', '  external\n', '  pure\n', '  override\n', '  returns(bytes4)\n', '  {\n', '    return this.onERC1155Received.selector;\n', '  }\n', '\n', '  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data)\n', '  external\n', '  pure\n', '  override\n', '  returns(bytes4)\n', '  {\n', '    return this.onERC1155BatchReceived.selector;\n', '  }\n', '}\n', '\n', '// File: contracts/openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/PortionAuctionFactory.sol\n', '\n', 'pragma solidity ^0.7.4;\n', '\n', 'contract PortionAuctionFactory {\n', '  using SafeMath for uint;\n', '\n', '  struct AuctionParameters {\n', '    uint startingBid;\n', '    uint bidStep;\n', '    uint startBlock;\n', '    uint endBlock;\n', '    uint overtimeBlocksSize;\n', '    uint feeRate;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  bytes32 public name = "PortionAuctionFactory";\n', '  address owner;\n', '  IERC20 public portionTokenContract;\n', '  IERC721 public artTokenContract;\n', '  IERC1155 public artToken1155Contract;\n', '  mapping(address => AuctionParameters) public auctionParameters;\n', '\n', '  event AuctionCreated(address indexed auctionContract, address indexed beneficiary, uint indexed tokenId);\n', '  event BidPlaced (address indexed bidder, uint bid);\n', '  event FundsClaimed (address indexed claimer, address withdrawalAccount, uint withdrawalAmount);\n', '  event ItemClaimed (address indexed claimer);\n', '  event AuctionCancelled ();\n', '\n', '  constructor(address portionTokenAddress, address artTokenAddress, address artToken1155Address) {\n', '    owner = msg.sender;\n', '    portionTokenContract = IERC20(portionTokenAddress);\n', '    artTokenContract = IERC721(artTokenAddress);\n', '    artToken1155Contract = IERC1155(artToken1155Address);\n', '  }\n', '\n', '  function createAuction(\n', '    address beneficiary,\n', '    uint tokenId,\n', '    uint bidStep,\n', '    uint startingBid,\n', '    uint startBlock,\n', '    uint endBlock,\n', '    bool acceptPRT,\n', '    bool isErc1155,\n', '    uint quantity,\n', '    uint feeRate,\n', '    uint overtimeBlocksSize\n', '  )\n', '  onlyOwner\n', '  external\n', '  {\n', '    require(beneficiary != address(0));\n', '    require(bidStep > 0);\n', '    require(startingBid >= 0);\n', '    require(startBlock < endBlock);\n', '    require(startBlock >= block.number);\n', '    require(feeRate <= 100);\n', '    if (isErc1155) {\n', '      require(quantity > 0);\n', '    }\n', '\n', '    PortionAuction newAuction = new PortionAuction(\n', '      msg.sender,\n', '      beneficiary,\n', '      acceptPRT,\n', '      isErc1155,\n', '      tokenId,\n', '      quantity,\n', '      address(portionTokenContract),\n', '      address(artTokenContract),\n', '      address(artToken1155Contract)\n', '    );\n', '\n', '    auctionParameters[address(newAuction)] = AuctionParameters(\n', '      startingBid,\n', '      bidStep,\n', '      startBlock,\n', '      endBlock,\n', '      overtimeBlocksSize,\n', '      feeRate\n', '    );\n', '\n', '    if (isErc1155) {\n', '      artToken1155Contract.safeTransferFrom(msg.sender, address(newAuction), tokenId, quantity, "");\n', '    } else {\n', '      artTokenContract.safeTransferFrom(msg.sender, address(newAuction), tokenId);\n', '    }\n', '\n', '    emit AuctionCreated(address(newAuction), beneficiary, tokenId);\n', '  }\n', '\n', '  function placeBid(\n', '    address auctionAddress\n', '  )\n', '  payable\n', '  external\n', '  {\n', '    PortionAuction auction = PortionAuction(auctionAddress);\n', '    AuctionParameters memory parameters = auctionParameters[auctionAddress];\n', '\n', '    require(block.number >= parameters.startBlock);\n', '    require(block.number < parameters.endBlock);\n', '    require(!auction.cancelled());\n', '    require(!auction.acceptPRT());\n', '    require(msg.sender != auction.controller());\n', '    require(msg.sender != auction.beneficiary());\n', '    require(msg.value > 0);\n', '\n', "    // calculate the user's total bid\n", '    uint totalBid = auction.fundsByBidder(msg.sender) + msg.value;\n', '\n', '    if (auction.highestBid() == 0) {\n', '      // reject if user did not overbid\n', '      require(totalBid >= parameters.startingBid);\n', '    } else {\n', '      // reject if user did not overbid\n', '      require(totalBid >= auction.highestBid() + parameters.bidStep);\n', '    }\n', '\n', '    auction.handlePayment{value:msg.value}();\n', '    auction.placeBid(msg.sender, totalBid);\n', '\n', "    // if bid was placed within specified number of blocks before the auction's end\n", '    // extend auction time\n', '    if (parameters.overtimeBlocksSize > parameters.endBlock - block.number) {\n', '      auctionParameters[auctionAddress].endBlock += parameters.overtimeBlocksSize;\n', '    }\n', '\n', '    emit BidPlaced(msg.sender, totalBid);\n', '  }\n', '\n', '  function placeBidPRT(address auctionAddress, uint amount)\n', '  external\n', '  {\n', '    PortionAuction auction = PortionAuction(auctionAddress);\n', '    AuctionParameters memory parameters = auctionParameters[auctionAddress];\n', '\n', '    require(block.number >= parameters.startBlock);\n', '    require(block.number < parameters.endBlock);\n', '    require(!auction.cancelled());\n', '    require(auction.acceptPRT());\n', '    require(msg.sender != auction.controller());\n', '    require(msg.sender != auction.beneficiary());\n', '    require(amount > 0);\n', '\n', "    // calculate the user's total bid\n", '    uint totalBid = auction.fundsByBidder(msg.sender) + amount;\n', '\n', '    if (auction.highestBid() == 0) {\n', '      // reject if user did not overbid\n', '      require(totalBid >= parameters.startingBid);\n', '    } else {\n', '      // reject if user did not overbid\n', '      require(totalBid >= auction.highestBid() + parameters.bidStep);\n', '    }\n', '\n', '    require(portionTokenContract.transferFrom(msg.sender, auctionAddress, amount));\n', '    auction.placeBid(msg.sender, totalBid);\n', '\n', "    // if bid was placed within specified number of blocks before the auction's end\n", '    // extend auction time\n', '    if (parameters.overtimeBlocksSize > parameters.endBlock - block.number) {\n', '      auctionParameters[auctionAddress].endBlock += parameters.overtimeBlocksSize;\n', '    }\n', '\n', '    emit BidPlaced(msg.sender, totalBid);\n', '  }\n', '\n', '  function claimFunds(address auctionAddress)\n', '  external\n', '  {\n', '    PortionAuction auction = PortionAuction(auctionAddress);\n', '    AuctionParameters memory parameters = auctionParameters[auctionAddress];\n', '\n', '    require(auction.cancelled() || block.number >= parameters.endBlock);\n', '\n', '    address withdrawalAccount;\n', '    uint withdrawalAmount;\n', '    bool beneficiaryClaimedFunds;\n', '    bool controllerClaimedFunds;\n', '\n', '    if (auction.cancelled()) {\n', '      // if the auction was cancelled, everyone should be allowed to withdraw their funds\n', '      withdrawalAccount = msg.sender;\n', '      withdrawalAmount = auction.fundsByBidder(withdrawalAccount);\n', '    } else {\n', '      // the auction finished without being cancelled\n', '\n', '      // reject when auction winner claims funds\n', '      require(msg.sender != auction.highestBidder());\n', '\n', '      // everyone except auction winner should be allowed to withdraw their funds\n', '      if (msg.sender == auction.beneficiary()) {\n', '        require(parameters.feeRate < 100 && !auction.beneficiaryClaimedFunds());\n', '        withdrawalAccount = auction.highestBidder();\n', '        withdrawalAmount = auction.fundsByBidder(withdrawalAccount).mul(100 - parameters.feeRate).div(100);\n', '        beneficiaryClaimedFunds = true;\n', '      } else if (msg.sender == auction.controller()) {\n', '        require(parameters.feeRate > 0 && !auction.controllerClaimedFunds());\n', '        withdrawalAccount = auction.highestBidder();\n', '        withdrawalAmount = auction.fundsByBidder(withdrawalAccount).mul(parameters.feeRate).div(100);\n', '        controllerClaimedFunds = true;\n', '      } else {\n', '        withdrawalAccount = msg.sender;\n', '        withdrawalAmount = auction.fundsByBidder(withdrawalAccount);\n', '      }\n', '    }\n', '\n', '    // reject when there are no funds to claim\n', '    require(withdrawalAmount != 0);\n', '\n', '    auction.withdrawFunds(msg.sender, withdrawalAccount, withdrawalAmount, beneficiaryClaimedFunds, controllerClaimedFunds);\n', '\n', '    emit FundsClaimed(msg.sender, withdrawalAccount, withdrawalAmount);\n', '  }\n', '\n', '  function claimItem(address auctionAddress)\n', '  external\n', '  {\n', '    PortionAuction auction = PortionAuction(auctionAddress);\n', '    AuctionParameters memory parameters = auctionParameters[auctionAddress];\n', '\n', '    require(!auction.itemClaimed());\n', '    require(auction.cancelled() || block.number >= parameters.endBlock);\n', '\n', '    if (auction.cancelled()\n', '      || (auction.highestBidder() == address(0) && block.number >= parameters.endBlock)) {\n', '      require(msg.sender == auction.beneficiary());\n', '    } else {\n', '      require(msg.sender == auction.highestBidder());\n', '    }\n', '\n', '    auction.transferItem(msg.sender);\n', '\n', '    emit ItemClaimed(msg.sender);\n', '  }\n', '\n', '  function cancelAuction(address auctionAddress)\n', '  onlyOwner\n', '  external\n', '  {\n', '    PortionAuction auction = PortionAuction(auctionAddress);\n', '    AuctionParameters memory parameters = auctionParameters[auctionAddress];\n', '\n', '    require(!auction.cancelled());\n', '    require(block.number < parameters.endBlock);\n', '\n', '    auction.cancelAuction();\n', '    emit AuctionCancelled();\n', '  }\n', '}']