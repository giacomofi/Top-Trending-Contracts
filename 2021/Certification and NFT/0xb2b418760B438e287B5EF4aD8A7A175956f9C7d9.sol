['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../libraries/ExchangeConstants.sol";\n', 'import "../libraries/LiquidVoting.sol";\n', 'import "../libraries/SafeCast.sol";\n', 'import "../utils/BalanceAccounting.sol";\n', 'import "./BaseGovernanceModule.sol";\n', '\n', '\n', 'contract ExchangeGovernance is BaseGovernanceModule, BalanceAccounting {\n', '    using Vote for Vote.Data;\n', '    using LiquidVoting for LiquidVoting.Data;\n', '    using VirtualVote for VirtualVote.Data;\n', '    using SafeCast for uint256;\n', '\n', '    event LeftoverGovernanceShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n', '    event LeftoverReferralShareUpdate(address indexed user, uint256 vote, bool isDefault, uint256 amount);\n', '\n', '    LiquidVoting.Data private _leftoverGovernanceShare;\n', '\n', '    constructor(address _mothership) public BaseGovernanceModule(_mothership) {\n', '        _leftoverGovernanceShare.data.result = ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE.toUint104();\n', '    }\n', '\n', '    function parameters() external view returns(uint256 govShare, uint256 refShare) {\n', '        govShare = _leftoverGovernanceShare.data.current();\n', '        refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare);\n', '    }\n', '\n', '    function leftoverGovernanceShare() external view returns(uint256) {\n', '        return _leftoverGovernanceShare.data.current();\n', '    }\n', '\n', '    function leftoverGovernanceShareVotes(address user) external view returns(uint256) {\n', '        return _leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE);\n', '    }\n', '\n', '    function virtualLeftoverGovernanceShare() external view returns(uint104, uint104, uint48) {\n', '        return (_leftoverGovernanceShare.data.oldResult, _leftoverGovernanceShare.data.result, _leftoverGovernanceShare.data.time);\n', '    }\n', '\n', '    //\n', '\n', '    function leftoverReferralShare() external view returns(uint256) {\n', '        return ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.current());\n', '    }\n', '\n', '    function leftoverReferralShareVotes(address user) external view returns(uint256) {\n', '        return ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.votes[user].get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE));\n', '    }\n', '\n', '    function virtualLeftoverReferralShare() external view returns(uint104, uint104, uint48) {\n', '        return (\n', '            ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.oldResult).toUint104(),\n', '            ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(_leftoverGovernanceShare.data.result).toUint104(),\n', '            _leftoverGovernanceShare.data.time\n', '        );\n', '    }\n', '\n', '    ///\n', '\n', '    function leftoverShareVote(uint256 govShare) external {\n', '        uint256 refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShare, "Governance share is too high");\n', '\n', '        uint256 balance = balanceOf(msg.sender);\n', '        uint256 supply = totalSupply();\n', '\n', '        _leftoverGovernanceShare.updateVote(\n', '            msg.sender,\n', '            _leftoverGovernanceShare.votes[msg.sender],\n', '            Vote.init(govShare),\n', '            balance,\n', '            supply,\n', '            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n', '            _emitLeftoverGovernanceShareVoteUpdate\n', '        );\n', '\n', '        _emitLeftoverReferralShareVoteUpdate(msg.sender, refShare, false, balance);\n', '    }\n', '\n', '    function discardLeftoverShareVote() external {\n', '        uint256 balance = balanceOf(msg.sender);\n', '        uint256 supply = totalSupply();\n', '\n', '        _leftoverGovernanceShare.updateVote(\n', '           msg.sender,\n', '           _leftoverGovernanceShare.votes[msg.sender],\n', '           Vote.init(),\n', '           balance,\n', '           supply,\n', '           ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n', '           _emitLeftoverGovernanceShareVoteUpdate\n', '        );\n', '\n', '        _emitLeftoverReferralShareVoteUpdate(msg.sender, ExchangeConstants._DEFAULT_LEFTOVER_REF_SHARE, true, balance);\n', '    }\n', '\n', '    function _notifyStakeChanged(address account, uint256 newBalance) internal override {\n', '        uint256 balance = _set(account, newBalance);\n', '        if (newBalance == balance) {\n', '            return;\n', '        }\n', '\n', '        Vote.Data memory govShareVote = _leftoverGovernanceShare.votes[account];\n', '        uint256 refShare = ExchangeConstants._LEFTOVER_TOTAL_SHARE.sub(govShareVote.get(ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE));\n', '        uint256 supply = totalSupply();\n', '\n', '        _leftoverGovernanceShare.updateBalance(\n', '            account,\n', '            govShareVote,\n', '            balance,\n', '            newBalance,\n', '            supply,\n', '            ExchangeConstants._DEFAULT_LEFTOVER_GOV_SHARE,\n', '            _emitLeftoverGovernanceShareVoteUpdate\n', '        );\n', '\n', '        _emitLeftoverReferralShareVoteUpdate(\n', '            account,\n', '            refShare,\n', '            govShareVote.isDefault(),\n', '            newBalance\n', '        );\n', '    }\n', '\n', '    function _emitLeftoverGovernanceShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n', '        emit LeftoverGovernanceShareUpdate(user, newDefaultShare, isDefault, balance);\n', '    }\n', '\n', '    function _emitLeftoverReferralShareVoteUpdate(address user, uint256 newDefaultShare, bool isDefault, uint256 balance) private {\n', '        emit LeftoverReferralShareUpdate(user, newDefaultShare, isDefault, balance);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'library ExchangeConstants {\n', '    uint256 internal constant _LEFTOVER_TOTAL_SHARE = 1e18;          // 100%\n', '    uint256 internal constant _DEFAULT_LEFTOVER_GOV_SHARE = 0.5e18;  //  50%\n', '    uint256 internal constant _DEFAULT_LEFTOVER_REF_SHARE = 0.5e18;  //  50%\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "./SafeCast.sol";\n', 'import "./VirtualVote.sol";\n', 'import "./Vote.sol";\n', '\n', '\n', 'library LiquidVoting {\n', '    using SafeMath for uint256;\n', '    using SafeCast for uint256;\n', '    using Vote for Vote.Data;\n', '    using VirtualVote for VirtualVote.Data;\n', '\n', '    struct Data {\n', '        VirtualVote.Data data;\n', '        uint256 _weightedSum;\n', '        uint256 _defaultVotes;\n', '        mapping(address => Vote.Data) votes;\n', '    }\n', '\n', '    function updateVote(\n', '        LiquidVoting.Data storage self,\n', '        address user,\n', '        Vote.Data memory oldVote,\n', '        Vote.Data memory newVote,\n', '        uint256 balance,\n', '        uint256 totalSupply,\n', '        uint256 defaultVote,\n', '        function(address, uint256, bool, uint256) emitEvent\n', '    ) internal {\n', '        return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\n', '    }\n', '\n', '    function updateBalance(\n', '        LiquidVoting.Data storage self,\n', '        address user,\n', '        Vote.Data memory oldVote,\n', '        uint256 oldBalance,\n', '        uint256 newBalance,\n', '        uint256 newTotalSupply,\n', '        uint256 defaultVote,\n', '        function(address, uint256, bool, uint256) emitEvent\n', '    ) internal {\n', '        return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\n', '    }\n', '\n', '    function _update(\n', '        LiquidVoting.Data storage self,\n', '        address user,\n', '        Vote.Data memory oldVote,\n', '        Vote.Data memory newVote,\n', '        uint256 oldBalance,\n', '        uint256 newBalance,\n', '        uint256 newTotalSupply,\n', '        uint256 defaultVote,\n', '        function(address, uint256, bool, uint256) emitEvent\n', '    ) private {\n', '        uint256 oldWeightedSum = self._weightedSum;\n', '        uint256 newWeightedSum = oldWeightedSum;\n', '        uint256 oldDefaultVotes = self._defaultVotes;\n', '        uint256 newDefaultVotes = oldDefaultVotes;\n', '\n', '        if (oldVote.isDefault()) {\n', '            newDefaultVotes = newDefaultVotes.sub(oldBalance);\n', '        } else {\n', '            newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\n', '        }\n', '\n', '        if (newVote.isDefault()) {\n', '            newDefaultVotes = newDefaultVotes.add(newBalance);\n', '        } else {\n', '            newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\n', '        }\n', '\n', '        if (newWeightedSum != oldWeightedSum) {\n', '            self._weightedSum = newWeightedSum;\n', '        }\n', '\n', '        if (newDefaultVotes != oldDefaultVotes) {\n', '            self._defaultVotes = newDefaultVotes;\n', '        }\n', '\n', '        {\n', '            uint256 newResult = newTotalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVotes.mul(defaultVote)).div(newTotalSupply);\n', '            VirtualVote.Data memory data = self.data;\n', '\n', '            if (newResult != data.result) {\n', '                VirtualVote.Data storage sdata = self.data;\n', '                (sdata.oldResult, sdata.result, sdata.time) = (\n', '                    data.current().toUint104(),\n', '                    newResult.toUint104(),\n', '                    block.timestamp.toUint48()\n', '                );\n', '            }\n', '        }\n', '\n', '        if (!newVote.eq(oldVote)) {\n', '            self.votes[user] = newVote;\n', '        }\n', '\n', '        emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'library SafeCast {\n', '    function toUint216(uint256 value) internal pure returns (uint216) {\n', '        require(value < 2**216, "value does not fit in 216 bits");\n', '        return uint216(value);\n', '    }\n', '\n', '    function toUint104(uint256 value) internal pure returns (uint104) {\n', '        require(value < 2**104, "value does not fit in 104 bits");\n', '        return uint104(value);\n', '    }\n', '\n', '    function toUint48(uint256 value) internal pure returns (uint48) {\n', '        require(value < 2**48, "value does not fit in 48 bits");\n', '        return uint48(value);\n', '    }\n', '\n', '    function toUint40(uint256 value) internal pure returns (uint40) {\n', '        require(value < 2**40, "value does not fit in 40 bits");\n', '        return uint40(value);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '\n', 'contract BalanceAccounting {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        _balances[account] = _balances[account].sub(amount, "Burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '    }\n', '\n', '    function _set(address account, uint256 amount) internal virtual returns(uint256 oldAmount) {\n', '        oldAmount = _balances[account];\n', '        if (oldAmount != amount) {\n', '            _balances[account] = amount;\n', '            _totalSupply = _totalSupply.add(amount).sub(oldAmount);\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../interfaces/IGovernanceModule.sol";\n', '\n', '\n', 'abstract contract BaseGovernanceModule is IGovernanceModule {\n', '    address public immutable mothership;\n', '\n', '    modifier onlyMothership {\n', '        require(msg.sender == mothership, "Access restricted to mothership");\n', '\n', '        _;\n', '    }\n', '\n', '    constructor(address _mothership) public {\n', '        mothership = _mothership;\n', '    }\n', '\n', '    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external override onlyMothership {\n', '        require(accounts.length == newBalances.length, "Arrays length should be equal");\n', '\n', '        for(uint256 i = 0; i < accounts.length; ++i) {\n', '            _notifyStakeChanged(accounts[i], newBalances[i]);\n', '        }\n', '    }\n', '\n', '    function notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {\n', '        _notifyStakeChanged(account, newBalance);\n', '    }\n', '\n', '    function _notifyStakeChanged(address account, uint256 newBalance) internal virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'import "@openzeppelin/contracts/math/Math.sol";\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '\n', 'library VirtualVote {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\n', '\n', '    struct Data {\n', '        uint104 oldResult;\n', '        uint104 result;\n', '        uint48 time;\n', '    }\n', '\n', '    function current(VirtualVote.Data memory self) internal view returns(uint256) {\n', '        uint256 timePassed = Math.min(_VOTE_DECAY_PERIOD, block.timestamp.sub(self.time));\n', '        uint256 timeRemain = _VOTE_DECAY_PERIOD.sub(timePassed);\n', '        return uint256(self.oldResult).mul(timeRemain).add(\n', '            uint256(self.result).mul(timePassed)\n', '        ).div(_VOTE_DECAY_PERIOD);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', 'library Vote {\n', '    struct Data {\n', '        uint256 value;\n', '    }\n', '\n', '    function eq(Vote.Data memory self, Vote.Data memory vote) internal pure returns(bool) {\n', '        return self.value == vote.value;\n', '    }\n', '\n', '    function init() internal pure returns(Vote.Data memory data) {\n', '        return Vote.Data({\n', '            value: 0\n', '        });\n', '    }\n', '\n', '    function init(uint256 vote) internal pure returns(Vote.Data memory data) {\n', '        return Vote.Data({\n', '            value: vote + 1\n', '        });\n', '    }\n', '\n', '    function isDefault(Data memory self) internal pure returns(bool) {\n', '        return self.value == 0;\n', '    }\n', '\n', '    function get(Data memory self, uint256 defaultVote) internal pure returns(uint256) {\n', '        if (self.value > 0) {\n', '            return self.value - 1;\n', '        }\n', '        return defaultVote;\n', '    }\n', '\n', '    function get(Data memory self, function() external view returns(uint256) defaultVoteFn) internal view returns(uint256) {\n', '        if (self.value > 0) {\n', '            return self.value - 1;\n', '        }\n', '        return defaultVoteFn();\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'interface IGovernanceModule {\n', '    function notifyStakeChanged(address account, uint256 newBalance) external;\n', '    function notifyStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external;\n', '}']