['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-08\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '/*\n', 'Top Dawg Entertainment, LLC (“Owner”), for the benefit of Solana Imani Rowe, p/k/a SZA (“Artist”) is offering on FANAPLY at https://www.fanaply.com/mainpage (“Marketplace”) Non-Fungible Tokens (each, an “NFT”, collectively, “NFTs”), each associated with an underlying piece of digital content (“Content”) to celebrate SZA’s debut performance for the American Express UNSTAGED virtual concert series on June 17, 2021 (the “Promotion”). American Express Travel Related Services Company, Inc., R/GA Media Group, Inc., Owner, Artist, and each of their parents, affiliates, and subsidiaries, and their respective officers, directors, employees, representatives, and agents may be referred to herein individually as a “Released Party” and collectively as the “Released Parties.”\n', '\n', 'Transferring NFTs\n', '\n', 'You are solely responsible for the safekeeping of the private key associated with the blockchain address used to interact with your wallet (“Wallet”), following any such transfer of any NFT to your Wallet (“Private Key”). None of the Released Parties shall be responsible for your failure to keep your Private Key secure, however caused.\n', '\n', 'Rights and Restrictions\n', '\n', 'The digital content in this NFT (Content) is the property of Owner.  \n', '\n', 'WHILE YOU ARE ABLE TO PURCHASE THE NFT, AND THE NFT MAY POINT TO THE UNDERLYING CONTENT, IT IS IMPORTANT TO UNDERSTAND THAT NFT PURCHASERS DO NOT OWN THE UNDERLYING CONTENT AND WILL NOT HOLD THE COPYRIGHT IN OR TO THE UNDERLYING CONTENT. Such owners of successfully purchased and transferred NFTs shall be referred to herein as “NFT purchasers.”\n', 'Each purchaser of this NFT is granted a limited, non-assignable, non-sublicenseable, royalty-free license to use and display the Content associated with the NFT for the duration of such purchaser’s ownership of this NFT solely to (i) publicly and privately display the applicable Content; and (ii) to market, promote, advertise and sell the NFT associated with the applicable Content.  Each purchaser may use the Content only for personal, non-commercial purposes.  \n', '\n', 'NFT purchasers may not do (nor permit any third party to do or attempt to do) the following:\n', '\n', 'o\tModify the Content in any way.\n', '\n', 'o\tMake “commercial use” of the Content, including any Content associated with their NFT(s), including, for example, by creating and selling copies of the Content, licensing the Content for commercial purposes (e.g., to sell merchandise, products or services), or otherwise commercially exploiting the Content. \n', '\n', 'o\tApply for, register, or otherwise use or attempt to use the Content or acquire additional rights in any property of any Released Party, anywhere in the world, for any purpose other than as strictly permitted herein.\n', '\n', 'o\tMake any additional representations or warranties relating to the Content.  \n', '\n', 'o\tUse the Content or the NFT in any way that: (a) violates the rights of any third party or any applicable law, rule, or regulation; (b) is obscene, profane, pornographic, vulgar or offensive; (c) incites or promotes violence or violent or dangerous behavior, or depicts violence (either towards others or oneself); (d) involves hate speech, endorses any form of hate, or harasses, abuses, insults, harms, defames, slanders, disparages, intimidates, threatens or discriminates on others based on gender, sexual orientation, religion, ethnicity, race, age, national origin, or disability; (e) spreads false, deceptive, misleading, otherwise unsubstantiated or unfair information or material or promotes any particular political agenda or message; (f) promotes any activities that may be or appear unsafe or dangerous, including, without limitation, excessive consumption of alcohol, illegal drugs, tobacco, firearms/weapons (or the use of any of the foregoing); and/or (g) disparages any Released Party, or its brands, products or services or communicates messages inconsistent with the positive images and/or good will with which a Released Party wishes to associate.\n', 'If a purchaser violates this license in a manner that infringes Owner’s rights, such purchaser agrees that Owner may take any action necessary to stop such infringement, at purchaser’s expense.  If a purchaser incurs liability due to infringement of Owner’s rights, such liability survives expiration of this license.\n', 'This limited license to use or display the Content expires immediately upon transfer of the NFT to a new purchaser.  \n', '\n', 'Assumption of Risk; Liability Waiver\n', 'THE LICENSE GRANTED IS PROVIDED “AS IS.” EACH PURCHASER ASSUMES THE ENTIRE RISK OF THEIR USE OF THE CONTENT. NO WARRANTIES ARE GIVEN, WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OF FITNESS FOR PARTICULAR PURPOSE, MERCHANTABILITY, NON-INFRINGEMENT OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  IN NO EVENT WILL RELEASED PARTIES BE LIABLE FOR ANY SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR FOR ANY LIABILITY IN TORT, NEGLIGENCE, OR ANY OTHER LIABILITY INCURRED BY OR UNDER OR IN CONNECTION WITH THIS LICENSE.\n', '\n', 'You bear sole responsibility for paying any and all taxes, duties, and assessments payable as the result of purchase, ownership, sale, transfer, use and/or exploitation of any NFT.\n', '\n', 'Released Parties will have no liability whatsoever for, and shall be held harmless against, any liability for any injuries, losses or damages of any kind, including death, to persons, or property resulting in whole or in part, directly or indirectly, from participation in this Promotion. \n', '\n', 'Void where prohibited and subject to all applicable federal, state and local laws. \n', '*/\n', '\n', 'pragma solidity 0.8.1;\n', '\n', '/*\n', 'VERSION DATE: 24/03/2021\n', '*/\n', '\n', 'library Address \n', '{\n', '    function isContract(address account) internal view returns (bool)\n', '\t{\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library Strings\n', '{\n', '    function toString(uint256 value) internal pure returns (string memory)\n', '\t{\n', '        if (value == 0) return "0";\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0)\n', '\t\t{\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        while (value != 0)\n', '\t\t{\n', '            digits -= 1;\n', '            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n', '            value /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '}\n', '\n', 'abstract contract Context\n', '{\n', '    function _msgSender() internal view virtual returns (address)\n', '\t{\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', 'interface IERC165\n', '{\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'abstract contract ERC165 is IERC165\n', '{\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool)\n', '\t{\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', 'interface IERC721 is IERC165\n', '{\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', 'interface IERC721Enumerable is IERC721\n', '{\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', 'interface IERC721Metadata is IERC721\n', '{\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', 'interface IERC721Receiver\n', '{\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', 'contract ERC721Full is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable, IERC721Receiver\n', '{\n', '    using Address for address;\n', '    using Strings for uint256;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    string private _baseTokenURI;\n', '\t\n', '    mapping (uint256 => address) private _owners;\t\t\t// Mapping from token ID to owner address\n', '    mapping (address => uint256) private _balances;\t\t\t// Mapping owner address to token count\n', '    mapping (uint256 => address) private _tokenApprovals;\t// Mapping from token ID to approved address\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\t// Mapping from owner to operator approvals\n', '\n', '\tuint256[] private _allTokens;\t\t\t\t\t\t\t// Array with all token ids, used for enumeration\n', '    mapping(uint256 => uint256) private _allTokensIndex;\t// Mapping from token id to position in the allTokens array\n', '\n', '\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\t// Mapping from owner to list of owned token IDs\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\t// Mapping from token ID to index of the owner tokens list\n', '\n', '    constructor(string memory name_, string memory symbol_, string memory baseTokenURI_)\n', '\t{\n', '\t\t_name = name_;\n', '\t\t_symbol = symbol_;\n', '\t\t_baseTokenURI = baseTokenURI_;\n', '    }\n', '\n', '\tfunction onERC721Received( address _operator, address _from, uint256 _tokenId, bytes calldata _data )\n', '\t\texternal pure override returns(bytes4)\n', '\t{\n', '\t\t_operator;\n', '\t\t_from;\n', '\t\t_tokenId;\n', '\t\t_data;\n', '\t\treturn 0x150b7a02;\n', '\t}\n', '\t\n', '\t// 0x01ffc9a7 = ERC165\n', '\t// 0x80ac58cd = ERC721\n', '\t// 0x780e9d63 = ERC721Enumerable\n', '\t// 0x5b5e139f = ERC721Metadata\n', '\t// 0x150b7a02 = ERC721Receiver\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool)\n', '\t{\n', '        return interfaceId == type(IERC721).interfaceId\n', '            || interfaceId == type(IERC721Metadata).interfaceId\n', '            || interfaceId == type(IERC721Enumerable).interfaceId\n', '            || interfaceId == type(IERC721Receiver).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    function totalSupply() public view virtual override returns (uint256)\n', '\t{\n', '\t\treturn _allTokens.length;\n', '\t}\n', '\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256 tokenId)\n', '\t{\n', '        require(index < balanceOf(owner), "ERC721Enumerable: owner index out of bounds");\n', '        return _ownedTokens[owner][index];\n', '\t}\n', '\n', '    function tokenByIndex(uint256 index) public view virtual override returns (uint256)\n', '\t{\n', '        require(index < totalSupply(), "ERC721Enumerable: global index out of bounds");\n', '        return _allTokens[index];\n', '\t}\n', '\n', '    function balanceOf(address owner) public view virtual override returns (uint256)\n', '\t{\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '        return _balances[owner];\n', '    }\n', '\n', '    function ownerOf(uint256 tokenId) public view virtual override returns (address)\n', '\t{\n', '        address owner = _owners[tokenId];\n', '        require(owner != address(0), "ERC721: owner query for nonexistent token");\n', '        return owner;\n', '    }\n', '\n', '    function name() public view virtual override returns (string memory)\n', '\t{\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual override returns (string memory)\n', '\t{\n', '        return _symbol;\n', '    }\n', '\n', '    function tokenURI(uint256 tokenId) public view virtual override returns (string memory)\n', '\t{\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        string memory baseURI = _baseURI();\n', '        return bytes(baseURI).length > 0\n', '            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n', "            : '';\n", '    }\n', '\n', '    function _baseURI() internal view virtual returns (string memory)\n', '\t{\n', '        return _baseTokenURI;\n', '    }\n', '\n', '    function approve(address to, uint256 tokenId) public virtual override\n', '\t{\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    function getApproved(uint256 tokenId) public view virtual override returns (address)\n', '\t{\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    function setApprovalForAll(address operator, bool approved) public virtual override\n', '\t{\n', '        require(operator != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool)\n', '\t{\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public virtual override\n', '\t{\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override\n', '\t{\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override\n', '\t{\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual\n', '\t{\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    function _exists(uint256 tokenId) internal view virtual returns (bool)\n', '\t{\n', '        return _owners[tokenId] != address(0);\n', '    }\n', '\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool)\n', '\t{\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    function _safeMint(address to, uint256 tokenId) internal virtual\n', '\t{\n', '        _safeMint(to, tokenId, "");\n', '    }\n', '\n', '    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual\n', '\t{\n', '        _mint(to, tokenId);\n', '        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    function _mint(address to, uint256 tokenId) internal virtual\n', '\t{\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '\n', '        _beforeTokenTransfer(address(0), to, tokenId);\n', '\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 tokenId) internal virtual\n', '\t{\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        if (_tokenApprovals[tokenId] != address(0)) _approve(address(0), tokenId);\n', '\n', '        _balances[from] -= 1;\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    function _approve(address to, uint256 tokenId) internal virtual\n', '\t{\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool)\n', '    {\n', '        if (to.isContract()) \n', '\t\t{\n', '            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n', '                return retval == IERC721Receiver(to).onERC721Received.selector;\n', '            } catch (bytes memory reason) {\n', '                if (reason.length == 0) {\n', '                    revert("ERC721: transfer to non ERC721Receiver implementer");\n', '                } else {\n', '                    // solhint-disable-next-line no-inline-assembly\n', '                    assembly {\n', '                        revert(add(32, reason), mload(reason))\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\t\telse \n', '\t\t{\n', '            return true;\n', '        }\n', '    }\n', '\t\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual\n', '\t{\n', '\t\trequire( to != address(0), "forbidden transfer to address(0)" );\n', '\t\trequire( from != to, "from equal to" );\n', '\t\t\n', '        if (from == address(0)) {\n', '            _addTokenToAllTokensEnumeration(tokenId);\n', '        } else {\n', '            _removeTokenFromOwnerEnumeration(from, tokenId);\n', '        }\n', '\t\t\n', '\t\t_addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\t\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private\n', '\t{\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\t\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private\n', '\t{\n', '        uint256 lastTokenIndex = balanceOf(from) - 1;\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId;\n', '            _ownedTokensIndex[lastTokenId] = tokenIndex;\n', '        }\n', '\n', '        delete _ownedTokensIndex[tokenId];\n', '        delete _ownedTokens[from][lastTokenIndex];\n', '    }\n', '\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private\n', '\t{\n', '        uint256 length = balanceOf(to);\n', '        _ownedTokens[to][length] = tokenId;\n', '        _ownedTokensIndex[tokenId] = length;\n', '    }\n', '\n', '}\n', ' \n', 'abstract contract CheckAccess \n', '{\n', '\tfunction isAdmin(address addr) public virtual view returns (bool);\n', '}\n', '\n', 'contract MultiHandler is ERC721Full\n', '{\n', '\tusing Strings for uint256;\n', '    using Address for address;\n', '\taddress checkAccessContract;\n', '\t\n', '\tstruct Type\n', '\t{\n', '        string name;\n', '        string URI;\n', '        string IPFSHash;\n', '        uint issuedCount;\n', '\t\tuint minBound;\n', '\t\tuint maxBound;\n', '    }\n', '\n', '\tType[] typesById;\n', '\n', '\tuint public endPoint = 0;\n', '\t\n', '\tmapping (uint256 => uint256) public tokenType; // idToken => idType\n', '\tmapping (uint64 => bool) public nonces;\n', '\t\n', '    constructor(\n', '\t\tstring memory _name,\n', '\t\tstring memory _symbol,\n', '\t\tstring memory _tokenURI,\n', '\t\taddress _checkAccessContract\n', '\t) ERC721Full(_name, _symbol, _tokenURI) \n', '\t{\n', '\t\tcheckAccessContract = _checkAccessContract;\n', '\t\t\n', '\t\trequire(checkAccessContract.isContract(), "checkAccessContract is not found");\n', '\t}\n', '\t\n', '\tevent CreateType(uint typeId, string name, uint count, uint min, uint max);\n', '\t\n', '\tfunction checkAdmin(address addr) public view returns (bool)\n', '\t{\n', '\t\tCheckAccess check = CheckAccess(checkAccessContract);\n', '\t\treturn( check.isAdmin(addr) );\n', '\t}\n', '\n', '\tmodifier onlyAdmin()\n', '\t{\n', '\t\trequire( checkAdmin(_msgSender()), "wrong admin" );\n', '\t\t_;\n', '\t}\n', '\t\n', '\tfunction createType(\n', '\t\tstring memory _name,\n', '\t\tstring memory _uri,\n', '\t\tstring memory _ipfs,\n', '\t\tuint _startPoint,\n', '\t\tuint _count) public onlyAdmin\n', '\t{\n', '\t\trequire( bytes(_name).length >= 3, "wrong length" );\n', '\t\trequire( bytes(_ipfs).length >= 3, "wrong length" );\n', '\t\trequire( _count > 0, "count must not be zero" );\n', '\t\trequire( _startPoint > endPoint, "wrong startPoint" );\n', '\t\t\n', '\t\tuint id = typesById.length;\n', '\t\tif ( bytes(_uri).length == 0 ) _uri = _baseURI();\n', '\n', '\t\tuint minBound = _startPoint;\n', '\t\tuint maxBound = _startPoint + _count - 1;\n', '\t\tendPoint = maxBound;\n', '\t\t\n', '\t\tType memory _type = Type({\n', '\t\t\tname: _name,\n', '\t\t\tURI: _uri,\n', '\t\t\tIPFSHash: _ipfs,\n', '\t\t\tissuedCount: 0,\n', '\t\t\tminBound: minBound,\n', '\t\t\tmaxBound: maxBound\n', '\t\t});\n', '\n', '\t\ttypesById.push( _type );\n', '\t\t\n', '\t\temit CreateType(id, _name, _count, minBound, maxBound);\n', '\t}\n', '\n', '\tfunction getTypeById(uint256 typeId) public view returns (\n', '\t\tstring memory name,\n', '\t\tstring memory URI,\n', '\t\tstring memory IPFSHash,\n', '\t\tuint maxCount,\n', '\t\tuint issuedCount,\n', '\t\tuint minBound,\n', '\t\tuint maxBound\n', '\t){\n', '\t\trequire( typeId < typesById.length, "query for nonexistent type" );\n', '\t\t\n', '\t\tname = typesById[typeId].name;\n', '\t\tURI = typesById[typeId].URI;\n', '\t\tIPFSHash = typesById[typeId].IPFSHash;\n', '\t\tmaxCount = typesById[typeId].maxBound - typesById[typeId].minBound + 1;\n', '\t\tissuedCount = typesById[typeId].issuedCount;\n', '\t\tminBound = typesById[typeId].minBound;\n', '\t\tmaxBound = typesById[typeId].maxBound;\n', '\t}\n', '\t\n', '    function tokenURI(uint256 tokenId) public view override returns (string memory)\n', '\t{\n', '        require(_exists(tokenId), "query for nonexistent token");\n', '\t\tuint typeId = tokenType[tokenId];\n', '\t\treturn string(abi.encodePacked( typesById[typeId].URI, tokenId.toString()));\n', '    }\n', '\t\n', '\tfunction tokenIPFSHash(uint256 tokenId) public view returns (string memory hash)\n', '\t{\n', '\t\trequire(_exists(tokenId), "query for nonexistent token");\n', '\t\tuint typeId = tokenType[tokenId];\n', '\t\treturn typesById[typeId].IPFSHash;\n', '\t}\n', '\t\n', '\tfunction issueToken(address addr, uint typeId, uint256 tokenId) internal\n', '\t{\n', '\t\trequire( typeId < typesById.length, "query for nonexistent type" );\n', '\t\t\n', '\t\trequire( tokenId >= typesById[typeId].minBound, "min overrun" );\n', '\t\trequire( tokenId <= typesById[typeId].maxBound, "max overrun" );\n', '\t\t\n', '\t\tif (_exists(tokenId))\n', '\t\t{\n', '\t\t\t_transfer(address(this), addr, tokenId);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\ttokenType[tokenId] = typeId;\n', '\t\t\t\n', '\t\t\ttypesById[typeId].issuedCount++;\n', '\t\t\t\n', '\t\t\t_mint(addr, tokenId);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction giveTokenTo(address to, uint typeId, uint tokenId) public onlyAdmin\n', '\t{\n', '\t\tissueToken(to, typeId, tokenId);\n', '\t}\n', '\t\n', '\tfunction giveTokens(address[] memory addrs, uint typeId, uint[] memory idTokens) public onlyAdmin\n', '\t{\n', '\t\trequire(addrs.length>0, "length is 0");\n', '\t\trequire(addrs.length == idTokens.length, "arrays are not equal");\n', '\t\t\n', '\t\tuint count = addrs.length;\n', '\t\tfor(uint i = 0; i < count; i++) \n', '\t\t{\n', '\t\t\tissueToken(addrs[i], typeId, idTokens[i]);\n', '        }\n', '    }\n', '\t\n', '\tfunction takeToken(uint256 typeId, uint256 tokenId, uint64 nonce, bytes32 r, bytes32 s, uint8 v) public\n', '\t{\n', '\t\tbytes memory prefix = "\\x19Ethereum Signed Message:\\n32";\n', '\t\tbytes32 hash = keccak256( abi.encodePacked(address(this), _msgSender(), nonce, typeId, tokenId) );\n', '        address signer = ecrecover(keccak256(abi.encodePacked(prefix,hash)), v, r, s);\n', '\n', '\t\trequire( nonces[nonce] == false, "wrong nonce" );\n', '\t\tnonces[nonce] = true;\n', '\n', '\t\trequire( checkAdmin(signer), "wrong admin" );\n', '\t\t\n', '\t\tissueToken(_msgSender(), typeId, tokenId);\n', '\t}\n', '}']