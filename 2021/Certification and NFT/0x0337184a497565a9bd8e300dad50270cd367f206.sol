['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-13\n', '*/\n', '\n', '// SPDX-License-Identifier: Bprotocol Foundation (Bancor) LICENSE\n', '\n', '// File: solidity/contracts/utility/interfaces/IOwned.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'interface IOwned {\n', "    // this function isn't since the compiler emits automatically generated getter functions as external\n", '    function owner() external view returns (address);\n', '\n', '    function transferOwnership(address _newOwner) external;\n', '    function acceptOwnership() external;\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/*\n', '    Converter Anchor interface\n', '*/\n', 'interface IConverterAnchor is IOwned {\n', '}\n', '\n', '// File: solidity/contracts/token/interfaces/IERC20Token.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    ERC20 Standard Token interface\n', '*/\n', 'interface IERC20Token {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '}\n', '\n', '// File: solidity/contracts/utility/interfaces/IWhitelist.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Whitelist interface\n', '*/\n', 'interface IWhitelist {\n', '    function isWhitelisted(address _address) external view returns (bool);\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverter.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Converter interface\n', '*/\n', 'interface IConverter is IOwned {\n', '    function converterType() external pure returns (uint16);\n', '    function anchor() external view returns (IConverterAnchor);\n', '    function isActive() external view returns (bool);\n', '\n', '    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) external view returns (uint256, uint256);\n', '    function convert(IERC20Token _sourceToken,\n', '                     IERC20Token _targetToken,\n', '                     uint256 _amount,\n', '                     address _trader,\n', '                     address payable _beneficiary) external payable returns (uint256);\n', '\n', '    function conversionWhitelist() external view returns (IWhitelist);\n', '    function conversionFee() external view returns (uint32);\n', '    function maxConversionFee() external view returns (uint32);\n', '    function reserveBalance(IERC20Token _reserveToken) external view returns (uint256);\n', '    receive() external payable;\n', '\n', '    function transferAnchorOwnership(address _newOwner) external;\n', '    function acceptAnchorOwnership() external;\n', '    function setConversionFee(uint32 _conversionFee) external;\n', '    function setConversionWhitelist(IWhitelist _whitelist) external;\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n', '    function withdrawETH(address payable _to) external;\n', '    function addReserve(IERC20Token _token, uint32 _ratio) external;\n', '\n', '    // deprecated, backward compatibility\n', '    function token() external view returns (IConverterAnchor);\n', '    function transferTokenOwnership(address _newOwner) external;\n', '    function acceptTokenOwnership() external;\n', '    function connectors(IERC20Token _address) external view returns (uint256, uint32, bool, bool, bool);\n', '    function getConnectorBalance(IERC20Token _connectorToken) external view returns (uint256);\n', '    function connectorTokens(uint256 _index) external view returns (IERC20Token);\n', '    function connectorTokenCount() external view returns (uint16);\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Converter Upgrader interface\n', '*/\n', 'interface IConverterUpgrader {\n', '    function upgrade(bytes32 _version) external;\n', '    function upgrade(uint16 _version) external;\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IBancorFormula.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Bancor Formula interface\n', '*/\n', 'interface IBancorFormula {\n', '    function purchaseTargetAmount(uint256 _supply,\n', '                                  uint256 _reserveBalance,\n', '                                  uint32 _reserveWeight,\n', '                                  uint256 _amount)\n', '                                  external view returns (uint256);\n', '\n', '    function saleTargetAmount(uint256 _supply,\n', '                              uint256 _reserveBalance,\n', '                              uint32 _reserveWeight,\n', '                              uint256 _amount)\n', '                              external view returns (uint256);\n', '\n', '    function crossReserveTargetAmount(uint256 _sourceReserveBalance,\n', '                                      uint32 _sourceReserveWeight,\n', '                                      uint256 _targetReserveBalance,\n', '                                      uint32 _targetReserveWeight,\n', '                                      uint256 _amount)\n', '                                      external view returns (uint256);\n', '\n', '    function fundCost(uint256 _supply,\n', '                      uint256 _reserveBalance,\n', '                      uint32 _reserveRatio,\n', '                      uint256 _amount)\n', '                      external view returns (uint256);\n', '\n', '    function fundSupplyAmount(uint256 _supply,\n', '                              uint256 _reserveBalance,\n', '                              uint32 _reserveRatio,\n', '                              uint256 _amount)\n', '                              external view returns (uint256);\n', '\n', '    function liquidateReserveAmount(uint256 _supply,\n', '                                    uint256 _reserveBalance,\n', '                                    uint32 _reserveRatio,\n', '                                    uint256 _amount)\n', '                                    external view returns (uint256);\n', '\n', '    function balancedWeights(uint256 _primaryReserveStakedBalance,\n', '                             uint256 _primaryReserveBalance,\n', '                             uint256 _secondaryReserveBalance,\n', '                             uint256 _reserveRateNumerator,\n', '                             uint256 _reserveRateDenominator)\n', '                             external view returns (uint32, uint32);\n', '}\n', '\n', '// File: solidity/contracts/utility/Owned.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Provides support and utilities for contract ownership\n', '*/\n', 'contract Owned is IOwned {\n', '    address public override owner;\n', '    address public newOwner;\n', '\n', '    /**\n', '      * @dev triggered when the owner is updated\n', '      *\n', '      * @param _prevOwner previous owner\n', '      * @param _newOwner  new owner\n', '    */\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '      * @dev initializes a new Owned instance\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        _ownerOnly();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _ownerOnly() internal view {\n', '        require(msg.sender == owner, "ERR_ACCESS_DENIED");\n', '    }\n', '\n', '    /**\n', '      * @dev allows transferring the contract ownership\n', '      * the new owner still needs to accept the transfer\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _newOwner    new contract owner\n', '    */\n', '    function transferOwnership(address _newOwner) public override ownerOnly {\n', '        require(_newOwner != owner, "ERR_SAME_OWNER");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '      * @dev used by a new owner to accept an ownership transfer\n', '    */\n', '    function acceptOwnership() override public {\n', '        require(msg.sender == newOwner, "ERR_ACCESS_DENIED");\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/Utils.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Utilities & Common Modifiers\n', '*/\n', 'contract Utils {\n', '    // verifies that a value is greater than zero\n', '    modifier greaterThanZero(uint256 _value) {\n', '        _greaterThanZero(_value);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _greaterThanZero(uint256 _value) internal pure {\n', '        require(_value > 0, "ERR_ZERO_VALUE");\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        _validAddress(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validAddress(address _address) internal pure {\n', '        require(_address != address(0), "ERR_INVALID_ADDRESS");\n', '    }\n', '\n', '    // verifies that the address is different than this contract address\n', '    modifier notThis(address _address) {\n', '        _notThis(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _notThis(address _address) internal view {\n', '        require(_address != address(this), "ERR_ADDRESS_IS_SELF");\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Contract Registry interface\n', '*/\n', 'interface IContractRegistry {\n', '    function addressOf(bytes32 _contractName) external view returns (address);\n', '}\n', '\n', '// File: solidity/contracts/utility/ContractRegistryClient.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/**\n', '  * @dev Base contract for ContractRegistry clients\n', '*/\n', 'contract ContractRegistryClient is Owned, Utils {\n', '    bytes32 internal constant CONTRACT_REGISTRY = "ContractRegistry";\n', '    bytes32 internal constant BANCOR_NETWORK = "BancorNetwork";\n', '    bytes32 internal constant BANCOR_FORMULA = "BancorFormula";\n', '    bytes32 internal constant CONVERTER_FACTORY = "ConverterFactory";\n', '    bytes32 internal constant CONVERSION_PATH_FINDER = "ConversionPathFinder";\n', '    bytes32 internal constant CONVERTER_UPGRADER = "BancorConverterUpgrader";\n', '    bytes32 internal constant CONVERTER_REGISTRY = "BancorConverterRegistry";\n', '    bytes32 internal constant CONVERTER_REGISTRY_DATA = "BancorConverterRegistryData";\n', '    bytes32 internal constant BNT_TOKEN = "BNTToken";\n', '    bytes32 internal constant BANCOR_X = "BancorX";\n', '    bytes32 internal constant BANCOR_X_UPGRADER = "BancorXUpgrader";\n', '    bytes32 internal constant CHAINLINK_ORACLE_WHITELIST = "ChainlinkOracleWhitelist";\n', '\n', '    IContractRegistry public registry;      // address of the current contract-registry\n', '    IContractRegistry public prevRegistry;  // address of the previous contract-registry\n', '    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\n', '\n', '    /**\n', '      * @dev verifies that the caller is mapped to the given contract name\n', '      *\n', '      * @param _contractName    contract name\n', '    */\n', '    modifier only(bytes32 _contractName) {\n', '        _only(_contractName);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _only(bytes32 _contractName) internal view {\n', '        require(msg.sender == addressOf(_contractName), "ERR_ACCESS_DENIED");\n', '    }\n', '\n', '    /**\n', '      * @dev initializes a new ContractRegistryClient instance\n', '      *\n', '      * @param  _registry   address of a contract-registry contract\n', '    */\n', '    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\n', '        registry = IContractRegistry(_registry);\n', '        prevRegistry = IContractRegistry(_registry);\n', '    }\n', '\n', '    /**\n', '      * @dev updates to the new contract-registry\n', '     */\n', '    function updateRegistry() public {\n', '        // verify that this function is permitted\n', '        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, "ERR_ACCESS_DENIED");\n', '\n', '        // get the new contract-registry\n', '        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\n', '\n', '        // verify that the new contract-registry is different and not zero\n', '        require(newRegistry != registry && address(newRegistry) != address(0), "ERR_INVALID_REGISTRY");\n', '\n', '        // verify that the new contract-registry is pointing to a non-zero contract-registry\n', '        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), "ERR_INVALID_REGISTRY");\n', '\n', '        // save a backup of the current contract-registry before replacing it\n', '        prevRegistry = registry;\n', '\n', '        // replace the current contract-registry with the new contract-registry\n', '        registry = newRegistry;\n', '    }\n', '\n', '    /**\n', '      * @dev restores the previous contract-registry\n', '    */\n', '    function restoreRegistry() public ownerOnly {\n', '        // restore the previous contract-registry\n', '        registry = prevRegistry;\n', '    }\n', '\n', '    /**\n', '      * @dev restricts the permission to update the contract-registry\n', '      *\n', '      * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\n', '    */\n', '    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\n', '        // change the permission to update the contract-registry\n', '        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the address associated with the given contract name\n', '      *\n', '      * @param _contractName    contract name\n', '      *\n', '      * @return contract address\n', '    */\n', '    function addressOf(bytes32 _contractName) internal view returns (address) {\n', '        return registry.addressOf(_contractName);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/ReentrancyGuard.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev ReentrancyGuard\n', '  *\n', '  * The contract provides protection against re-entrancy - calling a function (directly or\n', '  * indirectly) from within itself.\n', '*/\n', 'contract ReentrancyGuard {\n', '    // true while protected code is being executed, false otherwise\n', '    bool private locked = false;\n', '\n', '    /**\n', '      * @dev ensures instantiation only by sub-contracts\n', '    */\n', '    constructor() internal {}\n', '\n', '    // protects a function against reentrancy attacks\n', '    modifier protected() {\n', '        _protected();\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _protected() internal view {\n', '        require(!locked, "ERR_REENTRANCY");\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/SafeMath.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Library for basic math operations with overflow/underflow protection\n', '*/\n', 'library SafeMath {\n', '    /**\n', '      * @dev returns the sum of _x and _y, reverts if the calculation overflows\n', '      *\n', '      * @param _x   value 1\n', '      * @param _y   value 2\n', '      *\n', '      * @return sum\n', '    */\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        uint256 z = _x + _y;\n', '        require(z >= _x, "ERR_OVERFLOW");\n', '        return z;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the difference of _x minus _y, reverts if the calculation underflows\n', '      *\n', '      * @param _x   minuend\n', '      * @param _y   subtrahend\n', '      *\n', '      * @return difference\n', '    */\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        require(_x >= _y, "ERR_UNDERFLOW");\n', '        return _x - _y;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the product of multiplying _x by _y, reverts if the calculation overflows\n', '      *\n', '      * @param _x   factor 1\n', '      * @param _y   factor 2\n', '      *\n', '      * @return product\n', '    */\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        // gas optimization\n', '        if (_x == 0)\n', '            return 0;\n', '\n', '        uint256 z = _x * _y;\n', '        require(z / _x == _y, "ERR_OVERFLOW");\n', '        return z;\n', '    }\n', '\n', '    /**\n', '      * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '      *\n', '      * @param _x   dividend\n', '      * @param _y   divisor\n', '      *\n', '      * @return quotient\n', '    */\n', '    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n', '        require(_y > 0, "ERR_DIVIDE_BY_ZERO");\n', '        uint256 c = _x / _y;\n', '        return c;\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/TokenHandler.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'contract TokenHandler {\n', '    bytes4 private constant APPROVE_FUNC_SELECTOR = bytes4(keccak256("approve(address,uint256)"));\n', '    bytes4 private constant TRANSFER_FUNC_SELECTOR = bytes4(keccak256("transfer(address,uint256)"));\n', '    bytes4 private constant TRANSFER_FROM_FUNC_SELECTOR = bytes4(keccak256("transferFrom(address,address,uint256)"));\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `approve` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _spender approved address\n', '      * @param _value   allowance amount\n', '    */\n', '    function safeApprove(IERC20Token _token, address _spender, uint256 _value) internal {\n', '        (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(APPROVE_FUNC_SELECTOR, _spender, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_APPROVE_FAILED');\n", '    }\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `transfer` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '    */\n', '    function safeTransfer(IERC20Token _token, address _to, uint256 _value) internal {\n', '       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FUNC_SELECTOR, _to, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FAILED');\n", '    }\n', '\n', '    /**\n', "      * @dev executes the ERC20 token's `transferFrom` function and reverts upon failure\n", '      * the main purpose of this function is to prevent a non standard ERC20 token\n', '      * from failing silently\n', '      *\n', '      * @param _token   ERC20 token address\n', '      * @param _from    source address\n', '      * @param _to      target address\n', '      * @param _value   transfer amount\n', '    */\n', '    function safeTransferFrom(IERC20Token _token, address _from, address _to, uint256 _value) internal {\n', '       (bool success, bytes memory data) = address(_token).call(abi.encodeWithSelector(TRANSFER_FROM_FUNC_SELECTOR, _from, _to, _value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ERR_TRANSFER_FROM_FAILED');\n", '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/interfaces/ITokenHolder.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '/*\n', '    Token Holder interface\n', '*/\n', 'interface ITokenHolder is IOwned {\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) external;\n', '}\n', '\n', '// File: solidity/contracts/utility/TokenHolder.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', "  * @dev We consider every contract to be a 'token holder' since it's currently not possible\n", '  * for a contract to deny receiving tokens.\n', '  *\n', "  * The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\n", '  * the owner to send tokens that were sent to the contract by mistake back to their sender.\n', '  *\n', '  * Note that we use the non standard ERC-20 interface which has no return value for transfer\n', '  * in order to support both non standard as well as standard token contracts.\n', '  * see https://github.com/ethereum/solidity/issues/4116\n', '*/\n', 'contract TokenHolder is ITokenHolder, TokenHandler, Owned, Utils {\n', '    /**\n', '      * @dev withdraws tokens held by the contract and sends them to an account\n', '      * can only be called by the owner\n', '      *\n', '      * @param _token   ERC20 token contract address\n', '      * @param _to      account to receive the new amount\n', '      * @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        virtual\n', '        override\n', '        ownerOnly\n', '        validAddress(address(_token))\n', '        validAddress(_to)\n', '        notThis(_to)\n', '    {\n', '        safeTransfer(_token, _to, _amount);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/token/interfaces/IEtherToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/*\n', '    Ether Token interface\n', '*/\n', 'interface IEtherToken is IERC20Token {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 _amount) external;\n', '    function depositTo(address _to) external payable;\n', '    function withdrawTo(address payable _to, uint256 _amount) external;\n', '}\n', '\n', '// File: solidity/contracts/bancorx/interfaces/IBancorX.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IBancorX {\n', '    function token() external view returns (IERC20Token);\n', '    function xTransfer(bytes32 _toBlockchain, bytes32 _to, uint256 _amount, uint256 _id) external;\n', '    function getXTransferAmount(uint256 _xTransferId, address _for) external view returns (uint256);\n', '}\n', '\n', '// File: solidity/contracts/converter/ConverterBase.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '  * @dev ConverterBase\n', '  *\n', '  * The converter contains the main logic for conversions between different ERC20 tokens.\n', '  *\n', '  * It is also the upgradable part of the mechanism (note that upgrades are opt-in).\n', '  *\n', '  * The anchor must be set on construction and cannot be changed afterwards.\n', "  * Wrappers are provided for some of the anchor's functions, for easier access.\n", '  *\n', "  * Once the converter accepts ownership of the anchor, it becomes the anchor's sole controller\n", '  * and can execute any of its functions.\n', '  *\n', '  * To upgrade the converter, anchor ownership must be transferred to a new converter, along with\n', '  * any relevant data.\n', '  *\n', '  * Note that the converter can transfer anchor ownership to a new converter that\n', "  * doesn't allow upgrades anymore, for finalizing the relationship between the converter\n", '  * and the anchor.\n', '  *\n', '  * Converter types (defined as uint16 type) -\n', '  * 0 = liquid token converter\n', '  * 1 = liquidity pool v1 converter\n', '  * 2 = liquidity pool v2 converter\n', '  *\n', "  * Note that converters don't currently support tokens with transfer fees.\n", '*/\n', 'abstract contract ConverterBase is IConverter, TokenHandler, TokenHolder, ContractRegistryClient, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    uint32 internal constant PPM_RESOLUTION = 1000000;\n', '    IERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '\n', '    struct Reserve {\n', '        uint256 balance;    // reserve balance\n', '        uint32 weight;      // reserve weight, represented in ppm, 1-1000000\n', '        bool deprecated1;   // deprecated\n', '        bool deprecated2;   // deprecated\n', '        bool isSet;         // true if the reserve is valid, false otherwise\n', '    }\n', '\n', '    /**\n', '      * @dev version number\n', '    */\n', '    uint16 public constant version = 40;\n', '\n', '    IConverterAnchor public override anchor;            // converter anchor contract\n', '    IWhitelist public override conversionWhitelist;     // whitelist contract with list of addresses that are allowed to use the converter\n', "    IERC20Token[] public reserveTokens;                 // ERC20 standard token addresses (prior version 17, use 'connectorTokens' instead)\n", "    mapping (IERC20Token => Reserve) public reserves;   // reserve token addresses -> reserve data (prior version 17, use 'connectors' instead)\n", '    uint32 public reserveRatio = 0;                     // ratio between the reserves and the market cap, equal to the total reserve weights\n', '    uint32 public override maxConversionFee = 0;        // maximum conversion fee for the lifetime of the contract,\n', '                                                        // represented in ppm, 0...1000000 (0 = no fee, 100 = 0.01%, 1000000 = 100%)\n', '    uint32 public override conversionFee = 0;           // current conversion fee, represented in ppm, 0...maxConversionFee\n', '    bool public constant conversionsEnabled = true;     // deprecated, backward compatibility\n', '\n', '    /**\n', '      * @dev triggered when the converter is activated\n', '      *\n', '      * @param _type        converter type\n', '      * @param _anchor      converter anchor\n', '      * @param _activated   true if the converter was activated, false if it was deactivated\n', '    */\n', '    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\n', '\n', '    /**\n', '      * @dev triggered when a conversion between two tokens occurs\n', '      *\n', '      * @param _fromToken       source ERC20 token\n', '      * @param _toToken         target ERC20 token\n', '      * @param _trader          wallet that initiated the trade\n', '      * @param _amount          amount converted, in the source token\n', '      * @param _return          amount returned, minus conversion fee\n', '      * @param _conversionFee   conversion fee\n', '    */\n', '    event Conversion(\n', '        IERC20Token indexed _fromToken,\n', '        IERC20Token indexed _toToken,\n', '        address indexed _trader,\n', '        uint256 _amount,\n', '        uint256 _return,\n', '        int256 _conversionFee\n', '    );\n', '\n', '    /**\n', '      * @dev triggered when the rate between two tokens in the converter changes\n', '      * note that the event might be dispatched for rate updates between any two tokens in the converter\n', "      * note that prior to version 28, you should use the 'PriceDataUpdate' event instead\n", '      *\n', '      * @param  _token1 address of the first token\n', '      * @param  _token2 address of the second token\n', '      * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\n', '      * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\n', '    */\n', '    event TokenRateUpdate(\n', '        IERC20Token indexed _token1,\n', '        IERC20Token indexed _token2,\n', '        uint256 _rateN,\n', '        uint256 _rateD\n', '    );\n', '\n', '    /**\n', '      * @dev triggered when the conversion fee is updated\n', '      *\n', '      * @param  _prevFee    previous fee percentage, represented in ppm\n', '      * @param  _newFee     new fee percentage, represented in ppm\n', '    */\n', '    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\n', '\n', '    /**\n', '      * @dev used by sub-contracts to initialize a new converter\n', '      *\n', '      * @param  _anchor             anchor governed by the converter\n', '      * @param  _registry           address of a contract registry contract\n', '      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\n', '    */\n', '    constructor(\n', '        IConverterAnchor _anchor,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee\n', '    )\n', '        validAddress(address(_anchor))\n', '        ContractRegistryClient(_registry)\n', '        internal\n', '        validConversionFee(_maxConversionFee)\n', '    {\n', '        anchor = _anchor;\n', '        maxConversionFee = _maxConversionFee;\n', '    }\n', '\n', '    // ensures that the converter is active\n', '    modifier active() {\n', '        _active();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _active() internal view {\n', '        require(isActive(), "ERR_INACTIVE");\n', '    }\n', '\n', '    // ensures that the converter is not active\n', '    modifier inactive() {\n', '        _inactive();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _inactive() internal view {\n', '        require(!isActive(), "ERR_ACTIVE");\n', '    }\n', '\n', '    // validates a reserve token address - verifies that the address belongs to one of the reserve tokens\n', '    modifier validReserve(IERC20Token _address) {\n', '        _validReserve(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validReserve(IERC20Token _address) internal view {\n', '        require(reserves[_address].isSet, "ERR_INVALID_RESERVE");\n', '    }\n', '\n', '    // validates conversion fee\n', '    modifier validConversionFee(uint32 _conversionFee) {\n', '        _validConversionFee(_conversionFee);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validConversionFee(uint32 _conversionFee) internal pure {\n', '        require(_conversionFee <= PPM_RESOLUTION, "ERR_INVALID_CONVERSION_FEE");\n', '    }\n', '\n', '    // validates reserve weight\n', '    modifier validReserveWeight(uint32 _weight) {\n', '        _validReserveWeight(_weight);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validReserveWeight(uint32 _weight) internal pure {\n', '        require(_weight > 0 && _weight <= PPM_RESOLUTION, "ERR_INVALID_RESERVE_WEIGHT");\n', '    }\n', '\n', '    // overrides interface declaration\n', '    function converterType() public pure virtual override returns (uint16);\n', '\n', '    // overrides interface declaration\n', '    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256, uint256);\n', '\n', '    /**\n', '      * @dev deposits ether\n', '      * can only be called if the converter has an ETH reserve\n', '    */\n', '    receive() external override payable {\n', '        require(reserves[ETH_RESERVE_ADDRESS].isSet, "ERR_INVALID_RESERVE"); // require(hasETHReserve(), "ERR_INVALID_RESERVE");\n', '        // a workaround for a problem when running solidity-coverage\n', '        // see https://github.com/sc-forks/solidity-coverage/issues/487\n', '    }\n', '\n', '    /**\n', '      * @dev withdraws ether\n', '      * can only be called by the owner if the converter is inactive or by upgrader contract\n', '      * can only be called after the upgrader contract has accepted the ownership of this contract\n', '      * can only be called if the converter has an ETH reserve\n', '      *\n', '      * @param _to  address to send the ETH to\n', '    */\n', '    function withdrawETH(address payable _to)\n', '        public\n', '        override\n', '        virtual\n', '        protected\n', '        ownerOnly\n', '        validReserve(ETH_RESERVE_ADDRESS)\n', '    {\n', '        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\n', '\n', '        // verify that the converter is inactive or that the owner is the upgrader contract\n', '        require(!isActive() || owner == converterUpgrader, "ERR_ACCESS_DENIED");\n', '        _to.transfer(address(this).balance);\n', '\n', '        // sync the ETH reserve balance\n', '        syncReserveBalance(ETH_RESERVE_ADDRESS);\n', '    }\n', '\n', '    /**\n', '      * @dev checks whether or not the converter version is 28 or higher\n', '      *\n', '      * @return true, since the converter version is 28 or higher\n', '    */\n', '    function isV28OrHigher() public pure returns (bool) {\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @dev allows the owner to update & enable the conversion whitelist contract address\n', '      * when set, only addresses that are whitelisted are actually allowed to use the converter\n', '      * note that the whitelist check is actually done by the BancorNetwork contract\n', '      *\n', '      * @param _whitelist    address of a whitelist contract\n', '    */\n', '    function setConversionWhitelist(IWhitelist _whitelist)\n', '        public\n', '        override\n', '        ownerOnly\n', '        notThis(address(_whitelist))\n', '    {\n', '        conversionWhitelist = _whitelist;\n', '    }\n', '\n', '    /**\n', '      * @dev returns true if the converter is active, false otherwise\n', '      *\n', '      * @return true if the converter is active, false otherwise\n', '    */\n', '    function isActive() public view virtual override returns (bool) {\n', '        return anchor.owner() == address(this);\n', '    }\n', '\n', '    /**\n', '      * @dev transfers the anchor ownership\n', '      * the new owner needs to accept the transfer\n', '      * can only be called by the converter upgrder while the upgrader is the owner\n', "      * note that prior to version 28, you should use 'transferAnchorOwnership' instead\n", '      *\n', '      * @param _newOwner    new token owner\n', '    */\n', '    function transferAnchorOwnership(address _newOwner)\n', '        public\n', '        virtual\n', '        override\n', '        ownerOnly\n', '        only(CONVERTER_UPGRADER)\n', '    {\n', '        anchor.transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '      * @dev accepts ownership of the anchor after an ownership transfer\n', '      * most converters are also activated as soon as they accept the anchor ownership\n', '      * can only be called by the contract owner\n', "      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\n", '    */\n', '    function acceptAnchorOwnership() public virtual override ownerOnly {\n', '        // verify the the converter has at least one reserve\n', '        require(reserveTokenCount() > 0, "ERR_INVALID_RESERVE_COUNT");\n', '        anchor.acceptOwnership();\n', '        syncReserveBalances();\n', '    }\n', '\n', '    /**\n', '      * @dev updates the current conversion fee\n', '      * can only be called by the contract owner\n', '      *\n', '      * @param _conversionFee new conversion fee, represented in ppm\n', '    */\n', '    function setConversionFee(uint32 _conversionFee) public override ownerOnly {\n', '        require(_conversionFee <= maxConversionFee, "ERR_INVALID_CONVERSION_FEE");\n', '        emit ConversionFeeUpdate(conversionFee, _conversionFee);\n', '        conversionFee = _conversionFee;\n', '    }\n', '\n', '    /**\n', '      * @dev withdraws tokens held by the converter and sends them to an account\n', '      * can only be called by the owner\n', '      * note that reserve tokens can only be withdrawn by the owner while the converter is inactive\n', '      * unless the owner is the converter upgrader contract\n', '      *\n', '      * @param _token   ERC20 token contract address\n', '      * @param _to      account to receive the new amount\n', '      * @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        virtual\n', '        override(IConverter, TokenHolder)\n', '        protected\n', '        ownerOnly\n', '    {\n', '        address converterUpgrader = addressOf(CONVERTER_UPGRADER);\n', '\n', '        // if the token is not a reserve token, allow withdrawal\n', '        // otherwise verify that the converter is inactive or that the owner is the upgrader contract\n', '        require(!reserves[_token].isSet || !isActive() || owner == converterUpgrader, "ERR_ACCESS_DENIED");\n', '        super.withdrawTokens(_token, _to, _amount);\n', '\n', '        // if the token is a reserve token, sync the reserve balance\n', '        if (reserves[_token].isSet)\n', '            syncReserveBalance(_token);\n', '    }\n', '\n', '    /**\n', '      * @dev upgrades the converter to the latest version\n', '      * can only be called by the owner\n', '      * note that the owner needs to call acceptOwnership on the new converter after the upgrade\n', '    */\n', '    function upgrade() public ownerOnly {\n', '        IConverterUpgrader converterUpgrader = IConverterUpgrader(addressOf(CONVERTER_UPGRADER));\n', '\n', '        // trigger de-activation event\n', '        emit Activation(converterType(), anchor, false);\n', '\n', '        transferOwnership(address(converterUpgrader));\n', '        converterUpgrader.upgrade(version);\n', '        acceptOwnership();\n', '    }\n', '\n', '    /**\n', '      * @dev returns the number of reserve tokens defined\n', "      * note that prior to version 17, you should use 'connectorTokenCount' instead\n", '      *\n', '      * @return number of reserve tokens\n', '    */\n', '    function reserveTokenCount() public view returns (uint16) {\n', '        return uint16(reserveTokens.length);\n', '    }\n', '\n', '    /**\n', '      * @dev defines a new reserve token for the converter\n', '      * can only be called by the owner while the converter is inactive\n', '      *\n', '      * @param _token   address of the reserve token\n', '      * @param _weight  reserve weight, represented in ppm, 1-1000000\n', '    */\n', '    function addReserve(IERC20Token _token, uint32 _weight)\n', '        public\n', '        virtual\n', '        override\n', '        ownerOnly\n', '        inactive\n', '        validAddress(address(_token))\n', '        notThis(address(_token))\n', '        validReserveWeight(_weight)\n', '    {\n', '        // validate input\n', '        require(address(_token) != address(anchor) && !reserves[_token].isSet, "ERR_INVALID_RESERVE");\n', '        require(_weight <= PPM_RESOLUTION - reserveRatio, "ERR_INVALID_RESERVE_WEIGHT");\n', '        require(reserveTokenCount() < uint16(-1), "ERR_INVALID_RESERVE_COUNT");\n', '\n', '        Reserve storage newReserve = reserves[_token];\n', '        newReserve.balance = 0;\n', '        newReserve.weight = _weight;\n', '        newReserve.isSet = true;\n', '        reserveTokens.push(_token);\n', '        reserveRatio += _weight;\n', '    }\n', '\n', '    /**\n', "      * @dev returns the reserve's weight\n", '      * added in version 28\n', '      *\n', '      * @param _reserveToken    reserve token contract address\n', '      *\n', '      * @return reserve weight\n', '    */\n', '    function reserveWeight(IERC20Token _reserveToken)\n', '        public\n', '        view\n', '        validReserve(_reserveToken)\n', '        returns (uint32)\n', '    {\n', '        return reserves[_reserveToken].weight;\n', '    }\n', '\n', '    /**\n', "      * @dev returns the reserve's balance\n", "      * note that prior to version 17, you should use 'getConnectorBalance' instead\n", '      *\n', '      * @param _reserveToken    reserve token contract address\n', '      *\n', '      * @return reserve balance\n', '    */\n', '    function reserveBalance(IERC20Token _reserveToken)\n', '        public\n', '        override\n', '        view\n', '        validReserve(_reserveToken)\n', '        returns (uint256)\n', '    {\n', '        return reserves[_reserveToken].balance;\n', '    }\n', '\n', '    /**\n', '      * @dev checks whether or not the converter has an ETH reserve\n', '      *\n', '      * @return true if the converter has an ETH reserve, false otherwise\n', '    */\n', '    function hasETHReserve() public view returns (bool) {\n', '        return reserves[ETH_RESERVE_ADDRESS].isSet;\n', '    }\n', '\n', '    /**\n', '      * @dev converts a specific amount of source tokens to target tokens\n', '      * can only be called by the bancor network contract\n', '      *\n', '      * @param _sourceToken source ERC20 token\n', '      * @param _targetToken target ERC20 token\n', '      * @param _amount      amount of tokens to convert (in units of the source token)\n', '      * @param _trader      address of the caller who executed the conversion\n', '      * @param _beneficiary wallet to receive the conversion result\n', '      *\n', '      * @return amount of tokens received (in units of the target token)\n', '    */\n', '    function convert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\n', '        public\n', '        override\n', '        payable\n', '        protected\n', '        only(BANCOR_NETWORK)\n', '        returns (uint256)\n', '    {\n', '        // validate input\n', '        require(_sourceToken != _targetToken, "ERR_SAME_SOURCE_TARGET");\n', '\n', '        // if a whitelist is set, verify that both and trader and the beneficiary are whitelisted\n', '        require(address(conversionWhitelist) == address(0) ||\n', '                (conversionWhitelist.isWhitelisted(_trader) && conversionWhitelist.isWhitelisted(_beneficiary)),\n', '                "ERR_NOT_WHITELISTED");\n', '\n', '        return doConvert(_sourceToken, _targetToken, _amount, _trader, _beneficiary);\n', '    }\n', '\n', '    /**\n', '      * @dev converts a specific amount of source tokens to target tokens\n', '      * called by ConverterBase and allows the inherited contracts to implement custom conversion logic\n', '      *\n', '      * @param _sourceToken source ERC20 token\n', '      * @param _targetToken target ERC20 token\n', '      * @param _amount      amount of tokens to convert (in units of the source token)\n', '      * @param _trader      address of the caller who executed the conversion\n', '      * @param _beneficiary wallet to receive the conversion result\n', '      *\n', '      * @return amount of tokens received (in units of the target token)\n', '    */\n', '    function doConvert(\n', '        IERC20Token _sourceToken,\n', '        IERC20Token _targetToken,\n', '        uint256 _amount,\n', '        address _trader,\n', '        address payable _beneficiary)\n', '        internal\n', '        virtual\n', '        returns (uint256);\n', '\n', '    /**\n', '      * @dev returns the conversion fee for a given target amount\n', '      *\n', '      * @param _targetAmount  target amount\n', '      *\n', '      * @return conversion fee\n', '    */\n', '    function calculateFee(uint256 _targetAmount) internal view returns (uint256) {\n', '        return _targetAmount.mul(conversionFee).div(PPM_RESOLUTION);\n', '    }\n', '\n', '    /**\n', '      * @dev syncs the stored reserve balance for a given reserve with the real reserve balance\n', '      *\n', '      * @param _reserveToken    address of the reserve token\n', '    */\n', '    function syncReserveBalance(IERC20Token _reserveToken) internal validReserve(_reserveToken) {\n', '        if (_reserveToken == ETH_RESERVE_ADDRESS)\n', '            reserves[_reserveToken].balance = address(this).balance;\n', '        else\n', '            reserves[_reserveToken].balance = _reserveToken.balanceOf(address(this));\n', '    }\n', '\n', '    /**\n', '      * @dev syncs all stored reserve balances\n', '    */\n', '    function syncReserveBalances() internal {\n', '        uint256 reserveCount = reserveTokens.length;\n', '        for (uint256 i = 0; i < reserveCount; i++)\n', '            syncReserveBalance(reserveTokens[i]);\n', '    }\n', '\n', '    /**\n', '      * @dev helper, dispatches the Conversion event\n', '      *\n', '      * @param _sourceToken     source ERC20 token\n', '      * @param _targetToken     target ERC20 token\n', '      * @param _trader          address of the caller who executed the conversion\n', '      * @param _amount          amount purchased/sold (in the source token)\n', '      * @param _returnAmount    amount returned (in the target token)\n', '    */\n', '    function dispatchConversionEvent(\n', '        IERC20Token _sourceToken,\n', '        IERC20Token _targetToken,\n', '        address _trader,\n', '        uint256 _amount,\n', '        uint256 _returnAmount,\n', '        uint256 _feeAmount)\n', '        internal\n', '    {\n', '        // fee amount is converted to 255 bits -\n', '        // negative amount means the fee is taken from the source token, positive amount means its taken from the target token\n', '        // currently the fee is always taken from the target token\n', "        // since we convert it to a signed number, we first ensure that it's capped at 255 bits to prevent overflow\n", '        assert(_feeAmount < 2 ** 255);\n', '        emit Conversion(_sourceToken, _targetToken, _trader, _amount, _returnAmount, int256(_feeAmount));\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated since version 28, backward compatibility - use only for earlier versions\n', '    */\n', '    function token() public view override returns (IConverterAnchor) {\n', '        return anchor;\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function transferTokenOwnership(address _newOwner) public override ownerOnly {\n', '        transferAnchorOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function acceptTokenOwnership() public override ownerOnly {\n', '        acceptAnchorOwnership();\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function connectors(IERC20Token _address) public view override returns (uint256, uint32, bool, bool, bool) {\n', '        Reserve memory reserve = reserves[_address];\n', '        return(reserve.balance, reserve.weight, false, false, reserve.isSet);\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function connectorTokens(uint256 _index) public view override returns (IERC20Token) {\n', '        return ConverterBase.reserveTokens[_index];\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function connectorTokenCount() public view override returns (uint16) {\n', '        return reserveTokenCount();\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function getConnectorBalance(IERC20Token _connectorToken) public view override returns (uint256) {\n', '        return reserveBalance(_connectorToken);\n', '    }\n', '\n', '    /**\n', '      * @dev deprecated, backward compatibility\n', '    */\n', '    function getReturn(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view returns (uint256, uint256) {\n', '        return targetAmountAndFee(_sourceToken, _targetToken, _amount);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/token/interfaces/IDSToken.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/*\n', '    DSToken interface\n', '*/\n', 'interface IDSToken is IConverterAnchor, IERC20Token {\n', '    function issue(address _to, uint256 _amount) external;\n', '    function destroy(address _from, uint256 _amount) external;\n', '}\n', '\n', '// File: solidity/contracts/converter/types/liquid-token/LiquidTokenConverter.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', '  * @dev Liquid Token Converter\n', '  *\n', '  * The liquid token converter is a specialized version of a converter that manages a liquid token.\n', '  *\n', '  * The converters govern a token with a single reserve and allow converting between the two.\n', '  * Liquid tokens usually have fractional reserve (reserve ratio smaller than 100%).\n', '*/\n', 'contract LiquidTokenConverter is ConverterBase {\n', '    /**\n', '      * @dev initializes a new LiquidTokenConverter instance\n', '      *\n', '      * @param  _token              liquid token governed by the converter\n', '      * @param  _registry           address of a contract registry contract\n', '      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\n', '    */\n', '    constructor(\n', '        IDSToken _token,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee\n', '    )\n', '        ConverterBase(_token, _registry, _maxConversionFee)\n', '        public\n', '    {\n', '    }\n', '\n', '    /**\n', '      * @dev returns the converter type\n', '      *\n', '      * @return see the converter types in the the main contract doc\n', '    */\n', '    function converterType() public pure override returns (uint16) {\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '      * @dev accepts ownership of the anchor after an ownership transfer\n', '      * also activates the converter\n', '      * can only be called by the contract owner\n', "      * note that prior to version 28, you should use 'acceptTokenOwnership' instead\n", '    */\n', '    function acceptAnchorOwnership() public override ownerOnly {\n', '        super.acceptAnchorOwnership();\n', '\n', '        emit Activation(converterType(), anchor, true);\n', '    }\n', '\n', '    /**\n', '      * @dev defines the reserve token for the converter\n', '      * can only be called by the owner while the converter is inactive and the\n', "      * reserve wasn't defined yet\n", '      *\n', '      * @param _token   address of the reserve token\n', '      * @param _weight  reserve weight, represented in ppm, 1-1000000\n', '    */\n', '    function addReserve(IERC20Token _token, uint32 _weight) public override ownerOnly {\n', "        // verify that the converter doesn't have a reserve yet\n", '        require(reserveTokenCount() == 0, "ERR_INVALID_RESERVE_COUNT");\n', '        super.addReserve(_token, _weight);\n', '    }\n', '\n', '    /**\n', '      * @dev returns the expected target amount of converting the source token to the\n', '      * target token along with the fee\n', '      *\n', '      * @param _sourceToken contract address of the source token\n', '      * @param _targetToken contract address of the target token\n', '      * @param _amount      amount of tokens received from the user\n', '      *\n', '      * @return expected target amount\n', '      * @return expected fee\n', '    */\n', '    function targetAmountAndFee(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount) public view override returns (uint256, uint256) {\n', '        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet)\n', '            return purchaseTargetAmount(_amount);\n', '        if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet)\n', '            return saleTargetAmount(_amount);\n', '\n', '        // invalid input\n', '        revert("ERR_INVALID_TOKEN");\n', '    }\n', '\n', '    /**\n', '      * @dev converts between the liquid token and its reserve\n', '      * can only be called by the bancor network contract\n', '      *\n', '      * @param _sourceToken source ERC20 token\n', '      * @param _targetToken target ERC20 token\n', '      * @param _amount      amount of tokens to convert (in units of the source token)\n', '      * @param _trader      address of the caller who executed the conversion\n', '      * @param _beneficiary wallet to receive the conversion result\n', '      *\n', '      * @return amount of tokens received (in units of the target token)\n', '    */\n', '    function doConvert(IERC20Token _sourceToken, IERC20Token _targetToken, uint256 _amount, address _trader, address payable _beneficiary)\n', '        internal\n', '        override\n', '        returns (uint256)\n', '    {\n', '        uint256 targetAmount;\n', '        IERC20Token reserveToken;\n', '\n', '        if (_targetToken == IDSToken(address(anchor)) && reserves[_sourceToken].isSet) {\n', '            reserveToken = _sourceToken;\n', '            targetAmount = buy(_amount, _trader, _beneficiary);\n', '        }\n', '        else if (_sourceToken == IDSToken(address(anchor)) && reserves[_targetToken].isSet) {\n', '            reserveToken = _targetToken;\n', '            targetAmount = sell(_amount, _trader, _beneficiary);\n', '        }\n', '        else {\n', '            // invalid input\n', '            revert("ERR_INVALID_TOKEN");\n', '        }\n', '\n', '        // dispatch rate update for the liquid token\n', '        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n', '        uint32 reserveWeight = reserves[reserveToken].weight;\n', '        emit TokenRateUpdate(IDSToken(address(anchor)), reserveToken, reserveBalance(reserveToken).mul(PPM_RESOLUTION), totalSupply.mul(reserveWeight));\n', '\n', '        return targetAmount;\n', '    }\n', '\n', '    /**\n', '      * @dev returns the expected target amount of buying with a given amount of tokens\n', '      *\n', '      * @param _amount  amount of reserve tokens to get the target amount for\n', '      *\n', '      * @return amount of liquid tokens that the user will receive\n', '      * @return amount of liquid tokens that the user will pay as fee\n', '    */\n', '    function purchaseTargetAmount(uint256 _amount)\n', '        internal\n', '        view\n', '        active\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n', '        IERC20Token reserveToken = reserveTokens[0];\n', '\n', '        // if the current supply is zero, then return the input amount divided by the normalized reserve-weight\n', '        if (totalSupply == 0)\n', '            return (_amount.mul(PPM_RESOLUTION).div(reserves[reserveToken].weight), 0);\n', '\n', '        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).purchaseTargetAmount(\n', '            totalSupply,\n', '            reserveBalance(reserveToken),\n', '            reserves[reserveToken].weight,\n', '            _amount\n', '        );\n', '\n', '        // return the amount minus the conversion fee and the conversion fee\n', '        uint256 fee = calculateFee(amount);\n', '        return (amount - fee, fee);\n', '    }\n', '\n', '    /**\n', '      * @dev returns the expected target amount of selling a given amount of tokens\n', '      *\n', '      * @param _amount  amount of liquid tokens to get the target amount for\n', '      *\n', '      * @return expected reserve tokens\n', '      * @return expected fee\n', '    */\n', '    function saleTargetAmount(uint256 _amount)\n', '        internal\n', '        view\n', '        active\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n', '\n', '        IERC20Token reserveToken = reserveTokens[0];\n', '\n', '        // if selling the entire supply, then return the entire reserve\n', '        if (totalSupply == _amount)\n', '            return (reserveBalance(reserveToken), 0);\n', '\n', '        uint256 amount = IBancorFormula(addressOf(BANCOR_FORMULA)).saleTargetAmount(\n', '            totalSupply,\n', '            reserveBalance(reserveToken),\n', '            reserves[reserveToken].weight,\n', '            _amount\n', '        );\n', '\n', '        // return the amount minus the conversion fee and the conversion fee\n', '        uint256 fee = calculateFee(amount);\n', '        return (amount - fee, fee);\n', '    }\n', '\n', '    /**\n', '      * @dev buys the liquid token by depositing in its reserve\n', '      *\n', '      * @param _amount      amount of reserve token to buy the token for\n', '      * @param _trader      address of the caller who executed the conversion\n', '      * @param _beneficiary wallet to receive the conversion result\n', '      *\n', '      * @return amount of liquid tokens received\n', '    */\n', '    function buy(uint256 _amount, address _trader, address _beneficiary) internal returns (uint256) {\n', '        // get expected target amount and fee\n', '        (uint256 amount, uint256 fee) = purchaseTargetAmount(_amount);\n', '\n', '        // ensure the trade gives something in return\n', '        require(amount != 0, "ERR_ZERO_TARGET_AMOUNT");\n', '\n', '        IERC20Token reserveToken = reserveTokens[0];\n', '\n', '        // ensure that the input amount was already deposited\n', '        if (reserveToken == ETH_RESERVE_ADDRESS)\n', '            require(msg.value == _amount, "ERR_ETH_AMOUNT_MISMATCH");\n', '        else\n', '            require(msg.value == 0 && reserveToken.balanceOf(address(this)).sub(reserveBalance(reserveToken)) >= _amount, "ERR_INVALID_AMOUNT");\n', '\n', '        // sync the reserve balance\n', '        syncReserveBalance(reserveToken);\n', '\n', '        // issue new funds to the beneficiary in the liquid token\n', '        IDSToken(address(anchor)).issue(_beneficiary, amount);\n', '\n', '        // dispatch the conversion event\n', '        dispatchConversionEvent(reserveToken, IDSToken(address(anchor)), _trader, _amount, amount, fee);\n', '\n', '        return amount;\n', '    }\n', '\n', '    /**\n', '      * @dev sells the liquid token by withdrawing from its reserve\n', '      *\n', '      * @param _amount      amount of liquid tokens to sell\n', '      * @param _trader      address of the caller who executed the conversion\n', '      * @param _beneficiary wallet to receive the conversion result\n', '      *\n', '      * @return amount of reserve tokens received\n', '    */\n', '    function sell(uint256 _amount, address _trader, address payable _beneficiary) internal returns (uint256) {\n', '        // ensure that the input amount was already deposited\n', '        require(_amount <= IDSToken(address(anchor)).balanceOf(address(this)), "ERR_INVALID_AMOUNT");\n', '\n', '        // get expected target amount and fee\n', '        (uint256 amount, uint256 fee) = saleTargetAmount(_amount);\n', '\n', '        // ensure the trade gives something in return\n', '        require(amount != 0, "ERR_ZERO_TARGET_AMOUNT");\n', '\n', '        IERC20Token reserveToken = reserveTokens[0];\n', '\n', '        // ensure that the trade will only deplete the reserve balance if the total supply is depleted as well\n', '        uint256 tokenSupply = IDSToken(address(anchor)).totalSupply();\n', '        uint256 rsvBalance = reserveBalance(reserveToken);\n', '        assert(amount < rsvBalance || (amount == rsvBalance && _amount == tokenSupply));\n', '\n', '        // destroy the tokens from the converter balance in the liquid token\n', '        IDSToken(address(anchor)).destroy(address(this), _amount);\n', '\n', '        // update the reserve balance\n', '        reserves[reserveToken].balance = reserves[reserveToken].balance.sub(amount);\n', '\n', '        // transfer funds to the beneficiary in the reserve token\n', '        if (reserveToken == ETH_RESERVE_ADDRESS)\n', '            _beneficiary.transfer(amount);\n', '        else\n', '            safeTransfer(reserveToken, _beneficiary, amount);\n', '\n', '        // dispatch the conversion event\n', '        dispatchConversionEvent(IDSToken(address(anchor)), reserveToken, _trader, _amount, amount, fee);\n', '\n', '        return amount;\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', '  * @dev Liquid Token Converter\n', '  *\n', '  * The dynamic liquid token converter is a specialized version of a converter that manages a liquid token\n', '  * and allows for a reduction in reserve weight within a predefined set of boundaries.\n', '  *\n', '  * The converters govern a token with a single reserve and allow converting between the two.\n', '  * Liquid tokens usually have fractional reserve (reserve ratio smaller than 100%).\n', '  * The weight can be reduced by the defined stepWeight any time the defined marketCapThreshold\n', '  * has been reached.\n', '*/\n', 'contract DynamicLiquidTokenConverter is LiquidTokenConverter {\n', '    uint32 public minimumWeight = 30000;\n', '    uint32 public stepWeight = 10000;\n', '    uint256 public marketCapThreshold = 10000 ether;\n', '    uint256 lastWeightAdjustmentMarketCap = 0;\n', '\n', '    event ReserveTokenWeightUpdate(uint32 _prevWeight, uint32 _newWeight, uint256 _percentage, uint256 _balance);\n', '\n', '    /**\n', '      * @dev initializes a new DyamicLiquidTokenConverter instance\n', '      *\n', '      * @param  _token              liquid token governed by the converter\n', '      * @param  _registry           address of a contract registry contract\n', '      * @param  _maxConversionFee   maximum conversion fee, represented in ppm\n', '    */\n', '    constructor(\n', '        IDSToken _token,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee\n', '    )\n', '        LiquidTokenConverter(_token, _registry, _maxConversionFee)\n', '        public\n', '    {\n', '    }\n', '\n', '    /**\n', '      * @dev updates the market cap threshold\n', '      * can only be called by the owner while inactive\n', '      * \n', '      * @param _marketCapThreshold new threshold\n', '    */\n', '    function setMarketCapThreshold(uint256 _marketCapThreshold)\n', '        public\n', '        ownerOnly\n', '        inactive\n', '    {\n', '        marketCapThreshold = _marketCapThreshold;\n', '    }\n', '\n', '    /**\n', '      * @dev updates the current minimum weight\n', '      * can only be called by the owner while inactive\n', '      * \n', '      * @param _minimumWeight new minimum weight, represented in ppm\n', '    */\n', '    function setMinimumWeight(uint32 _minimumWeight)\n', '        public\n', '        ownerOnly\n', '        inactive\n', '    {\n', '        minimumWeight = _minimumWeight;\n', '    }\n', '\n', '    /**\n', '      * @dev updates the current step weight\n', '      * can only be called by the owner while inactive\n', '      * \n', '      * @param _stepWeight new step weight, represented in ppm\n', '    */\n', '    function setStepWeight(uint32 _stepWeight)\n', '        public\n', '        ownerOnly\n', '        inactive\n', '    {\n', '        stepWeight = _stepWeight;\n', '    }\n', '\n', '    /**\n', '      * @dev updates the token reserve weight\n', '      * can only be called by the owner\n', '      * \n', '      * @param _reserveToken    address of the reserve token\n', '    */\n', '    function reduceWeight(IERC20Token _reserveToken)\n', '        public\n', '        validReserve(_reserveToken)\n', '        ownerOnly\n', '    {\n', '        uint256 currentMarketCap = getMarketCap(_reserveToken);\n', '        require(currentMarketCap > (lastWeightAdjustmentMarketCap.add(marketCapThreshold)), "ERR_MARKET_CAP_BELOW_THRESHOLD");\n', '\n', '        Reserve storage reserve = reserves[_reserveToken];\n', '        uint256 newWeight = uint256(reserve.weight).sub(stepWeight);\n', '        uint32 oldWeight = reserve.weight;\n', '        require(newWeight >= minimumWeight, "ERR_INVALID_RESERVE_WEIGHT");\n', '\n', '        uint256 percentage = uint256(PPM_RESOLUTION).sub(newWeight.mul(1e6).div(reserve.weight));\n', '\n', '        uint32 weight = uint32(newWeight);\n', '        reserve.weight = weight;\n', '        reserveRatio = weight;\n', '\n', '        uint256 balance = reserveBalance(_reserveToken).mul(percentage).div(1e6);\n', '\n', '        if (_reserveToken == ETH_RESERVE_ADDRESS)\n', '          msg.sender.transfer(balance);\n', '        else\n', '          safeTransfer(_reserveToken, msg.sender, balance);\n', '\n', '        lastWeightAdjustmentMarketCap = currentMarketCap;\n', '\n', '        syncReserveBalance(_reserveToken);\n', '\n', '        emit ReserveTokenWeightUpdate(oldWeight, weight, percentage, reserve.balance);\n', '    }\n', '\n', '    function getMarketCap(IERC20Token _reserveToken)\n', '        public\n', '        view\n', '        returns(uint256)\n', '    {\n', '        Reserve storage reserve = reserves[_reserveToken];\n', '        return reserveBalance(_reserveToken).mul(1e6).div(reserve.weight);\n', '    }\n', '\n', '    /**\n', '      * Upgrade functions. Overriden to allow upgrades by owner.\n', '    **/\n', '\n', '    /**\n', '      * @dev withdraws ether\n', '      * can only be called by the owner\n', '      * can only be called if the converter has an ETH reserve\n', '      *\n', '      * @param _to  address to send the ETH to\n', '    */\n', '    function withdrawETH(address payable _to)\n', '        public\n', '        override\n', '        protected\n', '        ownerOnly\n', '        validReserve(ETH_RESERVE_ADDRESS)\n', '    {\n', '        _to.transfer(address(this).balance);\n', '\n', '        // sync the ETH reserve balance\n', '        syncReserveBalance(ETH_RESERVE_ADDRESS);\n', '    }\n', '\n', '    /**\n', '      * @dev transfers the anchor ownership\n', '      * the new owner needs to accept the transfer\n', '      *\n', '      * @param _newOwner    new token owner\n', '    */\n', '    function transferAnchorOwnership(address _newOwner)\n', '        public\n', '        override\n', '        ownerOnly\n', '    {\n', '        anchor.transferOwnership(_newOwner);\n', '    }\n', '\n', '    /**\n', '      * @dev withdraws tokens held by the converter and sends them to an account\n', '      * can only be called by the owner\n', '      *\n', '      * @param _token   ERC20 token contract address\n', '      * @param _to      account to receive the new amount\n', '      * @param _amount  amount to withdraw\n', '    */\n', '    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\n', '        public\n', '        override\n', '        protected\n', '        ownerOnly\n', '    {\n', '        TokenHolder.withdrawTokens(_token, _to, _amount);\n', '\n', '        // if the token is a reserve token, sync the reserve balance\n', '        if (reserves[_token].isSet)\n', '            syncReserveBalance(_token);\n', '    }\n', '\n', '}']