['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-15\n', '*/\n', '\n', 'pragma solidity 0.5.8; \n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function decimals() public view returns (uint8);\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address public owner;\n', '    address public proposedOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Has to be owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _proposedOwner) public onlyOwner {\n', '        require(msg.sender != _proposedOwner, "Has to be diff than current owner");\n', '        proposedOwner = _proposedOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '        require(msg.sender == proposedOwner, "Has to be the proposed owner");\n', '        emit OwnershipTransferred(owner, proposedOwner);\n', '        owner = proposedOwner;\n', '        proposedOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is not paused.\n', '    */\n', '    modifier whenNotPaused() {\n', '        require(!paused, "Has to be unpaused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier to make a function callable only when the contract is paused.\n', '    */\n', '    modifier whenPaused() {\n', '        require(paused, "Has to be paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to pause, triggers stopped state\n', '    */\n', '    function pause() onlyOwner whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    /**\n', '    * @dev called by the owner to unpause, returns to normal state\n', '    */\n', '    function unpause() onlyOwner whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', '\n', 'contract Whitelist is Ownable {\n', '\n', '    mapping(address => bool) public whitelist;\n', '    address[] public whitelistedAddresses;\n', '    bool public hasWhitelisting = false;\n', '\n', '    event AddedToWhitelist(address[] indexed accounts);\n', '    event RemovedFromWhitelist(address indexed account);\n', '\n', '    modifier onlyWhitelisted() {\n', '        if(hasWhitelisting){\n', '            require(isWhitelisted(msg.sender));\n', '        }\n', '        _;\n', '    }\n', '    \n', '    constructor (bool _hasWhitelisting) public{\n', '        hasWhitelisting = _hasWhitelisting;\n', '    }\n', '\n', '    function add(address[] memory _addresses) public onlyOwner {\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            require(whitelist[_addresses[i]] != true);\n', '            whitelist[_addresses[i]] = true;\n', '            whitelistedAddresses.push(_addresses[i]);\n', '        }\n', '        emit AddedToWhitelist(_addresses);\n', '    }\n', '\n', '    function remove(address _address, uint256 _index) public onlyOwner {\n', '        require(_address == whitelistedAddresses[_index]);\n', '        whitelist[_address] = false;\n', '        delete whitelistedAddresses[_index];\n', '        emit RemovedFromWhitelist(_address);\n', '    }\n', '\n', '    function getWhitelistedAddresses() public view returns(address[] memory) {\n', '        return whitelistedAddresses;\n', '    } \n', '\n', '    function isWhitelisted(address _address) public view returns(bool) {\n', '        return whitelist[_address];\n', '    }\n', '}\n', '\n', 'contract FixedSwap is Pausable, Whitelist {\n', '    using SafeMath for uint256;\n', '    uint256 increment = 0;\n', '\n', '    mapping(uint256 => Purchase) public purchases; /* Purchasers mapping */\n', '    address[] public buyers; /* Current Buyers Addresses */\n', '    uint256[] public purchaseIds; /* All purchaseIds */\n', '    mapping(address => uint256[]) public myPurchases; /* Purchasers mapping */\n', '\n', '    ERC20 public erc20;\n', '    bool public isSaleFunded = false;\n', '    uint public decimals = 0;\n', '    bool public unsoldTokensReedemed = false;\n', '    uint256 public tradeValue; /* Price in Wei */\n', '    uint256 public startDate; /* Start Date  */\n', '    uint256 public endDate;  /* End Date  */\n', '    uint256 public individualMinimumAmount = 0;  /* Minimum Amount Per Address */\n', '    uint256 public individualMaximumAmount = 0;  /* Minimum Amount Per Address */\n', '    uint256 public minimumRaise = 0;  /* Minimum Amount of Tokens that have to be sold */\n', '    uint256 public tokensAllocated = 0; /* Tokens Available for Allocation - Dynamic */\n', '    uint256 public tokensForSale = 0; /* Tokens Available for Sale */\n', '    bool    public isTokenSwapAtomic; /* Make token release atomic or not */\n', '    address payable public FEE_ADDRESS = 0xAEb39b67F27b641Ef9F95fB74F1A46b1EE4Efc83; /* Default Address for Fee Percentage */\n', '    uint256 public feePercentage = 1; /* Default Fee 1% */\n', '\n', '    struct Purchase {\n', '        uint256 amount;\n', '        address purchaser;\n', '        uint256 ethAmount;\n', '        uint256 timestamp;\n', '        bool wasFinalized /* Confirm the tokens were sent already */;\n', '        bool reverted /* Confirm the tokens were sent already */;\n', '    }\n', '\n', '    event PurchaseEvent(uint256 amount, address indexed purchaser, uint256 timestamp);\n', '\n', '    constructor(address _tokenAddress, uint256 _tradeValue, uint256 _tokensForSale, uint256 _startDate, \n', '        uint256 _endDate, uint256 _individualMinimumAmount, uint256 _individualMaximumAmount, bool _isTokenSwapAtomic, uint256 _minimumRaise,\n', '        uint256 _feeAmount, bool _hasWhitelisting\n', '    ) public Whitelist(_hasWhitelisting) {\n', '        \n', '        /* Confirmations */\n', '        require(block.timestamp < _endDate, "End Date should be further than current date");\n', '        require(block.timestamp < _startDate, "End Date should be further than current date");\n', '        require(_startDate < _endDate, "End Date higher than Start Date");\n', '        require(_tokensForSale > 0, "Tokens for Sale should be > 0");\n', '        require(_tokensForSale > _individualMinimumAmount, "Tokens for Sale should be > Individual Minimum Amount");\n', '        require(_individualMaximumAmount >= _individualMinimumAmount, "Individual Maximim AMount should be > Individual Minimum Amount");\n', '        require(_minimumRaise <= _tokensForSale, "Minimum Raise should be < Tokens For Sale");\n', '        require(_feeAmount >= feePercentage, "Fee Percentage has to be >= 1");\n', '        require(_feeAmount <= 99, "Fee Percentage has to be < 100");\n', '\n', '        startDate = _startDate; \n', '        endDate = _endDate;\n', '        tokensForSale = _tokensForSale;\n', '        tradeValue = _tradeValue;\n', '\n', '        individualMinimumAmount = _individualMinimumAmount; \n', '        individualMaximumAmount = _individualMaximumAmount; \n', '        isTokenSwapAtomic = _isTokenSwapAtomic;\n', '\n', '        if(!_isTokenSwapAtomic){ /* If raise is not atomic swap */\n', '            minimumRaise = _minimumRaise;\n', '        }\n', '\n', '        erc20 = ERC20(_tokenAddress);\n', '        decimals = erc20.decimals();\n', '        feePercentage = _feeAmount;\n', '    }\n', '\n', '    /**\n', '    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\n', '    */\n', '    modifier isNotAtomicSwap() {\n', '        require(!isTokenSwapAtomic, "Has to be non Atomic swap");\n', '        _;\n', '    }\n', '\n', '     /**\n', '    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\n', '    */\n', '    modifier isSaleFinalized() {\n', '        require(hasFinalized(), "Has to be finalized");\n', '        _;\n', '    }\n', '\n', '     /**\n', '    * Modifier to make a function callable only when the swap time is open.\n', '    */\n', '    modifier isSaleOpen() {\n', '        require(isOpen(), "Has to be open");\n', '        _;\n', '    }\n', '\n', '     /**\n', '    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\n', '    */\n', '    modifier isSalePreStarted() {\n', '        require(isPreStart(), "Has to be pre-started");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Modifier to make a function callable only when the contract has Atomic Swaps not available.\n', '    */\n', '    modifier isFunded() {\n', '        require(isSaleFunded, "Has to be funded");\n', '        _;\n', '    }\n', '\n', '\n', '    /* Get Functions */\n', '    function isBuyer(uint256 purchase_id) public view returns (bool) {\n', '        return (msg.sender == purchases[purchase_id].purchaser);\n', '    }\n', '\n', '    /* Get Functions */\n', '    function totalRaiseCost() public view returns (uint256) {\n', '        return (cost(tokensForSale));\n', '    }\n', '\n', '    function availableTokens() public view returns (uint256) {\n', '        return erc20.balanceOf(address(this));\n', '    }\n', '\n', '    function tokensLeft() public view returns (uint256) {\n', '        return tokensForSale - tokensAllocated;\n', '    }\n', '\n', '    function hasMinimumRaise() public view returns (bool){\n', '        return (minimumRaise != 0);\n', '    }\n', '\n', '    /* Verify if minimum raise was not achieved */\n', '    function minimumRaiseNotAchieved() public view returns (bool){\n', '        require(cost(tokensAllocated) < cost(minimumRaise), "TotalRaise is bigger than minimum raise amount");\n', '        return true;\n', '    }\n', '\n', '    /* Verify if minimum raise was achieved */\n', '    function minimumRaiseAchieved() public view returns (bool){\n', '        if(hasMinimumRaise()){\n', '            require(cost(tokensAllocated) >= cost(minimumRaise), "TotalRaise is less than minimum raise amount");\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function hasFinalized() public view returns (bool){\n', '        return block.timestamp > endDate;\n', '    }\n', '\n', '    function hasStarted() public view returns (bool){\n', '        return block.timestamp >= startDate;\n', '    }\n', '    \n', '    function isPreStart() public view returns (bool){\n', '        return block.timestamp < startDate;\n', '    }\n', '\n', '    function isOpen() public view returns (bool){\n', '        return hasStarted() && !hasFinalized();\n', '    }\n', '\n', '    function hasMinimumAmount() public view returns (bool){\n', '       return (individualMinimumAmount != 0);\n', '    }\n', '\n', '    function cost(uint256 _amount) public view returns (uint){\n', '        return _amount.mul(tradeValue).div(10**decimals); \n', '    }\n', '\n', '    function getPurchase(uint256 _purchase_id) external view returns (uint256, address, uint256, uint256, bool, bool){\n', '        Purchase memory purchase = purchases[_purchase_id];\n', '        return (purchase.amount, purchase.purchaser, purchase.ethAmount, purchase.timestamp, purchase.wasFinalized, purchase.reverted);\n', '    }\n', '\n', '    function getPurchaseIds() public view returns(uint256[] memory) {\n', '        return purchaseIds;\n', '    }\n', '\n', '    function getBuyers() public view returns(address[] memory) {\n', '        return buyers;\n', '    }\n', '\n', '    function getMyPurchases(address _address) public view returns(uint256[] memory) {\n', '        return myPurchases[_address];\n', '    }\n', '\n', '    /* Fund - Pre Sale Start */\n', '    function fund(uint256 _amount) public isSalePreStarted {\n', '        \n', '        /* Confirm transfered tokens is no more than needed */\n', '        require(availableTokens().add(_amount) <= tokensForSale, "Transfered tokens have to be equal or less than proposed");\n', '\n', '        /* Transfer Funds */\n', '        require(erc20.transferFrom(msg.sender, address(this), _amount), "Failed ERC20 token transfer");\n', '        \n', '        /* If Amount is equal to needed - sale is ready */\n', '        if(availableTokens() == tokensForSale){\n', '            isSaleFunded = true;\n', '        }\n', '    }\n', '    \n', '    /* Action Functions */\n', '    function swap(uint256 _amount) payable external whenNotPaused isFunded isSaleOpen onlyWhitelisted {\n', '\n', '        /* Confirm Amount is positive */\n', '        require(_amount > 0, "Amount has to be positive");\n', '\n', '        /* Confirm Amount is less than tokens available */\n', '        require(_amount <= tokensLeft(), "Amount is less than tokens available");\n', '            \n', '        /* Confirm the user has funds for the transfer, confirm the value is equal */\n', '        require(msg.value == cost(_amount), "User has to cover the cost of the swap in ETH, use the cost function to determine");\n', '\n', '        /* Confirm Amount is bigger than minimum Amount */\n', '        require(_amount >= individualMinimumAmount, "Amount is bigger than minimum amount");\n', '\n', '        /* Confirm Amount is smaller than maximum Amount */\n', '        require(_amount <= individualMaximumAmount, "Amount is smaller than maximum amount");\n', '\n', '        /* Verify all user purchases, loop thru them */\n', '        uint256[] memory _purchases = getMyPurchases(msg.sender);\n', '        uint256 purchaserTotalAmountPurchased = 0;\n', '        for (uint i = 0; i < _purchases.length; i++) {\n', '            Purchase memory _purchase = purchases[_purchases[i]];\n', '            purchaserTotalAmountPurchased = purchaserTotalAmountPurchased.add(_purchase.amount);\n', '        }\n', '        require(purchaserTotalAmountPurchased.add(_amount) <= individualMaximumAmount, "Address has already passed the max amount of swap");\n', '\n', '        if(isTokenSwapAtomic){\n', '            /* Confirm transfer */\n', '            require(erc20.transfer(msg.sender, _amount), "ERC20 transfer didn´t work");\n', '        }\n', '        \n', '        uint256 purchase_id = increment;\n', '        increment = increment.add(1);\n', '\n', '        /* Create new purchase */\n', '        Purchase memory purchase = Purchase(_amount, msg.sender, msg.value, block.timestamp, isTokenSwapAtomic /* If Atomic Swap */, false);\n', '        purchases[purchase_id] = purchase;\n', '        purchaseIds.push(purchase_id);\n', '        myPurchases[msg.sender].push(purchase_id);\n', '        buyers.push(msg.sender);\n', '        tokensAllocated = tokensAllocated.add(_amount);\n', '        emit PurchaseEvent(_amount, msg.sender, block.timestamp);\n', '    }\n', '\n', '    /* Redeem tokens when the sale was finalized */\n', '    function redeemTokens(uint256 purchase_id) external isNotAtomicSwap isSaleFinalized whenNotPaused {\n', '        /* Confirm it exists and was not finalized */\n', '        require((purchases[purchase_id].amount != 0) && !purchases[purchase_id].wasFinalized, "Purchase is either 0 or finalized");\n', '        require(isBuyer(purchase_id), "Address is not buyer");\n', '        purchases[purchase_id].wasFinalized = true;\n', '        require(erc20.transfer(msg.sender, purchases[purchase_id].amount), "ERC20 transfer failed");\n', '    }\n', '\n', '    /* Retrieve Minumum Amount */\n', '    function redeemGivenMinimumGoalNotAchieved(uint256 purchase_id) external isSaleFinalized isNotAtomicSwap {\n', '        require(hasMinimumRaise(), "Minimum raise has to exist");\n', '        require(minimumRaiseNotAchieved(), "Minimum raise has to be reached");\n', '        /* Confirm it exists and was not finalized */\n', '        require((purchases[purchase_id].amount != 0) && !purchases[purchase_id].wasFinalized, "Purchase is either 0 or finalized");\n', '        require(isBuyer(purchase_id), "Address is not buyer");\n', '        purchases[purchase_id].wasFinalized = true;\n', '        purchases[purchase_id].reverted = true;\n', '        msg.sender.transfer(purchases[purchase_id].ethAmount);\n', '    }\n', '\n', '    /* Admin Functions */\n', '    function withdrawFunds() external onlyOwner whenNotPaused isSaleFinalized {\n', '        require(minimumRaiseAchieved(), "Minimum raise has to be reached");\n', '        FEE_ADDRESS.transfer(address(this).balance.mul(feePercentage).div(100)); /* Fee Address */\n', '        msg.sender.transfer(address(this).balance);\n', '    }  \n', '    \n', '    function withdrawUnsoldTokens() external onlyOwner isSaleFinalized {\n', '        require(!unsoldTokensReedemed);\n', '        uint256 unsoldTokens;\n', '        if(hasMinimumRaise() && \n', '            (cost(tokensAllocated) < cost(minimumRaise))){ /* Minimum Raise not reached */\n', '                unsoldTokens = tokensForSale;\n', '        }else{\n', '            /* If minimum Raise Achieved Redeem All Tokens minus the ones */\n', '            unsoldTokens = tokensForSale.sub(tokensAllocated);\n', '        }\n', '\n', '        if(unsoldTokens > 0){\n', '            unsoldTokensReedemed = true;\n', '            require(erc20.transfer(msg.sender, unsoldTokens), "ERC20 transfer failed");\n', '        }\n', '    }   \n', '\n', '    function removeOtherERC20Tokens(address _tokenAddress, address _to) external onlyOwner isSaleFinalized {\n', '        require(_tokenAddress != address(erc20), "Token Address has to be diff than the erc20 subject to sale"); // Confirm tokens addresses are different from main sale one\n', '        ERC20 erc20Token = ERC20(_tokenAddress);\n', '        require(erc20Token.transfer(_to, erc20Token.balanceOf(address(this))), "ERC20 Token transfer failed");\n', '    } \n', '\n', '    /* Safe Pull function */\n', '    function safePull() payable external onlyOwner whenPaused {\n', '        msg.sender.transfer(address(this).balance);\n', '        erc20.transfer(msg.sender, erc20.balanceOf(address(this)));\n', '    }\n', '}']