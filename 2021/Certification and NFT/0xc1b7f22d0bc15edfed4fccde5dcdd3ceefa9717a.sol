['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract StringUtil {\n', '    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n', '        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n', '    }\n', '\n', '    function append(string memory a, string memory b) internal pure returns (string memory) {\n', '        return string(abi.encodePacked(a, b));\n', '    }\n', '\n', '    function append2(string memory a, string memory b, string memory c) internal pure returns (string memory) {\n', '        return string(abi.encodePacked(a, b, c));\n', '    }\n', '\n', '    function append3(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\n', '        return string(abi.encodePacked(a, b, c, d));\n', '    }\n', '\n', '    function bool2str(bool b) internal pure returns(string memory){\n', '        if(b) return "true";\n', '\n', '        return "false";\n', '    }\n', '\n', '    function address2str(address x) internal pure returns (string memory) {\n', '        bytes memory s = new bytes(40);\n', '        for (uint i = 0; i < 20; i++) {\n', '            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n', '            bytes1 hi = bytes1(uint8(b) / 16);\n', '            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n', '            s[2*i] = char(hi);\n', '            s[2*i+1] = char(lo);\n', '        }\n', '        return string(s);\n', '    }\n', '\n', '    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = byte(uint8(48 + _i % 10));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '\n', '    function char(bytes1 b) internal pure returns (bytes1 c) {\n', '        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n', '        else return bytes1(uint8(b) + 0x57);\n', '    }\n', '}\n', '\n', 'contract Constants {\n', '    uint internal constant oneMantissa = 10**18;\n', '\n', '    enum LoopControl {\n', '        NONE,\n', '        CONTINUE,\n', '        BREAK\n', '    }\n', '}\n', '\n', 'contract CompoundAddresses {\n', '      address internal constant cDAIAddr = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n', '      address internal constant cETHAddr = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '      address internal constant cUSDCAddr = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n', '      address internal constant cUSDTAddr = 0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9;\n', '      address internal constant cWBTCAddr = 0xC11b1268C1A384e55C48c2391d8d480264A3A7F4;\n', '      address internal constant cWBTC2Addr = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a; //migrated at block number 12069867\n', '      address internal constant cCOMPAddr = 0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4;\n', '      address internal constant cSAIAddr = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\n', '      address internal constant compAddr = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n', '\n', '      address internal constant compoundLensAddr = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\n', '      address internal constant comptrollerAddr = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n', '      address internal constant uniswapAnchoredViewAddr = 0x922018674c12a7F0D394ebEEf9B58F186CdE13c1;\n', '\n', '      function getCWBTCAddr(uint blockNumber) public pure returns(address){\n', '          if(blockNumber >= 12069867){\n', '              return cWBTC2Addr;\n', '          }\n', '\n', '          return cWBTCAddr;\n', '      }\n', '}\n', '\n', 'contract ERC20Addresses {\n', '      address internal constant usdtAddr = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '}\n', '\n', 'contract UniswapV2Addresses {\n', '      address internal constant uniswapV2Router02Address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '      address internal constant wETHAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '}\n', '\n', 'contract ERC20 {\n', '\n', '    uint8 public decimals;\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function transfer(address dst, uint amount) external returns (bool);\n', '    function symbol() external view returns (string memory);\n', '\n', '}\n', '\n', 'contract USDT_ERC20 {\n', '    function approve(address spender, uint value) external;\n', '}\n', '\n', 'contract Comptroller {\n', '    struct Market {\n', '           bool isListed;\n', '           uint collateralFactorMantissa;\n', '           bool isComped;\n', '    }\n', '\n', '    mapping(address => Market) public markets;\n', '    mapping(address => uint) public compAccrued;\n', '\n', '\n', '    uint public closeFactorMantissa;\n', '    uint public liquidationIncentiveMantissa;\n', '    address public oracle;\n', '    function getAccountLiquidity(address account) public view returns (uint, uint, uint);\n', '    function getAssetsIn(address account) external view returns (address[] memory);\n', '    function compSpeeds(address cTokenAddress) external view returns(uint);\n', '    function getAllMarkets() public view returns (CToken[] memory);\n', '\n', '\n', '}\n', '\n', 'contract CToken is ERC20{\n', '    address public underlying;\n', '    uint public totalBorrows;\n', '    uint public totalReserves;\n', '    \n', '    function mint(uint mintAmount) external returns (uint);\n', '    function redeem(uint redeemTokens) external returns (uint);\n', '    function exchangeRateStored() public view returns (uint);\n', '    function balanceOfUnderlying(address owner) external returns (uint);\n', '    function borrowBalanceStored(address account) public view returns (uint);\n', '    function getCash() external view returns (uint);\n', '    function totalBorrowsCurrent() external view returns (uint);\n', '    function borrowRatePerBlock() external view returns (uint);\n', '    function supplyRatePerBlock() external view returns (uint);\n', '    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\n', '}\n', '\n', 'contract PriceOracle {\n', '    function getUnderlyingPrice(CToken cToken) public view returns (uint);\n', '}\n', '\n', 'contract UniswapAnchoredView {\n', '    function price(string memory symbol) public view returns (uint);\n', '}\n', '\n', 'contract CErc20 is CToken {\n', '    address public underlying;\n', '    function liquidateBorrow(address borrower, uint repayAmount, CToken cTokenCollateral) external returns (uint);\n', '}\n', '\n', 'contract CompoundLens {\n', '\n', '    struct CompBalanceMetadataExt{\n', '            uint balance;\n', '            uint votes;\n', '            address delegate;\n', '            uint allocated;\n', '    }\n', '\n', '    function getCompBalanceMetadataExt(Comp comp, ComptrollerLensInterface comptroller, address account) external returns (CompBalanceMetadataExt memory);\n', '\n', '}\n', '\n', 'contract Comp {\n', '\n', '}\n', '\n', 'interface ComptrollerLensInterface {\n', '\n', '}\n', '\n', 'contract ERC20ErrorReporter {\n', '    enum ERC20Error {\n', '        NO_ERROR,\n', '        TRANSFER_FROM_FAILED,\n', '        APPROVE_FAILED,\n', '        TRANSFER_FAILED\n', '    }\n', '\n', '    event fail(uint err);\n', '}\n', '\n', 'contract ERC20Methods is ERC20ErrorReporter, ERC20Addresses{\n', '\n', '    function getDecimals(address token) internal view returns(uint decimals){\n', '        if(token == address(0)){\n', '            return 18;\n', '        }\n', '\n', '        return ERC20(token).decimals();\n', '    }\n', '\n', '    function transferIn(address token, address from, address to, uint amount) internal returns(ERC20Error){\n', '\n', '        if(!ERC20(token).transferFrom(from, to, amount)){\n', '             emit fail(uint(ERC20Error.TRANSFER_FROM_FAILED));\n', '             return ERC20Error.TRANSFER_FROM_FAILED;\n', '        }\n', '\n', '        return ERC20Error.NO_ERROR;\n', '    }\n', '\n', '    function transferOut(address token, address to, uint amount) internal returns(ERC20Error){\n', '        ERC20 erc20 = ERC20(token);\n', '\n', '        if(!erc20.approve(to, amount)){\n', '             emit fail(uint(ERC20Error.APPROVE_FAILED));\n', '             return ERC20Error.APPROVE_FAILED;\n', '        }\n', '\n', '        if(!erc20.transfer(to, amount)){\n', '             emit fail(uint(ERC20Error.TRANSFER_FAILED));\n', '             return ERC20Error.TRANSFER_FAILED;\n', '        }\n', '\n', '        return ERC20Error.NO_ERROR;\n', '    }\n', '\n', '    //works with ETH and ERC20\n', '    function balanceOf(address tokenAddr, address accAddr) internal view returns(uint){\n', '        //for ETH\n', '        if(tokenAddr == address(0)){\n', '            return accAddr.balance;\n', '        }\n', '\n', '        return ERC20(tokenAddr).balanceOf(accAddr);\n', '    }\n', '\n', '    //works with standard and non-standard ERC20\n', '    function approve(address tokenAddr, address spender, uint256 amount) internal returns(bool){\n', '        if(tokenAddr == usdtAddr){\n', '             USDT_ERC20(usdtAddr).approve(spender, 0);\n', '             USDT_ERC20(usdtAddr).approve(spender, amount);\n', '             return true;\n', '        }\n', '\n', '        return ERC20(tokenAddr).approve(spender, amount);\n', '    }\n', '}\n', '\n', 'contract CompoundMethodsErrorReporter {\n', '    enum CompoundMethodsError {\n', '        NO_ERROR,\n', '        Liquidation_Failed,\n', '        APPROVE_FAILED,\n', '        Redeem_Failed\n', '    }\n', '\n', '    event fail(uint err);\n', '    event fail(uint err, uint detail);\n', '}\n', '\n', 'contract CompoundMethods is CompoundMethodsErrorReporter, ERC20Methods, CompoundAddresses, UniswapV2Addresses, Constants, StringUtil{\n', '      using SafeMath for uint;\n', '\n', '      function cmp_redeemUnderlying(address cToken, uint amount) internal returns(CompoundMethodsError err){\n', '          uint error_redeem = CToken(cToken).redeem(amount);\n', '          if(error_redeem != 0){\n', '              emit fail(uint(CompoundMethodsError.Redeem_Failed), error_redeem);\n', '              return CompoundMethodsError.Redeem_Failed;\n', '          }\n', '\n', '          return CompoundMethodsError.NO_ERROR;\n', '      }\n', '\n', '      function cmp_liquidateBorrow(address cTokenBorrowed, address underlyingBorrowed, address borrower, uint repayAmount, CToken cTokenCollateral) internal returns(CompoundMethodsError err){\n', "          //approve USDT won't work\n", '          if(!approve(underlyingBorrowed, cTokenBorrowed, repayAmount)){\n', '              emit fail(uint(CompoundMethodsError.APPROVE_FAILED));\n', '              return CompoundMethodsError.APPROVE_FAILED;\n', '          }\n', '\n', '          //liquidate\n', '          uint err_liquidateBorrow = CErc20(cTokenBorrowed).liquidateBorrow(borrower, repayAmount, cTokenCollateral);\n', '          if(err_liquidateBorrow != 0){\n', '              emit fail(uint(CompoundMethodsError.APPROVE_FAILED), err_liquidateBorrow);\n', '              return CompoundMethodsError.APPROVE_FAILED;\n', '          }\n', '\n', '          return CompoundMethodsError.NO_ERROR;\n', '      }\n', '\n', '      function cmp_getUnderlyingAddr(address cTokenAddr) internal view returns(address underlyingAddr) {\n', '          if(cTokenAddr == cETHAddr){\n', '              return address(0);\n', '          }\n', '\n', '          underlyingAddr = CToken(cTokenAddr).underlying();\n', '\n', '          return underlyingAddr;\n', '      }\n', '\n', '\n', '      function cmp_underlyingValueInUSD(uint underlyingBalance, address cTokenAddr) internal view returns(uint valueInUSD){\n', '\n', '          uint underlyingDecimals = cmp_getUnderlyingDecimals(cTokenAddr);\n', '          valueInUSD = cmp_getUnderlyingPriceInUSD(cTokenAddr).mul(underlyingBalance).div(10**underlyingDecimals);\n', '\n', '          return valueInUSD;\n', '      }\n', '\n', '      function cmp_getUnderlyingPriceInUSD(address cTokenAddr) internal view returns (uint priceInUSD){\n', '\n', '            address oracleAddr = Comptroller(comptrollerAddr).oracle();\n', '\n', '            if(cTokenAddr == cUSDCAddr || cTokenAddr == cUSDTAddr){\n', '                priceInUSD = oneMantissa;\n', '                return priceInUSD;\n', '            }\n', '\n', '            if(cTokenAddr == cWBTC2Addr || cTokenAddr == cWBTCAddr){\n', '                priceInUSD = PriceOracle(oracleAddr).getUnderlyingPrice(CToken(cTokenAddr)).div(10**10);\n', '                return priceInUSD;\n', '            }\n', '\n', '            priceInUSD = PriceOracle(oracleAddr).getUnderlyingPrice(CToken(cTokenAddr));\n', '            return priceInUSD;\n', '      }\n', '\n', '      function cmp_getPriceInUSDByUnderlyingAddr(address underlyingAddr) internal view returns(uint underlyingPriceInUSD){\n', '          string memory symbol = ERC20(underlyingAddr).symbol();\n', '          if(compareStrings(symbol, "wBTC")){\n', '              symbol = "BTC";\n', '          }\n', '\n', '          return cmp_getPriceBySymbol(symbol).mul(10**12);\n', '      }\n', '\n', '      function cmp_getPriceBySymbol(string memory symbol) internal view returns(uint priceInUSDMantissa6){\n', '          return UniswapAnchoredView(uniswapAnchoredViewAddr).price(symbol);\n', '      }\n', '\n', '      function cmp_getUnderlyingSymbol(address cTokenAddr) internal view returns(string memory getUnderlyingSymbol){\n', '          if(cTokenAddr == cETHAddr) return "ETH";\n', '\n', '          if(cTokenAddr == cSAIAddr) return "SAI";\n', '\n', '          return ERC20(CToken(cTokenAddr).underlying()).symbol();\n', '      }\n', '\n', '      function cmp_getUnderlyingDecimals(address cTokenAddr) internal view returns(uint decimals){\n', '          if(cTokenAddr == cETHAddr){\n', '               decimals = 18;\n', '               return decimals;\n', '          }\n', '\n', '          address underlyingAddr = cmp_getUnderlyingAddr(cTokenAddr);\n', '          decimals = ERC20(underlyingAddr).decimals();\n', '          return decimals;\n', '      }\n', '\n', '      //not tested\n', '      function cmp_getTotalSupplyInUSD(address cTokenAddr) internal view returns(uint totalSupplyInUSD){\n', '          return cmp_underlyingValueInUSD(cmp_getTotalSupply(cTokenAddr), cTokenAddr);\n', '      }\n', '\n', '      function cmp_getTotalSupply(address cTokenAddr) internal view returns(uint totalSupply){\n', '          CToken cToken = CToken(cTokenAddr);\n', '          uint cash = cToken.getCash();\n', '          uint totalBorrow = cToken.totalBorrows();\n', '          uint totalReserves = cToken.totalReserves();\n', '\n', '          return cash.add(totalBorrow).sub(totalReserves);\n', '      }\n', '\n', '      function cmp_getCompDistSpeedPerBlock(address cTokenAddr) internal view returns(uint compDistSpeedPerBlock){\n', '          Comptroller comptroller = Comptroller(comptrollerAddr);\n', '          return comptroller.compSpeeds(cTokenAddr);\n', '      }\n', '\n', '\n', '      function cmp_getCompDistAmount(address cTokenAddr, uint numberOfBlocks) internal view returns(uint compDistAmount){\n', '          return cmp_getCompDistSpeedPerBlock(cTokenAddr).mul(numberOfBlocks);\n', '      }\n', '\n', '      function cmp_getCurrentCTokenAddrList() internal view returns(address[] memory cTokenAddrList){\n', '            Comptroller comptroller = Comptroller(comptrollerAddr);\n', '            CToken[] memory allMarkets = comptroller.getAllMarkets();\n', '\n', '            cTokenAddrList = new address[](cmp_getNumberOfCurrentCTokens(allMarkets));\n', '\n', '            CToken eachCToken;\n', '            uint index;\n', '            for(uint i = 0; i < allMarkets.length; i++){\n', '                eachCToken = allMarkets[i];\n', '\n', '                if(!cmp_isCurrentCToken(address(eachCToken))) continue;\n', '\n', '                cTokenAddrList[index] = address(eachCToken);\n', '                index++;\n', '            }\n', '\n', '            return cTokenAddrList;\n', '      }\n', '\n', '      function cmp_getCurrentCTokenSymbolList() internal view returns(string[] memory cTokenSymbolList){\n', '            Comptroller comptroller = Comptroller(comptrollerAddr);\n', '            CToken[] memory allMarkets = comptroller.getAllMarkets();\n', '\n', '            cTokenSymbolList = new string[](cmp_getNumberOfCurrentCTokens(allMarkets));\n', '\n', '            CToken eachCToken;\n', '            uint index;\n', '            for(uint i = 0; i < allMarkets.length; i++){\n', '                eachCToken = allMarkets[i];\n', '\n', '                if(!cmp_isCurrentCToken(address(eachCToken))) continue;\n', '\n', '                cTokenSymbolList[index] = eachCToken.symbol();\n', '                index++;\n', '            }\n', '\n', '            return cTokenSymbolList;\n', '      }\n', '\n', '\n', '\n', '      function cmp_isCurrentCToken(address cTokenAddr) internal view returns(bool){\n', '          bool isListed;\n', '          bool isComped;\n', '\n', '          Comptroller comptroller = Comptroller(comptrollerAddr);\n', '          (isListed, , isComped) = comptroller.markets(cTokenAddr);\n', '\n', '          if(isListed && isComped) return true;\n', '\n', '          return false;\n', '      }\n', '\n', '      function cmp_getNumberOfCurrentCTokens(CToken[] memory allMarkets) internal view returns(uint numberOfCurrentCTokens){\n', '\n', '          for(uint i = 0; i < allMarkets.length; i++){\n', '              if(cmp_isCurrentCToken(address(allMarkets[i]))) numberOfCurrentCTokens++;\n', '          }\n', '\n', '          return numberOfCurrentCTokens;\n', '      }\n', '\n', '      function cmp_getPercentageOfStakeOnSupplyMantissa(address acc, address cTokenAddr) internal view returns(uint percentageOfStakeOnSupplyMantissa){\n', '\n', '          uint supplyByTheAcc = cmp_getUnderlyingBalanceOfAnAcc(acc, cTokenAddr);\n', '\n', '          return cmp_calPercentageOfStakeOnSupplyMantissa(cTokenAddr, supplyByTheAcc);\n', '      }\n', '\n', '      function cmp_calPercentageOfStakeOnSupplyMantissa(address cTokenAddr, uint supplyByTheAcc) internal view returns(uint percentageOfStakeOnSupplyMantissa){\n', '          uint totalSupply = cmp_getTotalSupply(cTokenAddr);\n', '\n', '          return supplyByTheAcc.mul(oneMantissa).div(totalSupply);\n', '      }\n', '\n', '      function cmp_getPercentageOfStakeOnBorrowMantissa(address acc, address cTokenAddr) internal view returns(uint percentageOfStakeOnBorrowMantissa){\n', '\n', '          uint err;\n', '          uint borrowByTheAcc;\n', '\n', '          (err, ,borrowByTheAcc, ) = CToken(cTokenAddr).getAccountSnapshot(acc);\n', '\n', '          if(err != 0){\n', '              return 0;\n', '          }\n', '\n', '          return cmp_calPercentageOfStakeOnBorrowMantissa(cTokenAddr, borrowByTheAcc);\n', '      }\n', '\n', '      function cmp_calPercentageOfStakeOnBorrowMantissa(address cTokenAddr, uint borrowByTheAcc) internal view returns(uint percentageOfStakeOnBorrowMantissa){\n', '\n', '          uint totalBorrow = CToken(cTokenAddr).totalBorrows();\n', '\n', '          return borrowByTheAcc.mul(oneMantissa).div(totalBorrow);\n', '      }\n', '\n', '      function cmp_getUnderlyingBalanceOfAnAcc(address acc, address cTokenAddr) internal view returns(uint underlyingBalanceOfAnAcc){\n', '          CToken cToken = CToken(cTokenAddr);\n', '          return cToken.balanceOf(acc).mul(cToken.exchangeRateStored()).div(oneMantissa);\n', '      }\n', '\n', '      function cmp_getBorrowedTokenList(address acc) internal view returns(address[] memory borrowedCTokenList){\n', '          CToken[] memory allMarkets = Comptroller(comptrollerAddr).getAllMarkets();\n', '\n', '          uint length;\n', '          for(uint i = 0; i < allMarkets.length; i++){\n', '//require(false, uint2str(CToken(cDAIAddr).borrowBalanceStored(acc)));\n', '              if(allMarkets[i].borrowBalanceStored(acc) == 0) continue;\n', '\n', '              length++;\n', '          }\n', '\n', '          borrowedCTokenList = new address[](length);\n', '\n', '          uint index;\n', '          for(uint i = 0; i < allMarkets.length; i++){\n', '              if(allMarkets[i].borrowBalanceStored(acc) == 0) continue;\n', '\n', '              borrowedCTokenList[index] = address(allMarkets[i]);\n', '              index++;\n', '          }\n', '\n', '          return borrowedCTokenList;\n', '      }\n', '\n', '      function cmp_getCollateralFactorMantissa(address cTokenAddr) internal view returns(uint collateralFactorMantissa){\n', '          bool isListed;\n', '\n', '          (isListed, collateralFactorMantissa, ) = Comptroller(comptrollerAddr).markets(cTokenAddr);\n', '\n', '          if(!isListed) return 0;\n', '\n', '          return collateralFactorMantissa;\n', '      }\n', '\n', '\n', '\n', '}\n', '\n', 'contract ArrayUtil {\n', '      \n', '      function quickSortDESC(string[] memory keys, uint[] memory values) internal pure returns (string[] memory, uint[] memory){\n', '\n', '            string[] memory keysPlus = new string[](keys.length + 1);\n', '            uint[] memory valuesPlus = new uint[](values.length + 1);\n', '\n', '            for(uint i = 0; i < keys.length; i++){\n', '                keysPlus[i] = keys[i];\n', '                valuesPlus[i] = values[i];\n', '            }\n', '\n', '            (keysPlus, valuesPlus) = quickSort(keysPlus, valuesPlus, 0, keysPlus.length - 1);\n', '\n', '            string[] memory keys_desc = new string[](keys.length);\n', '            uint[] memory values_desc = new uint[](values.length);\n', '            for(uint i = 0; i < keys.length; i++){\n', '                keys_desc[keys.length - 1 - i] = keysPlus[i + 1];\n', '                values_desc[keys.length - 1 - i] = valuesPlus[i + 1];\n', '            }\n', '\n', '            return (keys_desc, values_desc);\n', '      }\n', '\n', '      function quickSort(string[] memory keys, uint[] memory values, uint left, uint right) internal pure returns (string[] memory, uint[] memory){\n', '            uint i = left;\n', '            uint j = right;\n', '            uint pivot = values[left + (right - left) / 2];\n', '            while (i <= j) {\n', '                while (values[i] < pivot) i++;\n', '                while (pivot < values[j]) j--;\n', '                if (i <= j) {\n', '                    (keys[i], keys[j]) = (keys[j], keys[i]);\n', '                    (values[i], values[j]) = (values[j], values[i]);\n', '                    i++;\n', '                    j--;\n', '                }\n', '            }\n', '            if (left < j)\n', '                quickSort(keys, values, left, j);\n', '\n', '            if (i < right)\n', '                quickSort(keys, values, i, right);\n', '\n', '                return (keys, values);\n', '      }\n', '}\n', '\n', 'contract Logging is StringUtil{\n', '\n', '    function debug(string memory name, string[] memory values) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr;\n', '\n', '        for(uint i = 0; i < values.length; i++){\n', '            valueStr = append(valueStr, values[i]);\n', '            valueStr = append(valueStr, ", ");\n', '        }\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, address[] memory values) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr;\n', '\n', '        for(uint i = 0; i < values.length; i++){\n', '            valueStr = append(valueStr, address2str(values[i]));\n', '            valueStr = append(valueStr, ", ");\n', '        }\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, uint[] memory values) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr;\n', '\n', '        for(uint i = 0; i < values.length; i++){\n', '            valueStr = append(valueStr, uint2str(values[i]));\n', '            valueStr = append(valueStr, ", ");\n', '        }\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, string memory value) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr = value;\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, address value) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr = address2str(value);\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, uint value) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr = uint2str(value);\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '    function debug(string memory name, bool value) internal pure{\n', '        string memory log_name = append(name, ": ");\n', '        string memory valueStr = bool2str(value);\n', '\n', '        require(false, append(log_name, valueStr));\n', '    }\n', '\n', '\n', '\n', '    event log(string name, address value);\n', '    event log(string name, uint value);\n', '    event log(string name, string value);\n', '    event log(string name, bool value);\n', '    event log(string name, uint[] value);\n', '    event log(string name, address[] value);\n', '\n', '}\n', '\n', 'contract CompFarmingSummaryV3Model is CompoundMethods, ArrayUtil{\n', '    uint256 constant public MAX_INT_NUMBER = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n', '\n', '    enum LiquidationRiskRanking{\n', '        ZERO_RISK,\n', '        INTEREST_RISK_ONLY,\n', '        PRICE_MOVEMENT_RISK\n', '    }\n', '\n', '    struct CompProfile{\n', '         uint balance;\n', '         uint yetToClaimed;\n', '    }\n', '\n', '    struct AccountInterestProfile{\n', '        CTokenInterest[] supplyInterests;\n', '        CTokenInterest[] borrowInterests;\n', '\n', '        uint totalInterestInUSD_;\n', '        bool isPositiveInterest_;\n', '    }\n', '\n', '    struct CTokenInterest{\n', '        address cTokenAddr;\n', '        uint interestRateMantissa;\n', '        uint balance;\n', '        uint numberOfBlocks;\n', '\n', '        string underlyingSymbol_;\n', '        uint interestInUSD_;\n', '    }\n', '\n', '    struct AccountProfile{\n', '        SupplyAsset[] suppliedAssets;\n', '        BorrowAsset[] borrowedAssets;\n', '\n', '        uint totalSuppliedInUSD_;\n', '        uint totalBorrowedInUSD_;\n', '        uint totalSuppliedInUsdAsCollateral_;\n', '        uint borrowLimitPCTMantissa_;\n', '        uint accountCapital_;\n', '\n', '        uint[] borrowLimitPCTLineItemMantissaList;\n', '    }\n', '\n', '    struct SupplyAsset{\n', '        Asset asset;\n', '\n', '        uint collateralFactorMantissa_;\n', '        uint suppliedInUsdAsCollateral_;\n', '    }\n', '\n', '    struct BorrowAsset{\n', '        Asset asset;\n', '    }\n', '\n', '    struct Asset{\n', '        address cTokenAddr;\n', '        uint amount;\n', '\n', '        string underlyingSymbol_;\n', '        uint underlyingDecimals_;\n', '        uint valueInUSD_;\n', '        uint compSpeed_;\n', '    }\n', '\n', '    function createCTokenInterest(address cTokenAddr, uint interestRateMantissa, uint balance, uint numberOfBlocks) internal view returns(CTokenInterest memory cTokenInterest){\n', '        cTokenInterest.cTokenAddr = cTokenAddr;\n', '        cTokenInterest.interestRateMantissa = interestRateMantissa;\n', '        cTokenInterest.balance = balance;\n', '        cTokenInterest.numberOfBlocks = numberOfBlocks;\n', '\n', '        refreshCTokenInterest(cTokenInterest);\n', '\n', '        return cTokenInterest;\n', '    }\n', '\n', '    function refreshCTokenInterest(CTokenInterest memory cTokenInterest) internal view{\n', '        cTokenInterest.underlyingSymbol_ = cmp_getUnderlyingSymbol(cTokenInterest.cTokenAddr);\n', '        cTokenInterest.interestInUSD_ = cmp_underlyingValueInUSD(cTokenInterest.balance.mul(cTokenInterest.interestRateMantissa), cTokenInterest.cTokenAddr).mul(cTokenInterest.numberOfBlocks).div(oneMantissa);\n', '    }\n', '\n', '    function createAccountInterestProfile(CTokenInterest[] memory supplyInterests, CTokenInterest[] memory borrowInterests) internal pure returns(AccountInterestProfile memory accountInterestProfile){\n', '        accountInterestProfile.supplyInterests = supplyInterests;\n', '        accountInterestProfile.borrowInterests = borrowInterests;\n', '\n', '        refreshAccountInterestProfile(accountInterestProfile);\n', '\n', '        return accountInterestProfile;\n', '    }\n', '\n', '    function refreshAccountInterestProfile(AccountInterestProfile memory accountInterestProfile) internal pure {\n', '        uint totalSupplyInterestInUSD;\n', '        uint totalBorrowInterestInUSD;\n', '\n', '        for(uint i = 0; i < accountInterestProfile.supplyInterests.length; i++){\n', '            totalSupplyInterestInUSD += accountInterestProfile.supplyInterests[i].interestInUSD_;\n', '        }\n', '\n', '        for(uint i = 0; i < accountInterestProfile.borrowInterests.length; i++){\n', '            totalBorrowInterestInUSD += accountInterestProfile.borrowInterests[i].interestInUSD_;\n', '        }\n', '\n', '        if(totalSupplyInterestInUSD > totalBorrowInterestInUSD){\n', '            accountInterestProfile.totalInterestInUSD_ = totalSupplyInterestInUSD.sub(totalBorrowInterestInUSD);\n', '            accountInterestProfile.isPositiveInterest_ = true;\n', '        }\n', '\n', '        if(totalSupplyInterestInUSD <= totalBorrowInterestInUSD){\n', '            accountInterestProfile.totalInterestInUSD_ = totalBorrowInterestInUSD.sub(totalSupplyInterestInUSD);\n', '            accountInterestProfile.isPositiveInterest_ = false;\n', '        }\n', '    }\n', '\n', '    function createSupplyAsset(address cTokenAddr, uint amount) internal view returns(SupplyAsset memory supplyAsset){\n', '        Asset memory asset = createAsset(cTokenAddr, amount);\n', '        supplyAsset.asset = asset;\n', '\n', '        refreshSupplyAsset(supplyAsset);\n', '\n', '        return supplyAsset;\n', '    }\n', '\n', '    function createBorrowAsset(address cTokenAddr, uint amount) internal view returns(BorrowAsset memory borrowAsset){\n', '        Asset memory asset = createAsset(cTokenAddr, amount);\n', '        borrowAsset.asset = asset;\n', '\n', '        return borrowAsset;\n', '    }\n', '\n', '    function updateSupplyAssetAmount(SupplyAsset memory supplyAsset, uint newAmount) internal view{\n', '        supplyAsset.asset.amount = newAmount;\n', '\n', '        refreshAsset(supplyAsset.asset);\n', '        refreshSupplyAsset(supplyAsset);\n', '    }\n', '\n', '    function updateBorrowAssetAmount(BorrowAsset memory borrowAsset, uint newAmount) internal view{\n', '        borrowAsset.asset.amount = newAmount;\n', '\n', '        refreshAsset(borrowAsset.asset);\n', '    }\n', '\n', '    function refreshSupplyAsset(SupplyAsset memory supplyAsset) internal view{\n', '        supplyAsset.collateralFactorMantissa_ = cmp_getCollateralFactorMantissa(supplyAsset.asset.cTokenAddr);\n', '        supplyAsset.suppliedInUsdAsCollateral_ = supplyAsset.asset.valueInUSD_.mul(supplyAsset.collateralFactorMantissa_).div(oneMantissa);\n', '    }\n', '\n', '    function createAsset(address cTokenAddr, uint amount) internal view returns(Asset memory asset){\n', '        updateAsset(asset, cTokenAddr, amount);\n', '\n', '        return asset;\n', '    }\n', '\n', '    function updateAsset(Asset memory asset, address cTokenAddr, uint amount) internal view{\n', '        asset.cTokenAddr = cTokenAddr;\n', '        asset.amount = amount;\n', '\n', '        refreshAsset(asset);\n', '    }\n', '\n', '    function refreshAsset(Asset memory asset) internal view{\n', '        asset.underlyingSymbol_ = cmp_getUnderlyingSymbol(asset.cTokenAddr);\n', '        asset.underlyingDecimals_ = cmp_getUnderlyingDecimals(asset.cTokenAddr);\n', '        asset.valueInUSD_ = cmp_underlyingValueInUSD(asset.amount, asset.cTokenAddr);\n', '        asset.compSpeed_ = cmp_getCompDistSpeedPerBlock(asset.cTokenAddr);\n', '    }\n', '\n', '    function createAccountProfile(SupplyAsset[] memory suppliedAssets, BorrowAsset[] memory borrowedAssets) internal pure returns(AccountProfile memory accountProfile){\n', '        accountProfile.suppliedAssets = suppliedAssets;\n', '        accountProfile.borrowedAssets = borrowedAssets;\n', '\n', '        refreshAccountProfile(accountProfile);\n', '    }\n', '\n', '    function refreshAccountProfile(AccountProfile memory accountProfile) internal pure{\n', '        accountProfile.totalSuppliedInUSD_ = calTotalSuppliedInUSD(accountProfile.suppliedAssets);\n', '        accountProfile.totalBorrowedInUSD_ = calTotalBorrowedInUSD(accountProfile.borrowedAssets);\n', '        accountProfile.totalSuppliedInUsdAsCollateral_ = calTotalSuppliedInUsdAsCollateral(accountProfile.suppliedAssets);\n', '        accountProfile.accountCapital_ = calAccountCapital(accountProfile.totalSuppliedInUSD_, accountProfile.totalBorrowedInUSD_);\n', '        accountProfile.borrowLimitPCTMantissa_ = calBorrowLimitPCTMantissa(accountProfile.totalSuppliedInUsdAsCollateral_, accountProfile.totalBorrowedInUSD_);\n', '        accountProfile.borrowLimitPCTLineItemMantissaList = calBorrowLimitPCTLineItemMantissaList(accountProfile.suppliedAssets, accountProfile.borrowedAssets);\n', '    }\n', '\n', '    function calTotalSuppliedInUSD(SupplyAsset[] memory suppliedAssets) internal pure returns(uint totalSuppliedInUSD){\n', '        for(uint i = 0; i < suppliedAssets.length; i++){\n', '            totalSuppliedInUSD += suppliedAssets[i].asset.valueInUSD_;\n', '        }\n', '\n', '        return totalSuppliedInUSD;\n', '    }\n', '\n', '    function calTotalBorrowedInUSD(BorrowAsset[] memory borrowedAssets) internal pure returns(uint totalBorrowedInUSD){\n', '        for(uint i = 0; i < borrowedAssets.length; i++){\n', '            totalBorrowedInUSD += borrowedAssets[i].asset.valueInUSD_;\n', '        }\n', '\n', '        return totalBorrowedInUSD;\n', '    }\n', '\n', '    function calTotalSuppliedInUsdAsCollateral(SupplyAsset[] memory suppliedAssets) internal pure returns(uint totalSuppliedInUsdAsCollateral){\n', '        for(uint i = 0; i < suppliedAssets.length; i++){\n', '            totalSuppliedInUsdAsCollateral += suppliedAssets[i].suppliedInUsdAsCollateral_;\n', '        }\n', '\n', '        return totalSuppliedInUsdAsCollateral;\n', '    }\n', '\n', '    function calBorrowLimitPCTMantissa(uint totalSuppliedInUsdAsCollateral, uint totalBorrowedInUSD) internal pure returns(uint borrowLimitPCTMantissa){\n', '        if(totalSuppliedInUsdAsCollateral == 0) return oneMantissa;\n', '\n', '        return totalBorrowedInUSD.mul(oneMantissa).div(totalSuppliedInUsdAsCollateral);\n', '    }\n', '\n', '    function calBorrowLimitPCTLineItemMantissaList(SupplyAsset[] memory suppliedAssets, BorrowAsset[] memory borrowedAssets) internal pure returns(uint[] memory borrowLimitPCTLineItemMantissaList){\n', '\n', '        borrowLimitPCTLineItemMantissaList = new uint[](suppliedAssets.length);\n', '\n', '        bool _hasFound;\n', '        BorrowAsset memory _borrowedAsset;\n', '\n', '        for(uint i = 0; i < suppliedAssets.length; i++){\n', '            (_hasFound, _borrowedAsset) = findBorrowedAssetBycTokenAddr(suppliedAssets[i].asset.cTokenAddr, borrowedAssets);\n', '\n', '            if(suppliedAssets[i].suppliedInUsdAsCollateral_ == 0){\n', '                borrowLimitPCTLineItemMantissaList[i] = MAX_INT_NUMBER;\n', '            }\n', '\n', '            if(!_hasFound){\n', '                borrowLimitPCTLineItemMantissaList[i] = 0;\n', '                continue;\n', '            }\n', '\n', '            if(suppliedAssets[i].suppliedInUsdAsCollateral_ != 0){\n', '                borrowLimitPCTLineItemMantissaList[i] = _borrowedAsset.asset.valueInUSD_.mul(oneMantissa).div(suppliedAssets[i].suppliedInUsdAsCollateral_);\n', '            }\n', '\n', '        }\n', '\n', '        return borrowLimitPCTLineItemMantissaList;\n', '    }\n', '\n', '    function calAccountCapital(uint totalSuppliedInUSD, uint totalBorrowedInUSD) internal pure returns(uint accountCapital){\n', '        if(totalSuppliedInUSD > totalBorrowedInUSD){\n', '            return totalSuppliedInUSD.sub(totalBorrowedInUSD);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function findBorrowedAssetBycTokenAddr(address cTokenAddr, BorrowAsset[] memory borrowedAssets) internal pure returns(bool hasFound, BorrowAsset memory borrowAsset){\n', '        for(uint i = 0; i < borrowedAssets.length; i++){\n', '            if(borrowedAssets[i].asset.cTokenAddr == cTokenAddr) return (true, borrowedAssets[i]);\n', '        }\n', '\n', '        return (false, borrowAsset);\n', '    }\n', '\n', '    function addSuppliedAsset(AccountProfile memory accountProfile, SupplyAsset memory supplyAsset) internal view{\n', '\n', '        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\n', '            if(accountProfile.suppliedAssets[i].asset.cTokenAddr != supplyAsset.asset.cTokenAddr) continue;\n', '\n', '            updateSupplyAssetAmount(accountProfile.suppliedAssets[i], accountProfile.suppliedAssets[i].asset.amount.add(supplyAsset.asset.amount));\n', '            refreshAccountProfile(accountProfile);\n', '\n', '            return;\n', '        }\n', '\n', '        //if not matching existing supplyAsset found\n', '        uint length = accountProfile.suppliedAssets.length.add(1);\n', '        SupplyAsset[] memory newSupplyAsset = new SupplyAsset[](length);\n', '\n', '        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\n', '            newSupplyAsset[i] = accountProfile.suppliedAssets[i];\n', '        }\n', '\n', '        newSupplyAsset[length-1] = supplyAsset;\n', '        accountProfile.suppliedAssets = newSupplyAsset;\n', '\n', '        refreshAccountProfile(accountProfile);\n', '    }\n', '\n', '    function addBorrowAsset(AccountProfile memory accountProfile, BorrowAsset memory borrowAsset) internal view{\n', '        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\n', '            if(accountProfile.borrowedAssets[i].asset.cTokenAddr != borrowAsset.asset.cTokenAddr) continue;\n', '\n', '            updateBorrowAssetAmount(accountProfile.borrowedAssets[i], accountProfile.borrowedAssets[i].asset.amount.add(borrowAsset.asset.amount));\n', '            refreshAccountProfile(accountProfile);\n', '\n', '            return;\n', '        }\n', '\n', '        uint length = accountProfile.borrowedAssets.length.add(1);\n', '        BorrowAsset[] memory newBorrowAssets = new BorrowAsset[](length);\n', '\n', '        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\n', '            newBorrowAssets[i] = accountProfile.borrowedAssets[i];\n', '        }\n', '\n', '        newBorrowAssets[length-1] = borrowAsset;\n', '\n', '        accountProfile.borrowedAssets = newBorrowAssets;\n', '        refreshAccountProfile(accountProfile);\n', '\n', '    }\n', '\n', '    function findSuppliedAsset(address cTokenAddr, SupplyAsset[] memory supplyAssets) internal pure returns(bool hasFound, SupplyAsset memory supplyAsset){\n', '        for(uint i = 0; i < supplyAssets.length; i++){\n', '            if(cTokenAddr == supplyAssets[i].asset.cTokenAddr){\n', '                return (true, supplyAssets[i]);\n', '            }\n', '        }\n', '\n', '        return (false, supplyAsset);\n', '    }\n', '\n', '    function findBorrowAsset(address cTokenAddr, BorrowAsset[] memory borrowAssets) internal pure returns(bool hasFound, BorrowAsset memory borrowAsset){\n', '        for(uint i = 0; i < borrowAssets.length; i++){\n', '            if(cTokenAddr == borrowAssets[i].asset.cTokenAddr){\n', '                return (true, borrowAssets[i]);\n', '            }\n', '        }\n', '\n', '        return (false, borrowAsset);\n', '    }\n', '\n', '    function removeEmptySupplyAsset(SupplyAsset[] memory supplyAssets) internal pure returns(SupplyAsset[] memory newSupplyAssets){\n', '        uint length;\n', '\n', '        for(uint i = 0; i < supplyAssets.length; i++){\n', '            if(supplyAssets[i].asset.valueInUSD_ == 0) continue;\n', '\n', '            length++;\n', '        }\n', '\n', '        newSupplyAssets = new SupplyAsset[](length);\n', '        uint index;\n', '\n', '        for(uint i = 0; i < supplyAssets.length; i++){\n', '            if(supplyAssets[i].asset.valueInUSD_ == 0) continue;\n', '\n', '            newSupplyAssets[index] = supplyAssets[i];\n', '            index++;\n', '        }\n', '\n', '        return newSupplyAssets;\n', '    }\n', '\n', '    function removeEmptyBorrowAsset(BorrowAsset[] memory borrowAssets) internal pure returns(BorrowAsset[] memory newBorrowAssets){\n', '        uint length;\n', '\n', '        for(uint i = 0; i < borrowAssets.length; i++){\n', '            if(borrowAssets[i].asset.valueInUSD_ == 0) continue;\n', '\n', '            length++;\n', '        }\n', '\n', '        newBorrowAssets = new BorrowAsset[](length);\n', '        uint index;\n', '\n', '        for(uint i = 0; i < borrowAssets.length; i++){\n', '            if(borrowAssets[i].asset.valueInUSD_ == 0) continue;\n', '\n', '            newBorrowAssets[index] = borrowAssets[i];\n', '            index++;\n', '        }\n', '\n', '        return newBorrowAssets;\n', '    }\n', '\n', '\n', '}\n', '\n', 'contract CompFarmingSummaryV3 is CompFarmingSummaryV3Model{\n', '\n', '    string constant public version = "v3";\n', '    uint constant internal n80PCTMantissa = 800000000000000000;\n', '    uint constant internal n1PCTMantissa = 10000000000000000;\n', '\n', '    uint constant internal borrowLimitPCTDelta = 50000000000000000;\n', '\n', '    function getCompProfile(address acc) external returns(CompProfile memory compProfile){\n', '        return getCompProfileInternal(acc);\n', '    }\n', '\n', '    function getCOMPPriceInUSD() public view returns(uint compPriceInUSD){\n', '        return cmp_getUnderlyingPriceInUSD(cCOMPAddr);\n', '    }\n', '    //bulk testing required\n', '    function getTotalCompReceivable(address acc, uint numberOfBlocks) public view returns(uint totalCompReceivable){\n', '        return getTotalCompReceivableInternal(acc, numberOfBlocks);\n', '    }\n', '\n', '    function getTotalCompReceivablByAP(AccountProfile memory accountProfile, uint numberOfBlocks) public view returns(uint compReceivable){\n', '        return getTotalCompReceivableInternal(accountProfile, numberOfBlocks);\n', '    }\n', '    //bulk testing done\n', '    function getAccountProfile(address acc) external view returns(AccountProfile memory accountProfile){\n', '        return getAccountProfileInternal(acc);\n', '    }\n', '\n', '    function getAccountInterestProfile(address acc, uint numberOfBlocks) external view returns(AccountInterestProfile memory accountInterestProfile){\n', '        return getAccountInterestProfileInternal(acc, numberOfBlocks);\n', '    }\n', '\n', '    function getFarmingAccountProfileByAP(AccountProfile memory accountProfile, uint targetedBorrowLimitPCTMantissa) public view returns(bool isValidated, AccountProfile memory farmingAccountProfile){\n', '        return getFarmingAccountProfileInternal(accountProfile, targetedBorrowLimitPCTMantissa);\n', '    }\n', '\n', '    function getAccountInterestProfileByAP(AccountProfile memory accountProfile, uint numberOfBlocks) public view returns(AccountInterestProfile memory accountInterestProfile){\n', '        return getAccountInterestProfileInternal(accountProfile, numberOfBlocks);\n', '    }\n', '    //bulk testing done\n', '    function getLiquidationRiskRanking(address acc) external view returns(LiquidationRiskRanking liquidationRiskRanking){\n', '        return getLiquidationRiskRankingInternal(acc);\n', '    }\n', '\n', '    function getLiquidationRiskRankingByAP(AccountProfile memory accountProfile) public view returns(LiquidationRiskRanking liquidationRiskRanking){\n', '        return getLiquidationRiskRankingInternal(accountProfile);\n', '    }\n', '\n', '    function getMaxInterestAccountProfileByAP(AccountProfile memory accountProfile) public view returns(bool isValidated, AccountProfile memory maxInterestAccountProfile){\n', '        return getMaxInterestAccountProfileInternal(accountProfile);\n', '    }\n', '\n', '    //internal functions below\n', '    function getTotalCompReceivableInternal(address acc, uint numberOfBlocks) internal view returns(uint compReceivable){\n', '        return getTotalCompReceivableInternal(getAccountProfileInternal(acc), numberOfBlocks);\n', '    }\n', '\n', '    function getCompReceivableOfCToken(uint supplyByTheAcc, uint borrowByTheAcc, address cTokenAddr, uint numberOfBlocks) internal view returns(uint compReceivableByCToken){\n', '\n', '        uint compDistAmount = cmp_getCompDistAmount(cTokenAddr, numberOfBlocks);\n', '        uint percentageOfStakeOnSupplyMantissa = cmp_calPercentageOfStakeOnSupplyMantissa(cTokenAddr, supplyByTheAcc);\n', '        uint percentageOfStakeOnBorrowMantissa = cmp_calPercentageOfStakeOnBorrowMantissa(cTokenAddr, borrowByTheAcc);\n', '        uint decimals = cmp_getUnderlyingDecimals(cCOMPAddr);\n', '\n', '        //formula: compDistAmount * (stakeSupplied + stakeBorrowed)\n', '        compReceivableByCToken = compDistAmount.mul(percentageOfStakeOnSupplyMantissa.add(percentageOfStakeOnBorrowMantissa)).div(10**decimals);\n', '\n', '        return compReceivableByCToken;\n', '    }\n', '\n', '\n', '    function getTotalCompReceivableInternal(AccountProfile memory accountProfile, uint numberOfBlocks) internal view returns(uint compReceivable){\n', '        SupplyAsset[] memory suppliedAssets = accountProfile.suppliedAssets;\n', '        BorrowAsset[] memory borrowedAssets = accountProfile.borrowedAssets;\n', '\n', '        for(uint i = 0; i < suppliedAssets.length; i++){\n', '            compReceivable += getCompReceivableOfCToken(suppliedAssets[i].asset.amount, 0, suppliedAssets[i].asset.cTokenAddr, numberOfBlocks);\n', '        }\n', '\n', '        for(uint i = 0; i < borrowedAssets.length; i++){\n', '            compReceivable += getCompReceivableOfCToken(0, borrowedAssets[i].asset.amount, borrowedAssets[i].asset.cTokenAddr, numberOfBlocks);\n', '        }\n', '\n', '        return compReceivable;\n', '    }\n', '\n', '    function getCompProfileInternal(address acc) internal returns(CompProfile memory compProfile){\n', '\n', '        compProfile.balance = ERC20(compAddr).balanceOf(acc);\n', '\n', '        CompoundLens compoundLens = CompoundLens(compoundLensAddr);\n', '        compProfile.yetToClaimed = compoundLens.getCompBalanceMetadataExt(Comp(compAddr), ComptrollerLensInterface(comptrollerAddr), acc).allocated;\n', '\n', '    }\n', '\n', '    function getAccountProfileInternal(address acc) internal view returns(AccountProfile memory accountProfile){\n', '\n', '        SupplyAsset[] memory suppliedAssets = getSuppliedAssets(acc);\n', '        BorrowAsset[] memory borrowedAssets = getBorrowedAssets(acc);\n', '\n', '        return createAccountProfile(suppliedAssets, borrowedAssets);\n', '    }\n', '\n', '    function getSuppliedAssets(address acc) internal view returns(SupplyAsset[] memory suppliedAssets){\n', '        address[] memory suppliedCTokenAddrList = Comptroller(comptrollerAddr).getAssetsIn(acc);\n', '        suppliedAssets = new SupplyAsset[](suppliedCTokenAddrList.length);\n', '\n', '        for(uint i = 0; i < suppliedCTokenAddrList.length; i++){\n', '            //filter out cSAI\n', '            //if(suppliedCTokenAddrList[i] == 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC) continue;\n', '            suppliedAssets[i] = createSupplyAsset(suppliedCTokenAddrList[i], cmp_getUnderlyingBalanceOfAnAcc(acc, suppliedCTokenAddrList[i]));\n', '        }\n', '\n', '        suppliedAssets = removeEmptySupplyAsset(suppliedAssets);\n', '\n', '        return suppliedAssets;\n', '    }\n', '\n', '    function getBorrowedAssets(address acc) internal view returns(BorrowAsset[] memory borrowedAssets){\n', '        address[] memory borrowedCTokenList = cmp_getBorrowedTokenList(acc);\n', '\n', '        borrowedAssets = new BorrowAsset[](borrowedCTokenList.length);\n', '\n', '        for(uint i = 0; i < borrowedCTokenList.length; i++){\n', '            borrowedAssets[i] = createBorrowAsset(borrowedCTokenList[i], CToken(borrowedCTokenList[i]).borrowBalanceStored(acc));\n', '        }\n', '\n', '        borrowedAssets = removeEmptyBorrowAsset(borrowedAssets);\n', '\n', '        return borrowedAssets;\n', '    }\n', '\n', '\n', '    function getFarmingAccountProfileInternal(AccountProfile memory accountProfile, uint targetedBorrowLimitPCTMantissa) internal view returns(bool isValidated, AccountProfile memory farmingAccountProfile){\n', '        //liquidation risk ranking needs to be lower or equials to 2\n', '        if(uint(getLiquidationRiskRankingInternal(accountProfile)) > 1) return (false, farmingAccountProfile);\n', '\n', '        //each supplied asset, run borrowANDsupplym check util borrowLimitsPCTPerAsset hits 80%withDelta\n', '        SupplyAsset[] memory suppliedAssets = accountProfile.suppliedAssets;\n', '\n', '        for(uint i = 0; i < suppliedAssets.length; i++){\n', '\n', '              if(suppliedAssets[i].collateralFactorMantissa_ == 0) continue;\n', '\n', '              uint maxBorrowAmount;\n', '              BorrowAsset memory moreBorrowAsset;\n', '              SupplyAsset memory moreSupplyAsset;\n', '\n', '              while(accountProfile.borrowLimitPCTLineItemMantissaList[i] <= targetedBorrowLimitPCTMantissa.sub(n1PCTMantissa)){\n', '                  maxBorrowAmount = suppliedAssets[i].asset.amount.mul(suppliedAssets[i].collateralFactorMantissa_).mul(targetedBorrowLimitPCTMantissa.sub(accountProfile.borrowLimitPCTLineItemMantissaList[i])).div(oneMantissa).div(oneMantissa);\n', '                  moreBorrowAsset = createBorrowAsset(suppliedAssets[i].asset.cTokenAddr, maxBorrowAmount);\n', '                  moreSupplyAsset = createSupplyAsset(suppliedAssets[i].asset.cTokenAddr, maxBorrowAmount);\n', '\n', '                  addBorrowAsset(accountProfile, moreBorrowAsset);\n', '                  addSuppliedAsset(accountProfile, moreSupplyAsset);\n', '\n', '              }\n', '        }\n', '\n', '        return (true, accountProfile);\n', '    }\n', '\n', '    function getAccountInterestProfileInternal(address acc, uint numberOfBlocks) internal view returns(AccountInterestProfile memory accountInterestProfile){\n', '        return getAccountInterestProfileInternal(getAccountProfileInternal(acc), numberOfBlocks);\n', '    }\n', '\n', '    function getAccountInterestProfileInternal(AccountProfile memory accountProfile, uint numberOfBlocks) internal view returns(AccountInterestProfile memory accountInterestProfile){\n', '        return createAccountInterestProfile(getSupplyInterests(accountProfile.suppliedAssets, numberOfBlocks), getBorrowInterests(accountProfile.borrowedAssets, numberOfBlocks));\n', '    }\n', '\n', '    function getSupplyInterests(SupplyAsset[] memory supplyAssets, uint numberOfBlocks) internal view returns(CTokenInterest[] memory supplyInterests){\n', '        supplyInterests = new CTokenInterest[](supplyAssets.length);\n', '\n', '        address cTokenAddr;\n', '        uint interestRateMantissa;\n', '        uint balance;\n', '        for(uint i = 0; i < supplyAssets.length; i++){\n', '            cTokenAddr = supplyAssets[i].asset.cTokenAddr;\n', '            interestRateMantissa = CToken(cTokenAddr).supplyRatePerBlock();\n', '            balance = supplyAssets[i].asset.amount;\n', '\n', '            supplyInterests[i] = createCTokenInterest(cTokenAddr, interestRateMantissa, balance, numberOfBlocks);\n', '        }\n', '\n', '        return supplyInterests;\n', '    }\n', '\n', '    function getBorrowInterests(BorrowAsset[] memory borrowedAssets, uint numberOfBlocks) internal view returns(CTokenInterest[] memory borrowInterests){\n', '        borrowInterests = new CTokenInterest[](borrowedAssets.length);\n', '\n', '        address cTokenAddr;\n', '        uint interestRateMantissa;\n', '        uint balance;\n', '        for(uint i = 0; i < borrowedAssets.length; i++){\n', '            cTokenAddr = borrowedAssets[i].asset.cTokenAddr;\n', '            interestRateMantissa = CToken(cTokenAddr).borrowRatePerBlock();\n', '            balance = borrowedAssets[i].asset.amount;\n', '\n', '            borrowInterests[i] = createCTokenInterest(cTokenAddr, interestRateMantissa, balance, numberOfBlocks);\n', '        }\n', '\n', '        return borrowInterests;\n', '    }\n', '\n', '    function getLiquidationRiskRankingInternal(AccountProfile memory accountProfile) internal view returns(LiquidationRiskRanking liquidationRiskRanking){\n', '        //find all the supplied asset\n', '        //find all the matching asset\n', '        //find calBorrowLimitPCTLineItemMantissaList\n', '        //check to see if any borrowed asset outside from supplied asset, acceptable asset require valueInUSD over 1\n', '        //check to see if any borrowed asset with underlying supplied of 0 collateral factor\n', '\n', '        //get account interest profile\n', '\n', '\n', '        liquidationRiskRanking = LiquidationRiskRanking.ZERO_RISK;\n', '///\n', '        if(!getAccountInterestProfileInternal(accountProfile, 1).isPositiveInterest_){\n', '            liquidationRiskRanking = LiquidationRiskRanking.INTEREST_RISK_ONLY;\n', '        }\n', '\n', '        for(uint i = 0; i < accountProfile.borrowLimitPCTLineItemMantissaList.length; i++){\n', '            if(accountProfile.borrowLimitPCTLineItemMantissaList[i] == MAX_INT_NUMBER) continue;\n', '\n', '            if(accountProfile.borrowLimitPCTLineItemMantissaList[i] > oneMantissa) {\n', '                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\n', '                break;\n', '            }\n', '\n', '        }\n', '\n', '        bool hasFound;\n', '        SupplyAsset memory suppliedAsset;\n', '        for(uint i = 0; i < accountProfile.borrowedAssets.length; i++){\n', '            if(accountProfile.borrowedAssets[i].asset.valueInUSD_ < oneMantissa) continue;  //filter small value asset(asset USD value less than 1 USD)\n', '\n', '            (hasFound, suppliedAsset) = findSuppliedAsset(accountProfile.borrowedAssets[i].asset.cTokenAddr, accountProfile.suppliedAssets);\n', '\n', '            if(!hasFound){\n', '                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\n', '                break;\n', '            }\n', '\n', '            if(suppliedAsset.collateralFactorMantissa_ == 0){\n', '                liquidationRiskRanking = LiquidationRiskRanking.PRICE_MOVEMENT_RISK;\n', '                break;\n', '            }\n', '        }\n', '\n', '        return liquidationRiskRanking;\n', '    }\n', '\n', '    function getLiquidationRiskRankingInternal(address acc) internal view returns(LiquidationRiskRanking liquidationRiskRanking){\n', '        return getLiquidationRiskRankingInternal(getAccountProfileInternal(acc));\n', '    }\n', '\n', '    function getMaxInterestAccountProfileInternal(AccountProfile memory accountProfile) internal view returns(bool isValidated, AccountProfile memory maxInterestAccountProfile){\n', '        if(uint(getLiquidationRiskRankingInternal(accountProfile)) > 1) return (false, maxInterestAccountProfile);\n', '\n', '        SupplyAsset[] memory newSupplyAssets = new SupplyAsset[](accountProfile.suppliedAssets.length);\n', '\n', '        address cTokenAddr;\n', '        uint amount;\n', '        bool hasFound;\n', '        BorrowAsset memory borrowedAsset;\n', '        for(uint i = 0; i < accountProfile.suppliedAssets.length; i++){\n', '            cTokenAddr = accountProfile.suppliedAssets[i].asset.cTokenAddr;\n', '\n', '            (hasFound, borrowedAsset) = findBorrowAsset(cTokenAddr, accountProfile.borrowedAssets);\n', '            if(!hasFound){\n', '                amount = accountProfile.suppliedAssets[i].asset.amount;\n', '            }\n', '\n', '            amount = accountProfile.suppliedAssets[i].asset.amount.sub(borrowedAsset.asset.amount);\n', '\n', '            newSupplyAssets[i] = createSupplyAsset(cTokenAddr, amount);\n', '        }\n', '\n', '        BorrowAsset[] memory borrowedAssets;\n', '\n', '        return (true, createAccountProfile(newSupplyAssets, borrowedAssets));\n', '    }\n', '\n', '\n', '\n', '}']