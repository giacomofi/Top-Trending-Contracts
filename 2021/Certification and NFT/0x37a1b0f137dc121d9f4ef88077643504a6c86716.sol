['pragma solidity 0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./SafeMath.sol";\n', '// File: contracts/governance/GovernorAlpha.sol\n', '\n', '\n', '// Original work from Compound: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\n', '// Modified to work in the YAM system\n', '\n', '// all votes work on underlying _auscBalances[address], not balanceOf(address)\n', '\n', '// Original audit: https://blog.openzeppelin.com/compound-alpha-governance-system-audit/\n', '// Overview:\n', '//    No Critical\n', '//    High:\n', '//      Issue:\n', '//        Approved proposal may be impossible to queue, cancel or execute\n', '//        Fixed with `proposalMaxOperations`\n', '//      Issue:\n', '//        Queued proposal with repeated actions cannot be executed\n', '//        Fixed by explicitly disallow proposals with repeated actions to be queued in the Timelock contract.\n', '//\n', '// Changes made by YAM after audit:\n', '//    Formatting, naming, & uint256 instead of uint\n', '//    Since YAM supply changes, updated quorum & proposal requirements\n', '//    If any uint96, changed to uint256 to match YAM as opposed to comp\n', '\n', 'contract GovernorStorage {\n', '    /// @notice Ballot receipt record for a voter\n', '    struct Receipt {\n', '        /// @notice Whether or not a vote has been cast\n', '        bool hasVoted;\n', '\n', '        /// @notice Whether or not the voter supports the proposal\n', '        bool support;\n', '\n', '        /// @notice The number of votes the voter had, which were cast\n', '        uint256 votes;\n', '    }\n', '\n', '    struct Proposal {\n', '        /// @notice Unique id for looking up a proposal\n', '        uint256 id;\n', '\n', '        /// @notice Creator of the proposal\n', '        address proposer;\n', '\n', '        /// @notice Approver of the proposal\n', '        address approver;\n', '        \n', '        /// @notice The block number the proposal is created on\n', '        uint256 createBlock;\n', '\n', '        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n', '        uint256 eta;\n', '\n', '        /// @notice the ordered list of target addresses for calls to be made\n', '        address[] targets;\n', '\n', '        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n', '        uint[] values;\n', '\n', '        /// @notice The ordered list of function signatures to be called\n', '        string[] signatures;\n', '\n', '        /// @notice The ordered list of calldata to be passed to each call\n', '        bytes[] calldatas;\n', '\n', '        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n', '        uint256 startBlock;\n', '\n', '        /// @notice The block at which voting ends: votes must be cast prior to this block\n', '        uint256 endBlock;\n', '\n', '        /// @notice Current number of votes in favor of this proposal\n', '        uint256 forVotes;\n', '\n', '        /// @notice Current number of votes in opposition to this proposal\n', '        uint256 againstVotes;\n', '\n', '        /// @notice Flag marking whether the proposal has been canceled\n', '        bool canceled;\n', '\n', '        /// @notice Flag marking whether the proposal has been executed\n', '        bool executed;\n', '\n', '        /// @notice Receipts of ballots for the entire set of voters\n', '        mapping (address => Receipt) receipts;\n', '    }\n', '    /// @notice Possible states that a proposal may be in\n', '    enum ProposalState {\n', '        Created,\n', '        Pending,\n', '        Active,\n', '        Canceled,\n', '        Defeated,\n', '        Succeeded,\n', '        Queued,\n', '        Expired,\n', '        Executed\n', '    }\n', '\n', '}\n', '\n', 'contract GovernorEvents {\n', '     /// @notice An event emitted when a new proposal is created\n', '    event ProposalCreated(uint256 id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, string description);\n', '\n', '    /// @notice An event emitted when a proposal is added to pending\n', '    event ProposalApproved(uint256 id, address approver,  uint256 startBlock, uint256 endBlock);\n', '\n', '    /// @notice An event emitted when a vote has been cast on a proposal\n', '    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n', '\n', '    /// @notice An event emitted when a proposal has been canceled\n', '    event ProposalCanceled(uint256 id, address callerAddress);\n', '\n', '    /// @notice An event emitted when a proposal has been queued in the Timelock\n', '    event ProposalQueued(uint256 id, uint256 eta, address callerAddress);\n', '\n', '    /// @notice An event emitted when a proposal has been executed in the Timelock\n', '    event ProposalExecuted(uint256 id, address callerAddress);\n', '\n', '    event VotingDelaySet(uint oldVotingDelay, uint newVotingDelay);\n', '\n', '    /// @notice An event emitted when the voting period is set\n', '    event VotingPeriodSet(uint oldVotingPeriod, uint newVotingPeriod);\n', '\n', '    /// @notice Emitted when approve Percent is set\n', '    event ApprovePercentSet(uint oldProposalPercent, uint newProposalPercent);\n', '\n', '    /// @notice Emitted when Quorum Percent is set\n', '    event QuorumPercentSet(uint oldPercent, uint quorumPercent);\n', '\n', '    /// @notice Emitted when pendingAdmin is changed\n', '    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n', '\n', '    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n', '    event NewAdmin(address oldAdmin, address newAdmin);\n', '}\n', '\n', 'contract AUSCMGovernor is GovernorStorage, GovernorEvents {\n', '    /// @notice The name of this contract\n', '    string public constant NAME = "AUSCM Governor";\n', '    \n', '    /// @notice The minimum setable approve threshold\n', '    uint public constant MIN_APPROVE_THRESHOLD = 50; // 0.5% voting power\n', '\n', '    /// @notice The maximum setable approve threshold\n', '    uint public constant MAX_APPROVE_THRESHOLD = 500; // 5% voting power\n', '\n', '    /// @notice The minimum setable quorum threshold\n', '    uint public constant MIN_QUORUM_THRESHOLD = 50; // 0.5% voting power\n', '\n', '    /// @notice The maximum setable quorum threshold\n', '    uint public constant MAX_QUORUM_THRESHOLD = 1000; // 10% voting power\n', '\n', '    /// @notice The minimum setable voting period\n', '    uint public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\n', '\n', '    /// @notice The max setable voting period\n', '    uint public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\n', '\n', '    /// @notice The min setable voting delay\n', '    uint public constant MIN_VOTING_DELAY = 1; // 1 block\n', '\n', '    /// @notice The max setable voting delay\n', '    uint public constant MAX_VOTING_DELAY = 40320; // About 1 week\n', '    \n', '    /// @notice Percentage of votes needed for a proposal to pass multiplied by 100 (to accomodate 2 decimal point) i.e. 125 = 1.25%\n', '    uint public quorumPercent = 400; // 4% by default\n', '    \n', '    /// @notice Percentage of votes needed for a proposal to be approved\n', '    uint public approvePercent = 100; // 1% voting power\n', '    \n', '    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n', '    uint public votingDelay = 1; // 1 block\n', '\n', '    /// @notice The duration of voting on a proposal, in blocks\n', '    uint public votingPeriod =  17280; // ~3 days in blocks (assuming 15s blocks)\n', '\n', '    /// @notice The duration of the approval phase of a proposal\n', '    uint public approvalPeriod = 5760; // ~1 day in blocks (assuming 15s blocks)\n', '\n', '    /// @notice The maximum number of actions that can be included in a proposal\n', '    function proposalMaxOperations() public pure returns (uint256) { return 10; } // 10 actions\n', '\n', '    /// @notice The address of the Timelock\n', '    TimelockInterface public timelock;\n', '\n', '    /// @notice The address of the governance token\n', '    AUSCInterface public ausc;\n', '\n', '    /// @notice The address of the Governor Guardian\n', '    address public guardian;\n', '    \n', '    /// @notice The address of the Governor Admin\n', '    address public admin;\n', '    \n', '    /// @notice The address of the pending Admin\n', '    address public pendingAdmin;\n', '\n', '    /// @notice The total number of proposals\n', '    uint256 public proposalCount;\n', '\n', '    /// @notice The official record of all proposals ever proposed\n', '    mapping (uint256 => Proposal) public proposals;\n', '\n', '    /// @notice The latest proposal for each proposer\n', '    mapping (address => uint256) public latestProposalIds;\n', '\n', '    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    function quorumVotes() public view returns (uint256) {\n', '        uint256 minimumVotes =  SafeMath.div(ausc.initSupply(), 10000); // Quorum requirement is always a multiple of 0.01% of AUSC supply\n', '        return SafeMath.mul(minimumVotes, quorumPercent); \n', '    }\n', '    \n', '    /// @notice The number of votes required in order for a voter to approve a proposal\n', '    function approveVotes() public view returns (uint256) {\n', '        uint256 minimumVotes =  SafeMath.div(ausc.initSupply(), 10000); // Approval requirement is always a multiple of 0.01% of AUSC supply\n', '        return SafeMath.mul(minimumVotes, approvePercent);\n', '    }\n', '\n', '    /// @notice The number of Tokens required in order for a voter to create a proposal\n', '    function createVotes() public pure returns (uint256) { return 9000; }\n', '\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\n', '    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n', '    bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,bool support)");\n', '\n', '\n', '    constructor(address timelock_, address ausc_) public {\n', '        timelock = TimelockInterface(timelock_);\n', '        ausc = AUSCInterface(ausc_);\n', '        guardian = msg.sender;\n', '        admin = msg.sender;\n', '    }\n', '\n', '    function propose(\n', '        address[] memory targets,\n', '        uint[] memory values,\n', '        string[] memory signatures,\n', '        bytes[] memory calldatas,\n', '        string memory description\n', '    )\n', '        public\n', '        returns (uint256)\n', '    {\n', '        require(ausc.balanceOf(msg.sender) >= createVotes(), "POWERLEVEL UNDER 9000!!! Proposer balance below create threshold");\n', '        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, "AUSCMGovernor::propose: proposal function information arity mismatch");\n', '        require(targets.length != 0, "AUSCMGovernor::propose: must provide actions");\n', '        require(targets.length <= proposalMaxOperations(), "AUSCMGovernor::propose: too many actions");\n', '\n', '        uint256 latestProposalId = latestProposalIds[msg.sender];\n', '        if (latestProposalId != 0) {\n', '          ProposalState proposersLatestProposalState = state(latestProposalId);\n', '           require(proposersLatestProposalState != ProposalState.Pending, "AUSCMGovernor::propose: one live proposal per proposer, found an already unapproved proposal");\n', '          require(proposersLatestProposalState != ProposalState.Active, "AUSCMGovernor::propose: one live proposal per proposer, found an already active proposal");\n', '          require(proposersLatestProposalState != ProposalState.Created, "AUSCMGovernor::propose: one live proposal per proposer, found an already created proposal");\n', '        }\n', '\n', '        uint256 startBlock = block.number;\n', '        uint256 endBlock = SafeMath.add(startBlock, approvalPeriod);\n', '\n', '        proposalCount++;\n', '        Proposal memory newProposal = Proposal({\n', '            id: proposalCount,\n', '            proposer: msg.sender,\n', '            approver: address(0),\n', '            createBlock: block.number,\n', '            eta: 0,\n', '            targets: targets,\n', '            values: values,\n', '            signatures: signatures,\n', '            calldatas: calldatas,\n', '            startBlock: startBlock,\n', '            endBlock: endBlock,\n', '            forVotes: 0,\n', '            againstVotes: 0,\n', '            canceled: false,\n', '            executed: false\n', '        });\n', '\n', '        proposals[newProposal.id] = newProposal;\n', '        latestProposalIds[newProposal.proposer] = newProposal.id;\n', '\n', '        emit ProposalCreated(\n', '            newProposal.id,\n', '            msg.sender,\n', '            targets,\n', '            values,\n', '            signatures,\n', '            calldatas,\n', '            description\n', '        );\n', '        return newProposal.id;\n', '    }\n', '    \n', '    function approve(uint256 proposalId)\n', '        public\n', '    {\n', '        require(state(proposalId) == ProposalState.Created, "AUSCMGovernor::add: proposal already approved or expired");\n', '        require(ausc.getPriorVotes(msg.sender, SafeMath.sub(block.number, 1)) >= approveVotes(), "AUSCMGovernor::propose: approver votes below approval threshold");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        uint256 startBlock = SafeMath.add(block.number, votingDelay);\n', '        uint256 endBlock = SafeMath.add(startBlock, votingPeriod);\n', '        proposal.approver = msg.sender;\n', '        proposal.startBlock = startBlock;\n', '        proposal.endBlock = endBlock;\n', '        \n', '        emit ProposalApproved(\n', '            proposal.id,\n', '            msg.sender,\n', '            startBlock,\n', '            endBlock\n', '        );\n', '\n', '    }\n', '\n', '    function queue(uint256 proposalId)\n', '        public\n', '    {\n', '        require(state(proposalId) == ProposalState.Succeeded, "AUSCMGovernor::queue: proposal can only be queued if it is succeeded");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        uint256 eta = SafeMath.add(block.timestamp, timelock.delay());\n', '        for (uint256 i = 0; i < proposal.targets.length; i++) {\n', '            _queueOrRevert(\n', '                proposal.targets[i],\n', '                proposal.values[i],\n', '                proposal.signatures[i],\n', '                proposal.calldatas[i],\n', '                eta\n', '            );\n', '        }\n', '        proposal.eta = eta;\n', '        emit ProposalQueued(proposalId, eta, msg.sender);\n', '    }\n', '\n', '    function _queueOrRevert(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    )\n', '        internal\n', '    {\n', '        require(!timelock.queuedTransactions(\n', '              keccak256(\n', '                  abi.encode(\n', '                      target,\n', '                      value,\n', '                      signature,\n', '                      data,\n', '                      eta\n', '                  )\n', '              )\n', '          ),\n', '          "AUSCMGovernor::_queueOrRevert: proposal action already queued at eta"\n', '        );\n', '\n', '        timelock.queueTransaction(target, value, signature, data, eta);\n', '    }\n', '\n', '    function execute(uint256 proposalId)\n', '        public\n', '        payable\n', '    {\n', '        require(state(proposalId) == ProposalState.Queued, "AUSCMGovernor::execute: proposal can only be executed if it is queued");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        proposal.executed = true;\n', '        for (uint256 i = 0; i < proposal.targets.length; i++) {\n', '            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '        emit ProposalExecuted(proposalId, msg.sender);\n', '    }\n', '\n', '    function cancel(uint256 proposalId)\n', '        public\n', '    {\n', '        ProposalState state = state(proposalId);\n', '        require(state != ProposalState.Executed, "AUSCMGovernor::cancel: cannot cancel executed proposal");\n', '\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(msg.sender == guardian || msg.sender == proposal.proposer || ausc.balanceOf(proposal.approver) < approveVotes(), "AUSCMGovernor::cancel: proposer above threshold");\n', '\n', '        proposal.canceled = true;\n', '        for (uint256 i = 0; i < proposal.targets.length; i++) {\n', '            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '\n', '        emit ProposalCanceled(proposalId, msg.sender);\n', '    }\n', '\n', '    function getActions(uint256 proposalId)\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory targets,\n', '            uint[] memory values,\n', '            string[] memory signatures,\n', '            bytes[] memory calldatas\n', '        )\n', '    {\n', '        Proposal storage p = proposals[proposalId];\n', '        return (p.targets, p.values, p.signatures, p.calldatas);\n', '    }\n', '\n', '    function getReceipt(uint256 proposalId, address voter)\n', '        public\n', '        view\n', '        returns (Receipt memory)\n', '    {\n', '        return proposals[proposalId].receipts[voter];\n', '    }\n', '\n', '    function state(uint256 proposalId)\n', '        public\n', '        view\n', '        returns (ProposalState)\n', '    {\n', '        require(proposalCount >= proposalId && proposalId > 0, "AUSCMGovernor::state: invalid proposal id");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        if (proposal.canceled) {\n', '            return ProposalState.Canceled;\n', '        } else if (proposal.approver == address(0) && block.number >= SafeMath.add(proposal.createBlock, approvalPeriod)) {\n', '            return ProposalState.Expired;\n', '        } else if (proposal.approver == address(0)) {\n', '            return ProposalState.Created;\n', '        } else if (block.number <= proposal.startBlock) {\n', '            return ProposalState.Pending;\n', '        } else if (block.number <= proposal.endBlock) {\n', '            return ProposalState.Active;\n', '        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n', '            return ProposalState.Defeated;\n', '        } else if (proposal.eta == 0) {\n', '            return ProposalState.Succeeded;\n', '        } else if (proposal.executed) {\n', '            return ProposalState.Executed;\n', '        } else if (block.timestamp >= SafeMath.add(proposal.eta, timelock.GRACE_PERIOD())) {\n', '            return ProposalState.Expired;\n', '        } else {\n', '            return ProposalState.Queued;\n', '        }\n', '    }\n', '\n', '    function castVote(uint256 proposalId, bool support)\n', '        public\n', '    {\n', '        return _castVote(msg.sender, proposalId, support);\n', '    }\n', '\n', '    function _castVote(\n', '        address voter,\n', '        uint256 proposalId,\n', '        bool support\n', '    )\n', '        internal\n', '    {\n', '        require(state(proposalId) == ProposalState.Active, "AUSCMGovernor::_castVote: voting is closed");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        Receipt storage receipt = proposal.receipts[voter];\n', '        require(receipt.hasVoted == false, "AUSCMGovernor::_castVote: voter already voted");\n', '        uint256 votes = ausc.getPriorVotes(voter, proposal.startBlock);\n', '\n', '        if (support) {\n', '            proposal.forVotes = SafeMath.add(proposal.forVotes, votes);\n', '        } else {\n', '            proposal.againstVotes = SafeMath.add(proposal.againstVotes, votes);\n', '        }\n', '\n', '        receipt.hasVoted = true;\n', '        receipt.support = support;\n', '        receipt.votes = votes;\n', '\n', '        emit VoteCast(voter, proposalId, support, votes);\n', '    }\n', '\n', '    /**\n', '      * @notice Admin function for setting the voting delay\n', '      * @param newVotingDelay new voting delay, in blocks\n', '      */\n', '    function _setVotingDelay(uint newVotingDelay) external {\n', '        require(msg.sender == admin, "AUSCMGovernor::_setVotingDelay: admin only");\n', '        require(newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY, "AUSCMGovernor::_setVotingDelay: invalid voting delay");\n', '        uint oldVotingDelay = votingDelay;\n', '        votingDelay = newVotingDelay;\n', '\n', '        emit VotingDelaySet(oldVotingDelay,votingDelay);\n', '    }\n', '\n', '    /**\n', '      * @notice Admin function for setting the voting period\n', '      * @param newVotingPeriod new voting period, in blocks\n', '      */\n', '    function _setVotingPeriod(uint newVotingPeriod) external {\n', '        require(msg.sender == admin, "AUSCMGovernor::_setVotingPeriod: admin only");\n', '        require(newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD, "AUSCMGovernor::_setVotingPeriod: invalid voting period");\n', '        uint oldVotingPeriod = votingPeriod;\n', '        votingPeriod = newVotingPeriod;\n', '\n', '        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n', '    }\n', '\n', '    /**\n', '      * @notice Admin function for setting the approve threshold\n', '      * @dev newApprovePercent must be greater than the hardcoded min\n', '      * @param newApprovePercent new approve threshold\n', '      */\n', '    function _setApprovePercent(uint newApprovePercent) external {\n', '        require(msg.sender == admin, "AUSCMGovernor::_setProposalThreshold: admin only");\n', '        require(newApprovePercent >= MIN_APPROVE_THRESHOLD && newApprovePercent <= MAX_APPROVE_THRESHOLD, "AUSCMGovernor::_setProposalThreshold: invalid approve threshold");\n', '        uint oldApprovePercent = approvePercent;\n', '        approvePercent = newApprovePercent;\n', '\n', '        emit ApprovePercentSet(oldApprovePercent, approvePercent);\n', '    }\n', '\n', '    /**\n', '      * @notice Admin function for setting the Quorum Percent\n', '      * @dev newQuorum must be greater than the hardcoded min\n', '      * @param newQuorum new quorum threshold\n', '      */\n', '    function _setQuorumPercent(uint newQuorum) public {\n', '        require(msg.sender == admin, "AUSCMGovernor::_setQuorumPercent admin only");\n', '        require(newQuorum >= MIN_QUORUM_THRESHOLD && newQuorum <= MAX_QUORUM_THRESHOLD, "AUSCMGovernor::_setQuorumPercent: invalid quorum percent");\n', '        uint oldQuorumPercent = quorumPercent;\n', '        quorumPercent = newQuorum;\n', '\n', '        emit QuorumPercentSet(oldQuorumPercent, quorumPercent);\n', '    }\n', '        /**\n', '      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '      * @param newPendingAdmin New pending admin.\n', '      */\n', '    function _setPendingAdmin(address newPendingAdmin) external {\n', '        // Check caller = admin\n', '        require(msg.sender == admin, "AUSCMGovernor:_setPendingAdmin: admin only");\n', '\n', '        // Save current value, if any, for inclusion in log\n', '        address oldPendingAdmin = pendingAdmin;\n', '\n', '        // Store pendingAdmin with value newPendingAdmin\n', '        pendingAdmin = newPendingAdmin;\n', '\n', '        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n', '        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n', '    }\n', '\n', '    /**\n', '      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n', '      * @dev Admin function for pending admin to accept role and update admin\n', '      */\n', '    function _acceptAdmin() external {\n', '        // Check caller is pendingAdmin and pendingAdmin â‰  address(0)\n', '        require(msg.sender == pendingAdmin && msg.sender != address(0), "AUSCMGovernor:_acceptAdmin: pending admin only");\n', '\n', '        // Save current values for inclusion in log\n', '        address oldAdmin = admin;\n', '        address oldPendingAdmin = pendingAdmin;\n', '\n', '        // Store admin with value pendingAdmin\n', '        admin = pendingAdmin;\n', '\n', '        // Clear the pending value\n', '        pendingAdmin = address(0);\n', '\n', '        emit NewAdmin(oldAdmin, admin);\n', '        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n', '    }\n', '    \n', '    function _acceptTimelockAdmin()\n', '        public\n', '    {\n', '        require(msg.sender == guardian, "AUSCMGovernor::_acceptTimelockAdmin: sender must be gov guardian");\n', '        timelock.acceptAdmin();\n', '    }\n', '\n', '    function __abdicate()\n', '        public\n', '    {\n', '        require(msg.sender == guardian, "AUSCMGovernor::__abdicate: sender must be gov guardian");\n', '        guardian = address(0);\n', '    }\n', '\n', '    function __queueSetTimelockPendingAdmin(\n', '        address newPendingAdmin,\n', '        uint256 eta\n', '    )\n', '        public\n', '    {\n', '        require(msg.sender == guardian, "AUSCMGovernor::__queueSetTimelockPendingAdmin: sender must be gov guardian");\n', '        timelock.queueTransaction(address(timelock), 0, "setPendingAdmin(address)", abi.encode(newPendingAdmin), eta);\n', '    }\n', '\n', '    function __executeSetTimelockPendingAdmin(\n', '        address newPendingAdmin,\n', '        uint256 eta\n', '    )\n', '        public\n', '    {\n', '        require(msg.sender == guardian, "AUSCMGovernor::__executeSetTimelockPendingAdmin: sender must be gov guardian");\n', '        timelock.executeTransaction(address(timelock), 0, "setPendingAdmin(address)", abi.encode(newPendingAdmin), eta);\n', '    }\n', '}\n', '\n', 'interface TimelockInterface {\n', '    function delay() external view returns (uint256);\n', '    function GRACE_PERIOD() external view returns (uint256);\n', '    function acceptAdmin() external;\n', '    function queuedTransactions(bytes32 hash) external view returns (bool);\n', '    function queueTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external returns (bytes32);\n', '    function cancelTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external;\n', '    function executeTransaction(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta) external payable returns (bytes memory);\n', '}\n', '\n', 'interface AUSCInterface {\n', '    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function initSupply() external view returns (uint256);\n', '}']