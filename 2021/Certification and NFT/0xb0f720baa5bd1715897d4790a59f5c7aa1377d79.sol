['// SPDX-License-Identifier: GPL3\n', '\n', 'pragma solidity 0.8.0;\n', '\n', "import './IMVDFunctionalitiesManager.sol';\n", "import './IDoubleProxy.sol';\n", "import './IMVDProxy.sol';\n", '\n', "import './IMateriaOrchestrator.sol';\n", "import './IMateriaFactory.sol';\n", '\n', "import './IEthItemInteroperableInterface.sol';\n", "import './IERC20WrapperV1.sol';\n", '\n', "import './MateriaLibrary.sol';\n", "import './TransferHelper.sol';\n", '\n', 'abstract contract Proxy {\n', '    function _delegate(address implementation) internal virtual {\n', '        assembly {\n', '            calldatacopy(0, 0, calldatasize())\n', '            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '            returndatacopy(0, 0, returndatasize())\n', '            switch result\n', '                case 0 {\n', '                    revert(0, returndatasize())\n', '                }\n', '                default {\n', '                    return(0, returndatasize())\n', '                }\n', '        }\n', '    }\n', '}\n', '\n', 'contract MateriaOrchestrator is Proxy, IMateriaOrchestrator {\n', '    IDoubleProxy public override doubleProxy;\n', '\n', '    address public override swapper;\n', '    address public override liquidityAdder;\n', '    address public override liquidityRemover;\n', '\n', '    IMateriaFactory public override factory;\n', '    IERC20WrapperV1 public override erc20Wrapper;\n', '    IERC20 public override bridgeToken;\n', '    uint256 public override ETHEREUM_OBJECT_ID;\n', '\n', '    constructor(\n', '        address initialFactory,\n', '        address initialBridgeToken,\n', '        address initialErc20Wrapper,\n', '        address initialDoubleProxy,\n', '        address initialLiquidityAdder,\n', '        address initialLiquidityRemover,\n', '        address initialSwapper\n', '    ) {\n', '        factory = IMateriaFactory(initialFactory);\n', '        bridgeToken = IERC20(initialBridgeToken);\n', '        erc20Wrapper = IERC20WrapperV1(initialErc20Wrapper);\n', "        ETHEREUM_OBJECT_ID = uint256(keccak256(bytes('THE ETHEREUM OBJECT IT')));\n", '        doubleProxy = IDoubleProxy(initialDoubleProxy);\n', '        liquidityAdder = initialLiquidityAdder;\n', '        liquidityRemover = initialLiquidityRemover;\n', '        swapper = initialSwapper;\n', '    }\n', '\n', '    function setDoubleProxy(address newDoubleProxy) external override onlyDFO {\n', '        doubleProxy = IDoubleProxy(newDoubleProxy);\n', '    }\n', '\n', '    function setBridgeToken(address newBridgeToken) external override onlyDFO {\n', '        bridgeToken = IERC20(newBridgeToken);\n', '    }\n', '\n', '    function setErc20Wrapper(address newErc20Wrapper) external override onlyDFO {\n', '        erc20Wrapper = IERC20WrapperV1(newErc20Wrapper);\n', '    }\n', '\n', '    function setFactory(address newFactory) external override onlyDFO {\n', '        factory = IMateriaFactory(newFactory);\n', '    }\n', '\n', '    function setEthereumObjectId(uint256 newEthereumObjectId) external override onlyDFO {\n', '        ETHEREUM_OBJECT_ID = newEthereumObjectId;\n', '    }\n', '\n', '    function setSwapper(address _swapper) external override onlyDFO {\n', '        swapper = _swapper;\n', '    }\n', '\n', '    function setLiquidityAdder(address _adder) external override onlyDFO {\n', '        liquidityAdder = _adder;\n', '    }\n', '\n', '    function setLiquidityRemover(address _remover) external override onlyDFO {\n', '        liquidityRemover = _remover;\n', '    }\n', '\n', '    function retire(address newOrchestrator) external override onlyDFO {\n', '        factory.transferOwnership(newOrchestrator);\n', '    }\n', '\n', '    function setFees(\n', '        address token,\n', '        uint256 materiaFee,\n', '        uint256 swapFee\n', '    ) external override onlyDFO {\n', '        factory.setFees(MateriaLibrary.pairFor(address(factory), address(bridgeToken), token), materiaFee, swapFee);\n', '    }\n', '\n', '    function setDefaultFees(uint256 materiaFee, uint256 swapFee) external override onlyDFO {\n', '        factory.setDefaultMateriaFee(materiaFee);\n', '        factory.setDefaultSwapFee(swapFee);\n', '    }\n', '\n', '    function setFeeTo(address feeTo) external override onlyDFO {\n', '        factory.setFeeTo(feeTo);\n', '    }\n', '\n', '    //better be safe than sorry\n', '    function getCrumbs(\n', '        address token,\n', '        uint256 amount,\n', '        address receiver\n', '    ) external override onlyDFO {\n', '        TransferHelper.safeTransfer(token, receiver, amount);\n', '    }\n', '\n', '    modifier onlyDFO() {\n', '        require(IMVDFunctionalitiesManager(IMVDProxy(doubleProxy.proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(msg.sender), "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {\n', "        require(msg.sender == address(erc20Wrapper), 'Only EthItem can send ETH to this contract');\n", '    }\n', '\n', '    /**\n', '     * As ERC1155 receiver Materia Orchestrator implements onERC1155Received and onERC1155BatchReceived.\n', '     * onERC1155Received exposes the delegate call to the Liquidity Adder, Remover Liquidity and to the Swapper contracts.\n', '     * Calling with a callback you will be able to specify the operation needed.\n', '     * onERC1155BatchReceived will be implemented with batch/lego operation.\n', '     */\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        bytes calldata payload\n', '    ) external override returns (bytes4) {\n', '        (uint256 operation, ) = abi.decode(payload, (uint256, bytes));\n', '        if (operation == 1) {\n', '            //Adding liquidity\n', '            _delegate(liquidityAdder);\n', '        } else if (operation == 2 || operation == 3 || operation == 4 || operation == 5) {\n', '            //Remove liquidity\n', '            _delegate(swapper); //Swapping\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        bytes calldata\n', '    ) external pure override returns (bytes4) {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '     * Liquidity adding methods are exposed to call the Liquidity Adder contract via a secure channel such as the Orchestrator.\n', '     * Both addLiquidity and addLiquidityETH methods are provided. addLiquidity can be used for ERC20 and ITEMs.\n', '     */\n', '\n', '    function addLiquidity(\n', '        address token,\n', '        uint256 tokenAmountDesired,\n', '        uint256 bridgeAmountDesired,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        override\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        )\n', '    {\n', '        _delegate(liquidityAdder);\n', '    }\n', '\n', '    function addLiquidityETH(\n', '        uint256 bridgeAmountDesired,\n', '        uint256 EthAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        override\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        )\n', '    {\n', '        _delegate(liquidityAdder);\n', '    }\n', '\n', '    /**\n', '     * Liquidity removing methods are exposed to call the Liquidity Remover contract via a secure channel such as the Orchestrator.\n', '     * The following methods are provided:\n', '     * removeLiquidity, removeLiquidityETH, removeLiquidityWithPermit and removeLiquidityETHWithPermit\n', '     */\n', '\n', '    function removeLiquidity(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override {\n', '        _delegate(liquidityRemover);\n', '    }\n', '\n', '    function removeLiquidityETH(\n', '        uint256 liquidity,\n', '        uint256 bridgeAmountMin,\n', '        uint256 EthAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override {\n', '        _delegate(liquidityRemover);\n', '    }\n', '\n', '    function removeLiquidityWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _delegate(liquidityRemover);\n', '    }\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        uint256 liquidity,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _delegate(liquidityRemover);\n', '    }\n', '\n', '    /**\n', '     * Swapping methods are exposed to call the Swapper Operator contract via a secure channel such as the Orchestrator.\n', '     * The following methods are provided:\n', '     * swapExactTokensForTokens, swapTokensForExactTokens, swapExactETHForTokens, swapTokensForExactETH, swapExactTokensForETH and swapETHForExactTokens\n', '     */\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override returns (uint256[] memory amounts) {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override returns (uint256[] memory amounts) {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public payable override {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public payable override {\n', '        _delegate(swapper);\n', '    }\n', '\n', '    /**\n', '     * Methods are exposed for the UI to retrive useful information such as quote, getAmountOut, getAmountIn, getAmountsOut, getAmountsIn\n', '     */\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) public pure override returns (uint256 amountB) {\n', '        return MateriaLibrary.quote(amountA, reserveA, reserveB);\n', '    }\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) public pure override returns (uint256 amountOut) {\n', '        return MateriaLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) public pure override returns (uint256 amountIn) {\n', '        return MateriaLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] memory path)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256[] memory amounts)\n', '    {\n', '        return MateriaLibrary.getAmountsOut(address(factory), amountIn, path);\n', '    }\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] memory path)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256[] memory amounts)\n', '    {\n', '        return MateriaLibrary.getAmountsIn(address(factory), amountOut, path);\n', '    }\n', '\n', '    /**\n', '     * isEthItem is a custom implementation to check whether a token is an ITEM or a standard ERC20.\n', '     */\n', '\n', '    function isEthItem(address token)\n', '        public\n', '        view\n', '        override\n', '        returns (\n', '            address collection,\n', '            bool ethItem,\n', '            uint256 itemId\n', '        )\n', '    {\n', '        if (token == address(0)) {\n', '            return (address(0), false, 0);\n', '        } else {\n', '            try IEthItemInteroperableInterface(token).mainInterface() returns (address mainInterface) {\n', '                return (mainInterface, true, IEthItemInteroperableInterface(token).objectId());\n', '            } catch {\n', '                return (address(0), false, 0);\n', '            }\n', '        }\n', '    }\n', '}']