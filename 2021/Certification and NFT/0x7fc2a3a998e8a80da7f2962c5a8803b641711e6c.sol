['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-07\n', '*/\n', '\n', '/**\n', ' *Paralism.com EPARA Token V1 on Ethereum\n', '*/\n', 'pragma solidity >=0.6.4 <0.8.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @title Math library with safety checks\n', '/// @author Paralism.com\n', 'library SafeMath {\n', '    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "add() overflow!");\n', '    }\n', '\n', '    function safeSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "sub() underflow!");\n', '    }\n', '    \n', '    function toUint64(uint256 _value) internal pure returns (uint64 z){\n', '        require(_value < 2**64, "toUint64() overflow!");\n', '        return uint64(_value);\n', '    }\n', '}\n', '\n', '/// @title Contract of EPARA\n', '/// @author Paralism.com\n', '/// @notice EPARA ERC20 contract with lock functionality extension \n', '/// @dev EPARA V1 March 2021 \n', 'contract EPARA {\n', '    using SafeMath for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    \n', '    uint256 internal _supplyCap;\n', '    uint256 public totalLocked;\n', '\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    mapping (address => uint256) public freezeOf;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner,address indexed spender,uint256 value);\n', '    \n', '    event Freeze(address indexed from, uint256 value);\n', '    event Unfreeze(address indexed from, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    struct TokensWithLock {\n', '        address sender;\n', '        uint256 lockValue;\n', '        uint64 lockTime;\n', '        bool allowLockTimeUpdate;      \n', '        uint64 initAskTime;\n', '        uint256 askToLock;\n', '    }\n', '\n', '    mapping (address => TokensWithLock) public lock;\n', '    \n', '    event TransferWithLock(address indexed sender, address indexed owner, uint256 value, uint256 lockTime ,uint256 initLockDays);\n', '    event ReturnLockedTokens(address indexed owner, address indexed sender, uint256 value);\n', '    event UpdateLockTime(address indexed sender, address indexed owner, uint256 lockDays);\n', '    event AllowUpdateLock(address indexed owner, bool allow);\n', '    event RequestToLock(address indexed sender, address indexed owner, uint256 value, uint256 intLockDays);\n', '    event AcceptLock(address indexed owner,address indexed sender, uint256 value, uint256 lockTime);\n', '    event ReduceLockValue(address indexed sender, address indexed owner, uint256 value);\n', ' \n', '    /*MultiSign*/\n', '    struct Approver {address addr; uint64 score; bool activated; }\n', '    struct ApproveTrans {address to; uint256 value; }\n', '    struct MultiSign {\n', '        uint256 multiSignBalance;\n', '        Approver[] approvers;\n', '        uint64 passScore;                // score of multi party signed to effective\n', '        uint64 expiration;               // MultiSign account expiration time in UNIX seconds\n', '        bool holdFlag;                // hold balance flag, for transfer check gas saving\n', '        address backAccount;             // all tokens controled by MultiSign will return to backAccount when expired\n', '    }\n', '    mapping (address => MultiSign) public multiSign;\n', '    struct Vote {\n', '        ApproveTrans approveTrans;       // transfer request\n', "        uint256 recall;                  // the requestion of recall from keeper's balance to multisign balance\n", '        address backAccount;             // the account where the expired token return to\n', "        bool holdBalance;                // true: freeze account keeper's balance\n", '        uint64 expireDays;               // update expiration days \n', '    }\n', '    mapping (address => mapping(address => Vote)) public vote;\n', '    \n', '    event MultiSignApprover(address indexed keeper, address indexed approver, uint individualScore);\n', '    event CreateMultiSign(address indexed keeper, uint passScore, address backAccount, uint expiration);\n', '    event FreezeKeeper(address indexed approver, address indexed keeper, bool freeze);\n', '    event HoldBalance(address indexed keeper, bool _freeze);\n', '    event ApproveTransferTo(address indexed approver,address indexed keeper, address indexed to, uint value);\n', '    event MultiSignTransfer(address indexed keeper, address indexed to, uint value);\n', '    event RecallToMultiSign(address indexed approver, address indexed keeper, uint value);\n', '    event MultiSignRecall(address indexed keeper, uint value);\n', '    event UpdateExpiration(address indexed approver, address indexed keeper,uint expireDays);\n', '    event MultiSignExpirationUpdated(address indexed keeper,uint expireDays);\n', '    event UpdateBackAccount(address indexed approver, address indexed keeper, address newBackAccount);\n', '    event MultiSignBackAccountUpdated(address indexed keeper, address newBackAccount);\n', '    event CancelVote(address indexed approver, address indexed keeper);\n', '    event TransferToMultiSign(address indexed approver,address indexed keeper, uint valu);\n', '    event ClearMutiSign(address indexed sender,address indexed keeper, address indexed backAccount,uint value);\n', '\n', '    constructor() {\n', '        decimals = 9;\n', '        name = "Paralism-EPARA";  \n', '        symbol = "EPARA";\n', '        _supplyCap = 21000*10000*(10**9);\n', '        totalLocked = 0;\n', '\n', '        balanceOf[msg.sender] = _supplyCap;         //210M\n', '    }\n', '\n', '    /// @notice Return total available liquidity of token\n', '    /// @return total available liquidity of token\n', '    function totalSupply() public view returns (uint256){\n', '        return _supplyCap - totalLocked;\n', '    }\n', '    \n', '    /// @notice transfer tokens with a timer lock to an address, the timer lock would lock up the transfered funds from being spend for given days\n', '    /// @dev this increase totalLocked and reduce the totalSupply\n', '    /// @param _to the receiver address of token\n', '    /// @param _value the amount of token\n', '    /// @param _initLockdays the how long time in days the funds would be locked up, only can be set at when timer lock initializes\n', '    /// @return success true if transaction accomplished\n', '    function transferWithLockInit(address _to, uint256 _value, uint256 _initLockdays) public returns (bool success) {\n', '        require (address(0) != _to,"transfer to address 0");\n', '        require (false == isMutltiSignHoldBalance(msg.sender), "multisign balance hold");\n', '        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),"insufficient balance or locked");\n', '\n', '        if (0 < theLockValue(_to)) {\n', '            require (msg.sender == lock[_to].sender,"others lock detected") ;\n', '            require (_initLockdays == 0,"Lock detected, init fail") ;\n', '        }\n', '\n', '        if (0 == theLockValue(_to)) {\n', '            lock[_to].lockTime = (block.timestamp.safeAdd(_initLockdays * 1 days)).toUint64();           //init expriation day.\n', '            lock[_to].sender= msg.sender;                                                   //init sender\n', '        }\n', '\n', '        lock[_to].lockValue = lock[_to].lockValue.safeAdd(_value);                          //add lock value\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);                      //subtract from the sender\n', '        balanceOf[_to] = balanceOf[_to].safeAdd(_value);                                    //add to the recipient\n', '        \n', '        if (true == lock[_to].allowLockTimeUpdate) \n', '            lock[_to].allowLockTimeUpdate = false;                                         //disable sender change lock time until owner allowed again\n', '        \n', '        emit TransferWithLock(msg.sender, _to, _value, lock[_to].lockTime , _initLockdays);\n', '\n', '        totalLocked = totalLocked.safeAdd(_value);    //increase totalLocked\n', '        return true;\n', '    }\n', '    \n', '    /// @notice transfer more tokens to an existed lock\n', '    /// @dev this increase totalLocked and reduce the totalSupply\n', '    /// @param _to the receiver address of token\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function transferMoreToLock(address _to, uint256 _value) public returns (bool success) {\n', '        if(0 == theLockValue(_to)) revert("NO lock detected");\n', '        return transferWithLockInit(_to,_value,0);\n', '    }\n', '\n', '    /// @notice get timer locked value in effective on owner address.\n', '    /// @dev contract inernal only,once timer expired, the value will update to 0.\n', '    /// @param _addr the address of lock funds owner\n', '    /// @return amount the effective value of timer lock \n', '    function theLockValue(address _addr) internal returns (uint256 amount){\n', '        if (lock[_addr].lockTime <= block.timestamp) {\n', '            totalLocked = totalLocked.safeSub(lock[_addr].lockValue);           //reduce totalLocked\n', '            lock[_addr].lockValue = 0;                      //reset expired value\n', '        }\n', '        return lock[_addr].lockValue;\n', '    }\n', '\n', '    /// @notice Query timer locked balance of funds on owner address\n', '    /// @param _addr the address of lock funds owner\n', '    /// @return amount the effective value of timer lock \n', '    function getLockValue(address _addr) public view returns (uint256 amount){\n', '        lock[_addr].lockTime > block.timestamp ? amount = lock[_addr].lockValue : amount = 0;\n', '    }\n', '\n', '    /// @notice get lock remaining time in seconds of funds on owner address\n', '    /// @param _addr the address of lock funds owner\n', '    /// @return sec the time in seconds of timer\n', '    function getLockRemainSeconds(address _addr) public view returns (uint256 sec){\n', '        lock[_addr].lockTime > block.timestamp ? sec = lock[_addr].lockTime - block.timestamp : sec = 0;\n', '    }\n', '\n', '    /// @notice the lock expiration could be modify by lock sender\n', '    /// @dev none.\n', '    /// @param _addr the address of lock funds owner\n', '    /// @param _days the how long time in days the funds would be locked up\n', '    /// @return success true if transaction accomplished\n', '    function updateLockTime(address _addr, uint256 _days)public returns (bool success) {\n', '        require(theLockValue(_addr) > 0,"NO lock detected");\n', '        require(msg.sender == lock[_addr].sender, "others lock detected");\n', '        require(true == lock[_addr].allowLockTimeUpdate,"allowUpdateLockTime is false");\n', '\n', '        lock[_addr].lockTime = (block.timestamp.safeAdd(_days * 1 days)).toUint64();\n', '        lock[_addr].allowLockTimeUpdate = false;\n', '        emit UpdateLockTime(msg.sender, _addr, _days);\n', '        return true;\n', '    }\n', '\n', '    /// @notice address Owner switch on to permit lock sender updating the lock expiration or switch off to prohibit the modification\n', '    /// @param _allow the permssion flag\n', '    /// @return success true if transaction accomplished\n', '    function allowUpdateLockTime(bool _allow) public returns (bool success){\n', '        lock[msg.sender].allowLockTimeUpdate = _allow;\n', '        emit AllowUpdateLock(msg.sender, _allow);\n', '        return true;\n', '    }\n', '\n', '    /// @notice address owner return given amount of locked tokens to the lock sender when the lock in effective\n', '    /// @dev this would reduce totalLocked and increase totalSupply.\n', '    /// @param _value the amount return to the lock funds sender\n', '    /// @return success true if transaction accomplished\n', '    function returnLockedTokens(uint256 _value) public returns (bool success){\n', '        address _returnTo = lock[msg.sender].sender;\n', '        address _returnFrom = msg.sender;\n', '\n', '        uint256 lockValue = theLockValue(_returnFrom);\n', '        require(0 < lockValue, "NO lock detected");\n', '        require(_value <= lockValue,"insufficient lock value");\n', '        require(balanceOf[_returnFrom] >= _value,"insufficient balance");\n', '\n', '        balanceOf[_returnFrom] = balanceOf[_returnFrom].safeSub(_value);\n', '        balanceOf[_returnTo] = balanceOf[_returnTo].safeAdd(_value);\n', '\n', '        lock[_returnFrom].lockValue = lock[_returnFrom].lockValue.safeSub(_value);   //reduce locked amount\n', '\n', '        emit ReturnLockedTokens(_returnFrom, _returnTo, _value);\n', '\n', '        totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\n', '        return true;\n', '    }\n', '\n', '    /// @notice send lock request to an address, the lock would take effective once the adderss owner accept the request\n', '    /// @dev this would have not impact to totalLocked and totalSupply.\n', '    /// @param _to the address of funds owner\n', '    /// @param _value the amount of token requet to locked\n', '    /// @param _initLockdays the how long time in days the funds would be locked up\n', '    /// @return success true if transaction accomplished\n', '    function askToLock(address _to, uint256 _value, uint256 _initLockdays) public returns(bool success) {\n', '        require(balanceOf[_to] >= theLockValue(_to).safeAdd(_value), "insufficient balance to lock");\n', '        if (0 < theLockValue(_to)) {\n', '            require (msg.sender == lock[_to].sender,"others lock detected") ;\n', '            require (_initLockdays == 0,"lock time exist") ;\n', '        }\n', '        lock[_to].askToLock = _value;\n', '        lock[_to].initAskTime = (block.timestamp + _initLockdays * 1 days).toUint64();\n', '        lock[_to].sender = msg.sender;\n', '        \n', '        emit RequestToLock(msg.sender, _to, _value, _initLockdays);\n', '        return true;\n', '    }\n', '\n', '    /// @notice accept a lock request by address owner, the lock take effective\n', '    /// @dev this would increase totalLocked and decrease totalSupply.\n', '    /// @param _sender the address of timer lock request sender\n', '    /// @param _value the amount return to the lock funds sender\n', '    /// @return success true if transaction accomplished\n', '    function acceptLockReq(address _sender, uint256 _value) public returns(bool success) {\n', '        require(lock[msg.sender].askToLock == _value,"value incorrect");\n', '        require(balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value), "insufficient balance or locked");//\n', '        require(_sender == lock[msg.sender].sender,"sender incorrect");\n', '\n', '        if(0 == theLockValue(msg.sender)) {\n', '            lock[msg.sender].lockTime = lock[msg.sender].initAskTime;\n', '        }\n', '        lock[msg.sender].lockValue = theLockValue(msg.sender).safeAdd(_value);\n', '        totalLocked = totalLocked.safeAdd(_value);    //increase totalLocked\n', '        \n', '        if (true ==lock[msg.sender].allowLockTimeUpdate) \n', '            lock[msg.sender].allowLockTimeUpdate = false;           //disable sender change lock timer until owner permits\n', '            \n', '        emit AcceptLock(msg.sender, _sender, _value, lock[msg.sender].lockTime);\n', '        resetLockReq();\n', '        return true;\n', '    }\n', '\n', '    /// @notice reset a lock request received\n', '    /// @dev this would have not impact to totalLocked and totalSupply.\n', '    /// @return success true if transaction accomplished\n', '    function resetLockReq() public returns(bool success) {\n', '        lock[msg.sender].askToLock = 0;\n', '        lock[msg.sender].initAskTime = 0;\n', '        return true;\n', '    }\n', '\n', '    /// @notice lock sender reduce given amount of locked funds\n', '    /// @dev this would reduce totalLocked and increase totalSupply.\n', '    /// @param _to the address of funds owner\n', '    /// @param _value the amount of locked token to be reudced\n', '    /// @return success true if transaction accomplished\n', '    function reduceLockValue(address _to, uint256 _value) public returns(bool success) {\n', '        require(_value <= theLockValue(_to), "insufficient lock balance");\n', '        require (msg.sender == lock[_to].sender,"others lock detected") ;\n', '\n', '        lock[_to].lockValue = lock[_to].lockValue.safeSub(_value);\n', '        totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\n', '        emit ReduceLockValue(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice create MultiSign Account on own address \n', '    /// @dev this function will clean previous MultiSign account if it is expired or not activated\n', '    /// @param _approvers the approver address list\n', '    /// @param _individualScores the array of vote weight of each approver\n', "    /// @param _initPassScore passing score of approver's vote\n", '    /// @param _backAccount the account to which MultiSignBalance will transfer when Multisign are cleared   \n', '    /// @param _initExpireDays the days from now on MultiSign account will expire \n', '    /// @return success true if transaction accomplished\n', '    function createMultiSign(address[] memory _approvers, \n', '                             uint[] memory _individualScores, \n', '                             uint _initPassScore, \n', '                             address _backAccount, \n', '                             uint _initExpireDays) \n', '                             public returns(bool) \n', '    {\n', '        require(_initPassScore > 0,"invalid pass score");\n', '        require(false == isMultiSignActivated(msg.sender), "multiSign existed");\n', '        require(_individualScores.length == _approvers.length,"arrays length mismatch");\n', '\n', '        if (0 < multiSign[address(this)].approvers.length) clearMultiSign(address(this));  //have multiSign not activated and not expired, clean\n', '        \n', '        for (uint i = 0; i < _approvers.length; i++) {\n', '            Approver memory a = Approver(_approvers[i],_individualScores[i].toUint64(),false);\n', '            multiSign[msg.sender].approvers.push(a);\n', '            emit MultiSignApprover(msg.sender, _approvers[i], _individualScores[i]);\n', '        }\n', '        multiSign[msg.sender].passScore = _initPassScore.toUint64();\n', '        multiSign[msg.sender].expiration = (block.timestamp+_initExpireDays*1 days).toUint64();\n', '        \n', '        if (address(0) != _backAccount){\n', '            multiSign[msg.sender].backAccount = _backAccount;\n', '        } else {\n', '            multiSign[msg.sender].backAccount = msg.sender;\n', '        }\n', '        \n', '        emit CreateMultiSign(msg.sender,_initPassScore,_backAccount, _initExpireDays);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice check if MultiSign Account activated or not \n', '    /// @dev this function will clean previous MultiSign account if it is expired\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return activated true if activated\n', '    function isMultiSignActivated(address _multisign) public returns (bool activated){\n', '        uint score;\n', '        uint length = multiSign[_multisign].approvers.length;\n', '        if (multiSign[_multisign].expiration < block.timestamp && multiSign[_multisign].expiration != 0) { // if expired clean \n', '            clearMultiSign(_multisign); \n', '        }\n', '        else{       //check if actived \n', '            for (uint i = 0; i < length; i++) {\n', '                if(true == multiSign[_multisign].approvers[i].activated){\n', '                    score += multiSign[_multisign].approvers[i].score;\n', '                    if (score >= multiSign[_multisign].passScore) return true;\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    /// @notice check if msg.sender is an approver of MultiSign account \n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return presence true if msg.sender is approver\n', '    function isApprover(address _multisign) public view returns (bool presence) {\n', '        uint length = multiSign[_multisign].approvers.length;\n', '        require(length > 0, "multiSign not found");\n', '        for (uint i = 0; i < length; i++) {\n', '            if (msg.sender == multiSign[_multisign].approvers[i].addr){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    /// @notice activate an approver of MultiSign Account \n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return activated true if approver activated\n', '    function activateApprover(address _multisign) public returns(bool activated) \n', '    {\n', '        require(isApprover(_multisign),"approver only");\n', '        uint length = multiSign[_multisign].approvers.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            if (msg.sender == multiSign[_multisign].approvers[i].addr){\n', '                if(false == multiSign[_multisign].approvers[i].activated){\n', '                    multiSign[_multisign].approvers[i].activated = true;\n', '                }\n', '                activated = true;\n', '            }\n', '        }\n', '        return activated;\n', '    }\n', '    \n', '    /// @notice vote to agree on freeze or unfreeze keeper address balance   \n', '    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _freeze true for freeze, false for unfreeze\n', '    /// @return success true if transaction accomplished\n', '    function freezeKeeper(address _multisign, bool _freeze) public returns(bool success) \n', '    {\n', '        require(activateApprover(_multisign));\n', '        vote[_multisign][msg.sender].holdBalance = _freeze;\n', '        emit FreezeKeeper(msg.sender, _multisign, _freeze);\n', '\n', '        uint length = multiSign[_multisign].approvers.length;\n', '        uint score = 0;\n', '        for (uint i = 0; i < length; i++) {                     //count score\n', '            if (_freeze == vote[_multisign][multiSign[_multisign].approvers[i].addr].holdBalance) \n', '                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\n', '        }\n', '        \n', '        if (true == isMultiSignActivated(_multisign)\n', '            && score >= multiSign[_multisign].passScore \n', '            && multiSign[_multisign].holdFlag != _freeze){           //check if reach passScore,and is necessary to update\n', '            multiSign[_multisign].holdFlag = _freeze;                //update holdFlag\n', '            emit HoldBalance(_multisign, _freeze);\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice check if MultiSign account set to freeze keeper address balance or not  \n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return flag the multiSign account holdFlag bool value\n', '    function isMutltiSignHoldBalance(address _multisign) public view returns(bool flag){\n', '        return multiSign[_multisign].holdFlag;\n', '    }\n', '    \n', '    /// @notice vote to agree on tranfer from MultiSignBalance to an receiver address   \n', '    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _to receiver address\n', '    /// @param _value value to transfer\n', '    /// @return success true if transaction accomplished\n', '    function approveTransferTo(address _multisign, address _to, uint _value) public returns(bool success) \n', '    {\n', '        require(address(0) != _to,"transfer to address 0");\n', '        require(activateApprover(_multisign));\n', '\n', '        vote[_multisign][msg.sender].approveTrans.to = _to;\n', '        vote[_multisign][msg.sender].approveTrans.value = _value;\n', '        emit ApproveTransferTo(msg.sender,_multisign, _to, _value);\n', '        \n', '        uint length = multiSign[_multisign].approvers.length;\n', '        uint score = 0;\n', '        for (uint i = 0; i < length; i++) {                                    //count score\n', '            if (_to == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to\n', '                && _value == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value) \n', '                score += multiSign[_multisign].approvers[i].score;             //count score by individual score weight\n', '        }\n', '        \n', '        if (true == isMultiSignActivated(_multisign)\n', '            && score >= multiSign[_multisign].passScore){//check if reach passScore, execute recall\n', '            require(_value <= multiSign[_multisign].multiSignBalance,"insufficent MultiSign balance");\n', '            //reset to prevent errorly repeat transfer trigger by more vote \n', '            for (uint i = 0; i < length; i++) {                                                                \n', '                if (_to == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to\n', '                    && _value == vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value) \n', '                {   \n', '                    vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.to = address(0);        //reset\n', '                    vote[_multisign][multiSign[_multisign].approvers[i].addr].approveTrans.value = 0;              //reset\n', '                }\n', '            }\n', '            \n', '            multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeSub(_value);     //reduce multiSignBalance\n', '            balanceOf[_to] = balanceOf[_to].safeAdd(_value);                   //increase receiver balance\n', '            emit MultiSignTransfer(_multisign, _to, _value);\n', '            totalLocked = totalLocked.safeSub(_value);  //reduce totalLocked\n', '            }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice vote to agree on tranfer from keeper address balance to MultiSignBalances   \n', '    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _value value to transfer\n', '    /// @return success true if transaction accomplished\n', '    function recallToMultiSign(address _multisign, uint _value) public returns(bool success) \n', '    {\n', '        require(activateApprover(_multisign));\n', '        require(0 <_value);\n', '        \n', '        vote[_multisign][msg.sender].recall = _value;         //vote recall\n', '        emit RecallToMultiSign(msg.sender, _multisign, _value);\n', '        \n', '        uint length = multiSign[_multisign].approvers.length;\n', '        uint score = 0;\n', '        for (uint i = 0; i < length; i++) {                     //count score\n', '            if (_value == vote[_multisign][multiSign[_multisign].approvers[i].addr].recall) \n', '                score += multiSign[_multisign].approvers[i].score;             //count score by individual score weight\n', '        }\n', '\n', '        if (true == isMultiSignActivated(_multisign)\n', '            && score >= multiSign[_multisign].passScore\n', '            && balanceOf[_multisign] >= theLockValue(_multisign).safeAdd(_value)){//check if reach passScore and have enough balance, execute recall\n', '            //reset to prevent errorly repeat transfer trigger by more vote\n', '            for (uint i = 0; i < length; i++) {                     \n', '                if (_value == vote[_multisign][multiSign[_multisign].approvers[i].addr].recall) \n', '                    vote[_multisign][multiSign[_multisign].approvers[i].addr].recall = 0;             //reset\n', '            }\n', "            balanceOf[_multisign] = balanceOf[_multisign].safeSub(_value);                                   //reduce keeper's balance\n", '            multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeAdd(_value); //increase multiSignBalance\n', '            emit MultiSignRecall(_multisign, _value);\n', '            totalLocked = totalLocked.safeAdd(_value);                                                     //increase totalLocked\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice vote to agree on update expiration time of MultiSign Account\n', '    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _expireDays new expiration dayss\n', '    /// @return success true if transaction accomplished\n', '    function updateExpiration(address _multisign, uint _expireDays) public returns(bool success) \n', '    {\n', '        require (activateApprover(_multisign));\n', '\n', '        _expireDays = _expireDays.safeAdd(1);     //add vote guard\n', '        \n', '        vote[_multisign][msg.sender].expireDays = _expireDays.toUint64();     //vote expireDays\n', '        emit UpdateExpiration(msg.sender, _multisign, _expireDays);\n', '        \n', '        uint length = multiSign[_multisign].approvers.length;\n', '        uint score = 0;\n', '        for (uint i = 0; i < length; i++) {                     //count score\n', '            if (_expireDays == vote[_multisign][multiSign[_multisign].approvers[i].addr].expireDays) \n', '                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\n', '        }\n', '        \n', '        if (true == isMultiSignActivated(_multisign)\n', '            && score >= multiSign[_multisign].passScore){                         //check if reach passScore,\n', '            for (uint i = 0; i < length; i++) {\n', '                vote[_multisign][multiSign[_multisign].approvers[i].addr].expireDays = 0;   //clear voted data\n', '            }  \n', '            _expireDays -= 1;   //clear vote guard\n', '            multiSign[_multisign].expiration = (block.timestamp + (_expireDays) * 1 days).toUint64();             //update multisign expire\n', '            emit MultiSignExpirationUpdated(_multisign, _expireDays);\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice vote to agree on update back account of MultiSign Account\n', '    /// @dev the vote history of the option to which have just been voted and take effective will be cleaned after execution\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _newBackAccount new back account\n', '    /// @return success true if transaction accomplished\n', '    function updateBackAccount(address _multisign, address _newBackAccount) public returns(bool success)\n', '    {\n', '        require (address(0) != _newBackAccount,"invalid address");\n', '        require (activateApprover(_multisign));\n', '        vote[_multisign][msg.sender].backAccount = _newBackAccount;     //vote backAccount\n', '        emit UpdateBackAccount(msg.sender, _multisign, _newBackAccount);\n', '        \n', '        uint length = multiSign[_multisign].approvers.length;\n', '        uint score = 0;\n', '        for (uint i = 0; i < length; i++) {                     //count score\n', '            if (_newBackAccount == vote[_multisign][multiSign[_multisign].approvers[i].addr].backAccount) \n', '                score += multiSign[_multisign].approvers[i].score;            //count score by individual score weight\n', '        }\n', '        \n', '        if (true == isMultiSignActivated(_multisign)\n', '            && score >= multiSign[_multisign].passScore\n', '            && multiSign[_multisign].backAccount != _newBackAccount){     //check if reach passScore,\n', '            multiSign[_multisign].backAccount = _newBackAccount;             //update multisign backAccount\n', '            emit MultiSignBackAccountUpdated(_multisign, _newBackAccount);\n', '        }\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /// @notice clean all vote by msg.sender who is an approver of MultiSign Account\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return success true if transaction accomplished\n', '    function cancelVote(address _multisign) public returns(bool success) \n', '    {\n', '        require (activateApprover(_multisign));\n', '        delete vote[_multisign][msg.sender];\n', '        emit CancelVote(msg.sender,_multisign);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice transfer tokens to MultiSign Account Balance if it is activated\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @param _value token value to transfer\n', '    /// @return success true if transaction accomplished\n', '    function transferToMultiSign(address _multisign, uint _value) public returns(bool success) \n', '    {\n', '        require (address(0) != _multisign,"transfer to address 0");\n', '        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),"insufficient balance or locked");\n', '        require (isMultiSignActivated(_multisign),"multisign not activated");\n', '        require (false == isMutltiSignHoldBalance(msg.sender), "multisign balance hold");\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);                                    //subtract from the sender\n', '        multiSign[_multisign].multiSignBalance = multiSign[_multisign].multiSignBalance.safeAdd(_value);    //add to the multisignbalance\n', '        emit TransferToMultiSign(msg.sender, _multisign, _value);\n', '        totalLocked = totalLocked.safeAdd(_value);                                                     //increase totalLocked\n', '        return true;\n', '    }\n', '    \n', '    /// @notice get MultiSign account balance\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return balanceOfMultiSign value of balance\n', '    function getBalanceOfMultiSign(address _multisign) public view returns(uint balanceOfMultiSign) \n', '    {\n', '        return multiSign[_multisign].multiSignBalance;\n', '    }\n', '    \n', '    /// @notice get MultiSign account approvers\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return approvers list\n', '    function getApproversOfMultiSign(address _multisign) public view returns(Approver[] memory approvers) \n', '    {\n', '        return multiSign[_multisign].approvers;\n', '    }\n', '    \n', '    /// @notice clear MultiSign Account if it is not activated or expired\n', '    /// @param _multisign the keeper address of MultiSign Account\n', '    /// @return success true if transaction accomplished\n', '    function clearMultiSign(address _multisign) public returns (bool success) {\n', '        require(isApprover(_multisign) || msg.sender == _multisign);\n', '        \n', '        uint score;\n', '        uint length = multiSign[_multisign].approvers.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            if(true == multiSign[_multisign].approvers[i].activated){\n', '                score += multiSign[_multisign].approvers[i].score;\n', '            }\n', '        }\n', '        \n', '        require(score < multiSign[_multisign].passScore || multiSign[_multisign].expiration < block.timestamp);\n', '            \n', '        for (uint i = 0; i < length; i++) {\n', '            delete vote[_multisign][multiSign[_multisign].approvers[i].addr];   //clear votes\n', '        }\n', '           \n', '        address bAccount = multiSign[_multisign].backAccount;\n', '        uint value = multiSign[_multisign].multiSignBalance;\n', '        if (address(0) != bAccount && 0 < value){                                 //transfer balance to backAccount\n', '            balanceOf[bAccount] = balanceOf[bAccount].safeAdd(value); \n', '            totalLocked = totalLocked.safeSub(value);   //reduce totalLocked\n', '        }\n', '\n', '        delete multiSign[_multisign];                                           //remove multiSign\n', '        emit ClearMutiSign(msg.sender,_multisign,bAccount,value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice Transfer tokens to multiple addresses\n', '    /// @param _addresses the address list of token receivers\n', '    /// @param _amounts the amount list one to one correspondence to the address list\n', '    /// @return success true if transaction accomplished\n', '    function transferForMultiAddresses(address[] memory _addresses, uint256[] memory _amounts) public returns (bool) {\n', '        require(_addresses.length == _amounts.length,"arrays length mismatch");\n', '        require (false == isMutltiSignHoldBalance(msg.sender), "multisign balance hold");\n', '\n', '        for (uint i = 0; i < _addresses.length; i++) {\n', '            require(_addresses[i] != address(0),"transfer to address 0");\n', '            if (balanceOf[msg.sender] < theLockValue(msg.sender).safeAdd(_amounts[i])) revert("insufficient balance or locked");\n', '\n', '            balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_amounts[i]);\n', '            balanceOf[_addresses[i]] = balanceOf[_addresses[i]].safeAdd(_amounts[i]);\n', '            emit Transfer(msg.sender, _addresses[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    /// @notice token plain transfer to given address\n', '    /// @param _to the receiver address of token\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function transfer(address _to, uint256 _value) public returns (bool success){\n', '        if (_to == address(0)) revert("transfert to address 0");\n', '        require (false == isMutltiSignHoldBalance(msg.sender), "multisign balance hold");\n', '        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value),"insufficient balance or locked");\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\n', '        balanceOf[_to] = balanceOf[_to].safeAdd(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice approve another address to spend giben tokens on your behalf\n', '    /// @param _spender the address would be given permission\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice the permitted address spend the approved amount of tokens\n', '    /// @param _from the address approved the spend\n', '    /// @param _to the receiver address of token \n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require (_to != address(0), "transfert to address 0");\n', '        require (_value <= allowance[_from][msg.sender],"transfer more than allowance");\n', '        require (false == isMutltiSignHoldBalance(_from), "multisign balance hold");\n', '        require (balanceOf[_from] >= theLockValue(_from).safeAdd(_value),"insufficient balance or locked");\n', '\n', '        allowance[_from][msg.sender] = allowance[_from][msg.sender].safeSub(_value);\n', '        balanceOf[_from] = balanceOf[_from].safeSub(_value);\n', '        balanceOf[_to] = balanceOf[_to].safeAdd(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice burn a given amount of token, unrecoverable\n', '    /// @dev this would reduce _supplyCap\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require (balanceOf[msg.sender] >= theLockValue(msg.sender).safeAdd(_value), "insufficient balance or locked");\n', '        require (false == isMutltiSignHoldBalance(msg.sender), "multisign balance hold");\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\n', '        _supplyCap = _supplyCap.safeSub(_value);\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /// @notice move given amount of token from balanceOf into freezeOf \n', '    /// @dev no size impact to _supplyCap\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function freeze(uint256 _value) public returns (bool success) {\n', '        if (balanceOf[msg.sender] < _value) revert("insufficient balance");\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeSub(_value);\n', '        freezeOf[msg.sender] = freezeOf[msg.sender].safeAdd(_value);\n', '        emit Freeze(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    /// @notice move given amount of token from freezeOf into balanceOf\n', '    /// @dev no size impact to _supplyCap\n', '    /// @param _value the amount of token\n', '    /// @return success true if transaction accomplished\n', '    function unfreeze(uint256 _value) public returns (bool success) {\n', '        if (freezeOf[msg.sender] < _value) revert("insufficient balance.");\n', '\n', '        freezeOf[msg.sender] = freezeOf[msg.sender].safeSub(_value);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].safeAdd(_value);\n', '        emit Unfreeze(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', ' }']