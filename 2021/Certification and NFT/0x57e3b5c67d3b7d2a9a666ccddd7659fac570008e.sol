['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.7.4;\n', '\n', 'interface IOwnable {\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function renounceOwnership() external;\n', '  \n', '    function transferOwnership( address newOwner_ ) external;\n', '}\n', '\n', 'contract Ownable is IOwnable {\n', '    \n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred( address(0), _owner );\n', '    }\n', '\n', '    function owner() public view override returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require( _owner == msg.sender, "Ownable: caller is not the owner" );\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual override onlyOwner() {\n', '        emit OwnershipTransferred( _owner, address(0) );\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n', '        require( newOwner_ != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred( _owner, newOwner_ );\n', '        _owner = newOwner_;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function sqrrt(uint256 a) internal pure returns (uint c) {\n', '        if (a > 3) {\n', '            c = a;\n', '            uint b = add( div( a, 2), 1 );\n', '            while (b < c) {\n', '                c = b;\n', '                b = div( add( div( a, b ), b), 2 );\n', '            }\n', '        } else if (a != 0) {\n', '            c = 1;\n', '        }\n', '    }\n', '\n', '    function percentageAmount( uint256 total_, uint8 percentage_ ) internal pure returns ( uint256 percentAmount_ ) {\n', '        return div( mul( total_, percentage_ ), 1000 );\n', '    }\n', '\n', '    function substractPercentage( uint256 total_, uint8 percentageToSub_ ) internal pure returns ( uint256 result_ ) {\n', '        return sub( total_, div( mul( total_, percentageToSub_ ), 1000 ) );\n', '    }\n', '\n', '    function percentageOfTotal( uint256 part_, uint256 total_ ) internal pure returns ( uint256 percent_ ) {\n', '        return div( mul(part_, 100) , total_ );\n', '    }\n', '\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    function quadraticPricing( uint256 payment_, uint256 multiplier_ ) internal pure returns (uint256) {\n', '        return sqrrt( mul( multiplier_, payment_ ) );\n', '    }\n', '\n', '  function bondingCurve( uint256 supply_, uint256 multiplier_ ) internal pure returns (uint256) {\n', '      return mul( multiplier_, supply_ );\n', '  }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addressToString(address _address) internal pure returns(string memory) {\n', '        bytes32 _bytes = bytes32(uint256(_address));\n', '        bytes memory HEX = "0123456789abcdef";\n', '        bytes memory _addr = new bytes(42);\n', '\n', "        _addr[0] = '0';\n", "        _addr[1] = 'x';\n", '\n', '        for(uint256 i = 0; i < 20; i++) {\n', '            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n', '            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n', '        }\n', '\n', '        return string(_addr);\n', '\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // TODO comment actual hash value.\n', '    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( "ERC20Token" );\n', '    \n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string internal _name;\n', '    \n', '    string internal _symbol;\n', '    \n', '    uint8 internal _decimals;\n', '\n', '    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '    require(sender != address(0), "ERC20: transfer from the zero address");\n', '    require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '    _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '    _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '    _balances[recipient] = _balances[recipient].add(amount);\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '    function _mint(address account_, uint256 ammount_) internal virtual {\n', '        require(account_ != address(0), "ERC20: mint to the zero address");\n', '        _beforeTokenTransfer(address( this ), account_, ammount_);\n', '        _totalSupply = _totalSupply.add(ammount_);\n', '        _balances[account_] = _balances[account_].add(ammount_);\n', '        emit Transfer(address( this ), account_, ammount_);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n', '}\n', '\n', 'interface IERC2612Permit {\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '}\n', '\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Permit is ERC20, IERC2612Permit {\n', '    using Counters for Counters.Counter;\n', '\n', '    mapping(address => Counters.Counter) private _nonces;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    constructor() {\n', '        uint256 chainID;\n', '        assembly {\n', '            chainID := chainid()\n', '        }\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes("1")), // Version\n', '                chainID,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public virtual override {\n', '        require(block.timestamp <= deadline, "Permit: expired deadline");\n', '\n', '        bytes32 hashStruct =\n', '            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\n', '\n', '        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n', '\n', '        address signer = ecrecover(_hash, v, r, s);\n', '        require(signer != address(0) && signer == owner, "ZeroSwapPermit: Invalid signature");\n', '\n', '        _nonces[owner].increment();\n', '        _approve(owner, spender, amount);\n', '    }\n', '\n', '    function nonces(address owner) public view override returns (uint256) {\n', '        return _nonces[owner].current();\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2ERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'library Babylonian {\n', '    // credit for this implementation goes to\n', '    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n', '    function sqrt(uint256 x) internal pure returns (uint256) {\n', '        if (x == 0) return 0;\n', '        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n', '        // however that code costs significantly more gas\n', '        uint256 xx = x;\n', '        uint256 r = 1;\n', '        if (xx >= 0x100000000000000000000000000000000) {\n', '            xx >>= 128;\n', '            r <<= 64;\n', '        }\n', '        if (xx >= 0x10000000000000000) {\n', '            xx >>= 64;\n', '            r <<= 32;\n', '        }\n', '        if (xx >= 0x100000000) {\n', '            xx >>= 32;\n', '            r <<= 16;\n', '        }\n', '        if (xx >= 0x10000) {\n', '            xx >>= 16;\n', '            r <<= 8;\n', '        }\n', '        if (xx >= 0x100) {\n', '            xx >>= 8;\n', '            r <<= 4;\n', '        }\n', '        if (xx >= 0x10) {\n', '            xx >>= 4;\n', '            r <<= 2;\n', '        }\n', '        if (xx >= 0x8) {\n', '            r <<= 1;\n', '        }\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1; // Seven iterations should be enough\n', '        uint256 r1 = x / r;\n', '        return (r < r1 ? r : r1);\n', '    }\n', '}\n', '\n', 'library BitMath {\n', '    // returns the 0 indexed position of the most significant bit of the input x\n', '    // s.t. x >= 2**msb and x < 2**(msb+1)\n', '    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n', "        require(x > 0, 'BitMath::mostSignificantBit: zero');\n", '\n', '        if (x >= 0x100000000000000000000000000000000) {\n', '            x >>= 128;\n', '            r += 128;\n', '        }\n', '        if (x >= 0x10000000000000000) {\n', '            x >>= 64;\n', '            r += 64;\n', '        }\n', '        if (x >= 0x100000000) {\n', '            x >>= 32;\n', '            r += 32;\n', '        }\n', '        if (x >= 0x10000) {\n', '            x >>= 16;\n', '            r += 16;\n', '        }\n', '        if (x >= 0x100) {\n', '            x >>= 8;\n', '            r += 8;\n', '        }\n', '        if (x >= 0x10) {\n', '            x >>= 4;\n', '            r += 4;\n', '        }\n', '        if (x >= 0x4) {\n', '            x >>= 2;\n', '            r += 2;\n', '        }\n', '        if (x >= 0x2) r += 1;\n', '    }\n', '\n', '    // returns the 0 indexed position of the least significant bit of the input x\n', '    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n', '    // i.e. the bit at the index is set and the mask of all lower bits is 0\n', '    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n', "        require(x > 0, 'BitMath::leastSignificantBit: zero');\n", '\n', '        r = 255;\n', '        if (x & uint128(-1) > 0) {\n', '            r -= 128;\n', '        } else {\n', '            x >>= 128;\n', '        }\n', '        if (x & uint64(-1) > 0) {\n', '            r -= 64;\n', '        } else {\n', '            x >>= 64;\n', '        }\n', '        if (x & uint32(-1) > 0) {\n', '            r -= 32;\n', '        } else {\n', '            x >>= 32;\n', '        }\n', '        if (x & uint16(-1) > 0) {\n', '            r -= 16;\n', '        } else {\n', '            x >>= 16;\n', '        }\n', '        if (x & uint8(-1) > 0) {\n', '            r -= 8;\n', '        } else {\n', '            x >>= 8;\n', '        }\n', '        if (x & 0xf > 0) {\n', '            r -= 4;\n', '        } else {\n', '            x >>= 4;\n', '        }\n', '        if (x & 0x3 > 0) {\n', '            r -= 2;\n', '        } else {\n', '            x >>= 2;\n', '        }\n', '        if (x & 0x1 > 0) r -= 1;\n', '    }\n', '}\n', '\n', 'library FullMath {\n', '    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n', '        uint256 mm = mulmod(x, y, uint256(-1));\n', '        l = x * y;\n', '        h = mm - l;\n', '        if (mm < l) h -= 1;\n', '    }\n', '\n', '    function fullDiv(\n', '        uint256 l,\n', '        uint256 h,\n', '        uint256 d\n', '    ) private pure returns (uint256) {\n', '        uint256 pow2 = d & -d;\n', '        d /= pow2;\n', '        l /= pow2;\n', '        l += h * ((-pow2) / pow2 + 1);\n', '        uint256 r = 1;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        return l * r;\n', '    }\n', '\n', '    function mulDiv(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 d\n', '    ) internal pure returns (uint256) {\n', '        (uint256 l, uint256 h) = fullMul(x, y);\n', '        uint256 mm = mulmod(x, y, d);\n', '        if (mm > l) h -= 1;\n', '        l -= mm;\n', "        require(h < d, 'FullMath::mulDiv: overflow');\n", '        return fullDiv(l, h, d);\n', '    }\n', '}\n', '\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // range: [0, 2**144 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq144x112 {\n', '        uint256 _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint256 private constant Q112 = 0x10000000000000000000000000000;\n', '    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(x) << RESOLUTION);\n', '    }\n', '\n', '    // encodes a uint144 as a UQ144x112\n', '    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n', '        return uq144x112(uint256(x) << RESOLUTION);\n', '    }\n', '\n', '    // decode a UQ112x112 into a uint112 by truncating after the radix point\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // decode a UQ144x112 into a uint144 by truncating after the radix point\n', '    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n', '        return uint144(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // decode a uq112x112 into a uint with 18 decimals of precision\n', '  function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '    // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n', '    // instead, get close to:\n', '    //  (x * 1e18) >> 112\n', '    // without risk of overflowing, e.g.:\n', '    //  (x) / 2 ** (112 - lg(1e18))\n', '    return uint(self._x) / 5192296858534827;\n', '  }\n', '\n', '    // multiply a UQ112x112 by a uint, returning a UQ144x112\n', '    // reverts on overflow\n', '    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n', '        uint256 z = 0;\n', "        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n", '        return uq144x112(z);\n', '    }\n', '\n', '    // multiply a UQ112x112 by an int and decode, returning an int\n', '    // reverts on overflow\n', '    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n', '        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n', "        require(z < 2**255, 'FixedPoint::muli: overflow');\n", '        return y < 0 ? -int256(z) : int256(z);\n', '    }\n', '\n', '    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n', '    // lossy\n', '    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n', '        if (self._x == 0 || other._x == 0) {\n', '            return uq112x112(0);\n', '        }\n', '        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n', '        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n', '        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n', '        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n', '\n', '        // partial products\n', '        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n', '        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n', '        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n', '        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n', '\n', '        // so the bit shift does not overflow\n', "        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\n", '\n', '        // this cannot exceed 256 bits, all values are 224 bits\n', '        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n', '\n', '        // so the cast does not overflow\n', "        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\n", '\n', '        return uq112x112(uint224(sum));\n', '    }\n', '\n', '    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n', '    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n', "        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n", '        if (self._x == other._x) {\n', '            return uq112x112(uint224(Q112));\n', '        }\n', '        if (self._x <= uint144(-1)) {\n', '            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n', "            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\n", '            return uq112x112(uint224(value));\n', '        }\n', '\n', '        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n', "        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\n", '        return uq112x112(uint224(result));\n', '    }\n', '\n', '  // returns a uq112x112 which represents the ratio of the numerator to the denominator\n', '  // equivalent to encode(numerator).div(denominator)\n', '  // function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '  //   require(denominator > 0, "DIV_BY_ZERO");\n', '  //   return uq112x112((uint224(numerator) << 112) / denominator);\n', '  // }\n', '\n', '    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n', '    // lossy if either numerator or denominator is greater than 112 bits\n', '    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n', "        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n", '        if (numerator == 0) return FixedPoint.uq112x112(0);\n', '\n', '        if (numerator <= uint144(-1)) {\n', '            uint256 result = (numerator << RESOLUTION) / denominator;\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        } else {\n', '            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        }\n', '    }\n', '\n', '    // take the reciprocal of a UQ112x112\n', '    // reverts on overflow\n', '    // lossy\n', '    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', "        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n", "        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n", '        return uq112x112(uint224(Q224 / self._x));\n', '    }\n', '\n', '    // square root of a UQ112x112\n', '    // lossy between 0/1 and 40 bits\n', '    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', '        if (self._x <= uint144(-1)) {\n', '            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n', '        }\n', '\n', '        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n', '        safeShiftBits -= safeShiftBits % 2;\n', '        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n', '    }\n', '}\n', '\n', '\n', 'interface IPrincipleDepository {\n', '\n', '    function getDepositorInfo( address _depositorAddress_ ) external view returns \n', '        ( uint principleValue_, uint paidOut_, uint maxPayout, uint vestingPeriod_ );\n', '    \n', '    function depositBondPrinciple( uint256 amountToDeposit_ ) external returns ( bool );\n', '\n', '    function depositBondPrincipleWithPermit( uint256 amountToDeposit_, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external returns ( bool );\n', '\n', '    function redeemBond() external returns ( bool );\n', '\n', '    function calculatePercentVested( address depositor_ ) external view returns ( uint _percentVested );\n', '    \n', '    function calculatePendingPayout( address depositor_ ) external view returns ( uint _pendingPayout );\n', '      \n', '    function calculateBondInterest( uint principleValue_ ) external view returns ( uint maxPayout );\n', '        \n', '    function calculatePremium() external view returns ( uint _premium );\n', '}\n', '\n', 'interface IBondingCalculator {\n', '    function principleValuation( address principleTokenAddress_, uint amountDeposited_ ) external view returns ( uint principleValuation_ );\n', '}\n', '\n', 'interface ITreasury {\n', '    function depositPrinciple( uint depositAmount_, address principleToken_ ) external returns ( bool );\n', '}\n', '\n', 'contract OHMPrincipleDepository is IPrincipleDepository, Ownable {\n', '\n', '    using FixedPoint for *;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    struct DepositInfo {\n', '        uint principleValue; // Risk-Free Value of LP\n', '        uint payoutRemaining; // OHM remaining to be paid\n', '        uint lastBlock; // Last interaction\n', '        uint vestingPeriod; // Blocks left to vest\n', '    }\n', '\n', '    mapping( address => DepositInfo ) public depositorInfo; \n', '\n', '    uint public bondControlVariable; // Premium scaling variable\n', '    uint public vestingPeriodInBlocks; \n', '    uint public minPremium; // Floor for the premium\n', '\n', '    address public treasury;\n', '    address public bondCalculator;\n', '    address public principleToken; // OHM-DAI LP\n', '    address public OHM;\n', '\n', '    uint256 public totalDebt; // Total principle value of outstanding bonds\n', '\n', '    address public stakingContract;\n', '    address public DAOWallet;\n', '    uint public DAOShare; // % = 1 / DAOShare\n', '\n', '    bool public isInitialized;\n', '\n', '    function initialize ( address principleToken_, address OHM_ ) external onlyOwner() returns ( bool ) {\n', '        require( isInitialized == false );\n', '        principleToken = principleToken_;\n', '        OHM = OHM_;\n', '\n', '        isInitialized = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function setAddresses( address bondCalculator_, address treasury_, address stakingContract_, \n', '    address DAOWallet_, uint DAOShare_ ) external onlyOwner() returns ( bool ) {\n', '        bondCalculator = bondCalculator_;\n', '        treasury = treasury_;\n', '        stakingContract = stakingContract_;\n', '        DAOWallet = DAOWallet_;\n', '        DAOShare = DAOShare_;\n', '        return true;\n', '    }\n', '\n', '    function setBondTerms( uint bondControlVariable_, uint vestingPeriodInBlocks_, uint minPremium_ ) \n', '    external onlyOwner() returns ( bool ) {\n', '        bondControlVariable = bondControlVariable_;\n', '        vestingPeriodInBlocks = vestingPeriodInBlocks_;\n', '        minPremium = minPremium_;\n', '        return true;\n', '    }\n', '\n', '    function getDepositorInfo( address depositorAddress_ ) external view override returns \n', '    ( uint _principleValue, uint _payoutRemaining, uint _lastBlock, uint _vestingPeriod ) {\n', '        DepositInfo memory depositorInfo_ = depositorInfo[ depositorAddress_ ];\n', '        _principleValue = depositorInfo_.principleValue;\n', '        _payoutRemaining = depositorInfo_.payoutRemaining;\n', '        _lastBlock = depositorInfo_.lastBlock;\n', '        _vestingPeriod = depositorInfo_.vestingPeriod;\n', '    }\n', '\n', '    function depositBondPrinciple( uint amountToDeposit_ ) external override returns ( bool ) {\n', '        _depositBondPrinciple( amountToDeposit_ ) ;\n', '        return true;\n', '    }\n', '\n', '    function depositBondPrincipleWithPermit( uint amountToDeposit_, uint deadline, uint8 v, bytes32 r, bytes32 s ) \n', '    external override returns ( bool ) {\n', '        ERC20Permit( principleToken ).permit( msg.sender, address(this), amountToDeposit_, deadline, v, r, s );\n', '        _depositBondPrinciple( amountToDeposit_ ) ;\n', '        return true;\n', '    }\n', '\n', '    function _depositBondPrinciple( uint amountToDeposit_ ) internal returns ( bool ){\n', '        IERC20( principleToken ).safeTransferFrom( msg.sender, address(this), amountToDeposit_ );\n', '\n', '        uint principleValue_ = IBondingCalculator( bondCalculator )\n', '            .principleValuation( principleToken, amountToDeposit_ ).div( 1e9 );\n', '\n', '        uint payout_ = _calculateBondInterest( principleValue_ );\n', '\n', '        require( payout_ >= 10000000, "Bond too small" );\n', '\n', '        totalDebt = totalDebt.add( principleValue_ );\n', '\n', '        uint profit_ = principleValue_.sub( payout_ );\n', '        uint DAOProfit_ = FixedPoint.fraction( profit_, DAOShare ).decode();\n', '\n', '        IUniswapV2ERC20( principleToken ).approve( address( treasury ), amountToDeposit_ );\n', '\n', '        ITreasury( treasury ).depositPrinciple( amountToDeposit_, principleToken ); // Returns OHM\n', '\n', '        IERC20( OHM ).safeTransfer( stakingContract, profit_.sub( DAOProfit_ ) );\n', '        IERC20( OHM ).safeTransfer( DAOWallet, DAOProfit_ );\n', '\n', '        depositorInfo[msg.sender] = DepositInfo({\n', '            principleValue: depositorInfo[msg.sender].principleValue.add( principleValue_ ),\n', '            payoutRemaining: depositorInfo[msg.sender].payoutRemaining.add( payout_ ),\n', '            lastBlock: block.number,\n', '            vestingPeriod: vestingPeriodInBlocks\n', '        });\n', '        return true;\n', '    }\n', '\n', '    function redeemBond() external override returns ( bool ) {\n', '        uint payoutRemaining_ = depositorInfo[msg.sender].payoutRemaining;\n', '\n', '        require( payoutRemaining_ > 0, "Sender is not due any interest." );\n', '\n', '        uint principleValue_ = depositorInfo[msg.sender].principleValue;\n', '\n', '        uint blocksSinceLast_ = block.number.sub( depositorInfo[msg.sender].lastBlock );\n', '\n', '        uint vestingPeriod_ = depositorInfo[msg.sender].vestingPeriod;\n', '\n', '        uint percentVested_ = _calculatePercentVested( msg.sender );\n', '\n', '        if ( percentVested_ >= 10000 ) {\n', '            delete depositorInfo[msg.sender];\n', '\n', '            IERC20( OHM ).safeTransfer( msg.sender, payoutRemaining_ );\n', '            totalDebt = totalDebt.sub( principleValue_ );\n', '\n', '            return true;\n', '        }\n', '\n', '        uint payout_ = payoutRemaining_.mul( percentVested_ ).div( 10000 );\n', '        IERC20( OHM ).safeTransfer( msg.sender, payout_ );\n', '\n', '        uint principleUsed_ = principleValue_.mul( percentVested_ ).div( 10000 );\n', '        totalDebt = totalDebt.sub( principleUsed_ );\n', '\n', '        depositorInfo[msg.sender] = DepositInfo({\n', '            principleValue: principleValue_.sub( principleUsed_ ),\n', '            payoutRemaining: payoutRemaining_.sub( payout_ ),\n', '            lastBlock: block.number,\n', '            vestingPeriod: vestingPeriod_.sub( blocksSinceLast_ )\n', '        });\n', '        return true;\n', '    }\n', '\n', '    function calculatePercentVested( address depositor_ ) external view override returns ( uint _percentVested ) {\n', '        _percentVested = _calculatePercentVested( depositor_ );\n', '    }\n', '\n', '    // In thousandths ( 1 = 0.01% )\n', '    function _calculatePercentVested( address depositor_ ) internal view returns ( uint _percentVested ) {\n', '        uint blocksSinceLast_ = block.number.sub( depositorInfo[ depositor_ ].lastBlock );\n', '\n', '        uint vestingPeriod_ = depositorInfo[ depositor_ ].vestingPeriod;\n', '\n', '        if ( vestingPeriod_ > 0 ) {\n', '            _percentVested = blocksSinceLast_.mul( 10000 ).div( vestingPeriod_ );\n', '        } else {\n', '            _percentVested = 0;\n', '        }\n', '    }\n', '\n', '    function calculatePendingPayout( address depositor_ ) external view override returns ( uint _pendingPayout ) {\n', '        uint percentVested_ = _calculatePercentVested( depositor_ );\n', '        uint payoutRemaining_ = depositorInfo[ depositor_ ].payoutRemaining;\n', '        \n', '        _pendingPayout = payoutRemaining_.mul( percentVested_ ).div( 10000 );\n', '\n', '        if ( percentVested_ >= 10000 ) {\n', '            _pendingPayout = payoutRemaining_;\n', '        } \n', '    }\n', '\n', '    function calculateBondInterest( uint amountToDeposit_ ) external view override returns ( uint _interestDue ) {\n', '        uint principleValue_ = IBondingCalculator( bondCalculator ).principleValuation( principleToken, amountToDeposit_ ).div( 1e9 );\n', '        _interestDue = _calculateBondInterest( principleValue_ );\n', '    }\n', '\n', '    function _calculateBondInterest( uint principleValue_ ) internal view returns ( uint _interestDue ) {\n', '        _interestDue = FixedPoint.fraction( principleValue_, _calcPremium() ).decode112with18().div( 1e16 );\n', '    }\n', '\n', '    function calculatePremium() external view override returns ( uint _premium ) {\n', '        _premium = _calcPremium();\n', '    }\n', '\n', '    function _calcPremium() internal view returns ( uint _premium ) {\n', '        _premium = bondControlVariable.mul( _calcDebtRatio() ).add( uint(1000000000) ).div( 1e7 );\n', '        if ( _premium < minPremium ) {\n', '            _premium = minPremium;\n', '        }\n', '    }\n', '\n', '    function _calcDebtRatio() internal view returns ( uint _debtRatio ) {    \n', '        _debtRatio = FixedPoint.fraction( \n', '            // Must move the decimal to the right by 9 places to avoid math underflow error\n', '            totalDebt.mul( 1e9 ), \n', '            IERC20( OHM ).totalSupply()\n', '        ).decode112with18().div( 1e18 );\n', '        // Must move the decimal tot he left 18 places to account for the 9 places added above and the 19 signnificant digits added by FixedPoint.\n', '    }\n', '}']