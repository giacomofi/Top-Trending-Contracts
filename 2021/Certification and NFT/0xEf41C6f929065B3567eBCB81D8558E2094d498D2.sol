['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.6.0;\n', '\n', "import './SafeERC20.sol';\n", "import './CurveInterface.sol';\n", "import './UniswapInterface.sol';\n", '\n', 'contract CurveStrategy {\n', '\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    address public royaleAddress;\n', '    address public yieldDistributor;\n', '    IERC20 public poolToken;\n', '    IERC20[3] public tokens;  // DAI / USDC / USDT\n', '    CurvePool public pool;\n', '    PoolGauge public gauge;\n', '    Minter public minter;\n', '    VoteEscrow public voteEscrow;\n', '    FeeDistributor public feeDistributor;\n', '    UniswapI  public uniAddr;\n', '    IERC20 public crvAddr;\n', '    address public wethAddr;\n', '     \n', '    uint256 public constant DENOMINATOR = 10000;\n', '\n', '    uint256 public depositSlip = 100;\n', '\n', '    uint256 public withdrawSlip = 200;\n', '    \n', '    uint256 public uniswapSlippage=50;\n', '\n', '    address public wallet;\n', '    address public nominatedWallet;\n', '    \n', '   // uint256 public totalProfit;\n', '    \n', '    uint256 public crvBreak=10000;\n', '\n', '   // uint256 public virtualPrice;\n', ' \n', '    bool public TEST = false; // For testing uniswap , should be removed on deployment to the mainnet\n', '\n', '    modifier onlyAuthorized(){\n', '      require(wallet == msg.sender|| msg.sender==royaleAddress, "Not authorized");\n', '      _;\n', '    }\n', '\n', '    modifier onlyWallet(){\n', '        require((wallet==msg.sender),"Not Authorized");\n', '        _;\n', '    }\n', '\n', '    modifier onlyRoyaleLP() {\n', '        require(msg.sender == royaleAddress, "Not authorized");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '         address _wallet,\n', '         IERC20[3] memory _tokens, \n', '         address _royaleaddress,\n', '         address _yieldDistributor,\n', '         address _crvpool,\n', '         address _poolToken,\n', '         address _gauge,\n', '         address _minter,\n', '         address _uniAddress,\n', '         address _crvAddress,\n', '         address _wethAddress,\n', '         address _voteEscrow,\n', '         address _feeDistributor\n', '         ) public {\n', '\n', '        wallet=_wallet;\n', '        tokens = _tokens;\n', '        royaleAddress =_royaleaddress;\n', '        yieldDistributor=_yieldDistributor;\n', '        pool = CurvePool(_crvpool);\n', '        poolToken = IERC20(_poolToken);\n', '        gauge = PoolGauge(_gauge);\n', '        minter=Minter(_minter);\n', '        uniAddr=UniswapI(_uniAddress);\n', '        crvAddr=IERC20(_crvAddress);\n', '        wethAddr=_wethAddress;  \n', '        feeDistributor = FeeDistributor(_feeDistributor);\n', '        voteEscrow = VoteEscrow(_voteEscrow);\n', '    }\n', '\n', '    function setCRVBreak(uint256 _percentage)external onlyWallet(){\n', '        crvBreak=_percentage;\n', '    }\n', '\n', '    function nominateNewOwner(address _wallet) external onlyWallet {\n', '        nominatedWallet = _wallet;\n', '        emit walletNominated(_wallet);\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(msg.sender == nominatedWallet, "You must be nominated before you can accept ownership");\n', '        emit walletChanged(wallet, nominatedWallet);\n', '        wallet = nominatedWallet;\n', '        nominatedWallet = address(0);\n', '    }\n', '\n', '    function changeRoyaleLP(address _address)external onlyWallet(){\n', '        royaleAddress=_address;\n', '    }\n', '\n', '    function changeYieldDistributor(address _address)external onlyWallet(){\n', '        yieldDistributor=_address;\n', '    }\n', '    \n', '    function changeDepositSlip(uint _value)external onlyWallet(){\n', '        depositSlip=_value;\n', '    }\n', '    \n', '    function changeWithdrawSlip(uint _value)external onlyWallet(){\n', '        withdrawSlip=_value;\n', '    }\n', '    \n', '    function changeUniswapSlippage(uint _value) external onlyWallet(){\n', '        uniswapSlippage=_value;\n', '    }\n', '\n', '// deposits stable tokens into the 3pool and stake recived LPtoken(3CRV) in the curve 3pool gauge\n', '    function deposit(uint[3] memory amounts) external onlyRoyaleLP(){\n', '        uint currentTotal;\n', '        for(uint8 i=0; i<3; i++) {\n', '            if(amounts[i] > 0) {\n', '               uint decimal;\n', '               decimal=tokens[i].decimals();\n', '               tokens[i].safeApprove(address(pool),0);\n', '               tokens[i].safeApprove(address(pool), amounts[i]); \n', '               currentTotal =currentTotal.add(amounts[i].mul(1e18).div(10**decimal));\n', '            }\n', '        }\n', '        uint256 mintAmount = currentTotal.mul(1e18).div(pool.get_virtual_price());\n', '        pool.add_liquidity(amounts,  mintAmount.mul(DENOMINATOR.sub(depositSlip)).div(DENOMINATOR));\n', '        stakeLP();   \n', '    }\n', '\n', '    //withdraws stable tokens from the 3pool.Unstake required LPtokens and stake LP tokens if not used.\n', '    function withdraw(uint[3] memory amounts,uint[3] memory max_burn) external onlyRoyaleLP() {\n', '        //uint256 max_burn = pool.calc_token_amount(amounts,false);\n', '        uint burnAmount;\n', '        for(uint i=0;i<3;i++){\n', '             burnAmount = burnAmount.add(max_burn[i]);\n', '        }\n', '        burnAmount=burnAmount.mul(DENOMINATOR.add(withdrawSlip)).div(DENOMINATOR);\n', '        unstakeLP(burnAmount);\n', '        pool.remove_liquidity_imbalance(amounts, burnAmount);\n', '        for(uint8 i=0;i<3;i++){\n', '            if(amounts[i]!=0){\n', '               tokens[i].safeTransfer(royaleAddress, tokens[i].balanceOf(address(this)));\n', '            }\n', '        }\n', '        if(poolToken.balanceOf(address(this))>0){\n', '            stakeLP();\n', '        } \n', '    }\n', '\n', '   //unstake all the LPtokens and withdraw all the Stable tokens from 3pool \n', '    function withdrawAll() external onlyRoyaleLP() returns(uint256[3] memory){\n', '        unstakeLP(gauge.balanceOf(address(this)));\n', '        uint256[3] memory withdrawAmt;\n', '        pool.remove_liquidity(poolToken.balanceOf(address(this)),withdrawAmt);\n', '        for(uint8 i=0;i<3;i++){\n', '            if(tokens[i].balanceOf(address(this))!=0){\n', '                withdrawAmt[i]=tokens[i].balanceOf(address(this));\n', '                tokens[i].safeTransfer(royaleAddress,withdrawAmt[i]); \n', '            }\n', '        }\n', '        return withdrawAmt; \n', '    } \n', '    \n', '    // Functions to stake and unstake LPTokens(Ycrv) and claim CRV\n', '\n', '\n', '    //Stakes LP token(3CRV) into the curve 3pool gauage\n', '    function stakeLP() public onlyAuthorized() {\n', '        uint depositAmt = poolToken.balanceOf(address(this)) ;\n', '        poolToken.safeApprove(address(gauge),0);\n', '        poolToken.safeApprove(address(gauge), depositAmt);\n', '        gauge.deposit(depositAmt);  \n', '        emit staked(depositAmt);\n', '    }\n', '\n', '    //For unstaking LP tokens(3CRV)\n', '    function unstakeLP(uint _amount) public  onlyAuthorized(){\n', '        require(gauge.balanceOf(address(this)) >= _amount,"You have not staked that much amount");\n', '        gauge.withdraw(_amount);\n', '        emit unstaked(_amount);\n', '    }\n', '    \n', '    //Checking claimable CRV tokens.\n', '    function checkClaimableToken()public view  returns(uint256){\n', '        return gauge.claimable_tokens(address(this));\n', '    }\n', '\n', '    //for claiming CRV tokens which accumalates on staking 3CRV.\n', '    function claimCRV() public onlyAuthorized(){\n', '        minter.mint(address(gauge));\n', '        emit crvClaimed();\n', '    }\n', '\n', '    // Functions to lock and unlock CRV and recieve VeCRV\n', '\n', '\n', '   //For locking CRV tokens in the curve lock\n', '    function createLock(uint256 _value,uint256 _unlockTime) external onlyWallet(){\n', '        crvAddr.safeApprove(address(voteEscrow), 0);\n', '        crvAddr.safeApprove(address(voteEscrow), _value);\n', '        voteEscrow.create_lock(_value, _unlockTime);\n', '        emit locked(_value);\n', '    }\n', '\n', '\n', '    //Increasing lock CRV amount\n', '    function increaseLockAmount(uint256 _value) external onlyWallet(){\n', '        crvAddr.safeApprove(address(voteEscrow), 0);\n', '        crvAddr.safeApprove(address(voteEscrow), _value);\n', '        voteEscrow.increase_amount(_value);\n', '        emit locked(_value);\n', '    }\n', '\n', '    //For unlocking CRV tokens\n', '    function releaseLock() external onlyWallet(){\n', '        voteEscrow.withdraw(); \n', '        emit unlocked();\n', '    }\n', '\n', '//For claiming recieved 3CRV tokens which are given for locking CRV and\n', '   // withdrawing stable tokens from curve 3pool using those 3CRV and sending those stable tokens to an address\n', '    function claim3CRV()public onlyWallet(){\n', '        uint prevCoin=poolToken.balanceOf(address(this));\n', '        feeDistributor.claim();\n', '        uint postCoin=poolToken.balanceOf(address(this));\n', '        uint[3] memory minimum;\n', '        pool.remove_liquidity(postCoin-prevCoin,minimum);\n', '        for(uint i=0;i<3;i++){\n', '            emit yieldTransfered(i,tokens[i].balanceOf(address(this)));\n', '            tokens[i].safeTransfer(yieldDistributor,tokens[i].balanceOf(address(this)));\n', '        }\n', '    }\n', '    \n', '    // Function to sell CRV using uniswap to any stable token and send that token to an address\n', '    function sellCRV(uint8 _index,uint _amount) public onlyWallet() returns(uint256) {  //here index=0 means convert crv into DAI , index=1 means crv into USDC , index=2 means crv into USDT\n', '        uint256 crvAmt = IERC20(crvAddr).balanceOf(address(this));\n', '        uint256 prevCoin = tokens[_index].balanceOf(address(this));\n', '        require(crvAmt > 0, "insufficient CRV");\n', '        crvAmt=crvAmt.mul(crvBreak).div(DENOMINATOR);\n', '        crvAddr.safeApprove(address(uniAddr), 0);\n', '        crvAddr.safeApprove(address(uniAddr), crvAmt);\n', '        address[] memory path; \n', '        if(TEST) {\n', '            path = new address[](2);\n', '            path[0] = address(crvAddr);\n', '            path[1] = address(tokens[_index]);\n', '\n', '        } else {    \n', '            path = new address[](3);\n', '            path[0] = address(crvAddr);\n', '            path[1] = wethAddr;\n', '            path[2] = address(tokens[_index]);\n', '        }\n', '        uint minimumAmount=_amount.sub(_amount.mul(uniswapSlippage).div(DENOMINATOR));\n', '        UniswapI(uniAddr).swapExactTokensForTokens(\n', '            crvAmt, \n', '            minimumAmount, \n', '            path, \n', '            address(this), \n', '            now + 1800\n', '        );\n', '        uint256 postCoin=tokens[_index].balanceOf(address(this));\n', '        tokens[_index].safeTransfer(yieldDistributor,postCoin.sub(prevCoin));\n', '        emit yieldTransfered(_index,postCoin.sub(prevCoin));\n', '    }\n', '\n', '    //calulates how much VeCRV is needed to get 2.5X boost.\n', '    function gaugeVeCRVCalculator() public view returns(uint256){\n', '          uint minimumVeCRV ;\n', '          minimumVeCRV =(gauge.balanceOf(address(this)).mul(100)).sub((gauge.balanceOf(address(this)).mul(40))).mul(voteEscrow.totalSupply()).div(gauge.totalSupply().mul(60));\n', '          return minimumVeCRV;\n', '    }\n', '    \n', '    event yieldTransfered(uint index,uint coin);\n', '    event staked(uint amount);\n', '    event unstaked(uint amount);\n', '    event crvClaimed();\n', '    event locked(uint amount);\n', '    event unlocked();\n', '    event walletNominated(address newOwner);\n', '    event walletChanged(address oldOwner, address newOwner);\n', '\n', '}']