['# @version ^0.2.0\n', '\n', 'interface UniswapV2Pair:\n', '    def sync(): nonpayable\n', '\n', 'interface Stakable:\n', '    def deposit(_account: address, _amount: uint256) -> bool: nonpayable\n', '    def stake(_reward: uint256) -> bool: nonpayable\n', '    def withdraw(_account: address) -> bool: nonpayable\n', '\n', 'event CommitOwnership:\n', '    owner: address\n', '\n', 'event ApplyOwnership:\n', '    owner: address\n', '\n', '\n', 'TOKEN: constant(address) = 0x1cF4592ebfFd730c7dc92c1bdFFDfc3B9EfCf29a\n', 'MAX_PAIRS_LENGTH: constant(uint256) = 10 ** 3\n', '\n', '\n', 'uniswapPairs: public(address[MAX_PAIRS_LENGTH])\n', 'indexByPair: public(HashMap[address, uint256])\n', 'lastPairIndex: public(uint256)\n', '\n', 'author: public(address)\n', 'owner: public(address)\n', 'futureOwner: public(address)\n', '\n', '\n', '@external\n', 'def __init__():\n', '    self.author = msg.sender\n', '    self.owner = msg.sender\n', '\n', '\n', '@external\n', 'def deposit(_account: address, _amount: uint256) -> bool:\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    return Stakable(TOKEN).deposit(_account, _amount)\n', '\n', '\n', '@external\n', 'def stake(_reward: uint256) -> bool:\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    assert Stakable(TOKEN).stake(_reward)\n', '\n', '    _lastPairIndex: uint256 = self.lastPairIndex\n', '    for i in range(1, MAX_PAIRS_LENGTH):\n', '        if i > _lastPairIndex:\n', '            break\n', '\n', '        UniswapV2Pair(self.uniswapPairs[i]).sync()\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def withdraw(_account: address) -> bool:\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    return Stakable(TOKEN).withdraw(_account)\n', '\n', '\n', '@external\n', 'def addUniswapPair(_pair: address):\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    assert _pair != ZERO_ADDRESS\n', '    pairIndex: uint256 = self.indexByPair[_pair]\n', '    assert pairIndex == 0, "pair is exist"\n', '\n', '    pairIndex = self.lastPairIndex + 1\n', '    self.uniswapPairs[pairIndex] = _pair\n', '    self.indexByPair[_pair] = pairIndex\n', '    self.lastPairIndex = pairIndex\n', '\n', '\n', '@external\n', 'def removeUniswapPair(_pair: address):\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    pairIndex: uint256 = self.indexByPair[_pair]\n', '    assert pairIndex > 0, "pair is not exist"\n', '\n', '    recentPairIndex: uint256 = self.lastPairIndex\n', '    lastPair: address = self.uniswapPairs[recentPairIndex]\n', '\n', '    self.uniswapPairs[pairIndex] = lastPair\n', '    self.indexByPair[lastPair] = pairIndex\n', '    self.indexByPair[_pair] = 0\n', '    self.lastPairIndex = recentPairIndex - 1\n', '\n', '\n', '@external\n', 'def transferOwnership(_futureOwner: address):\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    self.futureOwner = _futureOwner\n', '    log CommitOwnership(_futureOwner)\n', '\n', '\n', '@external\n', 'def applyOwnership():\n', '    assert msg.sender == self.owner or msg.sender == self.author, "owner only"\n', '    _owner: address = self.futureOwner\n', '    assert _owner != ZERO_ADDRESS, "owner not set"\n', '    self.owner = _owner\n', '    log ApplyOwnership(_owner)']