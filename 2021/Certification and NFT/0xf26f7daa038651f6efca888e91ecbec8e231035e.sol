['//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.3;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./FlashbotsCheckAndSend.sol";\n', 'import "./IWETH.sol";\n', '\n', 'import "./Counters.sol";\n', 'import "./ECDSA.sol";\n', 'import "./EIP712.sol";\n', '\n', '/*\n', '  Copyright 2021 Kendrick Tan ([email\xa0protected]).\n', '\n', "  This contract is an extension of flashbot's FlashbotsCheckAndSend.sol\n", '  This contract takes in WETH instead of ETH so that transactions can be signed via a browser.\n', '  But needs to be approved beforehand.\n', '*/\n', '\n', 'contract MEVBriber is FlashbotsCheckAndSend, EIP712 {\n', '  using Counters for Counters.Counter;\n', '\n', '  constructor() EIP712("MEVBriber", "1") {}\n', '\n', '  IWETH public constant WETH =\n', '    IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '\n', '  event Bribed(address indexed briber, address indexed miner, uint256 amount);\n', '\n', '  bytes32 public constant PERMIT_TYPEHASH =\n', '    keccak256(\n', '      "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n', '    );\n', '\n', '  mapping(address => Counters.Counter) private _nonces;\n', '\n', '  receive() external payable {}\n', '\n', '  function check32BytesAndSendWETH(\n', '    address _owner,\n', '    address _spender,\n', '    uint256 _value,\n', '    uint256 _deadline,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address _target,\n', '    bytes memory _payload,\n', '    bytes32 _resultMatch\n', '  ) external {\n', '    briberPermitted(_owner, _spender, _value, _deadline, _v, _r, _s);\n', '    _check32Bytes(_target, _payload, _resultMatch);\n', '    WETH.transferFrom(_owner, address(this), _value);\n', '    WETH.withdraw(_value);\n', '    block.coinbase.transfer(_value);\n', '\n', '    emit Bribed(_owner, block.coinbase, _value);\n', '  }\n', '\n', '  function check32BytesAndSendMultiWETH(\n', '    address _owner,\n', '    address _spender,\n', '    uint256 _value,\n', '    uint256 _deadline,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address[] memory _targets,\n', '    bytes[] memory _payloads,\n', '    bytes32[] memory _resultMatches\n', '  ) external {\n', '    require(_targets.length == _payloads.length);\n', '    require(_targets.length == _resultMatches.length);\n', '    briberPermitted(_owner, _spender, _value, _deadline, _v, _r, _s);\n', '    for (uint256 i = 0; i < _targets.length; i++) {\n', '      _check32Bytes(_targets[i], _payloads[i], _resultMatches[i]);\n', '    }\n', '    WETH.transferFrom(_owner, address(this), _value);\n', '    WETH.withdraw(_value);\n', '    block.coinbase.transfer(_value);\n', '\n', '    emit Bribed(_owner, block.coinbase, _value);\n', '  }\n', '\n', '  function checkBytesAndSendWETH(\n', '    address _owner,\n', '    address _spender,\n', '    uint256 _value,\n', '    uint256 _deadline,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address _target,\n', '    bytes memory _payload,\n', '    bytes memory _resultMatch\n', '  ) external {\n', '    briberPermitted(_owner, _spender, _value, _deadline, _v, _r, _s);\n', '    _checkBytes(_target, _payload, _resultMatch);\n', '    WETH.transferFrom(_owner, address(this), _value);\n', '    WETH.withdraw(_value);\n', '    block.coinbase.transfer(_value);\n', '\n', '    emit Bribed(_owner, block.coinbase, _value);\n', '  }\n', '\n', '  function checkBytesAndSendMultiWETH(\n', '    address _owner,\n', '    address _spender,\n', '    uint256 _value,\n', '    uint256 _deadline,\n', '    uint8 _v,\n', '    bytes32 _r,\n', '    bytes32 _s,\n', '    address[] memory _targets,\n', '    bytes[] memory _payloads,\n', '    bytes[] memory _resultMatches\n', '  ) external {\n', '    require(_targets.length == _payloads.length);\n', '    require(_targets.length == _resultMatches.length);\n', '    briberPermitted(_owner, _spender, _value, _deadline, _v, _r, _s);\n', '    for (uint256 i = 0; i < _targets.length; i++) {\n', '      _checkBytes(_targets[i], _payloads[i], _resultMatches[i]);\n', '    }\n', '    WETH.transferFrom(_owner, address(this), _value);\n', '    WETH.withdraw(_value);\n', '    block.coinbase.transfer(_value);\n', '\n', '    emit Bribed(_owner, block.coinbase, _value);\n', '  }\n', '\n', '  // Briber permit functionality\n', '  function briberPermitted(\n', '    address owner,\n', '    address spender,\n', '    uint256 value,\n', '    uint256 deadline,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) public {\n', '    // solhint-disable-next-line not-rely-on-time\n', '    require(block.timestamp <= deadline, "ERC20Permit: expired deadline");\n', '\n', '    bytes32 structHash =\n', '      keccak256(\n', '        abi.encode(\n', '          PERMIT_TYPEHASH,\n', '          owner,\n', '          spender,\n', '          value,\n', '          _nonces[owner].current(),\n', '          deadline\n', '        )\n', '      );\n', '\n', '    bytes32 hash = _hashTypedDataV4(structHash);\n', '\n', '    address signer = ECDSA.recover(hash, v, r, s);\n', '    require(signer == owner, "ERC20Permit: invalid signature");\n', '    require(spender == address(this), "ERC20Permit: invalid signature");\n', '\n', '    _nonces[owner].increment();\n', '  }\n', '\n', '  // **** Helpers ****\n', '\n', '  function nonces(address owner) public view virtual returns (uint256) {\n', '    return _nonces[owner].current();\n', '  }\n', '}']