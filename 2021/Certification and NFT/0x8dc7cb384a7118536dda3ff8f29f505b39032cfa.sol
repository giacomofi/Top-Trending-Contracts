['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-16\n', '*/\n', '\n', '// contracts/multisender.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title EternalStorage\n', ' * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\n', ' */\n', 'contract EternalStorage {\n', '\n', '    mapping(bytes32 => uint256) internal uintStorage;\n', '    mapping(bytes32 => string) internal stringStorage;\n', '    mapping(bytes32 => address) internal addressStorage;\n', '    mapping(bytes32 => bytes) internal bytesStorage;\n', '    mapping(bytes32 => bool) internal boolStorage;\n', '    mapping(bytes32 => int256) internal intStorage;\n', '\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityStorage\n', ' * @dev This contract holds all the necessary state variables to support the upgrade functionality\n', ' */\n', 'contract UpgradeabilityStorage {\n', '    // Version name of the current implementation\n', '    string internal _version;\n', '\n', '    // Address of the current implementation\n', '    address internal _implementation;\n', '\n', '    /**\n', '    * @dev Tells the version name of the current implementation\n', '    * @return string representing the name of the current version\n', '    */\n', '    function version() public view returns (string memory) {\n', '        return _version;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the current implementation\n', '    * @return address of the current implementation\n', '    */\n', '    function implementation() public view returns (address) {\n', '        return _implementation;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityOwnerStorage\n', ' * @dev This contract keeps track of the upgradeability owner\n', ' */\n', 'contract UpgradeabilityOwnerStorage {\n', '    // Owner of the contract\n', '    address private _upgradeabilityOwner;\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function upgradeabilityOwner() public view returns (address) {\n', '        return _upgradeabilityOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Sets the address of the owner\n', '    */\n', '    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\n', '        _upgradeabilityOwner = newUpgradeabilityOwner;\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title OwnedUpgradeabilityStorage\n', ' * @dev This is the storage necessary to perform upgradeable contracts.\n', ' * This means, required state variables for upgradeability purpose and eternal storage per se.\n', ' */\n', 'contract OwnedUpgradeabilityStorage is UpgradeabilityOwnerStorage, UpgradeabilityStorage, EternalStorage {}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev This contract has an owner address providing basic authorization control\n', ' */\n', 'contract Ownable is EternalStorage {\n', '    /**\n', '    * @dev Event to show ownership has been transferred\n', '    * @param previousOwner representing the address of the previous owner\n', '    * @param newOwner representing the address of the new owner\n', '    */\n', '    event OwnershipTransferred(address previousOwner, address newOwner);\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner(), "not an owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Tells the address of the owner\n', '    * @return the address of the owner\n', '    */\n', '    function owner() public view returns (address) {\n', '        return addressStorage[keccak256("owner")];\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner the address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        setOwner(newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Sets a new owner address\n', '    */\n', '    function setOwner(address newOwner) internal {\n', '        emit OwnershipTransferred(owner(), newOwner);\n', '        addressStorage[keccak256("owner")] = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Claimable\n', ' * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n', ' * This allows the new owner to accept the transfer.\n', ' */\n', 'contract Claimable is EternalStorage, Ownable {\n', '    function pendingOwner() public view returns (address) {\n', '        return addressStorage[keccak256("pendingOwner")];\n', '    }\n', '\n', '    /**\n', '    * @dev Modifier throws if called by any account other than the pendingOwner.\n', '    */\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to set the pendingOwner address.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        addressStorage[keccak256("pendingOwner")] = newOwner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the pendingOwner address to finalize the transfer.\n', '    */\n', '    function claimOwnership() public onlyPendingOwner {\n', '        emit OwnershipTransferred(owner(), pendingOwner());\n', '        addressStorage[keccak256("owner")] = addressStorage[keccak256("pendingOwner")];\n', '        addressStorage[keccak256("pendingOwner")] = address(0);\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', 'contract Messages is EternalStorage {\n', '    struct Authorization {\n', '        address authorizedSigner;\n', '        uint256 expiration;\n', '    }\n', '    /**\n', '     * Domain separator encoding per EIP 712.\n', '     * keccak256(\n', '     *     "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)"\n', '     * )\n', '     */\n', '    bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\n', '\n', '    /**\n', '     * Validator struct type encoding per EIP 712\n', '     * keccak256(\n', '     *     "Authorization(address authorizedSigner,uint256 expiration)"\n', '     * )\n', '     */\n', '    bytes32 private constant AUTHORIZATION_TYPEHASH = 0xe419504a688f0e6ea59c2708f49b2bbc10a2da71770bd6e1b324e39c73e7dc25;\n', '\n', '\n', '    /**\n', '     * Domain separator per EIP 712\n', '     */\n', '    // bytes32 public DOMAIN_SEPARATOR;\n', '    function DOMAIN_SEPARATOR() public view returns(bytes32) {\n', '        bytes32 salt = 0xf2d857f4a3edcb9b78b4d503bfe733db1e3f6cdc2b7971ee739626c97e86a558;\n', '        return keccak256(abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256("Multisender"),\n', '                keccak256("2.0"),\n', '                uintStorage[keccak256("chainId")],\n', '                address(this),\n', '                salt\n', '            ));\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates authorizationHash according to EIP 712.\n', '     * @param _authorizedSigner address of trustee\n', '     * @param _expiration expiration date\n', '     * @return bytes32 EIP 712 hash of _authorization.\n', '     */\n', '    function hash(address _authorizedSigner, uint256 _expiration) public pure returns (bytes32) {\n', '        return keccak256(abi.encode(\n', '                AUTHORIZATION_TYPEHASH,\n', '                _authorizedSigner,\n', '                _expiration\n', '            ));\n', '    }\n', '\n', '    /**\n', '     * @return the recovered address from the signature\n', '     */\n', '    function recoverAddress(\n', '        bytes32 messageHash,\n', '        bytes memory signature\n', '    )\n', '    public\n', '    view\n', '    returns (address)\n', '    {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        bytes1 v;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(signature, 0x20))\n', '            s := mload(add(signature, 0x40))\n', '            v := mload(add(signature, 0x60))\n', '        }\n', '        bytes32 digest = keccak256(abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR(),\n', '                messageHash\n', '            ));\n', '        return ecrecover(digest, uint8(v), r, s);\n', '    }\n', '\n', '    function getApprover(uint256 timestamp, bytes memory signature) public view returns(address) {\n', '        if (timestamp < now) {\n', '            return address(0);\n', '        }\n', '        bytes32 messageHash = hash(msg.sender, timestamp);\n', '        return recoverAddress(messageHash, signature);\n', '    }\n', '\n', '\n', '}\n', '\n', 'pragma solidity 0.5.7;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    function balanceOf(address who) public view returns (uint256);\n', '\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '\n', 'contract ERC20 is ERC20Basic {\n', '    function allowance(address owner, address spender)\n', '    public\n', '    view\n', '    returns (uint256);\n', '\n', '    function transferFrom(address from, address to, uint256 value)\n', '    public\n', '    returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '\n', 'contract UpgradebleStormSender is\n', 'OwnedUpgradeabilityStorage,\n', 'Claimable,\n', 'Messages\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    event Multisended(uint256 total, address tokenAddress);\n', '    event ClaimedTokens(address token, address owner, uint256 balance);\n', '    event PurchaseVIP(address customer, uint256 tier);\n', '\n', '    modifier hasFee() {\n', '        uint256 contractFee = currentFee(msg.sender);\n', '        if (contractFee > 0) {\n', '            require(msg.value >= contractFee, "no fee");\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier validLists(uint256 _contributorsLength, uint256 _balancesLength) {\n', '        require(_contributorsLength > 0, "no contributors sent");\n', '        require(\n', '            _contributorsLength == _balancesLength,\n', '            "different arrays lengths"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function() external payable {}\n', '\n', '    function initialize(\n', '        address _owner,\n', '        uint256 _fee,\n', '        uint256 _vipPrice0,\n', '        uint256 _vipPrice1,\n', '        uint256 _vipPrice2,\n', '        uint256 _chainId\n', '    ) public {\n', '        require(!initialized() || msg.sender == owner());\n', '        setOwner(_owner);\n', '        setFee(_fee); // 0.05 ether fee\n', '        setVipPrice(0, _vipPrice0); // 1 eth\n', '        setVipPrice(1, _vipPrice1); // 5 eth\n', '        setVipPrice(2, _vipPrice2); // 10 eth\n', '        uintStorage[keccak256("chainId")] = _chainId;\n', '        boolStorage[keccak256("rs_multisender_initialized")] = true;\n', '        require(fee() >= 0.01 ether);\n', '        uintStorage[keccak256("referralFee")] = 0.01 ether;\n', '    }\n', '\n', '    function initialized() public view returns (bool) {\n', '        return boolStorage[keccak256("rs_multisender_initialized")];\n', '    }\n', '\n', '    function fee() public view returns (uint256) {\n', '        return uintStorage[keccak256("fee")];\n', '    }\n', '\n', '    function currentFee(address _customer) public view returns (uint256) {\n', '        if (getUnlimAccess(_customer) >= block.timestamp) {\n', '            return 0;\n', '        }\n', '        return fee();\n', '    }\n', '\n', '    function setFee(uint256 _newStep) public onlyOwner {\n', '        require(_newStep != 0);\n', '        uintStorage[keccak256("fee")] = _newStep;\n', '    }\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes memory _data)\n', '    public\n', '    {}\n', '\n', '    function _checkFee(address _user, address payable _referral) internal {\n', '        uint256 contractFee = currentFee(_user);\n', '        if (contractFee > 0) {\n', '            require(msg.value >= contractFee, "no fee");\n', '            if (_referral != address(0)) {\n', '                _referral.send(referralFee());\n', '            }\n', '        }\n', '    }\n', '\n', '    function multisendToken(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total,\n', '        address payable _referral\n', '    ) external payable validLists(_contributors.length, _balances.length) {\n', '        bool isGoodToken;\n', '        bytes memory data;\n', '        _checkFee(msg.sender, _referral);\n', '        uint256 change = 0;\n', '        ERC20 erc20token = ERC20(_token);\n', '        // bytes4 transferFrom = 0x23b872dd;\n', '        (isGoodToken, data) = _token.call(\n', '            abi.encodeWithSelector(\n', '                0x23b872dd,\n', '                msg.sender,\n', '                address(this),\n', '                _total\n', '            )\n', '        );\n', '        require(isGoodToken, "transferFrom failed");\n', '        if (data.length > 0) {\n', '            bool success = abi.decode(data, (bool));\n', '            require(success, "not enough allowed tokens");\n', '        }\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                    erc20token.transfer.selector,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '            if (!success) {\n', '                change += _balances[i];\n', '            }\n', '        }\n', '        if (change != 0) {\n', '            erc20token.transfer(msg.sender, change);\n', '        }\n', '        emit Multisended(_total, _token);\n', '    }\n', '\n', '    function findBadAddressesForBurners(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total\n', '    )\n', '    external\n', '    payable\n', '    validLists(_contributors.length, _balances.length)\n', '    hasFee\n', '    returns (address[] memory badAddresses, uint256[] memory badBalances)\n', '    {\n', '        badAddresses = new address[](_contributors.length);\n', '        badBalances = new uint256[](_contributors.length);\n', '        ERC20 erc20token = ERC20(_token);\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                    erc20token.transferFrom.selector,\n', '                    msg.sender,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '            if (!success) {\n', '                badAddresses[i] = _contributors[i];\n', '                badBalances[i] = _balances[i];\n', '            }\n', '        }\n', '    }\n', '\n', '    function multisendTokenForBurners(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total,\n', '        address payable _referral\n', '    ) external payable validLists(_contributors.length, _balances.length) {\n', '        _checkFee(msg.sender, _referral);\n', '        ERC20 erc20token = ERC20(_token);\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                    erc20token.transferFrom.selector,\n', '                    msg.sender,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '        }\n', '        emit Multisended(_total, _token);\n', '    }\n', '\n', '    function multisendTokenForBurnersWithSignature(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total,\n', '        address payable _referral,\n', '        bytes calldata _signature,\n', '        uint256 _timestamp\n', '    ) external payable {\n', '        address tokenHolder = getApprover(_timestamp, _signature);\n', '        require(\n', '            tokenHolder != address(0),\n', '            "the signature is invalid or has expired"\n', '        );\n', '        require(_contributors.length > 0, "no contributors sent");\n', '        require(\n', '            _contributors.length == _balances.length,\n', '            "different arrays lengths"\n', '        );\n', '        // require(msg.value >= currentFee(tokenHolder), "no fee");\n', '        _checkFee(tokenHolder, _referral);\n', '        ERC20 erc20token = ERC20(_token);\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                    erc20token.transferFrom.selector,\n', '                    tokenHolder,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '        }\n', '        emit Multisended(_total, _token);\n', '    }\n', '\n', '    function multisendTokenWithSignature(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total,\n', '        address payable _referral,\n', '        bytes calldata _signature,\n', '        uint256 _timestamp\n', '    ) external payable {\n', '        bool isGoodToken;\n', '        address tokenHolder = getApprover(_timestamp, _signature);\n', '        require(\n', '            tokenHolder != address(0),\n', '            "the signature is invalid or has expired"\n', '        );\n', '        require(_contributors.length > 0, "no contributors sent");\n', '        require(\n', '            _contributors.length == _balances.length,\n', '            "different arrays lengths"\n', '        );\n', '        _checkFee(tokenHolder, _referral);\n', '        uint256 change = 0;\n', '        (isGoodToken, ) = _token.call(\n', '            abi.encodeWithSelector(\n', '                0x23b872dd,\n', '                tokenHolder,\n', '                address(this),\n', '                _total\n', '            )\n', '        );\n', '        require(isGoodToken, "not enough allowed tokens");\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                // transfer\n', '                    0xa9059cbb,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '            if (!success) {\n', '                change += _balances[i];\n', '            }\n', '        }\n', '        if (change != 0) {\n', '            _token.call(\n', '                abi.encodeWithSelector(\n', '                // transfer\n', '                    0xa9059cbb,\n', '                    tokenHolder,\n', '                    change\n', '                )\n', '            );\n', '        }\n', '        emit Multisended(_total, _token);\n', '    }\n', '\n', '    // DONT USE THIS METHOD, only for eth_call\n', '    function tokenFindBadAddresses(\n', '        address _token,\n', '        address[] calldata _contributors,\n', '        uint256[] calldata _balances,\n', '        uint256 _total\n', '    )\n', '    external\n', '    payable\n', '    validLists(_contributors.length, _balances.length)\n', '    hasFee\n', '    returns (address[] memory badAddresses, uint256[] memory badBalances)\n', '    {\n', '        badAddresses = new address[](_contributors.length);\n', '        badBalances = new uint256[](_contributors.length);\n', '        ERC20 erc20token = ERC20(_token);\n', '        bool isGoodToken;\n', '        (isGoodToken, ) = _token.call(\n', '            abi.encodeWithSelector(\n', '                0x23b872dd,\n', '                msg.sender,\n', '                address(this),\n', '                _total\n', '            )\n', '        );\n', '        // erc20token.transferFrom(msg.sender, address(this), _total);\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            (bool success, ) = _token.call(\n', '                abi.encodeWithSelector(\n', '                    erc20token.transfer.selector,\n', '                    _contributors[i],\n', '                    _balances[i]\n', '                )\n', '            );\n', '            if (!success) {\n', '                badAddresses[i] = _contributors[i];\n', '                badBalances[i] = _balances[i];\n', '            }\n', '        }\n', '    }\n', '\n', '    // DONT USE THIS METHOD, only for eth_call\n', '    function etherFindBadAddresses(\n', '        address payable[] calldata _contributors,\n', '        uint256[] calldata _balances\n', '    )\n', '    external\n', '    payable\n', '    validLists(_contributors.length, _balances.length)\n', '    returns (address[] memory badAddresses, uint256[] memory badBalances)\n', '    {\n', '        badAddresses = new address[](_contributors.length);\n', '        badBalances = new uint256[](_contributors.length);\n', '\n', '        uint256 _total = msg.value;\n', '        uint256 _contractFee = currentFee(msg.sender);\n', '        _total = _total.sub(_contractFee);\n', '\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            bool _success = _contributors[i].send(_balances[i]);\n', '            if (!_success) {\n', '                badAddresses[i] = _contributors[i];\n', '                badBalances[i] = _balances[i];\n', '            } else {\n', '                _total = _total.sub(_balances[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function multisendEther(\n', '        address payable[] calldata _contributors,\n', '        uint256[] calldata _balances\n', '    ) external payable validLists(_contributors.length, _balances.length) {\n', '        uint256 _contractBalanceBefore = address(this).balance.sub(msg.value);\n', '        uint256 _total = msg.value;\n', '        uint256 _contractFee = currentFee(msg.sender);\n', '        _total = _total.sub(_contractFee);\n', '\n', '        for (uint256 i = 0; i < _contributors.length; i++) {\n', '            bool _success = _contributors[i].send(_balances[i]);\n', '            if (_success) {\n', '                _total = _total.sub(_balances[i]);\n', '            }\n', '        }\n', '\n', '        uint256 _contractBalanceAfter = address(this).balance;\n', '        // assert. Just for sure\n', '        require(\n', '            _contractBalanceAfter >= _contractBalanceBefore.add(_contractFee),\n', '            "don’t try to take the contract money"\n', '        );\n', '\n', '        emit Multisended(_total, 0x000000000000000000000000000000000000bEEF);\n', '    }\n', '\n', '    function setVipPrice(uint256 _tier, uint256 _price) public onlyOwner {\n', '        uintStorage[keccak256(abi.encodePacked("vip", _tier))] = _price;\n', '    }\n', '\n', '    function setAddressToVip(address _address, uint256 _tier)\n', '    external\n', '    onlyOwner\n', '    {\n', '        setUnlimAccess(_address, _tier);\n', '        emit PurchaseVIP(msg.sender, _tier);\n', '    }\n', '\n', '    function buyVip(uint256 _tier) external payable {\n', '        require(\n', '            msg.value >= uintStorage[keccak256(abi.encodePacked("vip", _tier))]\n', '        );\n', '        setUnlimAccess(msg.sender, _tier);\n', '        emit PurchaseVIP(msg.sender, _tier);\n', '    }\n', '\n', '    function setReferralFee(uint256 _newFee) external onlyOwner {\n', '        require(fee() >= _newFee);\n', '        uintStorage[keccak256("referralFee")] = _newFee;\n', '    }\n', '\n', '    function referralFee() public view returns (uint256) {\n', '        return uintStorage[keccak256("referralFee")];\n', '    }\n', '\n', '    function getVipPrice(uint256 _tier) public view returns (uint256) {\n', '        return uintStorage[keccak256(abi.encodePacked("vip", _tier))];\n', '    }\n', '\n', '    function getAllVipPrices()\n', '    external\n', '    view\n', '    returns (uint256 tier0, uint256 tier1, uint256 tier2)\n', '    {\n', '        return (\n', '        uintStorage[keccak256(abi.encodePacked("vip", uint256(0)))],\n', '        uintStorage[keccak256(abi.encodePacked("vip", uint256(1)))],\n', '        uintStorage[keccak256(abi.encodePacked("vip", uint256(2)))]\n', '        );\n', '    }\n', '\n', '    function claimTokens(address _token, uint256 _amount) external onlyOwner {\n', '        address payable ownerPayable = address(uint160(owner()));\n', '        uint256 amount = _amount;\n', '        if (_amount == 0) {\n', '            amount = address(this).balance;\n', '        }\n', '        if (_token == address(0)) {\n', '            ownerPayable.transfer(amount);\n', '            return;\n', '        }\n', '        ERC20 erc20token = ERC20(_token);\n', '        amount = erc20token.balanceOf(address(this));\n', '        erc20token.transfer(ownerPayable, amount);\n', '        emit ClaimedTokens(_token, ownerPayable, amount);\n', '    }\n', '\n', '    function getDeadline(uint256 _tier) public view returns (uint256) {\n', '        // 1 day\n', '        if (_tier == 0) {\n', '            return block.timestamp + 1 days;\n', '        }\n', '        // 7 days\n', '        if (_tier == 1) {\n', '            return block.timestamp + 7 days;\n', '        }\n', '        // Lifetime\n', '        if (_tier == 2) {\n', '            return block.timestamp + 30 days;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function getUnlimAccess(address customer) public view returns (uint256) {\n', '        return\n', '        uintStorage[keccak256(abi.encodePacked("unlimAccess", customer))];\n', '    }\n', '\n', '    function setUnlimAccess(address customer, uint256 _tier) private {\n', '        uintStorage[keccak256(\n', '            abi.encodePacked("unlimAccess", customer)\n', '        )] = getDeadline(_tier);\n', '    }\n', '\n', '    function exploreETHBalances(address[] calldata targets)\n', '    external\n', '    view\n', '    returns (uint256[] memory balances)\n', '    {\n', '        balances = new uint256[](targets.length);\n', '        for (uint256 i = 0; i < targets.length; i++) {\n', '            balances[i] = targets[i].balance;\n', '        }\n', '    }\n', '\n', '    function exploreERC20Balances(ERC20 token, address[] calldata targets)\n', '    external\n', '    view\n', '    returns (uint256[] memory balances)\n', '    {\n', '        balances = new uint256[](targets.length);\n', '        for (uint256 i = 0; i < targets.length; i++) {\n', '            balances[i] = token.balanceOf(targets[i]);\n', '        }\n', '    }\n', '}']