['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-17\n', '*/\n', '\n', '// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n', '\n', 'pragma solidity ^0.6.6;\n', '\n', 'interface IArmorMaster {\n', '    function registerModule(bytes32 _key, address _module) external;\n', '    function getModule(bytes32 _key) external view returns(address);\n', '    function keep() external;\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * \n', ' * @dev Completely default OpenZeppelin.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function initializeOwnable() internal {\n', '        require(_owner == address(0), "already initialized");\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "msg.sender is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    function receiveOwnership() public {\n', '        require(msg.sender == _pendingOwner, "only pending owner can call this function");\n', '        _transferOwnership(_pendingOwner);\n', '        _pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', 'library Bytes32 {\n', '    function toString(bytes32 x) internal pure returns (string memory) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint256 j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (uint256 j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n', '**/\n', 'contract ArmorModule {\n', '    IArmorMaster internal _master;\n', '\n', '    using Bytes32 for bytes32;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == Ownable(address(_master)).owner(), "only owner can call this function");\n', '        _;\n', '    }\n', '\n', '    modifier doKeep() {\n', '        _master.keep();\n', '        _;\n', '    }\n', '\n', '    modifier onlyModule(bytes32 _module) {\n', '        string memory message = string(abi.encodePacked("only module ", _module.toString()," can call this function"));\n', '        require(msg.sender == getModule(_module), message);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Used when multiple can call.\n', '    **/\n', '    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n', '        string memory message = string(abi.encodePacked("only module ", _moduleOne.toString()," or ", _moduleTwo.toString()," can call this function"));\n', '        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n', '        _;\n', '    }\n', '\n', '    function initializeModule(address _armorMaster) internal {\n', '        require(address(_master) == address(0), "already initialized");\n', '        require(_armorMaster != address(0), "master cannot be zero address");\n', '        _master = IArmorMaster(_armorMaster);\n', '    }\n', '\n', '    function changeMaster(address _newMaster) external onlyOwner {\n', '        _master = IArmorMaster(_newMaster);\n', '    }\n', '\n', '    function getModule(bytes32 _key) internal view returns(address) {\n', '        return _master.getModule(_key);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', 'interface IarNFT is IERC721 {\n', '    function getToken(uint256 _tokenId) external returns (uint256, uint8, uint256, uint16, uint256, address, bytes4, uint256, uint256, uint256);\n', '    function submitClaim(uint256 _tokenId) external;\n', '    function redeemClaim(uint256 _tokenId) external;\n', '}\n', '\n', 'interface IPlanManager {\n', '  // Event to notify frontend of plan update.\n', '  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n', '  function initialize(address _armorManager) external;\n', '  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n', '  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n', '  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n', '  function coverageLeft(address _protocol) external view returns(uint256);\n', '  function getCurrentPlan(address _user) external view returns(uint128 start, uint128 end);\n', '  function updateExpireTime(address _user) external;\n', '  function planRedeemed(address _useer, uint256 _planIndex, address _protocol) external;\n', '}\n', '\n', 'interface IStakeManager {\n', '    function totalStakedAmount(address protocol) external view returns(uint256);\n', '    function protocolAddress(uint64 id) external view returns(address);\n', '    function protocolId(address protocol) external view returns(uint64);\n', '    function initialize(address _armorMaster) external;\n', '    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\n', '    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\n', '}\n', '\n', 'interface IClaimManager {\n', '    function initialize(address _armorMaster) external;\n', '    function transferNft(address _to, uint256 _nftId) external;\n', '    function exchangeWithdrawal(uint256 _amount) external;\n', '}\n', '\n', '/**\n', ' * @dev This contract holds all NFTs. The only time it does something is if a user requests a claim.\n', ' * @notice We need to make sure a user can only claim when they have balance.\n', '**/\n', 'contract ClaimManager is ArmorModule, IClaimManager {\n', '    bytes4 public constant ETH_SIG = bytes4(0x45544800);\n', '\n', '    // Mapping of hacks that we have confirmed to have happened. (keccak256(protocol ID, timestamp) => didithappen).\n', '    mapping (bytes32 => bool) confirmedHacks;\n', '    \n', '    // Emitted when a new hack has been recorded.\n', '    event ConfirmedHack(bytes32 indexed hackId, address indexed protocol, uint256 timestamp);\n', '    \n', '    // Emitted when a user successfully receives a payout.\n', '    event ClaimPayout(bytes32 indexed hackId, address indexed user, uint256 amount);\n', '\n', '    // for receiving redeemed ether\n', '    receive() external payable {\n', '    }\n', '    \n', '    /**\n', '     * @dev Start the contract off by giving it the address of Nexus Mutual to submit a claim.\n', '    **/\n', '    function initialize(address _armorMaster)\n', '      public\n', '      override\n', '    {\n', '        initializeModule(_armorMaster);\n', '    }\n', '    \n', '    /**\n', '     * @dev User requests claim based on a loss.\n', '     *      Do we want this to be callable by anyone or only the person requesting?\n', '     *      Proof-of-Loss must be implemented here.\n', '     * @param _hackTime The given timestamp for when the hack occurred.\n', '     * @notice Make sure this cannot be done twice. I also think this protocol interaction can be simplified.\n', '    **/\n', '    function redeemClaim(address _protocol, uint256 _hackTime, uint256 _amount)\n', '      external\n', '      doKeep\n', '    {\n', '        bytes32 hackId = keccak256(abi.encodePacked(_protocol, _hackTime));\n', '        require(confirmedHacks[hackId], "No hack with these parameters has been confirmed.");\n', '        \n', '        // Gets the coverage amount of the user at the time the hack happened.\n', '        // TODO check if plan is not active now => to prevent users paying more than needed\n', '        (uint256 planIndex, bool covered) = IPlanManager(getModule("PLAN")).checkCoverage(msg.sender, _protocol, _hackTime, _amount);\n', '        require(covered, "User does not have cover for hack");\n', '        \n', '        IPlanManager(getModule("PLAN")).planRedeemed(msg.sender, planIndex, _protocol);\n', '        msg.sender.transfer(_amount);\n', '        \n', '        emit ClaimPayout(hackId, msg.sender, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Submit any NFT that was active at the time of a hack on its protocol.\n', '     * @param _nftId ID of the NFT to submit.\n', '     * @param _hackTime The timestamp of the hack that occurred. Hacktime is the START of the hack if not a single tx.\n', '    **/\n', '    function submitNft(uint256 _nftId,uint256 _hackTime)\n', '      external\n', '      doKeep\n', '    {\n', '        (/*cid*/, uint8 status, uint256 sumAssured, uint16 coverPeriod, uint256 validUntil, address scAddress,\n', '        bytes4 currencyCode, /*premiumNXM*/, /*coverPrice*/, /*claimId*/) = IarNFT(getModule("ARNFT")).getToken(_nftId);\n', '        bytes32 hackId = keccak256(abi.encodePacked(scAddress, _hackTime));\n', '        \n', '        require(confirmedHacks[hackId], "No hack with these parameters has been confirmed.");\n', '        require(currencyCode == ETH_SIG, "Only ETH nft can be submitted");\n', '        \n', '        // Make sure arNFT was active at the time\n', '        require(validUntil >= _hackTime, "arNFT was not valid at time of hack.");\n', '        \n', '        // Make sure NFT was purchased before hack.\n', '        uint256 generationTime = validUntil - (uint256(coverPeriod) * 1 days);\n', '        require(generationTime <= _hackTime, "arNFT had not been purchased before hack.");\n', '\n', '        // Subtract amount it was protecting from total staked for the protocol if it is not expired (in which case it already has been subtracted).\n', '        uint256 weiSumAssured = sumAssured * (1e18);\n', '        if (status != 3) IStakeManager(getModule("STAKE")).subtractTotal(_nftId, scAddress, weiSumAssured);\n', '        // subtract balance here\n', '\n', '        IarNFT(getModule("ARNFT")).submitClaim(_nftId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Calls the arNFT contract to redeem a claim (receive funds) if it has been accepted.\n', '     *      This is callable by anyone without any checks--either we receive money or it reverts.\n', '     * @param _nftId The ID of the yNft token.\n', '    **/\n', '    function redeemNft(uint256 _nftId)\n', '      external\n', '      doKeep\n', '    {\n', '        IarNFT(getModule("ARNFT")).redeemClaim(_nftId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by StakeManager in case a user wants to withdraw their NFT.\n', '     * @param _to Address to send the NFT to.\n', '     * @param _nftId ID of the NFT to be withdrawn.\n', '    **/\n', '    function transferNft(address _to, uint256 _nftId)\n', '      external\n', '      override\n', '      onlyModule("STAKE")\n', '    {\n', '        IarNFT(getModule("ARNFT")).safeTransferFrom(address(this), _to, _nftId);\n', '    }\n', '    \n', '    /**\n', '     * @dev Called by Armor for now--we confirm a hack happened and give a timestamp for what time it was.\n', '     * @param _protocol The address of the protocol that has been hacked (address that would be on yNFT).\n', '     * @param _hackTime The timestamp of the time the hack occurred.\n', '    **/\n', '    function confirmHack(address _protocol, uint256 _hackTime)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_hackTime < now, "Cannot confirm future");\n', '        bytes32 hackId = keccak256(abi.encodePacked(_protocol, _hackTime));\n', '        confirmedHacks[hackId] = true;\n', '        emit ConfirmedHack(hackId, _protocol, _hackTime);\n', '    }\n', '\n', '    /**\n', '     * @dev ExchangeManager may withdraw Ether from ClaimManager to then exchange for wNXM then deposit to arNXM vault.\n', '     * @param _amount Amount in Wei to send to ExchangeManager.\n', '    **/\n', '    function exchangeWithdrawal(uint256 _amount)\n', '      external\n', '      override\n', '      onlyModule("EXCHANGE")\n', '    {\n', '        msg.sender.transfer(_amount);\n', '    }\n', '\n', '}']