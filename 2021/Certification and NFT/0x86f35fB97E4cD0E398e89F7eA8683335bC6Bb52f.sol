['// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/access/Ownable.sol";\n', 'import "./Lockable.sol";\n', '\n', '/**\n', ' * @title A contract to track a whitelist of addresses.\n', ' */\n', 'contract AddressWhitelist is Ownable, Lockable {\n', '    enum Status { None, In, Out }\n', '    mapping(address => Status) public whitelist;\n', '\n', '    address[] public whitelistIndices;\n', '\n', '    event AddedToWhitelist(address indexed addedAddress);\n', '    event RemovedFromWhitelist(address indexed removedAddress);\n', '\n', '    /**\n', '     * @notice Adds an address to the whitelist.\n', '     * @param newElement the new address to add.\n', '     */\n', '    function addToWhitelist(address newElement) external nonReentrant() onlyOwner {\n', '        // Ignore if address is already included\n', '        if (whitelist[newElement] == Status.In) {\n', '            return;\n', '        }\n', '\n', '        // Only append new addresses to the array, never a duplicate\n', '        if (whitelist[newElement] == Status.None) {\n', '            whitelistIndices.push(newElement);\n', '        }\n', '\n', '        whitelist[newElement] = Status.In;\n', '\n', '        emit AddedToWhitelist(newElement);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes an address from the whitelist.\n', '     * @param elementToRemove the existing address to remove.\n', '     */\n', '    function removeFromWhitelist(address elementToRemove) external nonReentrant() onlyOwner {\n', '        if (whitelist[elementToRemove] != Status.Out) {\n', '            whitelist[elementToRemove] = Status.Out;\n', '            emit RemovedFromWhitelist(elementToRemove);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks whether an address is on the whitelist.\n', '     * @param elementToCheck the address to check.\n', '     * @return True if `elementToCheck` is on the whitelist, or False.\n', '     */\n', '    function isOnWhitelist(address elementToCheck) external view nonReentrantView() returns (bool) {\n', '        return whitelist[elementToCheck] == Status.In;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets all addresses that are currently included in the whitelist.\n', '     * @dev Note: This method skips over, but still iterates through addresses. It is possible for this call to run out\n', '     * of gas if a large number of addresses have been removed. To reduce the likelihood of this unlikely scenario, we\n', '     * can modify the implementation so that when addresses are removed, the last addresses in the array is moved to\n', '     * the empty index.\n', '     * @return activeWhitelist the list of addresses on the whitelist.\n', '     */\n', '    function getWhitelist() external view nonReentrantView() returns (address[] memory activeWhitelist) {\n', '        // Determine size of whitelist first\n', '        uint256 activeCount = 0;\n', '        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n', '            if (whitelist[whitelistIndices[i]] == Status.In) {\n', '                activeCount++;\n', '            }\n', '        }\n', '\n', '        // Populate whitelist\n', '        activeWhitelist = new address[](activeCount);\n', '        activeCount = 0;\n', '        for (uint256 i = 0; i < whitelistIndices.length; i++) {\n', '            address addr = whitelistIndices[i];\n', '            if (whitelist[addr] == Status.In) {\n', '                activeWhitelist[activeCount] = addr;\n', '                activeCount++;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/ERC20.sol";\n', 'import "./MultiRole.sol";\n', 'import "../interfaces/ExpandedIERC20.sol";\n', '\n', '/**\n', ' * @title An ERC20 with permissioned burning and minting. The contract deployer will initially\n', ' * be the owner who is capable of adding new roles.\n', ' */\n', 'contract ExpandedERC20 is ExpandedIERC20, ERC20, MultiRole {\n', '    enum Roles {\n', '        // Can set the minter and burner.\n', '        Owner,\n', '        // Addresses that can mint new tokens.\n', '        Minter,\n', '        // Addresses that can burn tokens that address owns.\n', '        Burner\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the ExpandedERC20.\n', '     * @param _tokenName The name which describes the new token.\n', '     * @param _tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n', '     * @param _tokenDecimals The number of decimals to define token precision.\n', '     */\n', '    constructor(\n', '        string memory _tokenName,\n', '        string memory _tokenSymbol,\n', '        uint8 _tokenDecimals\n', '    ) public ERC20(_tokenName, _tokenSymbol) {\n', '        _setupDecimals(_tokenDecimals);\n', '        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n', '        _createSharedRole(uint256(Roles.Minter), uint256(Roles.Owner), new address[](0));\n', '        _createSharedRole(uint256(Roles.Burner), uint256(Roles.Owner), new address[](0));\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `value` tokens to `recipient`, returning true on success.\n', '     * @param recipient address to mint to.\n', '     * @param value amount of tokens to mint.\n', '     * @return True if the mint succeeded, or False.\n', '     */\n', '    function mint(address recipient, uint256 value)\n', '        external\n', '        override\n', '        onlyRoleHolder(uint256(Roles.Minter))\n', '        returns (bool)\n', '    {\n', '        _mint(recipient, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Burns `value` tokens owned by `msg.sender`.\n', '     * @param value amount of tokens to burn.\n', '     */\n', '    function burn(uint256 value) external override onlyRoleHolder(uint256(Roles.Burner)) {\n', '        _burn(msg.sender, value);\n', '    }\n', '\n', '    /**\n', '     * @notice Add Minter role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Minter role is added.\n', '     */\n', '    function addMinter(address account) external virtual override {\n', '        addMember(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Add Burner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Burner role is added.\n', '     */\n', '    function addBurner(address account) external virtual override {\n', '        addMember(uint256(Roles.Burner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Reset Owner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The new holder of the Owner role.\n', '     */\n', '    function resetOwner(address account) external virtual override {\n', '        resetMember(uint256(Roles.Owner), account);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "@openzeppelin/contracts/math/SignedSafeMath.sol";\n', '\n', '/**\n', ' * @title Library for fixed point arithmetic on uints\n', ' */\n', 'library FixedPoint {\n', '    using SafeMath for uint256;\n', '    using SignedSafeMath for int256;\n', '\n', '    // Supports 18 decimals. E.g., 1e18 represents "1", 5e17 represents "0.5".\n', '    // For unsigned values:\n', '    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n', '    uint256 private constant FP_SCALING_FACTOR = 10**18;\n', '\n', '    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n', '    struct Unsigned {\n', '        uint256 rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\n', '     * @param a uint to convert into a FixedPoint.\n', '     * @return the converted FixedPoint.\n', '     */\n', '    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.mul(FP_SCALING_FACTOR));\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue == fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue == b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue > fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue >= fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue < fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n', '        return a.rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n', '        return a.rawValue <= fromUnscaledUint(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n', '        return fromUnscaledUint(a).rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice The minimum of `a` and `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the minimum of `a` and `b`.\n', '     */\n', '    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return a.rawValue < b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice The maximum of `a` and `b`.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the maximum of `a` and `b`.\n', '     */\n', '    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return a.rawValue > b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice Adds two `Unsigned`s, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.add(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return add(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.sub(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return sub(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n', '     * @param a a uint256.\n', '     * @param b a FixedPoint.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return sub(fromUnscaledUint(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n', '        // stored internally as a uint256 ~10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n", '        // would round to 3, but this computation produces the result 2.\n', '        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n', '        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.\n', '     * @param b a uint256.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Unsigned`s and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n', '        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n', '        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n', '        if (mod != 0) {\n', '            return Unsigned(mulFloor.add(1));\n', '        } else {\n', '            return Unsigned(mulFloor);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Unsigned` and an unscaled uint256 and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.\n', '     * @param b a FixedPoint.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        // Since b is an int, there is no risk of truncation and we can just mul it normally\n', '        return Unsigned(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n', '        // 10^41 is stored internally as a uint256 10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n", '        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n', '        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        return Unsigned(a.rawValue.div(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a uint256 numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        return div(fromUnscaledUint(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an `Unsigned` and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n', '        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n', '        uint256 divFloor = aScaled.div(b.rawValue);\n', '        uint256 mod = aScaled.mod(b.rawValue);\n', '        if (mod != 0) {\n', '            return Unsigned(divFloor.add(1));\n', '        } else {\n', '            return Unsigned(divFloor);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Unsigned` by an unscaled uint256 and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n', '        // Because it is possible that a quotient gets truncated, we can\'t just call "Unsigned(a.rawValue.div(b))"\n', '        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n', '        // This creates the possibility of overflow if b is very large.\n', '        return divCeil(a, fromUnscaledUint(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n', '     * @dev This will "floor" the result.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a uint256 denominator.\n', '     * @return output is `a` to the power of `b`.\n', '     */\n', '    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n', '        output = fromUnscaledUint(1);\n', '        for (uint256 i = 0; i < b; i = i.add(1)) {\n', '            output = mul(output, a);\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n', '    // Supports 18 decimals. E.g., 1e18 represents "1", 5e17 represents "0.5".\n', '    // For signed values:\n', '    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n', '    int256 private constant SFP_SCALING_FACTOR = 10**18;\n', '\n', '    struct Signed {\n', '        int256 rawValue;\n', '    }\n', '\n', '    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n', '        require(a.rawValue >= 0, "Negative value provided");\n', '        return Unsigned(uint256(a.rawValue));\n', '    }\n', '\n', '    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n', '        require(a.rawValue <= uint256(type(int256).max), "Unsigned too large");\n', '        return Signed(int256(a.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\n', '     * @param a int to convert into a FixedPoint.Signed.\n', '     * @return the converted FixedPoint.Signed.\n', '     */\n', '    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n', '        return Signed(a.mul(SFP_SCALING_FACTOR));\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a int256.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n', '        return a.rawValue == fromUnscaledInt(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if equal, or False.\n', '     */\n', '    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n', '        return a.rawValue == b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n', '        return a.rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n', '        return a.rawValue > fromUnscaledInt(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than `b`.\n', '     * @param a an int256.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a > b`, or False.\n', '     */\n', '    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n', '        return fromUnscaledInt(a).rawValue > b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n', '        return a.rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n', '        return a.rawValue >= fromUnscaledInt(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is greater than or equal to `b`.\n', '     * @param a an int256.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a >= b`, or False.\n', '     */\n', '    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n', '        return fromUnscaledInt(a).rawValue >= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n', '        return a.rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n', '        return a.rawValue < fromUnscaledInt(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than `b`.\n', '     * @param a an int256.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a < b`, or False.\n', '     */\n', '    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n', '        return fromUnscaledInt(a).rawValue < b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n', '        return a.rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n', '        return a.rawValue <= fromUnscaledInt(b).rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `a` is less than or equal to `b`.\n', '     * @param a an int256.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return True if `a <= b`, or False.\n', '     */\n', '    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n', '        return fromUnscaledInt(a).rawValue <= b.rawValue;\n', '    }\n', '\n', '    /**\n', '     * @notice The minimum of `a` and `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the minimum of `a` and `b`.\n', '     */\n', '    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        return a.rawValue < b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice The maximum of `a` and `b`.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the maximum of `a` and `b`.\n', '     */\n', '    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        return a.rawValue > b.rawValue ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @notice Adds two `Signed`s, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        return Signed(a.rawValue.add(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return the sum of `a` and `b`.\n', '     */\n', '    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        return add(a, fromUnscaledInt(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts two `Signed`s, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        return Signed(a.rawValue.sub(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        return sub(a, fromUnscaledInt(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n', '     * @param a an int256.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the difference of `a` and `b`.\n', '     */\n', '    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n', '        return sub(fromUnscaledInt(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Signed`s, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n', '        // stored internally as an int256 ~10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n", '        // would round to 3, but this computation produces the result 2.\n', '        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n', '        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n', '     * @dev This will "floor" the product.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b an int256.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        return Signed(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies two `Signed`s and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        int256 mulRaw = a.rawValue.mul(b.rawValue);\n', '        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n', "        // Manual mod because SignedSafeMath doesn't support it.\n", '        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n', '        if (mod != 0) {\n', '            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n', '            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n', '            return Signed(mulTowardsZero.add(valueToAdd));\n', '        } else {\n', '            return Signed(mulTowardsZero);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Multiplies an `Signed` and an unscaled int256 and "ceil\'s" the product, reverting on overflow.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a FixedPoint.Signed.\n', '     * @return the product of `a` and `b`.\n', '     */\n', '    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        // Since b is an int, there is no risk of truncation and we can just mul it normally\n', '        return Signed(a.rawValue.mul(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        // There are two caveats with this computation:\n', '        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n', '        // 10^41 is stored internally as an int256 10^59.\n', "        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n", '        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n', '        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b an int256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        return Signed(a.rawValue.div(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n', '     * @dev This will "floor" the quotient.\n', '     * @param a an int256 numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n', '        return div(fromUnscaledInt(a), b);\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Signed` by an `Signed` and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b a FixedPoint denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n', '        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n', '        int256 divTowardsZero = aScaled.div(b.rawValue);\n', "        // Manual mod because SignedSafeMath doesn't support it.\n", '        int256 mod = aScaled % b.rawValue;\n', '        if (mod != 0) {\n', '            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n', '            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n', '            return Signed(divTowardsZero.add(valueToAdd));\n', '        } else {\n', '            return Signed(divTowardsZero);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Divides one `Signed` by an unscaled int256 and "ceil\'s" the quotient, reverting on overflow or division by 0.\n', '     * @param a a FixedPoint numerator.\n', '     * @param b an int256 denominator.\n', '     * @return the quotient of `a` divided by `b`.\n', '     */\n', '    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n', '        // Because it is possible that a quotient gets truncated, we can\'t just call "Signed(a.rawValue.div(b))"\n', '        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n', '        // This creates the possibility of overflow if b is very large.\n', '        return divAwayFromZero(a, fromUnscaledInt(b));\n', '    }\n', '\n', '    /**\n', '     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n', '     * @dev This will "floor" the result.\n', '     * @param a a FixedPoint.Signed.\n', '     * @param b a uint256 (negative exponents are not allowed).\n', '     * @return output is `a` to the power of `b`.\n', '     */\n', '    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n', '        output = fromUnscaledInt(1);\n', '        for (uint256 i = 0; i < b; i = i.add(1)) {\n', '            output = mul(output, a);\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\n', ' * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\n', ' * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\n', ' */\n', 'contract Lockable {\n', '    bool private _notEntered;\n', '\n', '    constructor() internal {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _preEntranceCheck();\n', '        _preEntranceSet();\n', '        _;\n', '        _postEntranceReset();\n', '    }\n', '\n', '    /**\n', '     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\n', '     */\n', '    modifier nonReentrantView() {\n', '        _preEntranceCheck();\n', '        _;\n', '    }\n', '\n', "    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\n", '    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being re-entered.\n', '    // Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and then call `_postEntranceReset()`.\n', '    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\n', '    function _preEntranceCheck() internal view {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '    }\n', '\n', '    function _preEntranceSet() internal {\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '    }\n', '\n', '    function _postEntranceReset() internal {\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'library Exclusive {\n', '    struct RoleMembership {\n', '        address member;\n', '    }\n', '\n', '    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n', '        return roleMembership.member == memberToCheck;\n', '    }\n', '\n', '    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n', '        require(newMember != address(0x0), "Cannot set an exclusive role to 0x0");\n', '        roleMembership.member = newMember;\n', '    }\n', '\n', '    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n', '        return roleMembership.member;\n', '    }\n', '\n', '    function init(RoleMembership storage roleMembership, address initialMember) internal {\n', '        resetMember(roleMembership, initialMember);\n', '    }\n', '}\n', '\n', 'library Shared {\n', '    struct RoleMembership {\n', '        mapping(address => bool) members;\n', '    }\n', '\n', '    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n', '        return roleMembership.members[memberToCheck];\n', '    }\n', '\n', '    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n', '        require(memberToAdd != address(0x0), "Cannot add 0x0 to a shared role");\n', '        roleMembership.members[memberToAdd] = true;\n', '    }\n', '\n', '    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n', '        roleMembership.members[memberToRemove] = false;\n', '    }\n', '\n', '    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n', '        for (uint256 i = 0; i < initialMembers.length; i++) {\n', '            addMember(roleMembership, initialMembers[i]);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Base class to manage permissions for the derived class.\n', ' */\n', 'abstract contract MultiRole {\n', '    using Exclusive for Exclusive.RoleMembership;\n', '    using Shared for Shared.RoleMembership;\n', '\n', '    enum RoleType { Invalid, Exclusive, Shared }\n', '\n', '    struct Role {\n', '        uint256 managingRole;\n', '        RoleType roleType;\n', '        Exclusive.RoleMembership exclusiveRoleMembership;\n', '        Shared.RoleMembership sharedRoleMembership;\n', '    }\n', '\n', '    mapping(uint256 => Role) private roles;\n', '\n', '    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n', '    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n', '    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n', '\n', '    /**\n', '     * @notice Reverts unless the caller is a member of the specified roleId.\n', '     */\n', '    modifier onlyRoleHolder(uint256 roleId) {\n', '        require(holdsRole(roleId, msg.sender), "Sender does not hold required role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n', '     */\n', '    modifier onlyRoleManager(uint256 roleId) {\n', '        require(holdsRole(roles[roleId].managingRole, msg.sender), "Can only be called by a role manager");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n', '     */\n', '    modifier onlyExclusive(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Exclusive, "Must be called on an initialized Exclusive role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n', '     */\n', '    modifier onlyShared(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Shared, "Must be called on an initialized Shared role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Whether `memberToCheck` is a member of roleId.\n', '     * @dev Reverts if roleId does not correspond to an initialized role.\n', '     * @param roleId the Role to check.\n', '     * @param memberToCheck the address to check.\n', '     * @return True if `memberToCheck` is a member of `roleId`.\n', '     */\n', '    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n', '        Role storage role = roles[roleId];\n', '        if (role.roleType == RoleType.Exclusive) {\n', '            return role.exclusiveRoleMembership.isMember(memberToCheck);\n', '        } else if (role.roleType == RoleType.Shared) {\n', '            return role.sharedRoleMembership.isMember(memberToCheck);\n', '        }\n', '        revert("Invalid roleId");\n', '    }\n', '\n', '    /**\n', '     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n', '     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n', '     * initialized, ExclusiveRole.\n', '     * @param roleId the ExclusiveRole membership to modify.\n', '     * @param newMember the new ExclusiveRole member.\n', '     */\n', '    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n', '        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current holder of the exclusive role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n', '     * @param roleId the ExclusiveRole membership to check.\n', '     * @return the address of the current ExclusiveRole member.\n', '     */\n', '    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n', '        return roles[roleId].exclusiveRoleMembership.getMember();\n', '    }\n', '\n', '    /**\n', '     * @notice Adds `newMember` to the shared role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n', '     * managing role for `roleId`.\n', '     * @param roleId the SharedRole membership to modify.\n', '     * @param newMember the new SharedRole member.\n', '     */\n', '    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].sharedRoleMembership.addMember(newMember);\n', '        emit AddedSharedMember(roleId, newMember, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n', '     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n', '     * managing role for `roleId`.\n', '     * @param roleId the SharedRole membership to modify.\n', '     * @param memberToRemove the current SharedRole member to remove.\n', '     */\n', '    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n', '        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n', '        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes caller from the role, `roleId`.\n', '     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n', '     * initialized, SharedRole.\n', '     * @param roleId the SharedRole membership to modify.\n', '     */\n', '    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n', '        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n', '        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if `roleId` is not initialized.\n', '     */\n', '    modifier onlyValidRole(uint256 roleId) {\n', '        require(roles[roleId].roleType != RoleType.Invalid, "Attempted to use an invalid roleId");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if `roleId` is initialized.\n', '     */\n', '    modifier onlyInvalidRole(uint256 roleId) {\n', '        require(roles[roleId].roleType == RoleType.Invalid, "Cannot use a pre-existing role");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n', '     * `initialMembers` will be immediately added to the role.\n', '     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n', '     * initialized.\n', '     */\n', '    function _createSharedRole(\n', '        uint256 roleId,\n', '        uint256 managingRoleId,\n', '        address[] memory initialMembers\n', '    ) internal onlyInvalidRole(roleId) {\n', '        Role storage role = roles[roleId];\n', '        role.roleType = RoleType.Shared;\n', '        role.managingRole = managingRoleId;\n', '        role.sharedRoleMembership.init(initialMembers);\n', '        require(\n', '            roles[managingRoleId].roleType != RoleType.Invalid,\n', '            "Attempted to use an invalid role to manage a shared role"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n', '     * `initialMember` will be immediately added to the role.\n', '     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n', '     * initialized.\n', '     */\n', '    function _createExclusiveRole(\n', '        uint256 roleId,\n', '        uint256 managingRoleId,\n', '        address initialMember\n', '    ) internal onlyInvalidRole(roleId) {\n', '        Role storage role = roles[roleId];\n', '        role.roleType = RoleType.Exclusive;\n', '        role.managingRole = managingRoleId;\n', '        role.exclusiveRoleMembership.init(initialMember);\n', '        require(\n', '            roles[managingRoleId].roleType != RoleType.Invalid,\n', '            "Attempted to use an invalid role to manage an exclusive role"\n', '        );\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./Timer.sol";\n', '\n', '/**\n', ' * @title Base class that provides time overrides, but only if being run in test mode.\n', ' */\n', 'abstract contract Testable {\n', '    // If the contract is being run on the test network, then `timerAddress` will be the 0x0 address.\n', '    // Note: this variable should be set on construction and never modified.\n', '    address public timerAddress;\n', '\n', '    /**\n', '     * @notice Constructs the Testable contract. Called by child contracts.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(address _timerAddress) internal {\n', '        timerAddress = _timerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if not running in test mode.\n', '     */\n', '    modifier onlyIfTest {\n', '        require(timerAddress != address(0x0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set current Testable time to.\n', '     */\n', '    function setCurrentTime(uint256 time) external onlyIfTest {\n', '        Timer(timerAddress).setCurrentTime(time);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        if (timerAddress != address(0x0)) {\n', '            return Timer(timerAddress).getCurrentTime();\n', '        } else {\n', '            return now; // solhint-disable-line not-rely-on-time\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title Universal store of current contract time for testing environments.\n', ' */\n', 'contract Timer {\n', '    uint256 private currentTime;\n', '\n', '    constructor() public {\n', '        currentTime = now; // solhint-disable-line not-rely-on-time\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set `currentTime` to.\n', '     */\n', '    function setCurrentTime(uint256 time) external {\n', '        currentTime = time;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint256 for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        return currentTime;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', '/**\n', ' * @title ERC20 interface that includes burn and mint methods.\n', ' */\n', 'abstract contract ExpandedIERC20 is IERC20 {\n', '    /**\n', "     * @notice Burns a specific amount of the caller's tokens.\n", "     * @dev Only burns the caller's tokens, so it is safe to leave this method permissionless.\n", '     */\n', '    function burn(uint256 value) external virtual;\n', '\n', '    /**\n', '     * @notice Mints tokens and adds them to the balance of the `to` address.\n', '     * @dev This method should be permissioned to only allow designated parties to mint tokens.\n', '     */\n', '    function mint(address to, uint256 value) external virtual returns (bool);\n', '\n', '    function addMinter(address account) external virtual;\n', '\n', '    function addBurner(address account) external virtual;\n', '\n', '    function resetOwner(address account) external virtual;\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', '/**\n', ' * @title ERC20 interface that includes the decimals read only method.\n', ' */\n', 'interface IERC20Standard is IERC20 {\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05`\n', '     * (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value\n', '     * {ERC20} uses, unless {_setupDecimals} is called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic\n', '     * of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '/**\n', ' * @title EmergencyShutdownable contract.\n', ' * @notice Any contract that inherits this contract will have an emergency shutdown timestamp state variable.\n', ' * This contract provides modifiers that can be used by children contracts to determine if the contract is\n', ' * in the shutdown state. The child contract is expected to implement the logic that happens\n', ' * once a shutdown occurs.\n', ' */\n', '\n', 'abstract contract EmergencyShutdownable {\n', '    using SafeMath for uint256;\n', '\n', '    /****************************************\n', '     * EMERGENCY SHUTDOWN DATA STRUCTURES *\n', '     ****************************************/\n', '\n', '    // Timestamp used in case of emergency shutdown. 0 if no shutdown has been triggered.\n', '    uint256 public emergencyShutdownTimestamp;\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    modifier notEmergencyShutdown() {\n', '        _notEmergencyShutdown();\n', '        _;\n', '    }\n', '\n', '    modifier isEmergencyShutdown() {\n', '        _isEmergencyShutdown();\n', '        _;\n', '    }\n', '\n', '    /****************************************\n', '     *          EXTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    constructor() public {\n', '        emergencyShutdownTimestamp = 0;\n', '    }\n', '\n', '    /****************************************\n', '     *          INTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    function _notEmergencyShutdown() internal view {\n', '        // Note: removed require string to save bytecode.\n', '        require(emergencyShutdownTimestamp == 0);\n', '    }\n', '\n', '    function _isEmergencyShutdown() internal view {\n', '        // Note: removed require string to save bytecode.\n', '        require(emergencyShutdownTimestamp != 0);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', '\n', 'import "../../common/implementation/Lockable.sol";\n', 'import "../../common/implementation/FixedPoint.sol";\n', 'import "../../common/implementation/Testable.sol";\n', '\n', 'import "../../oracle/interfaces/StoreInterface.sol";\n', 'import "../../oracle/interfaces/FinderInterface.sol";\n', 'import "../../oracle/interfaces/AdministrateeInterface.sol";\n', 'import "../../oracle/implementation/Constants.sol";\n', '\n', '/**\n', ' * @title FeePayer contract.\n', ' * @notice Provides fee payment functionality for the ExpiringMultiParty contract.\n', ' * contract is abstract as each derived contract that inherits `FeePayer` must implement `pfc()`.\n', ' */\n', '\n', 'abstract contract FeePayer is AdministrateeInterface, Testable, Lockable {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /****************************************\n', '     *      FEE PAYER DATA STRUCTURES       *\n', '     ****************************************/\n', '\n', '    // The collateral currency used to back the positions in this contract.\n', '    IERC20 public collateralCurrency;\n', '\n', '    // Finder contract used to look up addresses for UMA system contracts.\n', '    FinderInterface public finder;\n', '\n', '    // Tracks the last block time when the fees were paid.\n', '    uint256 private lastPaymentTime;\n', '\n', '    // Tracks the cumulative fees that have been paid by the contract for use by derived contracts.\n', '    // The multiplier starts at 1, and is updated by computing cumulativeFeeMultiplier * (1 - effectiveFee).\n', '    // Put another way, the cumulativeFeeMultiplier is (1 - effectiveFee1) * (1 - effectiveFee2) ...\n', '    // For example:\n', '    // The cumulativeFeeMultiplier should start at 1.\n', '    // If a 1% fee is charged, the multiplier should update to .99.\n', '    // If another 1% fee is charged, the multiplier should be 0.99^2 (0.9801).\n', '    FixedPoint.Unsigned public cumulativeFeeMultiplier;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event RegularFeesPaid(uint256 indexed regularFee, uint256 indexed lateFee);\n', '    event FinalFeesPaid(uint256 indexed amount);\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    // modifier that calls payRegularFees().\n', '    modifier fees virtual {\n', '        // Note: the regular fee is applied on every fee-accruing transaction, where the total change is simply the\n', '        // regular fee applied linearly since the last update. This implies that the compounding rate depends on the\n', '        // frequency of update transactions that have this modifier, and it never reaches the ideal of continuous\n', '        // compounding. This approximate-compounding pattern is common in the Ethereum ecosystem because of the\n', '        // complexity of compounding data on-chain.\n', '        payRegularFees();\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the FeePayer contract. Called by child contracts.\n', '     * @param _collateralAddress ERC20 token that is used as the underlying collateral for the synthetic.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(\n', '        address _collateralAddress,\n', '        address _finderAddress,\n', '        address _timerAddress\n', '    ) public Testable(_timerAddress) {\n', '        collateralCurrency = IERC20(_collateralAddress);\n', '        finder = FinderInterface(_finderAddress);\n', '        lastPaymentTime = getCurrentTime();\n', '        cumulativeFeeMultiplier = FixedPoint.fromUnscaledUint(1);\n', '    }\n', '\n', '    /****************************************\n', '     *        FEE PAYMENT FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Pays UMA DVM regular fees (as a % of the collateral pool) to the Store contract.\n', '     * @dev These must be paid periodically for the life of the contract. If the contract has not paid its regular fee\n', '     * in a week or more then a late penalty is applied which is sent to the caller. If the amount of\n', '     * fees owed are greater than the pfc, then this will pay as much as possible from the available collateral.\n', '     * An event is only fired if the fees charged are greater than 0.\n', '     * @return totalPaid Amount of collateral that the contract paid (sum of the amount paid to the Store and caller).\n', '     * This returns 0 and exit early if there is no pfc, fees were already paid during the current block, or the fee rate is 0.\n', '     */\n', '    function payRegularFees() public nonReentrant() returns (FixedPoint.Unsigned memory totalPaid) {\n', '        StoreInterface store = _getStore();\n', '        uint256 time = getCurrentTime();\n', '        FixedPoint.Unsigned memory collateralPool = _pfc();\n', '\n', '        // Exit early if there is no collateral from which to pay fees.\n', '        if (collateralPool.isEqual(0)) {\n', '            // Note: set the lastPaymentTime in this case so the contract is credited for paying during periods when it\n', '            // has no locked collateral.\n', '            lastPaymentTime = time;\n', '            return totalPaid;\n', '        }\n', '\n', '        // Exit early if fees were already paid during this block.\n', '        if (lastPaymentTime == time) {\n', '            return totalPaid;\n', '        }\n', '\n', '        (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty) =\n', '            store.computeRegularFee(lastPaymentTime, time, collateralPool);\n', '        lastPaymentTime = time;\n', '\n', '        totalPaid = regularFee.add(latePenalty);\n', '        if (totalPaid.isEqual(0)) {\n', '            return totalPaid;\n', '        }\n', '        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\n', "        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\n", '        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\n', '        if (totalPaid.isGreaterThan(collateralPool)) {\n', '            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\n', '            FixedPoint.Unsigned memory latePenaltyReduction = FixedPoint.min(latePenalty, deficit);\n', '            latePenalty = latePenalty.sub(latePenaltyReduction);\n', '            deficit = deficit.sub(latePenaltyReduction);\n', '            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\n', '            totalPaid = collateralPool;\n', '        }\n', '\n', '        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n', '\n', '        _adjustCumulativeFeeMultiplier(totalPaid, collateralPool);\n', '\n', '        if (regularFee.isGreaterThan(0)) {\n', '            collateralCurrency.safeIncreaseAllowance(address(store), regularFee.rawValue);\n', '            store.payOracleFeesErc20(address(collateralCurrency), regularFee);\n', '        }\n', '\n', '        if (latePenalty.isGreaterThan(0)) {\n', '            collateralCurrency.safeTransfer(msg.sender, latePenalty.rawValue);\n', '        }\n', '        return totalPaid;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n', '     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\n', '     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\n', '     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\n', '     */\n', '    function pfc() external view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\n', '        return _pfc();\n', '    }\n', '\n', '    /**\n', '     * @notice Removes excess collateral balance not counted in the PfC by distributing it out pro-rata to all sponsors.\n', '     * @dev Multiplying the `cumulativeFeeMultiplier` by the ratio of non-PfC-collateral :: PfC-collateral effectively\n', '     * pays all sponsors a pro-rata portion of the excess collateral.\n', "     * @dev This will revert if PfC is 0 and this contract's collateral balance > 0.\n", '     */\n', '    function gulp() external nonReentrant() {\n', '        _gulp();\n', '    }\n', '\n', '    /****************************************\n', '     *         INTERNAL FUNCTIONS           *\n', '     ****************************************/\n', '\n', '    // Pays UMA Oracle final fees of `amount` in `collateralCurrency` to the Store contract. Final fee is a flat fee\n', '    // charged for each price request. If payer is the contract, adjusts internal bookkeeping variables. If payer is not\n', '    // the contract, pulls in `amount` of collateral currency.\n', '    function _payFinalFees(address payer, FixedPoint.Unsigned memory amount) internal {\n', '        if (amount.isEqual(0)) {\n', '            return;\n', '        }\n', '\n', '        if (payer != address(this)) {\n', '            // If the payer is not the contract pull the collateral from the payer.\n', '            collateralCurrency.safeTransferFrom(payer, address(this), amount.rawValue);\n', '        } else {\n', '            // If the payer is the contract, adjust the cumulativeFeeMultiplier to compensate.\n', '            FixedPoint.Unsigned memory collateralPool = _pfc();\n', '\n', '            // The final fee must be < available collateral or the fee will be larger than 100%.\n', '            // Note: revert reason removed to save bytecode.\n', '            require(collateralPool.isGreaterThan(amount));\n', '\n', '            _adjustCumulativeFeeMultiplier(amount, collateralPool);\n', '        }\n', '\n', '        emit FinalFeesPaid(amount.rawValue);\n', '\n', '        StoreInterface store = _getStore();\n', '        collateralCurrency.safeIncreaseAllowance(address(store), amount.rawValue);\n', '        store.payOracleFeesErc20(address(collateralCurrency), amount);\n', '    }\n', '\n', '    function _gulp() internal {\n', '        FixedPoint.Unsigned memory currentPfc = _pfc();\n', '        FixedPoint.Unsigned memory currentBalance = FixedPoint.Unsigned(collateralCurrency.balanceOf(address(this)));\n', '        if (currentPfc.isLessThan(currentBalance)) {\n', '            cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(currentBalance.div(currentPfc));\n', '        }\n', '    }\n', '\n', '    function _pfc() internal view virtual returns (FixedPoint.Unsigned memory);\n', '\n', '    function _getStore() internal view returns (StoreInterface) {\n', '        return StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\n', '    }\n', '\n', '    function _computeFinalFees() internal view returns (FixedPoint.Unsigned memory finalFees) {\n', '        StoreInterface store = _getStore();\n', '        return store.computeFinalFee(address(collateralCurrency));\n', '    }\n', '\n', "    // Returns the user's collateral minus any fees that have been subtracted since it was originally\n", '    // deposited into the contract. Note: if the contract has paid fees since it was deployed, the raw\n', '    // value should be larger than the returned value.\n', '    function _getFeeAdjustedCollateral(FixedPoint.Unsigned memory rawCollateral)\n', '        internal\n', '        view\n', '        returns (FixedPoint.Unsigned memory collateral)\n', '    {\n', '        return rawCollateral.mul(cumulativeFeeMultiplier);\n', '    }\n', '\n', '    // Converts a user-readable collateral value into a raw value that accounts for already-assessed fees. If any fees\n', '    // have been taken from this contract in the past, then the raw value will be larger than the user-readable value.\n', '    function _convertToRawCollateral(FixedPoint.Unsigned memory collateral)\n', '        internal\n', '        view\n', '        returns (FixedPoint.Unsigned memory rawCollateral)\n', '    {\n', '        return collateral.div(cumulativeFeeMultiplier);\n', '    }\n', '\n', '    // Decrease rawCollateral by a fee-adjusted collateralToRemove amount. Fee adjustment scales up collateralToRemove\n', '    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\n', '    // rawCollateral is decreased by less than expected. Because this method is usually called in conjunction with an\n', '    // actual removal of collateral from this contract, return the fee-adjusted amount that the rawCollateral is\n', '    // decreased by so that the caller can minimize error between collateral removed and rawCollateral debited.\n', '    function _removeCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToRemove)\n', '        internal\n', '        returns (FixedPoint.Unsigned memory removedCollateral)\n', '    {\n', '        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\n', '        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToRemove);\n', '        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n', '        removedCollateral = initialBalance.sub(_getFeeAdjustedCollateral(rawCollateral));\n', '    }\n', '\n', '    // Increase rawCollateral by a fee-adjusted collateralToAdd amount. Fee adjustment scales up collateralToAdd\n', '    // by dividing it by cumulativeFeeMultiplier. There is potential for this quotient to be floored, therefore\n', '    // rawCollateral is increased by less than expected. Because this method is usually called in conjunction with an\n', '    // actual addition of collateral to this contract, return the fee-adjusted amount that the rawCollateral is\n', '    // increased by so that the caller can minimize error between collateral added and rawCollateral credited.\n', "    // NOTE: This return value exists only for the sake of symmetry with _removeCollateral. We don't actually use it\n", '    // because we are OK if more collateral is stored in the contract than is represented by rawTotalPositionCollateral.\n', '    function _addCollateral(FixedPoint.Unsigned storage rawCollateral, FixedPoint.Unsigned memory collateralToAdd)\n', '        internal\n', '        returns (FixedPoint.Unsigned memory addedCollateral)\n', '    {\n', '        FixedPoint.Unsigned memory initialBalance = _getFeeAdjustedCollateral(rawCollateral);\n', '        FixedPoint.Unsigned memory adjustedCollateral = _convertToRawCollateral(collateralToAdd);\n', '        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n', '        addedCollateral = _getFeeAdjustedCollateral(rawCollateral).sub(initialBalance);\n', '    }\n', '\n', '    // Scale the cumulativeFeeMultiplier by the ratio of fees paid to the current available collateral.\n', '    function _adjustCumulativeFeeMultiplier(FixedPoint.Unsigned memory amount, FixedPoint.Unsigned memory currentPfc)\n', '        internal\n', '    {\n', '        FixedPoint.Unsigned memory effectiveFee = amount.divCeil(currentPfc);\n', '        cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee));\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/utils/SafeCast.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', '\n', 'import "../../common/implementation/Lockable.sol";\n', 'import "../../common/implementation/FixedPoint.sol";\n', 'import "../../common/implementation/Testable.sol";\n', '\n', 'import "../../oracle/implementation/Constants.sol";\n', 'import "../../oracle/interfaces/OptimisticOracleInterface.sol";\n', 'import "../perpetual-multiparty/ConfigStoreInterface.sol";\n', '\n', 'import "./EmergencyShutdownable.sol";\n', 'import "./FeePayer.sol";\n', '\n', '/**\n', ' * @title FundingRateApplier contract.\n', ' * @notice Provides funding rate payment functionality for the Perpetual contract.\n', ' */\n', '\n', 'abstract contract FundingRateApplier is EmergencyShutdownable, FeePayer {\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using FixedPoint for FixedPoint.Signed;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    /****************************************\n', '     * FUNDING RATE APPLIER DATA STRUCTURES *\n', '     ****************************************/\n', '\n', '    struct FundingRate {\n', '        // Current funding rate value.\n', '        FixedPoint.Signed rate;\n', '        // Identifier to retrieve the funding rate.\n', '        bytes32 identifier;\n', '        // Tracks the cumulative funding payments that have been paid to the sponsors.\n', '        // The multiplier starts at 1, and is updated by computing cumulativeFundingRateMultiplier * (1 + effectivePayment).\n', '        // Put another way, the cumulativeFeeMultiplier is (1 + effectivePayment1) * (1 + effectivePayment2) ...\n', '        // For example:\n', '        // The cumulativeFundingRateMultiplier should start at 1.\n', '        // If a 1% funding payment is paid to sponsors, the multiplier should update to 1.01.\n', '        // If another 1% fee is charged, the multiplier should be 1.01^2 (1.0201).\n', '        FixedPoint.Unsigned cumulativeMultiplier;\n', '        // Most recent time that the funding rate was updated.\n', '        uint256 updateTime;\n', '        // Most recent time that the funding rate was applied and changed the cumulative multiplier.\n', '        uint256 applicationTime;\n', '        // The time for the active (if it exists) funding rate proposal. 0 otherwise.\n', '        uint256 proposalTime;\n', '    }\n', '\n', '    FundingRate public fundingRate;\n', '\n', '    // Remote config store managed an owner.\n', '    ConfigStoreInterface public configStore;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event FundingRateUpdated(int256 newFundingRate, uint256 indexed updateTime, uint256 reward);\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    // This is overridden to both pay fees (which is done by applyFundingRate()) and apply the funding rate.\n', '    modifier fees override {\n', '        // Note: the funding rate is applied on every fee-accruing transaction, where the total change is simply the\n', '        // rate applied linearly since the last update. This implies that the compounding rate depends on the frequency\n', '        // of update transactions that have this modifier, and it never reaches the ideal of continuous compounding.\n', '        // This approximate-compounding pattern is common in the Ethereum ecosystem because of the complexity of\n', '        // compounding data on-chain.\n', '        applyFundingRate();\n', '        _;\n', '    }\n', '\n', '    // Note: this modifier is intended to be used if the caller intends to _only_ pay regular fees.\n', '    modifier regularFees {\n', '        payRegularFees();\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the FundingRateApplier contract. Called by child contracts.\n', '     * @param _fundingRateIdentifier identifier that tracks the funding rate of this contract.\n', '     * @param _collateralAddress address of the collateral token.\n', '     * @param _finderAddress Finder used to discover financial-product-related contracts.\n', '     * @param _configStoreAddress address of the remote configuration store managed by an external owner.\n', '     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\n', '     * @param _timerAddress address of the timer contract in test envs, otherwise 0x0.\n', '     */\n', '    constructor(\n', '        bytes32 _fundingRateIdentifier,\n', '        address _collateralAddress,\n', '        address _finderAddress,\n', '        address _configStoreAddress,\n', '        FixedPoint.Unsigned memory _tokenScaling,\n', '        address _timerAddress\n', '    ) public FeePayer(_collateralAddress, _finderAddress, _timerAddress) EmergencyShutdownable() {\n', '        uint256 currentTime = getCurrentTime();\n', '        fundingRate.updateTime = currentTime;\n', '        fundingRate.applicationTime = currentTime;\n', '\n', '        // Seed the cumulative multiplier with the token scaling, from which it will be scaled as funding rates are\n', '        // applied over time.\n', '        fundingRate.cumulativeMultiplier = _tokenScaling;\n', '\n', '        fundingRate.identifier = _fundingRateIdentifier;\n', '        configStore = ConfigStoreInterface(_configStoreAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice This method takes 3 distinct actions:\n', '     * 1. Pays out regular fees.\n', '     * 2. If possible, resolves the outstanding funding rate proposal, pulling the result in and paying out the rewards.\n', '     * 3. Applies the prevailing funding rate over the most recent period.\n', '     */\n', '    function applyFundingRate() public regularFees() nonReentrant() {\n', '        _applyEffectiveFundingRate();\n', '    }\n', '\n', '    /**\n', '     * @notice Proposes a new funding rate. Proposer receives a reward if correct.\n', '     * @param rate funding rate being proposed.\n', '     * @param timestamp time at which the funding rate was computed.\n', '     */\n', '    function proposeNewRate(FixedPoint.Signed memory rate, uint256 timestamp)\n', '        external\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory totalBond)\n', '    {\n', '        require(fundingRate.proposalTime == 0, "Proposal in progress");\n', '        _validateFundingRate(rate);\n', '\n', '        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n', '        uint256 currentTime = getCurrentTime();\n', '        uint256 updateTime = fundingRate.updateTime;\n', '        require(\n', '            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n', '            "Invalid proposal time"\n', '        );\n', '\n', '        // Set the proposal time in order to allow this contract to track this request.\n', '        fundingRate.proposalTime = timestamp;\n', '\n', '        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n', '\n', '        // Set up optimistic oracle.\n', '        bytes32 identifier = fundingRate.identifier;\n', '        bytes memory ancillaryData = _getAncillaryData();\n', '        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n', '        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n', '        totalBond = FixedPoint.Unsigned(\n', '            optimisticOracle.setBond(\n', '                identifier,\n', '                timestamp,\n', '                ancillaryData,\n', '                _pfc().mul(_getConfig().proposerBondPct).rawValue\n', '            )\n', '        );\n', '\n', '        // Pull bond from caller and send to optimistic oracle.\n', '        if (totalBond.isGreaterThan(0)) {\n', '            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n', '            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n', '        }\n', '\n', '        optimisticOracle.proposePriceFor(\n', '            msg.sender,\n', '            address(this),\n', '            identifier,\n', '            timestamp,\n', '            ancillaryData,\n', '            rate.rawValue\n', '        );\n', '    }\n', '\n', '    // Returns a token amount scaled by the current funding rate multiplier.\n', '    // Note: if the contract has paid fees since it was deployed, the raw value should be larger than the returned value.\n', '    function _getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\n', '        internal\n', '        view\n', '        returns (FixedPoint.Unsigned memory tokenDebt)\n', '    {\n', '        return rawTokenDebt.mul(fundingRate.cumulativeMultiplier);\n', '    }\n', '\n', '    function _getOptimisticOracle() internal view returns (OptimisticOracleInterface) {\n', '        return OptimisticOracleInterface(finder.getImplementationAddress(OracleInterfaces.OptimisticOracle));\n', '    }\n', '\n', '    function _getConfig() internal returns (ConfigStoreInterface.ConfigSettings memory) {\n', '        return configStore.updateAndGetCurrentConfig();\n', '    }\n', '\n', '    function _getLatestFundingRate() internal returns (FixedPoint.Signed memory) {\n', '        uint256 proposalTime = fundingRate.proposalTime;\n', '\n', '        // If there is no pending proposal then return the current funding rate, otherwise\n', '        // check to see if we can update the funding rate.\n', '        if (proposalTime != 0) {\n', '            // Attempt to update the funding rate.\n', '            OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n', '            bytes32 identifier = fundingRate.identifier;\n', '            bytes memory ancillaryData = _getAncillaryData();\n', '\n', '            // Try to get the price from the optimistic oracle. This call will revert if the request has not resolved\n', '            // yet. If the request has not resolved yet, then we need to do additional checks to see if we should\n', '            // "forget" the pending proposal and allow new proposals to update the funding rate.\n', '            try optimisticOracle.getPrice(identifier, proposalTime, ancillaryData) returns (int256 price) {\n', '                // If successful, determine if the funding rate state needs to be updated.\n', '                // If the request is more recent than the last update then we should update it.\n', '                uint256 lastUpdateTime = fundingRate.updateTime;\n', '                if (proposalTime >= lastUpdateTime) {\n', '                    // Update funding rates\n', '                    fundingRate.rate = FixedPoint.Signed(price);\n', '                    fundingRate.updateTime = proposalTime;\n', '\n', '                    // If there was no dispute, send a reward.\n', '                    FixedPoint.Unsigned memory reward = FixedPoint.fromUnscaledUint(0);\n', '                    OptimisticOracleInterface.Request memory request =\n', '                        optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData);\n', '                    if (request.disputer == address(0)) {\n', '                        reward = _pfc().mul(_getConfig().rewardRatePerSecond).mul(proposalTime.sub(lastUpdateTime));\n', '                        if (reward.isGreaterThan(0)) {\n', '                            _adjustCumulativeFeeMultiplier(reward, _pfc());\n', '                            collateralCurrency.safeTransfer(request.proposer, reward.rawValue);\n', '                        }\n', '                    }\n', '\n', '                    // This event will only be emitted after the fundingRate struct\'s "updateTime" has been set\n', "                    // to the latest proposal's proposalTime, indicating that the proposal has been published.\n", '                    // So, it suffices to just emit fundingRate.updateTime here.\n', '                    emit FundingRateUpdated(fundingRate.rate.rawValue, fundingRate.updateTime, reward.rawValue);\n', '                }\n', '\n', '                // Set proposal time to 0 since this proposal has now been resolved.\n', '                fundingRate.proposalTime = 0;\n', '            } catch {\n', '                // Stop tracking and allow other proposals to come in if:\n', '                // - The requester address is empty, indicating that the Oracle does not know about this funding rate\n', '                //   request. This is possible if the Oracle is replaced while the price request is still pending.\n', '                // - The request has been disputed.\n', '                OptimisticOracleInterface.Request memory request =\n', '                    optimisticOracle.getRequest(address(this), identifier, proposalTime, ancillaryData);\n', '                if (request.disputer != address(0) || request.proposer == address(0)) {\n', '                    fundingRate.proposalTime = 0;\n', '                }\n', '            }\n', '        }\n', '        return fundingRate.rate;\n', '    }\n', '\n', '    // Constraining the range of funding rates limits the PfC for any dishonest proposer and enhances the\n', "    // perpetual's security. For example, let's examine the case where the max and min funding rates\n", '    // are equivalent to +/- 500%/year. This 1000% funding rate range allows a 8.6% profit from corruption for a\n', '    // proposer who can deter honest proposers for 74 hours:\n', '    // 1000%/year / 360 days / 24 hours * 74 hours max attack time = ~ 8.6%.\n', '    // How would attack work? Imagine that the market is very volatile currently and that the "true" funding\n', '    // rate for the next 74 hours is -500%, but a dishonest proposer successfully proposes a rate of +500%\n', '    // (after a two hour liveness) and disputes honest proposers for the next 72 hours. This results in a funding\n', '    // rate error of 1000% for 74 hours, until the DVM can set the funding rate back to its correct value.\n', '    function _validateFundingRate(FixedPoint.Signed memory rate) internal {\n', '        require(\n', '            rate.isLessThanOrEqual(_getConfig().maxFundingRate) &&\n', '                rate.isGreaterThanOrEqual(_getConfig().minFundingRate)\n', '        );\n', '    }\n', '\n', '    // Fetches a funding rate from the Store, determines the period over which to compute an effective fee,\n', '    // and multiplies the current multiplier by the effective fee.\n', '    // A funding rate < 1 will reduce the multiplier, and a funding rate of > 1 will increase the multiplier.\n', '    // Note: 1 is set as the neutral rate because there are no negative numbers in FixedPoint, so we decide to treat\n', '    // values < 1 as "negative".\n', '    function _applyEffectiveFundingRate() internal {\n', '        // If contract is emergency shutdown, then the funding rate multiplier should no longer change.\n', '        if (emergencyShutdownTimestamp != 0) {\n', '            return;\n', '        }\n', '\n', '        uint256 currentTime = getCurrentTime();\n', '        uint256 paymentPeriod = currentTime.sub(fundingRate.applicationTime);\n', '\n', '        fundingRate.cumulativeMultiplier = _calculateEffectiveFundingRate(\n', '            paymentPeriod,\n', '            _getLatestFundingRate(),\n', '            fundingRate.cumulativeMultiplier\n', '        );\n', '\n', '        fundingRate.applicationTime = currentTime;\n', '    }\n', '\n', '    function _calculateEffectiveFundingRate(\n', '        uint256 paymentPeriodSeconds,\n', '        FixedPoint.Signed memory fundingRatePerSecond,\n', '        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\n', '    ) internal pure returns (FixedPoint.Unsigned memory newCumulativeFundingRateMultiplier) {\n', '        // Note: this method uses named return variables to save a little bytecode.\n', '\n', '        // The overall formula that this function is performing:\n', '        //   newCumulativeFundingRateMultiplier =\n', '        //   (1 + (fundingRatePerSecond * paymentPeriodSeconds)) * currentCumulativeFundingRateMultiplier.\n', '        FixedPoint.Signed memory ONE = FixedPoint.fromUnscaledInt(1);\n', '\n', '        // Multiply the per-second rate over the number of seconds that have elapsed to get the period rate.\n', '        FixedPoint.Signed memory periodRate = fundingRatePerSecond.mul(SafeCast.toInt256(paymentPeriodSeconds));\n', '\n', '        // Add one to create the multiplier to scale the existing fee multiplier.\n', '        FixedPoint.Signed memory signedPeriodMultiplier = ONE.add(periodRate);\n', '\n', "        // Max with 0 to ensure the multiplier isn't negative, then cast to an Unsigned.\n", '        FixedPoint.Unsigned memory unsignedPeriodMultiplier =\n', '            FixedPoint.fromSigned(FixedPoint.max(signedPeriodMultiplier, FixedPoint.fromUnscaledInt(0)));\n', '\n', '        // Multiply the existing cumulative funding rate multiplier by the computed period multiplier to get the new\n', '        // cumulative funding rate multiplier.\n', '        newCumulativeFundingRateMultiplier = currentCumulativeFundingRateMultiplier.mul(unsignedPeriodMultiplier);\n', '    }\n', '\n', '    function _getAncillaryData() internal view returns (bytes memory) {\n', '        // Note: when ancillary data is passed to the optimistic oracle, it should be tagged with the token address\n', "        // whose funding rate it's trying to get.\n", '        return abi.encodePacked(_getTokenAddress());\n', '    }\n', '\n', '    function _getTokenAddress() internal view virtual returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'import "../../common/implementation/ExpandedERC20.sol";\n', 'import "../../common/implementation/Lockable.sol";\n', '\n', '/**\n', ' * @title Burnable and mintable ERC20.\n', ' * @dev The contract deployer will initially be the only minter, burner and owner capable of adding new roles.\n', ' */\n', '\n', 'contract SyntheticToken is ExpandedERC20, Lockable {\n', '    /**\n', '     * @notice Constructs the SyntheticToken.\n', '     * @param tokenName The name which describes the new token.\n', '     * @param tokenSymbol The ticker abbreviation of the name. Ideally < 5 chars.\n', '     * @param tokenDecimals The number of decimals to define token precision.\n', '     */\n', '    constructor(\n', '        string memory tokenName,\n', '        string memory tokenSymbol,\n', '        uint8 tokenDecimals\n', '    ) public ExpandedERC20(tokenName, tokenSymbol, tokenDecimals) nonReentrant() {}\n', '\n', '    /**\n', '     * @notice Add Minter role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Minter role is added.\n', '     */\n', '    function addMinter(address account) external override nonReentrant() {\n', '        addMember(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Remove Minter role from account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address from which the Minter role is removed.\n', '     */\n', '    function removeMinter(address account) external nonReentrant() {\n', '        removeMember(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Add Burner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address to which the Burner role is added.\n', '     */\n', '    function addBurner(address account) external override nonReentrant() {\n', '        addMember(uint256(Roles.Burner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes Burner role from account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The address from which the Burner role is removed.\n', '     */\n', '    function removeBurner(address account) external nonReentrant() {\n', '        removeMember(uint256(Roles.Burner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Reset Owner role to account.\n', '     * @dev The caller must have the Owner role.\n', '     * @param account The new holder of the Owner role.\n', '     */\n', '    function resetOwner(address account) external override nonReentrant() {\n', '        resetMember(uint256(Roles.Owner), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a given account holds the Minter role.\n', '     * @param account The address which is checked for the Minter role.\n', '     * @return bool True if the provided account is a Minter.\n', '     */\n', '    function isMinter(address account) public view nonReentrantView() returns (bool) {\n', '        return holdsRole(uint256(Roles.Minter), account);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if a given account holds the Burner role.\n', '     * @param account The address which is checked for the Burner role.\n', '     * @return bool True if the provided account is a Burner.\n', '     */\n', '    function isBurner(address account) public view nonReentrantView() returns (bool) {\n', '        return holdsRole(uint256(Roles.Burner), account);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./SyntheticToken.sol";\n', 'import "../../common/interfaces/ExpandedIERC20.sol";\n', 'import "../../common/implementation/Lockable.sol";\n', '\n', '/**\n', ' * @title Factory for creating new mintable and burnable tokens.\n', ' */\n', '\n', 'contract TokenFactory is Lockable {\n', '    /**\n', '     * @notice Create a new token and return it to the caller.\n', '     * @dev The caller will become the only minter and burner and the new owner capable of assigning the roles.\n', '     * @param tokenName used to describe the new token.\n', '     * @param tokenSymbol short ticker abbreviation of the name. Ideally < 5 chars.\n', "     * @param tokenDecimals used to define the precision used in the token's numerical representation.\n", '     * @return newToken an instance of the newly created token interface.\n', '     */\n', '    function createToken(\n', '        string calldata tokenName,\n', '        string calldata tokenSymbol,\n', '        uint8 tokenDecimals\n', '    ) external nonReentrant() returns (ExpandedIERC20 newToken) {\n', '        SyntheticToken mintableToken = new SyntheticToken(tokenName, tokenSymbol, tokenDecimals);\n', '        mintableToken.addMinter(msg.sender);\n', '        mintableToken.addBurner(msg.sender);\n', '        mintableToken.resetOwner(msg.sender);\n', '        newToken = ExpandedIERC20(address(mintableToken));\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "@openzeppelin/contracts/access/Ownable.sol";\n', '\n', 'import "./ConfigStoreInterface.sol";\n', 'import "../../common/implementation/Testable.sol";\n', 'import "../../common/implementation/Lockable.sol";\n', 'import "../../common/implementation/FixedPoint.sol";\n', '\n', '/**\n', ' * @notice ConfigStore stores configuration settings for a perpetual contract and provides an interface for it\n', ' * to query settings such as reward rates, proposal bond sizes, etc. The configuration settings can be upgraded\n', ' * by a privileged account and the upgraded changes are timelocked.\n', ' */\n', 'contract ConfigStore is ConfigStoreInterface, Testable, Lockable, Ownable {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '\n', '    /****************************************\n', '     *        STORE DATA STRUCTURES         *\n', '     ****************************************/\n', '\n', '    // Make currentConfig private to force user to call getCurrentConfig, which returns the pendingConfig\n', '    // if its liveness has expired.\n', '    ConfigStoreInterface.ConfigSettings private currentConfig;\n', '\n', '    // Beginning on `pendingPassedTimestamp`, the `pendingConfig` can be published as the current config.\n', '    ConfigStoreInterface.ConfigSettings public pendingConfig;\n', '    uint256 public pendingPassedTimestamp;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event ProposedNewConfigSettings(\n', '        address indexed proposer,\n', '        uint256 rewardRate,\n', '        uint256 proposerBond,\n', '        uint256 timelockLiveness,\n', '        int256 maxFundingRate,\n', '        int256 minFundingRate,\n', '        uint256 proposalTimePastLimit,\n', '        uint256 proposalPassedTimestamp\n', '    );\n', '    event ChangedConfigSettings(\n', '        uint256 rewardRate,\n', '        uint256 proposerBond,\n', '        uint256 timelockLiveness,\n', '        int256 maxFundingRate,\n', '        int256 minFundingRate,\n', '        uint256 proposalTimePastLimit\n', '    );\n', '\n', '    /****************************************\n', '     *                MODIFIERS             *\n', '     ****************************************/\n', '\n', '    // Update config settings if possible.\n', '    modifier updateConfig() {\n', '        _updateConfig();\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Construct the Config Store. An initial configuration is provided and set on construction.\n', '     * @param _initialConfig Configuration settings to initialize `currentConfig` with.\n', '     * @param _timerAddress Address of testable Timer contract.\n', '     */\n', '    constructor(ConfigSettings memory _initialConfig, address _timerAddress) public Testable(_timerAddress) {\n', '        _validateConfig(_initialConfig);\n', '        currentConfig = _initialConfig;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns current config or pending config if pending liveness has expired.\n', '     * @return ConfigSettings config settings that calling financial contract should view as "live".\n', '     */\n', '    function updateAndGetCurrentConfig()\n', '        external\n', '        override\n', '        updateConfig()\n', '        nonReentrant()\n', '        returns (ConfigStoreInterface.ConfigSettings memory)\n', '    {\n', '        return currentConfig;\n', '    }\n', '\n', '    /**\n', '     * @notice Propose new configuration settings. New settings go into effect after a liveness period passes.\n', '     * @param newConfig Configuration settings to publish after `currentConfig.timelockLiveness` passes from now.\n', '     * @dev Callable only by owner. Calling this while there is already a pending proposal will overwrite the pending proposal.\n', '     */\n', '    function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n', '        _validateConfig(newConfig);\n', '\n', '        // Warning: This overwrites a pending proposal!\n', '        pendingConfig = newConfig;\n', '\n', "        // Use current config's liveness period to timelock this proposal.\n", '        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n', '\n', '        emit ProposedNewConfigSettings(\n', '            msg.sender,\n', '            newConfig.rewardRatePerSecond.rawValue,\n', '            newConfig.proposerBondPct.rawValue,\n', '            newConfig.timelockLiveness,\n', '            newConfig.maxFundingRate.rawValue,\n', '            newConfig.minFundingRate.rawValue,\n', '            newConfig.proposalTimePastLimit,\n', '            pendingPassedTimestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Publish any pending configuration settings if there is a pending proposal that has passed liveness.\n', '     */\n', '    function publishPendingConfig() external nonReentrant() updateConfig() {}\n', '\n', '    /****************************************\n', '     *         INTERNAL FUNCTIONS           *\n', '     ****************************************/\n', '\n', '    // Check if pending proposal can overwrite the current config.\n', '    function _updateConfig() internal {\n', '        // If liveness has passed, publish proposed configuration settings.\n', '        if (_pendingProposalPassed()) {\n', '            currentConfig = pendingConfig;\n', '\n', '            _deletePendingConfig();\n', '\n', '            emit ChangedConfigSettings(\n', '                currentConfig.rewardRatePerSecond.rawValue,\n', '                currentConfig.proposerBondPct.rawValue,\n', '                currentConfig.timelockLiveness,\n', '                currentConfig.maxFundingRate.rawValue,\n', '                currentConfig.minFundingRate.rawValue,\n', '                currentConfig.proposalTimePastLimit\n', '            );\n', '        }\n', '    }\n', '\n', '    function _deletePendingConfig() internal {\n', '        delete pendingConfig;\n', '        pendingPassedTimestamp = 0;\n', '    }\n', '\n', '    function _pendingProposalPassed() internal view returns (bool) {\n', '        return (pendingPassedTimestamp != 0 && pendingPassedTimestamp <= getCurrentTime());\n', '    }\n', '\n', '    // Use this method to constrain values with which you can set ConfigSettings.\n', '    function _validateConfig(ConfigStoreInterface.ConfigSettings memory config) internal pure {\n', "        // We don't set limits on proposal timestamps because there are already natural limits:\n", "        // - Future: price requests to the OptimisticOracle must be in the past---we can't add further constraints.\n", '        // - Past: proposal times must always be after the last update time, and  a reasonable past limit would be 30\n', '        //   mins, meaning that no proposal timestamp can be more than 30 minutes behind the current time.\n', '\n', '        // Make sure timelockLiveness is not too long, otherwise contract might not be able to fix itself\n', '        // before a vulnerability drains its collateral.\n', '        require(config.timelockLiveness <= 7 days && config.timelockLiveness >= 1 days, "Invalid timelockLiveness");\n', '\n', '        // The reward rate should be modified as needed to incentivize honest proposers appropriately.\n', '        // Additionally, the rate should be less than 100% a year => 100% / 360 days / 24 hours / 60 mins / 60 secs\n', '        // = 0.0000033\n', '        FixedPoint.Unsigned memory maxRewardRatePerSecond = FixedPoint.fromUnscaledUint(33).div(1e7);\n', '        require(config.rewardRatePerSecond.isLessThan(maxRewardRatePerSecond), "Invalid rewardRatePerSecond");\n', '\n', "        // We don't set a limit on the proposer bond because it is a defense against dishonest proposers. If a proposer\n", '        // were to successfully propose a very high or low funding rate, then their PfC would be very high. The proposer\n', '        // could theoretically keep their "evil" funding rate alive indefinitely by continuously disputing honest\n', '        // proposers, so we would want to be able to set the proposal bond (equal to the dispute bond) higher than their\n', '        // PfC for each proposal liveness window. The downside of not limiting this is that the config store owner\n', '        // can set it arbitrarily high and preclude a new funding rate from ever coming in. We suggest setting the\n', "        // proposal bond based on the configuration's funding rate range like in this discussion:\n", '        // https://github.com/UMAprotocol/protocol/issues/2039#issuecomment-719734383\n', '\n', "        // We also don't set a limit on the funding rate max/min because we might need to allow very high magnitude\n", '        // funding rates in extraordinarily volatile market situations. Note, that even though we do not bound\n', '        // the max/min, we still recommend that the deployer of this contract set the funding rate max/min values\n', '        // to bound the PfC of a dishonest proposer. A reasonable range might be the equivalent of [+200%/year, -200%/year].\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../../common/implementation/FixedPoint.sol";\n', '\n', 'interface ConfigStoreInterface {\n', '    // All of the configuration settings available for querying by a perpetual.\n', '    struct ConfigSettings {\n', '        // Liveness period (in seconds) for an update to currentConfig to become official.\n', '        uint256 timelockLiveness;\n', '        // Reward rate paid to successful proposers. Percentage of 1 E.g., .1 is 10%.\n', '        FixedPoint.Unsigned rewardRatePerSecond;\n', "        // Bond % (of given contract's PfC) that must be staked by proposers. Percentage of 1, e.g. 0.0005 is 0.05%.\n", '        FixedPoint.Unsigned proposerBondPct;\n', '        // Maximum funding rate % per second that can be proposed.\n', '        FixedPoint.Signed maxFundingRate;\n', '        // Minimum funding rate % per second that can be proposed.\n', '        FixedPoint.Signed minFundingRate;\n', '        // Funding rate proposal timestamp cannot be more than this amount of seconds in the past from the latest\n', '        // update time.\n', '        uint256 proposalTimePastLimit;\n', '    }\n', '\n', '    function updateAndGetCurrentConfig() external returns (ConfigSettings memory);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./PerpetualLiquidatable.sol";\n', '\n', '/**\n', ' * @title Perpetual Multiparty Contract.\n', ' * @notice Convenient wrapper for Liquidatable.\n', ' */\n', 'contract Perpetual is PerpetualLiquidatable {\n', '    /**\n', '     * @notice Constructs the Perpetual contract.\n', '     * @param params struct to define input parameters for construction of Liquidatable. Some params\n', "     * are fed directly into the PositionManager's constructor within the inheritance tree.\n", '     */\n', '    constructor(ConstructorParams memory params)\n', '        public\n', '        PerpetualLiquidatable(params)\n', '    // Note: since there is no logic here, there is no need to add a re-entrancy guard.\n', '    {\n', '\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../../common/interfaces/ExpandedIERC20.sol";\n', 'import "../../common/interfaces/IERC20Standard.sol";\n', 'import "../../oracle/implementation/ContractCreator.sol";\n', 'import "../../common/implementation/Testable.sol";\n', 'import "../../common/implementation/AddressWhitelist.sol";\n', 'import "../../common/implementation/Lockable.sol";\n', 'import "../common/TokenFactory.sol";\n', 'import "../common/SyntheticToken.sol";\n', 'import "./PerpetualLib.sol";\n', 'import "./ConfigStore.sol";\n', '\n', '/**\n', ' * @title Perpetual Contract creator.\n', ' * @notice Factory contract to create and register new instances of perpetual contracts.\n', ' * Responsible for constraining the parameters used to construct a new perpetual. This creator contains a number of constraints\n', ' * that are applied to newly created contract. These constraints can evolve over time and are\n', ' * initially constrained to conservative values in this first iteration. Technically there is nothing in the\n', ' * Perpetual contract requiring these constraints. However, because `createPerpetual()` is intended\n', ' * to be the only way to create valid financial contracts that are registered with the DVM (via _registerContract),\n', '  we can enforce deployment configurations here.\n', ' */\n', 'contract PerpetualCreator is ContractCreator, Testable, Lockable {\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '\n', '    /****************************************\n', '     *     PERP CREATOR DATA STRUCTURES      *\n', '     ****************************************/\n', '\n', '    // Immutable params for perpetual contract.\n', '    struct Params {\n', '        address collateralAddress;\n', '        bytes32 priceFeedIdentifier;\n', '        bytes32 fundingRateIdentifier;\n', '        string syntheticName;\n', '        string syntheticSymbol;\n', '        FixedPoint.Unsigned collateralRequirement;\n', '        FixedPoint.Unsigned disputeBondPct;\n', '        FixedPoint.Unsigned sponsorDisputeRewardPct;\n', '        FixedPoint.Unsigned disputerDisputeRewardPct;\n', '        FixedPoint.Unsigned minSponsorTokens;\n', '        FixedPoint.Unsigned tokenScaling;\n', '        uint256 withdrawalLiveness;\n', '        uint256 liquidationLiveness;\n', '    }\n', '    // Address of TokenFactory used to create a new synthetic token.\n', '    address public tokenFactoryAddress;\n', '\n', '    event CreatedPerpetual(address indexed perpetualAddress, address indexed deployerAddress);\n', '    event CreatedConfigStore(address indexed configStoreAddress, address indexed ownerAddress);\n', '\n', '    /**\n', '     * @notice Constructs the Perpetual contract.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _tokenFactoryAddress ERC20 token factory used to deploy synthetic token instances.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     */\n', '    constructor(\n', '        address _finderAddress,\n', '        address _tokenFactoryAddress,\n', '        address _timerAddress\n', '    ) public ContractCreator(_finderAddress) Testable(_timerAddress) nonReentrant() {\n', '        tokenFactoryAddress = _tokenFactoryAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Creates an instance of perpetual and registers it within the registry.\n', '     * @param params is a `ConstructorParams` object from Perpetual.\n', '     * @return address of the deployed contract.\n', '     */\n', '    function createPerpetual(Params memory params, ConfigStore.ConfigSettings memory configSettings)\n', '        public\n', '        nonReentrant()\n', '        returns (address)\n', '    {\n', '        require(bytes(params.syntheticName).length != 0, "Missing synthetic name");\n', '        require(bytes(params.syntheticSymbol).length != 0, "Missing synthetic symbol");\n', '\n', '        // Create new config settings store for this contract and reset ownership to the deployer.\n', '        ConfigStore configStore = new ConfigStore(configSettings, timerAddress);\n', '        configStore.transferOwnership(msg.sender);\n', '        emit CreatedConfigStore(address(configStore), configStore.owner());\n', '\n', '        // Create a new synthetic token using the params.\n', '        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n', '\n', '        // If the collateral token does not have a `decimals()` method,\n', '        // then a default precision of 18 will be applied to the newly created synthetic token.\n', '        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n', '        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n', '        address derivative = PerpetualLib.deploy(_convertParams(params, tokenCurrency, address(configStore)));\n', '\n', '        // Give permissions to new derivative contract and then hand over ownership.\n', '        tokenCurrency.addMinter(derivative);\n', '        tokenCurrency.addBurner(derivative);\n', '        tokenCurrency.resetOwner(derivative);\n', '\n', '        _registerContract(new address[](0), derivative);\n', '\n', '        emit CreatedPerpetual(derivative, msg.sender);\n', '\n', '        return derivative;\n', '    }\n', '\n', '    /****************************************\n', '     *          PRIVATE FUNCTIONS           *\n', '     ****************************************/\n', '\n', '    // Converts createPerpetual params to Perpetual constructor params.\n', '    function _convertParams(\n', '        Params memory params,\n', '        ExpandedIERC20 newTokenCurrency,\n', '        address configStore\n', '    ) private view returns (Perpetual.ConstructorParams memory constructorParams) {\n', '        // Known from creator deployment.\n', '        constructorParams.finderAddress = finderAddress;\n', '        constructorParams.timerAddress = timerAddress;\n', '\n', '        // Enforce configuration constraints.\n', '        require(params.withdrawalLiveness != 0, "Withdrawal liveness cannot be 0");\n', '        require(params.liquidationLiveness != 0, "Liquidation liveness cannot be 0");\n', '        _requireWhitelistedCollateral(params.collateralAddress);\n', '\n', "        // We don't want perpetual deployers to be able to intentionally or unintentionally set\n", "        // liveness periods that could induce arithmetic overflow, but we also don't want\n", '        // to be opinionated about what livenesses are "correct", so we will somewhat\n', '        // arbitrarily set the liveness upper bound to 100 years (5200 weeks). In practice, liveness\n', '        // periods even greater than a few days would make the perpetual unusable for most users.\n', '        require(params.withdrawalLiveness < 5200 weeks, "Withdrawal liveness too large");\n', '        require(params.liquidationLiveness < 5200 weeks, "Liquidation liveness too large");\n', '\n', '        // To avoid precision loss or overflows, prevent the token scaling from being too large or too small.\n', '        FixedPoint.Unsigned memory minScaling = FixedPoint.Unsigned(1e8); // 1e-10\n', '        FixedPoint.Unsigned memory maxScaling = FixedPoint.Unsigned(1e28); // 1e10\n', '        require(\n', '            params.tokenScaling.isGreaterThan(minScaling) && params.tokenScaling.isLessThan(maxScaling),\n', '            "Invalid tokenScaling"\n', '        );\n', '\n', '        // Input from function call.\n', '        constructorParams.configStoreAddress = configStore;\n', '        constructorParams.tokenAddress = address(newTokenCurrency);\n', '        constructorParams.collateralAddress = params.collateralAddress;\n', '        constructorParams.priceFeedIdentifier = params.priceFeedIdentifier;\n', '        constructorParams.fundingRateIdentifier = params.fundingRateIdentifier;\n', '        constructorParams.collateralRequirement = params.collateralRequirement;\n', '        constructorParams.disputeBondPct = params.disputeBondPct;\n', '        constructorParams.sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n', '        constructorParams.disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n', '        constructorParams.minSponsorTokens = params.minSponsorTokens;\n', '        constructorParams.withdrawalLiveness = params.withdrawalLiveness;\n', '        constructorParams.liquidationLiveness = params.liquidationLiveness;\n', '        constructorParams.tokenScaling = params.tokenScaling;\n', '    }\n', '\n', '    // IERC20Standard.decimals() will revert if the collateral contract has not implemented the decimals() method,\n', '    // which is possible since the method is only an OPTIONAL method in the ERC20 standard:\n', '    // https://eips.ethereum.org/EIPS/eip-20#methods.\n', '    function _getSyntheticDecimals(address _collateralAddress) public view returns (uint8 decimals) {\n', '        try IERC20Standard(_collateralAddress).decimals() returns (uint8 _decimals) {\n', '            return _decimals;\n', '        } catch {\n', '            return 18;\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./Perpetual.sol";\n', '\n', '/**\n', ' * @title Provides convenient Perpetual Multi Party contract utilities.\n', ' * @dev Using this library to deploy Perpetuals allows calling contracts to avoid importing the full bytecode.\n', ' */\n', 'library PerpetualLib {\n', '    /**\n', '     * @notice Returns address of new Perpetual deployed with given `params` configuration.\n', '     * @dev Caller will need to register new Perpetual with the Registry to begin requesting prices. Caller is also\n', '     * responsible for enforcing constraints on `params`.\n', '     * @param params is a `ConstructorParams` object from Perpetual.\n', '     * @return address of the deployed Perpetual contract\n', '     */\n', '    function deploy(Perpetual.ConstructorParams memory params) public returns (address) {\n', '        Perpetual derivative = new Perpetual(params);\n', '        return address(derivative);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', '\n', 'import "./PerpetualPositionManager.sol";\n', '\n', 'import "../../common/implementation/FixedPoint.sol";\n', '\n', '/**\n', ' * @title PerpetualLiquidatable\n', ' * @notice Adds logic to a position-managing contract that enables callers to liquidate an undercollateralized position.\n', ' * @dev The liquidation has a liveness period before expiring successfully, during which someone can "dispute" the\n', ' * liquidation, which sends a price request to the relevant Oracle to settle the final collateralization ratio based on\n', ' * a DVM price. The contract enforces dispute rewards in order to incentivize disputers to correctly dispute false\n', ' * liquidations and compensate position sponsors who had their position incorrectly liquidated. Importantly, a\n', ' * prospective disputer must deposit a dispute bond that they can lose in the case of an unsuccessful dispute.\n', ' */\n', 'contract PerpetualLiquidatable is PerpetualPositionManager {\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /****************************************\n', '     *     LIQUIDATION DATA STRUCTURES      *\n', '     ****************************************/\n', '\n', '    // Because of the check in withdrawable(), the order of these enum values should not change.\n', '    enum Status { Uninitialized, PreDispute, PendingDispute, DisputeSucceeded, DisputeFailed }\n', '\n', '    struct LiquidationData {\n', '        // Following variables set upon creation of liquidation:\n', "        address sponsor; // Address of the liquidated position's sponsor\n", '        address liquidator; // Address who created this liquidation\n', '        Status state; // Liquidated (and expired or not), Pending a Dispute, or Dispute has resolved\n', '        uint256 liquidationTime; // Time when liquidation is initiated, needed to get price from Oracle\n', '        // Following variables determined by the position that is being liquidated:\n', '        FixedPoint.Unsigned tokensOutstanding; // Synthetic tokens required to be burned by liquidator to initiate dispute\n', '        FixedPoint.Unsigned lockedCollateral; // Collateral locked by contract and released upon expiry or post-dispute\n', '        // Amount of collateral being liquidated, which could be different from\n', '        // lockedCollateral if there were pending withdrawals at the time of liquidation\n', '        FixedPoint.Unsigned liquidatedCollateral;\n', '        // Unit value (starts at 1) that is used to track the fees per unit of collateral over the course of the liquidation.\n', '        FixedPoint.Unsigned rawUnitCollateral;\n', '        // Following variable set upon initiation of a dispute:\n', '        address disputer; // Person who is disputing a liquidation\n', '        // Following variable set upon a resolution of a dispute:\n', '        FixedPoint.Unsigned settlementPrice; // Final price as determined by an Oracle following a dispute\n', '        FixedPoint.Unsigned finalFee;\n', '    }\n', '\n', "    // Define the contract's constructor parameters as a struct to enable more variables to be specified.\n", "    // This is required to enable more params, over and above Solidity's limits.\n", '    struct ConstructorParams {\n', '        // Params for PerpetualPositionManager only.\n', '        uint256 withdrawalLiveness;\n', '        address configStoreAddress;\n', '        address collateralAddress;\n', '        address tokenAddress;\n', '        address finderAddress;\n', '        address timerAddress;\n', '        bytes32 priceFeedIdentifier;\n', '        bytes32 fundingRateIdentifier;\n', '        FixedPoint.Unsigned minSponsorTokens;\n', '        FixedPoint.Unsigned tokenScaling;\n', '        // Params specifically for PerpetualLiquidatable.\n', '        uint256 liquidationLiveness;\n', '        FixedPoint.Unsigned collateralRequirement;\n', '        FixedPoint.Unsigned disputeBondPct;\n', '        FixedPoint.Unsigned sponsorDisputeRewardPct;\n', '        FixedPoint.Unsigned disputerDisputeRewardPct;\n', '    }\n', '\n', '    // This struct is used in the `withdrawLiquidation` method that disperses liquidation and dispute rewards.\n', '    // `payToX` stores the total collateral to withdraw from the contract to pay X. This value might differ\n', '    // from `paidToX` due to precision loss between accounting for the `rawCollateral` versus the\n', '    // fee-adjusted collateral. These variables are stored within a struct to avoid the stack too deep error.\n', '    struct RewardsData {\n', '        FixedPoint.Unsigned payToSponsor;\n', '        FixedPoint.Unsigned payToLiquidator;\n', '        FixedPoint.Unsigned payToDisputer;\n', '        FixedPoint.Unsigned paidToSponsor;\n', '        FixedPoint.Unsigned paidToLiquidator;\n', '        FixedPoint.Unsigned paidToDisputer;\n', '    }\n', '\n', '    // Liquidations are unique by ID per sponsor\n', '    mapping(address => LiquidationData[]) public liquidations;\n', '\n', '    // Total collateral in liquidation.\n', '    FixedPoint.Unsigned public rawLiquidationCollateral;\n', '\n', '    // Immutable contract parameters:\n', '    // Amount of time for pending liquidation before expiry.\n', '    // !!Note: The lower the liquidation liveness value, the more risk incurred by sponsors.\n', '    //       Extremely low liveness values increase the chance that opportunistic invalid liquidations\n', '    //       expire without dispute, thereby decreasing the usability for sponsors and increasing the risk\n', '    //       for the contract as a whole. An insolvent contract is extremely risky for any sponsor or synthetic\n', '    //       token holder for the contract.\n', '    uint256 public liquidationLiveness;\n', '    // Required collateral:TRV ratio for a position to be considered sufficiently collateralized.\n', '    FixedPoint.Unsigned public collateralRequirement;\n', "    // Percent of a Liquidation/Position's lockedCollateral to be deposited by a potential disputer\n", '    // Represented as a multiplier, for example 1.5e18 = "150%" and 0.05e18 = "5%"\n', '    FixedPoint.Unsigned public disputeBondPct;\n', '    // Percent of oraclePrice paid to sponsor in the Disputed state (i.e. following a successful dispute)\n', '    // Represented as a multiplier, see above.\n', '    FixedPoint.Unsigned public sponsorDisputeRewardPct;\n', '    // Percent of oraclePrice paid to disputer in the Disputed state (i.e. following a successful dispute)\n', '    // Represented as a multiplier, see above.\n', '    FixedPoint.Unsigned public disputerDisputeRewardPct;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event LiquidationCreated(\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        uint256 indexed liquidationId,\n', '        uint256 tokensOutstanding,\n', '        uint256 lockedCollateral,\n', '        uint256 liquidatedCollateral,\n', '        uint256 liquidationTime\n', '    );\n', '    event LiquidationDisputed(\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        address indexed disputer,\n', '        uint256 liquidationId,\n', '        uint256 disputeBondAmount\n', '    );\n', '    event DisputeSettled(\n', '        address indexed caller,\n', '        address indexed sponsor,\n', '        address indexed liquidator,\n', '        address disputer,\n', '        uint256 liquidationId,\n', '        bool disputeSucceeded\n', '    );\n', '    event LiquidationWithdrawn(\n', '        address indexed caller,\n', '        uint256 paidToLiquidator,\n', '        uint256 paidToDisputer,\n', '        uint256 paidToSponsor,\n', '        Status indexed liquidationStatus,\n', '        uint256 settlementPrice\n', '    );\n', '\n', '    /****************************************\n', '     *              MODIFIERS               *\n', '     ****************************************/\n', '\n', '    modifier disputable(uint256 liquidationId, address sponsor) {\n', '        _disputable(liquidationId, sponsor);\n', '        _;\n', '    }\n', '\n', '    modifier withdrawable(uint256 liquidationId, address sponsor) {\n', '        _withdrawable(liquidationId, sponsor);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Constructs the liquidatable contract.\n', '     * @param params struct to define input parameters for construction of Liquidatable. Some params\n', "     * are fed directly into the PositionManager's constructor within the inheritance tree.\n", '     */\n', '    constructor(ConstructorParams memory params)\n', '        public\n', '        PerpetualPositionManager(\n', '            params.withdrawalLiveness,\n', '            params.collateralAddress,\n', '            params.tokenAddress,\n', '            params.finderAddress,\n', '            params.priceFeedIdentifier,\n', '            params.fundingRateIdentifier,\n', '            params.minSponsorTokens,\n', '            params.configStoreAddress,\n', '            params.tokenScaling,\n', '            params.timerAddress\n', '        )\n', '    {\n', '        require(params.collateralRequirement.isGreaterThan(1));\n', '        require(params.sponsorDisputeRewardPct.add(params.disputerDisputeRewardPct).isLessThan(1));\n', '\n', '        // Set liquidatable specific variables.\n', '        liquidationLiveness = params.liquidationLiveness;\n', '        collateralRequirement = params.collateralRequirement;\n', '        disputeBondPct = params.disputeBondPct;\n', '        sponsorDisputeRewardPct = params.sponsorDisputeRewardPct;\n', '        disputerDisputeRewardPct = params.disputerDisputeRewardPct;\n', '    }\n', '\n', '    /****************************************\n', '     *        LIQUIDATION FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    /**\n', "     * @notice Liquidates the sponsor's position if the caller has enough\n", "     * synthetic tokens to retire the position's outstanding tokens. Liquidations above\n", '     * a minimum size also reset an ongoing "slow withdrawal"\'s liveness.\n', '     * @dev This method generates an ID that will uniquely identify liquidation for the sponsor. This contract must be\n', '     * approved to spend at least `tokensLiquidated` of `tokenCurrency` and at least `finalFeeBond` of `collateralCurrency`.\n', '     * @dev This contract must have the Burner role for the `tokenCurrency`.\n', '     * @param sponsor address of the sponsor to liquidate.\n', "     * @param minCollateralPerToken abort the liquidation if the position's collateral per token is below this value.\n", "     * @param maxCollateralPerToken abort the liquidation if the position's collateral per token exceeds this value.\n", '     * @param maxTokensToLiquidate max number of tokens to liquidate.\n', '     * @param deadline abort the liquidation if the transaction is mined after this timestamp.\n', '     * @return liquidationId ID of the newly created liquidation.\n', "     * @return tokensLiquidated amount of synthetic tokens removed and liquidated from the `sponsor`'s position.\n", '     * @return finalFeeBond amount of collateral to be posted by liquidator and returned if not disputed successfully.\n', '     */\n', '    function createLiquidation(\n', '        address sponsor,\n', '        FixedPoint.Unsigned calldata minCollateralPerToken,\n', '        FixedPoint.Unsigned calldata maxCollateralPerToken,\n', '        FixedPoint.Unsigned calldata maxTokensToLiquidate,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        notEmergencyShutdown()\n', '        fees()\n', '        nonReentrant()\n', '        returns (\n', '            uint256 liquidationId,\n', '            FixedPoint.Unsigned memory tokensLiquidated,\n', '            FixedPoint.Unsigned memory finalFeeBond\n', '        )\n', '    {\n', '        // Check that this transaction was mined pre-deadline.\n', '        require(getCurrentTime() <= deadline, "Mined after deadline");\n', '\n', '        // Retrieve Position data for sponsor\n', '        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n', '\n', '        tokensLiquidated = FixedPoint.min(maxTokensToLiquidate, positionToLiquidate.tokensOutstanding);\n', '        require(tokensLiquidated.isGreaterThan(0));\n', '\n', "        // Starting values for the Position being liquidated. If withdrawal request amount is > position's collateral,\n", '        // then set this to 0, otherwise set it to (startCollateral - withdrawal request amount).\n', '        FixedPoint.Unsigned memory startCollateral = _getFeeAdjustedCollateral(positionToLiquidate.rawCollateral);\n', '        FixedPoint.Unsigned memory startCollateralNetOfWithdrawal = FixedPoint.fromUnscaledUint(0);\n', '        if (positionToLiquidate.withdrawalRequestAmount.isLessThanOrEqual(startCollateral)) {\n', '            startCollateralNetOfWithdrawal = startCollateral.sub(positionToLiquidate.withdrawalRequestAmount);\n', '        }\n', '\n', '        // Scoping to get rid of a stack too deep error.\n', '        {\n', '            FixedPoint.Unsigned memory startTokens = positionToLiquidate.tokensOutstanding;\n', '\n', "            // The Position's collateralization ratio must be between [minCollateralPerToken, maxCollateralPerToken].\n", '            require(\n', '                maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),\n', '                "CR is more than max liq. price"\n', '            );\n', '            // minCollateralPerToken >= startCollateralNetOfWithdrawal / startTokens.\n', '            require(\n', '                minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),\n', '                "CR is less than min liq. price"\n', '            );\n', '        }\n', '\n', '        // Compute final fee at time of liquidation.\n', '        finalFeeBond = _computeFinalFees();\n', '\n', '        // These will be populated within the scope below.\n', '        FixedPoint.Unsigned memory lockedCollateral;\n', '        FixedPoint.Unsigned memory liquidatedCollateral;\n', '\n', '        // Scoping to get rid of a stack too deep error. The amount of tokens to remove from the position\n', '        // are not funding-rate adjusted because the multiplier only affects their redemption value, not their\n', '        // notional.\n', '        {\n', '            FixedPoint.Unsigned memory ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding);\n', '\n', '            // The actual amount of collateral that gets moved to the liquidation.\n', '            lockedCollateral = startCollateral.mul(ratio);\n', '\n', "            // For purposes of disputes, it's actually this liquidatedCollateral value that's used. This value is net of\n", '            // withdrawal requests.\n', '            liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio);\n', '\n', '            // Part of the withdrawal request is also removed. Ideally:\n', '            // liquidatedCollateral + withdrawalAmountToRemove = lockedCollateral.\n', '            FixedPoint.Unsigned memory withdrawalAmountToRemove =\n', '                positionToLiquidate.withdrawalRequestAmount.mul(ratio);\n', '            _reduceSponsorPosition(sponsor, tokensLiquidated, lockedCollateral, withdrawalAmountToRemove);\n', '        }\n', '\n', '        // Add to the global liquidation collateral count.\n', '        _addCollateral(rawLiquidationCollateral, lockedCollateral.add(finalFeeBond));\n', '\n', '        // Construct liquidation object.\n', '        // Note: All dispute-related values are zeroed out until a dispute occurs. liquidationId is the index of the new\n', '        // LiquidationData that is pushed into the array, which is equal to the current length of the array pre-push.\n', '        liquidationId = liquidations[sponsor].length;\n', '        liquidations[sponsor].push(\n', '            LiquidationData({\n', '                sponsor: sponsor,\n', '                liquidator: msg.sender,\n', '                state: Status.PreDispute,\n', '                liquidationTime: getCurrentTime(),\n', '                tokensOutstanding: _getFundingRateAppliedTokenDebt(tokensLiquidated),\n', '                lockedCollateral: lockedCollateral,\n', '                liquidatedCollateral: liquidatedCollateral,\n', '                rawUnitCollateral: _convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),\n', '                disputer: address(0),\n', '                settlementPrice: FixedPoint.fromUnscaledUint(0),\n', '                finalFee: finalFeeBond\n', '            })\n', '        );\n', '\n', '        // If this liquidation is a subsequent liquidation on the position, and the liquidation size is larger than\n', '        // some "griefing threshold", then re-set the liveness. This enables a liquidation against a withdraw request to be\n', '        // "dragged out" if the position is very large and liquidators need time to gather funds. The griefing threshold\n', "        // is enforced so that liquidations for trivially small # of tokens cannot drag out an honest sponsor's slow withdrawal.\n", '\n', '        // We arbitrarily set the "griefing threshold" to `minSponsorTokens` because it is the only parameter\n', '        // denominated in token currency units and we can avoid adding another parameter.\n', '        FixedPoint.Unsigned memory griefingThreshold = minSponsorTokens;\n', '        if (\n', '            positionToLiquidate.withdrawalRequestPassTimestamp > 0 && // The position is undergoing a slow withdrawal.\n', '            positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && // The slow withdrawal has not yet expired.\n', '            tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) // The liquidated token count is above a "griefing threshold".\n', '        ) {\n', '            positionToLiquidate.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n', '        }\n', '\n', '        emit LiquidationCreated(\n', '            sponsor,\n', '            msg.sender,\n', '            liquidationId,\n', '            _getFundingRateAppliedTokenDebt(tokensLiquidated).rawValue,\n', '            lockedCollateral.rawValue,\n', '            liquidatedCollateral.rawValue,\n', '            getCurrentTime()\n', '        );\n', '\n', '        // Destroy tokens\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensLiquidated.rawValue);\n', '        tokenCurrency.burn(tokensLiquidated.rawValue);\n', '\n', '        // Pull final fee from liquidator.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), finalFeeBond.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Disputes a liquidation, if the caller has enough collateral to post a dispute bond\n', '     * and pay a fixed final fee charged on each price request.\n', '     * @dev Can only dispute a liquidation before the liquidation expires and if there are no other pending disputes.\n', '     * This contract must be approved to spend at least the dispute bond amount of `collateralCurrency`. This dispute\n', '     * bond amount is calculated from `disputeBondPct` times the collateral in the liquidation.\n', '     * @param liquidationId of the disputed liquidation.\n', '     * @param sponsor the address of the sponsor whose liquidation is being disputed.\n', '     * @return totalPaid amount of collateral charged to disputer (i.e. final fee bond + dispute bond).\n', '     */\n', '    function dispute(uint256 liquidationId, address sponsor)\n', '        external\n', '        disputable(liquidationId, sponsor)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory totalPaid)\n', '    {\n', '        LiquidationData storage disputedLiquidation = _getLiquidationData(sponsor, liquidationId);\n', '\n', '        // Multiply by the unit collateral so the dispute bond is a percentage of the locked collateral after fees.\n', '        FixedPoint.Unsigned memory disputeBondAmount =\n', '            disputedLiquidation.lockedCollateral.mul(disputeBondPct).mul(\n', '                _getFeeAdjustedCollateral(disputedLiquidation.rawUnitCollateral)\n', '            );\n', '        _addCollateral(rawLiquidationCollateral, disputeBondAmount);\n', '\n', '        // Request a price from DVM. Liquidation is pending dispute until DVM returns a price.\n', '        disputedLiquidation.state = Status.PendingDispute;\n', '        disputedLiquidation.disputer = msg.sender;\n', '\n', '        // Enqueue a request with the DVM.\n', '        _requestOraclePrice(disputedLiquidation.liquidationTime);\n', '\n', '        emit LiquidationDisputed(\n', '            sponsor,\n', '            disputedLiquidation.liquidator,\n', '            msg.sender,\n', '            liquidationId,\n', '            disputeBondAmount.rawValue\n', '        );\n', '        totalPaid = disputeBondAmount.add(disputedLiquidation.finalFee);\n', '\n', '        // Pay the final fee for requesting price from the DVM.\n', '        _payFinalFees(msg.sender, disputedLiquidation.finalFee);\n', '\n', '        // Transfer the dispute bond amount from the caller to this contract.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), disputeBondAmount.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice After a dispute has settled or after a non-disputed liquidation has expired,\n', '     * anyone can call this method to disperse payments to the sponsor, liquidator, and disputer.\n', '     * @dev If the dispute SUCCEEDED: the sponsor, liquidator, and disputer are eligible for payment.\n', '     * If the dispute FAILED: only the liquidator receives payment. This method deletes the liquidation data.\n', '     * This method will revert if rewards have already been dispersed.\n', "     * @param liquidationId uniquely identifies the sponsor's liquidation.\n", '     * @param sponsor address of the sponsor associated with the liquidation.\n', '     * @return data about rewards paid out.\n', '     */\n', '    function withdrawLiquidation(uint256 liquidationId, address sponsor)\n', '        public\n', '        withdrawable(liquidationId, sponsor)\n', '        fees()\n', '        nonReentrant()\n', '        returns (RewardsData memory)\n', '    {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '\n', '        // Settles the liquidation if necessary. This call will revert if the price has not resolved yet.\n', '        _settle(liquidationId, sponsor);\n', '\n', '        // Calculate rewards as a function of the TRV.\n', '        // Note: all payouts are scaled by the unit collateral value so all payouts are charged the fees pro rata.\n', '        // TODO: Do we also need to apply some sort of funding rate adjustment to account for multiplier changes\n', '        // since liquidation time?\n', '        FixedPoint.Unsigned memory feeAttenuation = _getFeeAdjustedCollateral(liquidation.rawUnitCollateral);\n', '        FixedPoint.Unsigned memory settlementPrice = liquidation.settlementPrice;\n', '        FixedPoint.Unsigned memory tokenRedemptionValue =\n', '            liquidation.tokensOutstanding.mul(settlementPrice).mul(feeAttenuation);\n', '        FixedPoint.Unsigned memory collateral = liquidation.lockedCollateral.mul(feeAttenuation);\n', '        FixedPoint.Unsigned memory disputerDisputeReward = disputerDisputeRewardPct.mul(tokenRedemptionValue);\n', '        FixedPoint.Unsigned memory sponsorDisputeReward = sponsorDisputeRewardPct.mul(tokenRedemptionValue);\n', '        FixedPoint.Unsigned memory disputeBondAmount = collateral.mul(disputeBondPct);\n', '        FixedPoint.Unsigned memory finalFee = liquidation.finalFee.mul(feeAttenuation);\n', '\n', '        // There are three main outcome states: either the dispute succeeded, failed or was not updated.\n', '        // Based on the state, different parties of a liquidation receive different amounts.\n', '        // After assigning rewards based on the liquidation status, decrease the total collateral held in this contract\n', '        // by the amount to pay each party. The actual amounts withdrawn might differ if _removeCollateral causes\n', '        // precision loss.\n', '        RewardsData memory rewards;\n', '        if (liquidation.state == Status.DisputeSucceeded) {\n', '            // If the dispute is successful then all three users should receive rewards:\n', '\n', '            // Pay DISPUTER: disputer reward + dispute bond + returned final fee\n', '            rewards.payToDisputer = disputerDisputeReward.add(disputeBondAmount).add(finalFee);\n', '\n', '            // Pay SPONSOR: remaining collateral (collateral - TRV) + sponsor reward\n', '            rewards.payToSponsor = sponsorDisputeReward.add(collateral.sub(tokenRedemptionValue));\n', '\n', '            // Pay LIQUIDATOR: TRV - dispute reward - sponsor reward\n', '            // If TRV > Collateral, then subtract rewards from collateral\n', '            // NOTE: This should never be below zero since we prevent (sponsorDisputePct+disputerDisputePct) >= 0 in\n', '            // the constructor when these params are set.\n', '            rewards.payToLiquidator = tokenRedemptionValue.sub(sponsorDisputeReward).sub(disputerDisputeReward);\n', '\n', '            // Transfer rewards and debit collateral\n', '            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n', '            rewards.paidToSponsor = _removeCollateral(rawLiquidationCollateral, rewards.payToSponsor);\n', '            rewards.paidToDisputer = _removeCollateral(rawLiquidationCollateral, rewards.payToDisputer);\n', '\n', '            collateralCurrency.safeTransfer(liquidation.disputer, rewards.paidToDisputer.rawValue);\n', '            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n', '            collateralCurrency.safeTransfer(liquidation.sponsor, rewards.paidToSponsor.rawValue);\n', '\n', '            // In the case of a failed dispute only the liquidator can withdraw.\n', '        } else if (liquidation.state == Status.DisputeFailed) {\n', '            // Pay LIQUIDATOR: collateral + dispute bond + returned final fee\n', '            rewards.payToLiquidator = collateral.add(disputeBondAmount).add(finalFee);\n', '\n', '            // Transfer rewards and debit collateral\n', '            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n', '\n', '            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n', '\n', '            // If the state is pre-dispute but time has passed liveness then there was no dispute. We represent this\n', '            // state as a dispute failed and the liquidator can withdraw.\n', '        } else if (liquidation.state == Status.PreDispute) {\n', '            // Pay LIQUIDATOR: collateral + returned final fee\n', '            rewards.payToLiquidator = collateral.add(finalFee);\n', '\n', '            // Transfer rewards and debit collateral\n', '            rewards.paidToLiquidator = _removeCollateral(rawLiquidationCollateral, rewards.payToLiquidator);\n', '\n', '            collateralCurrency.safeTransfer(liquidation.liquidator, rewards.paidToLiquidator.rawValue);\n', '        }\n', '\n', '        emit LiquidationWithdrawn(\n', '            msg.sender,\n', '            rewards.paidToLiquidator.rawValue,\n', '            rewards.paidToDisputer.rawValue,\n', '            rewards.paidToSponsor.rawValue,\n', '            liquidation.state,\n', '            settlementPrice.rawValue\n', '        );\n', '\n', '        // Free up space after collateral is withdrawn by removing the liquidation object from the array.\n', '        delete liquidations[sponsor][liquidationId];\n', '\n', '        return rewards;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets all liquidation information for a given sponsor address.\n', '     * @param sponsor address of the position sponsor.\n', '     * @return liquidationData array of all liquidation information for the given sponsor address.\n', '     */\n', '    function getLiquidations(address sponsor)\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (LiquidationData[] memory liquidationData)\n', '    {\n', '        return liquidations[sponsor];\n', '    }\n', '\n', '    /****************************************\n', '     *          INTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    // This settles a liquidation if it is in the PendingDispute state. If not, it will immediately return.\n', '    // If the liquidation is in the PendingDispute state, but a price is not available, this will revert.\n', '    function _settle(uint256 liquidationId, address sponsor) internal {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '\n', '        // Settlement only happens when state == PendingDispute and will only happen once per liquidation.\n', '        // If this liquidation is not ready to be settled, this method should return immediately.\n', '        if (liquidation.state != Status.PendingDispute) {\n', '            return;\n', '        }\n', '\n', '        // Get the returned price from the oracle. If this has not yet resolved will revert.\n', '        liquidation.settlementPrice = _getOraclePrice(liquidation.liquidationTime);\n', '\n', '        // Find the value of the tokens in the underlying collateral.\n', '        FixedPoint.Unsigned memory tokenRedemptionValue =\n', '            liquidation.tokensOutstanding.mul(liquidation.settlementPrice);\n', '\n', '        // The required collateral is the value of the tokens in underlying * required collateral ratio.\n', '        FixedPoint.Unsigned memory requiredCollateral = tokenRedemptionValue.mul(collateralRequirement);\n', '\n', '        // If the position has more than the required collateral it is solvent and the dispute is valid (liquidation is invalid)\n', '        // Note that this check uses the liquidatedCollateral not the lockedCollateral as this considers withdrawals.\n', '        bool disputeSucceeded = liquidation.liquidatedCollateral.isGreaterThanOrEqual(requiredCollateral);\n', '        liquidation.state = disputeSucceeded ? Status.DisputeSucceeded : Status.DisputeFailed;\n', '\n', '        emit DisputeSettled(\n', '            msg.sender,\n', '            sponsor,\n', '            liquidation.liquidator,\n', '            liquidation.disputer,\n', '            liquidationId,\n', '            disputeSucceeded\n', '        );\n', '    }\n', '\n', '    function _pfc() internal view override returns (FixedPoint.Unsigned memory) {\n', '        return super._pfc().add(_getFeeAdjustedCollateral(rawLiquidationCollateral));\n', '    }\n', '\n', '    function _getLiquidationData(address sponsor, uint256 liquidationId)\n', '        internal\n', '        view\n', '        returns (LiquidationData storage liquidation)\n', '    {\n', '        LiquidationData[] storage liquidationArray = liquidations[sponsor];\n', '\n', '        // Revert if the caller is attempting to access an invalid liquidation\n', '        // (one that has never been created or one has never been initialized).\n', '        require(\n', '            liquidationId < liquidationArray.length && liquidationArray[liquidationId].state != Status.Uninitialized\n', '        );\n', '        return liquidationArray[liquidationId];\n', '    }\n', '\n', '    function _getLiquidationExpiry(LiquidationData storage liquidation) internal view returns (uint256) {\n', '        return liquidation.liquidationTime.add(liquidationLiveness);\n', '    }\n', '\n', '    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\n', '    // unnecessarily increase contract bytecode size.\n', '    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n', '    function _disputable(uint256 liquidationId, address sponsor) internal view {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '        require(\n', '            (getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.PreDispute),\n', '            "Liquidation not disputable"\n', '        );\n', '    }\n', '\n', '    function _withdrawable(uint256 liquidationId, address sponsor) internal view {\n', '        LiquidationData storage liquidation = _getLiquidationData(sponsor, liquidationId);\n', '        Status state = liquidation.state;\n', '\n', '        // Must be disputed or the liquidation has passed expiry.\n', '        require(\n', '            (state > Status.PreDispute) ||\n', '                ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.PreDispute)),\n', '            "Liquidation not withdrawable"\n', '        );\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', '\n', 'import "../../common/implementation/FixedPoint.sol";\n', 'import "../../common/interfaces/ExpandedIERC20.sol";\n', '\n', 'import "../../oracle/interfaces/OracleInterface.sol";\n', 'import "../../oracle/interfaces/IdentifierWhitelistInterface.sol";\n', 'import "../../oracle/implementation/Constants.sol";\n', '\n', 'import "../common/FundingRateApplier.sol";\n', '\n', '/**\n', ' * @title Financial contract with priceless position management.\n', ' * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\n', ' * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\n', ' */\n', '\n', 'contract PerpetualPositionManager is FundingRateApplier {\n', '    using SafeMath for uint256;\n', '    using FixedPoint for FixedPoint.Unsigned;\n', '    using SafeERC20 for IERC20;\n', '    using SafeERC20 for ExpandedIERC20;\n', '\n', '    /****************************************\n', '     *  PRICELESS POSITION DATA STRUCTURES  *\n', '     ****************************************/\n', '\n', "    // Represents a single sponsor's position. All collateral is held by this contract.\n", '    // This struct acts as bookkeeping for how much of that collateral is allocated to each sponsor.\n', '    struct PositionData {\n', '        FixedPoint.Unsigned tokensOutstanding;\n', '        // Tracks pending withdrawal requests. A withdrawal request is pending if `withdrawalRequestPassTimestamp != 0`.\n', '        uint256 withdrawalRequestPassTimestamp;\n', '        FixedPoint.Unsigned withdrawalRequestAmount;\n', '        // Raw collateral value. This value should never be accessed directly -- always use _getFeeAdjustedCollateral().\n', '        // To add or remove collateral, use _addCollateral() and _removeCollateral().\n', '        FixedPoint.Unsigned rawCollateral;\n', '    }\n', '\n', '    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\n', '    mapping(address => PositionData) public positions;\n', '\n', '    // Keep track of the total collateral and tokens across all positions to enable calculating the\n', '    // global collateralization ratio without iterating over all positions.\n', '    FixedPoint.Unsigned public totalTokensOutstanding;\n', '\n', '    // Similar to the rawCollateral in PositionData, this value should not be used directly.\n', '    // _getFeeAdjustedCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\n', '    FixedPoint.Unsigned public rawTotalPositionCollateral;\n', '\n', '    // Synthetic token created by this contract.\n', '    ExpandedIERC20 public tokenCurrency;\n', '\n', '    // Unique identifier for DVM price feed ticker.\n', '    bytes32 public priceIdentifier;\n', '\n', '    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\n', '    // !!Note: The lower the withdrawal liveness value, the more risk incurred by the contract.\n', '    //       Extremely low liveness values increase the chance that opportunistic invalid withdrawal requests\n', '    //       expire without liquidation, thereby increasing the insolvency risk for the contract as a whole. An insolvent\n', '    //       contract is extremely risky for any sponsor or synthetic token holder for the contract.\n', '    uint256 public withdrawalLiveness;\n', '\n', "    // Minimum number of tokens in a sponsor's position.\n", '    FixedPoint.Unsigned public minSponsorTokens;\n', '\n', '    // Expiry price pulled from the DVM in the case of an emergency shutdown.\n', '    FixedPoint.Unsigned public emergencyShutdownPrice;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event Deposit(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event Withdrawal(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawal(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawalExecuted(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event RequestWithdrawalCanceled(address indexed sponsor, uint256 indexed collateralAmount);\n', '    event PositionCreated(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\n', '    event NewSponsor(address indexed sponsor);\n', '    event EndedSponsorPosition(address indexed sponsor);\n', '    event Redeem(address indexed sponsor, uint256 indexed collateralAmount, uint256 indexed tokenAmount);\n', '    event Repay(address indexed sponsor, uint256 indexed numTokensRepaid, uint256 indexed newTokenCount);\n', '    event EmergencyShutdown(address indexed caller, uint256 shutdownTimestamp);\n', '    event SettleEmergencyShutdown(\n', '        address indexed caller,\n', '        uint256 indexed collateralReturned,\n', '        uint256 indexed tokensBurned\n', '    );\n', '\n', '    /****************************************\n', '     *               MODIFIERS              *\n', '     ****************************************/\n', '\n', '    modifier onlyCollateralizedPosition(address sponsor) {\n', '        _onlyCollateralizedPosition(sponsor);\n', '        _;\n', '    }\n', '\n', '    modifier noPendingWithdrawal(address sponsor) {\n', '        _positionHasNoPendingWithdrawal(sponsor);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Construct the PerpetualPositionManager.\n', '     * @dev Deployer of this contract should consider carefully which parties have ability to mint and burn\n', "     * the synthetic tokens referenced by `_tokenAddress`. This contract's security assumes that no external accounts\n", "     * can mint new tokens, which could be used to steal all of this contract's locked collateral.\n", '     * We recommend to only use synthetic token contracts whose sole Owner role (the role capable of adding & removing roles)\n', '     * is assigned to this contract, whose sole Minter role is assigned to this contract, and whose\n', '     * total supply is 0 prior to construction of this contract.\n', '     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\n', '     * @param _collateralAddress ERC20 token used as collateral for all positions.\n', '     * @param _tokenAddress ERC20 token used as synthetic token.\n', '     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n', '     * @param _priceIdentifier registered in the DVM for the synthetic.\n', '     * @param _fundingRateIdentifier Unique identifier for DVM price feed ticker for child financial contract.\n', '     * @param _minSponsorTokens minimum amount of collateral that must exist at any time in a position.\n', '     * @param _tokenScaling initial scaling to apply to the token value (i.e. scales the tracking index).\n', '     * @param _timerAddress Contract that stores the current time in a testing environment. Set to 0x0 for production.\n', '     */\n', '    constructor(\n', '        uint256 _withdrawalLiveness,\n', '        address _collateralAddress,\n', '        address _tokenAddress,\n', '        address _finderAddress,\n', '        bytes32 _priceIdentifier,\n', '        bytes32 _fundingRateIdentifier,\n', '        FixedPoint.Unsigned memory _minSponsorTokens,\n', '        address _configStoreAddress,\n', '        FixedPoint.Unsigned memory _tokenScaling,\n', '        address _timerAddress\n', '    )\n', '        public\n', '        FundingRateApplier(\n', '            _fundingRateIdentifier,\n', '            _collateralAddress,\n', '            _finderAddress,\n', '            _configStoreAddress,\n', '            _tokenScaling,\n', '            _timerAddress\n', '        )\n', '    {\n', '        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier));\n', '\n', '        withdrawalLiveness = _withdrawalLiveness;\n', '        tokenCurrency = ExpandedIERC20(_tokenAddress);\n', '        minSponsorTokens = _minSponsorTokens;\n', '        priceIdentifier = _priceIdentifier;\n', '    }\n', '\n', '    /****************************************\n', '     *          POSITION FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the specified sponsor's position.\n", '     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n', '     * at least `collateralAmount` of `collateralCurrency`.\n', '     * @param sponsor the sponsor to credit the deposit to.\n', "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n", '     */\n', '    function depositTo(address sponsor, FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        notEmergencyShutdown()\n', '        noPendingWithdrawal(sponsor)\n', '        fees()\n', '        nonReentrant()\n', '    {\n', '        require(collateralAmount.isGreaterThan(0));\n', '        PositionData storage positionData = _getPositionData(sponsor);\n', '\n', '        // Increase the position and global collateral balance by collateral amount.\n', '        _incrementCollateralBalances(positionData, collateralAmount);\n', '\n', '        emit Deposit(sponsor, collateralAmount.rawValue);\n', '\n', '        // Move collateral currency from sender to contract.\n', '        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n', '    }\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` into the caller's position.\n", '     * @dev Increases the collateralization level of a position after creation. This contract must be approved to spend\n', '     * at least `collateralAmount` of `collateralCurrency`.\n', "     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n", '     */\n', '    function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n', '        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n', '        depositTo(msg.sender, collateralAmount);\n', '    }\n', '\n', '    /**\n', "     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n", "     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global collateralization\n", '     * ratio. In that case, use `requestWithdrawal`. Might not withdraw the full requested amount to account for precision loss.\n', '     * @param collateralAmount is the amount of collateral to withdraw.\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function withdraw(FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        notEmergencyShutdown()\n', '        noPendingWithdrawal(msg.sender)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        require(collateralAmount.isGreaterThan(0));\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n", '        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n', '        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n', '\n', '        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n', '\n', '        // Move collateral currency from contract to sender.\n', '        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n', '        // instead of the user requested amount. This eliminates precision loss that could occur\n', '        // where the user withdraws more collateral than rawCollateral is decremented by.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw from their position.\n', '     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n', '     * @param collateralAmount the amount of collateral requested to withdraw\n', '     */\n', '    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n', '        public\n', '        notEmergencyShutdown()\n', '        noPendingWithdrawal(msg.sender)\n', '        nonReentrant()\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(\n', '            collateralAmount.isGreaterThan(0) &&\n', '                collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n', '        );\n', '\n', '        // Update the position object for the user.\n', '        positionData.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n', '        positionData.withdrawalRequestAmount = collateralAmount;\n', '\n', '        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\n', '     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\n', '     * @dev Might not withdraw the full requested amount in order to account for precision loss or if the full requested\n', '     * amount exceeds the collateral in the position (due to paying fees).\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function withdrawPassedRequest()\n', '        external\n', '        notEmergencyShutdown()\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(\n', '            positionData.withdrawalRequestPassTimestamp != 0 &&\n', '                positionData.withdrawalRequestPassTimestamp <= getCurrentTime(),\n', '            "Invalid withdraw request"\n', '        );\n', '\n', '        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n', '        // This situation is possible due to fees charged since the withdrawal was originally requested.\n', '        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n', '        if (positionData.withdrawalRequestAmount.isGreaterThan(_getFeeAdjustedCollateral(positionData.rawCollateral))) {\n', '            amountToWithdraw = _getFeeAdjustedCollateral(positionData.rawCollateral);\n', '        }\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts.\n", '        amountWithdrawn = _decrementCollateralBalances(positionData, amountToWithdraw);\n', '\n', '        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n', '        _resetWithdrawalRequest(positionData);\n', '\n', '        // Transfer approved withdrawal amount from the contract to the caller.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '\n', '        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels a pending withdrawal request.\n', '     */\n', '    function cancelWithdrawal() external notEmergencyShutdown() nonReentrant() {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        // No pending withdrawal require message removed to save bytecode.\n', '        require(positionData.withdrawalRequestPassTimestamp != 0);\n', '\n', '        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n', '\n', '        // Reset withdrawal request by setting withdrawal amount and withdrawal timestamp to 0.\n', '        _resetWithdrawalRequest(positionData);\n', '    }\n', '\n', '    /**\n', '     * @notice Creates tokens by creating a new position or by augmenting an existing position. Pulls `collateralAmount\n', "     * ` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n", '     * @dev This contract must have the Minter role for the `tokenCurrency`.\n', "     * @dev Reverts if minting these tokens would put the position's collateralization ratio below the\n", '     * global collateralization ratio. This contract must be approved to spend at least `collateralAmount` of\n', '     * `collateralCurrency`.\n', '     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n', '     * @param numTokens is the number of tokens to mint from the position.\n', '     */\n', '    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n', '        public\n', '        notEmergencyShutdown()\n', '        fees()\n', '        nonReentrant()\n', '    {\n', '        PositionData storage positionData = positions[msg.sender];\n', '\n', '        // Either the new create ratio or the resultant position CR must be above the current GCR.\n', '        require(\n', '            (_checkCollateralization(\n', '                _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n', '                positionData.tokensOutstanding.add(numTokens)\n', '            ) || _checkCollateralization(collateralAmount, numTokens)),\n', '            "Insufficient collateral"\n', '        );\n', '\n', '        require(positionData.withdrawalRequestPassTimestamp == 0);\n', '        if (positionData.tokensOutstanding.isEqual(0)) {\n', '            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n', '            emit NewSponsor(msg.sender);\n', '        }\n', '\n', '        // Increase the position and global collateral balance by collateral amount.\n', '        _incrementCollateralBalances(positionData, collateralAmount);\n', '\n', "        // Add the number of tokens created to the position's outstanding tokens.\n", '        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n', '\n', '        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n', '\n', '        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n', '\n', "        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n", '        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n', '\n', '        // Note: revert reason removed to save bytecode.\n', '        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n', '    }\n', '\n', '    /**\n', '     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n', '     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n', '     * in order to account for precision loss. This contract must be approved to spend at least `numTokens` of\n', '     * `tokenCurrency`.\n', '     * @dev This contract must have the Burner role for the `tokenCurrency`.\n', '     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function redeem(FixedPoint.Unsigned memory numTokens)\n', '        public\n', '        notEmergencyShutdown()\n', '        noPendingWithdrawal(msg.sender)\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n', '\n', '        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n', '        FixedPoint.Unsigned memory collateralRedeemed =\n', '            fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n', '\n', '        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n', '        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n', '            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n', '        } else {\n', "            // Decrement the sponsor's collateral and global collateral amounts.\n", '            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n', '\n', '            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n', '            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n', '            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n', '            positionData.tokensOutstanding = newTokenCount;\n', '\n', '            // Update the totalTokensOutstanding after redemption.\n', '            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n', '        }\n', '\n', '        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n', '\n', '        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n', '        tokenCurrency.burn(numTokens.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Burns `numTokens` of `tokenCurrency` to decrease sponsors position size, without sending back `collateralCurrency`.\n', '     * This is done by a sponsor to increase position CR. Resulting size is bounded by minSponsorTokens.\n', '     * @dev Can only be called by token sponsor. This contract must be approved to spend `numTokens` of `tokenCurrency`.\n', '     * @dev This contract must have the Burner role for the `tokenCurrency`.\n', "     * @param numTokens is the number of tokens to be burnt from the sponsor's debt position.\n", '     */\n', '    function repay(FixedPoint.Unsigned memory numTokens)\n', '        public\n', '        notEmergencyShutdown()\n', '        noPendingWithdrawal(msg.sender)\n', '        fees()\n', '        nonReentrant()\n', '    {\n', '        PositionData storage positionData = _getPositionData(msg.sender);\n', '        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n', '\n', '        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n', '        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n', '        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n', '        positionData.tokensOutstanding = newTokenCount;\n', '\n', '        // Update the totalTokensOutstanding after redemption.\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n', '\n', '        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n', '\n', '        // Transfer the tokens back from the sponsor and burn them.\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n', '        tokenCurrency.burn(numTokens.rawValue);\n', '    }\n', '\n', '    /**\n', '     * @notice If the contract is emergency shutdown then all token holders and sponsors can redeem their tokens or\n', '     * remaining collateral for underlying at the prevailing price defined by a DVM vote.\n', '     * @dev This burns all tokens from the caller of `tokenCurrency` and sends back the resolved settlement value of\n', '     * `collateralCurrency`. Might not redeem the full proportional amount of collateral in order to account for\n', "     * precision loss. This contract must be approved to spend `tokenCurrency` at least up to the caller's full balance.\n", '     * @dev This contract must have the Burner role for the `tokenCurrency`.\n', '     * @dev Note that this function does not call the updateFundingRate modifier to update the funding rate as this\n', '     * function is only called after an emergency shutdown & there should be no funding rate updates after the shutdown.\n', '     * @return amountWithdrawn The actual amount of collateral withdrawn.\n', '     */\n', '    function settleEmergencyShutdown()\n', '        external\n', '        isEmergencyShutdown()\n', '        fees()\n', '        nonReentrant()\n', '        returns (FixedPoint.Unsigned memory amountWithdrawn)\n', '    {\n', '        // Set the emergency shutdown price as resolved from the DVM. If DVM has not resolved will revert.\n', '        if (emergencyShutdownPrice.isEqual(FixedPoint.fromUnscaledUint(0))) {\n', '            emergencyShutdownPrice = _getOracleEmergencyShutdownPrice();\n', '        }\n', '\n', "        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n", '        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n', '        FixedPoint.Unsigned memory totalRedeemableCollateral =\n', '            _getFundingRateAppliedTokenDebt(tokensToRedeem).mul(emergencyShutdownPrice);\n', '\n', '        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n', '        PositionData storage positionData = positions[msg.sender];\n', '        if (_getFeeAdjustedCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n', '            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying with\n', '            // the funding rate applied to the outstanding token debt.\n', '\n', '            FixedPoint.Unsigned memory tokenDebtValueInCollateral =\n', '                _getFundingRateAppliedTokenDebt(positionData.tokensOutstanding).mul(emergencyShutdownPrice);\n', '            FixedPoint.Unsigned memory positionCollateral = _getFeeAdjustedCollateral(positionData.rawCollateral);\n', '\n', '            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n', '            FixedPoint.Unsigned memory positionRedeemableCollateral =\n', '                tokenDebtValueInCollateral.isLessThan(positionCollateral)\n', '                    ? positionCollateral.sub(tokenDebtValueInCollateral)\n', '                    : FixedPoint.Unsigned(0);\n', '\n', '            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n', '            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n', '\n', '            // Reset the position state as all the value has been removed after settlement.\n', '            delete positions[msg.sender];\n', '            emit EndedSponsorPosition(msg.sender);\n', '        }\n', '\n', '        // Take the min of the remaining collateral and the collateral "owed". If the contract is undercapitalized,\n', '        // the caller will get as much collateral as the contract can pay out.\n', '        FixedPoint.Unsigned memory payout =\n', '            FixedPoint.min(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalRedeemableCollateral);\n', '\n', '        // Decrement total contract collateral and outstanding debt.\n', '        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n', '\n', '        emit SettleEmergencyShutdown(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n', '\n', '        // Transfer tokens & collateral and burn the redeemed tokens.\n', '        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n', '        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n', '        tokenCurrency.burn(tokensToRedeem.rawValue);\n', '    }\n', '\n', '    /****************************************\n', '     *        GLOBAL STATE FUNCTIONS        *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Premature contract settlement under emergency circumstances.\n', '     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n', '     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n', '     * to occur via the `settleEmergencyShutdown` function.\n', '     */\n', '    function emergencyShutdown() external override notEmergencyShutdown() fees() nonReentrant() {\n', '        // Note: revert reason removed to save bytecode.\n', '        require(msg.sender == _getFinancialContractsAdminAddress());\n', '\n', '        emergencyShutdownTimestamp = getCurrentTime();\n', '        _requestOraclePrice(emergencyShutdownTimestamp);\n', '\n', '        emit EmergencyShutdown(msg.sender, emergencyShutdownTimestamp);\n', '    }\n', '\n', '    /**\n', '     * @notice Theoretically supposed to pay fees and move money between margin accounts to make sure they\n', "     * reflect the NAV of the contract. However, this functionality doesn't apply to this contract.\n", '     * @dev This is supposed to be implemented by any contract that inherits `AdministrateeInterface` and callable\n', '     * only by the Governor contract. This method is therefore minimally implemented in this contract and does nothing.\n', '     */\n', '    function remargin() external override {\n', '        return;\n', '    }\n', '\n', '    /**\n', "     * @notice Accessor method for a sponsor's collateral.\n", '     * @dev This is necessary because the struct returned by the positions() method shows\n', "     * rawCollateral, which isn't a user-readable value.\n", '     * @dev TODO: This method does not account for any pending regular fees that have not yet been withdrawn\n', '     * from this contract, for example if the `lastPaymentTime != currentTime`. Future work should be to add\n', '     * logic to this method to account for any such pending fees.\n', '     * @param sponsor address whose collateral amount is retrieved.\n', '     * @return collateralAmount amount of collateral within a sponsors position.\n', '     */\n', '    function getCollateral(address sponsor)\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (FixedPoint.Unsigned memory collateralAmount)\n', '    {\n', '        // Note: do a direct access to avoid the validity check.\n', '        return _getFeeAdjustedCollateral(positions[sponsor].rawCollateral);\n', '    }\n', '\n', '    /**\n', '     * @notice Accessor method for the total collateral stored within the PerpetualPositionManager.\n', '     * @return totalCollateral amount of all collateral within the position manager.\n', '     */\n', '    function totalPositionCollateral()\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (FixedPoint.Unsigned memory totalCollateral)\n', '    {\n', '        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '    }\n', '\n', '    function getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\n', '        external\n', '        view\n', '        nonReentrantView()\n', '        returns (FixedPoint.Unsigned memory totalCollateral)\n', '    {\n', '        return _getFundingRateAppliedTokenDebt(rawTokenDebt);\n', '    }\n', '\n', '    /****************************************\n', '     *          INTERNAL FUNCTIONS          *\n', '     ****************************************/\n', '\n', "    // Reduces a sponsor's position and global counters by the specified parameters. Handles deleting the entire\n", '    // position if the entire position is being removed. Does not make any external transfers.\n', '    function _reduceSponsorPosition(\n', '        address sponsor,\n', '        FixedPoint.Unsigned memory tokensToRemove,\n', '        FixedPoint.Unsigned memory collateralToRemove,\n', '        FixedPoint.Unsigned memory withdrawalAmountToRemove\n', '    ) internal {\n', '        PositionData storage positionData = _getPositionData(sponsor);\n', '\n', '        // If the entire position is being removed, delete it instead.\n', '        if (\n', '            tokensToRemove.isEqual(positionData.tokensOutstanding) &&\n', '            _getFeeAdjustedCollateral(positionData.rawCollateral).isEqual(collateralToRemove)\n', '        ) {\n', '            _deleteSponsorPosition(sponsor);\n', '            return;\n', '        }\n', '\n', "        // Decrement the sponsor's collateral and global collateral amounts.\n", '        _decrementCollateralBalances(positionData, collateralToRemove);\n', '\n', '        // Ensure that the sponsor will meet the min position size after the reduction.\n', '        positionData.tokensOutstanding = positionData.tokensOutstanding.sub(tokensToRemove);\n', '        require(positionData.tokensOutstanding.isGreaterThanOrEqual(minSponsorTokens));\n', '\n', "        // Decrement the position's withdrawal amount.\n", '        positionData.withdrawalRequestAmount = positionData.withdrawalRequestAmount.sub(withdrawalAmountToRemove);\n', '\n', '        // Decrement the total outstanding tokens in the overall contract.\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove);\n', '    }\n', '\n', "    // Deletes a sponsor's position and updates global counters. Does not make any external transfers.\n", '    function _deleteSponsorPosition(address sponsor) internal returns (FixedPoint.Unsigned memory) {\n', '        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n', '\n', '        FixedPoint.Unsigned memory startingGlobalCollateral = _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '\n', '        // Remove the collateral and outstanding from the overall total position.\n', '        rawTotalPositionCollateral = rawTotalPositionCollateral.sub(positionToLiquidate.rawCollateral);\n', '        totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding);\n', '\n', '        // Reset the sponsors position to have zero outstanding and collateral.\n', '        delete positions[sponsor];\n', '\n', '        emit EndedSponsorPosition(sponsor);\n', '\n', '        // Return fee-adjusted amount of collateral deleted from position.\n', '        return startingGlobalCollateral.sub(_getFeeAdjustedCollateral(rawTotalPositionCollateral));\n', '    }\n', '\n', '    function _pfc() internal view virtual override returns (FixedPoint.Unsigned memory) {\n', '        return _getFeeAdjustedCollateral(rawTotalPositionCollateral);\n', '    }\n', '\n', '    function _getPositionData(address sponsor)\n', '        internal\n', '        view\n', '        onlyCollateralizedPosition(sponsor)\n', '        returns (PositionData storage)\n', '    {\n', '        return positions[sponsor];\n', '    }\n', '\n', '    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n', '        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n', '    }\n', '\n', '    function _getOracle() internal view returns (OracleInterface) {\n', '        return OracleInterface(finder.getImplementationAddress(OracleInterfaces.Oracle));\n', '    }\n', '\n', '    function _getFinancialContractsAdminAddress() internal view returns (address) {\n', '        return finder.getImplementationAddress(OracleInterfaces.FinancialContractsAdmin);\n', '    }\n', '\n', '    // Requests a price for `priceIdentifier` at `requestedTime` from the Oracle.\n', '    function _requestOraclePrice(uint256 requestedTime) internal {\n', '        _getOracle().requestPrice(priceIdentifier, requestedTime);\n', '    }\n', '\n', "    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\n", '    function _getOraclePrice(uint256 requestedTime) internal view returns (FixedPoint.Unsigned memory price) {\n', '        // Create an instance of the oracle and get the price. If the price is not resolved revert.\n', '        int256 oraclePrice = _getOracle().getPrice(priceIdentifier, requestedTime);\n', '\n', "        // For now we don't want to deal with negative prices in positions.\n", '        if (oraclePrice < 0) {\n', '            oraclePrice = 0;\n', '        }\n', '        return FixedPoint.Unsigned(uint256(oraclePrice));\n', '    }\n', '\n', "    // Fetches a resolved Oracle price from the Oracle. Reverts if the Oracle hasn't resolved for this request.\n", '    function _getOracleEmergencyShutdownPrice() internal view returns (FixedPoint.Unsigned memory) {\n', '        return _getOraclePrice(emergencyShutdownTimestamp);\n', '    }\n', '\n', '    // Reset withdrawal request by setting the withdrawal request and withdrawal timestamp to 0.\n', '    function _resetWithdrawalRequest(PositionData storage positionData) internal {\n', '        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n', '        positionData.withdrawalRequestPassTimestamp = 0;\n', '    }\n', '\n', '    // Ensure individual and global consistency when increasing collateral balances. Returns the change to the position.\n', '    function _incrementCollateralBalances(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _addCollateral(positionData.rawCollateral, collateralAmount);\n', '        return _addCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the\n', '    // position. We elect to return the amount that the global collateral is decreased by, rather than the individual\n', "    // position's collateral, because we need to maintain the invariant that the global collateral is always\n", '    // <= the collateral owned by the contract to avoid reverts on withdrawals. The amount returned = amount withdrawn.\n', '    function _decrementCollateralBalances(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _removeCollateral(positionData.rawCollateral, collateralAmount);\n', '        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // Ensure individual and global consistency when decrementing collateral balances. Returns the change to the position.\n', '    // This function is similar to the _decrementCollateralBalances function except this function checks position GCR\n', '    // between the decrements. This ensures that collateral removal will not leave the position undercollateralized.\n', '    function _decrementCollateralBalancesCheckGCR(\n', '        PositionData storage positionData,\n', '        FixedPoint.Unsigned memory collateralAmount\n', '    ) internal returns (FixedPoint.Unsigned memory) {\n', '        _removeCollateral(positionData.rawCollateral, collateralAmount);\n', '        require(_checkPositionCollateralization(positionData), "CR below GCR");\n', '        return _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n', '    }\n', '\n', '    // These internal functions are supposed to act identically to modifiers, but re-used modifiers\n', '    // unnecessarily increase contract bytecode size.\n', '    // source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n', '    function _onlyCollateralizedPosition(address sponsor) internal view {\n', '        require(_getFeeAdjustedCollateral(positions[sponsor].rawCollateral).isGreaterThan(0));\n', '    }\n', '\n', '    // Note: This checks whether an already existing position has a pending withdrawal. This cannot be used on the\n', '    // `create` method because it is possible that `create` is called on a new position (i.e. one without any collateral\n', '    // or tokens outstanding) which would fail the `onlyCollateralizedPosition` modifier on `_getPositionData`.\n', '    function _positionHasNoPendingWithdrawal(address sponsor) internal view {\n', '        require(_getPositionData(sponsor).withdrawalRequestPassTimestamp == 0);\n', '    }\n', '\n', '    /****************************************\n', '     *          PRIVATE FUNCTIONS          *\n', '     ****************************************/\n', '\n', '    function _checkPositionCollateralization(PositionData storage positionData) private view returns (bool) {\n', '        return\n', '            _checkCollateralization(\n', '                _getFeeAdjustedCollateral(positionData.rawCollateral),\n', '                positionData.tokensOutstanding\n', '            );\n', '    }\n', '\n', '    // Checks whether the provided `collateral` and `numTokens` have a collateralization ratio above the global\n', '    // collateralization ratio.\n', '    function _checkCollateralization(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        FixedPoint.Unsigned memory global =\n', '            _getCollateralizationRatio(_getFeeAdjustedCollateral(rawTotalPositionCollateral), totalTokensOutstanding);\n', '        FixedPoint.Unsigned memory thisChange = _getCollateralizationRatio(collateral, numTokens);\n', '        return !global.isGreaterThan(thisChange);\n', '    }\n', '\n', '    function _getCollateralizationRatio(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n', '        private\n', '        pure\n', '        returns (FixedPoint.Unsigned memory ratio)\n', '    {\n', '        return numTokens.isLessThanOrEqual(0) ? FixedPoint.fromUnscaledUint(0) : collateral.div(numTokens);\n', '    }\n', '\n', '    function _getTokenAddress() internal view override returns (address) {\n', '        return address(tokenCurrency);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title Stores common interface names used throughout the DVM by registration in the Finder.\n', ' */\n', 'library OracleInterfaces {\n', '    bytes32 public constant Oracle = "Oracle";\n', '    bytes32 public constant IdentifierWhitelist = "IdentifierWhitelist";\n', '    bytes32 public constant Store = "Store";\n', '    bytes32 public constant FinancialContractsAdmin = "FinancialContractsAdmin";\n', '    bytes32 public constant Registry = "Registry";\n', '    bytes32 public constant CollateralWhitelist = "CollateralWhitelist";\n', '    bytes32 public constant OptimisticOracle = "OptimisticOracle";\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../interfaces/FinderInterface.sol";\n', 'import "../../common/implementation/AddressWhitelist.sol";\n', 'import "./Registry.sol";\n', 'import "./Constants.sol";\n', '\n', '/**\n', ' * @title Base contract for all financial contract creators\n', ' */\n', 'abstract contract ContractCreator {\n', '    address internal finderAddress;\n', '\n', '    constructor(address _finderAddress) public {\n', '        finderAddress = _finderAddress;\n', '    }\n', '\n', '    function _requireWhitelistedCollateral(address collateralAddress) internal view {\n', '        FinderInterface finder = FinderInterface(finderAddress);\n', '        AddressWhitelist collateralWhitelist =\n', '            AddressWhitelist(finder.getImplementationAddress(OracleInterfaces.CollateralWhitelist));\n', '        require(collateralWhitelist.isOnWhitelist(collateralAddress), "Collateral not whitelisted");\n', '    }\n', '\n', '    function _registerContract(address[] memory parties, address contractToRegister) internal {\n', '        FinderInterface finder = FinderInterface(finderAddress);\n', '        Registry registry = Registry(finder.getImplementationAddress(OracleInterfaces.Registry));\n', '        registry.registerContract(parties, contractToRegister);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../../common/implementation/MultiRole.sol";\n', 'import "../interfaces/RegistryInterface.sol";\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', '/**\n', ' * @title Registry for financial contracts and approved financial contract creators.\n', ' * @dev Maintains a whitelist of financial contract creators that are allowed\n', ' * to register new financial contracts and stores party members of a financial contract.\n', ' */\n', 'contract Registry is RegistryInterface, MultiRole {\n', '    using SafeMath for uint256;\n', '\n', '    /****************************************\n', '     *    INTERNAL VARIABLES AND STORAGE    *\n', '     ****************************************/\n', '\n', '    enum Roles {\n', '        Owner, // The owner manages the set of ContractCreators.\n', '        ContractCreator // Can register financial contracts.\n', '    }\n', '\n', '    // This enum is required because a `WasValid` state is required\n', '    // to ensure that financial contracts cannot be re-registered.\n', '    enum Validity { Invalid, Valid }\n', '\n', '    // Local information about a contract.\n', '    struct FinancialContract {\n', '        Validity valid;\n', '        uint128 index;\n', '    }\n', '\n', '    struct Party {\n', '        address[] contracts; // Each financial contract address is stored in this array.\n', '        // The address of each financial contract is mapped to its index for constant time look up and deletion.\n', '        mapping(address => uint256) contractIndex;\n', '    }\n', '\n', '    // Array of all contracts that are approved to use the UMA Oracle.\n', '    address[] public registeredContracts;\n', '\n', '    // Map of financial contract contracts to the associated FinancialContract struct.\n', '    mapping(address => FinancialContract) public contractMap;\n', '\n', '    // Map each party member to their their associated Party struct.\n', '    mapping(address => Party) private partyMap;\n', '\n', '    /****************************************\n', '     *                EVENTS                *\n', '     ****************************************/\n', '\n', '    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n', '    event PartyAdded(address indexed contractAddress, address indexed party);\n', '    event PartyRemoved(address indexed contractAddress, address indexed party);\n', '\n', '    /**\n', '     * @notice Construct the Registry contract.\n', '     */\n', '    constructor() public {\n', '        _createExclusiveRole(uint256(Roles.Owner), uint256(Roles.Owner), msg.sender);\n', '        // Start with no contract creators registered.\n', '        _createSharedRole(uint256(Roles.ContractCreator), uint256(Roles.Owner), new address[](0));\n', '    }\n', '\n', '    /****************************************\n', '     *        REGISTRATION FUNCTIONS        *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Registers a new financial contract.\n', '     * @dev Only authorized contract creators can call this method.\n', '     * @param parties array of addresses who become parties in the contract.\n', '     * @param contractAddress address of the contract against which the parties are registered.\n', '     */\n', '    function registerContract(address[] calldata parties, address contractAddress)\n', '        external\n', '        override\n', '        onlyRoleHolder(uint256(Roles.ContractCreator))\n', '    {\n', '        FinancialContract storage financialContract = contractMap[contractAddress];\n', '        require(contractMap[contractAddress].valid == Validity.Invalid, "Can only register once");\n', '\n', '        // Store contract address as a registered contract.\n', '        registeredContracts.push(contractAddress);\n', '\n', '        // No length check necessary because we should never hit (2^127 - 1) contracts.\n', '        financialContract.index = uint128(registeredContracts.length.sub(1));\n', '\n', "        // For all parties in the array add them to the contract's parties.\n", '        financialContract.valid = Validity.Valid;\n', '        for (uint256 i = 0; i < parties.length; i = i.add(1)) {\n', '            _addPartyToContract(parties[i], contractAddress);\n', '        }\n', '\n', '        emit NewContractRegistered(contractAddress, msg.sender, parties);\n', '    }\n', '\n', '    /**\n', '     * @notice Adds a party member to the calling contract.\n', '     * @dev msg.sender will be used to determine the contract that this party is added to.\n', '     * @param party new party for the calling contract.\n', '     */\n', '    function addPartyToContract(address party) external override {\n', '        address contractAddress = msg.sender;\n', '        require(contractMap[contractAddress].valid == Validity.Valid, "Can only add to valid contract");\n', '\n', '        _addPartyToContract(party, contractAddress);\n', '    }\n', '\n', '    /**\n', '     * @notice Removes a party member from the calling contract.\n', '     * @dev msg.sender will be used to determine the contract that this party is removed from.\n', '     * @param partyAddress address to be removed from the calling contract.\n', '     */\n', '    function removePartyFromContract(address partyAddress) external override {\n', '        address contractAddress = msg.sender;\n', '        Party storage party = partyMap[partyAddress];\n', '        uint256 numberOfContracts = party.contracts.length;\n', '\n', '        require(numberOfContracts != 0, "Party has no contracts");\n', '        require(contractMap[contractAddress].valid == Validity.Valid, "Remove only from valid contract");\n', '        require(isPartyMemberOfContract(partyAddress, contractAddress), "Can only remove existing party");\n', '\n', '        // Index of the current location of the contract to remove.\n', '        uint256 deleteIndex = party.contractIndex[contractAddress];\n', '\n', "        // Store the last contract's address to update the lookup map.\n", '        address lastContractAddress = party.contracts[numberOfContracts - 1];\n', '\n', '        // Swap the contract to be removed with the last contract.\n', '        party.contracts[deleteIndex] = lastContractAddress;\n', '\n', '        // Update the lookup index with the new location.\n', '        party.contractIndex[lastContractAddress] = deleteIndex;\n', '\n', '        // Pop the last contract from the array and update the lookup map.\n', '        party.contracts.pop();\n', '        delete party.contractIndex[contractAddress];\n', '\n', '        emit PartyRemoved(contractAddress, partyAddress);\n', '    }\n', '\n', '    /****************************************\n', '     *         REGISTRY STATE GETTERS       *\n', '     ****************************************/\n', '\n', '    /**\n', '     * @notice Returns whether the contract has been registered with the registry.\n', '     * @dev If it is registered, it is an authorized participant in the UMA system.\n', '     * @param contractAddress address of the financial contract.\n', '     * @return bool indicates whether the contract is registered.\n', '     */\n', '    function isContractRegistered(address contractAddress) external view override returns (bool) {\n', '        return contractMap[contractAddress].valid == Validity.Valid;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns a list of all contracts that are associated with a particular party.\n', '     * @param party address of the party.\n', '     * @return an array of the contracts the party is registered to.\n', '     */\n', '    function getRegisteredContracts(address party) external view override returns (address[] memory) {\n', '        return partyMap[party].contracts;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns all registered contracts.\n', '     * @return all registered contract addresses within the system.\n', '     */\n', '    function getAllRegisteredContracts() external view override returns (address[] memory) {\n', '        return registeredContracts;\n', '    }\n', '\n', '    /**\n', '     * @notice checks if an address is a party of a contract.\n', '     * @param party party to check.\n', '     * @param contractAddress address to check against the party.\n', '     * @return bool indicating if the address is a party of the contract.\n', '     */\n', '    function isPartyMemberOfContract(address party, address contractAddress) public view override returns (bool) {\n', '        uint256 index = partyMap[party].contractIndex[contractAddress];\n', '        return partyMap[party].contracts.length > index && partyMap[party].contracts[index] == contractAddress;\n', '    }\n', '\n', '    /****************************************\n', '     *           INTERNAL FUNCTIONS         *\n', '     ****************************************/\n', '\n', '    function _addPartyToContract(address party, address contractAddress) internal {\n', '        require(!isPartyMemberOfContract(party, contractAddress), "Can only register a party once");\n', '        uint256 contractIndex = partyMap[party].contracts.length;\n', '        partyMap[party].contracts.push(contractAddress);\n', '        partyMap[party].contractIndex[contractAddress] = contractIndex;\n', '\n', '        emit PartyAdded(contractAddress, party);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../../common/implementation/FixedPoint.sol";\n', '\n', '/**\n', ' * @title Interface that all financial contracts expose to the admin.\n', ' */\n', 'interface AdministrateeInterface {\n', '    /**\n', '     * @notice Initiates the shutdown process, in case of an emergency.\n', '     */\n', '    function emergencyShutdown() external;\n', '\n', '    /**\n', '     * @notice A core contract method called independently or as a part of other financial contract transactions.\n', '     * @dev It pays fees and moves money between margin accounts to make sure they reflect the NAV of the contract.\n', '     */\n', '    function remargin() external;\n', '\n', '    /**\n', '     * @notice Gets the current profit from corruption for this contract in terms of the collateral currency.\n', '     * @dev This is equivalent to the collateral pool available from which to pay fees. Therefore, derived contracts are\n', '     * expected to implement this so that pay-fee methods can correctly compute the owed fees as a % of PfC.\n', '     * @return pfc value for equal to the current profit from corruption denominated in collateral currency.\n', '     */\n', '    function pfc() external view returns (FixedPoint.Unsigned memory);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title Provides addresses of the live contracts implementing certain interfaces.\n', ' * @dev Examples are the Oracle or Store interfaces.\n', ' */\n', 'interface FinderInterface {\n', '    /**\n', '     * @notice Updates the address of the contract that implements `interfaceName`.\n', '     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n', '     * @param implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n', '\n', '    /**\n', '     * @notice Gets the address of the contract that implements the given `interfaceName`.\n', '     * @param interfaceName queried interface.\n', '     * @return implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n', ' */\n', 'interface IdentifierWhitelistInterface {\n', '    /**\n', '     * @notice Adds the provided identifier as a supported identifier.\n', '     * @dev Price requests using this identifier will succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function addSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Removes the identifier from the whitelist.\n', '     * @dev Price requests using this identifier will no longer succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function removeSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Checks whether an identifier is on the whitelist.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     * @return bool if the identifier is supported (or not).\n', '     */\n', '    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', '/**\n', ' * @title Financial contract facing Oracle interface.\n', ' * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n', ' */\n', 'abstract contract OptimisticOracleInterface {\n', '    // Struct representing the state of a price request.\n', '    enum State {\n', '        Invalid, // Never requested.\n', '        Requested, // Requested, no other actions taken.\n', '        Proposed, // Proposed, but not expired or disputed yet.\n', '        Expired, // Proposed, not disputed, past liveness.\n', '        Disputed, // Disputed, but no DVM price returned yet.\n', '        Resolved, // Disputed and DVM price is available.\n', '        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n', '    }\n', '\n', '    // Struct representing a price request.\n', '    struct Request {\n', '        address proposer; // Address of the proposer.\n', '        address disputer; // Address of the disputer.\n', '        IERC20 currency; // ERC20 token used to pay rewards and fees.\n', '        bool settled; // True if the request is settled.\n', '        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n', '        int256 proposedPrice; // Price that the proposer submitted.\n', '        int256 resolvedPrice; // Price resolved once the request is settled.\n', '        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n', '        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n', '        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n', '        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n', '        uint256 customLiveness; // Custom liveness value set by the requester.\n', '    }\n', '\n', "    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n", '    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n', '    // to accept a price request made with ancillary data length of a certain size.\n', '    uint256 public constant ancillaryBytesLimit = 8192;\n', '\n', '    /**\n', '     * @notice Requests a new price.\n', '     * @param identifier price identifier being requested.\n', '     * @param timestamp timestamp of the price being requested.\n', '     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n', '     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n', '     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n', '     *               which could make sense if the contract requests and proposes the value in the same call or\n', '     *               provides its own reward system.\n', '     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n', '     * This can be changed with a subsequent call to setBond().\n', '     */\n', '    function requestPrice(\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData,\n', '        IERC20 currency,\n', '        uint256 reward\n', '    ) external virtual returns (uint256 totalBond);\n', '\n', '    /**\n', '     * @notice Set the proposal bond associated with a price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @param bond custom bond amount to set.\n', '     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n', '     * changed again with a subsequent call to setBond().\n', '     */\n', '    function setBond(\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData,\n', '        uint256 bond\n', '    ) external virtual returns (uint256 totalBond);\n', '\n', '    /**\n', '     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to "hedge" the caller\n', "     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n", '     * bond, so there is still profit to be made even if the reward is refunded.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     */\n', '    function setRefundOnDispute(\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) external virtual;\n', '\n', '    /**\n', '     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n', '     * being auto-resolved.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @param customLiveness new custom liveness.\n', '     */\n', '    function setCustomLiveness(\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData,\n', '        uint256 customLiveness\n', '    ) external virtual;\n', '\n', '    /**\n', "     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n", '     * from this proposal. However, any bonds are pulled from the caller.\n', '     * @param proposer address to set as the proposer.\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @param proposedPrice price being proposed.\n', "     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n", '     * the proposer once settled if the proposal is correct.\n', '     */\n', '    function proposePriceFor(\n', '        address proposer,\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData,\n', '        int256 proposedPrice\n', '    ) public virtual returns (uint256 totalBond);\n', '\n', '    /**\n', '     * @notice Proposes a price value for an existing price request.\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @param proposedPrice price being proposed.\n', "     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n", '     * the proposer once settled if the proposal is correct.\n', '     */\n', '    function proposePrice(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData,\n', '        int256 proposedPrice\n', '    ) external virtual returns (uint256 totalBond);\n', '\n', '    /**\n', "     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n", '     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n', '     * @param disputer address to set as the disputer.\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', "     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n", '     * the disputer once settled if the dispute was value (the proposal was incorrect).\n', '     */\n', '    function disputePriceFor(\n', '        address disputer,\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) public virtual returns (uint256 totalBond);\n', '\n', '    /**\n', '     * @notice Disputes a price value for an existing price request with an active proposal.\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', "     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n", '     * the disputer once settled if the dispute was valid (the proposal was incorrect).\n', '     */\n', '    function disputePrice(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) external virtual returns (uint256 totalBond);\n', '\n', '    /**\n', '     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n', '     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n', "     * hasn't been settled.\n", '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @return resolved price.\n', '     */\n', '    function getPrice(\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) external virtual returns (int256);\n', '\n', '    /**\n', "     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n", '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @return payout the amount that the "winner" (proposer or disputer) receives on settlement. This amount includes\n', '     * the returned bonds as well as additional rewards.\n', '     */\n', '    function settle(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) external virtual returns (uint256 payout);\n', '\n', '    /**\n', '     * @notice Gets the current data structure containing all information about a price request.\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @return the Request data structure.\n', '     */\n', '    function getRequest(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) public view virtual returns (Request memory);\n', '\n', '    function getState(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) public view virtual returns (State);\n', '\n', '    /**\n', '     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n', '     * @param requester sender of the initial price request.\n', '     * @param identifier price identifier to identify the existing request.\n', '     * @param timestamp timestamp to identify the existing request.\n', '     * @param ancillaryData ancillary data of the price being requested.\n', '     * @return the State.\n', '     */\n', '    function hasPrice(\n', '        address requester,\n', '        bytes32 identifier,\n', '        uint256 timestamp,\n', '        bytes memory ancillaryData\n', '    ) public view virtual returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title Financial contract facing Oracle interface.\n', ' * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n', ' */\n', 'abstract contract OracleInterface {\n', '    /**\n', "     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n", '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     */\n', '    function requestPrice(bytes32 identifier, uint256 time) public virtual;\n', '\n', '    /**\n', '     * @notice Whether the price for `identifier` and `time` is available.\n', '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n', '     */\n', '    function hasPrice(bytes32 identifier, uint256 time) public view virtual returns (bool);\n', '\n', '    /**\n', '     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n', '     * @dev If the price is not available, the method reverts.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @return int256 representing the resolved price for the given identifier and timestamp.\n', '     */\n', '    function getPrice(bytes32 identifier, uint256 time) public view virtual returns (int256);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Interface for a registry of contracts and contract creators.\n', ' */\n', 'interface RegistryInterface {\n', '    /**\n', '     * @notice Registers a new contract.\n', '     * @dev Only authorized contract creators can call this method.\n', '     * @param parties an array of addresses who become parties in the contract.\n', '     * @param contractAddress defines the address of the deployed contract.\n', '     */\n', '    function registerContract(address[] calldata parties, address contractAddress) external;\n', '\n', '    /**\n', '     * @notice Returns whether the contract has been registered with the registry.\n', '     * @dev If it is registered, it is an authorized participant in the UMA system.\n', '     * @param contractAddress address of the contract.\n', '     * @return bool indicates whether the contract is registered.\n', '     */\n', '    function isContractRegistered(address contractAddress) external view returns (bool);\n', '\n', '    /**\n', '     * @notice Returns a list of all contracts that are associated with a particular party.\n', '     * @param party address of the party.\n', '     * @return an array of the contracts the party is registered to.\n', '     */\n', '    function getRegisteredContracts(address party) external view returns (address[] memory);\n', '\n', '    /**\n', '     * @notice Returns all registered contracts.\n', '     * @return all registered contract addresses within the system.\n', '     */\n', '    function getAllRegisteredContracts() external view returns (address[] memory);\n', '\n', '    /**\n', '     * @notice Adds a party to the calling contract.\n', '     * @dev msg.sender must be the contract to which the party member is added.\n', '     * @param party address to be added to the contract.\n', '     */\n', '    function addPartyToContract(address party) external;\n', '\n', '    /**\n', '     * @notice Removes a party member to the calling contract.\n', '     * @dev msg.sender must be the contract to which the party member is added.\n', '     * @param party address to be removed from the contract.\n', '     */\n', '    function removePartyFromContract(address party) external;\n', '\n', '    /**\n', '     * @notice checks if an address is a party in a contract.\n', '     * @param party party to check.\n', '     * @param contractAddress address to check against the party.\n', '     * @return bool indicating if the address is a party of the contract.\n', '     */\n', '    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "../../common/implementation/FixedPoint.sol";\n', '\n', '/**\n', ' * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\n', ' */\n', 'interface StoreInterface {\n', '    /**\n', '     * @notice Pays Oracle fees in ETH to the store.\n', '     * @dev To be used by contracts whose margin currency is ETH.\n', '     */\n', '    function payOracleFees() external payable;\n', '\n', '    /**\n', '     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\n', '     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\n', '     * @param erc20Address address of the ERC20 token used to pay the fee.\n', '     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\n', '     */\n', '    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\n', '\n', '    /**\n', '     * @notice Computes the regular oracle fees that a contract should pay for a period.\n', '     * @param startTime defines the beginning time from which the fee is paid.\n', '     * @param endTime end time until which the fee is paid.\n', '     * @param pfc "profit from corruption", or the maximum amount of margin currency that a\n', '     * token sponsor could extract from the contract through corrupting the price feed in their favor.\n', '     * @return regularFee amount owed for the duration from start to end time for the given pfc.\n', '     * @return latePenalty for paying the fee after the deadline.\n', '     */\n', '    function computeRegularFee(\n', '        uint256 startTime,\n', '        uint256 endTime,\n', '        FixedPoint.Unsigned calldata pfc\n', '    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\n', '\n', '    /**\n', '     * @notice Computes the final oracle fees that a contract should pay at settlement.\n', '     * @param currency token used to pay the final fee.\n', '     * @return finalFee amount due.\n', '     */\n', '    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../GSN/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title SignedSafeMath\n', ' * @dev Signed math operations with safety checks that revert on error.\n', ' */\n', 'library SignedSafeMath {\n', '    int256 constant private _INT256_MIN = -2**255;\n', '\n', '    /**\n', '     * @dev Multiplies two signed integers, reverts on overflow.\n', '     */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b, "SignedSafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "SignedSafeMath: division by zero");\n', '        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two signed integers, reverts on overflow.\n', '     */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two signed integers, reverts on overflow.\n', '     */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../../GSN/Context.sol";\n', 'import "./IERC20.sol";\n', 'import "../../math/SafeMath.sol";\n', 'import "../../utils/Address.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20MinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "../../math/SafeMath.sol";\n', 'import "../../utils/Address.sol";\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}']