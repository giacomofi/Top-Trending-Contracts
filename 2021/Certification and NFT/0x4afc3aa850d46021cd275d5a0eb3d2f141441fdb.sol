['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC1155.sol";\n', 'import "./IERC1155TokenReceiver.sol";\n', 'import "./Ownable.sol";\n', 'import "./Address.sol";\n', '\n', '// sns: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]\n', '// ids:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n', '// fertilities:[1,2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000]\n', '// carries:[0,0,0,0,0,0,10,20,50,100,300,1000,1,2,5,10,30,100]\n', '\n', 'interface MiningPool{\n', '    \n', '    function users(address userAddress) external view returns(uint256 id,uint256 investment,uint256 freezeTime);\n', '    \n', '    function balanceOf(address userAddress) external view returns (address[2] memory,uint256[2] memory balances);\n', '    \n', '    function totalSupply() external view returns (uint256);\n', '    \n', '    function stakeAmount() external view returns (uint256);\n', '    \n', '    function duration() external view returns (uint256);\n', '    \n', '    function token() external view returns (address);\n', '    \n', '    function deposit(uint256[2] calldata amounts) external returns(bool);\n', '    \n', '    function allot(address userAddress,uint256[2] calldata amounts) external returns(bool);\n', '    \n', '    function lock(address holder, address locker, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n', '    \n', '    function lockStatus(address userAddress) external view returns(bool);\n', '}\n', '\n', 'interface IUniswapPair {\n', '    \n', '    function setFeeOwner(address _feeOwner) external;\n', '}\n', '\n', 'interface IUniswapFactory {\n', '    \n', '    function getPair(address token0,address token1) external returns(address);\n', '}\n', '\n', 'abstract contract ERC1155TokenReceiver is IERC1155TokenReceiver{\n', '    \n', '    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n', '    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n', '    \n', '    //-------------------------------------ERC1155---------------------------------------------------------------------\n', '    \n', '    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external override returns(bytes4) {\n', '        uint256[] memory _values = new uint256[](1);\n', '        uint256[] memory _ids = new uint256[](1);\n', '        _ids[0] = _id;\n', '        _values[0] = _value;\n', '        \n', '        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\n', '        return ERC1155_RECEIVED_VALUE;\n', '    }\n', '\n', '    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external override returns(bytes4) {\n', '        operateToken1155(msg.sender,_operator,_from,_ids,_values,_data);\n', '        return ERC1155_BATCH_RECEIVED_VALUE;\n', '    }\n', '\n', '    // ERC165 interface support\n', '    function supportsInterface(bytes4 interfaceID) external override pure returns (bool) {\n', '        return  interfaceID == 0x01ffc9a7 ||    // ERC165\n', '                interfaceID == 0x4e2312e0;      // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\n', '    }\n', '    \n', '    function operateToken1155(address msgSender, address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata _data) internal virtual;\n', '}\n', '\n', 'contract Config{\n', '    \n', '    uint256 public constant ONE_DAY = 1 days;\n', '    \n', '    uint256[10] public  RANKING_AWARD_PERCENT = [10,5,3,1,1,1,1,1,1,1];\n', '    \n', '    uint256 public constant LAST_STRAW_PERCNET = 5;\n', '    \n', '    uint256[2] public  OUT_RATE = [1,1];\n', '\n', '}\n', '\n', '\n', 'contract MiningCore is Config, Ownable, ERC1155TokenReceiver {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    constructor(MiningPool _pool,IERC1155 _token1155,address payable _developer) {\n', '        pool = _pool;\n', '        token1155 = _token1155;\n', '        developer = _developer;\n', '    }\n', '    \n', '    MiningPool public pool;\n', '    \n', '    IERC1155 public token1155;\n', '    \n', '    \n', '    uint256 public ORE_AMOUNT = 500000000;\n', '    \n', '    struct Record{\n', '        //提现状态\n', '        bool drawStatus;\n', '        //挖矿总量\n', '        uint256 digGross;\n', '        //最后一击\n', '        bool lastStraw;\n', '       \n', '        mapping(uint256=>uint256) disCars;\n', '    }\n', '    \n', '    struct Pair {\n', '        uint256[2] amounts;\n', '        //挖矿总量\n', '        uint256 complete;\n', '        //实际挖矿量\n', '        uint256 actual;\n', '        \n', '        address lastStraw;\n', '    }\n', '    \n', '    struct Car{\n', '        uint256 sn;\n', '        uint256 fertility;\n', '        uint256 carry;\n', '    }\n', '    \n', '    //address[] callHelper;\n', '    \n', '    address payable developer;\n', '    \n', '    uint256 public version;\n', '    \n', '    //User acquisition record\n', '    //mapping(uint256=>mapping(address=>bool)) public obtainLogs;\n', '    \n', '    mapping(uint256=>mapping(address=>Record)) public records;\n', '    \n', '    //Record of each mining period\n', '    mapping(uint256=>Pair) public history;\n', '    \n', '    //Daily output\n', '    mapping(uint256=>uint256) public dailyOutput;\n', '    \n', '    //The number corresponds to the carIndex\n', '    uint256[] public carIndex;\n', '    \n', '    //Each ID corresponds to a car attribute\n', '    mapping(uint256=>Car) public cars;\n', '    \n', '    mapping(uint256=> address[10]) public rank;\n', '    \n', '    event ObtainCar(address indexed userAddress,uint256 indexed _version,uint256 amount );\n', '    \n', '    event Mining(address indexed userAddress,uint256 indexed _version,uint256[] ,uint256[],uint256 amount);\n', '    \n', '    event WithdrawAward(address indexed userAddress,uint256 indexed _version,uint256[2] amounts);\n', '    \n', '    event UpdateRank(address indexed operator);\n', '    \n', '    event DeveloperFee(uint256 fee1,uint256 fee2);\n', '    \n', '    event SetCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry);\n', '    \n', '    event LastStraw(address indexed userAddress,uint256 _version,uint256,uint256,uint256);\n', '    \n', '    function init() public onlyOwner {\n', '        uint256[18] memory _ids = [uint256(1),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18];\n', '        uint256[18] memory _fertilities = [uint256(1),2,5,10,30,100,1,2,5,10,30,100,10,20,50,100,300,1000];\n', '        uint256[18] memory _carries = [uint256(0),0,0,0,0,0,10,20,50,100,300,1000,1,2,5,10,30,100];\n', '        setCarIndexs(_ids,_fertilities,_carries);\n', '    }\n', '\n', '     //Set vehicle properties\n', '    function setCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry) public onlyOwner{\n', '        if(sn+1>carIndex.length){\n', '            carIndex.push(id);\n', '            //callHelper.push(address(this));\n', '        }else{\n', '            carIndex[sn] = id;\n', '        }\n', '        \n', '        cars[id] = Car(sn,fertility,carry);\n', '        emit SetCarIndex( sn, id, fertility, carry);\n', '    }\n', '    \n', '    //Batch set vehicle properties\n', '    function setCarIndexs(uint256[18] memory ids,uint256[18] memory fertilities,uint256[18] memory carries) private {\n', '        for(uint256 i=0;i<ids.length;i++){\n', '            setCarIndex(i,ids[i],fertilities[i],carries[i]);\n', '        }\n', '    }\n', '    \n', '    function setFeeOwner(address _feeOwner,address factory) external  onlyOwner {\n', '        (address[2] memory tokens,) = pool.balanceOf(address(0));\n', '        address pair = IUniswapFactory(factory).getPair(tokens[0],tokens[1]);\n', '        IUniswapPair(pair).setFeeOwner(_feeOwner);\n', '    }\n', '    \n', '    \n', '    function setOracle(uint256 _ORE_AMOUNT) public onlyOwner {\n', '        ORE_AMOUNT = _ORE_AMOUNT;\n', '    }\n', '    \n', '    \n', '    function operateToken1155(address msgSender,address _operator, address _from, uint256[] memory _ids, uint256[] memory _values, bytes calldata) internal override virtual{\n', '        \n', '        require(address(token1155)==msgSender,"not allowed");\n', '        require(!Address.isContract(_operator),"Contract invocation is not allowed");\n', '       \n', '        if(_from!=address(0x0)){\n', '            mining(_from,_ids,_values);\n', '        }\n', '    }\n', '    \n', '\n', '    function obtainCar(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) public {\n', '        require(!pool.lockStatus(msg.sender),"Have been received");\n', '\t\t\n', '\t\t     (,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity) = cat(msg.sender);\n', '            \n', '             if(dailyOutput[pool.duration()]==0){\n', '                 dailyOutput[pool.duration()] = token1155Amount;\n', '             }\n', '        \n', '        // uint256[] memory carUsable = new uint256[](kinds());\n', '        // {\n', '        //     (,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity) = cat(msg.sender);\n', '            \n', '        //     if(dailyOutput[pool.duration()]==0){\n', '        //         dailyOutput[pool.duration()] = token1155Amount;\n', '        //     }\n', '        \n', '        //     require(quantity>0&&len>0,"to small");\n', '\n', '        //     uint256 ratio = uint256(keccak256(abi.encodePacked(block.number, block.timestamp)));\n', '            \n', '        //     uint256 BASIC = len*10;\n', '        //     uint256 bn;\n', '        //     if(quantity>BASIC){\n', '        //         bn = (quantity-BASIC)/len+1;\n', '        //         quantity -= (quantity-9*len);\n', '        //     }\n', '            \n', '        //     for(uint256 i = 0;i<quantity;i++){\n', '        //          uint256 sn = (ratio>>i)%len;\n', '        //          carUsable[sn]++;\n', '        //     }\n', '            \n', '        //     for(uint256 j;j<len;j++){\n', '        //         carUsable[j]+= bn;\n', '        //         if(carUsable[j]>counts[j]){\n', '        //             carUsable[j] = counts[j];\n', '        //         }\n', '        //     }\n', '\n', '        //     emit ObtainCar(msg.sender,version,quantity);\n', '        // }\n', '        \n', '        pool.lock(msg.sender,address(this),nonce,expiry,allowed,v,r,s);\n', '        //token1155.safeBatchTransferFrom(address(this),msg.sender,carIndex,carUsable,"success");\n', ' \n', '    }\n', '    \n', '    function withdrawAward(uint256 _version) public {\n', '        \n', '       require(!records[_version][msg.sender].drawStatus,"have withdrawal");\n', '\t   require(_version<version,"Event not over");\n', '        \n', '       (uint256[2] memory amounts) =  getVersionAward(_version,msg.sender);\n', '\n', '       records[_version][msg.sender].drawStatus = true;\n', '       \n', '       pool.allot(msg.sender,amounts);\n', '       \n', '       emit WithdrawAward(msg.sender,_version,amounts);\n', '       \n', '    }\n', '    \n', '    \n', '    function getVersionAward(uint256 _version,address userAddress) public view returns(uint256[2] memory amounts){\n', '        Pair memory pair = history[_version];\n', '        return getPredictAward(_version,userAddress,pair);\n', '    }\n', '    \n', '    function getPredictAward(uint256 _version,address userAddress,Pair memory pair) internal view returns(uint256[2] memory amounts){\n', '        Record storage record = records[_version][userAddress];\n', '        \n', '        uint256 ranking = getRanking(userAddress,_version);\n', '\n', '        for(uint8 i = 0;i<2;i++){\n', '            uint256 baseAmount = pair.amounts[i].mul(70).div(100);\n', '            uint256 awardAmount = pair.amounts[i].mul(30).div(100);\n', '            \n', '            amounts[i] = amounts[i].add(baseAmount.mul(record.digGross).div(ORE_AMOUNT));\n', '            \n', '            if(ranking<10){\n', '                amounts[i] = amounts[i].add(awardAmount.mul(RANKING_AWARD_PERCENT[ranking]).div(30));\n', '            }\n', '            \n', '            if(record.lastStraw){\n', '                amounts[i] = amounts[i].add(awardAmount.mul(LAST_STRAW_PERCNET).div(30));\n', '            }\n', '        }\n', '    }\n', '\n', '    function getGlobalStats(uint256 _version) external view returns (uint256[5] memory stats,address lastStrawUser) {\n', '        \n', '        Pair memory pair = history[_version];\n', '        if(_version==version){\n', '            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n', '            pair.amounts = balances;\n', '        }\n', '        \n', '        stats[0] = pair.amounts[0];\n', '        stats[1] = pair.amounts[1];\n', '        stats[2] = pair.complete;\n', '        stats[3] = pair.actual;\n', '        stats[4] = (pool.duration()+1)*ONE_DAY;\n', '        lastStrawUser = pair.lastStraw;\n', '  \n', '    }\n', '    \n', '    \n', '    function crown(uint256 _version) external view returns (address[10] memory ranking,uint256[10] memory digGross){\n', '        ranking = sortRank(_version);\n', '        for(uint8 i =0;i<ranking.length;i++){\n', '            digGross[i] = getDigGross(ranking[i],_version);\n', '        }\n', '    }\n', '    \n', '    \n', '    function getPersonalStats(uint256 _version,address userAddress) external view returns (uint256[8] memory stats,bool[3] memory stats2,uint256[] memory departs){\n', '        Record storage record = records[_version][userAddress];\n', '         \n', '        (uint256 id,uint256 investment,uint256 freezeTime) = pool.users(userAddress);\n', '        stats[0] = investment;\n', '        stats[1] = record.digGross;\n', '         \n', '        Pair memory pair = history[_version];\n', '         \n', '        if(_version==version){\n', '            (,uint256[2] memory balances) = pool.balanceOf(address(this));\n', '            pair.amounts = balances;\n', '        }\n', '         \n', '        uint256[2] memory amounts = getPredictAward(_version,userAddress,pair);\n', '         \n', '        stats[2] = amounts[1];\n', '        stats[3] = amounts[0];\n', '        stats[4] = id;\n', '        stats[5] = freezeTime;\n', '        stats[6] = getRanking(userAddress,_version)+1;\n', '         \n', '        stats2[0] = record.drawStatus;\n', '        stats2[1] = record.lastStraw;\n', '        stats2[2] = pool.lockStatus(userAddress);\n', '         \n', '        departs = new uint256[](kinds());\n', '        uint256 total;\n', '        for(uint256 i =0;i<kinds();i++){\n', '            uint256 depart = getDepartCars(_version,userAddress,carIndex[i]);\n', '            departs[i] = depart;\n', '            total = total.add(depart);\n', '        }\n', '        stats[7] = total;\n', '        \n', '     }\n', '     \n', '\n', '    function getDepartCars(uint256 _version,address userAddress,uint256 _carId) public view returns(uint256){\n', '        return records[_version][userAddress].disCars[_carId];\n', '    }\n', '    \n', '    \n', '    \n', '    function mining(address userAddress,uint256[] memory ids,uint256[] memory amounts) internal returns(uint256){\n', '        Pair storage pair = history[version];\n', '        require(ids.length>0&&ids.length == amounts.length,"error");\n', '        \n', '        uint256 carFertility;\n', '        uint256 carCarry;\n', '        Record storage record = records[version][userAddress];\n', '        uint256 output;\n', '        for(uint256 i = 0;i<ids.length;i++){\n', '            Car memory car = cars[ids[i]];\n', '            carFertility = carFertility.add(car.fertility.mul(amounts[i]));\n', '            carCarry = carCarry.add(car.carry.mul(amounts[i]));\n', '            record.disCars[ids[i]] = record.disCars[ids[i]].add(amounts[i]);\n', '        }\n', '        \n', '        if(carFertility>carCarry){\n', '            output = carCarry;\n', '        }else{\n', '            output = carFertility;\n', '        }\n', '        \n', '        uint256 miningQuantity = pair.complete.add(carFertility);\n', '        if(miningQuantity>=ORE_AMOUNT){ \n', '            if(output>ORE_AMOUNT.sub(pair.complete))  output = ORE_AMOUNT.sub(pair.complete);\n', '            \n', '            emit LastStraw(userAddress,version,carFertility,carCarry,output);\n', '            lastStraw(userAddress,pair);\n', '        }\n', '        \n', '        record.digGross = record.digGross.add(output);\n', '        pair.complete = pair.complete.add(carFertility);\n', '        pair.actual = pair.actual.add(output);\n', '        updateRank(userAddress);\n', '        \n', '        token1155.safeBatchTransferFrom(address(this),owner(),ids,amounts,"success");\n', '        \n', '        emit Mining(userAddress,version,ids,amounts,output);\n', '        return output;\n', '    }\n', '    \n', '    function getRanking(address userAddress,uint256 _version) public view returns(uint256){\n', '        address[10] memory rankingList = sortRank(_version);\n', '        uint256 ranking = 10;\n', '        for(uint8 i =0;i<rankingList.length;i++){\n', '            if(userAddress == rankingList[i]){\n', '                ranking = i;\n', '                break;\n', '            }\n', '        }\n', '        return ranking;\n', '    }\n', '    \n', '    function pickUp(address[10] memory rankingList,address userAddress) internal view returns (uint256 sn,uint256 minDig){\n', '        \n', '        minDig = getDigGross(rankingList[0]);\n', '        for(uint8 i =0;i<rankingList.length;i++){\n', '            if(rankingList[i]==userAddress){\n', '                return (rankingList.length,0);\n', '            }\n', '            if(getDigGross(rankingList[i])<minDig){\n', '                minDig = getDigGross(rankingList[i]);\n', '                sn = i;\n', '            }\n', '        }\n', '        \n', '        return (sn,minDig);\n', '    }\n', '    \n', '    function updateRank(address userAddress) internal {\n', '        address[10] memory rankingList = rank[version];\n', '        \n', '        (uint256 sn,uint256 minDig) = pickUp(rankingList,userAddress);\n', '        if(sn!=rankingList.length){\n', '            if(minDig< getDigGross(userAddress)){\n', '                rankingList[sn] = userAddress;\n', '            }\n', '            rank[version] = rankingList;\n', '            emit UpdateRank(userAddress);\n', '        }\n', '    }\n', '    \n', '    function sortRank(uint256 _version) public view returns(address[10] memory ranking){\n', '        ranking = rank[_version];\n', '        \n', '        address tmp;\n', '        for(uint8 i = 1;i<5;i++){\n', '            for(uint8 j = 0;j<5-i;j++){\n', '                if(getDigGross(ranking[j],_version)<getDigGross(ranking[j+1],_version)){\n', '                    tmp = ranking[j];\n', '                    ranking[j] = ranking[j+1];\n', '                    ranking[j+1] = tmp;\n', '                }\n', '            }\n', '        }\n', '        return ranking;\n', '    }\n', '    \n', '    function getDigGross(address userAddress) internal view returns(uint256){\n', '        return getDigGross(userAddress,version);\n', '    }\n', '    \n', '    function getDigGross(address userAddress,uint256 _version) internal view returns(uint256){\n', '        return records[_version][userAddress].digGross;\n', '    }\n', '    \n', '    function lastStraw(address userAddress,Pair storage pair) internal{\n', '        \n', '        (address[2] memory tokens,uint256[2] memory amounts) = pool.balanceOf(address(this));\n', '        \n', '        for(uint8 i;i<amounts.length;i++){\n', '            TransferHelper.safeApprove(tokens[i],address(pool),amounts[i]);\n', '        }\n', '        pool.deposit(amounts);\n', '        pair.amounts = amounts;\n', '\n', '        pair.lastStraw = userAddress;\n', '        records[version][userAddress].lastStraw = true;    \n', '        \n', '        developerFee(pair);\n', '        version++;  \n', '        \n', '    }\n', '    \n', '     //项目方收款\n', '    function developerFee(Pair storage pair) internal{\n', '     \n', '        uint256[2] memory amounts;\n', '        for(uint256 i = 0;i<amounts.length;i++){\n', '            amounts[i] = pair.amounts[i].mul(70).mul(ORE_AMOUNT.sub(pair.actual)).div(ORE_AMOUNT).div(100);\n', '        }\n', '        pool.allot(developer,amounts);\n', '        \n', '        emit DeveloperFee(amounts[0],amounts[1]);\n', '    }\n', '    \n', '    \n', '    \n', '    function cat(address userAddress) public view returns(uint256[] memory,uint256[] memory counts,uint256 len,uint256 token1155Amount,uint256 quantity){\n', '        \n', '        ( ,uint256 investment, ) = pool.users(userAddress);\n', '        \n', '        (counts,token1155Amount) = determinate(); \n', '\n', '        uint256 dailyTokenAmount = dailyOutput[pool.duration()];\n', '        if(dailyTokenAmount==0){\n', '            dailyTokenAmount = token1155Amount;\n', '        }\n', '        uint256 totalSupply = pool.totalSupply();\n', '        quantity = investment.mul(dailyTokenAmount).div(totalSupply);\n', '        \n', '        return (carIndex,counts,kinds(),token1155Amount,quantity);\n', '\n', '    }\n', '    \n', '    function determinate() public view returns(uint256[] memory counts,uint256 token1155Amount){\n', '        address _owner = owner();\n', '        counts = new uint256[](kinds());\n', '        for(uint8 i = 0;i<kinds();i++){\n', '            uint256 count = token1155.balanceOf(_owner,carIndex[i]);\n', '            counts[i] = count;\n', '            token1155Amount+=count;\n', '        }\n', '\t\t\n', '        for(uint8 i = 0;i<kinds();i++){\n', '            token1155Amount+=counts[i];\n', '        }\n', '        \n', '    }\n', '    \n', '    function kinds() internal view returns (uint256) {\n', '        return carIndex.length;\n', '    }\n', '}\n', '\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}']