['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0\n', '\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// Global Enums and Structs\n', '\n', '\n', '\n', 'struct Rebase {\n', '    uint128 elastic;\n', '    uint128 base;\n', '}\n', 'struct StrategyParams {\n', '    uint256 performanceFee;\n', '    uint256 activation;\n', '    uint256 debtRatio;\n', '    uint256 minDebtPerHarvest;\n', '    uint256 maxDebtPerHarvest;\n', '    uint256 lastReport;\n', '    uint256 totalDebt;\n', '    uint256 totalGain;\n', '    uint256 totalLoss;\n', '}\n', '\n', '// Part: BIERC20\n', '\n', 'interface BIERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// Part: BoringMath\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '// Part: BoringMath128\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\n', 'library BoringMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '// Part: IMasterChef\n', '\n', 'interface IMasterChef {\n', '    struct UserInfo {\n', '        uint256 amount; // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '    }\n', '\n', '    struct PoolInfo {\n', '        address lpToken; // Address of LP token contract.\n', '        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHI to distribute per block.\n', '        uint256 lastRewardBlock; // Last block number that SUSHI distribution occurs.\n', '        uint256 accSushiPerShare; // Accumulated SUSHI per share, times 1e12. See below.\n', '    }\n', '\n', '    function poolInfo(uint256 pid)\n', '        external\n', '        view\n', '        returns (IMasterChef.PoolInfo memory);\n', '\n', '    function totalAllocPoint() external view returns (uint256);\n', '\n', '    function deposit(uint256 _pid, uint256 _amount) external;\n', '\n', '    function withdraw(uint256 _pid, uint256 _amount) external;\n', '\n', '    function emergencyWithdraw(uint256 _pid) external;\n', '\n', '    function userInfo(uint256 _pid, address user)\n', '        external\n', '        view\n', '        returns (IMasterChef.UserInfo memory);\n', '\n', '    function pendingSushi(uint256 _pid, address _user)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '// Part: IOracle\n', '\n', 'interface IOracle {\n', '    /// @notice Get the latest exchange rate.\n', '    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n', '    /// For example:\n', '    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n', '    /// @return success if no valid (recent) rate is available, return false else true.\n', '    /// @return rate The rate of the requested asset / pair / pool.\n', '    function get(bytes calldata data)\n', '        external\n', '        returns (bool success, uint256 rate);\n', '\n', '    /// @notice Check the last exchange rate without any state changes.\n', '    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n', '    /// For example:\n', '    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n', '    /// @return success if no valid (recent) rate is available, return false else true.\n', '    /// @return rate The rate of the requested asset / pair / pool.\n', '    function peek(bytes calldata data)\n', '        external\n', '        view\n', '        returns (bool success, uint256 rate);\n', '\n', '    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n', '    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n', '    /// For example:\n', '    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n', '    /// @return rate The rate of the requested asset / pair / pool.\n', '    function peekSpot(bytes calldata data) external view returns (uint256 rate);\n', '\n', '    /// @notice Returns a human readable (short) name about this oracle.\n', '    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n', '    /// For example:\n', '    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n', '    /// @return (string) A human readable symbol name about this oracle.\n', '    function symbol(bytes calldata data) external view returns (string memory);\n', '\n', '    /// @notice Returns a human readable name about this oracle.\n', '    /// @param data Usually abi encoded, implementation specific data that contains information and arguments to & about the oracle.\n', '    /// For example:\n', '    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n', '    /// @return (string) A human readable name about this oracle.\n', '    function name(bytes calldata data) external view returns (string memory);\n', '}\n', '\n', '// Part: IStrategy\n', '\n', 'interface IStrategy {\n', '    // Send the assets to the Strategy and call skim to invest them\n', '    function skim(uint256 amount) external;\n', '\n', '    // Harvest any profits made converted to the asset and pass them to the caller\n', '    function harvest(uint256 balance, address sender)\n', '        external\n', '        returns (int256 amountAdded);\n', '\n', '    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n', "    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\n", '    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n', '\n', "    // Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    function exit(uint256 balance) external returns (int256 amountAdded);\n', '}\n', '\n', '// Part: IUniswapV2Router01\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) external pure returns (uint256 amountB);\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/Address\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/IERC20\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/Math\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/SafeMath\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// Part: iearn-finance/[email\xa0protected]/HealthCheck\n', '\n', 'interface HealthCheck {\n', '    function check(\n', '        uint256 profit,\n', '        uint256 loss,\n', '        uint256 debtPayment,\n', '        uint256 debtOutstanding,\n', '        uint256 totalDebt\n', '    ) external view returns (bool);\n', '}\n', '\n', '// Part: IBatchFlashBorrower\n', '\n', 'interface IBatchFlashBorrower {\n', '    function onBatchFlashLoan(\n', '        address sender,\n', '        BIERC20[] calldata tokens,\n', '        uint256[] calldata amounts,\n', '        uint256[] calldata fees,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// Part: IFlashBorrower\n', '\n', 'interface IFlashBorrower {\n', '    function onFlashLoan(\n', '        address sender,\n', '        BIERC20 token,\n', '        uint256 amount,\n', '        uint256 fee,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// Part: ISwapper\n', '\n', 'interface ISwapper {\n', "    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n", "    /// Swaps it for at least 'amountToMin' of token 'to'.\n", "    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n", "    /// Returns the amount of tokens 'to' transferred to BentoBox.\n", '    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n', '    function swap(\n', '        BIERC20 fromToken,\n', '        BIERC20 toToken,\n', '        address recipient,\n', '        uint256 shareToMin,\n', '        uint256 shareFrom\n', '    ) external returns (uint256 extraShare, uint256 shareReturned);\n', '\n', "    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n", '    /// this should be less than or equal to amountFromMax.\n', "    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n", "    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n", "    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n", "    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n", "    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n", '    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n', '    function swapExact(\n', '        BIERC20 fromToken,\n', '        BIERC20 toToken,\n', '        address recipient,\n', '        address refundTo,\n', '        uint256 shareFromSupplied,\n', '        uint256 shareToExact\n', '    ) external returns (uint256 shareUsed, uint256 shareReturned);\n', '}\n', '\n', '// Part: IUniswapV2Router02\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '}\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/SafeERC20\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// Part: RebaseLibrary\n', '\n', '/// @notice A rebasing library using overflow-/underflow-safe math.\n', 'library RebaseLibrary {\n', '    using BoringMath for uint256;\n', '    using BoringMath128 for uint128;\n', '\n', '    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n', '    function toBase(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 base) {\n', '        if (total.elastic == 0) {\n', '            base = elastic;\n', '        } else {\n', '            base = elastic.mul(total.base) / total.elastic;\n', '            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n', '                base = base.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n', '    function toElastic(\n', '        Rebase memory total,\n', '        uint256 base,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 elastic) {\n', '        if (total.base == 0) {\n', '            elastic = base;\n', '        } else {\n', '            elastic = base.mul(total.elastic) / total.base;\n', '            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n', '                elastic = elastic.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Add `elastic` to `total` and doubles `total.base`.\n', '    /// @return (Rebase) The new total.\n', '    /// @return base in relationship to `elastic`.\n', '    function add(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        bool roundUp\n', '    ) internal pure returns (Rebase memory, uint256 base) {\n', '        base = toBase(total, elastic, roundUp);\n', '        total.elastic = total.elastic.add(elastic.to128());\n', '        total.base = total.base.add(base.to128());\n', '        return (total, base);\n', '    }\n', '\n', '    /// @notice Sub `base` from `total` and update `total.elastic`.\n', '    /// @return (Rebase) The new total.\n', '    /// @return elastic in relationship to `base`.\n', '    function sub(\n', '        Rebase memory total,\n', '        uint256 base,\n', '        bool roundUp\n', '    ) internal pure returns (Rebase memory, uint256 elastic) {\n', '        elastic = toElastic(total, base, roundUp);\n', '        total.elastic = total.elastic.sub(elastic.to128());\n', '        total.base = total.base.sub(base.to128());\n', '        return (total, elastic);\n', '    }\n', '\n', '    /// @notice Add `elastic` and `base` to `total`.\n', '    function add(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        uint256 base\n', '    ) internal pure returns (Rebase memory) {\n', '        total.elastic = total.elastic.add(elastic.to128());\n', '        total.base = total.base.add(base.to128());\n', '        return total;\n', '    }\n', '\n', '    /// @notice Subtract `elastic` and `base` to `total`.\n', '    function sub(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        uint256 base\n', '    ) internal pure returns (Rebase memory) {\n', '        total.elastic = total.elastic.sub(elastic.to128());\n', '        total.base = total.base.sub(base.to128());\n', '        return total;\n', '    }\n', '\n', '    /// @notice Add `elastic` to `total` and update storage.\n', '    /// @return newElastic Returns updated `elastic`.\n', '    function addElastic(Rebase storage total, uint256 elastic)\n', '        internal\n', '        returns (uint256 newElastic)\n', '    {\n', '        newElastic = total.elastic = total.elastic.add(elastic.to128());\n', '    }\n', '\n', '    /// @notice Subtract `elastic` from `total` and update storage.\n', '    /// @return newElastic Returns updated `elastic`.\n', '    function subElastic(Rebase storage total, uint256 elastic)\n', '        internal\n', '        returns (uint256 newElastic)\n', '    {\n', '        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n', '    }\n', '}\n', '\n', '// Part: iearn-finance/[email\xa0protected]/VaultAPI\n', '\n', 'interface VaultAPI is IERC20 {\n', '    function name() external view returns (string calldata);\n', '\n', '    function symbol() external view returns (string calldata);\n', '\n', '    function decimals() external view returns (uint256);\n', '\n', '    function apiVersion() external pure returns (string memory);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 expiry,\n', '        bytes calldata signature\n', '    ) external returns (bool);\n', '\n', '    // NOTE: Vyper produces multiple signatures for a given function with "default" args\n', '    function deposit() external returns (uint256);\n', '\n', '    function deposit(uint256 amount) external returns (uint256);\n', '\n', '    function deposit(uint256 amount, address recipient) external returns (uint256);\n', '\n', '    // NOTE: Vyper produces multiple signatures for a given function with "default" args\n', '    function withdraw() external returns (uint256);\n', '\n', '    function withdraw(uint256 maxShares) external returns (uint256);\n', '\n', '    function withdraw(uint256 maxShares, address recipient) external returns (uint256);\n', '\n', '    function token() external view returns (address);\n', '\n', '    function strategies(address _strategy) external view returns (StrategyParams memory);\n', '\n', '    function pricePerShare() external view returns (uint256);\n', '\n', '    function totalAssets() external view returns (uint256);\n', '\n', '    function depositLimit() external view returns (uint256);\n', '\n', '    function maxAvailableShares() external view returns (uint256);\n', '\n', '    /**\n', "     * View how much the Vault would increase this Strategy's borrow limit,\n", '     * based on its present performance (since its last report). Can be used to\n', '     * determine expectedReturn in your Strategy.\n', '     */\n', '    function creditAvailable() external view returns (uint256);\n', '\n', '    /**\n', '     * View how much the Vault would like to pull back from the Strategy,\n', '     * based on its present performance (since its last report). Can be used to\n', '     * determine expectedReturn in your Strategy.\n', '     */\n', '    function debtOutstanding() external view returns (uint256);\n', '\n', '    /**\n', '     * View how much the Vault expect this Strategy to return at the current\n', '     * block, based on its present performance (since its last report). Can be\n', '     * used to determine expectedReturn in your Strategy.\n', '     */\n', '    function expectedReturn() external view returns (uint256);\n', '\n', '    /**\n', '     * This is the main contact point where the Strategy interacts with the\n', '     * Vault. It is critical that this call is handled as intended by the\n', '     * Strategy. Therefore, this function will be called by BaseStrategy to\n', '     * make sure the integration is correct.\n', '     */\n', '    function report(\n', '        uint256 _gain,\n', '        uint256 _loss,\n', '        uint256 _debtPayment\n', '    ) external returns (uint256);\n', '\n', '    /**\n', '     * This function should only be used in the scenario where the Strategy is\n', '     * being retired but no migration of the positions are possible, or in the\n', '     * extreme scenario that the Strategy needs to be put into "Emergency Exit"\n', '     * mode in order for it to exit as quickly as possible. The latter scenario\n', '     * could be for any reason that is considered "critical" that the Strategy\n', '     * exits its position as fast as possible, such as a sudden change in\n', '     * market conditions leading to losses, or an imminent failure in an\n', '     * external dependency.\n', '     */\n', '    function revokeStrategy() external;\n', '\n', '    /**\n', '     * View the governance address of the Vault to assert privileged functions\n', '     * can only be called by governance. The Strategy serves the Vault, so it\n', '     * is subject to governance defined by the Vault.\n', '     */\n', '    function governance() external view returns (address);\n', '\n', '    /**\n', '     * View the management address of the Vault to assert privileged functions\n', '     * can only be called by management. The Strategy serves the Vault, so it\n', '     * is subject to management defined by the Vault.\n', '     */\n', '    function management() external view returns (address);\n', '\n', '    /**\n', '     * View the guardian address of the Vault to assert privileged functions\n', '     * can only be called by guardian. The Strategy serves the Vault, so it\n', '     * is subject to guardian defined by the Vault.\n', '     */\n', '    function guardian() external view returns (address);\n', '}\n', '\n', '// Part: IBentoBoxV1 (Alias import as IBentoBox)\n', '\n', 'interface IBentoBox {\n', '    event LogDeploy(\n', '        address indexed masterContract,\n', '        bytes data,\n', '        address indexed cloneAddress\n', '    );\n', '    event LogDeposit(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 share\n', '    );\n', '    event LogFlashLoan(\n', '        address indexed borrower,\n', '        address indexed token,\n', '        uint256 amount,\n', '        uint256 feeAmount,\n', '        address indexed receiver\n', '    );\n', '    event LogRegisterProtocol(address indexed protocol);\n', '    event LogSetMasterContractApproval(\n', '        address indexed masterContract,\n', '        address indexed user,\n', '        bool approved\n', '    );\n', '    event LogStrategyDivest(address indexed token, uint256 amount);\n', '    event LogStrategyInvest(address indexed token, uint256 amount);\n', '    event LogStrategyLoss(address indexed token, uint256 amount);\n', '    event LogStrategyProfit(address indexed token, uint256 amount);\n', '    event LogStrategyQueued(address indexed token, address indexed strategy);\n', '    event LogStrategySet(address indexed token, address indexed strategy);\n', '    event LogStrategyTargetPercentage(\n', '        address indexed token,\n', '        uint256 targetPercentage\n', '    );\n', '    event LogTransfer(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share\n', '    );\n', '    event LogWhiteListMasterContract(\n', '        address indexed masterContract,\n', '        bool approved\n', '    );\n', '    event LogWithdraw(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 share\n', '    );\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    function balanceOf(BIERC20, address) external view returns (uint256);\n', '\n', '    function batch(bytes[] calldata calls, bool revertOnFail)\n', '        external\n', '        payable\n', '        returns (bool[] memory successes, bytes[] memory results);\n', '\n', '    function batchFlashLoan(\n', '        IBatchFlashBorrower borrower,\n', '        address[] calldata receivers,\n', '        BIERC20[] calldata tokens,\n', '        uint256[] calldata amounts,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function claimOwnership() external;\n', '\n', '    function deploy(\n', '        address masterContract,\n', '        bytes calldata data,\n', '        bool useCreate2\n', '    ) external payable;\n', '\n', '    function deposit(\n', '        BIERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external payable returns (uint256 amountOut, uint256 shareOut);\n', '\n', '    function flashLoan(\n', '        IFlashBorrower borrower,\n', '        address receiver,\n', '        BIERC20 token,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function harvest(\n', '        BIERC20 token,\n', '        bool balance,\n', '        uint256 maxChangeAmount\n', '    ) external;\n', '\n', '    function masterContractApproved(address, address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function masterContractOf(address) external view returns (address);\n', '\n', '    function nonces(address) external view returns (uint256);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function pendingOwner() external view returns (address);\n', '\n', '    function pendingStrategy(BIERC20) external view returns (IStrategy);\n', '\n', '    function permitToken(\n', '        BIERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function registerProtocol() external;\n', '\n', '    function setMasterContractApproval(\n', '        address user,\n', '        address masterContract,\n', '        bool approved,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function setStrategy(BIERC20 token, IStrategy newStrategy) external;\n', '\n', '    function setStrategyTargetPercentage(\n', '        BIERC20 token,\n', '        uint64 targetPercentage_\n', '    ) external;\n', '\n', '    function strategy(BIERC20) external view returns (IStrategy);\n', '\n', '    function strategyData(BIERC20)\n', '        external\n', '        view\n', '        returns (\n', '            uint64 strategyStartDate,\n', '            uint64 targetPercentage,\n', '            uint128 balance\n', '        );\n', '\n', '    function toAmount(\n', '        BIERC20 token,\n', '        uint256 share,\n', '        bool roundUp\n', '    ) external view returns (uint256 amount);\n', '\n', '    function toShare(\n', '        BIERC20 token,\n', '        uint256 amount,\n', '        bool roundUp\n', '    ) external view returns (uint256 share);\n', '\n', '    function totals(BIERC20) external view returns (Rebase memory totals_);\n', '\n', '    function transfer(\n', '        BIERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 share\n', '    ) external;\n', '\n', '    function transferMultiple(\n', '        BIERC20 token,\n', '        address from,\n', '        address[] calldata tos,\n', '        uint256[] calldata shares\n', '    ) external;\n', '\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) external;\n', '\n', '    function whitelistMasterContract(address masterContract, bool approved)\n', '        external;\n', '\n', '    function whitelistedMasterContracts(address) external view returns (bool);\n', '\n', '    function withdraw(\n', '        BIERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external returns (uint256 amountOut, uint256 shareOut);\n', '}\n', '\n', '// Part: IBentoBoxV1\n', '\n', 'interface IBentoBoxV1 {\n', '    event LogDeploy(\n', '        address indexed masterContract,\n', '        bytes data,\n', '        address indexed cloneAddress\n', '    );\n', '    event LogDeposit(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 share\n', '    );\n', '    event LogFlashLoan(\n', '        address indexed borrower,\n', '        address indexed token,\n', '        uint256 amount,\n', '        uint256 feeAmount,\n', '        address indexed receiver\n', '    );\n', '    event LogRegisterProtocol(address indexed protocol);\n', '    event LogSetMasterContractApproval(\n', '        address indexed masterContract,\n', '        address indexed user,\n', '        bool approved\n', '    );\n', '    event LogStrategyDivest(address indexed token, uint256 amount);\n', '    event LogStrategyInvest(address indexed token, uint256 amount);\n', '    event LogStrategyLoss(address indexed token, uint256 amount);\n', '    event LogStrategyProfit(address indexed token, uint256 amount);\n', '    event LogStrategyQueued(address indexed token, address indexed strategy);\n', '    event LogStrategySet(address indexed token, address indexed strategy);\n', '    event LogStrategyTargetPercentage(\n', '        address indexed token,\n', '        uint256 targetPercentage\n', '    );\n', '    event LogTransfer(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share\n', '    );\n', '    event LogWhiteListMasterContract(\n', '        address indexed masterContract,\n', '        bool approved\n', '    );\n', '    event LogWithdraw(\n', '        address indexed token,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 share\n', '    );\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    function balanceOf(BIERC20, address) external view returns (uint256);\n', '\n', '    function batch(bytes[] calldata calls, bool revertOnFail)\n', '        external\n', '        payable\n', '        returns (bool[] memory successes, bytes[] memory results);\n', '\n', '    function batchFlashLoan(\n', '        IBatchFlashBorrower borrower,\n', '        address[] calldata receivers,\n', '        BIERC20[] calldata tokens,\n', '        uint256[] calldata amounts,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function claimOwnership() external;\n', '\n', '    function deploy(\n', '        address masterContract,\n', '        bytes calldata data,\n', '        bool useCreate2\n', '    ) external payable;\n', '\n', '    function deposit(\n', '        BIERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external payable returns (uint256 amountOut, uint256 shareOut);\n', '\n', '    function flashLoan(\n', '        IFlashBorrower borrower,\n', '        address receiver,\n', '        BIERC20 token,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function harvest(\n', '        BIERC20 token,\n', '        bool balance,\n', '        uint256 maxChangeAmount\n', '    ) external;\n', '\n', '    function masterContractApproved(address, address)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function masterContractOf(address) external view returns (address);\n', '\n', '    function nonces(address) external view returns (uint256);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function pendingOwner() external view returns (address);\n', '\n', '    function pendingStrategy(BIERC20) external view returns (IStrategy);\n', '\n', '    function permitToken(\n', '        BIERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function registerProtocol() external;\n', '\n', '    function setMasterContractApproval(\n', '        address user,\n', '        address masterContract,\n', '        bool approved,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function setStrategy(BIERC20 token, IStrategy newStrategy) external;\n', '\n', '    function setStrategyTargetPercentage(\n', '        BIERC20 token,\n', '        uint64 targetPercentage_\n', '    ) external;\n', '\n', '    function strategy(BIERC20) external view returns (IStrategy);\n', '\n', '    function strategyData(BIERC20)\n', '        external\n', '        view\n', '        returns (\n', '            uint64 strategyStartDate,\n', '            uint64 targetPercentage,\n', '            uint128 balance\n', '        );\n', '\n', '    function toAmount(\n', '        BIERC20 token,\n', '        uint256 share,\n', '        bool roundUp\n', '    ) external view returns (uint256 amount);\n', '\n', '    function toShare(\n', '        BIERC20 token,\n', '        uint256 amount,\n', '        bool roundUp\n', '    ) external view returns (uint256 share);\n', '\n', '    function totals(BIERC20) external view returns (Rebase memory totals_);\n', '\n', '    function transfer(\n', '        BIERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 share\n', '    ) external;\n', '\n', '    function transferMultiple(\n', '        BIERC20 token,\n', '        address from,\n', '        address[] calldata tos,\n', '        uint256[] calldata shares\n', '    ) external;\n', '\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) external;\n', '\n', '    function whitelistMasterContract(address masterContract, bool approved)\n', '        external;\n', '\n', '    function whitelistedMasterContracts(address) external view returns (bool);\n', '\n', '    function withdraw(\n', '        BIERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external returns (uint256 amountOut, uint256 shareOut);\n', '}\n', '\n', '// Part: iearn-finance/[email\xa0protected]/BaseStrategy\n', '\n', '/**\n', ' * @title Yearn Base Strategy\n', ' * @author yearn.finance\n', ' * @notice\n', ' *  BaseStrategy implements all of the required functionality to interoperate\n', ' *  closely with the Vault contract. This contract should be inherited and the\n', ' *  abstract methods implemented to adapt the Strategy to the particular needs\n', ' *  it has to create a return.\n', ' *\n', ' *  Of special interest is the relationship between `harvest()` and\n', " *  `vault.report()'. `harvest()` may be called simply because enough time has\n", ' *  elapsed since the last report, and not because any funds need to be moved\n', ' *  or positions adjusted. This is critical so that the Vault may maintain an\n', " *  accurate picture of the Strategy's performance. See  `vault.report()`,\n", ' *  `harvest()`, and `harvestTrigger()` for further details.\n', ' */\n', '\n', 'abstract contract BaseStrategy {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    string public metadataURI;\n', '\n', '    // health checks\n', '    bool public doHealthCheck;\n', '    address public healthCheck;\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to track which version of `StrategyAPI` this Strategy\n', '     *  implements.\n', "     * @dev The Strategy's version must match the Vault's `API_VERSION`.\n", '     * @return A string which holds the current API version of this contract.\n', '     */\n', '    function apiVersion() public pure returns (string memory) {\n', '        return "0.4.3";\n', '    }\n', '\n', '    /**\n', "     * @notice This Strategy's name.\n", '     * @dev\n', '     *  You can use this field to manage the "version" of this Strategy, e.g.\n', '     *  `StrategySomethingOrOtherV1`. However, "API Version" is managed by\n', '     *  `apiVersion()` function above.\n', "     * @return This Strategy's name.\n", '     */\n', '    function name() external view virtual returns (string memory);\n', '\n', '    /**\n', '     * @notice\n', '     *  The amount (priced in want) of the total assets managed by this strategy should not count\n', "     *  towards Yearn's TVL calculations.\n", '     * @dev\n', '     *  You can override this field to set it to a non-zero value if some of the assets of this\n', "     *  Strategy is somehow delegated inside another part of of Yearn's ecosystem e.g. another Vault.\n", '     *  Note that this value must be strictly less than or equal to the amount provided by\n', '     *  `estimatedTotalAssets()` below, as the TVL calc will be total assets minus delegated assets.\n', '     *  Also note that this value is used to determine the total assets under management by this\n', '     *  strategy, for the purposes of computing the management fee in `Vault`\n', '     * @return\n', "     *  The amount of assets this strategy manages that should not be included in Yearn's Total Value\n", "     *  Locked (TVL) calculation across it's ecosystem.\n", '     */\n', '    function delegatedAssets() external view virtual returns (uint256) {\n', '        return 0;\n', '    }\n', '\n', '    VaultAPI public vault;\n', '    address public strategist;\n', '    address public rewards;\n', '    address public keeper;\n', '\n', '    IERC20 public want;\n', '\n', '    // So indexers can keep track of this\n', '    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n', '\n', '    event UpdatedStrategist(address newStrategist);\n', '\n', '    event UpdatedKeeper(address newKeeper);\n', '\n', '    event UpdatedRewards(address rewards);\n', '\n', '    event UpdatedMinReportDelay(uint256 delay);\n', '\n', '    event UpdatedMaxReportDelay(uint256 delay);\n', '\n', '    event UpdatedProfitFactor(uint256 profitFactor);\n', '\n', '    event UpdatedDebtThreshold(uint256 debtThreshold);\n', '\n', '    event EmergencyExitEnabled();\n', '\n', '    event UpdatedMetadataURI(string metadataURI);\n', '\n', '    // The minimum number of seconds between harvest calls. See\n', '    // `setMinReportDelay()` for more details.\n', '    uint256 public minReportDelay;\n', '\n', '    // The maximum number of seconds between harvest calls. See\n', '    // `setMaxReportDelay()` for more details.\n', '    uint256 public maxReportDelay;\n', '\n', '    // The minimum multiple that `callCost` must be above the credit/profit to\n', '    // be "justifiable". See `setProfitFactor()` for more details.\n', '    uint256 public profitFactor;\n', '\n', '    // Use this to adjust the threshold at which running a debt causes a\n', '    // harvest trigger. See `setDebtThreshold()` for more details.\n', '    uint256 public debtThreshold;\n', '\n', '    // See note on `setEmergencyExit()`.\n', '    bool public emergencyExit;\n', '\n', '    // modifiers\n', '    modifier onlyAuthorized() {\n', '        require(msg.sender == strategist || msg.sender == governance(), "!authorized");\n', '        _;\n', '    }\n', '\n', '    modifier onlyEmergencyAuthorized() {\n', '        require(\n', '            msg.sender == strategist || msg.sender == governance() || msg.sender == vault.guardian() || msg.sender == vault.management(),\n', '            "!authorized"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyStrategist() {\n', '        require(msg.sender == strategist, "!strategist");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        require(msg.sender == governance(), "!authorized");\n', '        _;\n', '    }\n', '\n', '    modifier onlyKeepers() {\n', '        require(\n', '            msg.sender == keeper ||\n', '                msg.sender == strategist ||\n', '                msg.sender == governance() ||\n', '                msg.sender == vault.guardian() ||\n', '                msg.sender == vault.management(),\n', '            "!authorized"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyVaultManagers() {\n', '        require(msg.sender == vault.management() || msg.sender == governance(), "!authorized");\n', '        _;\n', '    }\n', '\n', '    constructor(address _vault) public {\n', '        _initialize(_vault, msg.sender, msg.sender, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Initializes the Strategy, this is called only once, when the\n', '     *  contract is deployed.\n', '     * @dev `_vault` should implement `VaultAPI`.\n', '     * @param _vault The address of the Vault responsible for this Strategy.\n', '     * @param _strategist The address to assign as `strategist`.\n', '     * The strategist is able to change the reward address\n', '     * @param _rewards  The address to use for pulling rewards.\n', '     * @param _keeper The adddress of the _keeper. _keeper\n', '     * can harvest and tend a strategy.\n', '     */\n', '    function _initialize(\n', '        address _vault,\n', '        address _strategist,\n', '        address _rewards,\n', '        address _keeper\n', '    ) internal {\n', '        require(address(want) == address(0), "Strategy already initialized");\n', '\n', '        vault = VaultAPI(_vault);\n', '        want = IERC20(vault.token());\n', '        want.safeApprove(_vault, uint256(-1)); // Give Vault unlimited access (might save gas)\n', '        strategist = _strategist;\n', '        rewards = _rewards;\n', '        keeper = _keeper;\n', '\n', '        // initialize variables\n', '        minReportDelay = 0;\n', '        maxReportDelay = 86400;\n', '        profitFactor = 100;\n', '        debtThreshold = 0;\n', '\n', '        vault.approve(rewards, uint256(-1)); // Allow rewards to be pulled\n', '    }\n', '\n', '    function setHealthCheck(address _healthCheck) external onlyVaultManagers {\n', '        healthCheck = _healthCheck;\n', '    }\n', '\n', '    function setDoHealthCheck(bool _doHealthCheck) external onlyVaultManagers {\n', '        doHealthCheck = _doHealthCheck;\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `strategist`.\n', '     *\n', '     *  This may only be called by governance or the existing strategist.\n', '     * @param _strategist The new address to assign as `strategist`.\n', '     */\n', '    function setStrategist(address _strategist) external onlyAuthorized {\n', '        require(_strategist != address(0));\n', '        strategist = _strategist;\n', '        emit UpdatedStrategist(_strategist);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `keeper`.\n', '     *\n', '     *  `keeper` is the only address that may call `tend()` or `harvest()`,\n', '     *  other than `governance()` or `strategist`. However, unlike\n', '     *  `governance()` or `strategist`, `keeper` may *only* call `tend()`\n', '     *  and `harvest()`, and no other authorized functions, following the\n', '     *  principle of least privilege.\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _keeper The new address to assign as `keeper`.\n', '     */\n', '    function setKeeper(address _keeper) external onlyAuthorized {\n', '        require(_keeper != address(0));\n', '        keeper = _keeper;\n', '        emit UpdatedKeeper(_keeper);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `rewards`. EOA or smart contract which has the permission\n', '     *  to pull rewards from the vault.\n', '     *\n', '     *  This may only be called by the strategist.\n', '     * @param _rewards The address to use for pulling rewards.\n', '     */\n', '    function setRewards(address _rewards) external onlyStrategist {\n', '        require(_rewards != address(0));\n', '        vault.approve(rewards, 0);\n', '        rewards = _rewards;\n', '        vault.approve(rewards, uint256(-1));\n', '        emit UpdatedRewards(_rewards);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `minReportDelay`. `minReportDelay` is the minimum number\n', '     *  of blocks that should pass for `harvest()` to be called.\n', '     *\n', '     *  For external keepers (such as the Keep3r network), this is the minimum\n', '     *  time between jobs to wait. (see `harvestTrigger()`\n', '     *  for more details.)\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _delay The minimum number of seconds to wait between harvests.\n', '     */\n', '    function setMinReportDelay(uint256 _delay) external onlyAuthorized {\n', '        minReportDelay = _delay;\n', '        emit UpdatedMinReportDelay(_delay);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `maxReportDelay`. `maxReportDelay` is the maximum number\n', '     *  of blocks that should pass for `harvest()` to be called.\n', '     *\n', '     *  For external keepers (such as the Keep3r network), this is the maximum\n', '     *  time between jobs to wait. (see `harvestTrigger()`\n', '     *  for more details.)\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _delay The maximum number of seconds to wait between harvests.\n', '     */\n', '    function setMaxReportDelay(uint256 _delay) external onlyAuthorized {\n', '        maxReportDelay = _delay;\n', '        emit UpdatedMaxReportDelay(_delay);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `profitFactor`. `profitFactor` is used to determine\n', "     *  if it's worthwhile to harvest, given gas costs. (See `harvestTrigger()`\n", '     *  for more details.)\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _profitFactor A ratio to multiply anticipated\n', '     * `harvest()` gas cost against.\n', '     */\n', '    function setProfitFactor(uint256 _profitFactor) external onlyAuthorized {\n', '        profitFactor = _profitFactor;\n', '        emit UpdatedProfitFactor(_profitFactor);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Sets how far the Strategy can go into loss without a harvest and report\n', '     *  being required.\n', '     *\n', '     *  By default this is 0, meaning any losses would cause a harvest which\n', '     *  will subsequently report the loss to the Vault for tracking. (See\n', '     *  `harvestTrigger()` for more details.)\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _debtThreshold How big of a loss this Strategy may carry without\n', '     * being required to report to the Vault.\n', '     */\n', '    function setDebtThreshold(uint256 _debtThreshold) external onlyAuthorized {\n', '        debtThreshold = _debtThreshold;\n', '        emit UpdatedDebtThreshold(_debtThreshold);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Used to change `metadataURI`. `metadataURI` is used to store the URI\n', '     * of the file describing the strategy.\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @param _metadataURI The URI that describe the strategy.\n', '     */\n', '    function setMetadataURI(string calldata _metadataURI) external onlyAuthorized {\n', '        metadataURI = _metadataURI;\n', '        emit UpdatedMetadataURI(_metadataURI);\n', '    }\n', '\n', '    /**\n', '     * Resolve governance address from Vault contract, used to make assertions\n', '     * on protected functions in the Strategy.\n', '     */\n', '    function governance() internal view returns (address) {\n', '        return vault.governance();\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)\n', '     *  to `want` (using the native decimal characteristics of `want`).\n', '     * @dev\n', '     *  Care must be taken when working with decimals to assure that the conversion\n', '     *  is compatible. As an example:\n', '     *\n', '     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),\n', '     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)\n', '     *\n', '     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`\n', '     * @return The amount in `want` of `_amtInEth` converted to `want`\n', '     **/\n', '    function ethToWant(uint256 _amtInWei) public view virtual returns (uint256);\n', '\n', '    /**\n', '     * @notice\n', '     *  Provide an accurate estimate for the total amount of assets\n', '     *  (principle + return) that this Strategy is currently managing,\n', '     *  denominated in terms of `want` tokens.\n', '     *\n', '     *  This total should be "realizable" e.g. the total value that could\n', '     *  *actually* be obtained from this Strategy if it were to divest its\n', '     *  entire position based on current on-chain conditions.\n', '     * @dev\n', '     *  Care must be taken in using this function, since it relies on external\n', '     *  systems, which could be manipulated by the attacker to give an inflated\n', '     *  (or reduced) value produced by this function, based on current on-chain\n', '     *  conditions (e.g. this function is possible to influence through\n', '     *  flashloan attacks, oracle manipulations, or other DeFi attack\n', '     *  mechanisms).\n', '     *\n', '     *  It is up to governance to use this function to correctly order this\n', '     *  Strategy relative to its peers in the withdrawal queue to minimize\n', '     *  losses for the Vault based on sudden withdrawals. This value should be\n', '     *  higher than the total debt of the Strategy and higher than its expected\n', '     *  value to be "safe".\n', '     * @return The estimated total assets in this Strategy.\n', '     */\n', '    function estimatedTotalAssets() public view virtual returns (uint256);\n', '\n', '    /*\n', '     * @notice\n', '     *  Provide an indication of whether this strategy is currently "active"\n', '     *  in that it is managing an active position, or will manage a position in\n', '     *  the future. This should correlate to `harvest()` activity, so that Harvest\n', '     *  events can be tracked externally by indexing agents.\n', '     * @return True if the strategy is actively managing a position.\n', '     */\n', '    function isActive() public view returns (bool) {\n', '        return vault.strategies(address(this)).debtRatio > 0 || estimatedTotalAssets() > 0;\n', '    }\n', '\n', '    /**\n', '     * Perform any Strategy unwinding or other calls necessary to capture the\n', '     * "free return" this Strategy has generated since the last time its core\n', '     * position(s) were adjusted. Examples include unwrapping extra rewards.\n', '     * This call is only used during "normal operation" of a Strategy, and\n', '     * should be optimized to minimize losses as much as possible.\n', '     *\n', '     * This method returns any realized profits and/or realized losses\n', '     * incurred, and should return the total amounts of profits/losses/debt\n', "     * payments (in `want` tokens) for the Vault's accounting (e.g.\n", '     * `want.balanceOf(this) >= _debtPayment + _profit`).\n', '     *\n', '     * `_debtOutstanding` will be 0 if the Strategy is not past the configured\n', '     * debt limit, otherwise its value will be how far past the debt limit\n', "     * the Strategy is. The Strategy's debt limit is configured in the Vault.\n", '     *\n', '     * NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\n', '     *       It is okay for it to be less than `_debtOutstanding`, as that\n', '     *       should only used as a guide for how much is left to pay back.\n', '     *       Payments should be made to minimize loss from slippage, debt,\n', '     *       withdrawal fees, etc.\n', '     *\n', '     * See `vault.debtOutstanding()`.\n', '     */\n', '    function prepareReturn(uint256 _debtOutstanding)\n', '        internal\n', '        virtual\n', '        returns (\n', '            uint256 _profit,\n', '            uint256 _loss,\n', '            uint256 _debtPayment\n', '        );\n', '\n', '    /**\n', '     * Perform any adjustments to the core position(s) of this Strategy given\n', '     * what change the Vault made in the "investable capital" available to the\n', '     * Strategy. Note that all "free capital" in the Strategy after the report\n', '     * was made is available for reinvestment. Also note that this number\n', '     * could be 0, and you should handle that scenario accordingly.\n', '     *\n', '     * See comments regarding `_debtOutstanding` on `prepareReturn()`.\n', '     */\n', '    function adjustPosition(uint256 _debtOutstanding) internal virtual;\n', '\n', '    /**\n', "     * Liquidate up to `_amountNeeded` of `want` of this strategy's positions,\n", '     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\n', '     * This function should return the amount of `want` tokens made available by the\n', '     * liquidation. If there is a difference between them, `_loss` indicates whether the\n', '     * difference is due to a realized loss, or if there is some other sitution at play\n', '     * (e.g. locked funds) where the amount made available is less than what is needed.\n', '     *\n', '     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n', '     */\n', '    function liquidatePosition(uint256 _amountNeeded) internal virtual returns (uint256 _liquidatedAmount, uint256 _loss);\n', '\n', '    /**\n', '     * Liquidate everything and returns the amount that got freed.\n', '     * This function is used during emergency exit instead of `prepareReturn()` to\n', "     * liquidate all of the Strategy's positions back to the Vault.\n", '     */\n', '\n', '    function liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\n', '\n', '    /**\n', '     * @notice\n', '     *  Provide a signal to the keeper that `tend()` should be called. The\n', '     *  keeper will provide the estimated gas cost that they would pay to call\n', '     *  `tend()`, and this function should use that estimate to make a\n', '     *  determination if calling it is "worth it" for the keeper. This is not\n', '     *  the only consideration into issuing this trigger, for example if the\n', '     *  position would be negatively affected if `tend()` is not called\n', '     *  shortly, then this can return `true` even if the keeper might be\n', '     *  "at a loss" (keepers are always reimbursed by Yearn).\n', '     * @dev\n', '     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\n', '     *\n', '     *  This call and `harvestTrigger()` should never return `true` at the same\n', '     *  time.\n', "     * @param callCostInWei The keeper's estimated gas cost to call `tend()` (in wei).\n", '     * @return `true` if `tend()` should be called, `false` otherwise.\n', '     */\n', '    function tendTrigger(uint256 callCostInWei) public view virtual returns (bool) {\n', "        // We usually don't need tend, but if there are positions that need\n", '        // active maintainence, overriding this function is how you would\n', '        // signal for that.\n', '        // If your implementation uses the cost of the call in want, you can\n', '        // use uint256 callCost = ethToWant(callCostInWei);\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice\n', "     *  Adjust the Strategy's position. The purpose of tending isn't to\n", '     *  realize gains, but to maximize yield by reinvesting any returns.\n', '     *\n', '     *  See comments on `adjustPosition()`.\n', '     *\n', '     *  This may only be called by governance, the strategist, or the keeper.\n', '     */\n', '    function tend() external onlyKeepers {\n', "        // Don't take profits with this call, but adjust for better gains\n", '        adjustPosition(vault.debtOutstanding());\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Provide a signal to the keeper that `harvest()` should be called. The\n', '     *  keeper will provide the estimated gas cost that they would pay to call\n', '     *  `harvest()`, and this function should use that estimate to make a\n', '     *  determination if calling it is "worth it" for the keeper. This is not\n', '     *  the only consideration into issuing this trigger, for example if the\n', '     *  position would be negatively affected if `harvest()` is not called\n', '     *  shortly, then this can return `true` even if the keeper might be "at a\n', '     *  loss" (keepers are always reimbursed by Yearn).\n', '     * @dev\n', '     *  `callCostInWei` must be priced in terms of `wei` (1e-18 ETH).\n', '     *\n', '     *  This call and `tendTrigger` should never return `true` at the\n', '     *  same time.\n', '     *\n', '     *  See `min/maxReportDelay`, `profitFactor`, `debtThreshold` to adjust the\n', '     *  strategist-controlled parameters that will influence whether this call\n', '     *  returns `true` or not. These parameters will be used in conjunction\n', '     *  with the parameters reported to the Vault (see `params`) to determine\n', '     *  if calling `harvest()` is merited.\n', '     *\n', '     *  It is expected that an external system will check `harvestTrigger()`.\n', '     *  This could be a script run off a desktop or cloud bot (e.g.\n', '     *  https://github.com/iearn-finance/yearn-vaults/blob/main/scripts/keep.py),\n', '     *  or via an integration with the Keep3r network (e.g.\n', '     *  https://github.com/Macarse/GenericKeep3rV2/blob/master/contracts/keep3r/GenericKeep3rV2.sol).\n', "     * @param callCostInWei The keeper's estimated gas cost to call `harvest()` (in wei).\n", '     * @return `true` if `harvest()` should be called, `false` otherwise.\n', '     */\n', '    function harvestTrigger(uint256 callCostInWei) public view virtual returns (bool) {\n', '        uint256 callCost = ethToWant(callCostInWei);\n', '        StrategyParams memory params = vault.strategies(address(this));\n', '\n', '        // Should not trigger if Strategy is not activated\n', '        if (params.activation == 0) return false;\n', '\n', "        // Should not trigger if we haven't waited long enough since previous harvest\n", '        if (block.timestamp.sub(params.lastReport) < minReportDelay) return false;\n', '\n', "        // Should trigger if hasn't been called in a while\n", '        if (block.timestamp.sub(params.lastReport) >= maxReportDelay) return true;\n', '\n', '        // If some amount is owed, pay it back\n', '        // NOTE: Since debt is based on deposits, it makes sense to guard against large\n', '        //       changes to the value from triggering a harvest directly through user\n', '        //       behavior. This should ensure reasonable resistance to manipulation\n', '        //       from user-initiated withdrawals as the outstanding debt fluctuates.\n', '        uint256 outstanding = vault.debtOutstanding();\n', '        if (outstanding > debtThreshold) return true;\n', '\n', '        // Check for profits and losses\n', '        uint256 total = estimatedTotalAssets();\n', '        // Trigger if we have a loss to report\n', '        if (total.add(debtThreshold) < params.totalDebt) return true;\n', '\n', '        uint256 profit = 0;\n', "        if (total > params.totalDebt) profit = total.sub(params.totalDebt); // We've earned a profit!\n", '\n', '        // Otherwise, only trigger if it "makes sense" economically (gas cost\n', '        // is <N% of value moved)\n', '        uint256 credit = vault.creditAvailable();\n', '        return (profitFactor.mul(callCost) < credit.add(profit));\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Harvests the Strategy, recognizing any profits or losses and adjusting\n', "     *  the Strategy's position.\n", '     *\n', '     *  In the rare case the Strategy is in emergency shutdown, this will exit\n', "     *  the Strategy's position.\n", '     *\n', '     *  This may only be called by governance, the strategist, or the keeper.\n', '     * @dev\n', '     *  When `harvest()` is called, the Strategy reports to the Vault (via\n', '     *  `vault.report()`), so in some cases `harvest()` must be called in order\n', '     *  to take in profits, to borrow newly available funds from the Vault, or\n', '     *  otherwise adjust its position. In other cases `harvest()` must be\n', "     *  called to report to the Vault on the Strategy's position, especially if\n", '     *  any losses have occurred.\n', '     */\n', '    function harvest() external onlyKeepers {\n', '        uint256 profit = 0;\n', '        uint256 loss = 0;\n', '        uint256 debtOutstanding = vault.debtOutstanding();\n', '        uint256 debtPayment = 0;\n', '        if (emergencyExit) {\n', '            // Free up as much capital as possible\n', '            uint256 amountFreed = liquidateAllPositions();\n', '            if (amountFreed < debtOutstanding) {\n', '                loss = debtOutstanding.sub(amountFreed);\n', '            } else if (amountFreed > debtOutstanding) {\n', '                profit = amountFreed.sub(debtOutstanding);\n', '            }\n', '            debtPayment = debtOutstanding.sub(loss);\n', '        } else {\n', '            // Free up returns for Vault to pull\n', '            (profit, loss, debtPayment) = prepareReturn(debtOutstanding);\n', '        }\n', '\n', '        // Allow Vault to take up to the "harvested" balance of this contract,\n', '        // which is the amount it has earned since the last time it reported to\n', '        // the Vault.\n', '        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n', '        debtOutstanding = vault.report(profit, loss, debtPayment);\n', '\n', '        // Check if free returns are left, and re-invest them\n', '        adjustPosition(debtOutstanding);\n', '\n', '        // call healthCheck contract\n', '        if (doHealthCheck && healthCheck != address(0)) {\n', '            require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), "!healthcheck");\n', '        } else {\n', '            doHealthCheck = true;\n', '        }\n', '\n', '        emit Harvested(profit, loss, debtPayment, debtOutstanding);\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Withdraws `_amountNeeded` to `vault`.\n', '     *\n', '     *  This may only be called by the Vault.\n', '     * @param _amountNeeded How much `want` to withdraw.\n', '     * @return _loss Any realized losses\n', '     */\n', '    function withdraw(uint256 _amountNeeded) external returns (uint256 _loss) {\n', '        require(msg.sender == address(vault), "!vault");\n', '        // Liquidate as much as possible to `want`, up to `_amountNeeded`\n', '        uint256 amountFreed;\n', '        (amountFreed, _loss) = liquidatePosition(_amountNeeded);\n', '        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n', '        want.safeTransfer(msg.sender, amountFreed);\n', '        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\n', '    }\n', '\n', '    /**\n', '     * Do anything necessary to prepare this Strategy for migration, such as\n', '     * transferring any reserve or LP tokens, CDPs, or other tokens or stores of\n', '     * value.\n', '     */\n', '    function prepareMigration(address _newStrategy) internal virtual;\n', '\n', '    /**\n', '     * @notice\n', '     *  Transfers all `want` from this Strategy to `_newStrategy`.\n', '     *\n', '     *  This may only be called by the Vault.\n', '     * @dev\n', "     * The new Strategy's Vault must be the same as this Strategy's Vault.\n", '     *  The migration process should be carefully performed to make sure all\n', '     * the assets are migrated to the new address, which should have never\n', '     * interacted with the vault before.\n', '     * @param _newStrategy The Strategy to migrate to.\n', '     */\n', '    function migrate(address _newStrategy) external {\n', '        require(msg.sender == address(vault));\n', '        require(BaseStrategy(_newStrategy).vault() == vault);\n', '        prepareMigration(_newStrategy);\n', '        want.safeTransfer(_newStrategy, want.balanceOf(address(this)));\n', '    }\n', '\n', '    /**\n', '     * @notice\n', '     *  Activates emergency exit. Once activated, the Strategy will exit its\n', '     *  position upon the next harvest, depositing all funds into the Vault as\n', '     *  quickly as is reasonable given on-chain conditions.\n', '     *\n', '     *  This may only be called by governance or the strategist.\n', '     * @dev\n', '     *  See `vault.setEmergencyShutdown()` and `harvest()` for further details.\n', '     */\n', '    function setEmergencyExit() external onlyEmergencyAuthorized {\n', '        emergencyExit = true;\n', '        vault.revokeStrategy();\n', '\n', '        emit EmergencyExitEnabled();\n', '    }\n', '\n', '    /**\n', '     * Override this to add all tokens/tokenized positions this contract\n', '     * manages on a *persistent* basis (e.g. not just for swapping back to\n', '     * want ephemerally).\n', '     *\n', '     * NOTE: Do *not* include `want`, already included in `sweep` below.\n', '     *\n', '     * Example:\n', '     * ```\n', '     *    function protectedTokens() internal override view returns (address[] memory) {\n', '     *      address[] memory protected = new address[](3);\n', '     *      protected[0] = tokenA;\n', '     *      protected[1] = tokenB;\n', '     *      protected[2] = tokenC;\n', '     *      return protected;\n', '     *    }\n', '     * ```\n', '     */\n', '    function protectedTokens() internal view virtual returns (address[] memory);\n', '\n', '    /**\n', '     * @notice\n', '     *  Removes tokens from this Strategy that are not the type of tokens\n', '     *  managed by this Strategy. This may be used in case of accidentally\n', '     *  sending the wrong kind of token to this Strategy.\n', '     *\n', '     *  Tokens will be sent to `governance()`.\n', '     *\n', '     *  This will fail if an attempt is made to sweep `want`, or any tokens\n', '     *  that are protected by this Strategy.\n', '     *\n', '     *  This may only be called by governance.\n', '     * @dev\n', '     *  Implement `protectedTokens()` to specify any additional tokens that\n', '     *  should be protected from sweeping in addition to `want`.\n', '     * @param _token The token to transfer out of this vault.\n', '     */\n', '    function sweep(address _token) external onlyGovernance {\n', '        require(_token != address(want), "!want");\n', '        require(_token != address(vault), "!shares");\n', '\n', '        address[] memory _protectedTokens = protectedTokens();\n', '        for (uint256 i; i < _protectedTokens.length; i++) require(_token != _protectedTokens[i], "!protected");\n', '\n', '        IERC20(_token).safeTransfer(governance(), IERC20(_token).balanceOf(address(this)));\n', '    }\n', '}\n', '\n', '// Part: IKashiPair\n', '\n', 'interface IKashiPair {\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _value\n', '    );\n', '    event LogAccrue(\n', '        uint256 accruedAmount,\n', '        uint256 feeFraction,\n', '        uint64 rate,\n', '        uint256 utilization\n', '    );\n', '    event LogAddAsset(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share,\n', '        uint256 fraction\n', '    );\n', '    event LogAddCollateral(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share\n', '    );\n', '    event LogBorrow(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 part\n', '    );\n', '    event LogExchangeRate(uint256 rate);\n', '    event LogFeeTo(address indexed newFeeTo);\n', '    event LogRemoveAsset(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share,\n', '        uint256 fraction\n', '    );\n', '    event LogRemoveCollateral(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 share\n', '    );\n', '    event LogRepay(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        uint256 part\n', '    );\n', '    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function accrue() external;\n', '\n', '    function accrueInfo()\n', '        external\n', '        view\n', '        returns (\n', '            uint64 interestPerBlock,\n', '            uint64 lastBlockAccrued,\n', '            uint128 feesEarnedFraction\n', '        );\n', '\n', '    function addAsset(\n', '        address to,\n', '        bool skim,\n', '        uint256 share\n', '    ) external returns (uint256 fraction);\n', '\n', '    function addCollateral(\n', '        address to,\n', '        bool skim,\n', '        uint256 share\n', '    ) external;\n', '\n', '    function allowance(address, address) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function asset() external view returns (BIERC20);\n', '\n', '    function balanceOf(address) external view returns (uint256);\n', '\n', '    function bentoBox() external view returns (IBentoBoxV1);\n', '\n', '    function borrow(address to, uint256 amount)\n', '        external\n', '        returns (uint256 part, uint256 share);\n', '\n', '    function claimOwnership() external;\n', '\n', '    function collateral() external view returns (BIERC20);\n', '\n', '    function cook(\n', '        uint8[] calldata actions,\n', '        uint256[] calldata values,\n', '        bytes[] calldata datas\n', '    ) external payable returns (uint256 value1, uint256 value2);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function exchangeRate() external view returns (uint256);\n', '\n', '    function feeTo() external view returns (address);\n', '\n', '    function getInitData(\n', '        BIERC20 collateral_,\n', '        BIERC20 asset_,\n', '        IOracle oracle_,\n', '        bytes calldata oracleData_\n', '    ) external pure returns (bytes memory data);\n', '\n', '    function init(bytes calldata data) external payable;\n', '\n', '    function isSolvent(address user, bool open) external view returns (bool);\n', '\n', '    function liquidate(\n', '        address[] calldata users,\n', '        uint256[] calldata borrowParts,\n', '        address to,\n', '        ISwapper swapper,\n', '        bool open\n', '    ) external;\n', '\n', '    function masterContract() external view returns (address);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function nonces(address) external view returns (uint256);\n', '\n', '    function oracle() external view returns (IOracle);\n', '\n', '    function oracleData() external view returns (bytes memory);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function pendingOwner() external view returns (address);\n', '\n', '    function permit(\n', '        address owner_,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function removeAsset(address to, uint256 fraction)\n', '        external\n', '        returns (uint256 share);\n', '\n', '    function removeCollateral(address to, uint256 share) external;\n', '\n', '    function repay(\n', '        address to,\n', '        bool skim,\n', '        uint256 part\n', '    ) external returns (uint256 amount);\n', '\n', '    function setFeeTo(address newFeeTo) external;\n', '\n', '    function setSwapper(ISwapper swapper, bool enable) external;\n', '\n', '    function swappers(ISwapper) external view returns (bool);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function totalAsset() external view returns (Rebase memory);\n', '\n', '    function totalBorrow() external view returns (Rebase memory);\n', '\n', '    function totalCollateralShare() external view returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) external;\n', '\n', '    function updateExchangeRate() external returns (bool updated, uint256 rate);\n', '\n', '    function userBorrowPart(address) external view returns (uint256);\n', '\n', '    function userCollateralShare(address) external view returns (uint256);\n', '\n', '    function withdrawFees() external;\n', '}\n', '\n', '// File: Strategy.sol\n', '\n', 'contract Strategy is BaseStrategy {\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    using SafeMath for uint256;\n', '    using RebaseLibrary for Rebase;\n', '\n', '    struct KashiPairInfo {\n', '        IKashiPair kashiPair;\n', '        uint256 pid;\n', '    }\n', '\n', '    bool internal isOriginal = true;\n', '    uint256 internal constant MAX_PAIRS = 5;\n', '    uint256 internal constant MAX_BPS = 1e4;\n', '\n', '    // Kashi constants (apply to MediumRiskPairs)\n', '    uint256 internal constant KASHI_MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\n', '    uint256 internal constant KASHI_MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\n', '    uint256 internal constant KASHI_UTILIZATION_PRECISION = 1e18;\n', '\n', '    IERC20 internal constant weth =\n', '        IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    IERC20 internal constant sushi =\n', '        IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n', '\n', '    IMasterChef public constant masterChef =\n', '        IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n', '    IUniswapV2Router02 public constant sushiRouter =\n', '        IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n', '\n', '    IBentoBox public bentoBox;\n', '    KashiPairInfo[] public kashiPairs;\n', '\n', '    uint256 public dustThreshold = 2;\n', '\n', '    // Path for swaps\n', '    address[] private path;\n', '\n', '    string private strategyName;\n', '\n', '    constructor(\n', '        address _vault,\n', '        address _bentoBox,\n', '        address[] memory _kashiPairs,\n', '        uint256[] memory _pids,\n', '        string memory _strategyName\n', '    ) public BaseStrategy(_vault) {\n', '        _initializeStrat(_bentoBox, _kashiPairs, _pids, _strategyName);\n', '    }\n', '\n', '    function initialize(\n', '        address _vault,\n', '        address _strategist,\n', '        address _rewards,\n', '        address _keeper,\n', '        address _bentoBox,\n', '        address[] memory _kashiPairs,\n', '        uint256[] memory _pids,\n', '        string memory _strategyName\n', '    ) public {\n', '        _initialize(_vault, _strategist, _rewards, _keeper);\n', '        _initializeStrat(_bentoBox, _kashiPairs, _pids, _strategyName);\n', '    }\n', '\n', '    event Cloned(address indexed clone);\n', '\n', '    function cloneKashiLender(\n', '        address _vault,\n', '        address _strategist,\n', '        address _rewards,\n', '        address _keeper,\n', '        address _bentoBox,\n', '        address[] memory _kashiPairs,\n', '        uint256[] memory _pids,\n', '        string memory _strategyName\n', '    ) external returns (address newStrategy) {\n', '        require(isOriginal);\n', '        // Copied from https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\n', '        bytes20 addressBytes = bytes20(address(this));\n', '        assembly {\n', '            // EIP-1167 bytecode\n', '            let clone_code := mload(0x40)\n', '            mstore(\n', '                clone_code,\n', '                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n', '            )\n', '            mstore(add(clone_code, 0x14), addressBytes)\n', '            mstore(\n', '                add(clone_code, 0x28),\n', '                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n', '            )\n', '            newStrategy := create(0, clone_code, 0x37)\n', '        }\n', '\n', '        Strategy(newStrategy).initialize(\n', '            _vault,\n', '            _strategist,\n', '            _rewards,\n', '            _keeper,\n', '            _bentoBox,\n', '            _kashiPairs,\n', '            _pids,\n', '            _strategyName\n', '        );\n', '\n', '        emit Cloned(newStrategy);\n', '    }\n', '\n', '    function _initializeStrat(\n', '        address _bentoBox,\n', '        address[] memory _kashiPairs,\n', '        uint256[] memory _pids,\n', '        string memory _strategyName\n', '    ) internal {\n', '        require(address(bentoBox) == address(0)); // Check if previously initialized\n', '        require(_kashiPairs.length <= MAX_PAIRS); // Must not exceed the max length\n', '        require(_kashiPairs.length == _pids.length); // Pairs length must match pids length\n', '\n', '        strategyName = bytes(_strategyName).length == 0\n', '            ? "StrategyKashiMultiPairLender"\n', '            : _strategyName;\n', '\n', '        bentoBox = IBentoBox(_bentoBox);\n', '\n', '        healthCheck = address(0xDDCea799fF1699e98EDF118e0629A974Df7DF012); // health.ychad.eth\n', '\n', '        for (uint256 i = 0; i < _kashiPairs.length; i++) {\n', '            kashiPairs.push(\n', '                KashiPairInfo(IKashiPair(_kashiPairs[i]), _pids[i])\n', '            );\n', '            // kashiPair must use the right bentoBox\n', '            require(address(kashiPairs[i].kashiPair.bentoBox()) == _bentoBox);\n', '            // kashiPair asset must match want\n', '            require(address(kashiPairs[i].kashiPair.asset()) == address(want));\n', '\n', '            if (_pids[i] != 0) {\n', '                // the masterChef pid token must match the kashiPair\n', '                require(\n', '                    address(masterChef.poolInfo(_pids[i]).lpToken) ==\n', '                        _kashiPairs[i]\n', '                );\n', '\n', '                IERC20(_kashiPairs[i]).safeApprove(\n', '                    address(masterChef),\n', '                    type(uint256).max\n', '                );\n', '            }\n', '        }\n', '\n', '        want.safeApprove(_bentoBox, type(uint256).max);\n', '        sushi.safeApprove(address(sushiRouter), type(uint256).max);\n', '\n', '        // Initialize the swap path\n', '        path = new address[](3);\n', '        path[0] = address(sushi);\n', '        path[1] = address(weth);\n', '        path[2] = address(want);\n', '    }\n', '\n', '    function name() external view override returns (string memory) {\n', '        return strategyName;\n', '    }\n', '\n', '    function estimatedTotalAssets() public view override returns (uint256) {\n', '        uint256 totalShares = sharesInBento();\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            totalShares = totalShares.add(\n', '                kashiFractionToBentoShares(\n', '                    kashiPairInfo.kashiPair,\n', '                    kashiFractionTotal(\n', '                        kashiPairInfo.kashiPair,\n', '                        kashiPairInfo.pid\n', '                    )\n', '                )\n', '            );\n', '        }\n', '\n', '        return balanceOfWant().add(bentoSharesToWant(totalShares));\n', '    }\n', '\n', '    function kashiPairEstimatedAssets(uint256 i) public view returns (uint256) {\n', '        KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '        return\n', '            bentoSharesToWant(\n', '                kashiFractionToBentoShares(\n', '                    kashiPairInfo.kashiPair,\n', '                    kashiFractionTotal(\n', '                        kashiPairInfo.kashiPair,\n', '                        kashiPairInfo.pid\n', '                    )\n', '                )\n', '            );\n', '    }\n', '\n', '    function prepareReturn(uint256 _debtOutstanding)\n', '        internal\n', '        override\n', '        returns (\n', '            uint256 _profit,\n', '            uint256 _loss,\n', '            uint256 _debtPayment\n', '        )\n', '    {\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '            if (\n', '                kashiFractionTotal(\n', '                    kashiPairInfo.kashiPair,\n', '                    kashiPairInfo.pid\n', '                ) == 0\n', '            ) continue; // skip the pair has no assets\n', '            accrueInterest(kashiPairInfo.kashiPair);\n', '            depositKashiInMasterChef(\n', '                kashiPairInfo.kashiPair,\n', '                kashiPairInfo.pid\n', '            ); // claim and deposit loose\n', '        }\n', '\n', '        sell();\n', '\n', '        uint256 assets = estimatedTotalAssets();\n', '        uint256 wantBal = balanceOfWant();\n', '\n', '        uint256 debt = vault.strategies(address(this)).totalDebt;\n', '\n', '        if (assets >= debt) {\n', '            _profit = assets.sub(debt);\n', '        } else {\n', '            _loss = debt.sub(assets);\n', '        }\n', '\n', '        _debtPayment = _debtOutstanding;\n', '        uint256 amountToFree = _debtPayment.add(_profit);\n', '\n', '        if (amountToFree > 0 && wantBal < amountToFree) {\n', '            (uint256 newLoose, ) = liquidatePosition(amountToFree);\n', '\n', '            // if we didnt free enough money, prioritize paying down debt before taking profit\n', '            if (newLoose < amountToFree) {\n', '                if (newLoose <= _debtPayment) {\n', '                    _profit = 0;\n', '                    _debtPayment = newLoose;\n', '                } else {\n', '                    _profit = newLoose.sub(_debtPayment);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function adjustPosition(uint256 _debtOutstanding) internal override {\n', '        if (emergencyExit) {\n', '            return;\n', '        }\n', '\n', '        uint256 wantBalance = balanceOfWant();\n', '\n', '        uint256 shares = 0;\n', '\n', '        if (wantBalance > dustThreshold) {\n', '            (, shares) = depositInBento(wantBalance);\n', '        }\n', '\n', '        uint256 sharesInBento = sharesInBento();\n', '\n', '        if (sharesInBento > wantToBentoShares(dustThreshold)) {\n', '            // Get highest interest rate pair\n', '            (IKashiPair highestPair, uint256 highestPid) =\n', '                highestInterestPair(sharesInBento);\n', '\n', '            depositInKashiPair(highestPair, highestPid, sharesInBento);\n', '        }\n', '    }\n', '\n', '    function liquidatePosition(uint256 _amountNeeded)\n', '        internal\n', '        override\n', '        returns (uint256 _liquidatedAmount, uint256 _loss)\n', '    {\n', '        uint256 wantBalance = balanceOfWant();\n', '\n', '        if (_amountNeeded <= wantBalance) {\n', '            return (_amountNeeded, 0);\n', '        }\n', '\n', '        uint256 amountToFree = _amountNeeded.sub(wantBalance);\n', '        uint256 deposited = estimatedTotalAssets().sub(wantBalance);\n', '\n', '        if (amountToFree.add(dustThreshold) > deposited) {\n', '            amountToFree = deposited;\n', '        }\n', '\n', '        if (amountToFree > 0) {\n', '            uint256 sharesNeeded = wantToBentoShares(amountToFree);\n', '            uint256 bentoShares = sharesInBento();\n', '\n', '            if (sharesNeeded > bentoShares) {\n', '                uint256 sharesToFreeFromKashi = sharesNeeded.sub(bentoShares);\n', '                uint256 sharesFreedFromKashi = 0;\n', '\n', '                // Find the lowest apr pair with at least the lesser of\n', '                //   - the amount to free\n', '                //   - the mean assets per pair\n', '                (IKashiPair lowestPair, uint256 lowestPid) =\n', '                    lowestInterestPair(\n', '                        Math.min(\n', '                            sharesToFreeFromKashi,\n', '                            wantToBentoShares(\n', '                                estimatedTotalAssets().div(kashiPairs.length)\n', '                            )\n', '                        )\n', '                    );\n', '                if (address(lowestPair) != address(0)) {\n', '                    sharesFreedFromKashi = liquidateKashiPair(\n', '                        lowestPair,\n', '                        lowestPid,\n', '                        sharesToFreeFromKashi\n', '                    );\n', '                }\n', '\n', '                for (\n', '                    uint256 i = 0;\n', '                    i < kashiPairs.length &&\n', '                        sharesFreedFromKashi.add(dustThreshold) <\n', '                        sharesToFreeFromKashi;\n', '                    i++\n', '                ) {\n', '                    KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '                    if (address(kashiPairInfo.kashiPair) == address(lowestPair))\n', '                        continue; // we already visited this\n', '\n', '                    sharesFreedFromKashi = sharesFreedFromKashi.add(\n', '                        liquidateKashiPair(\n', '                            kashiPairInfo.kashiPair,\n', '                            kashiPairInfo.pid,\n', '                            sharesToFreeFromKashi.sub(sharesFreedFromKashi)\n', '                        )\n', '                    );\n', '                }\n', '            }\n', '\n', '            bentoBox.withdraw(\n', '                BIERC20(address(want)),\n', '                address(this),\n', '                address(this),\n', '                0,\n', '                sharesInBento()\n', '            );\n', '        }\n', '\n', '        _liquidatedAmount = Math.min(balanceOfWant(), _amountNeeded);\n', '\n', '        // To prevent the vault from moving on to the next strategy in the queue\n', '        // when we return the amountRequested minus dust, take a dust sized loss\n', '        if (_liquidatedAmount < _amountNeeded) {\n', '            uint256 diff = _amountNeeded.sub(_liquidatedAmount);\n', '            if (diff <= dustThreshold) {\n', '                _loss = diff;\n', '            }\n', '        }\n', '    }\n', '\n', '    function liquidateAllPositions()\n', '        internal\n', '        override\n', '        returns (uint256 _liquidatedAmount)\n', '    {\n', '        (_liquidatedAmount, ) = liquidatePosition(estimatedTotalAssets());\n', '    }\n', '\n', '    // new strategy **must** have the same kashiPairs attached\n', '    function prepareMigration(address _newStrategy) internal override {\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            if (kashiPairInfo.pid != 0) {\n', '                masterChef.withdraw(\n', '                    kashiPairInfo.pid,\n', '                    kashiFactionInMasterChef(kashiPairInfo.pid)\n', '                );\n', '            }\n', '\n', '            kashiPairs[i].kashiPair.transfer(\n', '                _newStrategy,\n', '                kashiFractionInPair(kashiPairInfo.kashiPair)\n', '            );\n', '        }\n', '    }\n', '\n', '    function addKashiPair(address _newKashiPair, uint256 _newPid)\n', '        external\n', '        onlyGovernance\n', '    {\n', '        // cannot exceed max pair length\n', '        require(kashiPairs.length < MAX_PAIRS);\n', '        // must use the correct bentobox\n', '        require(\n', '            address(IKashiPair(_newKashiPair).bentoBox()) == address(bentoBox)\n', '        );\n', '        // kashPair asset must match want\n', '        require(IKashiPair(_newKashiPair).asset() == BIERC20(address(want)));\n', '        if (_newPid != 0) {\n', '            // masterChef pid token must match the kashiPair\n', '            require(\n', '                address(masterChef.poolInfo(_newPid).lpToken) == _newKashiPair\n', '            );\n', '        }\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            // kashiPair must not already be attached\n', '            require(_newKashiPair != address(kashiPairs[i].kashiPair));\n', '        }\n', '\n', '        kashiPairs.push(KashiPairInfo(IKashiPair(_newKashiPair), _newPid));\n', '\n', '        if (_newPid != 0) {\n', '            IERC20(_newKashiPair).safeApprove(\n', '                address(masterChef),\n', '                type(uint256).max\n', '            );\n', '        }\n', '    }\n', '\n', '    function removeKashiPair(\n', '        address _remKashiPair,\n', '        uint256 _remIndex,\n', '        bool _force\n', '    ) external onlyEmergencyAuthorized {\n', '        KashiPairInfo memory kashiPairInfo = kashiPairs[_remIndex];\n', '\n', '        require(_remKashiPair == address(kashiPairInfo.kashiPair));\n', '\n', '        liquidateKashiPair(\n', '            kashiPairInfo.kashiPair,\n', '            kashiPairInfo.pid,\n', '            type(uint256).max // liquidateAll\n', '        );\n', '\n', '        if (!_force) {\n', '            // must have liquidated all but dust\n', '            require(\n', '                kashiFractionTotal(\n', '                    kashiPairInfo.kashiPair,\n', '                    kashiPairInfo.pid\n', '                ) <= dustThreshold\n', '            );\n', '        }\n', '\n', '        if (kashiPairInfo.pid != 0) {\n', '            IERC20(_remKashiPair).safeApprove(address(masterChef), 0);\n', '        }\n', '        kashiPairs[_remIndex] = kashiPairs[kashiPairs.length - 1];\n', '        kashiPairs.pop();\n', '    }\n', '\n', '    function adjustKashiPairRatios(uint256[] calldata _ratios)\n', '        external\n', '        onlyAuthorized\n', '    {\n', '        // length of ratios must match number of pairs\n', '        require(_ratios.length == kashiPairs.length);\n', '\n', '        uint256 totalRatio;\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            // We must accrue all pairs to ensure we get an accurate estimate of assets\n', '            accrueInterest(kashiPairs[i].kashiPair);\n', '            totalRatio += _ratios[i];\n', '        }\n', '\n', '        require(totalRatio == MAX_BPS); //ratios must add to 10000 bps\n', '\n', '        uint256 wantBalance = balanceOfWant();\n', '        if (wantBalance > dustThreshold) {\n', '            depositInBento(wantBalance);\n', '        }\n', '\n', '        uint256 totalAssets = estimatedTotalAssets();\n', '        uint256[] memory kashiPairsIncreasedAllocation =\n', '            new uint256[](kashiPairs.length);\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            uint256 pairTotalAssets =\n', '                bentoSharesToWant(\n', '                    kashiFractionToBentoShares(\n', '                        kashiPairInfo.kashiPair,\n', '                        kashiFractionTotal(\n', '                            kashiPairInfo.kashiPair,\n', '                            kashiPairInfo.pid\n', '                        )\n', '                    )\n', '                );\n', '            uint256 targetAssets = (_ratios[i] * totalAssets) / MAX_BPS;\n', '            if (targetAssets < pairTotalAssets) {\n', '                uint256 toLiquidate = pairTotalAssets.sub(targetAssets);\n', '                liquidateKashiPair(\n', '                    kashiPairInfo.kashiPair,\n', '                    kashiPairInfo.pid,\n', '                    wantToBentoShares(toLiquidate)\n', '                );\n', '            } else if (targetAssets > pairTotalAssets) {\n', '                kashiPairsIncreasedAllocation[i] = targetAssets.sub(\n', '                    pairTotalAssets\n', '                );\n', '            }\n', '        }\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            if (kashiPairsIncreasedAllocation[i] == 0) continue;\n', '\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            uint256 sharesInBento = sharesInBento();\n', '            uint256 sharesToAdd =\n', '                wantToBentoShares(kashiPairsIncreasedAllocation[i]);\n', '\n', '            if (sharesToAdd > sharesInBento) {\n', '                sharesToAdd = sharesInBento;\n', '            }\n', '\n', '            depositInKashiPair(\n', '                kashiPairInfo.kashiPair,\n', '                kashiPairInfo.pid,\n', '                sharesToAdd\n', '            );\n', '        }\n', '    }\n', '\n', '    function depositInKashiPair(\n', '        IKashiPair kashiPair,\n', '        uint256 pid,\n', '        uint256 sharesToDeposit\n', '    ) internal {\n', '        transferBento(address(kashiPair), sharesToDeposit);\n', '\n', '        uint256 depositedFraction =\n', '            kashiPair.addAsset(address(this), true, sharesToDeposit);\n', '\n', '        depositKashiInMasterChef(kashiPair, pid);\n', '    }\n', '\n', '    function depositKashiInMasterChef(IKashiPair kashiPair, uint256 pid)\n', '        internal\n', '    {\n', '        if (pid == 0) return;\n', '\n', '        uint256 fractionsToStake = kashiFractionInPair(kashiPair);\n', '        masterChef.deposit(pid, fractionsToStake);\n', '    }\n', '\n', '    function depositInBento(uint256 wantToDeposit)\n', '        internal\n', '        returns (uint256 amountOut, uint256 shareOut)\n', '    {\n', '        return\n', '            bentoBox.deposit(\n', '                BIERC20(address(want)),\n', '                address(this),\n', '                address(this),\n', '                wantToDeposit,\n', '                0\n', '            );\n', '    }\n', '\n', '    function transferBento(address to, uint256 shares) internal {\n', '        bentoBox.transfer(\n', '            BIERC20(address(want)),\n', '            address(this),\n', '            address(to),\n', '            shares\n', '        );\n', '    }\n', '\n', '    function liquidateKashiPair(\n', '        IKashiPair kashiPair,\n', '        uint256 pid,\n', '        uint256 sharesToFree\n', '    ) internal returns (uint256 _shareLiquidated) {\n', '        // We need to call accrue to accurately calculate totalAssets\n', '        accrueInterest(kashiPair);\n', '\n', '        uint256 liquidShares = kashiPairLiquidShares(kashiPair);\n', '        if (sharesToFree > liquidShares) {\n', '            sharesToFree = liquidShares;\n', '        }\n', '\n', '        if (sharesToFree == 0) return 0;\n', '\n', '        uint256 fractionsToFree =\n', '            bentoSharesToKashiFraction(kashiPair, sharesToFree);\n', '\n', '        // Remove from masterChef if there is a non-zero pid\n', '        if (pid != 0) {\n', '            uint256 fractionInMc = kashiFactionInMasterChef(pid);\n', '            uint256 fractionsToFreeFromMc = fractionsToFree;\n', '            if (fractionsToFreeFromMc.add(dustThreshold) > fractionInMc) {\n', '                fractionsToFreeFromMc = fractionInMc;\n', '            }\n', '            masterChef.withdraw(pid, fractionsToFreeFromMc);\n', '        }\n', '\n', '        uint256 fractionBalance = kashiFractionInPair(kashiPair);\n', '\n', '        if (fractionsToFree.add(dustThreshold) > fractionBalance) {\n', '            fractionsToFree = fractionBalance;\n', '        }\n', '\n', '        _shareLiquidated = kashiPair.removeAsset(\n', '            address(this),\n', '            fractionsToFree\n', '        );\n', '\n', "        // Redeposit into the masterChef if there's some spare change\n", '        depositKashiInMasterChef(kashiPair, pid);\n', '    }\n', '\n', '    // sell all function\n', '    function sell() internal {\n', '        uint256 sushiBal = balanceOfSushi();\n', '        if (sushiBal == 0) {\n', '            return;\n', '        }\n', '\n', '        sushiRouter.swapExactTokensForTokens(\n', '            sushiBal,\n', '            uint256(0),\n', '            path,\n', '            address(this),\n', '            now\n', '        );\n', '    }\n', '\n', '    function accrueInterest(IKashiPair kashiPair) internal {\n', '        (, uint256 lastAccrued, ) = kashiPair.accrueInfo();\n', '        // Accure interest\n', '        if (block.timestamp > lastAccrued) {\n', '            kashiPair.accrue();\n', '        }\n', '    }\n', '\n', '    function setDustThreshold(uint256 _newDustThreshold)\n', '        external\n', '        onlyAuthorized\n', '    {\n', '        dustThreshold = _newDustThreshold;\n', '    }\n', '\n', '    function setPath(address[] calldata _path) external onlyGovernance {\n', '        path = _path;\n', '    }\n', '\n', '    function balanceOfWant() internal view returns (uint256) {\n', '        return want.balanceOf(address(this));\n', '    }\n', '\n', '    function balanceOfSushi() internal view returns (uint256) {\n', '        return sushi.balanceOf(address(this));\n', '    }\n', '\n', '    function sharesInBento() internal view returns (uint256) {\n', '        return bentoBox.balanceOf(BIERC20(address(want)), address(this));\n', '    }\n', '\n', '    function kashiFractionTotal(IKashiPair kashiPair, uint256 pid)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            kashiFactionInMasterChef(pid).add(kashiFractionInPair(kashiPair));\n', '    }\n', '\n', '    function kashiFactionInMasterChef(uint256 pid)\n', '        internal\n', '        view\n', '        returns (uint256 _kashiFraction)\n', '    {\n', '        if (pid != 0) {\n', '            _kashiFraction = masterChef.userInfo(pid, address(this)).amount;\n', '        }\n', '    }\n', '\n', '    function kashiFractionInPair(IKashiPair kashiPair)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return kashiPair.balanceOf(address(this));\n', '    }\n', '\n', '    function kashiPairLiquidShares(IKashiPair kashiPair)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return kashiPair.totalAsset().elastic;\n', '    }\n', '\n', '    // highestInterestIndex finds the best pair to invest the given deposit\n', '    function highestInterestPair(uint256 sharesToDeposit)\n', '        internal\n', '        view\n', '        returns (IKashiPair _highestPair, uint256 _highestPid)\n', '    {\n', '        uint256 highestInterest = 0;\n', '        uint256 highestUtilization = 0;\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            (uint256 interestPerBlock, , ) =\n', '                kashiPairInfo.kashiPair.accrueInfo();\n', '\n', '            uint256 utilization =\n', '                kashiPairUtilization(kashiPairInfo.kashiPair, sharesToDeposit);\n', '\n', '            // A pair is highest (really best) if either\n', "            //   - It's utilization is higher, and either\n", '            //     - It is above the max target util\n', '            //     - The existing choice is below the min util target\n', '            //   - Compare APR directly only if both are between the min and max\n', '            if (\n', '                (utilization > highestUtilization &&\n', '                    (utilization > KASHI_MAXIMUM_TARGET_UTILIZATION ||\n', '                        highestUtilization <\n', '                        KASHI_MINIMUM_TARGET_UTILIZATION)) ||\n', '                (interestPerBlock > highestInterest &&\n', '                    utilization < KASHI_MAXIMUM_TARGET_UTILIZATION &&\n', '                    utilization > KASHI_MINIMUM_TARGET_UTILIZATION &&\n', '                    highestUtilization < KASHI_MAXIMUM_TARGET_UTILIZATION &&\n', '                    highestUtilization > KASHI_MINIMUM_TARGET_UTILIZATION)\n', '            ) {\n', '                highestInterest = interestPerBlock;\n', '                highestUtilization = utilization;\n', '                _highestPair = kashiPairInfo.kashiPair;\n', '                _highestPid = kashiPairInfo.pid;\n', '            }\n', '        }\n', '    }\n', '\n', '    function lowestInterestPair(uint256 minLiquidShares)\n', '        internal\n', '        view\n', '        returns (IKashiPair _lowestPair, uint256 _lowestPid)\n', '    {\n', '        uint256 lowestInterest = type(uint256).max;\n', '        uint256 lowestUtilization = KASHI_UTILIZATION_PRECISION;\n', '\n', '        for (uint256 i = 0; i < kashiPairs.length; i++) {\n', '            KashiPairInfo memory kashiPairInfo = kashiPairs[i];\n', '\n', '            (uint256 interestPerBlock, , ) =\n', '                kashiPairInfo.kashiPair.accrueInfo();\n', '\n', '            uint256 utilization =\n', '                kashiPairUtilization(kashiPairInfo.kashiPair, 0);\n', '\n', '            // A pair is lowest if either\n', "            //   - It's utilization is lower, and either\n", '            //     - It is below the min taget util\n', '            //     - The existing choice is above the max target util\n', '            //   - Compare APR directly only if both are between the min and max\n', '            if (\n', '                ((utilization < lowestUtilization &&\n', '                    (lowestUtilization > KASHI_MAXIMUM_TARGET_UTILIZATION ||\n', '                        utilization < KASHI_MINIMUM_TARGET_UTILIZATION)) ||\n', '                    (interestPerBlock < lowestInterest &&\n', '                        utilization < KASHI_MAXIMUM_TARGET_UTILIZATION &&\n', '                        utilization > KASHI_MINIMUM_TARGET_UTILIZATION &&\n', '                        lowestUtilization < KASHI_MAXIMUM_TARGET_UTILIZATION &&\n', '                        lowestUtilization >\n', '                        KASHI_MINIMUM_TARGET_UTILIZATION)) &&\n', '                kashiFractionTotal(kashiPairInfo.kashiPair, kashiPairInfo.pid) >\n', '                dustThreshold &&\n', '                kashiPairLiquidShares(kashiPairInfo.kashiPair) >=\n', '                minLiquidShares\n', '            ) {\n', '                lowestInterest = interestPerBlock;\n', '                _lowestPair = kashiPairInfo.kashiPair;\n', '                _lowestPid = kashiPairInfo.pid;\n', '            }\n', '        }\n', '    }\n', '\n', '    function kashiPairUtilization(IKashiPair kashiPair, uint256 sharesToDeposit)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalAssetShares = kashiPair.totalAsset().elastic;\n', '        uint256 totalBorrowAmount = kashiPair.totalBorrow().elastic;\n', '        uint256 fullAssetAmount =\n', '            bentoBox\n', '                .toAmount(\n', '                BIERC20(address(this)),\n', '                totalAssetShares.add(sharesToDeposit),\n', '                false\n', '            )\n', '                .add(totalBorrowAmount);\n', '\n', '        return\n', '            uint256(totalBorrowAmount).mul(KASHI_UTILIZATION_PRECISION).div(\n', '                fullAssetAmount\n', '            );\n', '    }\n', '\n', '    function wantToBentoShares(uint256 wantAmount)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (wantAmount == 0) return 0;\n', '        return bentoBox.toShare(BIERC20(address(this)), wantAmount, true);\n', '    }\n', '\n', '    function bentoSharesToWant(uint256 bentoShares)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (bentoShares == 0) return 0;\n', '        return bentoBox.toAmount(BIERC20(address(this)), bentoShares, true);\n', '    }\n', '\n', '    function bentoSharesToKashiFraction(\n', '        IKashiPair kashiPair,\n', '        uint256 bentoShares\n', '    ) internal view returns (uint256 _kashiFraction) {\n', '        // Adapted from https://github.com/sushiswap/kashi-lending/blob/b6e3521d8628a835935c94a9039cfd192044d66b/contracts/KashiPair.sol#L320-L323\n', '        Rebase memory totalAsset = kashiPair.totalAsset();\n', '        Rebase memory totalBorrow = kashiPair.totalBorrow();\n', '        uint256 allShare =\n', '            uint256(totalAsset.elastic).add(\n', '                wantToBentoShares(totalBorrow.elastic)\n', '            );\n', '        _kashiFraction = allShare == 0\n', '            ? bentoShares\n', '            : bentoShares.mul(totalAsset.base).div(allShare);\n', '    }\n', '\n', '    function kashiFractionToBentoShares(\n', '        IKashiPair kashiPair,\n', '        uint256 _kashiFraction\n', '    ) internal view returns (uint256 bentoShares) {\n', '        // Adapted from https://github.com/sushiswap/kashi-lending/blob/b6e3521d8628a835935c94a9039cfd192044d66b/contracts/KashiPair.sol#L351-L353\n', '        Rebase memory totalAsset = kashiPair.totalAsset();\n', '        Rebase memory totalBorrow = kashiPair.totalBorrow();\n', '        uint256 allShare =\n', '            uint256(totalAsset.elastic).add(\n', '                wantToBentoShares(totalBorrow.elastic)\n', '            );\n', '        bentoShares = _kashiFraction.mul(allShare).div(totalAsset.base);\n', '    }\n', '\n', '    function protectedTokens()\n', '        internal\n', '        view\n', '        override\n', '        returns (address[] memory)\n', '    {}\n', '\n', '    function ethToWant(uint256 _amtInWei)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        // TODO create an accurate price oracle\n', '        return _amtInWei;\n', '    }\n', '}']