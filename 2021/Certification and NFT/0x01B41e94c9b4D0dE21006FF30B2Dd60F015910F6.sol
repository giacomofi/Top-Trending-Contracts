['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Ingest Registry Contract\n', ' * @author Origin Protocol Inc\n', ' */\n', '\n', 'import "../governance/Governable.sol";\n', '\n', 'contract IngestRegistry is Governable {\n', '    address public endpointImplementation;\n', '    address public master;\n', '    address public pool;\n', '\n', '    event NewEndpointImplementation(\n', '        address indexed newCollector,\n', '        address indexed oldCollector\n', '    );\n', '\n', '    event NewMaster(address indexed newMaster, address indexed oldMaster);\n', '\n', '    event NewPool(address indexed newPool, address indexed oldPool);\n', '\n', '    function setEndpointImplementation(address addr) external onlyGovernor {\n', '        emit NewEndpointImplementation(addr, endpointImplementation);\n', '        endpointImplementation = addr;\n', '    }\n', '\n', '    function setMaster(address addr) external onlyGovernor {\n', '        emit NewMaster(addr, master);\n', '        master = addr;\n', '    }\n', '\n', '    function setPool(address addr) external onlyGovernor {\n', '        emit NewPool(addr, pool);\n', '        pool = addr;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title OUSD Governable Contract\n', ' * @dev Copy of the openzeppelin Ownable.sol contract with nomenclature change\n', ' *      from owner to governor and renounce methods removed. Does not use\n', ' *      Context.sol like Ownable.sol does for simplification.\n', ' * @author Origin Protocol Inc\n', ' */\n', 'abstract contract Governable {\n', '    // Storage position of the owner and pendingOwner of the contract\n', '    // keccak256("OUSD.governor");\n', '    bytes32 private constant governorPosition =\n', '        0x7bea13895fa79d2831e0a9e28edede30099005a50d652d8957cf8a607ee6ca4a;\n', '\n', '    // keccak256("OUSD.pending.governor");\n', '    bytes32 private constant pendingGovernorPosition =\n', '        0x44c4d30b2eaad5130ad70c3ba6972730566f3e6359ab83e800d905c61b1c51db;\n', '\n', '    // keccak256("OUSD.reentry.status");\n', '    bytes32 private constant reentryStatusPosition =\n', '        0x53bf423e48ed90e97d02ab0ebab13b2a235a6bfbe9c321847d5c175333ac4535;\n', '\n', '    // See OpenZeppelin ReentrancyGuard implementation\n', '    uint256 constant _NOT_ENTERED = 1;\n', '    uint256 constant _ENTERED = 2;\n', '\n', '    event PendingGovernorshipTransfer(\n', '        address indexed previousGovernor,\n', '        address indexed newGovernor\n', '    );\n', '\n', '    event GovernorshipTransferred(\n', '        address indexed previousGovernor,\n', '        address indexed newGovernor\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial Governor.\n', '     */\n', '    constructor() {\n', '        _setGovernor(msg.sender);\n', '        emit GovernorshipTransferred(address(0), _governor());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current Governor.\n', '     */\n', '    function governor() public view returns (address) {\n', '        return _governor();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current Governor.\n', '     */\n', '    function _governor() internal view returns (address governorOut) {\n', '        bytes32 position = governorPosition;\n', '        assembly {\n', '            governorOut := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the pending Governor.\n', '     */\n', '    function _pendingGovernor()\n', '        internal\n', '        view\n', '        returns (address pendingGovernor)\n', '    {\n', '        bytes32 position = pendingGovernorPosition;\n', '        assembly {\n', '            pendingGovernor := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the Governor.\n', '     */\n', '    modifier onlyGovernor() {\n', '        require(isGovernor(), "Caller is not the Governor");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current Governor.\n', '     */\n', '    function isGovernor() public view returns (bool) {\n', '        return msg.sender == _governor();\n', '    }\n', '\n', '    function _setGovernor(address newGovernor) internal {\n', '        bytes32 position = governorPosition;\n', '        assembly {\n', '            sstore(position, newGovernor)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        bytes32 position = reentryStatusPosition;\n', '        uint256 _reentry_status;\n', '        assembly {\n', '            _reentry_status := sload(position)\n', '        }\n', '\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_reentry_status != _ENTERED, "Reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        assembly {\n', '            sstore(position, _ENTERED)\n', '        }\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        assembly {\n', '            sstore(position, _NOT_ENTERED)\n', '        }\n', '    }\n', '\n', '    function _setPendingGovernor(address newGovernor) internal {\n', '        bytes32 position = pendingGovernorPosition;\n', '        assembly {\n', '            sstore(position, newGovernor)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers Governance of the contract to a new account (`newGovernor`).\n', '     * Can only be called by the current Governor. Must be claimed for this to complete\n', '     * @param _newGovernor Address of the new Governor\n', '     */\n', '    function transferGovernance(address _newGovernor) external onlyGovernor {\n', '        _setPendingGovernor(_newGovernor);\n', '        emit PendingGovernorshipTransfer(_governor(), _newGovernor);\n', '    }\n', '\n', '    /**\n', '     * @dev Claim Governance of the contract to a new account (`newGovernor`).\n', '     * Can only be called by the new Governor.\n', '     */\n', '    function claimGovernance() external {\n', '        require(\n', '            msg.sender == _pendingGovernor(),\n', '            "Only the pending Governor can complete the claim"\n', '        );\n', '        _changeGovernor(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Change Governance of the contract to a new account (`newGovernor`).\n', '     * @param _newGovernor Address of the new Governor\n', '     */\n', '    function _changeGovernor(address _newGovernor) internal {\n', '        require(_newGovernor != address(0), "New Governor is address(0)");\n', '        emit GovernorshipTransferred(_governor(), _newGovernor);\n', '        _setGovernor(_newGovernor);\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "metadata": {\n', '    "useLiteralContent": true\n', '  },\n', '  "libraries": {}\n', '}']