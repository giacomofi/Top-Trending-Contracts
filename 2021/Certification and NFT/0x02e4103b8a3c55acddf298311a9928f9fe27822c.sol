['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-02\n', '*/\n', '\n', '/*\n', ' * Crypto stamp Bridge: Token Holder\n', ' * ERC-721 and ERC-1155 tokens deposited to the bridge are owned by this\n', ' * contract while they are active on the other side of the bridge. The bridge\n', ' * can exit them from here again if needed via the bridge head. Users can push\n', ' * tokens to the bridge via safeTresferFrom() to this token holder, or run\n', ' * pull-based deposits via the bridge head.\n', ' *\n', ' * Developed by Capacity Blockchain Solutions GmbH <capacity.at>\n', ' * for Ã–sterreichische Post AG <post.at>\n', ' *\n', ' * Any usage of or interaction with this set of contracts is subject to the\n', ' * Terms & Conditions available at https://crypto.post.at/\n', ' */\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n', '\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\n', '\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC1155 compliant contract, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/ENSReverseRegistrarI.sol\n', '\n', '/*\n', ' * Interfaces for ENS Reverse Registrar\n', ' * See https://github.com/ensdomains/ens/blob/master/contracts/ReverseRegistrar.sol for full impl\n', ' * Also see https://github.com/wealdtech/wealdtech-solidity/blob/master/contracts/ens/ENSReverseRegister.sol\n', ' *\n', ' * Use this as follows (registryAddress is the address of the ENS registry to use):\n', ' * -----\n', " * // This hex value is caclulated by namehash('addr.reverse')\n", ' * bytes32 public constant ENS_ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', ' * function registerReverseENS(address registryAddress, string memory calldata) external {\n', ' *     require(registryAddress != address(0), "need a valid registry");\n', ' *     address reverseRegistrarAddress = ENSRegistryOwnerI(registryAddress).owner(ENS_ADDR_REVERSE_NODE)\n', ' *     require(reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', ' *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\n', ' * }\n', ' * -----\n', ' * or\n', ' * -----\n', ' * function registerReverseENS(address reverseRegistrarAddress, string memory calldata) external {\n', ' *    require(reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', ' *     ENSReverseRegistrarI(reverseRegistrarAddress).setName(name);\n', ' * }\n', ' * -----\n', ' * ENS deployments can be found at https://docs.ens.domains/ens-deployments\n', ' * E.g. Etherscan can be used to look up that owner on those contracts.\n', ' * namehash.hash("addr.reverse") == "0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2"\n', ' * Ropsten: ens.owner(namehash.hash("addr.reverse")) == "0x6F628b68b30Dc3c17f345c9dbBb1E483c2b7aE5c"\n', ' * Mainnet: ens.owner(namehash.hash("addr.reverse")) == "0x084b1c3C81545d370f3634392De611CaaBFf8148"\n', ' */\n', '\n', 'interface ENSRegistryOwnerI {\n', '    function owner(bytes32 node) external view returns (address);\n', '}\n', '\n', 'interface ENSReverseRegistrarI {\n', '    event NameChanged(bytes32 indexed node, string name);\n', '    /**\n', '     * @dev Sets the `name()` record for the reverse ENS record associated with\n', '     * the calling account.\n', '     * @param name The name to set for this address.\n', '     * @return The ENS node hash of the reverse record.\n', '     */\n', '    function setName(string calldata name) external returns (bytes32);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\n', '\n', '\n', '\n', '/**\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '// File: contracts/BridgeDataI.sol\n', '\n', '/*\n', ' * Interface for data storage of the bridge.\n', ' */\n', '\n', 'interface BridgeDataI {\n', '\n', '    event AddressChanged(string name, address previousAddress, address newAddress);\n', '    event ConnectedChainChanged(string previousConnectedChainName, string newConnectedChainName);\n', '    event TokenURIBaseChanged(string previousTokenURIBase, string newTokenURIBase);\n', '    event TokenSunsetAnnounced(uint256 indexed timestamp);\n', '\n', '    /**\n', '     * @dev The name of the chain connected to / on the other side of this bridge head.\n', '     */\n', '    function connectedChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The name of our own chain, used in token URIs handed to deployed tokens.\n', '     */\n', '    function ownChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The base of ALL token URIs, e.g. https://example.com/\n', '     */\n', '    function tokenURIBase() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The sunset timestamp for all deployed tokens.\n', '     * If 0, no sunset is in place. Otherwise, if older than block timestamp,\n', '     * all transfers of the tokens are frozen.\n', '     */\n', '    function tokenSunsetTimestamp() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Set a token sunset timestamp.\n', '     */\n', '    function setTokenSunsetTimestamp(uint256 _timestamp) external;\n', '\n', '    /**\n', '     * @dev Set an address for a name.\n', '     */\n', '    function setAddress(string memory name, address newAddress) external;\n', '\n', '    /**\n', '     * @dev Get an address for a name.\n', '     */\n', '    function getAddress(string memory name) external view returns (address);\n', '}\n', '\n', '// File: contracts/BridgeHeadI.sol\n', '\n', '/*\n', ' * Interface for a Bridge Head.\n', ' */\n', '\n', '\n', 'interface BridgeHeadI {\n', '\n', '    /**\n', '     * @dev Emitted when an ERC721 token is deposited to the bridge.\n', '     */\n', '    event TokenDepositedERC721(address indexed tokenAddress, uint256 indexed tokenId, address indexed otherChainRecipient);\n', '\n', '    /**\n', '     * @dev Emitted when one or more ERC1155 tokens are deposited to the bridge.\n', '     */\n', '    event TokenDepositedERC1155Batch(address indexed tokenAddress, uint256[] tokenIds, uint256[] amounts, address indexed otherChainRecipient);\n', '\n', '    /**\n', '     * @dev Emitted when an ERC721 token is exited from the bridge.\n', '     */\n', '    event TokenExitedERC721(address indexed tokenAddress, uint256 indexed tokenId, address indexed recipient);\n', '\n', '    /**\n', '     * @dev Emitted when one or more ERC1155 tokens are exited from the bridge.\n', '     */\n', '    event TokenExitedERC1155Batch(address indexed tokenAddress, uint256[] tokenIds, uint256[] amounts, address indexed recipient);\n', '\n', '    /**\n', '     * @dev Emitted when a new bridged token is deployed.\n', '     */\n', '    event BridgedTokenDeployed(address indexed ownAddress, address indexed foreignAddress);\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev The bridge controller address\n', '     */\n', '    function bridgeControl() external view returns (address);\n', '\n', '    /**\n', '     * @dev The token holder contract connected to this bridge head\n', '     */\n', '    function tokenHolder() external view returns (TokenHolderI);\n', '\n', '    /**\n', '     * @dev The name of the chain connected to / on the other side of this bridge head.\n', '     */\n', '    function connectedChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The name of our own chain, used in token URIs handed to deployed tokens.\n', '     */\n', '    function ownChainName() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev The minimum amount of (valid) signatures that need to be present in `processExitData()`.\n', '     */\n', '    function minSignatures() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev True if deposits are possible at this time.\n', '     */\n', '    function depositEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev True if exits are possible at this time.\n', '     */\n', '    function exitEnabled() external view returns (bool);\n', '\n', '    /**\n', '     * @dev Called by token holder when a ERC721 token has been deposited and\n', '     * needs to be moved to the other side of the bridge.\n', '     */\n', '    function tokenDepositedERC721(address tokenAddress, uint256 tokenId, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by token holder when a ERC1155 token has been deposited and\n', '     * needs to be moved to the other side of the bridge. If it was no batch\n', '     * deposit, still this function is called with with only the one items in\n', '     * the batch.\n', '     */\n', '    function tokenDepositedERC1155Batch(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by people/contracts who want to move an ERC721 token to the\n', '     * other side of the bridge. Needs to be called by the current token owner.\n', '     */\n', '    function depositERC721(address tokenAddress, uint256 tokenId, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Called by people/contracts who want to move an ERC1155 token to the\n', '     * other side of the bridge. When only a single token ID is desposited,\n', '     * called with only one entry in the arrays. Needs to be called by the\n', '     * current token owner.\n', '     */\n', '    function depositERC1155Batch(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts, address otherChainRecipient) external;\n', '\n', '    /**\n', '     * @dev Process an exit message. Can be called by anyone, but requires data\n', '     * with valid signatures from a minimum of `minSignatures()` of allowed\n', '     * signer addresses and an exit nonce for the respective signer that has\n', '     * not been used yet. Also, all signers need to be ordered with ascending\n', '     * addresses for the call to succeed.\n', '     * The ABI-encoded payload is for a call on the bridge head contract.\n', '     * The signature is over the contract address, the chain ID, the exit\n', '     * nonce, and the payload.\n', '     */\n', '    function processExitData(bytes memory _payload, uint256 _expirationTimestamp, bytes[] memory _signatures, uint256[] memory _exitNonces) external;\n', '\n', '    /**\n', '     * @dev Return a predicted token address given the prototype name as listed\n', '     * in bridge data ("ERC721Prototype" or "ERC1155Prototype") and foreign\n', '     * token address.\n', '     */\n', '    function predictTokenAddress(string memory _prototypeName, address _foreignAddress) external view returns (address);\n', '\n', '    /**\n', '     * @dev Exit an ERC721 token from the bridge to a recipient. Can be owned\n', '     * by either the token holder or an address that is treated as an\n', '     * equivalent holder for the bride. If not existing, can be minted if\n', '     * allowed, or even a token deployed based in a given foreign address and\n', '     * symbol. If properties data is set, will send that to the token contract\n', '     * to set properties for the token.\n', '     */\n', '    function exitERC721(address _tokenAddress, uint256 _tokenId, address _recipient, address _foreignAddress, bool _allowMinting, string calldata _symbol, bytes calldata _propertiesData) external;\n', '\n', '    /**\n', '     * @dev Exit an already existing ERC721 token from the bridge to a\n', '     * recipient, owned currently by the bridge in some form.\n', '     */\n', '    function exitERC721Existing(address _tokenAddress, uint256 _tokenId, address _recipient) external;\n', '\n', '    /**\n', '     * @dev Exit ERC1155 token(s) from the bridge to a recipient. The token\n', '     * source can be the token holder, an equivalent, or a Collection. Only\n', '     * tokens owned by one source can be existed in one transaction. If the\n', '     * source is the zero address, tokens will be minted.\n', '     */\n', '    function exitERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient, address _foreignAddress, address _tokenSource) external;\n', '\n', '    /**\n', '     * @dev Exit an already existing ERC1155 token from the bridge to a\n', '     * recipient, owned currently by the token holder.\n', '     */\n', '    function exitERC1155BatchFromHolder(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _recipient) external;\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function call etc.),\n', '     * we call that contract with this payload, e.g. to trigger actions in the name of the token holder.\n', '     */\n', '    function callAsHolder(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '}\n', '\n', '// File: contracts/TokenHolderI.sol\n', '\n', '/*\n', ' * Interface for a Token Holder.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', 'interface TokenHolderI is IERC165, IERC721Receiver, IERC1155Receiver {\n', '\n', '    /**\n', '     * @dev The address of the bridge data contract storing all addresses and chain info for this bridge\n', '     */\n', '    function bridgeData() external view returns (BridgeDataI);\n', '\n', '    /**\n', '     * @dev The bridge head contract connected to this token holder\n', '     */\n', '    function bridgeHead() external view returns (BridgeHeadI);\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function call etc.),\n', '     * we call that contract with this payload, e.g. to trigger actions in the name of the bridge.\n', '     */\n', '    function externalCall(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '    /**\n', '     * @dev Transfer ERC721 tokens out of the holder contract.\n', '     */\n', '    function safeTransferERC721(address _tokenAddress, uint256 _tokenId, address _to) external;\n', '\n', '    /**\n', '     * @dev Transfer ERC1155 tokens out of the holder contract.\n', '     */\n', '    function safeTransferERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _to) external;\n', '\n', '}\n', '\n', '// File: contracts/CollectionsI.sol\n', '\n', '/*\n', ' * Interface for the Collections factory.\n', ' */\n', '\n', '\n', '/**\n', ' * @dev Outward-facing interface of a Collections contract.\n', ' */\n', 'interface CollectionsI is IERC721 {\n', '\n', '    /**\n', '     * @dev Emitted when a new collection is created.\n', '     */\n', '    event NewCollection(address indexed owner, address collectionAddress);\n', '\n', '    /**\n', '     * @dev Emitted when a collection is destroyed.\n', '     */\n', '    event KilledCollection(address indexed owner, address collectionAddress);\n', '\n', '    /**\n', '     * @dev Creates a new Collection. For calling from other contracts,\n', '     * returns the address of the new Collection.\n', '     */\n', '    function create(address _notificationContract,\n', '                    string calldata _ensName,\n', '                    string calldata _ensSubdomainName,\n', '                    address _ensSubdomainRegistrarAddress,\n', '                    address _ensReverseRegistrarAddress)\n', '    external payable\n', '    returns (address);\n', '\n', '    /**\n', '     * @dev Create a collection for a different owner. Only callable by a\n', '     * create controller role. For calling from other contracts, returns the\n', '     * address of the new Collection.\n', '     */\n', '    function createFor(address payable _newOwner,\n', '                       address _notificationContract,\n', '                       string calldata _ensName,\n', '                       string calldata _ensSubdomainName,\n', '                       address _ensSubdomainRegistrarAddress,\n', '                       address _ensReverseRegistrarAddress)\n', '    external payable\n', '    returns (address);\n', '\n', '    /**\n', '     * @dev Removes (burns) an empty Collection. Only the Collection contract itself can call this.\n', '     */\n', '    function burn(uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns if a Collection NFT exists for the specified `tokenId`.\n', '     */\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given `collectionAddr`.\n', '     */\n', '    function isApprovedOrOwnerOnCollection(address spender, address collectionAddr) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the Collection address for a token ID.\n', '     */\n', '    function collectionAddress(uint256 tokenId) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the token ID for a Collection address.\n', '     */\n', '    function tokenIdForCollection(address collectionAddr) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns true if a Collection exists at this address, false if not.\n', '     */\n', '    function collectionExists(address collectionAddr) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the owner of the Collection with the given address.\n', '     */\n', '    function collectionOwner(address collectionAddr) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns a Collection address owned by `owner` at a given `index` of\n', '     * its Collections list. Mirrors `tokenOfOwnerByIndex` in ERC721Enumerable.\n', '     */\n', '    function collectionOfOwnerByIndex(address owner, uint256 index) external view returns (address);\n', '\n', '}\n', '\n', '// File: contracts/CollectionI.sol\n', '\n', '/*\n', ' * Interface for a single Collection, which is a very lightweight contract that can be the owner of ERC721 tokens.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', 'interface CollectionI is IERC165, IERC721Receiver, IERC1155Receiver  {\n', '\n', '    /**\n', '     * @dev Emitted when the notification conmtract is changed.\n', '     */\n', '    event NotificationContractTransferred(address indexed previousNotificationContract, address indexed newNotificationContract);\n', '\n', '    /**\n', '     * @dev Emitted when an asset is added to the collection.\n', '     */\n', '    event AssetAdded(address tokenAddress, uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when an asset is removed to the collection.\n', '     */\n', '    event AssetRemoved(address tokenAddress, uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when the Collection is destroyed.\n', '     */\n', '    event CollectionDestroyed(address operator);\n', '\n', '    /**\n', '     * @dev True is this is the prototype, false if this is an active\n', '     * (clone/proxy) collection contract.\n', '     */\n', '    function isPrototype() external view returns (bool);\n', '\n', '    /**\n', '     * @dev The linked Collections factory (the ERC721 contract).\n', '     */\n', '    function collections() external view returns (CollectionsI);\n', '\n', '    /**\n', '     * @dev The linked notification contract (e.g. achievements).\n', '     */\n', '    function notificationContract() external view returns (address);\n', '\n', '    /**\n', '     * @dev Initializes a new Collection. Needs to be called by the Collections\n', '     * factory.\n', '     */\n', '    function initialRegister(address _notificationContract,\n', '                             string calldata _ensName,\n', '                             string calldata _ensSubdomainName,\n', '                             address _ensSubdomainRegistrarAddress,\n', '                             address _ensReverseRegistrarAddress)\n', '    external;\n', '\n', '    /**\n', '     * @dev Switch the notification contract to a different address. Set to the\n', '     * zero address to disable notifications. Can only be called by owner.\n', '     */\n', '    function transferNotificationContract(address _newNotificationContract) external;\n', '\n', '    /**\n', '     * @dev Get collection owner from ERC 721 parent (Collections factory).\n', '     */\n', '    function ownerAddress() external view returns (address);\n', '\n', '    /**\n', '     * @dev Determine if the Collection owns a specific asset.\n', '     */\n', '    function ownsAsset(address _tokenAddress, uint256 _tokenId) external view returns(bool);\n', '\n', '    /**\n', '     * @dev Get count of owned assets.\n', '     */\n', '    function ownedAssetsCount() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Make sure ownership of a certain asset is recorded correctly (added\n', "     * if the collection owns it or removed if it doesn't).\n", '     */\n', '    function syncAssetOwnership(address _tokenAddress, uint256 _tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfer an owned asset to a new owner (for ERC1155, a single item\n', '     * of that asset).\n', '     */\n', '    function safeTransferTo(address _tokenAddress, uint256 _tokenId, address _to) external;\n', '\n', '    /**\n', '     * @dev Transfer a certain amount of an owned asset to a new owner (for\n', '     * ERC721, _value is ignored).\n', '     */\n', '    function safeTransferTo(address _tokenAddress, uint256 _tokenId, address _to, uint256 _value) external;\n', '\n', '    /**\n', '     * @dev Destroy and burn an empty Collection. Can only be called by owner\n', '     * and only on empty collections.\n', '     */\n', '    function destroy() external;\n', '\n', '    /**\n', '     * @dev Forward calls to external contracts. Can only be called by owner.\n', '     * Given a contract address and an already-encoded payload (with a function\n', '     * call etc.), we call that contract with this payload, e.g. to trigger\n', '     * actions in the name of the collection.\n', '     */\n', '    function externalCall(address payable _remoteAddress, bytes calldata _callPayload) external payable;\n', '\n', '    /**\n', '     * @dev Register ENS name. Can only be called by owner.\n', '     */\n', '    function registerENS(string calldata _name, address _registrarAddress) external;\n', '\n', '    /**\n', '     * @dev Register Reverse ENS name. Can only be called by owner.\n', '     */\n', '    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name) external;\n', '}\n', '\n', '// File: contracts/TokenHolder.sol\n', '\n', '/*\n', ' * Token Holder for the Crypto stamp bridge.\n', ' * This contract holds all tokens on its own layer/chain that have been\n', ' * deposited into the other layer/chain. Deposit interactions happen directly\n', ' * with depositing users, all other interactions (such as exits) come via the\n', ' * Bridge Head.\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenHolder is ERC165, TokenHolderI {\n', '    using Address for address;\n', '    using Address for address payable;\n', '\n', '    BridgeDataI public override bridgeData;\n', '\n', '    event BridgeDataChanged(address indexed previousBridgeData, address indexed newBridgeData);\n', '\n', '    constructor(address _bridgeDataAddress)\n', '    {\n', '        bridgeData = BridgeDataI(_bridgeDataAddress);\n', '    }\n', '\n', '    modifier onlyBridgeControl()\n', '    {\n', '        require(msg.sender == bridgeData.getAddress("bridgeControl"), "bridgeControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyBridge()\n', '    {\n', '        require(msg.sender == bridgeData.getAddress("bridgeControl") || msg.sender == bridgeData.getAddress("bridgeHead"), "bridgeControl key or bridge head required for this function.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenAssignmentControl() {\n', '        require(msg.sender == bridgeData.getAddress("tokenAssignmentControl"), "tokenAssignmentControl key required for this function.");\n', '        _;\n', '    }\n', '\n', '    /*** ERC165 ***/\n', '\n', '    function supportsInterface(bytes4 interfaceId)\n', '    public view override(ERC165, IERC165)\n', '    returns (bool)\n', '    {\n', '        return interfaceId == type(IERC721Receiver).interfaceId ||\n', '               interfaceId == type(IERC1155Receiver).interfaceId ||\n', '               super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /*** Enable adjusting variables after deployment ***/\n', '\n', '    function setBridgeData(BridgeDataI _newBridgeData)\n', '    external\n', '    onlyBridgeControl\n', '    {\n', '        require(address(_newBridgeData) != address(0x0), "You need to provide an actual bridge data contract.");\n', '        emit BridgeDataChanged(address(bridgeData), address(_newBridgeData));\n', '        bridgeData = _newBridgeData;\n', '    }\n', '\n', '    function bridgeHead()\n', '    public view override\n', '    returns (BridgeHeadI) {\n', '        return BridgeHeadI(bridgeData.getAddress("bridgeHead"));\n', '    }\n', '\n', '    /*** Deal with ERC721 and ERC1155 tokens we receive ***/\n', '\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data)\n', '    external override\n', '    returns (bytes4)\n', '    {\n', '        address otherChainRecipient = getRecipient(_operator, _from, _data);\n', '        address _tokenAddress = msg.sender;\n', '        // Make sure whoever called this plays nice, check for token being an ERC721 contract.\n', '        require(IERC165(_tokenAddress).supportsInterface(type(IERC721).interfaceId), "onERC721Received caller needs to implement ERC721!");\n', "        // If it's a Collection, make sure notification contract is set to zero.\n", '        if (_tokenAddress == bridgeData.getAddress("Collections")) {\n', '            CollectionI coll = CollectionI(CollectionsI(_tokenAddress).collectionAddress(_tokenId));\n', '            if (coll.notificationContract() != address(0)) {\n', '                coll.transferNotificationContract(address(0));\n', '            }\n', '        }\n', '        // Now, tell the bridge head of the deposit, it will care about forwarding this token over the bridge.\n', '        bridgeHead().tokenDepositedERC721(_tokenAddress, _tokenId, otherChainRecipient);\n', '        return this.onERC721Received.selector;\n', '    }\n', '\n', '    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data)\n', '    external override\n', '    returns(bytes4)\n', '    {\n', '        address otherChainRecipient = getRecipient(_operator, _from, _data);\n', '        address _tokenAddress = msg.sender;\n', '        // Make sure whoever called this plays nice, check for token being an ERC1155 contract.\n', '        require(IERC165(_tokenAddress).supportsInterface(type(IERC1155).interfaceId), "onERC1155Received caller needs to implement ERC1155!");\n', '        // Now, tell the bridge head of the deposit, it will care about forwarding this token over the bridge.\n', '        uint256[] memory tokenIds = new uint256[](1);\n', '        tokenIds[0] = _id;\n', '        uint256[] memory amounts = new uint256[](1);\n', '        amounts[0] = _value;\n', '        bridgeHead().tokenDepositedERC1155Batch(_tokenAddress, tokenIds, amounts, otherChainRecipient);\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data)\n', '    external override\n', '    returns(bytes4)\n', '    {\n', '        address otherChainRecipient = getRecipient(_operator, _from, _data);\n', '        address _tokenAddress = msg.sender;\n', '        // Make sure whoever called this plays nice, check for token being an ERC1155 contract.\n', '        require(IERC165(_tokenAddress).supportsInterface(type(IERC1155).interfaceId), "onERC1155BatchReceived caller needs to implement ERC1155!");\n', '        // Now, tell the bridge head of the deposit, it will care about forwarding this token over the bridge.\n', '        bridgeHead().tokenDepositedERC1155Batch(_tokenAddress, _ids, _values, otherChainRecipient);\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    function getRecipient(address _operator, address _from, bytes memory _data)\n', '    internal view\n', '    returns(address)\n', '    {\n', '        if (_operator == bridgeData.getAddress("bridgeHead") && _data.length > 0) {\n', '            // This is a pull-based deposit called via the bridge head, take recipient from _data.\n', '            return abi.decode(_data, (address));\n', '        }\n', '        if (_from.isContract()) {\n', '            // We do not want tokens to end up in un-reachable addresses on the other side, so revert.\n', '            revert("Deposit contract-owned token via bridge head!");\n', '        }\n', '        if (_from == address(0)) {\n', '            // We do not want tokens to end up in un-reachable addresses on the other side, so revert.\n', '            revert("Can\'t mint into bridge directly!");\n', '        }\n', '        // This is an EOA, so we give it to that address on the other side as well.\n', '        return _from;\n', '    }\n', '\n', '    /*** Forward calls to external contracts ***/\n', '\n', '    // Given a contract address and an already-encoded payload (with a function call etc.),\n', '    // we call that contract with this payload, e.g. to trigger actions in the name of the token holder.\n', '    function externalCall(address payable _remoteAddress, bytes calldata _callPayload)\n', '    external override payable\n', '    onlyBridge\n', '    {\n', '        require(_remoteAddress != address(this) && _remoteAddress != bridgeData.getAddress("bridgeHead"), "No calls to bridge via this mechanism!");\n', "        // Using methods from OpenZeppelin's Address library to bubble up exceptions with their messages.\n", '        if (_callPayload.length > 0) {\n', '            _remoteAddress.functionCallWithValue(_callPayload, msg.value);\n', '        }\n', '        else {\n', '            _remoteAddress.sendValue(msg.value);\n', '        }\n', '    }\n', '\n', '    /*** Transfer assets out of the holder ***/\n', '\n', '    function safeTransferERC721(address _tokenAddress, uint256 _tokenId, address _to)\n', '    public override\n', '    onlyBridge\n', '    {\n', '        IERC721(_tokenAddress).safeTransferFrom(address(this), _to, _tokenId);\n', '    }\n', '\n', '    function safeTransferERC1155Batch(address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _amounts, address _to)\n', '    public override\n', '    onlyBridge\n', '    {\n', '        IERC1155(_tokenAddress).safeBatchTransferFrom(address(this), _to, _tokenIds, _amounts, "");\n', '    }\n', '\n', '    /*** Enable reverse ENS registration ***/\n', '\n', '    // Call this with the address of the reverse registrar for the respective network and the ENS name to register.\n', "    // The reverse registrar can be found as the owner of 'addr.reverse' in the ENS system.\n", '    // For Mainnet, the address needed is 0x9062c0a6dbd6108336bcbe4593a3d1ce05512069\n', '    function registerReverseENS(address _reverseRegistrarAddress, string calldata _name)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        require(_reverseRegistrarAddress != address(0), "need a valid reverse registrar");\n', '        ENSReverseRegistrarI(_reverseRegistrarAddress).setName(_name);\n', '    }\n', '\n', "    /*** Make sure currency or NFT doesn't get stranded in this contract ***/\n", '\n', "    // If this contract gets a balance in some ERC20 contract after it's finished, then we can rescue it.\n", '    function rescueToken(address _foreignToken, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        IERC20 erc20Token = IERC20(_foreignToken);\n', '        erc20Token.transfer(_to, erc20Token.balanceOf(address(this)));\n', '    }\n', '\n', "    // If this contract gets a balance in some ERC721 contract after it's finished, then we can rescue it.\n", '    function approveNFTrescue(IERC721 _foreignNFT, address _to)\n', '    external\n', '    onlyTokenAssignmentControl\n', '    {\n', '        _foreignNFT.setApprovalForAll(_to, true);\n', '    }\n', '\n', '}']