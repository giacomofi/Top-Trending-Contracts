['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'interface IKeep3rV1 {\n', '    function keepers(address keeper) external returns (bool);\n', '    function KPRH() external view returns (IKeep3rV1Helper);\n', '    function receipt(address credit, address keeper, uint amount) external;\n', '}\n', '\n', 'interface IKeep3rV1Helper {\n', '    function getQuoteLimit(uint gasUsed) external view returns (uint);\n', '}\n', '\n', '// sliding oracle that uses observations collected to provide moving price averages in the past\n', 'contract Keep3rV2Oracle {\n', '\n', '    constructor(address _pair) {\n', '        _factory = msg.sender;\n', '        pair = _pair;\n', '        (,,uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\n', '        uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(_pair).price0CumulativeLast() * e10 / Q112);\n', '        uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(_pair).price1CumulativeLast() * e10 / Q112);\n', '        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '    }\n', '\n', '    struct Observation {\n', '        uint32 timestamp;\n', '        uint112 price0Cumulative;\n', '        uint112 price1Cumulative;\n', '    }\n', '\n', '    modifier factory() {\n', '        require(msg.sender == _factory, "!F");\n', '        _;\n', '    }\n', '\n', '    Observation[65535] public observations;\n', '    uint16 public length;\n', '\n', '    address immutable _factory;\n', '    address immutable public pair;\n', '    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n', '    uint constant periodSize = 1800;\n', '    uint Q112 = 2**112;\n', '    uint e10 = 10**18;\n', '\n', '    // Pre-cache slots for cheaper oracle writes\n', '    function cache(uint size) external {\n', '        uint _length = length+size;\n', '        for (uint i = length; i < _length; i++) observations[i].timestamp = 1;\n', '    }\n', '\n', '    // update the current feed for free\n', '    function update() external factory returns (bool) {\n', '        return _update();\n', '    }\n', '\n', '    function updateable() external view returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint timeElapsed = timestamp - _point.timestamp;\n', '        return timeElapsed > periodSize;\n', '    }\n', '\n', '    function _update() internal returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint32 timeElapsed = timestamp - _point.timestamp;\n', '        if (timeElapsed > periodSize) {\n', '            uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112);\n', '            uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112);\n', '            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '}\n', '\n', 'contract Keep3rV2OracleFactory {\n', '\n', '    function pairForSushi(address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                0xc35DADB65012eC5796536bD9864eD8773aBc74C4,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n", '            )))));\n', '    }\n', '\n', '    function pairForUni(address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            )))));\n', '    }\n', '\n', '    modifier keeper() {\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '    }\n', '\n', '    modifier upkeep() {\n', '        uint _gasUsed = gasleft();\n', '        require(KP3R.keepers(msg.sender), "!K");\n', '        _;\n', '        uint _received = KP3R.KPRH().getQuoteLimit(_gasUsed - gasleft());\n', '        KP3R.receipt(address(KP3R), msg.sender, _received);\n', '    }\n', '\n', '    address public governance;\n', '    address public pendingGovernance;\n', '\n', '    /**\n', '     * @notice Allows governance to change governance (for future upgradability)\n', '     * @param _governance new governance address to set\n', '     */\n', '    function setGovernance(address _governance) external {\n', '        require(msg.sender == governance, "!G");\n', '        pendingGovernance = _governance;\n', '    }\n', '\n', '    /**\n', '     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\n', '     */\n', '    function acceptGovernance() external {\n', '        require(msg.sender == pendingGovernance, "!pG");\n', '        governance = pendingGovernance;\n', '    }\n', '\n', '    IKeep3rV1 public constant KP3R = IKeep3rV1(0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44);\n', '\n', '    address[] internal _pairs;\n', '    mapping(address => Keep3rV2Oracle) public feeds;\n', '\n', '    function pairs() external view returns (address[] memory) {\n', '        return _pairs;\n', '    }\n', '\n', '    constructor() {\n', '        governance = msg.sender;\n', '    }\n', '\n', '    function update(address pair) external keeper returns (bool) {\n', '        return feeds[pair].update();\n', '    }\n', '\n', '    function byteCode(address pair) external pure returns (bytes memory bytecode) {\n', '        bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n', '    }\n', '\n', '    function deploy(address pair) external returns (address feed) {\n', '        require(msg.sender == governance, "!G");\n', "        require(address(feeds[pair]) == address(0), 'PE');\n", '        bytes memory bytecode = abi.encodePacked(type(Keep3rV2Oracle).creationCode, abi.encode(pair));\n', '        bytes32 salt = keccak256(abi.encodePacked(pair));\n', '        assembly {\n', '            feed := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n', '            if iszero(extcodesize(feed)) {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '        feeds[pair] = Keep3rV2Oracle(feed);\n', '        _pairs.push(pair);\n', '    }\n', '\n', '    function work() external upkeep {\n', '        require(workable(), "!W");\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function work(address pair) external upkeep {\n', '        require(feeds[pair].update(), "!W");\n', '    }\n', '\n', '    function workForFree() external keeper {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].update();\n', '        }\n', '    }\n', '\n', '    function workForFree(address pair) external keeper {\n', '        feeds[pair].update();\n', '    }\n', '\n', '    function cache(uint size) external {\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            feeds[_pairs[i]].cache(size);\n', '        }\n', '    }\n', '\n', '    function cache(address pair, uint size) external {\n', '        feeds[pair].cache(size);\n', '    }\n', '\n', '    function workable() public view returns (bool canWork) {\n', '        canWork = true;\n', '        for (uint i = 0; i < _pairs.length; i++) {\n', '            if (!feeds[_pairs[i]].updateable()) {\n', '                canWork = false;\n', '            }\n', '        }\n', '    }\n', '\n', '    function workable(address pair) public view returns (bool) {\n', '        return feeds[pair].updateable();\n', '    }\n', '}']