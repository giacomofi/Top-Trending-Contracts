['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.2;\n', '\n', 'interface cToken {\n', '    function underlying() external view returns (address);\n', '}\n', '\n', 'interface comptroller {\n', '    function getAllMarkets() external view returns (address[] memory);\n', '    function markets(address _market) external view returns (bool isListed, uint256 collateralFactorMantissa, bool isComped);\n', '}\n', '\n', 'interface ibtroller {\n', '    function getAllMarkets() external view returns (address[] memory);\n', '    function markets(address _market) external view returns (bool isListed, uint256 collateralFactorMantissa);\n', '}\n', '\n', 'interface aavecore {\n', '    struct ReserveConfigurationMap {\n', '        //bit 0-15: LTV\n', '        //bit 16-31: Liq. threshold\n', '        //bit 32-47: Liq. bonus\n', '        //bit 48-55: Decimals\n', '        //bit 56: Reserve is active\n', '        //bit 57: reserve is frozen\n', '        //bit 58: borrowing is enabled\n', '        //bit 59: stable rate borrowing enabled\n', '        //bit 60-63: reserved\n', '        //bit 64-79: reserve factor\n', '        uint256 data;\n', '    }\n', '    function getReserveConfiguration(address _market) external view returns (uint, uint, uint, bool);\n', '    function getConfiguration(address _market) external view returns (ReserveConfigurationMap memory);\n', '}\n', '\n', 'contract CollateralMaximizer {\n', '    address constant private _cream = address(0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258);\n', '    address constant private _compound = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n', '    address constant private _aavev1 = address(0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3);\n', '    address constant private _aavev2 = address(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n', '    address constant private _ib = address(0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB);\n', '    address constant private _weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    \n', '    uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n', '    uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n', '    uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n', '    uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n', '    uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n', '    uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n', '    uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n', '    uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n', '    uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n', '    \n', '    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n', '    uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n', '    uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n', '    uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n', '    uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\n', '    uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\n', '    uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n', '    uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n', '    uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n', '    \n', '    uint256 constant MAX_VALID_LTV = 65535;\n', '    uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n', '    uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n', '    uint256 constant MAX_VALID_DECIMALS = 255;\n', '    uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\n', '    \n', '    function getParamsMemory(aavecore.ReserveConfigurationMap memory self) internal pure returns (uint256) { \n', '        return (self.data & ~LTV_MASK);\n', '    }\n', '    function lookupMarket(address _core, address _token) public view returns (address) {\n', '        if (_core == _compound && _token == _weth) {\n', '            return 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '        } else if (_core == _cream && _token == _weth) {\n', '            return 0xD06527D5e56A3495252A528C4987003b712860eE;\n', '        }\n', '        address[] memory _list = comptroller(_core).getAllMarkets();\n', '        for (uint i = 0; i < _list.length; i++) {\n', '            if (_list[i] != address(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) && _list[i] != address(0xD06527D5e56A3495252A528C4987003b712860eE)) {\n', '                if (cToken(_list[i]).underlying() == _token) {\n', '                    return _list[i];\n', '                }\n', '            }\n', '        }\n', '        return address(0x0);\n', '    }\n', '    function lookupMarketCompound(address _token) external view returns (address) {\n', '        return lookupMarket(_compound, _token);\n', '    }\n', '    function lookupMarketCream(address _token) external view returns (address) {\n', '        return lookupMarket(_cream, _token);\n', '    }\n', '    function lookupMarketIB(address _token) external view returns (address) {\n', '        return lookupMarket(_ib, _token);\n', '    }\n', '    function getLTVCream(address _token) public view returns (uint cream) {\n', '        (,cream,) = comptroller(_cream).markets(lookupMarket(_cream, _token));\n', '        cream = cream / 1e16;\n', '    }\n', '    function getLTVCompound(address _token) public view returns (uint compound) {\n', '        (,compound,) = comptroller(_compound).markets(lookupMarket(_compound, _token));\n', '        compound = compound / 1e16;\n', '    }\n', '    function getLTVIB(address _token) public view returns (uint ib) {\n', '        (,ib) = ibtroller(_ib).markets(lookupMarket(_ib, _token));\n', '        ib = ib / 1e16;\n', '    }\n', '    function getLTVAaveV1(address _token) public view returns (uint aavev1) {\n', '        (,aavev1,,) = aavecore(_aavev1).getReserveConfiguration(_token);\n', '    }\n', '    function getLTVAaveV2(address _token) public view returns (uint aavev2) {\n', '        (aavev2) = getParamsMemory(aavecore(_aavev2).getConfiguration(_token));\n', '        aavev2 = aavev2 / 1e2;\n', '    }\n', '    function getLTV(address _token) public view returns (uint cream, uint compound, uint ib, uint aavev1, uint aavev2) {\n', '        cream = getLTVCream(_token);\n', '        compound = getLTVCompound(_token);\n', '        ib = getLTVIB(_token);\n', '        aavev1 = getLTVAaveV1(_token);\n', '        aavev2 = getLTVAaveV2(_token);\n', '    }\n', '}']