['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.11;\n', '\n', 'import "../interfaces/IQredoWalletImplementation.sol";\n', 'import "../interfaces/IWalletFactory.sol";\n', 'import "../libraries/Create2.sol";\n', '\n', 'contract WalletFactory is IWalletFactory {\n', '\n', '    mapping(address => address) private walletOwner;\n', '    address immutable private _template;\n', '\n', '    constructor(address _template_) public {\n', '        require(_template_ != address(0), "WF::constructor:_template_ address cannot be 0");\n', '        _template = _template_;\n', '    }\n', '\n', '    function computeFutureWalletAddress(address _walletOwner) external override view returns(address _walletAddress) {\n', '        return Create2.computeAddress(\n', '                    keccak256(abi.encodePacked(_walletOwner)),\n', '                    keccak256(getBytecode())\n', '                );\n', '    }\n', '   \n', '    function createWallet(address _walletOwner) external override returns (address _walletAddress) {\n', '        require(_walletOwner != address(0), "WF::createWallet:owner address cannot be 0");\n', '        require(walletOwner[_walletOwner] == address(0), "WF::createWallet:owner already has wallet");\n', '        address wallet = Create2.deploy(\n', '                0,\n', '                keccak256(abi.encodePacked(_walletOwner)),\n', '                getBytecode()\n', '            );\n', '        IQredoWalletImplementation(wallet).init(_walletOwner);\n', '        walletOwner[_walletOwner] = address(wallet);\n', '        emit WalletCreated(msg.sender, address(wallet), _walletOwner);\n', '        return wallet;\n', '    }\n', '\n', '    /**\n', '      * @dev Returns template address of the current {owner};\n', '    */\n', '    function getWalletByOwner(address owner) external override view returns (address _wallet) {\n', '        return walletOwner[owner];\n', '    }\n', '\n', '    function verifyWallet(address wallet) external override view returns (bool _validWallet) {\n', '        return walletOwner[IQredoWalletImplementation(wallet).getWalletOwnerAddress()] != address(0);\n', '    }\n', '\n', '    /**\n', '      * @dev Returns template address;\n', '    */\n', '    function getTemplate() external override view returns (address template){\n', '        return _template;\n', '    }\n', '\n', '    /**\n', '      * @dev EIP-1167 Minimal Proxy Bytecode with included Creation code.\n', '      * More information on EIP-1167 Minimal Proxy and the full bytecode \n', '      * read more here: \n', '      * (https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract)\n', '    */\n', '    function getBytecode() private view returns (bytes memory) {\n', '        bytes10 creation = 0x3d602d80600a3d3981f3;\n', '        bytes10 runtimePrefix = 0x363d3d373d3d3d363d73;\n', '        bytes20 targetBytes = bytes20(_template);\n', '        bytes15 runtimeSuffix = 0x5af43d82803e903d91602b57fd5bf3;\n', '        return abi.encodePacked(creation, runtimePrefix, targetBytes, runtimeSuffix);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.11;\n', '\n', 'interface IQredoWalletImplementation {\n', '    function init(address _walletOwner) external;\n', '    function invoke(bytes memory signature, address _to, uint256 _value, bytes calldata _data) external returns (bytes memory _result);\n', '    function getBalance(address tokenAddress) external view returns(uint256 _balance);\n', '    function getNonce() external view returns(uint256 nonce);\n', '    function getWalletOwnerAddress() external view returns(address _walletOwner);\n', '    \n', '    event Invoked(address indexed sender, address indexed target, uint256 value, uint256 indexed nonce, bytes data);\n', '    event Received(address indexed sender, uint indexed value, bytes data);\n', '    event Fallback(address indexed sender, uint indexed value, bytes data);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.11;\n', '\n', 'interface IWalletFactory {\n', '    function computeFutureWalletAddress(address _walletOwner) external view returns(address _walletAddress);\n', '    function createWallet(address owner) external returns (address _walletAddress);\n', '    function getTemplate() external view returns (address template);\n', '    function getWalletByOwner(address owner) external view returns (address _wallet);\n', '    function verifyWallet(address wallet) external  view returns (bool _validWallet);\n', '    \n', '    event WalletCreated(address indexed caller, address indexed wallet, address indexed owner);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.11;\n', '\n', '// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Create2.sol";\n', '\n', '/**\n', ' * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n', ' * `CREATE2` can be used to compute in advance the address where a smart\n', ' * contract will be deployed, which allows for interesting new mechanisms known\n', " * as 'counterfactual interactions'.\n", ' *\n', ' * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n', ' * information.\n', ' */\n', '\n', 'library Create2 {\n', '    /**\n', '     * @dev Deploys a contract using `CREATE2`. The address where the contract\n', '     * will be deployed can be known in advance via {computeAddress}.\n', '     *\n', '     * The bytecode for a contract can be obtained from Solidity with\n', '     * `type(contractName).creationCode`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `bytecode` must not be empty.\n', '     * - `salt` must have not been used for `bytecode` already.\n', '     * - the factory must have a balance of at least `amount`.\n', '     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n', '     */\n', '    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\n', '        address addr;\n', '        require(address(this).balance >= amount, "Create2: insufficient balance");\n', '        require(bytecode.length != 0, "Create2: bytecode length is zero");\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n', '        }\n', '        require(addr != address(0), "Create2: Failed on deploy");\n', '        return addr;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n', '     * `bytecodeHash` or `salt` will result in a new destination address.\n', '     */\n', '    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n', '        return computeAddress(salt, bytecodeHash, address(this));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n', "     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n", '     */\n', '    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\n', '        bytes32 _data = keccak256(\n', '            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\n', '        );\n', '        return address(uint160(uint256(_data)));\n', '    }\n', '}']