['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.8.0;\n', '\n', 'library IPFSlib {\n', '    // @title verifyIPFS\n', '    // @author Martin Lundfall ([email\xa0protected])\n', '    // @rewrited by Vakhtanh Chikhladze to new version solidity 0.8.0\n', '    bytes constant public sha256MultiHash = "\\x12\\x20";\n', '    bytes constant public ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";\n', '\n', '    //@dev generates the corresponding IPFS hash (in base 58) to the given stroraged decoded hash\n', '    //@param contentString The content of the IPFS object\n', '    //@return The IPFS hash in base 58\n', '    function encode(bytes32 decodedHash) public pure returns (string memory) {\n', '        bytes memory content=toBytes(decodedHash);\n', '        return toBase58(concat(sha256MultiHash, content));\n', '    }\n', '  \n', '    // @dev Converts hex string to base 58\n', '    /*\n', '        some comment-proof about array size of digits:\n', '        source is the number with base 256. \n', '        Example: for given input 0x414244 it can be presented as 0x41*256^2+0x42*256+0x44;\n', '        How many digits are needed to write such a number n in base 256?\n', '        (P.S. All all of the following formulas may be checked in WolframAlpha.)\n', '        We need rounded up logarithm of number n with base 256 , in formula presentation: roof(log(256,n))\n', '        Example: roof(log(256,0x414244))=|in decimal 0x414244=4276804|=roof(log(256,4276804))~=roof(2.4089)=3;\n', '        Encoding Base58 works with numbers in base 58.\n', '        Example: 0x414244 = 21 53 20 0 = 21*58^3 + 53*58^2 + 20*58+0\n', '        How many digits are needed to write such a number n in base 58?\n', '        We need rounded up logarithm of number n with base 58 , in formula presentation: roof(log(58,n))\n', '        Example: roof(log(58,0x414244))=|in decimal 0x414244=4276804|=roof(log(58,4276804))~=roof(3.7603)=4;\n', '        \n', '        And the question is: How many times the number in base 58 will be bigger than number in base 256 represantation?\n', '        The aswer is lim n->inf log(58,n)/log(256,n)\n', '        \n', '        lim n->inf log(58,n)/log(256,n)=[inf/inf]=|use hopitals rule|=(1/(n*ln(58))/(1/(n*ln(256))=\n', '        =ln(256)/ln(58)=log(58,256)~=1.36\n', '        \n', '        So, log(58,n)~=1.36 * log(256,n); (1)\n', '        \n', '        Therefore, we know the asymptoyic minimal size of additional memory of digits array, that shoud be used.\n', '        But calculated limit is asymptotic value. So it may be some errors like the size of n in base 58 is bigger than calculated value.\n', '        Hence, (1) will be rewrited as: log(58,n) = [log(256,n) * 136/100] + 1; (2)\n', '        ,where square brackets [a] is valuable part of number [a] \n', '        In code exist @param digitlength which dinamically calculates the explicit size of digits array.\n', '        And there are correct statement that digitlength <= [log(256,n) * 136/100] + 1 .\n', '    */\n', '    function toBase58(bytes memory source) public pure returns (string memory) {\n', '        uint8[] memory digits = new uint8[]((source.length*136/100)+1); \n', '        uint digitlength = 1;\n', '        for (uint i = 0; i<source.length; ++i) {\n', '            uint carry = uint8(source[i]);\n', '            for (uint j = 0; j<digitlength; ++j) {\n', '                carry += uint(digits[j]) * 256;\n', '                digits[j] = uint8(carry % 58);\n', '                carry = carry / 58;\n', '            }\n', '            while (carry > 0) {\n', '                digits[digitlength] = uint8(carry % 58);\n', '                digitlength++;\n', '                carry = carry / 58;\n', '            }\n', '        }\n', '        return string(toAlphabet(reverse(truncate(digits, digitlength))));\n', '    }\n', '\n', '    function toBytes(bytes32 input) public pure returns (bytes memory) {\n', '        return abi.encodePacked(input);\n', '    }\n', '    \n', '\n', '    function truncate(uint8[] memory array, uint length) pure public returns (uint8[] memory) {\n', '        if(array.length==length){\n', '            return array;\n', '        }else{\n', '            uint8[] memory output = new uint8[](length);\n', '            for (uint i = 0; i<length; i++) {\n', '                output[i] = array[i];\n', '            }\n', '            return output;\n', '        }\n', '    }\n', '    \n', '    function reverse(uint8[] memory input) pure public returns (uint8[] memory) {\n', '        uint8[] memory output = new uint8[](input.length);\n', '        for (uint i = 0; i<input.length; i++) {\n', '            output[i] = input[input.length-1-i];\n', '        }\n', '        return output;\n', '    }\n', '    \n', '    function toAlphabet(uint8[] memory indices) pure public returns (bytes memory) {\n', '        bytes memory output = new bytes(indices.length);\n', '        for (uint i = 0; i<indices.length; i++) {\n', '            output[i] = ALPHABET[indices[i]];\n', '        }\n', '        return output;\n', '    }\n', '\n', '    function concat(bytes memory byteArray1, bytes memory byteArray2) pure public returns (bytes memory) {\n', '        return abi.encodePacked(byteArray1,byteArray2);\n', '    }\n', '    \n', '    function concatStrings(string memory a,string memory b) public pure returns(string memory){\n', '        return string(abi.encodePacked(a,b));\n', '    }\n', '\n', '    function to_binary(uint256 x) public pure returns (bytes memory) {\n', '         return abi.encodePacked(x);\n', '    }\n', '  \n', '}']