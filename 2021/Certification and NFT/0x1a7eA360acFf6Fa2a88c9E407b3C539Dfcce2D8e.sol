['pragma solidity ^0.5.16;\n', '\n', 'import "./SToken.sol";\n', 'import "./ErrorReporter.sol";\n', 'import "./Exponential.sol";\n', 'import "./PriceOracle.sol";\n', 'import "./ComptrollerInterface.sol";\n', 'import "./ComptrollerStorage.sol";\n', 'import "./Unitroller.sol";\n', 'import "./STRK.sol";\n', '\n', '/**\n', " * @title Strike's Comptroller Contract\n", ' * @author Strike\n', ' */\n', 'contract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n', '    /// @notice Emitted when an admin supports a market\n', '    event MarketListed(SToken sToken);\n', '\n', '    /// @notice Emitted when an account enters a market\n', '    event MarketEntered(SToken sToken, address account);\n', '\n', '    /// @notice Emitted when an account exits a market\n', '    event MarketExited(SToken sToken, address account);\n', '\n', '    /// @notice Emitted when close factor is changed by admin\n', '    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n', '\n', '    /// @notice Emitted when a collateral factor is changed by admin\n', '    event NewCollateralFactor(SToken sToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n', '\n', '    /// @notice Emitted when liquidation incentive is changed by admin\n', '    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n', '\n', '    /// @notice Emitted when maxAssets is changed by admin\n', '    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\n', '\n', '    /// @notice Emitted when price oracle is changed\n', '    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n', '\n', '    /// @notice Emitted when pause guardian is changed\n', '    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n', '\n', '    /// @notice Emitted when an action is paused globally\n', '    event ActionPaused(string action, bool pauseState);\n', '\n', '    /// @notice Emitted when an action is paused on a market\n', '    event ActionPaused(SToken sToken, string action, bool pauseState);\n', '\n', '    /// @notice Emitted when market striked status is changed\n', '    event MarketStriked(SToken sToken, bool isStriked);\n', '\n', '    /// @notice Emitted when STRK rate is changed\n', '    event NewStrikeRate(uint oldStrikeRate, uint newStrikeRate);\n', '\n', '    /// @notice Emitted when a new STRK speed is calculated for a market\n', '    event StrikeSpeedUpdated(SToken indexed sToken, uint newSpeed);\n', '\n', '    /// @notice Emitted when STRK is distributed to a supplier\n', '    event DistributedSupplierStrike(SToken indexed sToken, address indexed supplier, uint strikeDelta, uint strikeSupplyIndex);\n', '\n', '    /// @notice Emitted when STRK is distributed to a borrower\n', '    event DistributedBorrowerStrike(SToken indexed sToken, address indexed borrower, uint strikeDelta, uint strikeBorrowIndex);\n', '\n', '    /// @notice The threshold above which the flywheel transfers STRK, in wei\n', '    uint public constant strikeClaimThreshold = 0.001e18;\n', '\n', '    /// @notice The initial STRK index for a market\n', '    uint224 public constant strikeInitialIndex = 1e36;\n', '\n', '    // closeFactorMantissa must be strictly greater than this value\n', '    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n', '\n', '    // closeFactorMantissa must not exceed this value\n', '    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    // No collateralFactorMantissa may exceed this value\n', '    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    // liquidationIncentiveMantissa must be no less than this value\n', '    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n', '\n', '    // liquidationIncentiveMantissa must be no greater than this value\n', '    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    /*** Assets You Are In ***/\n', '\n', '    /**\n', '     * @notice Returns the assets an account has entered\n', '     * @param account The address of the account to pull assets for\n', '     * @return A dynamic list with the assets the account has entered\n', '     */\n', '    function getAssetsIn(address account) external view returns (SToken[] memory) {\n', '        SToken[] memory assetsIn = accountAssets[account];\n', '\n', '        return assetsIn;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns whether the given account is entered in the given asset\n', '     * @param account The address of the account to check\n', '     * @param sToken The sToken to check\n', '     * @return True if the account is in the asset, otherwise false.\n', '     */\n', '    function checkMembership(address account, SToken sToken) external view returns (bool) {\n', '        return markets[address(sToken)].accountMembership[account];\n', '    }\n', '\n', '    /**\n', '     * @notice Add assets to be included in account liquidity calculation\n', '     * @param sTokens The list of addresses of the sToken markets to be enabled\n', '     * @return Success indicator for whether each corresponding market was entered\n', '     */\n', '    function enterMarkets(address[] memory sTokens) public returns (uint[] memory) {\n', '        uint len = sTokens.length;\n', '\n', '        uint[] memory results = new uint[](len);\n', '        for (uint i = 0; i < len; i++) {\n', '            SToken sToken = SToken(sTokens[i]);\n', '\n', '            results[i] = uint(addToMarketInternal(sToken, msg.sender));\n', '        }\n', '\n', '        return results;\n', '    }\n', '\n', '    /**\n', '     * @notice Add the market to the borrower\'s "assets in" for liquidity calculations\n', '     * @param sToken The market to enter\n', '     * @param borrower The address of the account to modify\n', '     * @return Success indicator for whether the market was entered\n', '     */\n', '    function addToMarketInternal(SToken sToken, address borrower) internal returns (Error) {\n', '        Market storage marketToJoin = markets[address(sToken)];\n', '\n', '        if (!marketToJoin.isListed) {\n', '            // market is not listed, cannot join\n', '            return Error.MARKET_NOT_LISTED;\n', '        }\n', '\n', '        if (marketToJoin.accountMembership[borrower] == true) {\n', '            // already joined\n', '            return Error.NO_ERROR;\n', '        }\n', '\n', '        if (accountAssets[borrower].length >= maxAssets)  {\n', '            // no space, cannot join\n', '            return Error.TOO_MANY_ASSETS;\n', '        }\n', '\n', '        // survived the gauntlet, add to list\n', '        // NOTE: we store these somewhat redundantly as a significant optimization\n', '        //  this avoids having to iterate through the list for the most common use cases\n', '        //  that is, only when we need to perform liquidity checks\n', '        //  and not whenever we want to check if an account is in a particular market\n', '        marketToJoin.accountMembership[borrower] = true;\n', '        accountAssets[borrower].push(sToken);\n', '\n', '        emit MarketEntered(sToken, borrower);\n', '\n', '        return Error.NO_ERROR;\n', '    }\n', '\n', '    /**\n', "     * @notice Removes asset from sender's account liquidity calculation\n", '     * @dev Sender must not have an outstanding borrow balance in the asset,\n', '     *  or be providing necessary collateral for an outstanding borrow.\n', '     * @param sTokenAddress The address of the asset to be removed\n', '     * @return Whether or not the account successfully exited the market\n', '     */\n', '    function exitMarket(address sTokenAddress) external returns (uint) {\n', '        SToken sToken = SToken(sTokenAddress);\n', '        /* Get sender tokensHeld and amountOwed underlying from the sToken */\n', '        (uint oErr, uint tokensHeld, uint amountOwed, ) = sToken.getAccountSnapshot(msg.sender);\n', '        require(oErr == 0, "exitMarket: getAccountSnapshot failed"); // semi-opaque error code\n', '\n', '        /* Fail if the sender has a borrow balance */\n', '        if (amountOwed != 0) {\n', '            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n', '        }\n', '\n', '        /* Fail if the sender is not permitted to redeem all of their tokens */\n', '        uint allowed = redeemAllowedInternal(sTokenAddress, msg.sender, tokensHeld);\n', '        if (allowed != 0) {\n', '            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n', '        }\n', '\n', '        Market storage marketToExit = markets[address(sToken)];\n', '\n', '        /* Return true if the sender is not already ‘in’ the market */\n', '        if (!marketToExit.accountMembership[msg.sender]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Set sToken account membership to false */\n', '        delete marketToExit.accountMembership[msg.sender];\n', '\n', '        /* Delete sToken from the account’s list of assets */\n', '        // load into memory for faster iteration\n', '        SToken[] memory userAssetList = accountAssets[msg.sender];\n', '        uint len = userAssetList.length;\n', '        uint assetIndex = len;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (userAssetList[i] == sToken) {\n', '                assetIndex = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // We *must* have found the asset in the list or our redundant data structure is broken\n', '        assert(assetIndex < len);\n', '\n', '        // copy last item in list to location of item to be removed, reduce length by 1\n', '        SToken[] storage storedList = accountAssets[msg.sender];\n', '        storedList[assetIndex] = storedList[storedList.length - 1];\n', '        storedList.length--;\n', '\n', '        emit MarketExited(sToken, msg.sender);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /*** Policy Hooks ***/\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to mint tokens in the given market\n', '     * @param sToken The market to verify the mint against\n', '     * @param minter The account which would get the minted tokens\n', '     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n', '     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function mintAllowed(address sToken, address minter, uint mintAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!mintGuardianPaused[sToken], "mint is paused");\n', '\n', '        // Shh - currently unused\n', '        minter;\n', '        mintAmount;\n', '\n', '        if (!markets[sToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateStrikeSupplyIndex(sToken);\n', '        distributeSupplierStrike(sToken, minter);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates mint and reverts on rejection. May emit logs.\n', '     * @param sToken Asset being minted\n', '     * @param minter The address minting the tokens\n', '     * @param actualMintAmount The amount of the underlying asset being minted\n', '     * @param mintTokens The number of tokens being minted\n', '     */\n', '    function mintVerify(address sToken, address minter, uint actualMintAmount, uint mintTokens) external {\n', '        // Shh - currently unused\n', '        sToken;\n', '        minter;\n', '        actualMintAmount;\n', '        mintTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to redeem tokens in the given market\n', '     * @param sToken The market to verify the redeem against\n', '     * @param redeemer The account which would redeem the tokens\n', '     * @param redeemTokens The number of sTokens to exchange for the underlying asset in the market\n', '     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function redeemAllowed(address sToken, address redeemer, uint redeemTokens) external returns (uint) {\n', '        uint allowed = redeemAllowedInternal(sToken, redeemer, redeemTokens);\n', '        if (allowed != uint(Error.NO_ERROR)) {\n', '            return allowed;\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateStrikeSupplyIndex(sToken);\n', '        distributeSupplierStrike(sToken, redeemer);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function redeemAllowedInternal(address sToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n', '        if (!markets[sToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', "        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n", '        if (!markets[sToken].accountMembership[redeemer]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, SToken(sToken), redeemTokens, 0);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates redeem and reverts on rejection. May emit logs.\n', '     * @param sToken Asset being redeemed\n', '     * @param redeemer The address redeeming the tokens\n', '     * @param redeemAmount The amount of the underlying asset being redeemed\n', '     * @param redeemTokens The number of tokens being redeemed\n', '     */\n', '    function redeemVerify(address sToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\n', '        // Shh - currently unused\n', '        sToken;\n', '        redeemer;\n', '\n', '        // Require tokens is zero or amount is also zero\n', '        if (redeemTokens == 0 && redeemAmount > 0) {\n', '            revert("redeemTokens zero");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n', '     * @param sToken The market to verify the borrow against\n', '     * @param borrower The account which would borrow the asset\n', '     * @param borrowAmount The amount of underlying the account would borrow\n', '     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function borrowAllowed(address sToken, address borrower, uint borrowAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!borrowGuardianPaused[sToken], "borrow is paused");\n', '\n', '        if (!markets[sToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        if (!markets[sToken].accountMembership[borrower]) {\n', '            // only sTokens may call borrowAllowed if borrower not in market\n', '            require(msg.sender == sToken, "sender must be sToken");\n', '\n', '            // attempt to add borrower to the market\n', '            Error err = addToMarketInternal(SToken(msg.sender), borrower);\n', '            if (err != Error.NO_ERROR) {\n', '                return uint(err);\n', '            }\n', '\n', '            // it should be impossible to break the important invariant\n', '            assert(markets[sToken].accountMembership[borrower]);\n', '        }\n', '\n', '        if (oracle.getUnderlyingPrice(SToken(sToken)) == 0) {\n', '            return uint(Error.PRICE_ERROR);\n', '        }\n', '\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, SToken(sToken), 0, borrowAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        Exp memory borrowIndex = Exp({mantissa: SToken(sToken).borrowIndex()});\n', '        updateStrikeBorrowIndex(sToken, borrowIndex);\n', '        distributeBorrowerStrike(sToken, borrower, borrowIndex);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates borrow and reverts on rejection. May emit logs.\n', '     * @param sToken Asset whose underlying is being borrowed\n', '     * @param borrower The address borrowing the underlying\n', '     * @param borrowAmount The amount of the underlying asset requested to borrow\n', '     */\n', '    function borrowVerify(address sToken, address borrower, uint borrowAmount) external {\n', '        // Shh - currently unused\n', '        sToken;\n', '        borrower;\n', '        borrowAmount;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to repay a borrow in the given market\n', '     * @param sToken The market to verify the repay against\n', '     * @param payer The account which would repay the asset\n', '     * @param borrower The account which would borrowed the asset\n', '     * @param repayAmount The amount of the underlying asset the account would repay\n', '     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function repayBorrowAllowed(\n', '        address sToken,\n', '        address payer,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        payer;\n', '        borrower;\n', '        repayAmount;\n', '\n', '        if (!markets[sToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        Exp memory borrowIndex = Exp({mantissa: SToken(sToken).borrowIndex()});\n', '        updateStrikeBorrowIndex(sToken, borrowIndex);\n', '        distributeBorrowerStrike(sToken, borrower, borrowIndex);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n', '     * @param sToken Asset being repaid\n', '     * @param payer The address repaying the borrow\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function repayBorrowVerify(\n', '        address sToken,\n', '        address payer,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint borrowerIndex) external {\n', '        // Shh - currently unused\n', '        sToken;\n', '        payer;\n', '        borrower;\n', '        actualRepayAmount;\n', '        borrowerIndex;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the liquidation should be allowed to occur\n', '     * @param sTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param sTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param repayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowAllowed(\n', '        address sTokenBorrowed,\n', '        address sTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        liquidator;\n', '\n', '        if (!markets[sTokenBorrowed].isListed || !markets[sTokenCollateral].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        /* The borrower must have shortfall in order to be liquidatable */\n', '        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall == 0) {\n', '            return uint(Error.INSUFFICIENT_SHORTFALL);\n', '        }\n', '\n', '        /* The liquidator may not repay more than what is allowed by the closeFactor */\n', '        uint borrowBalance = SToken(sTokenBorrowed).borrowBalanceStored(borrower);\n', '        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return uint(Error.MATH_ERROR);\n', '        }\n', '        if (repayAmount > maxClose) {\n', '            return uint(Error.TOO_MUCH_REPAY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n', '     * @param sTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param sTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowVerify(\n', '        address sTokenBorrowed,\n', '        address sTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        sTokenBorrowed;\n', '        sTokenCollateral;\n', '        liquidator;\n', '        borrower;\n', '        actualRepayAmount;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the seizing of assets should be allowed to occur\n', '     * @param sTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param sTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeAllowed(\n', '        address sTokenCollateral,\n', '        address sTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!seizeGuardianPaused, "seize is paused");\n', '\n', '        // Shh - currently unused\n', '        seizeTokens;\n', '\n', '        if (!markets[sTokenCollateral].isListed || !markets[sTokenBorrowed].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        if (SToken(sTokenCollateral).comptroller() != SToken(sTokenBorrowed).comptroller()) {\n', '            return uint(Error.COMPTROLLER_MISMATCH);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateStrikeSupplyIndex(sTokenCollateral);\n', '        distributeSupplierStrike(sTokenCollateral, borrower);\n', '        distributeSupplierStrike(sTokenCollateral, liquidator);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates seize and reverts on rejection. May emit logs.\n', '     * @param sTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param sTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeVerify(\n', '        address sTokenCollateral,\n', '        address sTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        sTokenCollateral;\n', '        sTokenBorrowed;\n', '        liquidator;\n', '        borrower;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to transfer tokens in the given market\n', '     * @param sToken The market to verify the transfer against\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of sTokens to transfer\n', '     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function transferAllowed(address sToken, address src, address dst, uint transferTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!transferGuardianPaused, "transfer is paused");\n', '\n', '        // Currently the only consideration is whether or not\n', '        //  the src is allowed to redeem this many tokens\n', '        uint allowed = redeemAllowedInternal(sToken, src, transferTokens);\n', '        if (allowed != uint(Error.NO_ERROR)) {\n', '            return allowed;\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateStrikeSupplyIndex(sToken);\n', '        distributeSupplierStrike(sToken, src);\n', '        distributeSupplierStrike(sToken, dst);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates transfer and reverts on rejection. May emit logs.\n', '     * @param sToken Asset being transferred\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of sTokens to transfer\n', '     */\n', '    function transferVerify(address sToken, address src, address dst, uint transferTokens) external {\n', '        // Shh - currently unused\n', '        sToken;\n', '        src;\n', '        dst;\n', '        transferTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /*** Liquidity/Liquidation Calculations ***/\n', '\n', '    /**\n', '     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n', '     *  Note that `sTokenBalance` is the number of sTokens the account owns in the market,\n', '     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n', '     */\n', '    struct AccountLiquidityLocalVars {\n', '        uint sumCollateral;\n', '        uint sumBorrowPlusEffects;\n', '        uint sTokenBalance;\n', '        uint borrowBalance;\n', '        uint exchangeRateMantissa;\n', '        uint oraclePriceMantissa;\n', '        Exp collateralFactor;\n', '        Exp exchangeRate;\n', '        Exp oraclePrice;\n', '        Exp tokensToDenom;\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code (semi-opaque),\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, SToken(0), 0, 0);\n', '\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code,\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n', '        return getHypotheticalAccountLiquidityInternal(account, SToken(0), 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param sTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @return (possible error code (semi-opaque),\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidity(\n', '        address account,\n', '        address sTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, SToken(sTokenModify), redeemTokens, borrowAmount);\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param sTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral sToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidityInternal(\n', '        address account,\n', '        SToken sTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) internal view returns (Error, uint, uint) {\n', '\n', '        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n', '        uint oErr;\n', '        MathError mErr;\n', '\n', '        // For each asset the account is in\n', '        SToken[] memory assets = accountAssets[account];\n', '        for (uint i = 0; i < assets.length; i++) {\n', '            SToken asset = assets[i];\n', '\n', '            // Read the balances and exchange rate from the sToken\n', '            (oErr, vars.sTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n', '            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n', '                return (Error.SNAPSHOT_ERROR, 0, 0);\n', '            }\n', '            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n', '            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n', '\n', '            // Get the normalized price of the asset\n', '            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n', '            if (vars.oraclePriceMantissa == 0) {\n', '                return (Error.PRICE_ERROR, 0, 0);\n', '            }\n', '            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n', '\n', '            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n', '            (mErr, vars.tokensToDenom) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // sumCollateral += tokensToDenom * sTokenBalance\n', '            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToDenom, vars.sTokenBalance, vars.sumCollateral);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n', '            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // Calculate effects of interacting with sTokenModify\n', '            if (asset == sTokenModify) {\n', '                // redeem effect\n', '                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n', '                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n', '                if (mErr != MathError.NO_ERROR) {\n', '                    return (Error.MATH_ERROR, 0, 0);\n', '                }\n', '\n', '                // borrow effect\n', '                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n', '                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n', '                if (mErr != MathError.NO_ERROR) {\n', '                    return (Error.MATH_ERROR, 0, 0);\n', '                }\n', '            }\n', '        }\n', '\n', '        // These are safe, as the underflow condition is checked first\n', '        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n', '            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n', '     * @dev Used in liquidation (called in sToken.liquidateBorrowFresh)\n', '     * @param sTokenBorrowed The address of the borrowed sToken\n', '     * @param sTokenCollateral The address of the collateral sToken\n', '     * @param actualRepayAmount The amount of sTokenBorrowed underlying to convert into sTokenCollateral tokens\n', '     * @return (errorCode, number of sTokenCollateral tokens to be seized in a liquidation)\n', '     */\n', '    function liquidateCalculateSeizeTokens(address sTokenBorrowed, address sTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n', '        /* Read oracle prices for borrowed and collateral markets */\n', '        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(SToken(sTokenBorrowed));\n', '        uint priceCollateralMantissa = oracle.getUnderlyingPrice(SToken(sTokenCollateral));\n', '        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n', '            return (uint(Error.PRICE_ERROR), 0);\n', '        }\n', '\n', '        /*\n', '         * Get the exchange rate and calculate the number of collateral tokens to seize:\n', '         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n', '         *  seizeTokens = seizeAmount / exchangeRate\n', '         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n', '         */\n', '        uint exchangeRateMantissa = SToken(sTokenCollateral).exchangeRateStored(); // Note: reverts on error\n', '        uint seizeTokens;\n', '        Exp memory numerator;\n', '        Exp memory denominator;\n', '        Exp memory ratio;\n', '        MathError mathErr;\n', '\n', '        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, ratio) = divExp(numerator, denominator);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        return (uint(Error.NO_ERROR), seizeTokens);\n', '    }\n', '\n', '    /*** Admin Functions ***/\n', '\n', '    /**\n', '      * @notice Sets a new price oracle for the comptroller\n', '      * @dev Admin function to set a new price oracle\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n', '        }\n', '\n', '        // Track the old oracle for the comptroller\n', '        PriceOracle oldOracle = oracle;\n', '\n', "        // Set comptroller's oracle to newOracle\n", '        oracle = newOracle;\n', '\n', '        // Emit NewPriceOracle(oldOracle, newOracle)\n', '        emit NewPriceOracle(oldOracle, newOracle);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the closeFactor used when liquidating borrows\n', '      * @dev Admin function to set closeFactor\n', '      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n', '        }\n', '\n', '        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n', '        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n', '        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n', '            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n', '        }\n', '\n', '        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n', '        if (lessThanExp(highLimit, newCloseFactorExp)) {\n', '            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n', '        }\n', '\n', '        uint oldCloseFactorMantissa = closeFactorMantissa;\n', '        closeFactorMantissa = newCloseFactorMantissa;\n', '        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the collateralFactor for a market\n', '      * @dev Admin function to set per-market collateralFactor\n', '      * @param sToken The market to set the factor on\n', '      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setCollateralFactor(SToken sToken, uint newCollateralFactorMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n', '        }\n', '\n', '        // Verify market is listed\n', '        Market storage market = markets[address(sToken)];\n', '        if (!market.isListed) {\n', '            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n', '        }\n', '\n', '        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n', '\n', '        // Check collateral factor <= 0.9\n', '        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n', '        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n', '            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n', '        }\n', '\n', '        // If collateral factor != 0, fail if price == 0\n', '        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(sToken) == 0) {\n', '            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n', '        }\n', '\n', "        // Set market's collateral factor to new collateral factor, remember old value\n", '        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n', '        market.collateralFactorMantissa = newCollateralFactorMantissa;\n', '\n', '        // Emit event with asset, old collateral factor, and new collateral factor\n', '        emit NewCollateralFactor(sToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets maxAssets which controls how many markets can be entered\n', '      * @dev Admin function to set maxAssets\n', '      * @param newMaxAssets New max assets\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n', '        }\n', '\n', '        uint oldMaxAssets = maxAssets;\n', '        maxAssets = newMaxAssets;\n', '        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets liquidationIncentive\n', '      * @dev Admin function to set liquidationIncentive\n', '      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n', '        }\n', '\n', '        // Check de-scaled min <= newLiquidationIncentive <= max\n', '        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n', '        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n', '        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n', '            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n', '        }\n', '\n', '        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n', '        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n', '            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n', '        }\n', '\n', '        // Save current value for use in log\n', '        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n', '\n', '        // Set liquidation incentive to new incentive\n', '        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n', '\n', '        // Emit event with old incentive, new incentive\n', '        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Add the market to the markets mapping and set it as listed\n', '      * @dev Admin function to set isListed and add support for the market\n', '      * @param sToken The address of the market (token) to list\n', '      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '      */\n', '    function _supportMarket(SToken sToken) external returns (uint) {\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n', '        }\n', '\n', '        if (markets[address(sToken)].isListed) {\n', '            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n', '        }\n', '\n', '        sToken.isSToken(); // Sanity check to make sure its really a SToken\n', '\n', '        markets[address(sToken)] = Market({isListed: true, isStriked: false, collateralFactorMantissa: 0});\n', '\n', '        _addMarketInternal(address(sToken));\n', '\n', '        emit MarketListed(sToken);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function _addMarketInternal(address sToken) internal {\n', '        for (uint i = 0; i < allMarkets.length; i ++) {\n', '            require(allMarkets[i] != SToken(sToken), "market already added");\n', '        }\n', '        allMarkets.push(SToken(sToken));\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function to change the Pause Guardian\n', '     * @param newPauseGuardian The address of the new Pause Guardian\n', '     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '     */\n', '    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n', '        }\n', '\n', '        // Save current value for inclusion in log\n', '        address oldPauseGuardian = pauseGuardian;\n', '\n', '        // Store pauseGuardian with value newPauseGuardian\n', '        pauseGuardian = newPauseGuardian;\n', '\n', '        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n', '        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function _setMintPaused(SToken sToken, bool state) public returns (bool) {\n', '        require(markets[address(sToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        mintGuardianPaused[address(sToken)] = state;\n', '        emit ActionPaused(sToken, "Mint", state);\n', '        return state;\n', '    }\n', '\n', '    function _setBorrowPaused(SToken sToken, bool state) public returns (bool) {\n', '        require(markets[address(sToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        borrowGuardianPaused[address(sToken)] = state;\n', '        emit ActionPaused(sToken, "Borrow", state);\n', '        return state;\n', '    }\n', '\n', '    function _setTransferPaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        transferGuardianPaused = state;\n', '        emit ActionPaused("Transfer", state);\n', '        return state;\n', '    }\n', '\n', '    function _setSeizePaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        seizeGuardianPaused = state;\n', '        emit ActionPaused("Seize", state);\n', '        return state;\n', '    }\n', '\n', '    function _become(Unitroller unitroller) public {\n', '        require(msg.sender == unitroller.admin(), "only unitroller admin can change brains");\n', '        require(unitroller._acceptImplementation() == 0, "change not authorized");\n', '    }\n', '\n', '    /**\n', '     * @notice Checks caller is admin, or this contract is becoming the new implementation\n', '     */\n', '    function adminOrInitializing() internal view returns (bool) {\n', '        return msg.sender == admin || msg.sender == comptrollerImplementation;\n', '    }\n', '\n', '    /*** STRK Distribution ***/\n', '\n', '    /**\n', '     * @notice Set STRK speed for a single market\n', '     * @param sToken The market whose STRK speed to update\n', '     * @param strikeSpeed New STRK speed for market\n', '     */\n', '    function _setStrikeSpeed(SToken sToken, uint strikeSpeed) public {\n', '        require(adminOrInitializing(), "only admin can set strike speed");\n', '        setStrikeSpeedInternal(sToken, strikeSpeed);\n', '    }\n', '\n', '    function setStrikeSpeedInternal(SToken sToken, uint strikeSpeed) internal {\n', '        uint currentStrikeSpeed = strikeSpeeds[address(sToken)];\n', '\n', '        if (currentStrikeSpeed != 0) {\n', '            // STRK speed could be set to 0 to half liquidity rewards for a market\n', '            Exp memory borrowIndex = Exp({\n', '                mantissa: sToken.borrowIndex()\n', '            });\n', '            updateStrikeSupplyIndex(address(sToken));\n', '            updateStrikeBorrowIndex(address(sToken), borrowIndex);\n', '        } else if (strikeSpeed != 0) {\n', '            // Add the STRK market\n', '            Market storage market = markets[address(sToken)];\n', '            require(market.isListed == true, "strike market is not listed");\n', '\n', '            if (strikeSupplyState[address(sToken)].index == 0 && strikeSupplyState[address(sToken)].block == 0) {\n', '                strikeSupplyState[address(sToken)] = StrikeMarketState({\n', '                    index: strikeInitialIndex,\n', '                    block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '                });\n', '            }\n', '\n', '            if (strikeBorrowState[address(sToken)].index == 0 && strikeBorrowState[address(sToken)].block == 0) {\n', '                strikeBorrowState[address(sToken)] = StrikeMarketState({\n', '                    index: strikeInitialIndex,\n', '                    block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '                });\n', '            }            \n', '        }\n', '\n', '        if (currentStrikeSpeed != strikeSpeed) {\n', '            strikeSpeeds[address(sToken)] = strikeSpeed;\n', '            emit StrikeSpeedUpdated(sToken, strikeSpeed);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Accrue STRK to the market by updating the supply index\n', '     * @param sToken The market whose supply index to update\n', '     */\n', '    function updateStrikeSupplyIndex(address sToken) internal {\n', '        StrikeMarketState storage supplyState = strikeSupplyState[sToken];\n', '        uint supplySpeed = strikeSpeeds[sToken];\n', '        uint blockNumber = getBlockNumber();\n', '        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n', '        if (deltaBlocks > 0 && supplySpeed > 0) {\n', '            uint supplyTokens = SToken(sToken).totalSupply();\n', '            uint strikeAccrued = mul_(deltaBlocks, supplySpeed);\n', '            Double memory ratio = supplyTokens > 0 ? fraction(strikeAccrued, supplyTokens) : Double({mantissa: 0});\n', '            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n', '            strikeSupplyState[sToken] = StrikeMarketState({\n', '                index: safe224(index.mantissa, "new index exceeds 224 bits"),\n', '                block: safe32(blockNumber, "block number exceeds 32 bits")\n', '            });\n', '        } else if (deltaBlocks > 0) {\n', '            supplyState.block = safe32(blockNumber, "block number exceeds 32 bits");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Accrue STRK to the market by updating the borrow index\n', '     * @param sToken The market whose borrow index to update\n', '     */\n', '    function updateStrikeBorrowIndex(address sToken, Exp memory marketBorrowIndex) internal {\n', '        StrikeMarketState storage borrowState = strikeBorrowState[sToken];\n', '        uint borrowSpeed = strikeSpeeds[sToken];\n', '        uint blockNumber = getBlockNumber();\n', '        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n', '        if (deltaBlocks > 0 && borrowSpeed > 0) {\n', '            uint borrowAmount = div_(SToken(sToken).totalBorrows(), marketBorrowIndex);\n', '            uint strikeAccrued = mul_(deltaBlocks, borrowSpeed);\n', '            Double memory ratio = borrowAmount > 0 ? fraction(strikeAccrued, borrowAmount) : Double({mantissa: 0});\n', '            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n', '            strikeBorrowState[sToken] = StrikeMarketState({\n', '                index: safe224(index.mantissa, "new index exceeds 224 bits"),\n', '                block: safe32(blockNumber, "block number exceeds 32 bits")\n', '            });\n', '        } else if (deltaBlocks > 0) {\n', '            borrowState.block = safe32(blockNumber, "block number exceeds 32 bits");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate STRK accrued by a supplier and possibly transfer it to them\n', '     * @param sToken The market in which the supplier is interacting\n', '     * @param supplier The address of the supplier to distribute STRK to\n', '     */\n', '    function distributeSupplierStrike(address sToken, address supplier) internal {\n', '        StrikeMarketState storage supplyState = strikeSupplyState[sToken];\n', '        Double memory supplyIndex = Double({mantissa: supplyState.index});\n', '        Double memory supplierIndex = Double({mantissa: strikeSupplierIndex[sToken][supplier]});\n', '        strikeSupplierIndex[sToken][supplier] = supplyIndex.mantissa;\n', '\n', '        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n', '            supplierIndex.mantissa = strikeInitialIndex;\n', '        }\n', '\n', '        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n', '        uint supplierTokens = SToken(sToken).balanceOf(supplier);\n', '        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n', '        uint supplierAccrued = add_(strikeAccrued[supplier], supplierDelta);\n', '        strikeAccrued[supplier] = supplierAccrued;\n', '        emit DistributedSupplierStrike(SToken(sToken), supplier, supplierDelta, supplyIndex.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate STRK accrued by a borrower and possibly transfer it to them\n', '     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n', '     * @param sToken The market in which the borrower is interacting\n', '     * @param borrower The address of the borrower to distribute STRK to\n', '     */\n', '    function distributeBorrowerStrike(address sToken, address borrower, Exp memory marketBorrowIndex) internal {\n', '        StrikeMarketState storage borrowState = strikeBorrowState[sToken];\n', '        Double memory borrowIndex = Double({mantissa: borrowState.index});\n', '        Double memory borrowerIndex = Double({mantissa: strikeBorrowerIndex[sToken][borrower]});\n', '        strikeBorrowerIndex[sToken][borrower] = borrowIndex.mantissa;\n', '\n', '        if (borrowerIndex.mantissa > 0) {\n', '            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n', '            uint borrowerAmount = div_(SToken(sToken).borrowBalanceStored(borrower), marketBorrowIndex);\n', '            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n', '            uint borrowerAccrued = add_(strikeAccrued[borrower], borrowerDelta);\n', '            strikeAccrued[borrower] = borrowerAccrued;\n', '            emit DistributedBorrowerStrike(SToken(sToken), borrower, borrowerDelta, borrowIndex.mantissa);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer STRK to the user, if they are above the threshold\n', '     * @dev Note: If there is not enough STRK, we do not perform the transfer all.\n', '     * @param user The address of the user to transfer STRK to\n', '     * @param userAccrued The amount of STRK to (possibly) transfer\n', '     * @return The amount of STRK which was NOT transferred to the user\n', '     */\n', '    function transferStrike(address user, uint userAccrued, uint threshold) internal returns (uint) {\n', '        if (userAccrued >= threshold && userAccrued > 0) {\n', '            STRK strk = STRK(getSTRKAddress());\n', '            uint strikeRemaining = strk.balanceOf(address(this));\n', '            if (userAccrued <= strikeRemaining) {\n', '                strk.transfer(user, userAccrued);\n', '                return 0;\n', '            }\n', '        }\n', '        return userAccrued;\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all the strike accrued by holder in all markets\n', '     * @param holder The address to claim STRK for\n', '     */\n', '    function claimStrike(address holder) public {\n', '        return claimStrike(holder, allMarkets);\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all the strike accrued by holder in the specified markets\n', '     * @param holder The address to claim STRK for\n', '     * @param sTokens The list of markets to claim STRK in\n', '     */\n', '    function claimStrike(address holder, SToken[] memory sTokens) public {\n', '        address[] memory holders = new address[](1);\n', '        holders[0] = holder;\n', '        claimStrike(holders, sTokens, true, true);\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all strike accrued by the holders\n', '     * @param holders The addresses to claim STRK for\n', '     * @param sTokens The list of markets to claim STRK in\n', '     * @param borrowers Whether or not to claim STRK earned by borrowing\n', '     * @param suppliers Whether or not to claim STRK earned by supplying\n', '     */\n', '    function claimStrike(address[] memory holders, SToken[] memory sTokens, bool borrowers, bool suppliers) public {\n', '        for (uint i = 0; i < sTokens.length; i++) {\n', '            SToken sToken = sTokens[i];\n', '            require(markets[address(sToken)].isListed, "market must be listed");\n', '            if (borrowers) {\n', '                Exp memory borrowIndex = Exp({mantissa: sToken.borrowIndex()});\n', '                updateStrikeBorrowIndex(address(sToken), borrowIndex);\n', '                for (uint j = 0; j < holders.length; j++) {\n', '                    distributeBorrowerStrike(address(sToken), holders[j], borrowIndex);\n', '                    strikeAccrued[holders[j]] = grantSTRKInternal(holders[j], strikeAccrued[holders[j]]);\n', '                }\n', '            }\n', '            if (suppliers) {\n', '                updateStrikeSupplyIndex(address(sToken));\n', '                for (uint j = 0; j < holders.length; j++) {\n', '                    distributeSupplierStrike(address(sToken), holders[j]);\n', '                    strikeAccrued[holders[j]] = grantSTRKInternal(holders[j], strikeAccrued[holders[j]]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer STRK to the user\n', '     * @dev Note: If there is not enough STRK, we do not perform the transfer all.\n', '     * @param user The address of the user to transfer STRK to\n', '     * @param amount The amount of STRK to (possibly) transfer\n', '     * @return The amount of STRK which was NOT transferred to the user\n', '     */\n', '    function grantSTRKInternal(address user, uint amount) internal returns (uint) {\n', '        STRK strk = STRK(getSTRKAddress());\n', '        uint strikeRemaining = strk.balanceOf(address(this));\n', '        if (amount > 0 && amount <= strikeRemaining) {\n', '            strk.transfer(user, amount);\n', '            return 0;\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    /*** STRK Distribution Admin ***/\n', '\n', '    /**\n', '     * @notice Set the amount of STRK distributed per block\n', '     * @param strikeRate_ The amount of STRK wei per block to distribute\n', '     */\n', '    function _setStrikeRate(uint strikeRate_) public {\n', '        require(adminOrInitializing(), "only admin can change strike rate");\n', '\n', '        uint oldRate = strikeRate;\n', '        strikeRate = strikeRate_;\n', '        emit NewStrikeRate(oldRate, strikeRate_);\n', '\n', '        // refreshStrikeSpeedsInternal();\n', '    }\n', '\n', '    /**\n', '     * @notice Add markets to strikeMarkets, allowing them to earn STRK in the flywheel\n', '     * @param sTokens The addresses of the markets to add\n', '     */\n', '    function _addStrikeMarkets(address[] memory sTokens) public {\n', '        require(adminOrInitializing(), "only admin can add strike market");\n', '\n', '        for (uint i = 0; i < sTokens.length; i++) {\n', '            _addStrikeMarketInternal(sTokens[i]);\n', '        }\n', '\n', '        // refreshStrikeSpeedsInternal();\n', '    }\n', '\n', '    function _addStrikeMarketInternal(address sToken) internal {\n', '        Market storage market = markets[sToken];\n', '        require(market.isListed == true, "strike market is not listed");\n', '        require(market.isStriked == false, "strike market already added");\n', '\n', '        market.isStriked = true;\n', '        emit MarketStriked(SToken(sToken), true);\n', '\n', '        if (strikeSupplyState[sToken].index == 0 && strikeSupplyState[sToken].block == 0) {\n', '            strikeSupplyState[sToken] = StrikeMarketState({\n', '                index: strikeInitialIndex,\n', '                block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '            });\n', '        }\n', '\n', '        if (strikeBorrowState[sToken].index == 0 && strikeBorrowState[sToken].block == 0) {\n', '            strikeBorrowState[sToken] = StrikeMarketState({\n', '                index: strikeInitialIndex,\n', '                block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '            });\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Remove a market from strikeMarkets, preventing it from earning STRK in the flywheel\n', '     * @param sToken The address of the market to drop\n', '     */\n', '    function _dropStrikeMarket(address sToken) public {\n', '        require(msg.sender == admin, "only admin can drop strike market");\n', '\n', '        Market storage market = markets[sToken];\n', '        require(market.isStriked == true, "market is not a strike market");\n', '\n', '        market.isStriked = false;\n', '        emit MarketStriked(SToken(sToken), false);\n', '\n', '        // refreshStrikeSpeedsInternal();\n', '    }\n', '\n', '    /**\n', '     * @notice Return all of the markets\n', '     * @dev The automatic getter may be used to access an individual market.\n', '     * @return The list of market addresses\n', '     */\n', '    function getAllMarkets() public view returns (SToken[] memory) {\n', '        return allMarkets;\n', '    }\n', '\n', '    function getBlockNumber() public view returns (uint) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the address of the STRK token\n', '     * @return The address of STRK\n', '     */\n', '    function getSTRKAddress() public view returns (address) {\n', '        return 0x74232704659ef37c08995e386A2E26cc27a8d7B1;\n', '    }\n', '}']