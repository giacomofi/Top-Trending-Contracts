['// "SPDX-License-Identifier: UNLICENSED"\n', 'pragma solidity >=0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n', '/// @notice all the APIs of GelatoConditionsStandard\n', '/// @dev all the APIs are implemented inside GelatoConditionsStandard\n', 'interface IGelatoCondition {\n', '\n', '    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n', "    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n", '    ///  "ok" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n', '    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n', '    ///  source of Task identification.\n', '    /// @param _conditionData This is the Condition.data field developers must encode their\n', "    ///  Condition's specific parameters in.\n", '    /// @param _cycleId For Tasks that are executed as part of a cycle.\n', '    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n', '        external\n', '        view\n', '        returns(string memory);\n', '}\n', '\n', '// "SPDX-License-Identifier: UNLICENSED"\n', 'pragma solidity >=0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import {IGelatoProviderModule} from "../../gelato_provider_modules/IGelatoProviderModule.sol";\n', 'import {IGelatoCondition} from "../../gelato_conditions/IGelatoCondition.sol";\n', '\n', 'struct Provider {\n', '    address addr;  //  if msg.sender == provider => self-Provider\n', '    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n', '}\n', '\n', 'struct Condition {\n', '    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n', '    bytes data;  // can be bytes32(0) for self-conditional Actions\n', '}\n', '\n', 'enum Operation { Call, Delegatecall }\n', '\n', 'enum DataFlow { None, In, Out, InAndOut }\n', '\n', 'struct Action {\n', '    address addr;\n', '    bytes data;\n', '    Operation operation;\n', '    DataFlow dataFlow;\n', '    uint256 value;\n', '    bool termsOkCheck;\n', '}\n', '\n', 'struct Task {\n', '    Condition[] conditions;  // optional\n', '    Action[] actions;\n', '    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n', '    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n', '}\n', '\n', 'struct TaskReceipt {\n', '    uint256 id;\n', '    address userProxy;\n', '    Provider provider;\n', '    uint256 index;\n', '    Task[] tasks;\n', '    uint256 expiryDate;\n', '    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n', '    uint256 submissionsLeft;\n', '}\n', '\n', 'interface IGelatoCore {\n', '    event LogTaskSubmitted(\n', '        uint256 indexed taskReceiptId,\n', '        bytes32 indexed taskReceiptHash,\n', '        TaskReceipt taskReceipt\n', '    );\n', '\n', '    event LogExecSuccess(\n', '        address indexed executor,\n', '        uint256 indexed taskReceiptId,\n', '        uint256 executorSuccessFee,\n', '        uint256 sysAdminSuccessFee\n', '    );\n', '    event LogCanExecFailed(\n', '        address indexed executor,\n', '        uint256 indexed taskReceiptId,\n', '        string reason\n', '    );\n', '    event LogExecReverted(\n', '        address indexed executor,\n', '        uint256 indexed taskReceiptId,\n', '        uint256 executorRefund,\n', '        string reason\n', '    );\n', '\n', '    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\n', '\n', '    /// @notice API to query whether Task can be submitted successfully.\n', '    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n', '    /// @param _provider Gelato Provider object: provider address and module.\n', '    /// @param _userProxy The userProxy from which the task will be submitted.\n', '    /// @param _task Selected provider, conditions, actions, expiry date of the task\n', '    function canSubmitTask(\n', '        address _userProxy,\n', '        Provider calldata _provider,\n', '        Task calldata _task,\n', '        uint256 _expiryDate\n', '    )\n', '        external\n', '        view\n', '        returns(string memory);\n', '\n', '    /// @notice API to submit a single Task.\n', '    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n', '    /// @param _provider Gelato Provider object: provider address and module.\n', '    /// @param _task A Gelato Task object: provider, conditions, actions.\n', '    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n', '    function submitTask(\n', '        Provider calldata _provider,\n', '        Task calldata _task,\n', '        uint256 _expiryDate\n', '    )\n', '        external;\n', '\n', '\n', '    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n', '    ///  the next one, after they have been executed.\n', '    /// @param _provider Gelato Provider object: provider address and module.\n', '    /// @param _tasks This can be a single task or a sequence of tasks.\n', '    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n', '    /// @param _cycles How many full cycles will be submitted\n', '    function submitTaskCycle(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _cycles\n', '    )\n', '        external;\n', '\n', '\n', '    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n', '    ///  the next one, after they have been executed.\n', '    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n', '    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n', '    ///  would be submitted, but not the second\n', '    /// @param _provider Gelato Provider object: provider address and module.\n', '    /// @param _tasks This can be a single task or a sequence of tasks.\n', '    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n', '    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n', '    ///  that should have occured once the cycle is complete:\n', '    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n', '    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n', '    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n', '    ///  ...\n', '    function submitTaskChain(\n', '        Provider calldata _provider,\n', '        Task[] calldata _tasks,\n', '        uint256 _expiryDate,\n', '        uint256 _sumOfRequestedTaskSubmits\n', '    )\n', '        external;\n', '\n', '    // ================  Exec Suite =========================\n', '    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n', '    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n', '    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n', '    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n', '    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n', '    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n', "    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n", '    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n', '    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\n', '        external\n', '        view\n', '        returns(string memory);\n', '\n', '    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n', '    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n', '    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n', '    ///   In the latter case Executors are refunded by the Task Provider.\n', '    /// @param _TR TaskReceipt: id, userProxy, Task.\n', '    function exec(TaskReceipt calldata _TR) external;\n', '\n', '    /// @notice Cancel task\n', '    /// @dev Callable only by userProxy or selected provider\n', '    /// @param _TR TaskReceipt: id, userProxy, Task.\n', '    function cancelTask(TaskReceipt calldata _TR) external;\n', '\n', '    /// @notice Cancel multiple tasks at once\n', '    /// @dev Callable only by userProxy or selected provider\n', '    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n', '    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n', '\n', '    /// @notice Compute hash of task receipt\n', '    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n', '    /// @return hash of taskReceipt\n', '    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n', '\n', '    // ================  Getters =========================\n', '    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n', '    /// @return currentId currentId, last TaskReceiptId submitted\n', '    function currentTaskReceiptId() external view returns(uint256);\n', '\n', '    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n', '    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n', '    /// @return hash of taskReceipt\n', '    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n', '}\n', '\n', '// "SPDX-License-Identifier: UNLICENSED"\n', 'pragma solidity >=0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import {Action, Task} from "../gelato_core/interfaces/IGelatoCore.sol";\n', '\n', 'interface IGelatoProviderModule {\n', '\n', '    /// @notice Check if provider agrees to pay for inputted task receipt\n', '    /// @dev Enables arbitrary checks by provider\n', '    /// @param _userProxy The smart contract account of the user who submitted the Task.\n', '    /// @param _provider The account of the Provider who uses the ProviderModule.\n', '    /// @param _task Gelato Task to be executed.\n', '    /// @return "OK" if provider agrees\n', '    function isProvided(address _userProxy, address _provider, Task calldata _task)\n', '        external\n', '        view\n', '        returns(string memory);\n', '\n', '    /// @notice Convert action specific payload into proxy specific payload\n', '    /// @dev Encoded multiple actions into a multisend\n', '    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n', '    /// @param _userProxy The smart contract account of the user who submitted the Task.\n', '    /// @param _provider The account of the Provider who uses the ProviderModule.\n', '    /// @param _task Gelato Task to be executed.\n', '    /// @param _cycleId For Tasks that form part of a cycle/chain.\n', '    /// @return Encoded payload that will be used for low-level .call on user proxy\n', '    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n', '    function execPayload(\n', '        uint256 _taskReceiptId,\n', '        address _userProxy,\n', '        address _provider,\n', '        Task calldata _task,\n', '        uint256 _cycleId\n', '    )\n', '        external\n', '        view\n', '        returns(bytes memory, bool checkReturndata);\n', '\n', '    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n', '    /// @dev If a caught revert is detected, this fn should revert with the detected error\n', '    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n', '    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', '// Aave Lending Pool Addresses Provider\n', 'address constant LENDING_POOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\n', 'address constant CHAINLINK_ETH_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n', 'address constant AAVE_PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\n', '\n', 'address constant LENDING_POOL_CORE_V1 = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'address constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'enum PROTOCOL {AAVE, MAKER, COMPOUND, NONE}\n', '\n', 'function GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()\n', '    pure\n', '    returns (uint256[4] memory)\n', '{\n', '    return [uint256(2519000), 3140500, 3971000, 4345000];\n', '}\n', '\n', 'function GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()\n', '    pure\n', '    returns (uint256[4] memory)\n', '{\n', '    return [uint256(2028307), 2626711, 2944065, 3698800];\n', '}\n', '\n', 'function GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()\n', '    pure\n', '    returns (uint256[4] memory)\n', '{\n', '    return [uint256(2358534), 2956937, 3381960, 4029400];\n', '}\n', '\n', 'uint256 constant FAST_TX_FEE = 30;\n', 'uint256 constant VAULT_CREATION_COST = 200000;\n', 'uint256 constant MAX_INSTA_FEE = 3e15;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IGelatoGasPriceOracle\n', '} from "../interfaces/gelato/IGelatoGasPriceOracle.sol";\n', '\n', 'IGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\n', '    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\n', ');\n', '\n', 'address constant GELATO_EXECUTOR_MODULE = 0x98edc8067Cc671BCAE82D36dCC609C3E4e078AC8;\n', '\n', 'address constant CONDITION_MAKER_VAULT_UNSAFE_OSM = 0xDF3CDd10e646e4155723a3bC5b1191741DD90333;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', '// InstaDapp\n', 'address constant INSTA_MEMORY = 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F;\n', '\n', '// Connectors\n', 'address constant CONNECT_MAKER = 0xac02030d8a8F49eD04b2f52C394D3F901A10F8A9;\n', 'address constant CONNECT_COMPOUND = 0x15FdD1e902cAC70786fe7D31013B1a806764B5a2;\n', 'address constant INSTA_POOL_V2 = 0xeB4bf86589f808f90EEC8e964dBF16Bd4D284905;\n', 'address constant CONNECT_AAVE_V2 = 0xBF6E4331ffd02F7043e62788FD272aeFc712f5ee;\n', 'address constant CONNECT_DYDX = 0x6AF6C791c869DfA65f8A2fa042fA47D1535Bef25;\n', 'address constant CONNECT_BASIC = 0xe5398f279175962E56fE4c5E0b62dc7208EF36c6;\n', 'address constant CONNECT_FEE = 0xB99152F8073033B318C1Bfbfaaa582029e982CE9;\n', '\n', '// Insta Pool\n', 'address constant INSTA_POOL_RESOLVER = 0xa004a5afBa04b74037E9E52bA1f7eb02b5E61509;\n', 'uint256 constant ROUTE_1_TOLERANCE = 1005e15;\n', '\n', '// Insta Mapping\n', 'address constant INSTA_MAPPING = 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88;\n', '\n', 'address constant INSTA_MAKER_RESOLVER = 0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'address constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n', 'address constant JUG = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', '// ETH\n', 'address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', 'address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '// USD\n', 'address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {GelatoBytes} from "../../../../lib/GelatoBytes.sol";\n', 'import {\n', '    DataFlow\n', '} from "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol";\n', 'import {\n', '    _isVaultOwner,\n', '    _getMakerVaultDebt\n', '} from "../../../../functions/dapps/FMaker.sol";\n', 'import {\n', '    AccountInterface,\n', '    ConnectorInterface\n', '} from "../../../../interfaces/InstaDapp/IInstaDapp.sol";\n', '\n', 'abstract contract BDebtBridgeFromMaker is ConnectorInterface {\n', '    using GelatoBytes for bytes;\n', '\n', '    string public constant OK = "OK";\n', '    uint256 internal immutable _id;\n', '    address public immutable oracleAggregator;\n', '    address public immutable instaFeeCollector;\n', '    address public immutable connectGelatoDataFromMakerAddr;\n', '    address internal immutable _connectGelatoDebtBridgeFee;\n', '\n', '    constructor(\n', '        uint256 __id,\n', '        address _oracleAggregator,\n', '        address __instaFeeCollector,\n', '        address __connectGelatoDebtBridgeFee\n', '    ) {\n', '        _id = __id;\n', '        oracleAggregator = _oracleAggregator;\n', '        instaFeeCollector = __instaFeeCollector;\n', '        _connectGelatoDebtBridgeFee = __connectGelatoDebtBridgeFee;\n', '        connectGelatoDataFromMakerAddr = address(this);\n', '    }\n', '\n', '    /// @dev Connector Details\n', '    function connectorID()\n', '        external\n', '        view\n', '        override\n', '        returns (uint256 _type, uint256 id)\n', '    {\n', '        (_type, id) = (1, _id); // Should put specific value.\n', '    }\n', '\n', '    // ====== ACTION TERMS CHECK ==========\n', "    // Overriding IGelatoAction's function (optional)\n", '    function termsOk(\n', '        uint256, // taskReceipId\n', '        address _dsa,\n', '        bytes calldata _actionData,\n', '        DataFlow,\n', '        uint256, // value\n', '        uint256 // cycleId\n', '    ) public view returns (string memory) {\n', '        uint256 vaultId = abi.decode(_actionData[4:36], (uint256));\n', '\n', '        if (vaultId == 0)\n', '            return\n', '                string(\n', '                    abi.encodePacked(this.name(), ": Vault Id is not valid")\n', '                );\n', '        if (!_isVaultOwner(vaultId, _dsa))\n', '            return\n', '                string(\n', '                    abi.encodePacked(this.name(), ": Vault not owned by dsa")\n', '                );\n', '        return OK;\n', '    }\n', '\n', '    function _cast(address[] memory targets, bytes[] memory datas) internal {\n', '        // Instapool V2 / FlashLoan call\n', '        bytes memory castData =\n', '            abi.encodeWithSelector(\n', '                AccountInterface.cast.selector,\n', '                targets,\n', '                datas,\n', '                msg.sender // msg.sender == GelatoCore\n', '            );\n', '\n', '        (bool success, bytes memory returndata) =\n', '            address(this).delegatecall(castData);\n', '        if (!success) {\n', '            returndata.revertWithError(\n', '                string(\n', '                    abi.encodePacked(\n', '                        ConnectorInterface(connectGelatoDataFromMakerAddr)\n', '                            .name(),\n', '                        "._cast:"\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectInstaPoolV2\n', '} from "../../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol";\n', 'import {DAI, ETH} from "../../../../../constants/CTokens.sol";\n', 'import {\n', '    CONNECT_MAKER,\n', '    CONNECT_COMPOUND,\n', '    INSTA_POOL_V2,\n', '    CONNECT_BASIC,\n', '    CONNECT_FEE\n', '} from "../../../../../constants/CInstaDapp.sol";\n', 'import {\n', '    _getMakerVaultDebt,\n', '    _getMakerVaultCollateralBalance\n', '} from "../../../../../functions/dapps/FMaker.sol";\n', 'import {\n', '    _encodeFlashPayback\n', '} from "../../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol";\n', 'import {\n', '    _encodePaybackMakerVault,\n', '    _encodedWithdrawMakerVault\n', '} from "../../../../../functions/InstaDapp/connectors/FConnectMaker.sol";\n', 'import {\n', '    _encodeDepositCompound,\n', '    _encodeBorrowCompound\n', '} from "../../../../../functions/InstaDapp/connectors/FConnectCompound.sol";\n', 'import {\n', '    _encodeBasicWithdraw\n', '} from "../../../../../functions/InstaDapp/connectors/FConnectBasic.sol";\n', 'import {\n', '    _encodeCalculateFee\n', '} from "../../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol";\n', 'import {\n', '    _getGelatoExecutorFees\n', '} from "../../../../../functions/gelato/FGelato.sol";\n', 'import {\n', '    _getFlashLoanRoute,\n', '    _getGasCostMakerToCompound,\n', '    _getRealisedDebt\n', '} from "../../../../../functions/gelato/FGelatoDebtBridge.sol";\n', 'import {\n', '    IInstaFeeCollector\n', '} from "../../../../../interfaces/InstaDapp/IInstaFeeCollector.sol";\n', 'import {BDebtBridgeFromMaker} from "../../base/BDebtBridgeFromMaker.sol";\n', 'import {\n', '    IOracleAggregator\n', '} from "../../../../../interfaces/gelato/IOracleAggregator.sol";\n', 'import {_convertTo18} from "../../../../../vendor/Convert.sol";\n', 'import {GELATO_EXECUTOR_MODULE} from "../../../../../constants/CGelato.sol";\n', '\n', 'contract ConnectGelatoDataMakerToCompound is BDebtBridgeFromMaker {\n', '    // solhint-disable const-name-snakecase\n', '    string public constant override name =\n', '        "ConnectGelatoDataMakerToCompound-v1.0";\n', '\n', '    // solhint-disable no-empty-blocks\n', '    constructor(\n', '        uint256 __id,\n', '        address _oracleAggregator,\n', '        address __instaFeeCollector,\n', '        address __connectGelatoDebtBridgeFee\n', '    )\n', '        BDebtBridgeFromMaker(\n', '            __id,\n', '            _oracleAggregator,\n', '            __instaFeeCollector,\n', '            __connectGelatoDebtBridgeFee\n', '        )\n', '    {}\n', '\n', '    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\n', '    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n', '    /// @param _vaultId Id of the unsafe vault of the client.\n', "    /// @param _colToken  vault's col token address .\n", '    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\n', '        external\n', '        payable\n', '    {\n', '        (address[] memory targets, bytes[] memory datas) =\n', '            _dataMakerToCompound(_vaultId, _colToken);\n', '\n', '        _cast(targets, datas);\n', '    }\n', '\n', '    /* solhint-disable function-max-lines */\n', '\n', '    function _dataMakerToCompound(uint256 _vaultId, address _colToken)\n', '        internal\n', '        view\n', '        returns (address[] memory targets, bytes[] memory datas)\n', '    {\n', '        targets = new address[](1);\n', '        targets[0] = INSTA_POOL_V2;\n', '\n', '        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\n', '\n', '        uint256 route = _getFlashLoanRoute(DAI, _vaultId, daiToBorrow);\n', '\n', '        (uint256 gasFeesPaidFromDebt, uint256 decimals) =\n', '            IOracleAggregator(oracleAggregator).getExpectedReturnAmount(\n', '                _getGelatoExecutorFees(_getGasCostMakerToCompound(route)),\n', '                ETH,\n', '                DAI\n', '            );\n', '\n', '        gasFeesPaidFromDebt = _convertTo18(decimals, gasFeesPaidFromDebt);\n', '\n', '        (address[] memory _targets, bytes[] memory _datas) =\n', '            _spellsMakerToCompound(\n', '                _vaultId,\n', '                _colToken,\n', '                daiToBorrow,\n', '                _getMakerVaultCollateralBalance(_vaultId),\n', '                gasFeesPaidFromDebt\n', '            );\n', '\n', '        datas = new bytes[](1);\n', '        datas[0] = abi.encodeWithSelector(\n', '            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n', '            DAI,\n', '            daiToBorrow,\n', '            route,\n', '            abi.encode(_targets, _datas)\n', '        );\n', '    }\n', '\n', '    function _spellsMakerToCompound(\n', '        uint256 _vaultId,\n', '        address _colToken,\n', '        uint256 _daiDebtAmt,\n', '        uint256 _colToWithdrawFromMaker,\n', '        uint256 _gasFeesPaidFromDebt\n', '    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n', '        targets = new address[](8);\n', '        targets[0] = CONNECT_MAKER; // payback\n', '        targets[1] = CONNECT_MAKER; // withdraw\n', '        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n', '        targets[3] = CONNECT_COMPOUND; // deposit\n', '        targets[4] = CONNECT_COMPOUND; // borrow\n', '        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n', '        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n', '        targets[7] = INSTA_POOL_V2; // flashPayback\n', '\n', '        datas = new bytes[](8);\n', '        datas[0] = _encodePaybackMakerVault(\n', '            _vaultId,\n', '            type(uint256).max,\n', '            0,\n', '            600\n', '        );\n', '        datas[1] = _encodedWithdrawMakerVault(\n', '            _vaultId,\n', '            type(uint256).max,\n', '            0,\n', '            0\n', '        );\n', '        datas[2] = _encodeCalculateFee(\n', '            0,\n', '            _gasFeesPaidFromDebt,\n', '            IInstaFeeCollector(instaFeeCollector).fee(),\n', '            600,\n', '            600,\n', '            601\n', '        );\n', '        datas[3] = _encodeDepositCompound(\n', '            _colToken,\n', '            _colToWithdrawFromMaker,\n', '            0,\n', '            0\n', '        );\n', '        datas[4] = _encodeBorrowCompound(DAI, 0, 600, 0);\n', '        datas[5] = _encodeBasicWithdraw(\n', '            DAI,\n', '            0,\n', '            IInstaFeeCollector(instaFeeCollector).feeCollector(),\n', '            601,\n', '            0\n', '        );\n', '        datas[6] = _encodeBasicWithdraw(\n', '            DAI,\n', '            _gasFeesPaidFromDebt,\n', '            payable(GELATO_EXECUTOR_MODULE),\n', '            0,\n', '            0\n', '        );\n', '        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n', '    }\n', '\n', '    /* solhint-enable function-max-lines */\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectBasic\n', '} from "../../../interfaces/InstaDapp/connectors/IConnectBasic.sol";\n', '\n', 'function _encodeBasicWithdraw(\n', '    address _erc20,\n', '    uint256 _tokenAmt,\n', '    address payable _to,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectBasic.withdraw.selector,\n', '            _erc20,\n', '            _tokenAmt,\n', '            _to,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectCompound\n', '} from "../../../interfaces/InstaDapp/connectors/IConnectCompound.sol";\n', '\n', 'function _encodeDepositCompound(\n', '    address _token,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectCompound.deposit.selector,\n', '            _token,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', 'function _encodeBorrowCompound(\n', '    address _token,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectCompound.borrow.selector,\n', '            _token,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectDebtBridgeFee\n', '} from "../../../interfaces/InstaDapp/connectors/IConnectDebtBridgeFee.sol";\n', '\n', 'function _encodeCalculateFee(\n', '    uint256 _amount,\n', '    uint256 _ftf,\n', '    uint256 _fee,\n', '    uint256 _getId,\n', '    uint256 _setId,\n', '    uint256 _setIdFee\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectDebtBridgeFee.calculateFee.selector,\n', '            _amount,\n', '            _ftf,\n', '            _fee,\n', '            _getId,\n', '            _setId,\n', '            _setIdFee\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectMaker\n', '} from "../../../interfaces/InstaDapp/connectors/IConnectMaker.sol";\n', '\n', 'function _encodeOpenMakerVault(string memory _colType)\n', '    pure\n', '    returns (bytes memory)\n', '{\n', '    return abi.encodeWithSelector(IConnectMaker.open.selector, _colType);\n', '}\n', '\n', 'function _encodeBorrowMakerVault(\n', '    uint256 _vaultId,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectMaker.borrow.selector,\n', '            _vaultId,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', 'function _encodedDepositMakerVault(\n', '    uint256 _vaultId,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectMaker.deposit.selector,\n', '            _vaultId,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', 'function _encodePaybackMakerVault(\n', '    uint256 _vaultId,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectMaker.payback.selector,\n', '            _vaultId,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', 'function _encodedWithdrawMakerVault(\n', '    uint256 _vaultId,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectMaker.withdraw.selector,\n', '            _vaultId,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IConnectInstaPoolV2\n', '} from "../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol";\n', '\n', 'function _encodeFlashPayback(\n', '    address _token,\n', '    uint256 _amt,\n', '    uint256 _getId,\n', '    uint256 _setId\n', ') pure returns (bytes memory) {\n', '    return\n', '        abi.encodeWithSelector(\n', '            IConnectInstaPoolV2.flashPayback.selector,\n', '            _token,\n', '            _amt,\n', '            _getId,\n', '            _setId\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    IAaveProtocolDataProvider\n', '} from "../../interfaces/dapps/Aave/IAaveProtocolDataProvider.sol";\n', 'import {\n', '    ILendingPoolAddressesProvider\n', '} from "../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol";\n', 'import {\n', '    ChainLinkInterface\n', '} from "../../interfaces/dapps/Aave/ChainLinkInterface.sol";\n', 'import {ILendingPool} from "../../interfaces/dapps/Aave/ILendingPool.sol";\n', 'import {WETH, ETH} from "../../constants/CTokens.sol";\n', 'import {AaveUserData} from "../../structs/SAave.sol";\n', 'import {\n', '    LENDING_POOL_ADDRESSES_PROVIDER,\n', '    CHAINLINK_ETH_FEED,\n', '    AAVE_PROTOCOL_DATA_PROVIDER,\n', '    LENDING_POOL_CORE_V1\n', '} from "../../constants/CAave.sol";\n', 'import {ETH, WETH} from "../../constants/CTokens.sol";\n', 'import {IERC20} from "../../interfaces/dapps/IERC20.sol";\n', '\n', 'function _getEtherPrice() view returns (uint256 ethPrice) {\n', '    ethPrice = uint256(ChainLinkInterface(CHAINLINK_ETH_FEED).latestAnswer());\n', '}\n', '\n', 'function _getUserData(address user)\n', '    view\n', '    returns (AaveUserData memory userData)\n', '{\n', '    (\n', '        uint256 totalCollateralETH,\n', '        uint256 totalDebtETH,\n', '        uint256 availableBorrowsETH,\n', '        uint256 currentLiquidationThreshold,\n', '        uint256 ltv,\n', '        uint256 healthFactor\n', '    ) =\n', '        ILendingPool(\n', '            ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER)\n', '                .getLendingPool()\n', '        )\n', '            .getUserAccountData(user);\n', '\n', '    userData = AaveUserData(\n', '        totalCollateralETH,\n', '        totalDebtETH,\n', '        availableBorrowsETH,\n', '        currentLiquidationThreshold,\n', '        ltv,\n', '        healthFactor,\n', '        _getEtherPrice()\n', '    );\n', '}\n', '\n', 'function _getAssetLiquidationThreshold(address _token)\n', '    view\n', '    returns (uint256 liquidationThreshold)\n', '{\n', '    (, , liquidationThreshold, , , , , , , ) = IAaveProtocolDataProvider(\n', '        AAVE_PROTOCOL_DATA_PROVIDER\n', '    )\n', '        .getReserveConfigurationData(_getTokenAddr(_token));\n', '}\n', '\n', 'function _getTokenAddr(address _token) pure returns (address) {\n', '    return _token == ETH ? WETH : _token;\n', '}\n', '\n', 'function _getTokenLiquidity(address _token) view returns (uint256) {\n', '    return\n', '        IERC20(_token).balanceOf(\n', '            ILendingPool(\n', '                ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER)\n', '                    .getLendingPool()\n', '            )\n', '                .getReserveData(_token)\n', '                .aTokenAddress\n', '        );\n', '}\n', '\n', 'function _isAaveUnderlyingLiquid(address _debtToken, uint256 _debtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    return _getTokenLiquidity(_debtToken) > _debtAmt;\n', '}\n', '\n', 'function _isAaveUnderlyingLiquidV1(address _debtToken, uint256 _debtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    return IERC20(_debtToken).balanceOf(LENDING_POOL_CORE_V1) > _debtAmt;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {INSTA_MAPPING} from "../../constants/CInstaDapp.sol";\n', 'import {COMPTROLLER} from "../../constants/CCompound.sol";\n', 'import {InstaMapping} from "../../interfaces/InstaDapp/IInstaDapp.sol";\n', 'import {ICToken} from "../../interfaces/dapps/Compound/ICToken.sol";\n', 'import {IComptroller} from "../../interfaces/dapps/Compound/IComptroller.sol";\n', 'import {IPriceOracle} from "../../interfaces/dapps/Compound/IPriceOracle.sol";\n', '\n', 'function _getCToken(address _token) view returns (address) {\n', '    return InstaMapping(INSTA_MAPPING).cTokenMapping(_token);\n', '}\n', '\n', 'function _wouldCompoundAccountBeLiquid(\n', '    address _dsa,\n', '    address _cColToken,\n', '    uint256 _colAmt,\n', '    address _cDebtToken,\n', '    uint256 _debtAmt\n', ') view returns (bool) {\n', '    IComptroller comptroller = IComptroller(COMPTROLLER);\n', '    IPriceOracle priceOracle = IPriceOracle(comptroller.oracle());\n', '\n', '    (, uint256 collateralFactor, ) = comptroller.markets(_cColToken);\n', '    (uint256 error, uint256 liquidity, uint256 shortfall) =\n', '        comptroller.getAccountLiquidity(_dsa);\n', '\n', '    require(error == 0, "Get Account Liquidity function failed.");\n', '\n', '    return\n', '        mulScalarTruncateAddUInt(\n', '            mul_expScale(collateralFactor, _colAmt),\n', '            priceOracle.getUnderlyingPrice(ICToken(_cColToken)),\n', '            liquidity\n', '        ) >\n', '        mulScalarTruncateAddUInt(\n', '            _debtAmt,\n', '            priceOracle.getUnderlyingPrice(ICToken(_cDebtToken)),\n', '            shortfall\n', '        );\n', '}\n', '\n', 'function _isCompoundUnderlyingLiquidity(address _debtToken, uint256 _debtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    return ICToken(_getCToken(_debtToken)).getCash() > _debtAmt;\n', '}\n', '\n', '// Compound Math Function\n', '\n', 'function mulScalarTruncateAddUInt(\n', '    uint256 _a,\n', '    uint256 _b,\n', '    uint256 _addend\n', ') pure returns (uint256) {\n', '    return mul_expScale(_a, _b) + _addend;\n', '}\n', '\n', 'function mul_expScale(uint256 _a, uint256 _b) pure returns (uint256) {\n', '    return (_a * _b) / 1e18;\n', '}\n', '\n', '// Compound Math Function\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {MCD_MANAGER} from "../../constants/CMaker.sol";\n', 'import {INSTA_MAPPING} from "../../constants/CInstaDapp.sol";\n', 'import {\n', '    ITokenJoinInterface\n', '} from "../../interfaces/dapps/Maker/ITokenJoinInterface.sol";\n', 'import {IMcdManager} from "../../interfaces/dapps/Maker/IMcdManager.sol";\n', 'import {InstaMapping} from "../../interfaces/InstaDapp/IInstaDapp.sol";\n', 'import {IVat} from "../../interfaces/dapps/Maker/IVat.sol";\n', 'import {RAY, add, sub, mul} from "../../vendor/DSMath.sol";\n', 'import {_stringToBytes32, _convertTo18} from "../../vendor/Convert.sol";\n', '\n', 'function _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '    IVat vat = IVat(manager.vat());\n', '    (, uint256 rate, , , ) = vat.ilks(ilk);\n', '    (, uint256 art) = vat.urns(ilk, urn);\n', '    uint256 dai = vat.dai(urn);\n', '\n', '    uint256 rad = sub(mul(art, rate), dai);\n', '    wad = rad / RAY;\n', '\n', '    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n', '}\n', '\n', 'function _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '    IVat vat = IVat(manager.vat());\n', '    (, uint256 rate, , , ) = vat.ilks(ilk);\n', '    (, uint256 art) = vat.urns(ilk, urn);\n', '\n', '    uint256 rad = mul(art, rate);\n', '\n', '    tab = rad / RAY;\n', '    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\n', '}\n', '\n', 'function _getMakerVaultCollateralBalance(uint256 _vaultId)\n', '    view\n', '    returns (uint256)\n', '{\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '\n', '    IVat vat = IVat(manager.vat());\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '    (uint256 ink, ) = vat.urns(ilk, urn);\n', '\n', '    return ink;\n', '}\n', '\n', 'function _vaultWillBeSafe(\n', '    uint256 _vaultId,\n', '    uint256 _colAmt,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    require(_vaultId != 0, "_vaultWillBeSafe: invalid vault id.");\n', '\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '\n', '    ITokenJoinInterface tokenJoinContract =\n', '        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\n', '\n', '    IVat vat = IVat(manager.vat());\n', '    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\n', '    (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n', '    uint256 dai = vat.dai(urn);\n', '\n', '    uint256 dink = _convertTo18(tokenJoinContract.dec(), _colAmt);\n', '    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n', '\n', '    ink = add(ink, dink);\n', '    art = add(art, dart);\n', '\n', '    uint256 tab = mul(rate, art);\n', '\n', '    return tab <= mul(ink, spot);\n', '}\n', '\n', 'function _newVaultWillBeSafe(\n', '    string memory _colType,\n', '    uint256 _colAmt,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '    IVat vat = IVat(manager.vat());\n', '\n', '    bytes32 ilk = _stringToBytes32(_colType);\n', '\n', '    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\n', '\n', '    ITokenJoinInterface tokenJoinContract =\n', '        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\n', '\n', '    uint256 ink = _convertTo18(tokenJoinContract.dec(), _colAmt);\n', '    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\n', '\n', '    uint256 tab = mul(rate, art);\n', '\n', '    return tab <= mul(ink, spot);\n', '}\n', '\n', 'function _debtCeilingIsReachedNewVault(\n', '    string memory _colType,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '    IVat vat = IVat(manager.vat());\n', '\n', '    bytes32 ilk = _stringToBytes32(_colType);\n', '\n', '    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\n', '    uint256 Line = vat.Line();\n', '    uint256 debt = vat.debt();\n', '\n', '    uint256 dart = _getDebtAmt(_daiDebtAmt, 0, rate);\n', '    uint256 dtab = mul(rate, dart);\n', '\n', '    debt = add(debt, dtab);\n', '    Art = add(Art, dart);\n', '\n', '    return mul(Art, rate) > line || debt > Line;\n', '}\n', '\n', 'function _debtCeilingIsReached(uint256 _vaultId, uint256 _daiDebtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '    IVat vat = IVat(manager.vat());\n', '\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '\n', '    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\n', '    uint256 dai = vat.dai(urn);\n', '    uint256 Line = vat.Line();\n', '    uint256 debt = vat.debt();\n', '\n', '    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n', '    uint256 dtab = mul(rate, dart);\n', '\n', '    debt = add(debt, dtab);\n', '    Art = add(Art, dart);\n', '\n', '    return mul(Art, rate) > line || debt > Line;\n', '}\n', '\n', 'function _debtIsDustNewVault(string memory _colType, uint256 _daiDebtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '    IVat vat = IVat(manager.vat());\n', '\n', '    bytes32 ilk = _stringToBytes32(_colType);\n', '\n', '    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\n', '    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\n', '\n', '    uint256 tab = mul(rate, art);\n', '\n', '    return tab < dust;\n', '}\n', '\n', 'function _debtIsDust(uint256 _vaultId, uint256 _daiDebtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    IMcdManager manager = IMcdManager(MCD_MANAGER);\n', '    IVat vat = IVat(manager.vat());\n', '\n', '    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n', '    (, uint256 art) = vat.urns(ilk, urn);\n', '    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\n', '\n', '    uint256 dai = vat.dai(urn);\n', '    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n', '    art = add(art, dart);\n', '    uint256 tab = mul(rate, art);\n', '\n', '    return tab < dust;\n', '}\n', '\n', 'function _getVaultData(IMcdManager _manager, uint256 _vault)\n', '    view\n', '    returns (bytes32 ilk, address urn)\n', '{\n', '    ilk = _manager.ilks(_vault);\n', '    urn = _manager.urns(_vault);\n', '}\n', '\n', 'function _getDebtAmt(\n', '    uint256 _amt,\n', '    uint256 _dai,\n', '    uint256 _rate\n', ') pure returns (uint256 dart) {\n', '    dart = sub(mul(_amt, RAY), _dai) / _rate;\n', '    dart = mul(dart, _rate) < mul(_amt, RAY) ? dart + 1 : dart;\n', '}\n', '\n', 'function _isVaultOwner(uint256 _vaultId, address _owner) view returns (bool) {\n', '    if (_vaultId == 0) return false;\n', '\n', '    try IMcdManager(MCD_MANAGER).owns(_vaultId) returns (address owner) {\n', '        return _owner == owner;\n', '    } catch Error(string memory error) {\n', '        revert(string(abi.encodePacked("FMaker._isVaultOwner:", error)));\n', '    } catch {\n', '        revert("FMaker._isVaultOwner:undefined");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {GELATO_GAS_PRICE_ORACLE} from "../../constants/CGelato.sol";\n', 'import {mul} from "../../vendor/DSMath.sol";\n', '\n', 'function _getGelatoGasPrice() view returns (uint256) {\n', '    int256 oracleGasPrice = GELATO_GAS_PRICE_ORACLE.latestAnswer();\n', '    if (oracleGasPrice <= 0) revert("_getGelatoGasPrice:0orBelow");\n', '    return uint256(oracleGasPrice);\n', '}\n', '\n', 'function _getGelatoExecutorFees(uint256 _gas) view returns (uint256) {\n', '    return mul(_gas, _getGelatoGasPrice());\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {wmul, wdiv} from "../../vendor/DSMath.sol";\n', 'import {\n', '    INSTA_POOL_RESOLVER,\n', '    ROUTE_1_TOLERANCE\n', '} from "../../constants/CInstaDapp.sol";\n', 'import {DebtBridgeInputData} from "../../structs/SDebtBridge.sol";\n', 'import {\n', '    _canDoMakerToAaveDebtBridge,\n', '    _canDoMakerToMakerDebtBridge,\n', '    _canDoMakerToCompoundDebtBridge\n', '} from "./conditions/FCanDoRefinance.sol";\n', 'import {\n', '    PROTOCOL,\n', '    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER,\n', '    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND,\n', '    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE,\n', '    FAST_TX_FEE,\n', '    VAULT_CREATION_COST\n', '} from "../../constants/CDebtBridge.sol";\n', 'import {\n', '    IInstaPoolResolver\n', '} from "../../interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol";\n', 'import {_getMakerVaultDebt, _debtCeilingIsReached} from "../dapps/FMaker.sol";\n', 'import {_isAaveUnderlyingLiquidV1} from "../dapps/FAave.sol";\n', 'import {_isCompoundUnderlyingLiquidity} from "../dapps/FCompound.sol";\n', 'import {_getGelatoExecutorFees} from "./FGelato.sol";\n', 'import {DAI, ETH} from "../../constants/CTokens.sol";\n', 'import {IOracleAggregator} from "../../interfaces/gelato/IOracleAggregator.sol";\n', 'import {_convertTo18} from "../../vendor/Convert.sol";\n', '\n', 'function _getFlashLoanRoute(\n', '    address _debtToken,\n', '    uint256 _vaultId,\n', '    uint256 _debtAmt\n', ') view returns (uint256) {\n', '    IInstaPoolResolver.RouteData memory rData =\n', '        IInstaPoolResolver(INSTA_POOL_RESOLVER).getTokenLimit(_debtToken);\n', '\n', '    if (rData.dydx > _debtAmt) return 0;\n', '\n', '    if (rData.maker > _debtAmt && !_debtCeilingIsReached(_vaultId, _debtAmt))\n', '        return 1;\n', '    if (\n', '        rData.compound > _debtAmt &&\n', '        _isCompoundUnderlyingLiquidity(_debtToken, _debtAmt)\n', '    ) return 2;\n', '    if (\n', '        rData.aave > _debtAmt && _isAaveUnderlyingLiquidV1(_debtToken, _debtAmt)\n', '    ) return 3;\n', '    revert("FGelatoDebtBridge._getFlashLoanRoute: illiquid");\n', '}\n', '\n', 'function _getDebtBridgeRoute(DebtBridgeInputData memory _data)\n', '    view\n', '    returns (PROTOCOL)\n', '{\n', '    if (_canDoMakerToAaveDebtBridge(_data)) return PROTOCOL.AAVE;\n', '    else if (_canDoMakerToMakerDebtBridge(_data)) return PROTOCOL.MAKER;\n', '    else if (_canDoMakerToCompoundDebtBridge(_data)) return PROTOCOL.COMPOUND;\n', '    return PROTOCOL.NONE;\n', '}\n', '\n', 'function _getGasCostMakerToMaker(bool _newVault, uint256 _route)\n', '    pure\n', '    returns (uint256)\n', '{\n', '    _checkRouteIndex(\n', '        _route,\n', '        "FGelatoDebtBridge._getGasCostMakerToMaker: invalid route index"\n', '    );\n', '    return\n', '        _getGasCostPremium(\n', '            _newVault\n', '                ? GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route] +\n', '                    VAULT_CREATION_COST\n', '                : GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route]\n', '        );\n', '}\n', '\n', 'function _getGasCostMakerToCompound(uint256 _route) pure returns (uint256) {\n', '    _checkRouteIndex(\n', '        _route,\n', '        "FGelatoDebtBridge._getGasCostMakerToCompound: invalid route index"\n', '    );\n', '    return\n', '        _getGasCostPremium(\n', '            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()[_route]\n', '        );\n', '}\n', '\n', 'function _getGasCostMakerToAave(uint256 _route) pure returns (uint256) {\n', '    _checkRouteIndex(\n', '        _route,\n', '        "FGelatoDebtBridge._getGasCostMakerToAave: invalid route index"\n', '    );\n', '    return\n', '        _getGasCostPremium(\n', '            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()[_route]\n', '        );\n', '}\n', '\n', 'function _getGasCostPremium(uint256 _rawGasCost) pure returns (uint256) {\n', '    return (_rawGasCost * (100 + FAST_TX_FEE)) / 100;\n', '}\n', '\n', 'function _getRealisedDebt(uint256 _debtToMove) pure returns (uint256) {\n', '    return wmul(_debtToMove, ROUTE_1_TOLERANCE);\n', '}\n', '\n', 'function _checkRouteIndex(uint256 _route, string memory _revertMsg) pure {\n', '    require(_route <= 4, _revertMsg);\n', '}\n', '\n', 'function _getMaxAmtToBorrowMakerToAave(\n', '    uint256 _fromVaultId,\n', '    uint256 _fees,\n', '    address _oracleAggregator\n', ') view returns (uint256) {\n', '    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\n', '\n', '    return\n', '        _getMaxAmtToBorrow(\n', '            wDaiToBorrow,\n', '            _getGasCostMakerToAave(\n', '                _getFlashLoanRoute(DAI, _fromVaultId, wDaiToBorrow)\n', '            ),\n', '            _fees,\n', '            _oracleAggregator\n', '        );\n', '}\n', '\n', 'function _getMaxAmtToBorrowMakerToCompound(\n', '    uint256 _fromVaultId,\n', '    uint256 _fees,\n', '    address _oracleAggregator\n', ') view returns (uint256) {\n', '    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\n', '\n', '    return\n', '        _getMaxAmtToBorrow(\n', '            wDaiToBorrow,\n', '            _getGasCostMakerToCompound(\n', '                _getFlashLoanRoute(DAI, _fromVaultId, wDaiToBorrow)\n', '            ),\n', '            _fees,\n', '            _oracleAggregator\n', '        );\n', '}\n', '\n', 'function _getMaxAmtToBorrowMakerToMaker(\n', '    uint256 _fromVaultId,\n', '    bool _newVault,\n', '    uint256 _fees,\n', '    address _oracleAggregator\n', ') view returns (uint256) {\n', '    uint256 wDaiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_fromVaultId));\n', '\n', '    return\n', '        _getMaxAmtToBorrow(\n', '            wDaiToBorrow,\n', '            _getGasCostMakerToMaker(\n', '                _newVault,\n', '                _getFlashLoanRoute(DAI, _fromVaultId, wDaiToBorrow)\n', '            ),\n', '            _fees,\n', '            _oracleAggregator\n', '        );\n', '}\n', '\n', 'function _getMaxAmtToBorrow(\n', '    uint256 _wDaiToBorrow,\n', '    uint256 _gasCost,\n', '    uint256 _fees,\n', '    address _oracleAggregator\n', ') view returns (uint256) {\n', '    (uint256 gasCostInDAI, uint256 decimals) =\n', '        IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n', '            _getGelatoExecutorFees(_gasCost),\n', '            ETH,\n', '            DAI\n', '        );\n', '\n', '    gasCostInDAI = _convertTo18(decimals, gasCostInDAI);\n', '\n', '    return _wDaiToBorrow + gasCostInDAI + wmul(_wDaiToBorrow, _fees);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {_isAaveLiquid} from "./aave/FAaveHasLiquidity.sol";\n', 'import {_aavePositionWillBeSafe} from "./aave/FAavePositionWillBeSafe.sol";\n', 'import {_isDebtAmtDust} from "./maker/FIsDebtAmtDust.sol";\n', 'import {_isDebtCeilingReached} from "./maker/FDebtCeilingIsReached.sol";\n', 'import {_destVaultWillBeSafe} from "./maker/FDestVaultWillBeSafe.sol";\n', 'import {_cTokenHasLiquidity} from "./compound/FCompoundHasLiquidity.sol";\n', 'import {\n', '    _compoundPositionWillBeSafe\n', '} from "./compound/FCompoundPositionWillBeSafe.sol";\n', 'import {DebtBridgeInputData} from "../../../structs/SDebtBridge.sol";\n', 'import {DAI} from "../../../constants/CTokens.sol";\n', 'import {\n', '    _getMaxAmtToBorrow,\n', '    _getGasCostMakerToAave,\n', '    _getGasCostMakerToCompound,\n', '    _getGasCostMakerToMaker\n', '} from "../FGelatoDebtBridge.sol";\n', '\n', 'function _canDoMakerToAaveDebtBridge(DebtBridgeInputData memory _data)\n', '    view\n', '    returns (bool)\n', '{\n', '    uint256 maxBorToAavePos =\n', '        _getMaxAmtToBorrow(\n', '            _data.debtAmt,\n', '            _getGasCostMakerToAave(_data.flashRoute),\n', '            _data.fees,\n', '            _data.oracleAggregator\n', '        );\n', '    return\n', '        _isAaveLiquid(DAI, maxBorToAavePos) &&\n', '        _aavePositionWillBeSafe(\n', '            _data.dsa,\n', '            _data.colAmt,\n', '            _data.colToken,\n', '            maxBorToAavePos,\n', '            _data.oracleAggregator\n', '        );\n', '}\n', '\n', 'function _canDoMakerToMakerDebtBridge(DebtBridgeInputData memory _data)\n', '    view\n', '    returns (bool)\n', '{\n', '    uint256 maxBorToMakerPos =\n', '        _getMaxAmtToBorrow(\n', '            _data.debtAmt,\n', '            _getGasCostMakerToMaker(\n', '                _data.makerDestVaultId == 0,\n', '                _data.flashRoute\n', '            ),\n', '            _data.fees,\n', '            _data.oracleAggregator\n', '        );\n', '    return\n', '        !_isDebtAmtDust(\n', '            _data.dsa,\n', '            _data.makerDestVaultId,\n', '            _data.makerDestColType,\n', '            maxBorToMakerPos\n', '        ) &&\n', '        !_isDebtCeilingReached(\n', '            _data.dsa,\n', '            _data.makerDestVaultId,\n', '            _data.makerDestColType,\n', '            maxBorToMakerPos\n', '        ) &&\n', '        _destVaultWillBeSafe(\n', '            _data.dsa,\n', '            _data.makerDestVaultId,\n', '            _data.makerDestColType,\n', '            _data.colAmt,\n', '            maxBorToMakerPos\n', '        );\n', '}\n', '\n', 'function _canDoMakerToCompoundDebtBridge(DebtBridgeInputData memory _data)\n', '    view\n', '    returns (bool)\n', '{\n', '    uint256 maxBorToCompPos =\n', '        _getMaxAmtToBorrow(\n', '            _data.debtAmt,\n', '            _getGasCostMakerToCompound(_data.flashRoute),\n', '            _data.fees,\n', '            _data.oracleAggregator\n', '        );\n', '\n', '    return\n', '        _cTokenHasLiquidity(\n', '            DAI,\n', '            _data.flashRoute == 2\n', '                ? _data.debtAmt + maxBorToCompPos\n', '                : maxBorToCompPos\n', '        ) &&\n', '        _compoundPositionWillBeSafe(\n', '            _data.dsa,\n', '            _data.colToken,\n', '            _data.colAmt,\n', '            DAI,\n', '            maxBorToCompPos\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {_isAaveUnderlyingLiquid} from "../../../dapps/FAave.sol";\n', '\n', 'function _isAaveLiquid(address _debtToken, uint256 _debtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    return _isAaveUnderlyingLiquid(_debtToken, _debtAmt);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    _getUserData,\n', '    _getAssetLiquidationThreshold\n', '} from "../../../../functions/dapps/FAave.sol";\n', 'import {AaveUserData} from "../../../../structs/SAave.sol";\n', 'import {GelatoBytes} from "../../../../lib/GelatoBytes.sol";\n', 'import {wdiv, wmul, mul} from "../../../../vendor/DSMath.sol";\n', 'import {\n', '    IOracleAggregator\n', '} from "../../../../interfaces/gelato/IOracleAggregator.sol";\n', 'import {ETH, DAI} from "../../../../constants/CTokens.sol";\n', 'import {_convertTo18} from "../../../../vendor/Convert.sol";\n', '\n', 'function _aavePositionWillBeSafe(\n', '    address _dsa,\n', '    uint256 _colAmt,\n', '    address _colToken,\n', '    uint256 _debtAmt,\n', '    address _oracleAggregator\n', ') view returns (bool) {\n', '    uint256 _colAmtInETH;\n', '    uint256 _decimals;\n', '    IOracleAggregator oracleAggregator = IOracleAggregator(_oracleAggregator);\n', '\n', '    AaveUserData memory userData = _getUserData(_dsa);\n', '\n', '    if (_colToken == ETH) _colAmtInETH = _colAmt;\n', '    else {\n', '        (_colAmtInETH, _decimals) = oracleAggregator.getExpectedReturnAmount(\n', '            _colAmt,\n', '            _colToken,\n', '            ETH\n', '        );\n', '\n', '        _colAmtInETH = _convertTo18(_decimals, _colAmtInETH);\n', '    }\n', '\n', '    (_debtAmt, _decimals) = oracleAggregator.getExpectedReturnAmount(\n', '        _debtAmt,\n', '        DAI,\n', '        ETH\n', '    );\n', '    _debtAmt = _convertTo18(_decimals, _debtAmt);\n', '\n', '    //\n', '    //                  __\n', '    //                  \\\n', '    //                  /__ (Collateral)i in ETH x (Liquidation Threshold)i\n', '    //  HealthFactor =  _________________________________________________\n', '    //\n', '    //                  Total Borrows in ETH + Total Fees in ETH\n', '    //\n', '\n', '    return\n', '        wdiv(\n', '            (\n', '                (mul(\n', '                    userData.currentLiquidationThreshold,\n', '                    userData.totalCollateralETH\n', '                ) + mul(_colAmtInETH, _getAssetLiquidationThreshold(_colToken)))\n', '            ) / 1e4,\n', '            userData.totalBorrowsETH + _debtAmt\n', '        ) > 1e18;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {_isCompoundUnderlyingLiquidity} from "../../../dapps/FCompound.sol";\n', '\n', 'function _cTokenHasLiquidity(address _debtToken, uint256 _debtAmt)\n', '    view\n', '    returns (bool)\n', '{\n', '    return _isCompoundUnderlyingLiquidity(_debtToken, _debtAmt);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {DAI} from "../../../../constants/CTokens.sol";\n', 'import {\n', '    _getCToken,\n', '    _wouldCompoundAccountBeLiquid\n', '} from "../../../dapps/FCompound.sol";\n', '\n', 'function _compoundPositionWillBeSafe(\n', '    address _dsa,\n', '    address _colToken,\n', '    uint256 _colAmt,\n', '    address _debtToken,\n', '    uint256 _debtAmt\n', ') view returns (bool) {\n', '    return\n', '        _wouldCompoundAccountBeLiquid(\n', '            _dsa,\n', '            _getCToken(_colToken),\n', '            _colAmt,\n', '            _getCToken(_debtToken),\n', '            _debtAmt\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    _debtCeilingIsReachedNewVault,\n', '    _debtCeilingIsReached,\n', '    _isVaultOwner\n', '} from "../../../../functions/dapps/FMaker.sol";\n', '\n', 'function _isDebtCeilingReached(\n', '    address _dsa,\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n', '\n', '    return\n', '        _debtCeilingIsReachedExplicit(_destVaultId, _destColType, _daiDebtAmt);\n', '}\n', '\n', 'function _debtCeilingIsReachedExplicit(\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    return\n', '        _destVaultId == 0\n', '            ? _debtCeilingIsReachedNewVault(_destColType, _daiDebtAmt)\n', '            : _debtCeilingIsReached(_destVaultId, _daiDebtAmt);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    _vaultWillBeSafe,\n', '    _newVaultWillBeSafe,\n', '    _isVaultOwner\n', '} from "../../../../functions/dapps/FMaker.sol";\n', '\n', 'function _destVaultWillBeSafe(\n', '    address _dsa,\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _colAmt,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n', '\n', '    return\n', '        _destVaultWillBeSafeExplicit(\n', '            _destVaultId,\n', '            _destColType,\n', '            _colAmt,\n', '            _daiDebtAmt\n', '        );\n', '}\n', '\n', 'function _destVaultWillBeSafeExplicit(\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _colAmt,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    return\n', '        _destVaultId == 0\n', '            ? _newVaultWillBeSafe(_destColType, _colAmt, _daiDebtAmt)\n', '            : _vaultWillBeSafe(_destVaultId, _colAmt, _daiDebtAmt);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {\n', '    _debtIsDustNewVault,\n', '    _debtIsDust,\n', '    _isVaultOwner\n', '} from "../../../../functions/dapps/FMaker.sol";\n', '\n', 'function _isDebtAmtDust(\n', '    address _dsa,\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n', '\n', '    return _isDebtAmtDustExplicit(_destVaultId, _destColType, _daiDebtAmt);\n', '}\n', '\n', 'function _isDebtAmtDustExplicit(\n', '    uint256 _destVaultId,\n', '    string memory _destColType,\n', '    uint256 _daiDebtAmt\n', ') view returns (bool) {\n', '    return\n', '        _destVaultId == 0\n', '            ? _debtIsDustNewVault(_destColType, _daiDebtAmt)\n', '            : _debtIsDust(_destVaultId, _daiDebtAmt);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', '/// @notice Interface InstaDapp Index\n', 'interface IndexInterface {\n', '    function connectors(uint256 version) external view returns (address);\n', '\n', '    function list() external view returns (address);\n', '}\n', '\n', '/// @notice Interface InstaDapp List\n', 'interface ListInterface {\n', '    function accountID(address _account) external view returns (uint64);\n', '}\n', '\n', '/// @notice Interface InstaDapp InstaMemory\n', 'interface MemoryInterface {\n', '    function setUint(uint256 _id, uint256 _val) external;\n', '\n', '    function getUint(uint256 _id) external returns (uint256);\n', '}\n', '\n', '/// @notice Interface InstaDapp Defi Smart Account wallet\n', 'interface AccountInterface {\n', '    function cast(\n', '        address[] calldata _targets,\n', '        bytes[] calldata _datas,\n', '        address _origin\n', '    ) external payable returns (bytes32[] memory responses);\n', '\n', '    function version() external view returns (uint256);\n', '\n', '    function isAuth(address user) external view returns (bool);\n', '\n', '    function shield() external view returns (bool);\n', '}\n', '\n', 'interface ConnectorInterface {\n', '    function connectorID() external view returns (uint256 _type, uint256 _id);\n', '\n', '    function name() external view returns (string memory);\n', '}\n', '\n', 'interface InstaMapping {\n', '    function gemJoinMapping(bytes32) external view returns (address);\n', '\n', '    function cTokenMapping(address) external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IInstaFeeCollector {\n', '    function setFeeCollector(address payable _feeCollector) external;\n', '\n', '    function setFee(uint256 _fee) external;\n', '\n', '    function fee() external view returns (uint256);\n', '\n', '    function feeCollector() external view returns (address payable);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IConnectBasic {\n', '    function withdraw(\n', '        address _erc20,\n', '        uint256 _tokenAmt,\n', '        address payable _to,\n', '        uint256 _getId,\n', '        uint256 _setId\n', '    ) external payable;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IConnectCompound {\n', '    function borrow(\n', '        address token,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '\n', '    function deposit(\n', '        address token,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IConnectDebtBridgeFee {\n', '    function calculateFee(\n', '        uint256 _amount,\n', '        uint256 _ftf,\n', '        uint256 _fee,\n', '        uint256 _getId,\n', '        uint256 _setId,\n', '        uint256 _setIdFee\n', '    ) external payable;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IConnectInstaPoolV2 {\n', '    function flashBorrowAndCast(\n', '        address token,\n', '        uint256 amt,\n', '        uint256 route,\n', '        bytes memory data\n', '    ) external payable;\n', '\n', '    function flashPayback(\n', '        address token,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IConnectMaker {\n', '    function payback(\n', '        uint256 vault,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '\n', '    function borrow(\n', '        uint256 vault,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '\n', '    function open(string calldata colType)\n', '        external\n', '        payable\n', '        returns (uint256 vault);\n', '\n', '    function withdraw(\n', '        uint256 vault,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '\n', '    function deposit(\n', '        uint256 vault,\n', '        uint256 amt,\n', '        uint256 getId,\n', '        uint256 setId\n', '    ) external payable;\n', '}\n', '\n', '// "SPDX-License-Identifier: UNLICENSED"\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IInstaPoolResolver {\n', '    struct RouteData {\n', '        uint256 dydx;\n', '        uint256 maker;\n', '        uint256 compound;\n', '        uint256 aave;\n', '    }\n', '\n', '    function getTokenLimit(address token)\n', '        external\n', '        view\n', '        returns (RouteData memory);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface ChainLinkInterface {\n', '    function latestAnswer() external view returns (int256);\n', '\n', '    function decimals() external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IAaveProtocolDataProvider {\n', '    function getUserReserveData(address asset, address user)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 currentATokenBalance,\n', '            uint256 currentStableDebt,\n', '            uint256 currentVariableDebt,\n', '            uint256 principalStableDebt,\n', '            uint256 scaledVariableDebt,\n', '            uint256 stableBorrowRate,\n', '            uint256 liquidityRate,\n', '            uint40 stableRateLastUpdated,\n', '            bool usageAsCollateralEnabled\n', '        );\n', '\n', '    function getReserveConfigurationData(address asset)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 decimals,\n', '            uint256 ltv,\n', '            uint256 liquidationThreshold,\n', '            uint256 liquidationBonus,\n', '            uint256 reserveFactor,\n', '            bool usageAsCollateralEnabled,\n', '            bool borrowingEnabled,\n', '            bool stableBorrowRateEnabled,\n', '            bool isActive,\n', '            bool isFrozen\n', '        );\n', '\n', '    function getReserveData(address asset)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 availableLiquidity,\n', '            uint256 totalStableDebt,\n', '            uint256 totalVariableDebt,\n', '            uint256 liquidityRate,\n', '            uint256 variableBorrowRate,\n', '            uint256 stableBorrowRate,\n', '            uint256 averageStableBorrowRate,\n', '            uint256 liquidityIndex,\n', '            uint256 variableBorrowIndex,\n', '            uint40 lastUpdateTimestamp\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {ReserveData} from "../../../structs/SAave.sol";\n', '\n', 'interface ILendingPool {\n', '    function getReserveData(address asset)\n', '        external\n', '        view\n', '        returns (ReserveData memory);\n', '\n', '    function getUserAccountData(address user)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 totalCollateralETH,\n', '            uint256 totalDebtETH,\n', '            uint256 availableBorrowsETH,\n', '            uint256 currentLiquidationThreshold,\n', '            uint256 ltv,\n', '            uint256 healthFactor\n', '        );\n', '\n', '    function getReservesList() external view returns (address[] memory);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface ILendingPoolAddressesProvider {\n', '    function getLendingPool() external view returns (address);\n', '\n', '    function getPriceOracle() external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface ICToken {\n', '    function getAccountSnapshot(address account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function getCash() external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {ICToken} from "./ICToken.sol";\n', '\n', 'interface IComptroller {\n', '    function getAssetsIn(address account)\n', '        external\n', '        view\n', '        returns (ICToken[] memory);\n', '\n', '    function oracle() external view returns (address);\n', '\n', '    function markets(address cToken)\n', '        external\n', '        view\n', '        returns (\n', '            bool isListed,\n', '            uint256 collateralFactorMantissa,\n', '            bool isComped\n', '        );\n', '\n', '    function getAccountLiquidity(address account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {ICToken} from "./ICToken.sol";\n', '\n', 'interface IPriceOracle {\n', '    function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IMcdManager {\n', '    function ilks(uint256) external view returns (bytes32);\n', '\n', '    function urns(uint256) external view returns (address);\n', '\n', '    function vat() external view returns (address);\n', '\n', '    function owns(uint256) external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface ITokenJoinInterface {\n', '    function dec() external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IVat {\n', '    function ilks(bytes32)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function dai(address) external view returns (uint256);\n', '\n', '    function urns(bytes32, address) external view returns (uint256, uint256);\n', '\n', '    function debt() external view returns (uint256);\n', '\n', '    // solhint-disable-next-line\n', '    function Line() external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IGelatoGasPriceOracle {\n', '    function latestAnswer() external view returns (int256);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IOracleAggregator {\n', '    function getExpectedReturnAmount(\n', '        uint256 amountIn,\n', '        address inToken,\n', '        address outToken\n', '    ) external view returns (uint256 returnAmount, uint256 outTokenDecimals);\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'library GelatoBytes {\n', '    function calldataSliceSelector(bytes calldata _bytes)\n', '        internal\n', '        pure\n', '        returns (bytes4 selector)\n', '    {\n', '        selector =\n', '            _bytes[0] |\n', '            (bytes4(_bytes[1]) >> 8) |\n', '            (bytes4(_bytes[2]) >> 16) |\n', '            (bytes4(_bytes[3]) >> 24);\n', '    }\n', '\n', '    function memorySliceSelector(bytes memory _bytes)\n', '        internal\n', '        pure\n', '        returns (bytes4 selector)\n', '    {\n', '        selector =\n', '            _bytes[0] |\n', '            (bytes4(_bytes[1]) >> 8) |\n', '            (bytes4(_bytes[2]) >> 16) |\n', '            (bytes4(_bytes[3]) >> 24);\n', '    }\n', '\n', '    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\n', '        internal\n', '        pure\n', '    {\n', '        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n', '        if (_bytes.length % 32 == 4) {\n', '            bytes4 selector;\n', '            assembly {\n', '                selector := mload(add(0x20, _bytes))\n', '            }\n', '            if (selector == 0x08c379a0) {\n', '                // Function selector for Error(string)\n', '                assembly {\n', '                    _bytes := add(_bytes, 68)\n', '                }\n', '                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n', '            } else {\n', '                revert(\n', '                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"))\n', '                );\n', '            }\n', '        } else {\n', '            revert(\n', '                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"))\n', '            );\n', '        }\n', '    }\n', '\n', '    function returnError(bytes memory _bytes, string memory _tracingInfo)\n', '        internal\n', '        pure\n', '        returns (string memory)\n', '    {\n', '        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n', '        if (_bytes.length % 32 == 4) {\n', '            bytes4 selector;\n', '            assembly {\n', '                selector := mload(add(0x20, _bytes))\n', '            }\n', '            if (selector == 0x08c379a0) {\n', '                // Function selector for Error(string)\n', '                assembly {\n', '                    _bytes := add(_bytes, 68)\n', '                }\n', '                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\n', '            } else {\n', '                return\n', '                    string(abi.encodePacked(_tracingInfo, "NoErrorSelector"));\n', '            }\n', '        } else {\n', '            return\n', '                string(abi.encodePacked(_tracingInfo, "UnexpectedReturndata"));\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', '// ////////// LendingPool /////////////////\n', 'struct AaveUserData {\n', '    uint256 totalCollateralETH;\n', '    uint256 totalBorrowsETH;\n', '    uint256 availableBorrowsETH;\n', '    uint256 currentLiquidationThreshold;\n', '    uint256 ltv;\n', '    uint256 healthFactor;\n', '    uint256 ethPriceInUsd;\n', '}\n', '\n', 'struct ReserveConfigurationMap {\n', '    uint256 data;\n', '}\n', '\n', 'struct ReserveData {\n', '    //stores the reserve configuration\n', '    ReserveConfigurationMap configuration;\n', '    //the liquidity index. Expressed in ray\n', '    uint128 liquidityIndex;\n', '    //variable borrow index. Expressed in ray\n', '    uint128 variableBorrowIndex;\n', '    //the current supply rate. Expressed in ray\n', '    uint128 currentLiquidityRate;\n', '    //the current variable borrow rate. Expressed in ray\n', '    uint128 currentVariableBorrowRate;\n', '    //the current stable borrow rate. Expressed in ray\n', '    uint128 currentStableBorrowRate;\n', '    uint40 lastUpdateTimestamp;\n', '    //tokens addresses\n', '    address aTokenAddress;\n', '    address stableDebtTokenAddress;\n', '    address variableDebtTokenAddress;\n', '    //address of the interest rate strategy\n', '    address interestRateStrategyAddress;\n', '    //the id of the reserve. Represents the position in the list of the active reserves\n', '    uint8 id;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'struct DebtBridgeInputData {\n', '    address dsa;\n', '    uint256 colAmt;\n', '    address colToken;\n', '    uint256 debtAmt;\n', '    address oracleAggregator;\n', '    uint256 makerDestVaultId;\n', '    string makerDestColType;\n', '    uint256 fees;\n', '    uint256 flashRoute;\n', '}\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.8.0;\n', '\n', 'import {mul as _mul} from "./DSMath.sol";\n', '\n', 'function _stringToBytes32(string memory str) pure returns (bytes32 result) {\n', '    require(bytes(str).length != 0, "string-empty");\n', '    assembly {\n', '        result := mload(add(str, 32))\n', '    }\n', '}\n', '\n', 'function _convertTo18(uint256 _dec, uint256 _amt) pure returns (uint256 amt) {\n', '    amt = _mul(_amt, 10**(18 - _dec));\n', '}\n', '\n', '// "SPDX-License-Identifier: AGPL-3.0-or-later"\n', '/// math.sol -- mixin for inline numerical wizardry\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'function add(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    require((z = x + y) >= x, "ds-math-add-overflow");\n', '}\n', '\n', 'function sub(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    require((z = x - y) <= x, "ds-math-sub-underflow");\n', '}\n', '\n', 'function mul(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '}\n', '\n', 'function min(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    return x <= y ? x : y;\n', '}\n', '\n', 'function max(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    return x >= y ? x : y;\n', '}\n', '\n', 'function imin(int256 x, int256 y) pure returns (int256 z) {\n', '    return x <= y ? x : y;\n', '}\n', '\n', 'function imax(int256 x, int256 y) pure returns (int256 z) {\n', '    return x >= y ? x : y;\n', '}\n', '\n', 'uint256 constant WAD = 10**18;\n', 'uint256 constant RAY = 10**27;\n', '\n', '//rounds to zero if x*y < WAD / 2\n', 'function wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    z = add(mul(x, y), WAD / 2) / WAD;\n', '}\n', '\n', '//rounds to zero if x*y < WAD / 2\n', 'function rmul(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    z = add(mul(x, y), RAY / 2) / RAY;\n', '}\n', '\n', '//rounds to zero if x*y < WAD / 2\n', 'function wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    z = add(mul(x, WAD), y / 2) / y;\n', '}\n', '\n', '//rounds to zero if x*y < RAY / 2\n', 'function rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n', '    z = add(mul(x, RAY), y / 2) / y;\n', '}\n', '\n', '// This famous algorithm is called "exponentiation by squaring"\n', '// and calculates x^n with x as fixed-point and n as regular unsigned.\n', '//\n', "// It's O(log n), instead of O(n) for naive repeated multiplication.\n", '//\n', '// These facts are why it works:\n', '//\n', '//  If n is even, then x^n = (x^2)^(n/2).\n', '//  If n is odd,  then x^n = x * x^(n-1),\n', '//   and applying the equation for even x gives\n', '//    x^n = x * (x^2)^((n-1) / 2).\n', '//\n', '//  Also, EVM division is flooring and\n', '//    floor[(n-1) / 2] = floor[n / 2].\n', '//\n', 'function rpow(uint256 x, uint256 n) pure returns (uint256 z) {\n', '    z = n % 2 != 0 ? x : RAY;\n', '\n', '    for (n /= 2; n != 0; n /= 2) {\n', '        x = rmul(x, x);\n', '\n', '        if (n % 2 != 0) {\n', '            z = rmul(z, x);\n', '        }\n', '    }\n', '}']