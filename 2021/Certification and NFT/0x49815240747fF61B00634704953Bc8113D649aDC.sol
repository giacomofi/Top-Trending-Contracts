['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./IO.sol";\n', 'import "./Storage.sol";\n', 'import "./Constants.sol";\n', '\n', 'import "./ABDKMath64x64.sol";\n', '\n', 'import "./ERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'contract Logic is Storage, Constants, IO {\n', '    using SafeERC20 for ERC20;\n', '    using SafeMath for uint256;\n', '\n', '    using ABDKMath64x64 for int128;\n', '    using ABDKMath64x64 for uint256;\n', '\n', '    // **** Events **** //\n', '    event ModuleApproved(address indexed module);\n', '    event ModuleRevoked(address indexed module);\n', '\n', '    // **** Modifiers **** //\n', '\n', '    modifier authorized(bytes32 role) {\n', '        require(hasRole(role, msg.sender), "!authorized");\n', '        _;\n', '    }\n', '\n', '    modifier authorized2(bytes32 role1, bytes32 role2) {\n', '        require(hasRole(role1, msg.sender) || hasRole(role2, msg.sender), "!authorized");\n', '        _;\n', '    }\n', '\n', '    // **** Initializers **** //\n', '\n', '    /// @notice Initializes the Basket\n', '    function initialize() public {\n', '        require(_readSlot(INITIALIZED) == 0, "initialized");\n', '\n', '        _setRoleAdmin(MARKET_MAKER, GOVERNANCE_ADMIN);\n', '\n', '        // Delayed Minter\n', '        _setupRole(MARKET_MAKER, 0x861cbEb7B0ea0D7ecC8d0103F78834bb4fe35097);\n', '\n', '        // Delayed Burner\n', '        _setupRole(MARKET_MAKER, 0xA4af5075C65ad3fEF0DEA860902A146CB67a4930);\n', '\n', '        // Priviledged Arb Contract\n', '        _setupRole(MARKET_MAKER, 0xa79dbBDe870E4802e865408fe59f0fFa222601A8);\n', '\n', '        __ERC20_update("BasketDAO DeFi Index", "BDI");\n', '\n', "        // Make sure we can't initialize again\n", '        _writeSlot(INITIALIZED, bytes32(uint256(1)));\n', '    }\n', '\n', '    // **** Getters **** //\n', '\n', '    /// @notice Gets the assets and their balances within the basket\n', '    /// @return (the addresses of the assets,\n', '    ///          the amount held by the basket of each asset)\n', '    function getAssetsAndBalances() public view returns (address[] memory, uint256[] memory) {\n', '        uint256[] memory assetBalances = new uint256[](assets.length);\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            assetBalances[i] = ERC20(assets[i]).balanceOf(address(this));\n', '        }\n', '\n', '        return (assets, assetBalances);\n', '    }\n', '\n', '    /// @notice Gets the amount of assets backing each Basket token\n', '    /// @return (the addresses of the assets,\n', '    ///          the amount of backing 1 Basket token)\n', '    function getOne() public view returns (address[] memory, uint256[] memory) {\n', '        uint256[] memory amounts = new uint256[](assets.length);\n', '\n', '        uint256 supply = totalSupply();\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            amounts[i] = ERC20(assets[i]).balanceOf(address(this)).mul(1e18).div(supply);\n', '        }\n', '\n', '        return (assets, amounts);\n', '    }\n', '\n', '    /// @notice Gets the fees and the fee recipient\n', '    /// @return (mint fee, burn fee, recipient)\n', '    function getFees()\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            address\n', '        )\n', '    {\n', '        return (_readSlotUint256(MINT_FEE), _readSlotUint256(BURN_FEE), _readSlotAddress(FEE_RECIPIENT));\n', '    }\n', '\n', '    // **** Admin functions **** //\n', '\n', '    /// @notice Pauses minting in case of emergency\n', '    function pause() public authorized2(GOVERNANCE, TIMELOCK) {\n', '        _pause();\n', '    }\n', '\n', '    /// @notice Unpauses burning in case of emergency\n', '    function unpause() public authorized2(GOVERNANCE, TIMELOCK) {\n', '        _unpause();\n', '    }\n', '\n', '    /// @notice Sets the mint/burn fee and fee recipient\n', '    function setFee(\n', '        uint256 _mintFee,\n', '        uint256 _burnFee,\n', '        address _recipient\n', '    ) public authorized(TIMELOCK) {\n', '        require(_mintFee < FEE_DIVISOR, "invalid-mint-fee");\n', '        require(_burnFee < FEE_DIVISOR, "invalid-burn-fee");\n', '        require(_recipient != address(0), "invalid-fee-recipient");\n', '\n', '        _writeSlot(MINT_FEE, _mintFee);\n', '        _writeSlot(BURN_FEE, _burnFee);\n', '        _writeSlot(FEE_RECIPIENT, _recipient);\n', '    }\n', '\n', '    /// @notice Sets the list of assets backing the basket\n', '    function setAssets(address[] memory _assets) public authorized(TIMELOCK) whenNotPaused {\n', '        assets = _assets;\n', '    }\n', '\n', "    /// @notice Rescues ERC20 stuck in the contract (can't be on the list of assets)\n", '    function rescueERC20(address _asset, uint256 _amount) public authorized2(MARKET_MAKER, GOVERNANCE) {\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            require(_asset != assets[i], "!rescue asset");\n', '        }\n', '        ERC20(_asset).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    /// @notice Approves a module.\n', '    /// @param _module Logic module to approve\n', '    function approveModule(address _module) public authorized(TIMELOCK) {\n', '        approvedModules[_module] = true;\n', '\n', '        emit ModuleApproved(_module);\n', '    }\n', '\n', '    /// @notice Revokes a module.\n', '    /// @param _module Logic module to approve\n', '    function revokeModule(address _module) public authorized2(TIMELOCK, GOVERNANCE) {\n', '        approvedModules[_module] = false;\n', '\n', '        emit ModuleRevoked(_module);\n', '    }\n', '\n', '    /// @notice Executes arbitrary logic on approved modules. Mostly used for rebalancing.\n', '    /// @param  _module  Logic code to assume\n', '    /// @param  _data  Payload\n', '    function execute(address _module, bytes memory _data)\n', '        public\n', '        payable\n', '        authorized2(GOVERNANCE, TIMELOCK)\n', '        returns (bytes memory response)\n', '    {\n', '        require(approvedModules[_module], "!module-approved");\n', '\n', '        // call contract in current context\n', '        assembly {\n', '            let succeeded := delegatecall(sub(gas(), 5000), _module, add(_data, 0x20), mload(_data), 0, 0)\n', '            let size := returndatasize()\n', '\n', '            response := mload(0x40)\n', '            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n', '            mstore(response, size)\n', '            returndatacopy(add(response, 0x20), 0, size)\n', '\n', '            switch iszero(succeeded)\n', '                case 1 {\n', '                    // throw if delegatecall failed\n', '                    revert(add(response, 0x20), size)\n', '                }\n', '        }\n', '    }\n', '\n', '    // **** Mint/Burn functionality **** //\n', '\n', '    /// @notice Mints a new Basket token\n', '    /// @param  _amountOut  Amount of Basket tokens to mint\n', '    function mint(uint256 _amountOut) public whenNotPaused nonReentrant {\n', '        require(totalSupply() > 0, "!migrated");\n', '\n', '        uint256[] memory _amountsToTransfer = viewMint(_amountOut);\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            ERC20(assets[i]).safeTransferFrom(msg.sender, address(this), _amountsToTransfer[i]);\n', '        }\n', '\n', '        // If user is a market maker then just mint the tokens\n', '        if (hasRole(MARKET_MAKER, msg.sender)) {\n', '            _mint(msg.sender, _amountOut);\n', '            return;\n', '        }\n', '\n', '        // Otherwise charge a fee\n', '        uint256 fee = _amountOut.mul(_readSlotUint256(MINT_FEE)).div(FEE_DIVISOR);\n', '        address feeRecipient = _readSlotAddress(FEE_RECIPIENT);\n', '\n', '        _mint(feeRecipient, fee);\n', '        _mint(msg.sender, _amountOut.sub(fee));\n', '    }\n', '\n', '    /// @notice Previews the corresponding assets and amount required to mint `_amountOut` Basket tokens\n', '    /// @param  _amountOut  Amount of Basket tokens to mint\n', '    function viewMint(uint256 _amountOut) public view returns (uint256[] memory _amountsIn) {\n', '        uint256 totalLp = totalSupply();\n', '\n', '        _amountsIn = new uint256[](assets.length);\n', '\n', '        // Precise math\n', '        int128 amountOut128 = _amountOut.divu(1e18).add(uint256(1).divu(1e18));\n', '        int128 totalLp128 = totalLp.divu(1e18).add(uint256(1).divu(1e18));\n', '        int128 ratio128 = amountOut128.div(totalLp128);\n', '\n', '        uint256 _amountToTransfer;\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            _amountToTransfer = ratio128.mulu(ERC20(assets[i]).balanceOf(address(this)));\n', '            _amountsIn[i] = _amountToTransfer;\n', '        }\n', '    }\n', '\n', '    /// @notice Burns the basket token and retrieves\n', '    /// @param  _amount  Amount of Basket tokens to burn\n', '    function burn(uint256 _amount) public whenNotPaused nonReentrant {\n', '        uint256 totalLp = totalSupply();\n', '\n', '        require(totalLp > 0, "!initialMint");\n', '        require(_amount >= 1e6, "!min-burn-1e6");\n', '\n', '        // Precise math library\n', '        int128 ratio128;\n', '        int128 totalLp128 = totalLp.divu(1e18).add(uint256(1).divu(1e18));\n', '        int128 amount128;\n', '\n', '        uint256 amountOut;\n', '\n', '        // If user is a market maker then no fee\n', '        if (hasRole(MARKET_MAKER, msg.sender)) {\n', '            amount128 = _amount.divu(1e18).add(uint256(1).divu(1e18));\n', '            ratio128 = amount128.div(totalLp128);\n', '\n', '            _burn(msg.sender, _amount);\n', '        } else {\n', '            // Otherwise calculate fee\n', '            address feeRecipient = _readSlotAddress(FEE_RECIPIENT);\n', '            uint256 fee = _amount.mul(_readSlotUint256(BURN_FEE)).div(FEE_DIVISOR);\n', '\n', '            amount128 = _amount.sub(fee).divu(1e18).add(uint256(1).divu(1e18));\n', '            ratio128 = amount128.div(totalLp128);\n', '\n', '            _burn(msg.sender, _amount.sub(fee));\n', '            _transfer(msg.sender, feeRecipient, fee);\n', '        }\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            amountOut = ratio128.mulu(ERC20(assets[i]).balanceOf(address(this)));\n', '            ERC20(assets[i]).safeTransfer(msg.sender, amountOut);\n', '        }\n', '    }\n', '}']