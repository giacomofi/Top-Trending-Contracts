['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// SPDX-License-Identifier: CC-BY-NC-SA-2.5\n', '//@code0x2\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IFeeManager {\n', '    function queryFee(address sender, address receiver, uint256 amount) external returns(address, uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external;\n', '    function transferFrom(address sender, address recipient, uint256 amount) external;\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IERC20Standard {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract Operator is Context, Ownable {\n', '    address private _operator;\n', '    mapping (address => bool) private privileged;\n', '\n', '    event OperatorTransferred(\n', '        address indexed previousOperator,\n', '        address indexed newOperator\n', '    );\n', '\n', '    constructor() internal {\n', '        _operator = _msgSender();\n', '        emit OperatorTransferred(address(0), _operator);\n', '    }\n', '\n', '    function operator() public view returns (address) {\n', '        return _operator;\n', '    }\n', '\n', '    function setPrivileged(address _usr, bool _isPrivileged) public onlyOwner {\n', '        privileged[_usr] = _isPrivileged;\n', '    }\n', '\n', '    modifier onlyOperator() {\n', "        require(msg.sender == _operator || privileged[msg.sender] == true, 'operator: caller does not have permission');\n", '        _;\n', '    }\n', '\n', '    function isOperator() public view returns (bool) {\n', '        return _msgSender() == _operator;\n', '    }\n', '\n', '    function transferOperator(address newOperator_) public onlyOwner {\n', '        _transferOperator(newOperator_);\n', '    }\n', '\n', '    function _transferOperator(address newOperator_) internal {\n', '        require(\n', '            newOperator_ != address(0),\n', "            'operator: zero address given for new operator'\n", '        );\n', '        emit OperatorTransferred(address(0), newOperator_);\n', '        _operator = newOperator_;\n', '    }\n', '}\n', '\n', 'contract Epoch is Operator {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private period;\n', '    uint256 private startTime;\n', '    uint256 private epoch;\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    constructor(\n', '        uint256 _period,\n', '        uint256 _startTime,\n', '        uint256 _startEpoch\n', '    ) public {\n', '        period = _period;\n', '        startTime = _startTime;\n', '        epoch = _startEpoch;\n', '    }\n', '\n', '    /* ========== Modifier ========== */\n', '\n', '    modifier checkStartTime {\n', "        require(now >= startTime, 'Epoch: not started yet');\n", '\n', '        _;\n', '    }\n', '\n', '    modifier checkEpoch {\n', "        require(now >= nextEpochPoint(), 'Epoch: not allowed');\n", '\n', '        _;\n', '\n', '        epoch = epoch.add(1);\n', '    }\n', '\n', '    /* ========== VIEW FUNCTIONS ========== */\n', '\n', '    function getCurrentEpoch() public view returns (uint256) {\n', '        return epoch;\n', '    }\n', '\n', '    function getPeriod() public view returns (uint256) {\n', '        return period;\n', '    }\n', '\n', '    function getStartTime() public view returns (uint256) {\n', '        return startTime;\n', '    }\n', '\n', '    function nextEpochPoint() public view returns (uint256) {\n', '        return startTime.add(epoch.mul(period));\n', '    }\n', '\n', '    /* ========== GOVERNANCE ========== */\n', '\n', '    function setPeriod(uint256 _period) external onlyOperator {\n', '        period = _period;\n', '    }\n', '\n', '    /* ========== DEPLOYEMENT ========= */\n', '    function setStarttime(uint256 _starttime) public onlyOwner {\n', '        require(startTime > now, "already start");\n', '        require(_starttime > now, "invalid param");\n', '        startTime = _starttime;\n', '    }\n', '}\n', '\n', 'contract ContractGuard {\n', '    mapping(uint256 => mapping(address => bool)) private _status;\n', '\n', '    function checkSameOriginReentranted() internal view returns (bool) {\n', '        return _status[block.number][tx.origin];\n', '    }\n', '\n', '    function checkSameSenderReentranted() internal view returns (bool) {\n', '        return _status[block.number][msg.sender];\n', '    }\n', '\n', '    modifier onlyOneBlock() {\n', '        require(\n', '            !checkSameOriginReentranted(),\n', "            'ContractGuard: one block, one function'\n", '        );\n', '        require(\n', '            !checkSameSenderReentranted(),\n', "            'ContractGuard: one block, one function'\n", '        );\n', '\n', '        _;\n', '\n', '        _status[block.number][tx.origin] = true;\n', '        _status[block.number][msg.sender] = true;\n', '    }\n', '}\n', '\n', 'library Babylonian {\n', '    function sqrt(uint256 y) internal pure returns (uint256 z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint256 x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // range: [0, 2**144 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq144x112 {\n', '        uint256 _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint256 private constant Q112 = uint256(1) << RESOLUTION;\n', '    uint256 private constant Q224 = Q112 << RESOLUTION;\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(x) << RESOLUTION);\n', '    }\n', '\n', '    // encodes a uint144 as a UQ144x112\n', '    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n', '        return uq144x112(uint256(x) << RESOLUTION);\n', '    }\n', '\n', '    // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '    function div(uq112x112 memory self, uint112 x)\n', '        internal\n', '        pure\n', '        returns (uq112x112 memory)\n', '    {\n', "        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n", '        return uq112x112(self._x / uint224(x));\n', '    }\n', '\n', '    // multiply a UQ112x112 by a uint, returning a UQ144x112\n', '    // reverts on overflow\n', '    function mul(uq112x112 memory self, uint256 y)\n', '        internal\n', '        pure\n', '        returns (uq144x112 memory)\n', '    {\n', '        uint256 z;\n', '        require(\n', '            y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x),\n', "            'FixedPoint: MULTIPLICATION_OVERFLOW'\n", '        );\n', '        return uq144x112(z);\n', '    }\n', '\n', '    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).div(denominator)\n', '    function fraction(uint112 numerator, uint112 denominator)\n', '        internal\n', '        pure\n', '        returns (uq112x112 memory)\n', '    {\n', "        require(denominator > 0, 'FixedPoint: DIV_BY_ZERO');\n", '        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n', '    }\n', '\n', '    // decode a UQ112x112 into a uint112 by truncating after the radix point\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // decode a UQ144x112 into a uint144 by truncating after the radix point\n', '    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n', '        return uint144(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // take the reciprocal of a UQ112x112\n', '    function reciprocal(uq112x112 memory self)\n', '        internal\n', '        pure\n', '        returns (uq112x112 memory)\n', '    {\n', "        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n", '        return uq112x112(uint224(Q224 / self._x));\n', '    }\n', '\n', '    // square root of a UQ112x112\n', '    function sqrt(uq112x112 memory self)\n', '        internal\n', '        pure\n', '        returns (uq112x112 memory)\n', '    {\n', '        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\n', '    }\n', '}\n', '\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'interface IOracle {\n', '    function update() external;\n', '\n', '    function consult(address token, uint256 amountIn)\n', '        external\n', '        view\n', '        returns (uint256 amountOut);\n', '    // function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestamp);\n', '}\n', '\n', 'interface IBoardroom {\n', '    function allocateSeigniorage(uint256 amount) external;\n', '}\n', '\n', 'interface IBasisAsset {\n', '    function mint(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function burn(uint256 amount) external;\n', '\n', '    function burnFrom(address from, uint256 amount) external;\n', '\n', '    function isOperator() external returns (bool);\n', '\n', '    function operator() external view returns (address);\n', '}\n', '\n', 'interface ISimpleERCFund {\n', '    function deposit(\n', '        address token,\n', '        uint256 amount,\n', '        string memory reason\n', '    ) external;\n', '\n', '    function withdraw(\n', '        address token,\n', '        uint256 amount,\n', '        address to,\n', '        string memory reason\n', '    ) external;\n', '}\n', '\n', 'library Safe112 {\n', '    function add(uint112 a, uint112 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', "        require(c >= a, 'Safe112: addition overflow');\n", '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint112 a, uint112 b) internal pure returns (uint256) {\n', "        return sub(a, b, 'Safe112: subtraction overflow');\n", '    }\n', '\n', '    function sub(\n', '        uint112 a,\n', '        uint112 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint112) {\n', '        require(b <= a, errorMessage);\n', '        uint112 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint112 a, uint112 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', "        require(c / a == b, 'Safe112: multiplication overflow');\n", '\n', '        return c;\n', '    }\n', '\n', '    function div(uint112 a, uint112 b) internal pure returns (uint256) {\n', "        return div(a, b, 'Safe112: division by zero');\n", '    }\n', '\n', '    function div(\n', '        uint112 a,\n', '        uint112 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint112) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint112 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint112 a, uint112 b) internal pure returns (uint256) {\n', "        return mod(a, b, 'Safe112: modulo by zero');\n", '    }\n', '\n', '    function mod(\n', '        uint112 a,\n', '        uint112 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint112) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract morphTreasury is ContractGuard, Epoch {\n', '    using FixedPoint for *;\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    using SafeMath for uint256;\n', '    using Safe112 for uint112;\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    // ========== FLAGS\n', '    bool public migrated = false;\n', '    bool public initialized = false;\n', '\n', '    // ========== CORE\n', '    address public fund;\n', '    address public cash;\n', '    address public share;\n', '    address public boardroom;\n', '\n', '    address public seigniorageOracle;\n', '\n', '    // ========== PARAMS\n', '    uint256 public cashPriceOne;\n', '    uint256 public cashPriceCeiling;\n', '    uint256 private accumulatedSeigniorage = 0;\n', '    uint256 public fundAllocationRate = 3; // %\n', '    uint256 public maxInflationRate = 10; // %\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    constructor(\n', '        address _cash,\n', '        address _share,\n', '        address _seigniorageOracle,\n', '        address _boardroom,\n', '        address _fund,\n', '        uint256 _startTime,\n', '        uint256 _epochTime\n', '    ) public Epoch(_epochTime, _startTime, 0) {\n', '        cash = _cash;\n', '        share = _share;\n', '        seigniorageOracle = _seigniorageOracle;\n', '\n', '        boardroom = _boardroom;\n', '        fund = _fund;\n', '\n', '        cashPriceOne = 10**18;\n', '        cashPriceCeiling = uint256(101).mul(cashPriceOne).div(10**2);\n', '    }\n', '\n', '    function updateAddresses(address _cash, address _share, address _seigniorageOracle, address _boardroom, address _fund) public onlyOwner {\n', '        cash = _cash;\n', '        share = _share;\n', '        seigniorageOracle = _seigniorageOracle;\n', '        boardroom = _boardroom;\n', '        fund = _fund;\n', '    }\n', '\n', '    /* =================== Modifier =================== */\n', '\n', '    modifier checkMigration {\n', "        require(!migrated, 'Treasury: migrated');\n", '\n', '        _;\n', '    }\n', '\n', '    modifier checkOperator {\n', '        require(\n', '            IBasisAsset(cash).operator() == address(this) &&\n', '                IBasisAsset(share).operator() == address(this) &&\n', '                Operator(boardroom).operator() == address(this),\n', "            'Treasury: need more permission'\n", '        );\n', '\n', '        _;\n', '    }\n', '\n', '    /* ========== VIEW FUNCTIONS ========== */\n', '\n', '    // budget\n', '    function getReserve() public view returns (uint256) {\n', '        return accumulatedSeigniorage;\n', '    }\n', '\n', '    function getSeigniorageOraclePrice() public view returns (uint256) {\n', '        return _getCashPrice(seigniorageOracle);\n', '    }\n', '\n', '    function _getCashPrice(address oracle) internal view returns (uint256) {\n', '        try IOracle(oracle).consult(cash, 1e18) returns (uint256 price) {\n', '            return price;\n', '        } catch {\n', "            revert('Treasury: failed to consult token price from the oracle');\n", '        }\n', '    }\n', '\n', '    /* ========== GOVERNANCE ========== */\n', '\n', '    function initialize() public checkOperator {\n', "        require(!initialized, 'Treasury: initialized');\n", '\n', "        // burn all of it's balance\n", '        IBasisAsset(cash).burn(IERC20(cash).balanceOf(address(this)));\n', '\n', "        // set accumulatedSeigniorage to it's balance\n", '        accumulatedSeigniorage = IERC20(cash).balanceOf(address(this));\n', '\n', '        initialized = true;\n', '        emit Initialized(msg.sender, block.number);\n', '    }\n', '\n', '    function migrate(address target) public onlyOperator checkOperator {\n', "        require(!migrated, 'Treasury: migrated');\n", '\n', '        // cash\n', '        Operator(cash).transferOperator(target);\n', '        IERC20(cash).transfer(target, IERC20(cash).balanceOf(address(this)));\n', '\n', '        // share\n', '        Operator(share).transferOperator(target);\n', '        IERC20(share).transfer(target, IERC20(share).balanceOf(address(this)));\n', '\n', '        // boardroom\n', '        Operator(boardroom).transferOperator(target);\n', '\n', '        migrated = true;\n', '        emit Migration(target);\n', '    }\n', '\n', '    function setFund(address newFund) public onlyOperator {\n', '        fund = newFund;\n', '        emit ContributionPoolChanged(msg.sender, newFund);\n', '    }\n', '\n', '    function setFundAllocationRate(uint256 rate) public onlyOperator {\n', '        fundAllocationRate = rate;\n', '        emit ContributionPoolRateChanged(msg.sender, rate);\n', '    }\n', '\n', '    /* ========== MUTABLE FUNCTIONS ========== */\n', '\n', '    function _updateCashPrice() internal {\n', '        try IOracle(seigniorageOracle).update()  {} catch {}\n', '    }\n', '\n', '    function setMaxInflation(uint256 _maxInflationRate) public onlyOperator {\n', '        maxInflationRate = _maxInflationRate;\n', '    }\n', '\n', '    function allocateSeigniorage()\n', '        external\n', '        onlyOneBlock\n', '        checkMigration\n', '        checkStartTime\n', '        checkEpoch\n', '        checkOperator\n', '    {\n', '        _updateCashPrice();\n', '        uint256 cashPrice = _getCashPrice(seigniorageOracle);\n', '        if (cashPrice <= cashPriceCeiling) {\n', '            return; // just advance epoch instead revert\n', '        }\n', '\n', '        // circulating supply\n', '        uint256 cashSupply = IERC20(cash).totalSupply().sub(\n', '            accumulatedSeigniorage\n', '        );\n', '        uint256 percentage = cashPrice.sub(cashPriceOne);\n', '        uint256 seigniorage = cashSupply.mul(percentage).div(1e18);\n', '        uint256 maxSeigniorage = cashSupply.mul(maxInflationRate).div(100);\n', '        if (seigniorage > maxSeigniorage) {\n', '            seigniorage = maxSeigniorage;\n', '        }\n', '        IBasisAsset(cash).mint(address(this), seigniorage);\n', '\n', '        // ======================== BIP-3\n', '        uint256 fundReserve = seigniorage.mul(fundAllocationRate).div(100);\n', '        if (fundReserve > 0) {\n', '            IERC20(cash).transfer(fund, fundReserve);\n', '            emit ContributionPoolFunded(now, fundReserve);\n', '        }\n', '\n', '        seigniorage = seigniorage.sub(fundReserve);\n', '\n', '        // boardroom\n', '        uint256 boardroomReserve = seigniorage;\n', '        if (boardroomReserve > 0) {\n', '            IERC20(cash).safeApprove(boardroom, boardroomReserve);\n', '            IBoardroom(boardroom).allocateSeigniorage(boardroomReserve);\n', '            emit BoardroomFunded(now, boardroomReserve);\n', '        }\n', '    }\n', '\n', '    // GOV\n', '    event Initialized(address indexed executor, uint256 at);\n', '    event Migration(address indexed target);\n', '    event ContributionPoolChanged(address indexed operator, address newFund);\n', '    event ContributionPoolRateChanged(\n', '        address indexed operator,\n', '        uint256 newRate\n', '    );\n', '\n', '    // CORE\n', '    event TreasuryFunded(uint256 timestamp, uint256 seigniorage);\n', '    event BoardroomFunded(uint256 timestamp, uint256 seigniorage);\n', '    event ContributionPoolFunded(uint256 timestamp, uint256 seigniorage);\n', '\n', '    // Fallback rescue\n', '    receive() external payable{\n', '        payable(owner()).transfer(msg.value);\n', '    }\n', '\n', '    function rescueToken(IERC20 _token) public {\n', '        _token.transfer(owner(), _token.balanceOf(address(this)));\n', '    }\n', '}']