['# @version ^0.2.12\n', '"""\n', "@title Polymer's Vesting and distribution contract\n", '@author Polymer\n', '@license MIT\n', '@notice\n', '    Enables vesting of a token distribution.\n', '    The token to distribution is stored until vesting has initiated.\n', '\n', '    Vesting is by a linear schedule set globally. \n', '    The schedule can be changed by the owner as long as the\n', '    cliff has not been passed yet. This is a mathematical concern.\n', '\n', '    Cliff\n', '    The contract contains a start timestamp, referred to as the cliff. \n', '    Once the cliff is passed, the vesting schedule and vesting amounts\n', '    are /fixed/. No new amounts can be entered into vesting, but the punisher\n', '    can lower vested amounts. The punisher can be disabled by setting him \n', '    to ZERO_ADDRESS, as he decides who inherits the role.\n', '\n', '    Whitelists\n', '    On contract creation, whitelisting is enabled by default.The administrator\n', '    can enable or disable a whitelist of allowed users. Alternatively, the\n', '    whitelist can be disabled. If the whitelist is disabled, a token contribution\n', '    is recommended. Even if entering is free, a token contribution (for example)\n', '    be used to ensure people only register a certain amount.\n', '\n', '    One-time payout\n', '    The contract contains a flag that enables a one-time payout of a fixed\n', '    percentage of the vesting. If the flag is never raised, this withholds the\n', '    percentage contribution.\n', '"""\n', '\n', '# Load the ERC20 interface to add an ERC20 token to the contract\n', 'from vyper.interfaces import ERC20\n', '\n', 'event Collect:\n', '    to: indexed(address)\n', '    token: address\n', '    amount: uint256\n', '\n', 'event VestedClaims:\n', '    to: indexed(address)\n', '    amount: uint256\n', '\n', 'event Enter:\n', '    who: indexed(address)\n', '    amount: uint256\n', '    contribution: uint256\n', '\n', 'event ContributionPrice:\n', '    new: uint256\n', '\n', 'event Flag:\n', '    status: bool\n', '\n', 'event Slope:\n', '    cliff: uint256\n', '    end: uint256\n', '\n', 'event Punish:\n', '    _who: indexed(address)\n', '    _from: uint256\n', '    _to: uint256\n', '\n', 'event Whitelist:\n', '    who: indexed(address)\n', '    status: uint256\n', '\n', '\n', '\n', 'event OwnerTransfer:\n', '    old: indexed(address)\n', '    new: indexed(address)\n', '\n', 'event ClaimTransfer:\n', '    old: indexed(address)\n', '    new: indexed(address)\n', '\n', 'event PunisherTransfer:\n', '    old: indexed(address)\n', '    new: indexed(address)\n', '\n', '\n', '\n', '# scale to increase precision.\n', 'RESOLUTION: constant(uint256) = 10**18\n', '\n', '# Contract variables\n', 'owner: public(address)\n', 'punisher: public(address)\n', '\n', '# Vesting Variables\n', 'cliffTimestamp: public(uint256)\n', 'endTimestamp: public(uint256)\n', 'flag: public(bool)\n', 'IMMEDIATEALLOCATION: constant(uint256) = 10**17 # out of RESOLUTION\n', '\n', 'useWhitelist: public(bool)\n', 'whitelisted: public(HashMap[address, uint256])\n', '\n', '\n', '# Token contribution\n', 'contributionToken: public(address)\n', 'contributionPrice: public(uint256) # · resolution\n', '\n', '\n', '# Token management variables\n', 'totalTokens: public(uint256)\n', '# Alternatively a struct.\n', 'userVesting: public(HashMap[address, uint256])\n', 'userClaimed: public(HashMap[address, uint256])\n', 'vestingToken: public(address)\n', '\n', '\n', '# Preclaim token storage.\n', '#  Tokens owned by claimAddress is distributable by this contract.\n', '#  Requires allowance.\n', 'claimAddress: public(address)\n', '\n', '\n', '@external\n', 'def __init__(_claimAddress : address, _vestingToken : address):\n', '    self.claimAddress = _claimAddress\n', '    self.useWhitelist = True\n', '    self.owner = msg.sender\n', '    self.punisher = msg.sender\n', '    self.vestingToken = _vestingToken\n', '\n', '\n', '@external\n', 'def transferOwner(_owner : address):\n', '    """\n', '    @notice Transfer ownership to another address\n', '    @dev Reverts if msg.sender is not owner\n', '    @param _owner address Address of new owner\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log OwnerTransfer(self.owner, _owner)\n', '\n', '    self.owner = _owner\n', '\n', '\n', '@external\n', 'def transferPunisher(_punisher : address):\n', '    """\n', '    @notice Transfer punisher to another address\n', '    @dev Reverts if msg.sender is not punisher\n', '    @param _punisher address Address of new punisher\n', '    """\n', '    assert msg.sender == self.punisher, "unauthorized"\n', '\n', '    log PunisherTransfer(self.punisher, _punisher)\n', '\n', '    self.punisher = _punisher\n', '\n', '\n', '@external\n', 'def setClaim(_contract : address):\n', '    """\n', '    @notice Sets the source of tokens\n', '    @dev Reverts if msg.sender is not owner\n', '    @param _contract address Address of the new source of tokens to vest\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log ClaimTransfer(self.claimAddress, _contract)\n', '\n', '    self.claimAddress = _contract\n', '\n', '\n', '@external\n', 'def setSlope(_cliffTimestamp : uint256, _endTimestamp : uint256):\n', '    """\n', '    @notice Sets the slope settings\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '        Reverts if cliff has already passed\n', '        Reverts if _cliffTimestamp has passed.\n', '    @param _cliffTimestamp uint256 New cliff\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '    assert (block.timestamp <= self.cliffTimestamp) or (self.cliffTimestamp == 0), "Cliff passed"\n', '    assert block.timestamp <= _cliffTimestamp, "Cliff invalid"\n', '    assert _cliffTimestamp < _endTimestamp\n', '\n', '    log Slope(_cliffTimestamp, _endTimestamp)\n', '\n', '    self.cliffTimestamp = _cliffTimestamp\n', '    self.endTimestamp = _endTimestamp\n', '\n', '\n', '@external\n', 'def raiseFlag():\n', '    """\n', '    @notice Allows the initial tokens to be released\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '    """\n', '    assert msg.sender == self.owner\n', '\n', '    self.flag = True\n', '\n', '    log Flag(True)\n', '\n', '\n', '@external\n', 'def setWhitelist(_bool : bool):\n', '    """\n', '    @notice Enable or disable whitelist.\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '    @param _bool bool\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log Whitelist(ZERO_ADDRESS, convert(_bool, uint256))\n', '\n', '    self.useWhitelist = _bool\n', '\n', '\n', '@external\n', 'def whitelist(_who : address, _amount : uint256):\n', '    """\n', '    @notice Sets whitelist for a user\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '    @param _who address User to set whitelist for\n', '    @param _amount uint256 The amount to whitelist the user for\n', '        True for whitelisted\n', '        False for not whitelisted\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log Whitelist(_who, _amount)\n', '\n', '    self.whitelisted[_who] = _amount\n', '\n', '\n', '@external\n', 'def setContribution(_price : uint256, _contributionToken : address):\n', '    """\n', '    @notice Sets a new contributionPrice and contributionToken for vesting\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '    @param _price uint256 New contributionPrice\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log ContributionPrice(_price)\n', '\n', '    self.contributionPrice = _price\n', '    self.contributionToken = _contributionToken\n', '\n', '\n', '@external\n', 'def punish(_who : address, _newAmount : uint256):\n', '    """\n', "    @notice Set a vesting user's amount.\n", '    @dev \n', '        Reverts if msg.sender != punisher\n', '        Reverts if _newAmount results in an increase.\n', '    @param _who address The address to punish\n', '    @param _newAmount uint256 The new amount.\n', '    """\n', '    assert msg.sender == self.punisher, "unauthorized"\n', '\n', '    _userClaimed: uint256 = self.userClaimed[_who]\n', '\n', '    assert self.userVesting[_who] - _userClaimed >= _newAmount, "Increases vesting"\n', '\n', '    log Punish(_who, self.userVesting[_who], _newAmount + _userClaimed)\n', '\n', '    self.userVesting[_who] = _newAmount + _userClaimed\n', '\n', '\n', '@external\n', 'def collect(_to : address, _token : address, _amount : uint256):\n', '    """\n', '    @notice Collect token contributions and forward them to _to.\n', '    @dev \n', '        Reverts if msg.sender != owner\n', '    @param _to address The address to send token contributions to\n', '    @param _token address The token to send contributions to. (Required in case contributionToken changed)\n', '    @param _amount uint256 Amount of _token to send to _to.\n', '    """\n', '    assert msg.sender == self.owner, "unauthorized"\n', '\n', '    log Collect(_to, _token, _amount)\n', '\n', '    assert ERC20(_token).transfer(_to, _amount), "Transfer failed"\n', '\n', '\n', '@nonreentrant("lock")\n', '@external\n', 'def enter(_amount : uint256) -> bool:\n', '    """\n', '    @notice Enter a vesting for _amount of vestingToken.\n', '    @dev \n', '        Reverts if cliff has been passed.\n', '        Reverts if useWhitelist == True and msg.sender is not whitelisted. \n', '        Reverts if user cannot pay _amount · contributionPrice.\n', '    @param _amount uint256 Amount of _token to allocate to msg.sender\n', '    @return bool True\n', '    """\n', '    assert block.timestamp <= self.cliffTimestamp, "Cliff passed"\n', '    if self.useWhitelist:\n', '        self.whitelisted[msg.sender] -= _amount  # dev: Not enough whitelisted\n', '\n', '    if self.contributionPrice > 0:\n', '        assert ERC20(self.contributionToken).transferFrom(msg.sender, self, (_amount*self.contributionPrice)/RESOLUTION), "Contribution"\n', '    assert ERC20(self.vestingToken).transferFrom(self.claimAddress, self, _amount), "Vest allocation"\n', '\n', '    log Enter(msg.sender, _amount, (_amount * self.contributionPrice)/RESOLUTION)\n', '\n', '    self.userVesting[msg.sender] += _amount\n', '\n', '    return True\n', '\n', '\n', '# No reentrancy lock because external call is after storage mod\n', '@external\n', 'def claimVested() -> uint256:\n', '    """\n', '    @notice Claims vested tokens\n', '    @dev\n', '        !Reverts if block.timestamp < cliffTimestamp. \n', '    @return uint256 Vested tokens.\n', '    """\n', '    \n', '    userVest: uint256 = self.userVesting[msg.sender]\n', '\n', '    # Logic for initial allocation\n', '    initial: uint256 = 0\n', '    if self.flag:\n', '        initial = (userVest*IMMEDIATEALLOCATION)/RESOLUTION\n', '\n', '    # Create vesting function.\n', '    #\n', '    # Y |         /-----\n', '    #   |       /\n', '    #   |     /     \n', '    # --+---/-----------\n', '    #   |   A     B     \n', '    # A: cliffTimestamp\n', '    # B: endTimestamp\n', '    # Y: userVesting\n', '    # y = a * x + b\n', '    # Y = ?a * B + ?b and 0 = ?a * A + ?b \n', '    # <=> a = -Y/(B-A), b = YB/(B-A)\n', '    # y = Y/(B-A) * x - YA/(B-A) = (Y·(x-A))/(B-A)\n', '\n', '    A: uint256 = self.cliffTimestamp\n', '    numRewardTokens: uint256 = initial\n', '    if block.timestamp > self.cliffTimestamp:\n', '        B: uint256 = self.endTimestamp\n', '        Y: uint256 = (userVest*(RESOLUTION-IMMEDIATEALLOCATION))/RESOLUTION\n', '\n', '\n', '        # Piecewise right.\n', '        x: uint256 = min(block.timestamp, B)\n', '        # Sainty check: x >= B <=> x = B <=> (Y·(x-A))/(B-A) = (Y·(B-A))/(B-A) = Y · (B-A)/(B-A) = Y\n', '        \n', '\n', '        # Piecewise left.\n', '        numRewardTokens += ((Y*(x-A))/(B-A)) # Dev: Call later; x < A => x-A < 0. uint256 < 0 => reverts.\n', '\n', '    numRewardTokens -= self.userClaimed[msg.sender]\n', '    \n', '    self.userClaimed[msg.sender] += numRewardTokens\n', '\n', '    assert ERC20(self.vestingToken).transfer(msg.sender, numRewardTokens)\n', '\n', '    log VestedClaims(msg.sender, numRewardTokens)\n', '\n', '    return numRewardTokens\n', '\n', '\n', '@view\n', '@external\n', 'def viewVested(_user : address) -> uint256:\n', '    """\n', '    @notice Claims vested tokens\n', '    @dev\n', '        !Reverts if block.timestamp < cliffTimestamp. \n', '    @return uint256 Vested tokens.\n', '    """\n', '    \n', '    userVest: uint256 = self.userVesting[_user]\n', '\n', '    initial: uint256 = 0\n', '    if self.flag:\n', '        initial = (userVest*IMMEDIATEALLOCATION)/RESOLUTION\n', '\n', '\n', '    A: uint256 = self.cliffTimestamp\n', '    numRewardTokens: uint256 = initial\n', '    if block.timestamp > self.cliffTimestamp:\n', '        B: uint256 = self.endTimestamp\n', '        Y: uint256 = (userVest*(RESOLUTION-IMMEDIATEALLOCATION))/RESOLUTION\n', '\n', '        x: uint256 = min(block.timestamp, B)\n', '        numRewardTokens += ((Y*(x-A))/(B-A)) \n', '\n', '    return numRewardTokens - self.userClaimed[_user]']