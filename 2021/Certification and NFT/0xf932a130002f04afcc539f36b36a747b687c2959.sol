['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-08\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', '// The ABI encoder is necessary, but older Solidity versions should work\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// These definitions are taken from across multiple dydx contracts, and are\n', '// limited to just the bare minimum necessary to make flash loans work.\n', 'library Types {\n', '    enum AssetDenomination { Wei, Par }\n', '    enum AssetReference { Delta, Target }\n', '    struct AssetAmount {\n', '        bool sign;\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '}\n', '\n', 'library Account {\n', '    struct Info {\n', '        address owner;\n', '        uint256 number;\n', '    }\n', '}\n', '\n', 'library Actions {\n', '    enum ActionType {\n', '        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\n', '    }\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        Types.AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '}\n', '\n', 'interface ISoloMargin {\n', '    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n', '}\n', '\n', '// The interface for a contract to be callable after receiving a flash loan\n', 'interface ICallee {\n', '    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external;\n', '}\n', '\n', '// Standard ERC-20 interface\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// Additional methods available for WETH\n', 'interface IWETH is IERC20 {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', 'interface Cryptopunks {\n', '    function punkIndexToAddress (uint256 punkIndex) external view returns (address);\n', '    function punkBids (uint256 punkIndex) external view returns ( bool , uint256 , address , uint256 );\n', '    function enterBidForPunk (uint256 punkIndex) external payable;\n', '    function withdrawBidForPunk (uint256 punkIndex) external;\n', '    function withdraw () external;\n', '}\n', '\n', 'interface ENS{\n', '    function setName(string memory name) external returns (bytes32);\n', '}\n', '\n', 'contract declineBid is ICallee {\n', "    // The WETH token contract, since we're assuming we want a loan in WETH\n", '    IWETH private WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    // The dydx Solo Margin contract, as can be found here:\n', '    // https://github.com/dydxprotocol/solo/blob/master/migrations/deployed.json\n', '    ISoloMargin private soloMargin = ISoloMargin(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n', '    Cryptopunks constant punkContract=Cryptopunks(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\n', '    ENS constant ensRegistar=ENS(0x084b1c3C81545d370f3634392De611CaaBFf8148);\n', '    address private owner;\n', '\n', '    constructor() {\n', '        // Give infinite approval to dydx to withdraw WETH on contract deployment,\n', "        // so we don't have to approve the loan repayment amount (+2 wei) on each call.\n", '        // The approval is used by the dydx contract to pay the loan back to itself.\n', '        WETH.approve(address(soloMargin), uint(-1));\n', '        owner= msg.sender;\n', '    }\n', '    \n', '    // This is the function we call\n', '    function declineBidOnPunk(uint256 punkIndex) external {\n', '        /*\n', '        The flash loan functionality in dydx is predicated by their "operate" function,\n', '        which takes a list of operations to execute, and defers validating the state of\n', "        things until it's done executing them.\n", '        \n', '        We thus create three operations, a Withdraw (which loans us the funds), a Call\n', '        (which invokes the callFunction method on this contract), and a Deposit (which\n', '        repays the loan, plus the 2 wei fee), and pass them all to "operate".\n', '        \n', '        Note that the Deposit operation will invoke the transferFrom to pay the loan \n', '        (or whatever amount it was initialised with) back to itself, there is no need\n', '        to pay it back explicitly.\n', '        \n', '        The loan must be given as an ERC-20 token, so WETH is used instead of ETH. Other\n', '        currencies (DAI, USDC) are also available, their index can be looked up by\n', '        calling getMarketTokenAddress on the solo margin contract, and set as the \n', '        primaryMarketId in the Withdraw and Deposit definitions.\n', '        */\n', '        \n', '        (,,,uint loanAmount) = punkContract.punkBids(punkIndex) ; //add 1 wei\n', '        require (loanAmount!=0,"No bid on this punk!");\n', '        require (msg.sender==owner || msg.sender==punkContract.punkIndexToAddress(punkIndex),"Not your punk!"); //owner may use for testing\n', '        loanAmount+=1;\n', '\n', '        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n', '\n', '        operations[0] = Actions.ActionArgs({\n', '            actionType: Actions.ActionType.Withdraw,\n', '            accountId: 0,\n', '            amount: Types.AssetAmount({\n', '                sign: false,\n', '                denomination: Types.AssetDenomination.Wei,\n', '                ref: Types.AssetReference.Delta,\n', '                value: loanAmount // Amount to borrow\n', '            }),\n', '            primaryMarketId: 0, // WETH\n', '            secondaryMarketId: 0,\n', '            otherAddress: address(this),\n', '            otherAccountId: 0,\n', '            data: ""\n', '        });\n', '        \n', '        operations[1] = Actions.ActionArgs({\n', '                actionType: Actions.ActionType.Call,\n', '                accountId: 0,\n', '                amount: Types.AssetAmount({\n', '                    sign: false,\n', '                    denomination: Types.AssetDenomination.Wei,\n', '                    ref: Types.AssetReference.Delta,\n', '                    value: 0\n', '                }),\n', '                primaryMarketId: 0,\n', '                secondaryMarketId: 0,\n', '                otherAddress: address(this),\n', '                otherAccountId: 0,\n', '                data: abi.encode(\n', '                    // Replace or add any additional variables that you want\n', '                    // to be available to the receiver function\n', '                    msg.sender,\n', '                    loanAmount,\n', '                    punkIndex\n', '                )\n', '            });\n', '        \n', '        operations[2] = Actions.ActionArgs({\n', '            actionType: Actions.ActionType.Deposit,\n', '            accountId: 0,\n', '            amount: Types.AssetAmount({\n', '                sign: true,\n', '                denomination: Types.AssetDenomination.Wei,\n', '                ref: Types.AssetReference.Delta,\n', '                value: loanAmount + 2 // Repayment amount with 2 wei fee\n', '            }),\n', '            primaryMarketId: 0, // WETH\n', '            secondaryMarketId: 0,\n', '            otherAddress: address(this),\n', '            otherAccountId: 0,\n', '            data: ""\n', '        });\n', '\n', '        Account.Info[] memory accountInfos = new Account.Info[](1);\n', '        accountInfos[0] = Account.Info({owner: address(this), number: 1});\n', '\n', '        soloMargin.operate(accountInfos, operations);\n', '    }\n', '    \n', '    // This is the function called by dydx after giving us the loan\n', '    function callFunction(address sender, Account.Info memory accountInfo, bytes memory data) external override {\n', '        // Decode the passed variables from the data object\n', '        (\n', '            // This must match the variables defined in the Call object above\n', '            address payable actualSender,\n', '            uint loanAmount,\n', '            uint256 punkIndex\n', '\n', '        ) = abi.decode(data, (\n', '            address, uint, uint256\n', '        ));\n', '        \n', '        // We now have a WETH balance of loanAmount. The logic for what we\n', '        // want to do with it goes here. The code below is just there in case\n', "        // it's useful.\n", '        WETH.withdraw(loanAmount);\n', '        punkContract.enterBidForPunk{value:loanAmount}(punkIndex);\n', '        punkContract.withdrawBidForPunk(punkIndex);\n', '        punkContract.withdraw();\n', '        WETH.deposit{value: loanAmount}();\n', '        // It can be useful for debugging to have a verbose error message when\n', "        // the loan can't be paid, since dydx doesn't provide one\n", '        require(WETH.balanceOf(address(this)) > loanAmount + 2, "CANNOT REPAY LOAN");\n', '    }\n', '\n', '    function setReverseRecord(string memory _name) external \n', '    {\n', '        require (msg.sender==owner);\n', '        ensRegistar.setName(_name);\n', '    }\n', '}']