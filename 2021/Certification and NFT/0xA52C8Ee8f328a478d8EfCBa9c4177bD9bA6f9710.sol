['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./ACOAssetHelper.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'contract ACOBuyerV2 {\n', '    \n', '    struct BuyACO {\n', '        address from;\n', '        uint256 ethValue;\n', '        bytes data;\n', '    }\n', '    \n', '    bool internal _notEntered;\n', '\n', '    modifier nonReentrant() {\n', '        require(_notEntered, "ACOBuyer::Reentry");\n', '        _notEntered = false;\n', '        _;\n', '        _notEntered = true;\n', '    }\n', '    \n', '    constructor() public {\n', '        _notEntered = true;\n', '    }\n', '\n', '    receive() external payable {\n', '        require(tx.origin != msg.sender, "ACOBuyer:: Not allowed");\n', '    }\n', '    \n', '    function buy(\n', '        address acoToken,\n', '        address paymentToken, \n', '        uint256 paymentAmount, \n', '        BuyACO[] calldata data\n', '    ) \n', '        nonReentrant\n', '        external\n', '        payable\n', '    {\n', '        require(paymentAmount > 0, "ACOBuyer::buy: Invalid amount");\n', '        require(data.length > 0, "ACOBuyer::buy: Invalid data");\n', '        require(acoToken != address(0), "ACOBuyer::buy: Invalid aco");\n', '        \n', '        bool isEther = ACOAssetHelper._isEther(paymentToken);\n', '        \n', '        uint256 previousEthBalance = SafeMath.sub(address(this).balance, msg.value);\n', '        uint256 previousAcoBalance = ACOAssetHelper._getAssetBalanceOf(acoToken, address(this));\n', '        uint256 previousTokenBalance;\n', '        \n', '        if (isEther) {\n', '            require(msg.value >= paymentAmount, "ACOBuyer::buy:Invalid ETH amount");\n', '        } else {\n', '            previousTokenBalance = ACOAssetHelper._getAssetBalanceOf(paymentToken, address(this));\n', '            ACOAssetHelper._callTransferFromERC20(paymentToken, msg.sender, address(this), paymentAmount);\n', '        }\n', '        \n', '        for (uint256 i = 0; i < data.length; ++i) {\n', '            if (!isEther) {\n', '                ACOAssetHelper._setAssetInfinityApprove(paymentToken, address(this), data[i].from, paymentAmount);\n', '            }\n', '            (bool success,) = data[i].from.call{value:data[i].ethValue}(data[i].data);\n', '            require(success, "ACOBuyer::buy:Error on order");\n', '        }\n', '        \n', '        uint256 remainingEth = SafeMath.sub(address(this).balance, previousEthBalance);\n', '        uint256 afterAcoBalance = ACOAssetHelper._getAssetBalanceOf(acoToken, address(this));\n', '        uint256 remainingAco = SafeMath.sub(afterAcoBalance, previousAcoBalance);\n', '\n', '        if (remainingAco > 0) {\n', '            ACOAssetHelper._callTransferERC20(acoToken, msg.sender, remainingAco);\n', '        }\n', '        if (!isEther) {\n', '            uint256 afterTokenBalance = ACOAssetHelper._getAssetBalanceOf(paymentToken, address(this));\n', '            uint256 remainingToken = SafeMath.sub(afterTokenBalance, previousTokenBalance);\n', '            if (remainingToken > 0) {\n', '                ACOAssetHelper._callTransferERC20(paymentToken, msg.sender, remainingToken);\n', '            }\n', '        }\n', '        if (remainingEth > 0) {\n', '            msg.sender.transfer(remainingEth);\n', '        }\n', '    }\n', '}']