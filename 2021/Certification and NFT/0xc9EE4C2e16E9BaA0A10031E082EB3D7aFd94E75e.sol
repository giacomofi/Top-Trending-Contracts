['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-04\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', '\n', 'interface AggregatorV3Interface {\n', '\n', '  function decimals() external view returns (uint8);\n', '  function description() external view returns (string memory);\n', '  function version() external view returns (uint256);\n', '\n', '  // getRoundData and latestRoundData should both raise "No data present"\n', '  // if they do not have data to report, instead of returning unset values\n', '  // which could be misinterpreted as actual reported values.\n', '  function getRoundData(uint80 _roundId)\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '  function latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '}\n', '\n', 'interface ITrollbox {\n', '    function withdrawWinnings(uint voterId) external;\n', '    function updateAccount(uint voterId, uint tournamentId, uint roundId) external;\n', '    function isSynced(uint voterId, uint tournamentId, uint roundId) external view returns (bool);\n', '    function roundAlreadyResolved(uint tournamentId, uint roundId) external view returns (bool);\n', '    function resolveRound(uint tournamentId, uint roundId, uint winningOption) external;\n', '    function getCurrentRoundId(uint tournamentId) external returns (uint);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ChainLinkOracle {\n', '\n', '    struct Proposal {\n', '        uint id;\n', '        uint time;\n', '        bool confirmed;\n', '        uint roundId;\n', '        uint winnerIndex;\n', '        uint challengeWinnerIndex;\n', '        address challenger;\n', '    }\n', '\n', '    mapping (bytes32 => address) public feedMap; // ticker symbol => price aggregator address\n', '    mapping (bytes32 => int) public prices; // symbol => price\n', '    mapping (uint => Proposal) public proposals;\n', '\n', '    address public management;\n', '    ITrollbox public trollbox;\n', '    IERC20 public token;\n', '\n', '    int constant public PRECISION = 1000000;\n', '    uint public numProposals = 0;\n', '    uint public challengeDeposit = 0;\n', '    uint public challengePeriodSeconds = 60 * 60 * 24;\n', '    uint public tournamentId = 1;\n', '\n', '    bytes32[] public tickerSymbols;\n', '\n', '    // mgmt events\n', '    event FeedUpdated(bytes32 indexed key, address indexed feedAddr);\n', '    event ManagementUpdated(address oldManagement, address newManagement);\n', '    event DepositUpdated(uint oldDeposit, uint newDeposit);\n', '    event ChallengePeriodUpdated(uint oldPeriod, uint newPeriod);\n', '    event TickerSymbolsUpdated(bytes32[] oldKeys, bytes32[] newKeys);\n', '\n', '    // winner events\n', '    event WinnerProposed(uint indexed roundId, uint indexed proposalId, uint winnerIndex);\n', '    event WinnerConfirmed(uint indexed roundId, uint indexed proposalId, int[] prices);\n', '\n', '    // challenger events\n', '    event ChallengeMade(uint indexed proposalId, address indexed challenger, uint indexed claimedWinner);\n', '    event ChallengerSlashed(uint indexed proposalId, address indexed challenger, uint indexed slashAmount);\n', '    event ChallengerVindicated(uint indexed proposalId, address indexed challenger);\n', '\n', '    modifier managementOnly() {\n', "        require (msg.sender == management, 'Only management may call this');\n", '        _;\n', '    }\n', '\n', '    modifier latestProposalConfirmed() {\n', "        require (proposals[numProposals].confirmed == true || numProposals == 0, 'Unconfirmed proposal present');\n", '        _;\n', '    }\n', '\n', '    constructor(address mgmt, address trollboxAddr, address tokenAddr, uint tournament, bytes32[] memory initialSymbols, int[] memory initialPrices) {\n', '        management = mgmt;\n', '        trollbox = ITrollbox(trollboxAddr);\n', '        token = IERC20(tokenAddr);\n', '        tournamentId = tournament;\n', '        tickerSymbols = initialSymbols;\n', '        setPricesInternal(initialPrices);\n', '    }\n', '\n', '    function setManagement(address newMgmt) public managementOnly {\n', '        address oldMgmt = management;\n', '        management =  newMgmt;\n', '        emit ManagementUpdated(oldMgmt, newMgmt);\n', '    }\n', '\n', '    function setChallengeDeposit(uint newDeposit) public managementOnly latestProposalConfirmed {\n', '        uint oldDeposit = challengeDeposit;\n', '        challengeDeposit = newDeposit;\n', '        emit DepositUpdated(oldDeposit, newDeposit);\n', '    }\n', '\n', '    function setChallengePeriod(uint newPeriod) public managementOnly latestProposalConfirmed {\n', '        uint oldPeriod = challengePeriodSeconds;\n', '        challengePeriodSeconds = newPeriod;\n', '        emit ChallengePeriodUpdated(oldPeriod, newPeriod);\n', '    }\n', '\n', '    function setPricesInternal(int[] memory newPrices) internal {\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            prices[tickerSymbols[i]] = newPrices[i];\n', '        }\n', '    }\n', '\n', '    function getTickerSymbols() public view returns (bytes32[] memory) {\n', '        return tickerSymbols;\n', '    }\n', '\n', '    function setTickerSymbols(bytes32[] memory newKeys) public managementOnly latestProposalConfirmed {\n', '        bytes32[] memory oldKeys = tickerSymbols;\n', '        tickerSymbols = newKeys;\n', '        emit TickerSymbolsUpdated(oldKeys, newKeys);\n', '    }\n', '\n', '    function addFeed(bytes32 key, address feedAddr) public managementOnly {\n', '        feedMap[key] = feedAddr;\n', '        emit FeedUpdated(key, feedAddr);\n', '    }\n', '\n', '    function getWinner() public view returns (int[] memory, uint) {\n', '        int256 maxPriceDiff = -100 * PRECISION;\n', '        uint winnerIndex = 0;\n', '        int[] memory pricesLocal = new int[](tickerSymbols.length);\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            bytes32 key = tickerSymbols[i];\n', '            int priceBefore = prices[key];\n', '            AggregatorV3Interface chainlink = AggregatorV3Interface(feedMap[key]);\n', '            (,int256 priceNow,,,) = chainlink.latestRoundData();\n', '            pricesLocal[i] = priceNow;\n', '            int256 priceDiff = ((priceNow - priceBefore) * PRECISION) / priceBefore;\n', '            if (priceDiff > maxPriceDiff) {\n', '                maxPriceDiff = priceDiff;\n', '                // add one to index to account for 1 based indexing on Trollbox contract\n', '                winnerIndex = i + 1;\n', '            }\n', '        }\n', '        return (pricesLocal, winnerIndex);\n', '    }\n', '\n', '    function proposeWinner(uint roundId) public latestProposalConfirmed {\n', "        require(trollbox.roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolve');\n", "        require(trollbox.getCurrentRoundId(tournamentId) > roundId + 1, 'Round not ready to resolve');\n", '        Proposal storage proposal = proposals[++numProposals];\n', '        proposal.id = numProposals;\n', '        proposal.time = block.timestamp;\n', '        proposal.roundId = roundId;\n', '        (int[] memory newPrices, uint winnerIndex) = getWinner();\n', '        setPricesInternal(newPrices);\n', '        proposal.winnerIndex = winnerIndex;\n', '        emit WinnerProposed(roundId, numProposals, proposal.winnerIndex);\n', '    }\n', '\n', '    function challengeWinner(uint proposalId, uint claimedWinner) public {\n', '        token.transferFrom(msg.sender, address(this), challengeDeposit);\n', '        Proposal storage proposal = proposals[proposalId];\n', "        require(proposal.challenger == address(0), 'Proposal already challenged');\n", "        require(claimedWinner != proposal.winnerIndex, 'Must claim different winner than proposed winner');\n", "        require(block.timestamp - proposal.time < challengePeriodSeconds, 'Challenge period has passed');\n", '        proposal.challenger = msg.sender;\n', '        proposal.challengeWinnerIndex = claimedWinner;\n', '        emit ChallengeMade(proposalId, msg.sender, claimedWinner);\n', '    }\n', '\n', '    function confirmWinnerUnchallenged(uint proposalId) public {\n', '        Proposal memory proposal = proposals[proposalId];\n', "        require(proposal.challenger == address(0), 'Proposal has been challenged');\n", "        require(block.timestamp - proposal.time > challengePeriodSeconds, 'Challenge period has not passed');\n", '        confirmWinnerInternal(proposalId);\n', '    }\n', '\n', '    function confirmWinnerChallenged(uint proposalId, uint chosenWinnerIndex, int[] memory localPrices) public managementOnly {\n', '        Proposal storage proposal = proposals[proposalId];\n', "        require(proposal.challenger != address(0), 'Proposal has not been challenged');\n", "        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\n", "        require(chosenWinnerIndex > 0, 'Winner index must be positive');\n", "        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\n", '\n', '        // set official winner\n', '        proposal.winnerIndex = chosenWinnerIndex;\n', '\n', '        // record prices\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            prices[tickerSymbols[i]] = localPrices[i];\n', '        }\n', '\n', '        confirmWinnerInternal(proposalId);\n', '\n', '        // if challenger failed, slash their deposit\n', '        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\n', '            token.transfer(address(0), challengeDeposit);\n', '            emit ChallengerSlashed(proposalId, proposal.challenger, challengeDeposit);\n', '        // else send it back to them\n', '        } else {\n', '            token.transfer(proposal.challenger, challengeDeposit);\n', '            emit ChallengerVindicated(proposalId, proposal.challenger);\n', '        }\n', '    }\n', '\n', '    function confirmWinnerInternal(uint proposalId) internal {\n', '        Proposal storage proposal = proposals[proposalId];\n', "        require(proposal.id == proposalId, 'Invalid proposalId');\n", "        require(proposal.confirmed == false, 'Already confirmed proposal');\n", '        proposal.confirmed = true;\n', '        int[] memory pricesLocal = new int[](tickerSymbols.length);\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            pricesLocal[i] = prices[tickerSymbols[i]];\n', '        }\n', '        emit WinnerConfirmed(proposal.roundId, proposalId, pricesLocal);\n', '        trollbox.resolveRound(tournamentId, proposal.roundId, proposal.winnerIndex);\n', '    }\n', '\n', '}']