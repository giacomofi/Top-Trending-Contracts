['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '/// StabilityFeeTreasury.sol\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>, 2020 Reflexer Labs, INC\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'abstract contract SAFEEngineLike {\n', '    function approveSAFEModification(address) virtual external;\n', '    function denySAFEModification(address) virtual external;\n', '    function transferInternalCoins(address,address,uint256) virtual external;\n', '    function settleDebt(uint256) virtual external;\n', '    function coinBalance(address) virtual public view returns (uint256);\n', '    function debtBalance(address) virtual public view returns (uint256);\n', '}\n', 'abstract contract SystemCoinLike {\n', '    function balanceOf(address) virtual public view returns (uint256);\n', '    function approve(address, uint256) virtual public returns (uint256);\n', '    function transfer(address,uint256) virtual public returns (bool);\n', '    function transferFrom(address,address,uint256) virtual public returns (bool);\n', '}\n', 'abstract contract CoinJoinLike {\n', '    function systemCoin() virtual public view returns (address);\n', '    function join(address, uint256) virtual external;\n', '}\n', '\n', 'contract StabilityFeeTreasury {\n', '    // --- Auth ---\n', '    mapping (address => uint256) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "StabilityFeeTreasury/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ModifyParameters(bytes32 parameter, address addr);\n', '    event ModifyParameters(bytes32 parameter, uint256 val);\n', '    event DisableContract();\n', '    event SetTotalAllowance(address indexed account, uint256 rad);\n', '    event SetPerBlockAllowance(address indexed account, uint256 rad);\n', '    event GiveFunds(address indexed account, uint256 rad, uint256 expensesAccumulator);\n', '    event TakeFunds(address indexed account, uint256 rad);\n', '    event PullFunds(address indexed sender, address indexed dstAccount, address token, uint256 rad, uint256 expensesAccumulator);\n', '    event TransferSurplusFunds(address extraSurplusReceiver, uint256 fundsToTransfer);\n', '\n', '    // --- Structs ---\n', '    struct Allowance {\n', '        uint256 total;\n', '        uint256 perBlock;\n', '    }\n', '\n', '    mapping(address => Allowance)                   private allowance;\n', '    mapping(address => mapping(uint256 => uint256)) public pulledPerBlock;\n', '\n', '    SAFEEngineLike  public safeEngine;\n', '    SystemCoinLike  public systemCoin;\n', '    CoinJoinLike    public coinJoin;\n', '\n', '    address public extraSurplusReceiver;\n', '\n', '    uint256 public treasuryCapacity;           // max amount of SF that can be kept in treasury                            [rad]\n', '    uint256 public minimumFundsRequired;       // minimum amount of SF that must be kept in the treasury at all times      [rad]\n', '    uint256 public expensesMultiplier;         // multiplier for expenses                                                  [hundred]\n', '    uint256 public surplusTransferDelay;       // minimum time between transferSurplusFunds calls                          [seconds]\n', '    uint256 public expensesAccumulator;        // expenses accumulator                                                     [rad]\n', '    uint256 public accumulatorTag;             // latest tagged accumulator price                                          [rad]\n', '    uint256 public pullFundsMinThreshold;      // minimum funds that must be in the treasury so that someone can pullFunds [rad]\n', '    uint256 public latestSurplusTransferTime;  // latest timestamp when transferSurplusFunds was called                    [seconds]\n', '    uint256 public contractEnabled;\n', '\n', '    modifier accountNotTreasury(address account) {\n', '        require(account != address(this), "StabilityFeeTreasury/account-cannot-be-treasury");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address safeEngine_,\n', '        address extraSurplusReceiver_,\n', '        address coinJoin_\n', '    ) public {\n', '        require(address(CoinJoinLike(coinJoin_).systemCoin()) != address(0), "StabilityFeeTreasury/null-system-coin");\n', '        require(extraSurplusReceiver_ != address(0), "StabilityFeeTreasury/null-surplus-receiver");\n', '        authorizedAccounts[msg.sender] = 1;\n', '        safeEngine                = SAFEEngineLike(safeEngine_);\n', '        extraSurplusReceiver      = extraSurplusReceiver_;\n', '        coinJoin                  = CoinJoinLike(coinJoin_);\n', '        systemCoin                = SystemCoinLike(coinJoin.systemCoin());\n', '        latestSurplusTransferTime = now;\n', '        expensesMultiplier        = HUNDRED;\n', '        contractEnabled           = 1;\n', '        systemCoin.approve(address(coinJoin), uint256(-1));\n', '        emit AddAuthorization(msg.sender);\n', '    }\n', '\n', '    // --- Math ---\n', '    uint256 constant HUNDRED = 10 ** 2;\n', '    uint256 constant RAY     = 10 ** 27;\n', '\n', '    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x + y;\n', '        require(z >= x, "StabilityFeeTreasury/add-uint-uint-overflow");\n', '    }\n', '    function addition(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x + y;\n', '        if (y <= 0) require(z <= x, "StabilityFeeTreasury/add-int-int-underflow");\n', '        if (y  > 0) require(z > x, "StabilityFeeTreasury/add-int-int-overflow");\n', '    }\n', '    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "StabilityFeeTreasury/sub-uint-uint-underflow");\n', '    }\n', '    function subtract(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x - y;\n', '        require(y <= 0 || z <= x, "StabilityFeeTreasury/sub-int-int-underflow");\n', '        require(y >= 0 || z >= x, "StabilityFeeTreasury/sub-int-int-overflow");\n', '    }\n', '    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "StabilityFeeTreasury/mul-uint-uint-overflow");\n', '    }\n', '    function divide(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "StabilityFeeTreasury/div-y-null");\n', '        z = x / y;\n', '        require(z <= x, "StabilityFeeTreasury/div-invalid");\n', '    }\n', '    function minimum(uint256 x, uint256 y) internal view returns (uint256 z) {\n', '        z = (x <= y) ? x : y;\n', '    }\n', '\n', '    // --- Administration ---\n', '    /**\n', '     * @notice Modify contract addresses\n', '     * @param parameter The name of the contract whose address will be changed\n', '     * @param addr New address for the contract\n', '     */\n', '    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n', '        require(contractEnabled == 1, "StabilityFeeTreasury/contract-not-enabled");\n', '        require(addr != address(0), "StabilityFeeTreasury/null-addr");\n', '        if (parameter == "extraSurplusReceiver") {\n', '          require(addr != address(this), "StabilityFeeTreasury/accounting-engine-cannot-be-treasury");\n', '          extraSurplusReceiver = addr;\n', '        }\n', '        else revert("StabilityFeeTreasury/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, addr);\n', '    }\n', '    /**\n', '     * @notice Modify uint256 parameters\n', '     * @param parameter The name of the parameter to modify\n', '     * @param val New parameter value\n', '     */\n', '    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n', '        require(contractEnabled == 1, "StabilityFeeTreasury/not-live");\n', '        if (parameter == "expensesMultiplier") expensesMultiplier = val;\n', '        else if (parameter == "treasuryCapacity") {\n', '          require(val >= minimumFundsRequired, "StabilityFeeTreasury/capacity-lower-than-min-funds");\n', '          treasuryCapacity = val;\n', '        }\n', '        else if (parameter == "minimumFundsRequired") {\n', '          require(val <= treasuryCapacity, "StabilityFeeTreasury/min-funds-higher-than-capacity");\n', '          minimumFundsRequired = val;\n', '        }\n', '        else if (parameter == "pullFundsMinThreshold") {\n', '          pullFundsMinThreshold = val;\n', '        }\n', '        else if (parameter == "surplusTransferDelay") surplusTransferDelay = val;\n', '        else revert("StabilityFeeTreasury/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, val);\n', '    }\n', '    /**\n', '     * @notice Disable this contract (normally called by GlobalSettlement)\n', '     */\n', '    function disableContract() external isAuthorized {\n', '        require(contractEnabled == 1, "StabilityFeeTreasury/already-disabled");\n', '        contractEnabled = 0;\n', '        joinAllCoins();\n', '        safeEngine.transferInternalCoins(address(this), extraSurplusReceiver, safeEngine.coinBalance(address(this)));\n', '        emit DisableContract();\n', '    }\n', '\n', '    // --- Utils ---\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '    /**\n', '     * @notice Join all ERC20 system coins that the treasury has inside SAFEEngine\n', '     */\n', '    function joinAllCoins() internal {\n', '        if (systemCoin.balanceOf(address(this)) > 0) {\n', '          coinJoin.join(address(this), systemCoin.balanceOf(address(this)));\n', '        }\n', '    }\n', '    function settleDebt() public {\n', '        uint256 coinBalanceSelf = safeEngine.coinBalance(address(this));\n', '        uint256 debtBalanceSelf = safeEngine.debtBalance(address(this));\n', '\n', '        if (debtBalanceSelf > 0) {\n', '          safeEngine.settleDebt(minimum(coinBalanceSelf, debtBalanceSelf));\n', '        }\n', '    }\n', '\n', '    // --- Getters ---\n', '    function getAllowance(address account) public view returns (uint256, uint256) {\n', '        return (allowance[account].total, allowance[account].perBlock);\n', '    }\n', '\n', '    // --- SF Transfer Allowance ---\n', '    /**\n', "     * @notice Modify an address' total allowance in order to withdraw SF from the treasury\n", '     * @param account The approved address\n', '     * @param rad The total approved amount of SF to withdraw (number with 45 decimals)\n', '     */\n', '    function setTotalAllowance(address account, uint256 rad) external isAuthorized accountNotTreasury(account) {\n', '        require(account != address(0), "StabilityFeeTreasury/null-account");\n', '        allowance[account].total = rad;\n', '        emit SetTotalAllowance(account, rad);\n', '    }\n', '    /**\n', "     * @notice Modify an address' per block allowance in order to withdraw SF from the treasury\n", '     * @param account The approved address\n', '     * @param rad The per block approved amount of SF to withdraw (number with 45 decimals)\n', '     */\n', '    function setPerBlockAllowance(address account, uint256 rad) external isAuthorized accountNotTreasury(account) {\n', '        require(account != address(0), "StabilityFeeTreasury/null-account");\n', '        allowance[account].perBlock = rad;\n', '        emit SetPerBlockAllowance(account, rad);\n', '    }\n', '\n', '    // --- Stability Fee Transfer (Governance) ---\n', '    /**\n', '     * @notice Governance transfers SF to an address\n', '     * @param account Address to transfer SF to\n', '     * @param rad Amount of internal system coins to transfer (a number with 45 decimals)\n', '     */\n', '    function giveFunds(address account, uint256 rad) external isAuthorized accountNotTreasury(account) {\n', '        require(account != address(0), "StabilityFeeTreasury/null-account");\n', '\n', '        joinAllCoins();\n', '        settleDebt();\n', '\n', '        require(safeEngine.debtBalance(address(this)) == 0, "StabilityFeeTreasury/outstanding-bad-debt");\n', '        require(safeEngine.coinBalance(address(this)) >= rad, "StabilityFeeTreasury/not-enough-funds");\n', '\n', '        if (account != extraSurplusReceiver) {\n', '          expensesAccumulator = addition(expensesAccumulator, rad);\n', '        }\n', '\n', '        safeEngine.transferInternalCoins(address(this), account, rad);\n', '        emit GiveFunds(account, rad, expensesAccumulator);\n', '    }\n', '    /**\n', '     * @notice Governance takes funds from an address\n', '     * @param account Address to take system coins from\n', '     * @param rad Amount of internal system coins to take from the account (a number with 45 decimals)\n', '     */\n', '    function takeFunds(address account, uint256 rad) external isAuthorized accountNotTreasury(account) {\n', '        safeEngine.transferInternalCoins(account, address(this), rad);\n', '        emit TakeFunds(account, rad);\n', '    }\n', '\n', '    // --- Stability Fee Transfer (Approved Accounts) ---\n', '    /**\n', '     * @notice Pull stability fees from the treasury (if your allowance permits)\n', '     * @param dstAccount Address to transfer funds to\n', '     * @param token Address of the token to transfer (in this case it must be the address of the ERC20 system coin).\n', '     *              Used only to adhere to a standard for automated, on-chain treasuries\n', '     * @param wad Amount of system coins (SF) to transfer (expressed as an 18 decimal number but the contract will transfer\n', '              internal system coins that have 45 decimals)\n', '     */\n', '    function pullFunds(address dstAccount, address token, uint256 wad) external {\n', '        if (dstAccount == address(this)) return;\n', '\t      require(allowance[msg.sender].total >= wad, "StabilityFeeTreasury/not-allowed");\n', '        require(dstAccount != address(0), "StabilityFeeTreasury/null-dst");\n', '        require(dstAccount != extraSurplusReceiver, "StabilityFeeTreasury/dst-cannot-be-accounting");\n', '        require(wad > 0, "StabilityFeeTreasury/null-transfer-amount");\n', '        require(token == address(systemCoin), "StabilityFeeTreasury/token-unavailable");\n', '        if (allowance[msg.sender].perBlock > 0) {\n', '          require(addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY)) <= allowance[msg.sender].perBlock, "StabilityFeeTreasury/per-block-limit-exceeded");\n', '        }\n', '\n', '        pulledPerBlock[msg.sender][block.number] = addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY));\n', '\n', '        joinAllCoins();\n', '        settleDebt();\n', '\n', '        require(safeEngine.debtBalance(address(this)) == 0, "StabilityFeeTreasury/outstanding-bad-debt");\n', '        require(safeEngine.coinBalance(address(this)) >= multiply(wad, RAY), "StabilityFeeTreasury/not-enough-funds");\n', '        require(safeEngine.coinBalance(address(this)) >= pullFundsMinThreshold, "StabilityFeeTreasury/below-pullFunds-min-threshold");\n', '\n', '        // Update allowance and accumulator\n', '        allowance[msg.sender].total = subtract(allowance[msg.sender].total, multiply(wad, RAY));\n', '        expensesAccumulator         = addition(expensesAccumulator, multiply(wad, RAY));\n', '\n', '        // Transfer money\n', '        safeEngine.transferInternalCoins(address(this), dstAccount, multiply(wad, RAY));\n', '\n', '        emit PullFunds(msg.sender, dstAccount, token, multiply(wad, RAY), expensesAccumulator);\n', '    }\n', '\n', '    // --- Treasury Maintenance ---\n', '    /**\n', '     * @notice Transfer surplus stability fees to the AccountingEngine. This is here to make sure that the treasury\n', "               doesn't accumulate too many fees that it doesn't even need in order to pay for allowances. It ensures\n", '               that there are enough funds left in the treasury to account for projected expenses (latest expenses multiplied\n', '               by an expense multiplier)\n', '     */\n', '    function transferSurplusFunds() external {\n', '        require(now >= addition(latestSurplusTransferTime, surplusTransferDelay), "StabilityFeeTreasury/transfer-cooldown-not-passed");\n', '        // Compute latest expenses\n', '        uint256 latestExpenses = subtract(expensesAccumulator, accumulatorTag);\n', '        // Check if we need to keep more funds than the total capacity\n', '        uint256 remainingFunds =\n', '          (treasuryCapacity <= divide(multiply(expensesMultiplier, latestExpenses), HUNDRED)) ?\n', '          divide(multiply(expensesMultiplier, latestExpenses), HUNDRED) : treasuryCapacity;\n', '        // Make sure to keep at least minimum funds\n', '        remainingFunds = (divide(multiply(expensesMultiplier, latestExpenses), HUNDRED) <= minimumFundsRequired) ?\n', '                   minimumFundsRequired : remainingFunds;\n', '        // Set internal vars\n', '        accumulatorTag            = expensesAccumulator;\n', '        latestSurplusTransferTime = now;\n', '        // Join all coins in system\n', '        joinAllCoins();\n', '        // Settle outstanding bad debt\n', '        settleDebt();\n', "        // Check that there's no bad debt left\n", '        require(safeEngine.debtBalance(address(this)) == 0, "StabilityFeeTreasury/outstanding-bad-debt");\n', '        // Check if we have too much money\n', '        if (safeEngine.coinBalance(address(this)) > remainingFunds) {\n', '          // Make sure that we still keep min SF in treasury\n', '          uint256 fundsToTransfer = subtract(safeEngine.coinBalance(address(this)), remainingFunds);\n', '          // Transfer surplus to accounting engine\n', '          safeEngine.transferInternalCoins(address(this), extraSurplusReceiver, fundsToTransfer);\n', '          // Emit event\n', '          emit TransferSurplusFunds(extraSurplusReceiver, fundsToTransfer);\n', '        }\n', '    }\n', '}']