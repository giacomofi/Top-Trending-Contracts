['/* SPDX-License-Identifier: LGPL-3.0-or-later */\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./Admin.sol";\n', 'import "./Exponential.sol";\n', 'import "./Erc20Interface.sol";\n', 'import "./SafeErc20.sol";\n', 'import "./ReentrancyGuard.sol";\n', '\n', 'import "./BalanceSheetInterface.sol";\n', 'import "./FintrollerInterface.sol";\n', 'import "./FyTokenInterface.sol";\n', 'import "./ChainlinkOperatorInterface.sol";\n', '\n', '/**\n', ' * @title BalanceSheet\n', ' * @author Hifi\n', ' * @notice Manages the debt vault for all fyTokens.\n', ' */\n', 'contract BalanceSheet is\n', '    ReentrancyGuard, /* no depedency */\n', '    BalanceSheetInterface, /* one dependency */\n', '    Admin, /* two dependencies */\n', '    Exponential /* two dependencies */\n', '{\n', '    using SafeErc20 for Erc20Interface;\n', '\n', '    modifier isVaultOpenForMsgSender(FyTokenInterface fyToken) {\n', '        require(vaults[address(fyToken)][msg.sender].isOpen, "ERR_VAULT_NOT_OPEN");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @param fintroller_ The address of the Fintroller contract.\n', '     */\n', '    constructor(FintrollerInterface fintroller_) Admin() {\n', '        /* Set the fyToken contract and sanity check it. */\n', '        fintroller = fintroller_;\n', '        fintroller.isFintroller();\n', '    }\n', '\n', '    /**\n', '     * CONSTANT FUNCTIONS\n', '     */\n', '\n', '    struct GetClutchableCollateralLocalVars {\n', '        MathError mathErr;\n', '        Exp clutchableCollateralAmountUpscaled;\n', '        uint256 clutchableCollateralAmount;\n', '        uint256 collateralPrecisionScalar;\n', '        uint256 collateralPriceUpscaled;\n', '        uint256 liquidationIncentiveMantissa;\n', '        Exp numerator;\n', '        uint256 oraclePricePrecisionScalar;\n', '        uint256 underlyingPriceUpscaled;\n', '    }\n', '\n', '    /**\n', '     * @notice Determines the amount of collateral that can be clutched when liquidating a borrow.\n', '     *\n', '     * @dev The formula applied:\n', '     * clutchedCollateral = repayAmount * liquidationIncentive * underlyingPriceUsd / collateralPriceUsd\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `repayAmount` must be non-zero.\n', '     *\n', '     * @param fyToken The fyToken to make the query against.\n', '     * @param repayAmount The amount of fyTokens to repay.\n', "     * @return The amount of clutchable collateral as uint256, specified in the collateral's decimal system.\n", '     */\n', '    function getClutchableCollateral(FyTokenInterface fyToken, uint256 repayAmount)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        GetClutchableCollateralLocalVars memory vars;\n', '\n', '        /* Avoid the zero edge cases. */\n', '        require(repayAmount > 0, "ERR_GET_CLUTCHABLE_COLLATERAL_ZERO");\n', '\n', '        /* When the liquidation incentive is zero, the end result would be zero anyways. */\n', '        vars.liquidationIncentiveMantissa = fintroller.liquidationIncentiveMantissa();\n', '        if (vars.liquidationIncentiveMantissa == 0) {\n', '            return 0;\n', '        }\n', '\n', '        /* Grab the upscaled USD price of the underlying. */\n', '        ChainlinkOperatorInterface oracle = fintroller.oracle();\n', '        vars.underlyingPriceUpscaled = oracle.getAdjustedPrice(fyToken.underlying().symbol());\n', '\n', '        /* Grab the upscaled USD price of the collateral. */\n', '        vars.collateralPriceUpscaled = oracle.getAdjustedPrice(fyToken.collateral().symbol());\n', '\n', '        /* Calculate the top part of the equation. */\n', '        (vars.mathErr, vars.numerator) = mulExp3(\n', '            Exp({ mantissa: repayAmount }),\n', '            Exp({ mantissa: vars.liquidationIncentiveMantissa }),\n', '            Exp({ mantissa: vars.underlyingPriceUpscaled })\n', '        );\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");\n', '\n', '        /* Calculate the mantissa form of the clutched collateral amount. */\n', '        (vars.mathErr, vars.clutchableCollateralAmountUpscaled) = divExp(\n', '            vars.numerator,\n', '            Exp({ mantissa: vars.collateralPriceUpscaled })\n', '        );\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");\n', '\n', '        /* If the precision scalar is not 1, calculate the final form of the clutched collateral amount. */\n', '        vars.collateralPrecisionScalar = fyToken.collateralPrecisionScalar();\n', '        if (vars.collateralPrecisionScalar != 1) {\n', '            (vars.mathErr, vars.clutchableCollateralAmount) = divUInt(\n', '                vars.clutchableCollateralAmountUpscaled.mantissa,\n', '                vars.collateralPrecisionScalar\n', '            );\n', '            require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_CLUTCHABLE_COLLATERAL_MATH_ERROR");\n', '        } else {\n', '            vars.clutchableCollateralAmount = vars.clutchableCollateralAmountUpscaled.mantissa;\n', '        }\n', '\n', '        return vars.clutchableCollateralAmount;\n', '    }\n', '\n', '    /**\n', '     * @notice Determines the current collateralization ratio for the given borrower account.\n', '     * @param fyToken The fyToken to make the query against.\n', '     * @param borrower The borrower account to make the query against.\n', '     * @return A quotient if locked collateral is non-zero, otherwise zero.\n', '     */\n', '    function getCurrentCollateralizationRatio(FyTokenInterface fyToken, address borrower)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        Vault memory vault = vaults[address(fyToken)][borrower];\n', '        return getHypotheticalCollateralizationRatio(fyToken, borrower, vault.lockedCollateral, vault.debt);\n', '    }\n', '\n', '    struct GetHypotheticalAccountLiquidityLocalVars {\n', '        MathError mathErr;\n', '        uint256 collateralPriceUpscaled;\n', '        uint256 collateralPrecisionScalar;\n', '        uint256 collateralizationRatioMantissa;\n', '        Exp debtValueUsd;\n', '        Exp hypotheticalCollateralizationRatio;\n', '        Exp lockedCollateralValueUsd;\n', '        uint256 lockedCollateralUpscaled;\n', '        uint256 oraclePricePrecisionScalar;\n', '        uint256 underlyingPriceUpscaled;\n', '        uint256 underlyingPrecisionScalar;\n', '    }\n', '\n', '    /**\n', '     * @notice Determines the hypothetical collateralization ratio for the given locked\n', '     * collateral and debt, at the current prices provided by the oracle.\n', '     *\n', '     * @dev The formula applied: collateralizationRatio = lockedCollateralValueUsd / debtValueUsd\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault must be open.\n', '     * - `debt` must be non-zero.\n', '     * - The oracle prices must be non-zero.\n', '     *\n', '     * @param fyToken The fyToken for which to make the query against.\n', '     * @param borrower The borrower account for which to make the query against.\n', '     * @param lockedCollateral The hypothetical locked collateral.\n', '     * @param debt The hypothetical debt.\n', '     * @return The hypothetical collateralization ratio as a percentage mantissa if locked\n', '     * collateral is non-zero, otherwise zero.\n', '     */\n', '    function getHypotheticalCollateralizationRatio(\n', '        FyTokenInterface fyToken,\n', '        address borrower,\n', '        uint256 lockedCollateral,\n', '        uint256 debt\n', '    ) public view override returns (uint256) {\n', '        GetHypotheticalAccountLiquidityLocalVars memory vars;\n', '\n', '        /* If the vault is not open, a hypothetical collateralization ratio cannot be calculated. */\n', '        require(vaults[address(fyToken)][borrower].isOpen, "ERR_VAULT_NOT_OPEN");\n', '\n', '        /* Avoid the zero edge cases. */\n', '        if (lockedCollateral == 0) {\n', '            return 0;\n', '        }\n', '        require(debt > 0, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_DEBT_ZERO");\n', '\n', '        /* Grab the upscaled USD price of the collateral. */\n', '        ChainlinkOperatorInterface oracle = fintroller.oracle();\n', '        vars.collateralPriceUpscaled = oracle.getAdjustedPrice(fyToken.collateral().symbol());\n', '\n', '        /* Grab the upscaled USD price of the underlying. */\n', '        vars.underlyingPriceUpscaled = oracle.getAdjustedPrice(fyToken.underlying().symbol());\n', '\n', '        /* Upscale the collateral, which can have any precision, to mantissa precision. */\n', '        vars.collateralPrecisionScalar = fyToken.collateralPrecisionScalar();\n', '        if (vars.collateralPrecisionScalar != 1) {\n', '            (vars.mathErr, vars.lockedCollateralUpscaled) = mulUInt(lockedCollateral, vars.collateralPrecisionScalar);\n', '            require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");\n', '        } else {\n', '            vars.lockedCollateralUpscaled = lockedCollateral;\n', '        }\n', '\n', '        /* Calculate the USD value of the collateral. */\n', '        (vars.mathErr, vars.lockedCollateralValueUsd) = mulExp(\n', '            Exp({ mantissa: vars.lockedCollateralUpscaled }),\n', '            Exp({ mantissa: vars.collateralPriceUpscaled })\n', '        );\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");\n', '\n', '        /* Calculate the USD value of the debt. */\n', '        (vars.mathErr, vars.debtValueUsd) = mulExp(\n', '            Exp({ mantissa: debt }),\n', '            Exp({ mantissa: vars.underlyingPriceUpscaled })\n', '        );\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");\n', '\n', '        /**\n', '         * Calculate the collateralization ratio by dividing the USD value of the hypothetical locked collateral by\n', '         * the USD value of the debt.\n', '         */\n', '        (vars.mathErr, vars.hypotheticalCollateralizationRatio) = divExp(\n', '            vars.lockedCollateralValueUsd,\n', '            vars.debtValueUsd\n', '        );\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_GET_HYPOTHETICAL_COLLATERALIZATION_RATIO_MATH_ERROR");\n', '\n', '        return vars.hypotheticalCollateralizationRatio.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @notice Reads the storage properties of a vault.\n', '     * @return (uint256 debt, uint256 freeCollateral, uint256 lockedCollateral, bool isOpen).\n', '     */\n', '    function getVault(FyTokenInterface fyToken, address borrower)\n', '        external\n', '        view\n', '        override\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        )\n', '    {\n', '        return (\n', '            vaults[address(fyToken)][borrower].debt,\n', '            vaults[address(fyToken)][borrower].freeCollateral,\n', '            vaults[address(fyToken)][borrower].lockedCollateral,\n', '            vaults[address(fyToken)][borrower].isOpen\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Reads the debt held by the given account.\n', '     * @return The debt held by the borrower, as an uint256.\n', '     */\n', '    function getVaultDebt(FyTokenInterface fyToken, address borrower) external view override returns (uint256) {\n', '        return vaults[address(fyToken)][borrower].debt;\n', '    }\n', '\n', '    /**\n', '     * @notice Reads the amount of collateral that the given borrower account locked in the vault.\n', '     * @return The collateral locked in the vault by the borrower, as an uint256.\n', '     */\n', '    function getVaultLockedCollateral(FyTokenInterface fyToken, address borrower)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return vaults[address(fyToken)][borrower].lockedCollateral;\n', '    }\n', '\n', '    /**\n', '     * @notice Checks whether the borrower account can be liquidated or not.\n', '     * @param fyToken The fyToken for which to make the query against.\n', '     * @param borrower The borrower account for which to make the query against.\n', '     * @return bool true = is underwater, otherwise not.\n', '     */\n', '    function isAccountUnderwater(FyTokenInterface fyToken, address borrower) external view override returns (bool) {\n', '        Vault memory vault = vaults[address(fyToken)][borrower];\n', '        if (!vault.isOpen || vault.debt == 0) {\n', '            return false;\n', '        }\n', '        uint256 currentCollateralizationRatioMantissa = getCurrentCollateralizationRatio(fyToken, borrower);\n', '        uint256 thresholdCollateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(fyToken);\n', '        return currentCollateralizationRatioMantissa < thresholdCollateralizationRatioMantissa;\n', '    }\n', '\n', '    /**\n', '     * @notice Checks whether the borrower account has a vault opened for a particular fyToken.\n', '     */\n', '    function isVaultOpen(FyTokenInterface fyToken, address borrower) external view override returns (bool) {\n', '        return vaults[address(fyToken)][borrower].isOpen;\n', '    }\n', '\n', '    /**\n', '     * NON-CONSTANT FUNCTIONS\n', '     */\n', '\n', '    /**\n', "     * @notice Transfers the collateral from the borrower's vault to the liquidator account.\n", '     *\n', '     * @dev Emits a {ClutchCollateral} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - Can only be called by the fyToken.\n', "     * - There must be enough collateral in the borrower's vault.\n", '     *\n', '     * @param fyToken The address of the fyToken contract.\n', "     * @param liquidator The account who repays the borrower's debt and receives the collateral.\n", '     * @param borrower The account who fell underwater and is liquidated.\n', "     * @param collateralAmount The amount of collateral to clutch, specified in the collateral's decimal system.\n", '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function clutchCollateral(\n', '        FyTokenInterface fyToken,\n', '        address liquidator,\n', '        address borrower,\n', '        uint256 collateralAmount\n', '    ) external override nonReentrant returns (bool) {\n', '        /* Checks: the caller is the fyToken. */\n', '        require(msg.sender == address(fyToken), "ERR_CLUTCH_COLLATERAL_NOT_AUTHORIZED");\n', '\n', '        /* Checks: there is enough clutchable collateral in the vault. */\n', '        uint256 lockedCollateral = vaults[address(fyToken)][borrower].lockedCollateral;\n', '        require(lockedCollateral >= collateralAmount, "ERR_INSUFFICIENT_LOCKED_COLLATERAL");\n', '\n', '        /* Calculate the new locked collateral amount. */\n', '        MathError mathErr;\n', '        uint256 newLockedCollateral;\n', '        (mathErr, newLockedCollateral) = subUInt(lockedCollateral, collateralAmount);\n', '        assert(mathErr == MathError.NO_ERROR);\n', '\n', '        /* Effects: update the vault. */\n', '        vaults[address(fyToken)][borrower].lockedCollateral = newLockedCollateral;\n', '\n', '        /* Interactions: transfer the collateral. */\n', '        fyToken.collateral().safeTransfer(liquidator, collateralAmount);\n', '\n', '        emit ClutchCollateral(fyToken, liquidator, borrower, collateralAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @notice Deposits collateral into the account's vault.\n", '     *\n', '     * @dev Emits a {DepositCollateral} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault must be open.\n', '     * - The amount to deposit cannot be zero.\n', '     * - The Fintroller must allow this action to be performed.\n', '     * - The caller must have allowed this contract to spend `collateralAmount` tokens.\n', '     *\n', '     * @param fyToken The address of the fyToken contract.\n', '     * @param collateralAmount The amount of collateral to deposit.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function depositCollateral(FyTokenInterface fyToken, uint256 collateralAmount)\n', '        external\n', '        override\n', '        isVaultOpenForMsgSender(fyToken)\n', '        nonReentrant\n', '        returns (bool)\n', '    {\n', '        /* Checks: the zero edge case. */\n', '        require(collateralAmount > 0, "ERR_DEPOSIT_COLLATERAL_ZERO");\n', '\n', '        /* Checks: the Fintroller allows this action to be performed. */\n', '        require(fintroller.getDepositCollateralAllowed(fyToken), "ERR_DEPOSIT_COLLATERAL_NOT_ALLOWED");\n', '\n', '        /* Effects: update storage. */\n', '        MathError mathErr;\n', '        uint256 hypotheticalFreeCollateral;\n', '        (mathErr, hypotheticalFreeCollateral) = addUInt(\n', '            vaults[address(fyToken)][msg.sender].freeCollateral,\n', '            collateralAmount\n', '        );\n', '        require(mathErr == MathError.NO_ERROR, "ERR_DEPOSIT_COLLATERAL_MATH_ERROR");\n', '        vaults[address(fyToken)][msg.sender].freeCollateral = hypotheticalFreeCollateral;\n', '\n', '        /* Interactions: perform the Erc20 transfer. */\n', '        fyToken.collateral().safeTransferFrom(msg.sender, address(this), collateralAmount);\n', '\n', '        emit DepositCollateral(fyToken, msg.sender, collateralAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    struct FreeCollateralLocalVars {\n', '        MathError mathErr;\n', '        uint256 collateralizationRatioMantissa;\n', '        uint256 hypotheticalCollateralizationRatioMantissa;\n', '        uint256 newFreeCollateral;\n', '        uint256 newLockedCollateral;\n', '    }\n', '\n', '    /**\n', '     * @notice Frees a portion or all of the locked collateral.\n', '     * @dev Emits a {FreeCollateral} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault must be open.\n', '     * - The amount to free cannot be zero.\n', '     * - There must be enough locked collateral.\n', '     * - The borrower account cannot fall below the collateralization ratio.\n', '     *\n', '     * @param fyToken The address of the fyToken contract.\n', '     * @param collateralAmount The amount of locked collateral to free.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function freeCollateral(FyTokenInterface fyToken, uint256 collateralAmount)\n', '        external\n', '        override\n', '        isVaultOpenForMsgSender(fyToken)\n', '        returns (bool)\n', '    {\n', '        FreeCollateralLocalVars memory vars;\n', '\n', '        /* Checks: the zero edge case. */\n', '        require(collateralAmount > 0, "ERR_FREE_COLLATERAL_ZERO");\n', '\n', '        /* Checks: enough locked collateral. */\n', '        Vault memory vault = vaults[address(fyToken)][msg.sender];\n', '        require(vault.lockedCollateral >= collateralAmount, "ERR_INSUFFICIENT_LOCKED_COLLATERAL");\n', '\n', "        /* This operation can't fail because of the first `require` in this function. */\n", '        (vars.mathErr, vars.newLockedCollateral) = subUInt(vault.lockedCollateral, collateralAmount);\n', '        assert(vars.mathErr == MathError.NO_ERROR);\n', '\n', '        /* Checks: the hypothetical collateralization ratio is above the threshold. */\n', '        if (vault.debt > 0) {\n', '            vars.hypotheticalCollateralizationRatioMantissa = getHypotheticalCollateralizationRatio(\n', '                fyToken,\n', '                msg.sender,\n', '                vars.newLockedCollateral,\n', '                vault.debt\n', '            );\n', '            vars.collateralizationRatioMantissa = fintroller.getBondCollateralizationRatio(fyToken);\n', '            require(\n', '                vars.hypotheticalCollateralizationRatioMantissa >= vars.collateralizationRatioMantissa,\n', '                "ERR_BELOW_COLLATERALIZATION_RATIO"\n', '            );\n', '        }\n', '\n', '        /* Effects: update storage. */\n', '        vaults[address(fyToken)][msg.sender].lockedCollateral = vars.newLockedCollateral;\n', '        (vars.mathErr, vars.newFreeCollateral) = addUInt(vault.freeCollateral, collateralAmount);\n', '        require(vars.mathErr == MathError.NO_ERROR, "ERR_FREE_COLLATERAL_MATH_ERROR");\n', '        vaults[address(fyToken)][msg.sender].freeCollateral = vars.newFreeCollateral;\n', '\n', '        emit FreeCollateral(fyToken, msg.sender, collateralAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Locks a portion or all of the free collateral to make it eligible for borrowing.\n', '     * @dev Emits a {LockCollateral} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault must be open.\n', '     * - The amount to lock cannot be zero.\n', '     * - There must be enough free collateral.\n', '     *\n', '     * @param fyToken The address of the fyToken contract.\n', '     * @param collateralAmount The amount of free collateral to lock.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function lockCollateral(FyTokenInterface fyToken, uint256 collateralAmount)\n', '        external\n', '        override\n', '        isVaultOpenForMsgSender(fyToken)\n', '        returns (bool)\n', '    {\n', '        /* Avoid the zero edge case. */\n', '        require(collateralAmount > 0, "ERR_LOCK_COLLATERAL_ZERO");\n', '\n', '        Vault memory vault = vaults[address(fyToken)][msg.sender];\n', '        require(vault.freeCollateral >= collateralAmount, "ERR_INSUFFICIENT_FREE_COLLATERAL");\n', '\n', '        MathError mathErr;\n', '        uint256 newLockedCollateral;\n', '        (mathErr, newLockedCollateral) = addUInt(vault.lockedCollateral, collateralAmount);\n', '        require(mathErr == MathError.NO_ERROR, "ERR_LOCK_COLLATERAL_MATH_ERROR");\n', '        vaults[address(fyToken)][msg.sender].lockedCollateral = newLockedCollateral;\n', '\n', "        /* This operation can't fail because of the first `require` in this function. */\n", '        uint256 hypotheticalFreeCollateral;\n', '        (mathErr, hypotheticalFreeCollateral) = subUInt(vault.freeCollateral, collateralAmount);\n', '        assert(mathErr == MathError.NO_ERROR);\n', '        vaults[address(fyToken)][msg.sender].freeCollateral = hypotheticalFreeCollateral;\n', '\n', '        emit LockCollateral(fyToken, msg.sender, collateralAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Opens a Vault for the caller.\n', '     * @dev Emits an {OpenVault} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault cannot be already open.\n', '     * - The fyToken must pass the inspection.\n', '     *\n', '     * @param fyToken The address of the fyToken contract for which to open the vault.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function openVault(FyTokenInterface fyToken) external override returns (bool) {\n', '        require(fyToken.isFyToken(), "ERR_OPEN_VAULT_FYTOKEN_INSPECTION");\n', '        require(vaults[address(fyToken)][msg.sender].isOpen == false, "ERR_VAULT_OPEN");\n', '        vaults[address(fyToken)][msg.sender].isOpen = true;\n', '        emit OpenVault(fyToken, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Updates the debt accrued by a particular borrower account.\n', '     *\n', '     * @dev Emits a {SetVaultDebt} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - Can only be called by the fyToken.\n', '     *\n', '     * @param fyToken The address of the fyToken contract.\n', '     * @param borrower The borrower account for which to update the debt.\n', '     * @param newVaultDebt The new debt to assign to the borrower account.\n', '     * @return bool=true success, otherwise it reverts.\n', '     */\n', '    function setVaultDebt(\n', '        FyTokenInterface fyToken,\n', '        address borrower,\n', '        uint256 newVaultDebt\n', '    ) external override returns (bool) {\n', '        /* Checks: the caller is the fyToken. */\n', '        require(msg.sender == address(fyToken), "ERR_SET_VAULT_DEBT_NOT_AUTHORIZED");\n', '\n', '        /* Effects: update storage. */\n', '        uint256 oldVaultDebt = vaults[address(fyToken)][borrower].debt;\n', '        vaults[address(fyToken)][borrower].debt = newVaultDebt;\n', '\n', '        emit SetVaultDebt(fyToken, borrower, oldVaultDebt, newVaultDebt);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraws a portion or all of the free collateral.\n', '     *\n', '     * @dev Emits a {WithdrawCollateral} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The vault must be open.\n', '     * - The amount to withdraw cannot be zero.\n', '     * - There must be enough free collateral in the vault.\n', '     *\n', '     * @param fyToken The address of the fyToken contract.\n', '     * @param collateralAmount The amount of collateral to withdraw.\n', '     * @return bool true = success, otherwise it reverts.\n', '     */\n', '    function withdrawCollateral(FyTokenInterface fyToken, uint256 collateralAmount)\n', '        external\n', '        override\n', '        isVaultOpenForMsgSender(fyToken)\n', '        nonReentrant\n', '        returns (bool)\n', '    {\n', '        /* Checks: the zero edge case. */\n', '        require(collateralAmount > 0, "ERR_WITHDRAW_COLLATERAL_ZERO");\n', '\n', '        /* Checks: there is enough free collateral. */\n', '        require(\n', '            vaults[address(fyToken)][msg.sender].freeCollateral >= collateralAmount,\n', '            "ERR_INSUFFICIENT_FREE_COLLATERAL"\n', '        );\n', '\n', '        /* Effects: update storage. */\n', '        MathError mathErr;\n', '        uint256 newFreeCollateral;\n', '        (mathErr, newFreeCollateral) = subUInt(vaults[address(fyToken)][msg.sender].freeCollateral, collateralAmount);\n', "        /* This operation can't fail because of the first `require` in this function. */\n", '        assert(mathErr == MathError.NO_ERROR);\n', '        vaults[address(fyToken)][msg.sender].freeCollateral = newFreeCollateral;\n', '\n', '        /* Interactions: perform the Erc20 transfer. */\n', '        fyToken.collateral().safeTransfer(msg.sender, collateralAmount);\n', '\n', '        emit WithdrawCollateral(fyToken, msg.sender, collateralAmount);\n', '\n', '        return true;\n', '    }\n', '}']