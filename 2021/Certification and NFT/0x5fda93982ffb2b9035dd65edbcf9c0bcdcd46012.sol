['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-03\n', '*/\n', '\n', '// Copyright 2020 Opera Norway AS\n', '//\n', '// Redistribution and use in source and binary forms, with or without modification, are permitted\n', '// provided that the following conditions are met:\n', '// 1. Redistributions of source code must retain the above copyright notice, this list of\n', '//    conditions and the following disclaimer.\n', '// 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n', '//    conditions and the following disclaimer in the documentation and/or other materials provided\n', '//    with the distribution.\n', '// 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n', '//    endorse or promote products derived from this software without specific prior written\n', '//    permission.\n', '//\n', '// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS\n', '// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n', '// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n', '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n', '// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n', '// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n', '// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n', '// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n', '// POSSIBILITY OF SUCH DAMAGE.\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'abstract contract DaiLike {\n', '    function transferFrom(address src, address dst, uint wad) public virtual;\n', '\n', '    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n', '                    bool allowed, uint8 v, bytes32 r, bytes32 s) external virtual;\n', '\n', '    mapping (address => mapping (address => uint)) public allowance;\n', '    mapping (address => uint)                      public balanceOf;\n', '    mapping (address => uint)                      public  nonces;\n', '\n', '    string public name;\n', '    string public constant version  = "1";\n', '}\n', '\n', 'contract DaiProxy {\n', '    DaiLike public dai;\n', '\n', '    // Auth\n', '    address public owner;\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Proxy/NotAuthorized");\n', '        _;\n', '    }\n', '\n', '    mapping (address => uint) public relayers;\n', '    modifier onlyRelayer {\n', '        require(relayers[msg.sender] == 1, "Proxy/InvalidRelayer");\n', '        _;\n', '    }\n', '    function addRelayer(address relayer_) external onlyOwner {\n', '        require(relayer_ != address(0));\n', '        relayers[relayer_] = 1;\n', '    }\n', '    function removeRelayer(address relayer_) external onlyOwner {\n', '        require(relayer_ != address(0));\n', '        relayers[relayer_] = 0;\n', '    }\n', '\n', '    address public feeRecipient;\n', '    function setFeeRecipient(address feeRecipient_) external onlyOwner {\n', '        require(feeRecipient_ != address(0));\n', '        feeRecipient = feeRecipient_;\n', '    }\n', '\n', '    constructor (DaiLike dai_, address relayer_, address feeRecipient_) public {\n', '        require(address(dai_) != address(0));\n', '        require(relayer_ != address(0));\n', '        require(feeRecipient_ != address(0));\n', '        require(feeRecipient_ != address(this));\n', '        DOMAIN_SEPARATOR = keccak256(abi.encode(\n', '            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '            keccak256(bytes(name)),\n', '            keccak256(bytes(version)),\n', '            getChainID(),\n', '            address(this)\n', '        ));\n', '\n', '        dai = dai_;\n', '        owner = msg.sender;\n', '        relayers[relayer_] = 1;\n', '        feeRecipient = feeRecipient_;\n', '    }\n', '\n', '    // Safe math helpers, throws on under/overflow\n', '    function safeAdd(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function safeSub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    // EIP712\n', '    string  public constant name    = "DaiProxy";\n', '    string  public constant version = "1.0";\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    bytes32 public constant TRANSFER_TYPEHASH = keccak256("Transfer(address sender,address recipient,uint256 amount,uint256 fee,uint256 expiry,uint256 nonce)");\n', '\n', '    mapping (address => uint256) public nonces;\n', '\n', '    // Transfer dai from src to dst. Takes both a signature for permit and\n', '    // transfer so they can always be done in one transaction. Permit will\n', '    // only be done when needed.\n', '    // The permit can be revoked by calling the approve() method in the DAI\n', '    // contract.\n', '    function permitAndTransfer(\n', '        address sender, address recipient, uint256 amount, uint256 fee, uint256 expiry,\n', '        uint256 nonce, uint8 v, bytes32 r, bytes32 s,\n', '        uint256 p_nonce, uint8 p_v, bytes32 p_r, bytes32 p_s)\n', '        onlyRelayer external {\n', '\n', '        if (safeAdd(amount, fee) >= dai.allowance(sender, address(this))) {\n', '            dai.permit(sender, address(this), p_nonce, expiry, true, p_v, p_r, p_s);\n', '        }\n', '\n', '        transfer(sender, recipient, amount, fee, expiry, nonce, v, r, s);\n', '    }\n', '\n', '    function transfer(\n', '        address sender, address recipient, uint256 amount, uint256 fee, uint256 expiry,\n', '        uint256 nonce, uint8 v, bytes32 r, bytes32 s)\n', '        onlyRelayer public {\n', '\n', '        bytes32 digest =\n', '            keccak256(abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                keccak256(abi.encode(TRANSFER_TYPEHASH,\n', '                                     sender,\n', '                                     recipient,\n', '                                     amount,\n', '                                     fee,\n', '                                     expiry,\n', '                                     nonce))\n', '        ));\n', '\n', '        require(sender != address(0), "Proxy/invalid src address");\n', '        require(recipient != address(0), "Proxy/invalid dst address");\n', '        require(nonce == nonces[sender]++, "Proxy/invalid nonce");\n', '        require(safeAdd(amount, fee) <= dai.balanceOf(sender), "Proxy/insufficient funds");\n', '        require(sender == ecrecover(digest, v, r, s), "Proxy/invalid signature");\n', '        require(expiry == 0 || now <= expiry, "Proxy/permit-expired");\n', '\n', '        // Transfer fee to fee recipient\n', '        if (fee > 0) {\n', '            dai.transferFrom(sender, feeRecipient, fee);\n', '        }\n', '        dai.transferFrom(sender, recipient, amount);\n', '    }\n', '\n', '    function getChainID() private pure returns (uint256) {\n', '        uint256 id;\n', '        assembly {\n', '            id := chainid()\n', '        }\n', '        return id;\n', '    }\n', '}']