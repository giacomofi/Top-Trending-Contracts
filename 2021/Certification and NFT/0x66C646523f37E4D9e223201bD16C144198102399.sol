['// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'import "./IFilter.sol";\n', '\n', 'abstract contract BaseFilter is IFilter {\n', '    function getMethod(bytes memory _data) internal pure returns (bytes4 method) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            method := mload(add(_data, 0x20))\n', '        }\n', '    }\n', '}\n', '\n', '// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'interface IFilter {\n', '    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view returns (bool valid);\n', '}\n', '\n', '// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'import "./BaseFilter.sol";\n', '\n', 'contract UniswapV2UniZapFilter is BaseFilter {\n', '\n', '    bytes4 private constant ERC20_APPROVE = bytes4(keccak256("approve(address,uint256)"));\n', '    bytes4 constant internal ADD_LIQUIDITY_WITH_ETH = bytes4(keccak256("swapExactETHAndAddLiquidity(address,uint256,address,uint256)"));\n', '    bytes4 constant internal REMOVE_LIQUIDITY_TO_ETH = bytes4(keccak256("removeLiquidityAndSwapToETH(address,uint256,uint256,address,uint256)"));\n', '    bytes4 constant internal ADD_LIQUIDITY_WITH_TOKEN = bytes4(\n', '        keccak256(\n', '            "swapExactTokensAndAddLiquidity(address,address,uint256,uint256,address,uint256)"\n', '            )\n', '        );\n', '    bytes4 constant internal REMOVE_LIQUIDITY_TO_TOKEN = bytes4(\n', '        keccak256(\n', '            "removeLiquidityAndSwapToToken(address,address,uint256,uint256,address,uint256)"\n', '            )\n', '        );\n', '\n', '    // Token registry\n', '    address public immutable tokenRegistry;\n', '    // Uniswap V2 factory\n', '    address public immutable uniFactory;\n', '    // Uniswap v2 pair init code\n', '    bytes32 public immutable uniInitCode;\n', '    // WETH address\n', '    address public immutable weth;\n', '\n', '    constructor (address _tokenRegistry, address _uniFactory, bytes32 _uniInitCode, address _weth) {\n', '        tokenRegistry = _tokenRegistry;\n', '        uniFactory = _uniFactory;\n', '        uniInitCode = _uniInitCode;\n', '        weth = _weth;\n', '    }\n', '\n', '    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view override returns (bool valid) {\n', '        // not needed but detects failure early\n', '        if (_data.length < 4) {\n', '            return false;\n', '        }\n', '        bytes4 method = getMethod(_data);\n', '        // UniZap method: check that pair is valid and recipient is the wallet\n', '        if (_spender == _to) {\n', '            if (method == ADD_LIQUIDITY_WITH_TOKEN || method == REMOVE_LIQUIDITY_TO_TOKEN) {\n', '                (address tokenA, address tokenB, , , address recipient) = abi.decode(_data[4:], (address, address, uint256, uint256, address));\n', '                return isValidPair(tokenA, tokenB) && recipient == _wallet;\n', '            }\n', '            if (method == ADD_LIQUIDITY_WITH_ETH) {\n', '                (address token, , address recipient) = abi.decode(_data[4:], (address, uint256, address));\n', '                return isValidPair(token, weth) && recipient == _wallet;\n', '            }\n', '            if (method == REMOVE_LIQUIDITY_TO_ETH) {\n', '                (address token, , , address recipient) = abi.decode(_data[4:], (address, uint256, uint256, address));\n', '                return isValidPair(token, weth) && recipient == _wallet;\n', '            }\n', '         // ERC20 methods\n', '        } else {\n', '            // only allow approve\n', '            return (method == ERC20_APPROVE);\n', '        }\n', '    }\n', '\n', '    function isValidPair(address _tokenA, address _tokenB) internal view returns (bool) {\n', '        address pair = pairFor(_tokenA, _tokenB);\n', '        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature("isTokenTradable(address)", pair));\n', '        return success && abi.decode(res, (bool));\n', '    }\n', '\n', '    function pairFor(address _tokenA, address _tokenB) internal view returns (address) {\n', '        (address token0, address token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n', '        return(address(uint160(uint256(keccak256(abi.encodePacked(\n', '            hex"ff",\n', '            uniFactory,\n', '            keccak256(abi.encodePacked(token0, token1)),\n', '            uniInitCode\n', '        ))))));\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 999\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {\n', '    "": {}\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']