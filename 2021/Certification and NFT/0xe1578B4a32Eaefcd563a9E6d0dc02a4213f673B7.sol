['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// hevm: flattened sources of ./contracts/bondingcurve/EthBondingCurve.sol\n', 'pragma solidity >=0.4.0 >=0.6.0 <0.7.0 >=0.6.0 <0.8.0 >=0.6.2 <0.7.0 >=0.6.2 <0.8.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '////// ./contracts/external/SafeMathCopy.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity ^0.6.0; */\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMathCopy { // To avoid namespace collision between openzeppelin safemath and uniswap safemath\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '////// ./contracts/external/Decimal.sol\n', '/*\n', '    Copyright 2019 dYdX Trading Inc.\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./SafeMathCopy.sol"; */\n', '\n', '/**\n', ' * @title Decimal\n', ' * @author dYdX\n', ' *\n', ' * Library that defines a fixed-point number with 18 decimal places.\n', ' */\n', 'library Decimal {\n', '    using SafeMathCopy for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 private constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Static Functions ============\n', '\n', '    function zero()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: 0 });\n', '    }\n', '\n', '    function one()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: BASE });\n', '    }\n', '\n', '    function from(\n', '        uint256 a\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: a.mul(BASE) });\n', '    }\n', '\n', '    function ratio(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(a, BASE, b) });\n', '    }\n', '\n', '    // ============ Self Functions ============\n', '\n', '    function add(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.mul(BASE)) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.mul(BASE)) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        uint256 b,\n', '        string memory reason\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.mul(BASE), reason) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.mul(b) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.div(b) });\n', '    }\n', '\n', '    function pow(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        if (b == 0) {\n', '            return from(1);\n', '        }\n', '\n', '        D256 memory temp = D256({ value: self.value });\n', '        for (uint256 i = 1; i < b; i++) {\n', '            temp = mul(temp, self);\n', '        }\n', '\n', '        return temp;\n', '    }\n', '\n', '    function add(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.value) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.value) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        D256 memory b,\n', '        string memory reason\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.value, reason) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, b.value, BASE) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, BASE, b.value) });\n', '    }\n', '\n', '    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return self.value == b.value;\n', '    }\n', '\n', '    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 2;\n', '    }\n', '\n', '    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 0;\n', '    }\n', '\n', '    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) > 0;\n', '    }\n', '\n', '    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) < 2;\n', '    }\n', '\n', '    function isZero(D256 memory self) internal pure returns (bool) {\n', '        return self.value == 0;\n', '    }\n', '\n', '    function asUint256(D256 memory self) internal pure returns (uint256) {\n', '        return self.value.div(BASE);\n', '    }\n', '\n', '    // ============ Core Methods ============\n', '\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    function compareTo(\n', '        D256 memory a,\n', '        D256 memory b\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        if (a.value == b.value) {\n', '            return 1;\n', '        }\n', '        return a.value > b.value ? 2 : 0;\n', '    }\n', '}\n', '////// ./contracts/bondingcurve/IBondingCurve.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../external/Decimal.sol"; */\n', '\n', 'interface IBondingCurve {\n', '    // ----------- Events -----------\n', '\n', '    event ScaleUpdate(uint256 _scale);\n', '\n', '    event BufferUpdate(uint256 _buffer);\n', '\n', '    event IncentiveAmountUpdate(uint256 _incentiveAmount);\n', '\n', '    event Purchase(address indexed _to, uint256 _amountIn, uint256 _amountOut);\n', '\n', '    event Allocate(address indexed _caller, uint256 _amount);\n', '\n', '    // ----------- State changing Api -----------\n', '\n', '    function purchase(address to, uint256 amountIn)\n', '        external\n', '        payable\n', '        returns (uint256 amountOut);\n', '\n', '    function allocate() external;\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setBuffer(uint256 _buffer) external;\n', '\n', '    function setScale(uint256 _scale) external;\n', '\n', '    function setAllocation(\n', '        address[] calldata pcvDeposits,\n', '        uint256[] calldata ratios\n', '    ) external;\n', '\n', '    function setIncentiveAmount(uint256 _incentiveAmount) external;\n', '\n', '    function setIncentiveFrequency(uint256 _frequency) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function getCurrentPrice() external view returns (Decimal.D256 memory);\n', '\n', '    function getAverageUSDPrice(uint256 amountIn)\n', '        external\n', '        view\n', '        returns (Decimal.D256 memory);\n', '\n', '    function getAmountOut(uint256 amountIn)\n', '        external\n', '        view\n', '        returns (uint256 amountOut);\n', '\n', '    function scale() external view returns (uint256);\n', '\n', '    function atScale() external view returns (bool);\n', '\n', '    function buffer() external view returns (uint256);\n', '\n', '    function totalPurchased() external view returns (uint256);\n', '\n', '    function getTotalPCVHeld() external view returns (uint256);\n', '\n', '    function incentiveAmount() external view returns (uint256);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20_5 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '////// ./contracts/pcv/PCVSplitter.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../external/SafeMathCopy.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol"; */\n', '\n', '/// @title abstract contract for splitting PCV into different deposits\n', '/// @author Fei Protocol\n', 'abstract contract PCVSplitter {\n', '    using SafeMathCopy for uint256;\n', '\n', '    /// @notice total allocation allowed representing 100%\n', '    uint256 public constant ALLOCATION_GRANULARITY = 10_000;\n', '\n', '    uint256[] private ratios;\n', '    address[] private pcvDeposits;\n', '\n', '    event AllocationUpdate(address[] _pcvDeposits, uint256[] _ratios);\n', '\n', '    /// @notice PCVSplitter constructor\n', '    /// @param _pcvDeposits list of PCV Deposits to split to\n', '    /// @param _ratios ratios for splitting PCV Deposit allocations\n', '    constructor(address[] memory _pcvDeposits, uint256[] memory _ratios)\n', '        public\n', '    {\n', '        _setAllocation(_pcvDeposits, _ratios);\n', '    }\n', '\n', '    /// @notice make sure an allocation has matching lengths and totals the ALLOCATION_GRANULARITY\n', '    /// @param _pcvDeposits new list of pcv deposits to send to\n', '    /// @param _ratios new ratios corresponding to the PCV deposits\n', '    /// @return true if it is a valid allocation\n', '    function checkAllocation(\n', '        address[] memory _pcvDeposits,\n', '        uint256[] memory _ratios\n', '    ) public pure returns (bool) {\n', '        require(\n', '            _pcvDeposits.length == _ratios.length,\n', '            "PCVSplitter: PCV Deposits and ratios are different lengths"\n', '        );\n', '\n', '        uint256 total;\n', '        for (uint256 i; i < _ratios.length; i++) {\n', '            total = total.add(_ratios[i]);\n', '        }\n', '\n', '        require(\n', '            total == ALLOCATION_GRANULARITY,\n', '            "PCVSplitter: ratios do not total 100%"\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @notice gets the pcvDeposits and ratios of the splitter\n', '    function getAllocation()\n', '        public\n', '        view\n', '        returns (address[] memory, uint256[] memory)\n', '    {\n', '        return (pcvDeposits, ratios);\n', '    }\n', '\n', '    /// @notice distribute funds to single PCV deposit\n', '    /// @param amount amount of funds to send\n', '    /// @param pcvDeposit the pcv deposit to send funds\n', '    function _allocateSingle(uint256 amount, address pcvDeposit)\n', '        internal\n', '        virtual;\n', '\n', '    /// @notice sets a new allocation for the splitter\n', '    /// @param _pcvDeposits new list of pcv deposits to send to\n', '    /// @param _ratios new ratios corresponding to the PCV deposits. Must total ALLOCATION_GRANULARITY\n', '    function _setAllocation(\n', '        address[] memory _pcvDeposits,\n', '        uint256[] memory _ratios\n', '    ) internal {\n', '        checkAllocation(_pcvDeposits, _ratios);\n', '\n', '        pcvDeposits = _pcvDeposits;\n', '        ratios = _ratios;\n', '\n', '        emit AllocationUpdate(_pcvDeposits, _ratios);\n', '    }\n', '\n', '    /// @notice distribute funds to all pcv deposits at specified allocation ratios\n', '    /// @param total amount of funds to send\n', '    function _allocate(uint256 total) internal {\n', '        uint256 granularity = ALLOCATION_GRANULARITY;\n', '        for (uint256 i; i < ratios.length; i++) {\n', '            uint256 amount = total.mul(ratios[i]) / granularity;\n', '            _allocateSingle(amount, pcvDeposits[i]);\n', '        }\n', '    }\n', '}\n', '\n', '////// ./contracts/core/IPermissions.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/// @title Permissions interface\n', '/// @author Fei Protocol\n', 'interface IPermissions {\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function createRole(bytes32 role, bytes32 adminRole) external;\n', '\n', '    function grantMinter(address minter) external;\n', '\n', '    function grantBurner(address burner) external;\n', '\n', '    function grantPCVController(address pcvController) external;\n', '\n', '    function grantGovernor(address governor) external;\n', '\n', '    function grantGuardian(address guardian) external;\n', '\n', '    function revokeMinter(address minter) external;\n', '\n', '    function revokeBurner(address burner) external;\n', '\n', '    function revokePCVController(address pcvController) external;\n', '\n', '    function revokeGovernor(address governor) external;\n', '\n', '    function revokeGuardian(address guardian) external;\n', '\n', '    // ----------- Revoker only state changing api -----------\n', '\n', '    function revokeOverride(bytes32 role, address account) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function isBurner(address _address) external view returns (bool);\n', '\n', '    function isMinter(address _address) external view returns (bool);\n', '\n', '    function isGovernor(address _address) external view returns (bool);\n', '\n', '    function isGuardian(address _address) external view returns (bool);\n', '\n', '    function isPCVController(address _address) external view returns (bool);\n', '}\n', '\n', '////// ./contracts/token/IFei.sol\n', '/* pragma solidity ^0.6.2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol"; */\n', '\n', '/// @title FEI stablecoin interface\n', '/// @author Fei Protocol\n', 'interface IFei is IERC20_5 {\n', '    // ----------- Events -----------\n', '\n', '    event Minting(\n', '        address indexed _to,\n', '        address indexed _minter,\n', '        uint256 _amount\n', '    );\n', '\n', '    event Burning(\n', '        address indexed _to,\n', '        address indexed _burner,\n', '        uint256 _amount\n', '    );\n', '\n', '    event IncentiveContractUpdate(\n', '        address indexed _incentivized,\n', '        address indexed _incentiveContract\n', '    );\n', '\n', '    // ----------- State changing api -----------\n', '\n', '    function burn(uint256 amount) external;\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    // ----------- Burner only state changing api -----------\n', '\n', '    function burnFrom(address account, uint256 amount) external;\n', '\n', '    // ----------- Minter only state changing api -----------\n', '\n', '    function mint(address account, uint256 amount) external;\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setIncentiveContract(address account, address incentive) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function incentiveContract(address account) external view returns (address);\n', '}\n', '\n', '////// ./contracts/core/ICore.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IPermissions.sol"; */\n', '/* import "../token/IFei.sol"; */\n', '\n', '/// @title Core Interface\n', '/// @author Fei Protocol\n', 'interface ICore is IPermissions {\n', '    // ----------- Events -----------\n', '\n', '    event FeiUpdate(address indexed _fei);\n', '    event TribeUpdate(address indexed _tribe);\n', '    event GenesisGroupUpdate(address indexed _genesisGroup);\n', '    event TribeAllocation(address indexed _to, uint256 _amount);\n', '    event GenesisPeriodComplete(uint256 _timestamp);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function init() external;\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setFei(address token) external;\n', '\n', '    function setTribe(address token) external;\n', '\n', '    function setGenesisGroup(address _genesisGroup) external;\n', '\n', '    function allocateTribe(address to, uint256 amount) external;\n', '\n', '    // ----------- Genesis Group only state changing api -----------\n', '\n', '    function completeGenesisGroup() external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function fei() external view returns (IFei);\n', '\n', '    function tribe() external view returns (IERC20_5);\n', '\n', '    function genesisGroup() external view returns (address);\n', '\n', '    function hasGenesisGroupCompleted() external view returns (bool);\n', '}\n', '\n', '////// ./contracts/refs/ICoreRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../core/ICore.sol"; */\n', '\n', '/// @title CoreRef interface\n', '/// @author Fei Protocol\n', 'interface ICoreRef {\n', '    // ----------- Events -----------\n', '\n', '    event CoreUpdate(address indexed _core);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setCore(address core) external;\n', '\n', '    function pause() external;\n', '\n', '    function unpause() external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function core() external view returns (ICore);\n', '\n', '    function fei() external view returns (IFei);\n', '\n', '    function tribe() external view returns (IERC20_5);\n', '\n', '    function feiBalance() external view returns (uint256);\n', '\n', '    function tribeBalance() external view returns (uint256);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Address.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.2 <0.8.0; */\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address_2 {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Context.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context_2 {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Pausable.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/* import "./Context.sol"; */\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'abstract contract Pausable_2 is Context_2 {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view virtual returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused(), "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused(), "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '////// ./contracts/refs/CoreRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./ICoreRef.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Pausable.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Address.sol"; */\n', '\n', '/// @title A Reference to Core\n', '/// @author Fei Protocol\n', '/// @notice defines some modifiers and utilities around interacting with Core\n', 'abstract contract CoreRef is ICoreRef, Pausable_2 {\n', '    ICore private _core;\n', '\n', '    /// @notice CoreRef constructor\n', '    /// @param core Fei Core to reference\n', '    constructor(address core) public {\n', '        _core = ICore(core);\n', '    }\n', '\n', '    modifier ifMinterSelf() {\n', '        if (_core.isMinter(address(this))) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier ifBurnerSelf() {\n', '        if (_core.isBurner(address(this))) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(_core.isMinter(msg.sender), "CoreRef: Caller is not a minter");\n', '        _;\n', '    }\n', '\n', '    modifier onlyBurner() {\n', '        require(_core.isBurner(msg.sender), "CoreRef: Caller is not a burner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPCVController() {\n', '        require(\n', '            _core.isPCVController(msg.sender),\n', '            "CoreRef: Caller is not a PCV controller"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovernor() {\n', '        require(\n', '            _core.isGovernor(msg.sender),\n', '            "CoreRef: Caller is not a governor"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyGuardianOrGovernor() {\n', '        require(\n', '            _core.isGovernor(msg.sender) ||\n', '            _core.isGuardian(msg.sender),\n', '            "CoreRef: Caller is not a guardian or governor"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyFei() {\n', '        require(msg.sender == address(fei()), "CoreRef: Caller is not FEI");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGenesisGroup() {\n', '        require(\n', '            msg.sender == _core.genesisGroup(),\n', '            "CoreRef: Caller is not GenesisGroup"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier postGenesis() {\n', '        require(\n', '            _core.hasGenesisGroupCompleted(),\n', '            "CoreRef: Still in Genesis Period"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier nonContract() {\n', '        require(!Address_2.isContract(msg.sender), "CoreRef: Caller is a contract");\n', '        _;\n', '    }\n', '\n', '    /// @notice set new Core reference address\n', '    /// @param core the new core address\n', '    function setCore(address core) external override onlyGovernor {\n', '        _core = ICore(core);\n', '        emit CoreUpdate(core);\n', '    }\n', '\n', '    /// @notice set pausable methods to paused\n', '    function pause() public override onlyGuardianOrGovernor {\n', '        _pause();\n', '    }\n', '\n', '    /// @notice set pausable methods to unpaused\n', '    function unpause() public override onlyGuardianOrGovernor {\n', '        _unpause();\n', '    }\n', '\n', '    /// @notice address of the Core contract referenced\n', '    /// @return ICore implementation address\n', '    function core() public view override returns (ICore) {\n', '        return _core;\n', '    }\n', '\n', '    /// @notice address of the Fei contract referenced by Core\n', '    /// @return IFei implementation address\n', '    function fei() public view override returns (IFei) {\n', '        return _core.fei();\n', '    }\n', '\n', '    /// @notice address of the Tribe contract referenced by Core\n', '    /// @return IERC20 implementation address\n', '    function tribe() public view override returns (IERC20_5) {\n', '        return _core.tribe();\n', '    }\n', '\n', '    /// @notice fei balance of contract\n', '    /// @return fei amount held\n', '    function feiBalance() public view override returns (uint256) {\n', '        return fei().balanceOf(address(this));\n', '    }\n', '\n', '    /// @notice tribe balance of contract\n', '    /// @return tribe amount held\n', '    function tribeBalance() public view override returns (uint256) {\n', '        return tribe().balanceOf(address(this));\n', '    }\n', '\n', '    function _burnFeiHeld() internal {\n', '        fei().burn(feiBalance());\n', '    }\n', '\n', '    function _mintFei(uint256 amount) internal {\n', '        fei().mint(address(this), amount);\n', '    }\n', '}\n', '\n', '////// ./contracts/oracle/IOracle.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../external/Decimal.sol"; */\n', '\n', '/// @title generic oracle interface for Fei Protocol\n', '/// @author Fei Protocol\n', 'interface IOracle {\n', '    // ----------- Events -----------\n', '\n', '    event Update(uint256 _peg);\n', '\n', '    // ----------- State changing API -----------\n', '\n', '    function update() external returns (bool);\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function read() external view returns (Decimal.D256 memory, bool);\n', '\n', '    function isOutdated() external view returns (bool);\n', '\n', '}\n', '\n', '////// ./contracts/refs/IOracleRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../oracle/IOracle.sol"; */\n', '\n', '/// @title OracleRef interface\n', '/// @author Fei Protocol\n', 'interface IOracleRef {\n', '    // ----------- Events -----------\n', '\n', '    event OracleUpdate(address indexed _oracle);\n', '\n', '    // ----------- State changing API -----------\n', '\n', '    function updateOracle() external returns (bool);\n', '\n', '    // ----------- Governor only state changing API -----------\n', '\n', '    function setOracle(address _oracle) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function oracle() external view returns (IOracle);\n', '\n', '    function peg() external view returns (Decimal.D256 memory);\n', '\n', '    function invert(Decimal.D256 calldata price)\n', '        external\n', '        pure\n', '        returns (Decimal.D256 memory);\n', '}\n', '\n', '////// ./contracts/refs/OracleRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IOracleRef.sol"; */\n', '/* import "./CoreRef.sol"; */\n', '\n', '/// @title Reference to an Oracle\n', '/// @author Fei Protocol\n', '/// @notice defines some utilities around interacting with the referenced oracle\n', 'abstract contract OracleRef is IOracleRef, CoreRef {\n', '    using Decimal for Decimal.D256;\n', '\n', '    /// @notice the oracle reference by the contract\n', '    IOracle public override oracle;\n', '\n', '    /// @notice OracleRef constructor\n', '    /// @param _core Fei Core to reference\n', '    /// @param _oracle oracle to reference\n', '    constructor(address _core, address _oracle) public CoreRef(_core) {\n', '        _setOracle(_oracle);\n', '    }\n', '\n', '    /// @notice sets the referenced oracle\n', '    /// @param _oracle the new oracle to reference\n', '    function setOracle(address _oracle) external override onlyGovernor {\n', '        _setOracle(_oracle);\n', '    }\n', '\n', '    /// @notice invert a peg price\n', '    /// @param price the peg price to invert\n', '    /// @return the inverted peg as a Decimal\n', '    /// @dev the inverted peg would be X per FEI\n', '    function invert(Decimal.D256 memory price)\n', '        public\n', '        pure\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return Decimal.one().div(price);\n', '    }\n', '\n', '    /// @notice updates the referenced oracle\n', '    /// @return true if the update is effective\n', '    function updateOracle() public override returns (bool) {\n', '        return oracle.update();\n', '    }\n', '\n', '    /// @notice the peg price of the referenced oracle\n', '    /// @return the peg as a Decimal\n', '    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n', '    function peg() public view override returns (Decimal.D256 memory) {\n', '        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n', '        require(valid, "OracleRef: oracle invalid");\n', '        return _peg;\n', '    }\n', '\n', '    function _setOracle(address _oracle) internal {\n', '        oracle = IOracle(_oracle);\n', '        emit OracleUpdate(_oracle);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/lib/contracts/libraries/Babylonian.sol\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '/* pragma solidity >=0.4.0; */\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'library Babylonian_3 {\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', '////// ./contracts/utils/Roots.sol\n', '/* pragma solidity ^0.6.0; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/lib/contracts/libraries/Babylonian.sol"; */\n', '\n', 'library Roots {\n', "    // Newton's method https://en.wikipedia.org/wiki/Cube_root#Numerical_methods\n", '    function cubeRoot(uint256 y) internal pure returns (uint256 z) {\n', '        if (y > 7) {\n', '            z = y;\n', '            uint256 x = y / 3 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / (x * x) + (2 * x)) / 3;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '\n', '    function sqrt(uint256 y) internal pure returns (uint256) {\n', '        return Babylonian_3.sqrt(y);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/SafeCast.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast_2 {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '////// ./contracts/utils/Timed.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/SafeCast.sol"; */\n', '\n', '/// @title an abstract contract for timed events\n', '/// @author Fei Protocol\n', 'abstract contract Timed {\n', '    using SafeCast_2 for uint256;\n', '\n', '    /// @notice the start timestamp of the timed period\n', '    uint256 public startTime;\n', '\n', '    /// @notice the duration of the timed period\n', '    uint256 public duration;\n', '\n', '    event DurationUpdate(uint256 _duration);\n', '\n', '    event TimerReset(uint256 _startTime);\n', '\n', '    constructor(uint256 _duration) public {\n', '        _setDuration(_duration);\n', '    }\n', '\n', '    modifier duringTime() {\n', '        require(isTimeStarted(), "Timed: time not started");\n', '        require(!isTimeEnded(), "Timed: time ended");\n', '        _;\n', '    }\n', '\n', '    modifier afterTime() {\n', '        require(isTimeEnded(), "Timed: time not ended");\n', '        _;\n', '    }\n', '\n', '    /// @notice return true if time period has ended\n', '    function isTimeEnded() public view returns (bool) {\n', '        return remainingTime() == 0;\n', '    }\n', '\n', '    /// @notice number of seconds remaining until time is up\n', '    /// @return remaining\n', '    function remainingTime() public view returns (uint256) {\n', '        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n', '    }\n', '\n', '    /// @notice number of seconds since contract was initialized\n', '    /// @return timestamp\n', '    /// @dev will be less than or equal to duration\n', '    function timeSinceStart() public view returns (uint256) {\n', '        if (!isTimeStarted()) {\n', '            return 0; // uninitialized\n', '        }\n', '        uint256 _duration = duration;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n', '        return timePassed > _duration ? _duration : timePassed;\n', '    }\n', '\n', '    function isTimeStarted() public view returns (bool) {\n', '        return startTime != 0;\n', '    }\n', '\n', '    function _initTimed() internal {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        startTime = block.timestamp;\n', '\n', '        // solhint-disable-next-line not-rely-on-time\n', '        emit TimerReset(block.timestamp);\n', '    }\n', '\n', '    function _setDuration(uint _duration) internal {\n', '        duration = _duration;\n', '        emit DurationUpdate(_duration);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/Math.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math_4 {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '////// ./contracts/bondingcurve/BondingCurve.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/Math.sol"; */\n', '/* import "./IBondingCurve.sol"; */\n', '/* import "../utils/Roots.sol"; */\n', '/* import "../refs/OracleRef.sol"; */\n', '/* import "../pcv/PCVSplitter.sol"; */\n', '/* import "../utils/Timed.sol"; */\n', '\n', '/// @title an abstract bonding curve for purchasing FEI\n', '/// @author Fei Protocol\n', 'abstract contract BondingCurve is IBondingCurve, OracleRef, PCVSplitter, Timed {\n', '    using Decimal for Decimal.D256;\n', '    using Roots for uint256;\n', '\n', '    /// @notice the Scale target at which bonding curve price fixes\n', '    uint256 public override scale;\n', '\n', '    /// @notice the total amount of FEI purchased on bonding curve. FEI_b from the whitepaper\n', '    uint256 public override totalPurchased; // FEI_b for this curve\n', '\n', '    /// @notice the buffer applied on top of the peg purchase price once at Scale\n', '    uint256 public override buffer = 100;\n', '    uint256 public constant BUFFER_GRANULARITY = 10_000;\n', '\n', '    /// @notice amount of FEI paid for allocation when incentivized\n', '    uint256 public override incentiveAmount;\n', '\n', '    /// @notice constructor\n', '    /// @param _scale the Scale target where peg fixes\n', '    /// @param _core Fei Core to reference\n', '    /// @param _pcvDeposits the PCV Deposits for the PCVSplitter\n', '    /// @param _ratios the ratios for the PCVSplitter\n', '    /// @param _oracle the UniswapOracle to reference\n', '    /// @param _duration the duration between incentivizing allocations\n', '    /// @param _incentive the amount rewarded to the caller of an allocation\n', '    constructor(\n', '        uint256 _scale,\n', '        address _core,\n', '        address[] memory _pcvDeposits,\n', '        uint256[] memory _ratios,\n', '        address _oracle,\n', '        uint256 _duration,\n', '        uint256 _incentive\n', '    )\n', '        public\n', '        OracleRef(_core, _oracle)\n', '        PCVSplitter(_pcvDeposits, _ratios)\n', '        Timed(_duration)\n', '    {\n', '        _setScale(_scale);\n', '        incentiveAmount = _incentive;\n', '\n', '        _initTimed();\n', '    }\n', '\n', '    /// @notice sets the bonding curve Scale target\n', '    function setScale(uint256 _scale) external override onlyGovernor {\n', '        _setScale(_scale);\n', '    }\n', '\n', '    /// @notice sets the bonding curve price buffer\n', '    function setBuffer(uint256 _buffer) external override onlyGovernor {\n', '        require(\n', '            _buffer < BUFFER_GRANULARITY,\n', '            "BondingCurve: Buffer exceeds or matches granularity"\n', '        );\n', '        buffer = _buffer;\n', '        emit BufferUpdate(_buffer);\n', '    }\n', '\n', '    /// @notice sets the allocate incentive amount\n', '    function setIncentiveAmount(uint256 _incentiveAmount) external override onlyGovernor {\n', '        incentiveAmount = _incentiveAmount;\n', '        emit IncentiveAmountUpdate(_incentiveAmount);\n', '    }\n', '\n', '    /// @notice sets the allocate incentive frequency\n', '    function setIncentiveFrequency(uint256 _frequency) external override onlyGovernor {\n', '        _setDuration(_frequency);\n', '    }\n', '\n', '    /// @notice sets the allocation of incoming PCV\n', '    function setAllocation(\n', '        address[] calldata allocations,\n', '        uint256[] calldata ratios\n', '    ) external override onlyGovernor {\n', '        _setAllocation(allocations, ratios);\n', '    }\n', '\n', '    /// @notice batch allocate held PCV\n', '    function allocate() external override postGenesis whenNotPaused {\n', '        require((!Address_2.isContract(msg.sender)) || msg.sender == core().genesisGroup(), "BondingCurve: Caller is a contract");\n', '        uint256 amount = getTotalPCVHeld();\n', '        require(amount != 0, "BondingCurve: No PCV held");\n', '\n', '        _allocate(amount);\n', '        _incentivize();\n', '\n', '        emit Allocate(msg.sender, amount);\n', '    }\n', '\n', '    /// @notice a boolean signalling whether Scale has been reached\n', '    function atScale() public view override returns (bool) {\n', '        return totalPurchased >= scale;\n', '    }\n', '\n', '    /// @notice return current instantaneous bonding curve price\n', '    /// @return price reported as FEI per X with X being the underlying asset\n', '    /// @dev Can be innacurate if outdated, need to call `oracle().isOutdated()` to check\n', '    function getCurrentPrice()\n', '        public\n', '        view\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        if (atScale()) {\n', '            return peg().mul(_getBufferMultiplier());\n', '        }\n', '        return peg().div(_getBondingCurvePriceMultiplier());\n', '    }\n', '\n', '    /// @notice return amount of FEI received after a bonding curve purchase\n', '    /// @param amountIn the amount of underlying used to purchase\n', '    /// @return amountOut the amount of FEI received\n', '    /// @dev Can be innacurate if outdated, need to call `oracle().isOutdated()` to check\n', '    function getAmountOut(uint256 amountIn)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256 amountOut)\n', '    {\n', '        uint256 adjustedAmount = _getAdjustedAmount(amountIn);\n', '        amountOut = _getBufferAdjustedAmount(adjustedAmount);\n', '        if (atScale()) {\n', '            return amountOut;\n', '        }\n', '        return Math_4.max(amountOut, _getBondingCurveAmountOut(adjustedAmount)); // Cap price at buffer adjusted\n', '    }\n', '\n', '    /// @notice return the average price of a transaction along bonding curve\n', '    /// @param amountIn the amount of underlying used to purchase\n', '    /// @return price reported as USD per FEI\n', '    /// @dev Can be innacurate if outdated, need to call `oracle().isOutdated()` to check\n', '    function getAverageUSDPrice(uint256 amountIn)\n', '        public\n', '        view\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        uint256 adjustedAmount = _getAdjustedAmount(amountIn);\n', '        uint256 amountOut = getAmountOut(amountIn);\n', '        return Decimal.ratio(adjustedAmount, amountOut);\n', '    }\n', '\n', '    /// @notice the amount of PCV held in contract and ready to be allocated\n', '    function getTotalPCVHeld() public view virtual override returns (uint256);\n', '\n', '    /// @notice multiplies amount in by the peg to convert to FEI\n', '    function _getAdjustedAmount(uint256 amountIn)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return peg().mul(amountIn).asUint256();\n', '    }\n', '\n', '    /// @notice mint FEI and send to buyer destination\n', '    function _purchase(uint256 amountIn, address to)\n', '        internal\n', '        returns (uint256 amountOut)\n', '    {\n', '        updateOracle();\n', '\n', '        amountOut = getAmountOut(amountIn);\n', '        _incrementTotalPurchased(amountOut);\n', '        fei().mint(to, amountOut);\n', '\n', '        emit Purchase(to, amountIn, amountOut);\n', '\n', '        return amountOut;\n', '    }\n', '\n', '    function _incrementTotalPurchased(uint256 amount) internal {\n', '        totalPurchased = totalPurchased.add(amount);\n', '    }\n', '\n', '    function _setScale(uint256 _scale) internal {\n', '        scale = _scale;\n', '        emit ScaleUpdate(_scale);\n', '    }\n', '\n', '    /// @notice if window has passed, reward caller and reset window\n', '    function _incentivize() internal virtual {\n', '        if (isTimeEnded()) {\n', '            _initTimed(); // reset window\n', '            fei().mint(msg.sender, incentiveAmount);\n', '        }\n', '    }\n', '\n', '    /// @notice the bonding curve price multiplier at the current totalPurchased relative to Scale\n', '    function _getBondingCurvePriceMultiplier()\n', '        internal\n', '        view\n', '        virtual\n', '        returns (Decimal.D256 memory);\n', '\n', '    /// @notice returns the integral of the bonding curve solved for the amount of tokens out for a certain amount of value in\n', '    /// @param adjustedAmountIn this is the value in FEI of the underlying asset coming in\n', '    function _getBondingCurveAmountOut(uint256 adjustedAmountIn)\n', '        internal\n', '        view\n', '        virtual\n', '        returns (uint256);\n', '\n', '    /// @notice returns the buffer on the post-scale bonding curve price\n', '    function _getBufferMultiplier() internal view returns (Decimal.D256 memory) {\n', '        uint256 granularity = BUFFER_GRANULARITY;\n', '        // uses granularity - buffer (i.e. 1-b) instead of 1+b because the peg is inverted\n', '        return Decimal.ratio(granularity - buffer, granularity);\n', '    }\n', '\n', '    function _getBufferAdjustedAmount(uint256 amountIn)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _getBufferMultiplier().mul(amountIn).asUint256();\n', '    }\n', '}\n', '\n', '////// ./contracts/pcv/IPCVDeposit.sol\n', '/* pragma solidity ^0.6.2; */\n', '\n', '/// @title a PCV Deposit interface\n', '/// @author Fei Protocol\n', 'interface IPCVDeposit {\n', '    // ----------- Events -----------\n', '    event Deposit(address indexed _from, uint256 _amount);\n', '\n', '    event Withdrawal(\n', '        address indexed _caller,\n', '        address indexed _to,\n', '        uint256 _amount\n', '    );\n', '\n', '    // ----------- State changing api -----------\n', '\n', '    function deposit(uint256 amount) external payable;\n', '\n', '    // ----------- PCV Controller only state changing api -----------\n', '\n', '    function withdraw(address to, uint256 amount) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function totalValue() external view returns (uint256);\n', '}\n', '\n', '////// ./contracts/bondingcurve/EthBondingCurve.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./BondingCurve.sol"; */\n', '/* import "../pcv/IPCVDeposit.sol"; */\n', '\n', '/// @title a square root growth bonding curve for purchasing FEI with ETH\n', '/// @author Fei Protocol\n', 'contract EthBondingCurve is BondingCurve {\n', '    // solhint-disable-next-line var-name-mixedcase\n', '    uint256 internal immutable SHIFT; // k shift\n', '\n', '    constructor(\n', '        uint256 scale,\n', '        address core,\n', '        address[] memory pcvDeposits,\n', '        uint256[] memory ratios,\n', '        address oracle,\n', '        uint256 duration,\n', '        uint256 incentive\n', '    )\n', '        public\n', '        BondingCurve(\n', '            scale,\n', '            core,\n', '            pcvDeposits,\n', '            ratios,\n', '            oracle,\n', '            duration,\n', '            incentive\n', '        )\n', '    {\n', '        SHIFT = scale / 3; // Enforces a .50c starting price per bonding curve formula\n', '    }\n', '\n', '    /// @notice purchase FEI for underlying tokens\n', '    /// @param to address to receive FEI\n', '    /// @param amountIn amount of underlying tokens input\n', '    /// @return amountOut amount of FEI received\n', '    function purchase(address to, uint256 amountIn)\n', '        external\n', '        payable\n', '        override\n', '        postGenesis\n', '        whenNotPaused\n', '        returns (uint256 amountOut)\n', '    {\n', '        require(\n', '            msg.value == amountIn,\n', '            "Bonding Curve: Sent value does not equal input"\n', '        );\n', '        return _purchase(amountIn, to);\n', '    }\n', '\n', '    function getTotalPCVHeld() public view override returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    // Represents the integral solved for upper bound of P(x) = ((k+X)/(k+S))^1/2 * O. Subtracting starting point C\n', '    function _getBondingCurveAmountOut(uint256 adjustedAmountIn)\n', '        internal\n', '        view\n', '        override\n', '        returns (uint256 amountOut)\n', '    {\n', '        uint256 shiftTotal = _shift(totalPurchased); // k + C\n', '        uint256 shiftTotalCubed = shiftTotal.mul(shiftTotal.mul(shiftTotal));\n', '        uint256 radicand =\n', '            (adjustedAmountIn.mul(3).mul(_shift(scale).sqrt()) / 2).add(\n', '                shiftTotalCubed.sqrt()\n', '            );\n', '        return (radicand.cubeRoot() ** 2).sub(shiftTotal); // result - (k + C)\n', '    }\n', '\n', '    // Bonding curve formula is sqrt(k+x)/sqrt(k+S)\n', '    function _getBondingCurvePriceMultiplier()\n', '        internal\n', '        view\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return\n', '            Decimal.ratio(_shift(totalPurchased).sqrt(), _shift(scale).sqrt());\n', '    }\n', '\n', '    function _allocateSingle(uint256 amount, address pcvDeposit)\n', '        internal\n', '        override\n', '    {\n', '        IPCVDeposit(pcvDeposit).deposit{value: amount}(amount);\n', '    }\n', '\n', '    function _shift(uint256 x) internal view returns (uint256) {\n', '        return SHIFT.add(x);\n', '    }\n', '}']