['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', '// Sources flattened with hardhat v2.1.1 https://hardhat.org\n', '\n', '// File contracts/utils/Clones.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '// File contracts/utils/Address.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/token/IERC20.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    function claim(uint256[] memory indices) external returns (uint256);\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/token/IERC165.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '// File contracts/token/IERC721.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '\n', '// File contracts/WrapperChild.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'interface IWrapperChildImpl {\n', '    function initialize(address user) external;\n', '    function unwrap(uint256 num) external;\n', '}\n', '\n', 'interface IWrapperParent {\n', '  function nftxFund() external view returns (address);\n', '  function xToken() external view returns (address);\n', '  function vaultID() external view returns (uint256);\n', '}\n', '\n', 'interface INFTXFund {\n', '    function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount) external;\n', '    function redeem(uint256 game, uint256 option) external;\n', '}\n', '\n', 'interface IWaifuDungeon {\n', '    function commitSwapWaifus(uint256[] calldata _ids) external;\n', '    function revealWaifus() external;\n', '}\n', '\n', 'contract WrapperChildImpl {\n', '  IERC721 constant WAIFUSION = IERC721(0x2216d47494E516d8206B70FCa8585820eD3C4946);\n', '  IERC20 constant WET = IERC20(0x76280AF9D18a868a0aF3dcA95b57DDE816c1aaf2);\n', '  IWaifuDungeon constant WAIFU_DUNGEON = IWaifuDungeon(0xB291984262259BcFe6Aa02b66a06e9769C5c1eF3);\n', '  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '  uint256 private constant UNSET = 1 << 255;\n', '  uint256 private constant MAX_SWAP = 3;\n', '\n', '  bool private initialized;\n', '  IWrapperParent public parent;\n', '  address public user; \n', '\n', '  uint256 private receivedNftID;\n', '\n', '  function initialize(address _parent, address _user) external {\n', '    require(!initialized, "already initialized");\n', '    initialized = true;\n', '\n', '    parent = IWrapperParent(_parent);\n', '    user = _user;\n', '    IERC20(parent.xToken()).approve(parent.nftxFund(), type(uint256).max);\n', '    WET.approve(address(WAIFU_DUNGEON), type(uint256).max);\n', '\n', '    WAIFUSION.setApprovalForAll(address(WAIFU_DUNGEON), true);\n', '    receivedNftID = UNSET;\n', '  }\n', '\n', '  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4) {\n', '      if (from == address(WAIFU_DUNGEON)) {\n', '        // Use msg.sender here to allow arbitrary NFTs from dungeon.\n', '        uint256[] memory ids = new uint256[](1);\n', '        ids[0] = tokenId;\n', '        WET.claim(ids);\n', '        IERC721(msg.sender).safeTransferFrom(address(this), user, tokenId);\n', '      } else if (from == address(parent.nftxFund())) {\n', '        receivedNftID = tokenId;\n', '      } else {\n', '        revert("invalid from");\n', '      }\n', '      return _ERC721_RECEIVED;\n', '  }\n', '\n', '  function commitSwapWaifus(uint256 num) external onlyParent() {\n', '    IERC20(parent.xToken()).transferFrom(user, address(this), num * 1 ether);\n', '    uint256[] memory ids = new uint256[](num);\n', '    for (uint256 i = 0; i < num; i++) {\n', '      INFTXFund(parent.nftxFund()).redeem(parent.vaultID(), 1);\n', '      ids[i] = receivedNftID;\n', '    }\n', '    WET.transferFrom(user, address(this), num * 5490 ether);\n', '    WAIFU_DUNGEON.commitSwapWaifus(ids);\n', '  }\n', '\n', '  function revealWaifus() external onlyParent() {\n', '    WAIFU_DUNGEON.revealWaifus();\n', '    WET.transfer(user, WET.balanceOf(address(this)));\n', '  }\n', '\n', '  modifier onlyParent() {\n', '    require(msg.sender == address(parent), "not parent");\n', '    _;\n', '  } \n', '}\n', '\n', '// File contracts/NFTXDungeonWrapper.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract NFTXDungeonWrapper {\n', '  // TODO: Maybe derive some way from NFTX addr.\n', '  address immutable wrapperChildImpl;\n', '  address public nftxFund = 0xAf93fCce0548D3124A5fC3045adAf1ddE4e8Bf7e; \n', '  address public xToken = 0x0F10E6ec76346c2362897BFe948c8011BB72880F;\n', '  uint256 public vaultID = 37;\n', '\n', '  constructor() {\n', '    address impl = address(new WrapperChildImpl());\n', '    wrapperChildImpl = impl;\n', '  }\n', '\n', '  function commitWaifusWithNFTX(uint256 num) external {\n', '    address userWrapper = checkChild();\n', '    WrapperChildImpl(userWrapper).commitSwapWaifus(num);\n', '  }\n', '\n', '  function revealWaifusWithNFTX() external {\n', '    address userWrapper = checkChild();\n', '    WrapperChildImpl(userWrapper).revealWaifus();\n', '  }\n', '\n', '  function userWrapperAddr(address user) public view returns (address) {\n', '    bytes32 salt = keccak256(abi.encodePacked(address(this), user));\n', '    return Clones.predictDeterministicAddress(wrapperChildImpl, salt);\n', '  }\n', '\n', '  function checkChild() public returns (address) {\n', '    address properWrapper = userWrapperAddr(msg.sender);\n', '    if (!Address.isContract(properWrapper)) {\n', '      bytes32 salt = keccak256(abi.encodePacked(address(this), msg.sender));\n', '      address wrapper = Clones.cloneDeterministic(wrapperChildImpl, salt);\n', '      WrapperChildImpl(wrapper).initialize(address(this), msg.sender); \n', '    }\n', '    return properWrapper;\n', '  }\n', '}']