['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-31\n', '*/\n', '\n', '// File: contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Factory.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', 'interface ICoFixFactory {\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (IUniswapV2Pair pair);\n', '    function allPairsLength() external view returns (uint);\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/UniswapV2Helper.sol\n', '\n', 'pragma solidity ^0.5.12;\n', '\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract CoFixHelper {\n', '    \n', '    struct Pair {\n', '        address pair;\n', '        address token0;\n', '        address token1;\n', '    }\n', '\n', '    ICoFixFactory constant factory =  ICoFixFactory(0x39816B841436a57729723d9DA127805755d2CB51);\n', '\n', '    function getPairs() external view returns (Pair[] memory pairs) {\n', '\n', '        uint256 pairsCount = factory.allPairsLength();\n', '        Pair[] memory allPairs = new Pair[](pairsCount);\n', '\n', '        uint256 notEmptyLength;\n', '        for (uint i; i < pairsCount; i++) {\n', '            IUniswapV2Pair pair = factory.allPairs(i);\n', '            address token0 = pair.token0();\n', '            address token1 = pair.token1();\n', '             \n', '            if (IERC20(token0).balanceOf(address(pair)) > 0) {\n', '                allPairs[notEmptyLength] = Pair({\n', '                    pair: address(pair),\n', '                    token0: token0,\n', '                    token1: token1\n', '                });\n', '                notEmptyLength++;\n', '            }\n', '        }\n', '\n', '        pairs = new Pair[](notEmptyLength);\n', '        for (uint i; i < notEmptyLength; i++) {\n', '            pairs[i] = allPairs[i];\n', '        }\n', '    }\n', '\n', '}']