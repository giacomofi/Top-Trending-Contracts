['// SPDX-License-Identifier: MIT\n', '\n', '/**\n', ' * BurnX 2.0 - #ShareFi on fire. Charity. Rewards.\n', ' *\n', ' * A community centric powerhouse of hot mechanics that funds good \n', ' * causes, rewards holders, & supports a healthy price floor. \n', ' * Blazing a path to financial freedom, truly. \n', ' *\n', ' * Website: https://BurnX.finance\n', ' * Telegram: https://t.me/BurnXCommunity\n', ' * Twitter: https://twitter.com/BurnX_Community\n', '*/\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// Contracts\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', 'import "./Address.sol";\n', 'import "./IERC20.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./IUniswapV2Router02.sol";\n', '\n', 'contract BurnX20 is Context, IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    // Reflect and allowances\n', '    mapping(address => uint256) private _rOwned;\n', '    mapping(address => uint256) private _tOwned;\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    // Reflect exclusions - fees & rewards\n', '    mapping(address => bool) private _isExcludedFromFee; // fee\n', '    mapping(address => bool) private _isExcluded; // reward\n', '    address[] private _excluded;\n', '\n', '    // Bots\n', '    mapping(address => bool) private _isBot;\n', '    address[] private _bots;\n', '\n', '    // Reflect & Total Supply (capped)\n', '    uint256 private constant MAX = ~uint256(0);\n', '    uint256 private _tTotal = 1_000_000_000_000_000 * 10**9;\n', '    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '    uint256 private _tFeeTotal;\n', '\n', '    // Standard token details\n', '    string private _name = "BurnX 2.0";\n', '    string private _symbol = "BurnX20";\n', '    uint8 private _decimals = 9;\n', '\n', '    // Default % trade tax settings\n', '    uint256 private _taxFee = 4; // reflection\n', '    uint256 private _marketingFee = 2; // marketing\n', '    uint256 private _liquidityFee = 4; // liquidity\n', '\n', '    // Rollback % trade tax settings\n', '    uint256 private _prevTaxFee = _taxFee;\n', '    uint256 private _prevMarketingFee = _marketingFee;\n', '    uint256 private _prevLiquidityFee = _liquidityFee;\n', '\n', '    // Uniswap\n', '    IUniswapV2Router02 public immutable uniswapV2Router;\n', '    address public immutable uniswapV2Pair;\n', '\n', '    // Reentrancy, swap & liquify\n', '    bool internal locked = false;\n', '    bool public swapLiquifyEnabled = true;\n', '\n', '    // Reentrancy guard\n', '    modifier noReentrant() {\n', '        locked = true;\n', '        _;\n', '        locked = false;\n', '    }\n', '\n', '    // Max token amount per TX\n', '    uint256 private _maxTx = _tTotal;\n', '\n', '    // Max tokens to be swapped - set to optimum\n', '    uint256 private _amountSellLiquidity = 1000000000 * 10**9;\n', '\n', '    // Events\n', '    event SwapAndLiquify(\n', '        uint256 tokensSwapped,\n', '        uint256 ethReceived,\n', '        uint256 tokensIntoLiqudity\n', '    );\n', '\n', '    // Wallets\n', '    address payable private _marketingAddress;\n', '    address private _lpAddress;\n', '\n', '    constructor(address marketingAddress) public {\n', '        // Total Supply to owner\n', '        _rOwned[_msgSender()] = _rTotal;\n', '\n', '        // Marketing\n', '        _marketingAddress = payable(marketingAddress);\n', '\n', '        // Uniswap router & pair\n', '        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n', '        uniswapV2Router = _uniswapV2Router;\n', '\n', '        // Exclude addresses from reflect fee\n', '        _isExcludedFromFee[address(this)] = true;\n', '        _isExcludedFromFee[_msgSender()] = true;\n', '        _isExcludedFromFee[_marketingAddress] = true;\n', '\n', '        // LP token\n', '        _lpAddress = _msgSender();\n', '\n', '        emit Transfer(address(0), _msgSender(), _tTotal);\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _tTotal;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        if (_isExcluded[account]) return _tOwned[account];\n', '\n', '        return tokenFromReflection(_rOwned[account]);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        public\n', '        override\n', '        returns (bool)\n', '    {\n', '        _transfer(_msgSender(), recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount)\n', '        public\n', '        override\n', '        returns (bool)\n', '    {\n', '        _approve(_msgSender(), spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(\n', '            sender,\n', '            _msgSender(),\n', '            _allowances[sender][_msgSender()].sub(amount, "Amount exceeds allowance")\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        public\n', '        virtual\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].add(addedValue)\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        public\n', '        virtual\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].sub(\n', '                subtractedValue,\n', '                "Allowance below zero"\n', '            )\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function isExcludedFromReward(address account) public view returns (bool) {\n', '        return _isExcluded[account];\n', '    }\n', '\n', '    function setExcludeFromFee(address account, bool excluded)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _isExcludedFromFee[account] = excluded;\n', '    }\n', '\n', '    function totalFees() public view returns (uint256) {\n', '        return _tFeeTotal;\n', '    }\n', '\n', '    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(tAmount <= _tTotal);\n', '\n', '        if (!deductTransferFee) {\n', '            (uint256 rAmount, , , , , ) = _getValues(tAmount);\n', '\n', '            return rAmount;\n', '        } else {\n', '            (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);\n', '\n', '            return rTransferAmount;\n', '        }\n', '    }\n', '\n', '    function tokenFromReflection(uint256 rAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(rAmount <= _rTotal);\n', '\n', '        uint256 currentRate = _getRate();\n', '\n', '        return rAmount.div(currentRate);\n', '    }\n', '\n', '    function excludeFromReward(address account) external onlyOwner {\n', '        require(account != address(uniswapV2Router)); // UniswapV2 router\n', '        require(!_isExcluded[account]);\n', '\n', '        if (_rOwned[account] > 0) {\n', '            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '        }\n', '\n', '        _isExcluded[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '\n', '    function includeInReward(address account) external onlyOwner {\n', '        require(_isExcluded[account]);\n', '\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _tOwned[account] = 0;\n', '                _isExcluded[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function addBots(address[] memory botAddresses) external onlyOwner {\n', '        for (uint256 i = 0; i < botAddresses.length; i++) {\n', '            require(botAddresses[i] != address(uniswapV2Router)); // UniswapV2 router\n', '\n', '            _isBot[botAddresses[i]] = true;\n', '            _bots.push(botAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function removeBot(address account) external onlyOwner {\n', '        require(_isBot[account]);\n', '\n', '        for (uint256 i = 0; i < _bots.length; i++) {\n', '            if (_bots[i] == account) {\n', '                _bots[i] = _bots[_bots.length - 1];\n', '                _isBot[account] = false;\n', '                _bots.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function removeAllFee() private {\n', '        if (_taxFee == 0 && _marketingFee == 0 && _liquidityFee == 0) return;\n', '\n', '        _prevTaxFee = _taxFee;\n', '        _prevMarketingFee = _marketingFee;\n', '        _prevLiquidityFee = _liquidityFee;\n', '\n', '        _taxFee = 0;\n', '        _marketingFee = 0;\n', '        _liquidityFee = 0;\n', '    }\n', '\n', '    function restoreAllFee() private {\n', '        _taxFee = _prevTaxFee;\n', '        _marketingFee = _prevMarketingFee;\n', '        _liquidityFee = _prevLiquidityFee;\n', '    }\n', '\n', '    function isExcludedFromFee(address account) public view returns (bool) {\n', '        return _isExcludedFromFee[account];\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) private {\n', '        require(sender != address(0));\n', '        require(recipient != address(0));\n', '        require(amount > 0);\n', '        require(!_isBot[sender]);\n', '        require(!_isBot[recipient]);\n', '        require(!_isBot[tx.origin]);\n', '\n', '        if (sender != owner() && recipient != owner()) {\n', '            require(amount <= _maxTx); // Max TX amount\n', '        }\n', '\n', '        uint256 contractTokenBalance = balanceOf(address(this));\n', '        \n', '        // Is token balance over minimum target for selling?\n', '        bool overMinTokenBalance = contractTokenBalance >= _amountSellLiquidity;\n', '        \n', '        // Token balance over Max TX\n', '        if (contractTokenBalance >= _maxTx) {\n', '            contractTokenBalance = _maxTx;\n', '        } else {\n', '            // Token balance over minimum but below Max TX\n', '            contractTokenBalance = _amountSellLiquidity;\n', '        }\n', '\n', '        if (\n', '            !locked &&\n', '            swapLiquifyEnabled &&\n', '            overMinTokenBalance &&\n', '            sender != address(uniswapV2Pair)\n', '        ) {\n', '            // Add liquidity\n', '            swapAndLiquify(contractTokenBalance);\n', '        }\n', '\n', '        bool takeFee = true;\n', '\n', '        // Temporarily omit the fee if any account is excluded\n', '        if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\n', '            takeFee = false;\n', '        }\n', '\n', '        // Transfer amount - deducts any necessary fees\n', '        _tokenTransfer(sender, recipient, amount, takeFee);\n', '    }\n', '\n', '    function swapAndLiquify(uint256 takeAmount) private noReentrant {\n', '        // Marketing vs Liquidity allocation.\n', '        uint256 marketingPecentage = _marketingFee.mul(10000).mul(10**9).div(_marketingFee.add(_liquidityFee));\n', '        uint256 toMarketing = marketingPecentage.mul(takeAmount).div(10000).div(10**9);\n', '        uint256 toLiquify = takeAmount.sub(toMarketing);\n', '\n', '        // Split token balance into halves\n', '        uint256 tokenHalfForETH = toLiquify.div(2);\n', '        uint256 halfForTokenLP = toLiquify.sub(tokenHalfForETH);\n', '\n', '        uint256 ethBalanceBeforeSwap = address(this).balance;\n', '\n', '        // Swap tokens for ETH\n', '        uint256 toSwapForEth = tokenHalfForETH.add(toMarketing);\n', '        swapTokensForEth(toSwapForEth);\n', '\n', '        // Get new ETH balance\n', '        uint256 ethRecivedFromSwap = address(this).balance.sub(ethBalanceBeforeSwap);\n', '\n', '        // Recent ETH balance * 50% of the allocated LP tokens / marketing tokens\n', '        uint256 ethLpPart = ethRecivedFromSwap.mul(tokenHalfForETH).div(toSwapForEth);\n', '\n', '        // Add liquidity to Uniswap\n', '        addLiquidity(halfForTokenLP, ethLpPart);\n', '\n', '        emit SwapAndLiquify(tokenHalfForETH, ethLpPart, halfForTokenLP);\n', '\n', '        // Send the rest to marketing.\n', '        sendETHToMarketing(ethRecivedFromSwap.sub(ethLpPart));\n', '    }\n', '\n', '    function swapTokensForEth(uint256 tokenAmount) private {\n', '        // Generate the Uniswap pair path of token -> weth\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = uniswapV2Router.WETH();\n', '\n', '        _approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '        // Swap\n', '        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0,\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n', '        _approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '        // Add liquidity\n', '        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n', '            address(this),\n', '            tokenAmount,\n', '            0,\n', '            0,\n', '            _lpAddress,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function sendETHToMarketing(uint256 amount) private {\n', '        _marketingAddress.transfer(amount);\n', '    }\n', '\n', '    // Manual swap & send if the token is highly valued\n', '    function manualSwap() external onlyOwner {\n', '        uint256 contractBalance = balanceOf(address(this));\n', '        swapTokensForEth(contractBalance);\n', '    }\n', '\n', '    function manualSend() public onlyOwner {\n', '        uint256 contractETHBalance = address(this).balance;\n', '        sendETHToMarketing(contractETHBalance);\n', '    }\n', '\n', '    function setSwapLiquifyEnabled() external onlyOwner {\n', '        swapLiquifyEnabled = !swapLiquifyEnabled;\n', '    }\n', '\n', '    function isSwapLiquifyEnabled() public view returns (bool) {\n', '        return swapLiquifyEnabled;\n', '    }\n', '\n', '    function _tokenTransfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount,\n', '        bool takeFee\n', '    ) private {\n', '        if (!takeFee) removeAllFee();\n', '\n', '        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n', '            _transferFromExcluded(sender, recipient, amount);\n', '        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n', '            _transferToExcluded(sender, recipient, amount);\n', '        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n', '            _transferStandard(sender, recipient, amount);\n', '        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n', '            _transferBothExcluded(sender, recipient, amount);\n', '        } else {\n', '            _transferStandard(sender, recipient, amount);\n', '        }\n', '\n', '        if (!takeFee) restoreAllFee();\n', '    }\n', '\n', '    function _transferStandard(\n', '        address sender,\n', '        address recipient,\n', '        uint256 tAmount\n', '    ) private {\n', '        (\n', '            uint256 rAmount,\n', '            uint256 rTransferAmount,\n', '            uint256 rFee,\n', '            uint256 tTransferAmount,\n', '            uint256 tFee,\n', '            uint256 tMarketingLiquidity\n', '        ) = _getValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        uint256 rMarketingLiquidity = tMarketingLiquidity.mul(currentRate);\n', '\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount).sub(rMarketingLiquidity);\n', '\n', '        _takeMarketingLiquidity(tMarketingLiquidity);\n', '        _reflectFee(rFee, tFee);\n', '\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '\n', '    function _transferToExcluded(\n', '        address sender,\n', '        address recipient,\n', '        uint256 tAmount\n', '    ) private {\n', '        (\n', '            uint256 rAmount,\n', '            uint256 rTransferAmount,\n', '            uint256 rFee,\n', '            uint256 tTransferAmount,\n', '            uint256 tFee,\n', '            uint256 tMarketingLiquidity\n', '        ) = _getValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        uint256 rMarketingLiquidity = tMarketingLiquidity.mul(currentRate);\n', '\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount).sub(rMarketingLiquidity);\n', '\n', '        _takeMarketingLiquidity(tMarketingLiquidity);\n', '        _reflectFee(rFee, tFee);\n', '\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '\n', '    function _transferFromExcluded(\n', '        address sender,\n', '        address recipient,\n', '        uint256 tAmount\n', '    ) private {\n', '        (\n', '            uint256 rAmount,\n', '            uint256 rTransferAmount,\n', '            uint256 rFee,\n', '            uint256 tTransferAmount,\n', '            uint256 tFee,\n', '            uint256 tMarketingLiquidity\n', '        ) = _getValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        uint256 rMarketingLiquidity = tMarketingLiquidity.mul(currentRate);\n', '\n', '        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount).sub(rMarketingLiquidity);\n', '\n', '        _takeMarketingLiquidity(tMarketingLiquidity);\n', '        _reflectFee(rFee, tFee);\n', '\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '\n', '    function _transferBothExcluded(\n', '        address sender,\n', '        address recipient,\n', '        uint256 tAmount\n', '    ) private {\n', '        (\n', '            uint256 rAmount,\n', '            uint256 rTransferAmount,\n', '            uint256 rFee,\n', '            uint256 tTransferAmount,\n', '            uint256 tFee,\n', '            uint256 tMarketingLiquidity\n', '        ) = _getValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        uint256 rMarketingLiquidity = tMarketingLiquidity.mul(currentRate);\n', '\n', '        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount).sub(rMarketingLiquidity);\n', '\n', '        _takeMarketingLiquidity(tMarketingLiquidity);\n', '        _reflectFee(rFee, tFee);\n', '\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '\n', '    function _takeMarketingLiquidity(uint256 tMarketingLiquidity) private {\n', '        uint256 currentRate = _getRate();\n', '        uint256 rMarketingLiquidity = tMarketingLiquidity.mul(currentRate);\n', '\n', '        _rOwned[address(this)] = _rOwned[address(this)].add(rMarketingLiquidity);\n', '\n', '        if (_isExcluded[address(this)]) {\n', '            _tOwned[address(this)] = _tOwned[address(this)].add(tMarketingLiquidity);\n', '        }\n', '    }\n', '\n', '    function _reflectFee(uint256 rFee, uint256 tFee) private {\n', '        _rTotal = _rTotal.sub(rFee);\n', '\n', '        _tFeeTotal = _tFeeTotal.add(tFee);\n', '    }\n', '\n', '    // Recieve ETH when swapping\n', '    receive() external payable {}\n', '\n', '    function _getValues(uint256 tAmount)\n', '        private\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (\n', '            uint256 tTransferAmount,\n', '            uint256 tFee,\n', '            uint256 tMarketingLiquidityFee\n', '        ) = _getTValues(tAmount, _taxFee, _marketingFee.add(_liquidityFee));\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n', '            tAmount,\n', '            tFee,\n', '            currentRate\n', '        );\n', '\n', '        return (\n', '            rAmount,\n', '            rTransferAmount,\n', '            rFee,\n', '            tTransferAmount,\n', '            tFee,\n', '            tMarketingLiquidityFee\n', '        );\n', '    }\n', '\n', '    function _getTValues(\n', '        uint256 tAmount,\n', '        uint256 taxFee,\n', '        uint256 marketingLiquidityFee\n', '    )\n', '        private\n', '        pure\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 tFee = tAmount.mul(taxFee).div(100);\n', '        uint256 tMarketingLiquidityFee = tAmount.mul(marketingLiquidityFee).div(100);\n', '        uint256 tTransferAmount = tAmount.sub(tFee).sub(tMarketingLiquidityFee);\n', '\n', '        return (tTransferAmount, tFee, tMarketingLiquidityFee);\n', '    }\n', '\n', '    function _getRValues(\n', '        uint256 tAmount,\n', '        uint256 tFee,\n', '        uint256 currentRate\n', '    )\n', '        private\n', '        pure\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '        uint256 rFee = tFee.mul(currentRate);\n', '        uint256 rTransferAmount = rAmount.sub(rFee);\n', '\n', '        if (rFee != 0) {\n', '            rFee = currentRate.div(2).add(rFee);\n', '        }\n', '\n', '        return (rAmount, rTransferAmount, rFee);\n', '    }\n', '\n', '    function _getRate() private view returns (uint256) {\n', '        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '\n', '        return rSupply.div(tSupply);\n', '    }\n', '\n', '    function _getCurrentSupply() private view returns (uint256, uint256) {\n', '        uint256 rSupply = _rTotal;\n', '        uint256 tSupply = _tTotal;\n', '\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (\n', '                _rOwned[_excluded[i]] > rSupply ||\n', '                _tOwned[_excluded[i]] > tSupply\n', '            ) return (_rTotal, _tTotal);\n', '            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n', '            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n', '        }\n', '\n', '        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '\n', '        return (rSupply, tSupply);\n', '    }\n', '\n', '    function setTxFees(\n', '        uint256 tax,\n', '        uint256 marketing,\n', '        uint256 liquidity\n', '    ) external onlyOwner {\n', '        require(tax.add(marketing).add(liquidity) <= 10);\n', '\n', '        _taxFee = tax;\n', '        _marketingFee = marketing;\n', '        _liquidityFee = liquidity;\n', '    }\n', '\n', '    function setWallets(address marketingAddress, address lpAddress)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _marketingAddress = payable(marketingAddress);\n', '\n', '        _lpAddress = lpAddress;\n', '    }\n', '\n', '    function setAmountSellLiquidity(uint256 amountSellLiquidity)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(amountSellLiquidity >= 10**9);\n', '\n', '        _amountSellLiquidity = amountSellLiquidity;\n', '    }\n', '\n', '    function setMaxTx(uint256 maxTx) external onlyOwner {\n', '        require(maxTx >= 10**9);\n', '\n', '        _maxTx = maxTx;\n', '    }\n', '\n', '    function recoverTokens(uint256 amount) public onlyOwner {\n', '        _approve(address(this), owner(), amount);\n', '        _transfer(address(this), owner(), amount);\n', '    }\n', '\n', '    function withdrawToken(\n', '        address token,\n', '        uint256 amount,\n', '        address recipient\n', '    ) external onlyOwner {\n', '        require(token != uniswapV2Pair);\n', '        require(token != address(this));\n', '\n', '        IERC20(token).transfer(recipient, amount);\n', '    }\n', '\n', '    function migrateHolders(\n', '        address[] memory recipients,\n', '        uint256[] memory amounts\n', '    ) external onlyOwner {\n', '        require(recipients.length == amounts.length);\n', '\n', '        for (uint256 i = 0; i < recipients.length; i++) {\n', '            transfer(recipients[i], amounts[i]);\n', '        }\n', '    }\n', '}']