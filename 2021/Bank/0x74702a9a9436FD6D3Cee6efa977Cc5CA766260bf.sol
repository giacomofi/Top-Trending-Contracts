['// SPDX-License-Identifier: J-J-J-JENGA!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./IERC20.sol";\n', 'import "./IERC31337.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IUniswapV2Factory.sol";\n', '\n', 'contract Arbitrage is TokensRecoverable\n', '{\n', '    IERC20 public immutable baseToken;\n', '    IERC31337 public immutable eliteToken;\n', '    IERC20 public immutable rootedToken;\n', '    IERC20 public immutable baseRootedPair;\n', '    IERC20 public immutable eliteRootedPair;\n', '    IUniswapV2Router02 public immutable uniswapV2Router;\n', '\n', '    mapping (address => bool) public arbitrageurs;\n', '\n', '    event Profit(uint256 _value);\n', '\n', '    constructor(IERC20 _baseToken, IERC31337 _eliteToken, IERC20 _rootedToken, IUniswapV2Router02 _uniswapV2Router)\n', '    {\n', '        baseToken = _baseToken;\n', '        eliteToken = _eliteToken;\n', '        rootedToken = _rootedToken;\n', '        uniswapV2Router = _uniswapV2Router;\n', '\n', '        IERC20 _baseRootedPair = IERC20(IUniswapV2Factory(_uniswapV2Router.factory()).getPair(address(_baseToken), address(_rootedToken)));\n', '        IERC20 _eliteRootedPair = IERC20(IUniswapV2Factory(_uniswapV2Router.factory()).getPair(address(_eliteToken), address(_rootedToken)));\n', '\n', '        baseRootedPair = _baseRootedPair;\n', '        eliteRootedPair = _eliteRootedPair;\n', '\n', '        _baseToken.approve(address(_uniswapV2Router), uint256(-1));\n', '        _eliteToken.approve(address(_uniswapV2Router), uint256(-1));\n', '        _rootedToken.approve(address(_uniswapV2Router), uint256(-1));\n', '        _baseToken.approve(address(_eliteToken), uint256(-1));\n', '    }    \n', '\n', '    modifier arbitrageurOnly()\n', '    {\n', '        require(arbitrageurs[msg.sender], "Not an arbitrageur");\n', '        _;\n', '    }\n', '\n', '    function setArbitrageur(address arbitrageur, bool allow) public ownerOnly()\n', '    {\n', '        arbitrageurs[arbitrageur] = allow;\n', '    }\n', '\n', '    function balancePriceBase(uint256 baseAmount) public arbitrageurOnly() \n', '    {\n', '        uint256 rootedAmount = buyRootedToken(address(baseToken), baseAmount);      \n', '        uint256 eliteAmount = sellRootedToken(address(eliteToken), rootedAmount);\n', '        require(eliteAmount > baseAmount, "No profit");\n', '        eliteToken.withdrawTokens(eliteAmount);\n', '        emit Profit(eliteAmount - baseAmount);\n', '    }\n', '\n', '    function balancePriceElite(uint256 eliteAmount) public arbitrageurOnly() \n', '    {\n', '        eliteToken.depositTokens(eliteAmount);\n', '        uint256 rootedAmount = buyRootedToken(address(eliteToken), eliteAmount);\n', '        uint256 baseAmount = sellRootedToken(address(baseToken), rootedAmount);\n', '        require(baseAmount > eliteAmount, "No profit");\n', '        emit Profit(baseAmount - eliteAmount);\n', '    }\n', '\n', '    function buyRootedToken(address token, uint256 amountToSpend) private returns (uint256) \n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(token);\n', '        path[1] = address(rootedToken);\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, path, address(this), block.timestamp);\n', '        return amounts[1];\n', '    }\n', '\n', '    function sellRootedToken(address token, uint256 amountToSpend) private returns (uint256) \n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(rootedToken);\n', '        path[1] = address(token);\n', '        uint256[] memory amounts = uniswapV2Router.getAmountsOut(amountToSpend, path);   \n', '        amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, path, address(this), block.timestamp);    \n', '        return amounts[1];\n', '    }\n', '}']