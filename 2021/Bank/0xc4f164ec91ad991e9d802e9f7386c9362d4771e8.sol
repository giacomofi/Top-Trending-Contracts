['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IUniswapV2Pair.sol";\n', '\n', '/**\n', ' * @dev Implementation of a PointOfSale.\n', ' *  This contract works as a PointOfSale for a set of pre-defined products with prices.\n', ' *  It provides a simple solution for merchants to process payments with on-chain data\n', ' *  on any EVM powered network.\n', ' *\n', ' *  The contract must work together with a backend API to use events as triggers to deliver\n', ' *  the purchased products. It has an internal system to track purchases and requires users\n', ' *  to register the deliver point outside of the network.\n', ' */\n', 'contract Shop is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /* STRUCTS */\n', '\n', '    struct Sale {\n', '        uint256 product;\n', '        address token;\n', '        uint256 tokenPrice;\n', '        uint256 wethPrice;\n', '        uint256 productPrice;\n', '        uint256 time;\n', '    }\n', '\n', '    struct Product {\n', '        uint256 id;\n', '        string image;\n', '        uint256 price;\n', '        bool available;\n', '    }\n', '\n', '    /* MAPS FOR TRACKING */\n', '\n', '    // Registered users.\n', '    // This serves as a second verification to make sure all users have\n', '    // registered a place (email) to redeem the purchase.\n', '    // Emails are not registered here, this should only include a hash\n', '    // of the email that will be verified to verify.\n', '    mapping(address => bytes32) public users;\n', '\n', '    // User purchases map\n', '    mapping(address => Sale[]) history;\n', '\n', '    // A map of products IDs with prices.\n', '    mapping(uint256 => Product) products;\n', '    uint256[] productsList;\n', '\n', '    /* CONST */\n', '\n', '    address public immutable router;\n', '    IUniswapV2Factory public immutable factory;\n', '\n', '    // Token to receive for all purchases.\n', '    address public immutable chargeToken;\n', '    address public immutable prefToken;\n', '    address public immutable WETH;\n', '\n', '    uint256 public fee;\n', '    uint256 public feeForPrefToken;\n', '\n', '    bool public initialized;\n', '    bool public buyBackAndBurn;\n', '\n', '    /* Events */\n', '    event Purchase(address addr, uint256 product);\n', '    event PurchaseCustomOrder(address addr, uint256 orderId, uint256 payed_price);\n', '\n', '    /* CONSTRUCTOR */\n', '    constructor(address _router, address _factory, address _receiveToken, address _prefToken, address _weth) {\n', '        router = _router;\n', '        factory = IUniswapV2Factory(_factory);\n', '        chargeToken = _receiveToken;\n', '        prefToken = _prefToken;\n', '        WETH = _weth;\n', '\n', '        initialized = false;\n', '        buyBackAndBurn = false;\n', '        fee = 4;\n', '        feeForPrefToken = 3;\n', '    }\n', '\n', '    // getUserHash returns the specified user hash\n', '    function getUserHash(address _user) public view returns (bytes32) {\n', '        return users[_user];\n', '    }\n', '\n', '    // getEmailHash returns the hashed result of the email, this is external to use with\n', '    // front-end compare against registered email.\n', '    function getEmailHash(string calldata email) public pure returns (bytes32) {\n', '        return keccak256(abi.encode(email));\n', '    }\n', '\n', '    // getProduct returns product information from the id\n', '    function getProduct(uint256 _id) public view returns(Product memory) {\n', '        return products[_id];\n', '    }\n', '\n', '    // getProductsList returns all product ids\n', '    function getProductsList() public view returns(uint256[] memory) {\n', '        return productsList;\n', '    }\n', '\n', '    // getUserHistory returns the user purchases history\n', '    function getUserHistory() public view returns (Sale[] memory) {\n', '        return history[msg.sender];\n', '    }\n', '\n', '    function getProductPrice(uint256 _id) public view returns (uint256) {\n', '        return products[_id].price;\n', '    }\n', '\n', '    // getProductPricesOnSpecificTokenForCustomOrder gives the price custom order using any token.\n', '    // This returns two prices: final order price and token price.\n', '    // Slippage is delegated to the user to prevent high slippage tokens (SafeMoon, PitBull, etc) to fail transactions.\n', '    function getProductPricesOnSpecificTokenForCustomOrder(uint256 _price, address _token, uint256 slippage) public view returns (uint256, uint256) {\n', '        // Check if the token the user wants is preferable and allows lower fee.\n', '        uint256 saleFee;\n', '        if (_token == prefToken) {\n', '            saleFee = feeForPrefToken;\n', '        } else {\n', '            saleFee = fee;\n', '        }\n', '\n', '        require(_price != 0, "POS: getProductPricesOnSpecificTokenForCustomOrder specific order price cannot be 0");\n', '\n', '        uint256 finalPrice = _price.add(_price.mul(saleFee).div(100));\n', '\n', '        // If the token submitted is the same as the chargeToken return the data.\n', '        if (_token == chargeToken) {\n', '            return (finalPrice, 0);\n', '        }\n', '\n', '        uint256 wethPrice = calcWethPrice(finalPrice, slippage);\n', '\n', '        // If token is WETH return the data;\n', '        if (_token == WETH) {\n', '            return (finalPrice, wethPrice);\n', '        }\n', '\n', '        uint256 tokenPrice = calcTokenPrice(_token, wethPrice, slippage);\n', '\n', '        return (finalPrice, tokenPrice);\n', '    }\n', '\n', '    // getProductPricesOnSpecificToken gives the price of a product using any token.\n', '    // This function returns: chargeTokenPrice, WETH price and Token Price.\n', '    // Slippage is delegated to the user to prevent high slippage tokens (SafeMoon, PitBull, etc) to fail transactions.\n', '    function getProductPricesOnSpecificToken(uint256 _id, address _token, uint256 slippage) public view returns (uint256, uint256, uint256) {\n', '        // Get pairs to calculate route price\n', '\n', '        // Check if the token the user wants is preferable and allows lower fee.\n', '        uint256 saleFee;\n', '        if (_token == prefToken) {\n', '            saleFee = feeForPrefToken;\n', '        } else {\n', '            saleFee = fee;\n', '        }\n', '\n', '        // Calculate final price\n', '        require(products[_id].price != 0, "POS: getProductPricesOnSpecificToken product doesn\'t exist");\n', '\n', '        uint256 finalPrice = products[_id].price.add(products[_id].price.mul(saleFee).div(100));\n', '\n', '        // If the token submitted is the same as the chargeToken return the data.\n', '        if (_token == chargeToken) {\n', '            return (finalPrice,0,0);\n', '        }\n', '\n', '        uint256 wethPrice = calcWethPrice(finalPrice, slippage);\n', '\n', '        // If token is WETH return the data;\n', '        if (_token == WETH) {\n', '            return (finalPrice, wethPrice, 0);\n', '        }\n', '\n', '        uint256 tokenPrice = calcTokenPrice(_token, wethPrice, slippage);\n', '\n', '        return (finalPrice, wethPrice, tokenPrice);\n', '    }\n', '\n', '    function calcWethPrice(uint256 chargePrice, uint256 slippage) internal view returns (uint256) {\n', '        // Calculate the amount of WETH user needs to pay to purchase the product (with fee and slippage)\n', '        (uint112 chargeTokenReserves, uint112 wethReserves,) = IUniswapV2Pair(factory.getPair(chargeToken, WETH)).getReserves();\n', '        uint256 wethPrice = chargePrice.mul(wethReserves).div(chargeTokenReserves);\n', '\n', '        return wethPrice.add(wethPrice.mul(slippage).div(100));\n', '    }\n', '\n', '    function calcTokenPrice(address _token, uint256 wethPrice, uint256 slippage) internal view returns (uint256) {\n', '        // Check that the token the user wants to use has a pair against WETH.\n', '        address tokenSalePair = factory.getPair(_token, WETH);\n', '        require(tokenSalePair != address(0), "POS: getProductPriceOnSpecificToken pair doesn\'t exist for this token");\n', '\n', '        // Calculate the amount of token user needs to pay to achieve the WETH amount\n', '        (uint112 tokenReserves, uint112 wethTokenReserves,) = IUniswapV2Pair(tokenSalePair).getReserves();\n', '        uint256 tokenPrice = wethPrice.mul(tokenReserves).div(wethTokenReserves);\n', '\n', '        return tokenPrice.add(tokenPrice.mul(slippage).div(100));\n', '    }\n', '\n', '    //*****************************************//\n', '\n', '    // setInitialize sets the initialization\n', '    function setInitialize(bool _init) public onlyOwner {\n', '        initialized = _init;\n', '    }\n', '\n', '    // setBuyBackAndBurn enables buy back and burn\n', '    function setBuyBackAndBurn(bool _set) public onlyOwner {\n', '        buyBackAndBurn = _set;\n', '    }\n', '\n', '    // buyCustomOrder submits the token to perform trades and submit a Purchase event\n', '    function buyCustomOrder(uint256 _orderID, address _token, uint256 slippage, uint256 _orderPrice) public {\n', '        require(initialized, "POS: Shop is closed, please try again later");\n', '\n', '        // Fetch price\n', '        (uint256 finalPrice, uint256 tokenPrice) = getProductPricesOnSpecificTokenForCustomOrder(_orderPrice, _token, slippage);\n', '\n', '        // Perform trades\n', '        if (_token == chargeToken) {\n', '            IERC20(chargeToken).safeTransferFrom(msg.sender, address(this), finalPrice);\n', '\n', '            // If the token purchase is made with chargeToken and buyBackAndBurn is enabled submit buyBackBurn.\n', '            if (buyBackAndBurn) {\n', '                buyBackAndBurnTokens(finalPrice);\n', '            }\n', '\n', '            emit PurchaseCustomOrder(msg.sender, _orderID, finalPrice);\n', '\n', '        } else if (_token == WETH) {\n', '\n', '            IERC20(WETH).safeTransferFrom(msg.sender, address(this), tokenPrice);\n', '\n', '            swapWETHToChargeToken(finalPrice, tokenPrice);\n', '\n', '            emit PurchaseCustomOrder(msg.sender, _orderID, finalPrice);\n', '\n', '        } else {\n', '\n', '            IERC20(_token).safeTransferFrom(msg.sender, address(this), tokenPrice);\n', '\n', '            swapTokenToChargeToken(_token, finalPrice, tokenPrice);\n', '\n', '            emit PurchaseCustomOrder(msg.sender, _orderID, finalPrice);\n', '\n', '        }\n', '\n', '    }\n', '\n', '    // buy submits the token perform trades and submit the Purchase event\n', '    function buy(uint256 _id, address _token, uint256 slippage) public {\n', '        require(initialized, "POS: Shop is closed, please try again later");\n', '\n', '        // Make sure user is registered\n', '        require(users[msg.sender] != "", "POS: buy user is not registered on-chain");\n', '\n', '        // Fetch prices\n', '        (uint256 chargePrice, uint256 wethPrice, uint256 tokenPrice) = getProductPricesOnSpecificToken(_id, _token, slippage);\n', '\n', '        // Perform trades\n', '        if (_token == chargeToken) {\n', '            IERC20(chargeToken).safeTransferFrom(msg.sender, address(this), chargePrice);\n', '\n', '            // If the token purchase is made with chargeToken and buyBackAndBurn is enabled\n', '            // submit buyBackBurn.\n', '            if (buyBackAndBurn) {\n', '                buyBackAndBurnTokens(chargePrice);\n', '            }\n', '\n', '            addSaleToUserHistory(_id, _token, tokenPrice, wethPrice, chargePrice);\n', '            emit Purchase(msg.sender, _id);\n', '\n', '        } else if (_token == WETH) {\n', '\n', '            IERC20(WETH).safeTransferFrom(msg.sender, address(this), wethPrice);\n', '\n', '            swapWETHToChargeToken(chargePrice, wethPrice);\n', '\n', '            addSaleToUserHistory(_id, _token, tokenPrice, wethPrice, chargePrice);\n', '            emit Purchase(msg.sender, _id);\n', '\n', '        } else {\n', '\n', '            IERC20(_token).safeTransferFrom(msg.sender, address(this), tokenPrice);\n', '\n', '            swapTokenToChargeToken(_token, chargePrice, tokenPrice);\n', '\n', '            addSaleToUserHistory(_id, _token, tokenPrice, wethPrice, chargePrice);\n', '            emit Purchase(msg.sender, _id);\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function buyBackAndBurnTokens(uint256 chargePrice) internal {\n', '        // Just buy 1% of the prefToken and burn it\n', '\n', '        // Use 1% to buy\n', '        uint256 amountBuy = chargePrice.div(100);\n', '        address[] memory path = new address[](3);\n', '        path[0] = chargeToken;\n', '        path[1] = WETH;\n', '        path[2] = prefToken;\n', '\n', '\n', '        // Check allowance and approve if needed\n', '        uint256 allowance = IERC20(chargeToken).allowance(address(this), router);\n', '        if (allowance < amountBuy) {\n', '            IERC20(chargeToken).approve(router, uint256(-1));\n', '        }\n', '\n', '        IUniswapV2Router02(router).swapExactTokensForTokens(amountBuy, 0, path, address(this), block.timestamp + 2000);\n', '\n', '        IERC20(prefToken).transfer(address(0xdeAD00000000000000000000000000000000dEAd), IERC20(prefToken).balanceOf(address(this)));\n', '    }\n', '\n', '    function swapWETHToChargeToken(uint256 chargePrice, uint256 wethPrice) internal {\n', '\n', '        // Change all WETH to Charge Token\n', '        address[] memory path = new address[](2);\n', '        path[0] = WETH;\n', '        path[1] = chargeToken;\n', '\n', '        // Check allowance and approve if needed\n', '        uint256 allowance = IERC20(WETH).allowance(address(this), router);\n', '        if (allowance < wethPrice) {\n', '            IERC20(WETH).approve(router, uint256(-1));\n', '        }\n', '\n', '        IUniswapV2Router02(router).swapExactTokensForTokens(wethPrice, chargePrice, path, address(this), block.timestamp + 200);\n', '\n', '        if (buyBackAndBurn) {\n', '            buyBackAndBurnTokens(chargePrice);\n', '        }\n', '\n', '    }\n', '\n', '    function swapTokenToChargeToken(address _token, uint256 chargePrice, uint256 tokenAmount) internal {\n', '\n', '        // Change all Token to Charge Token\n', '        address[] memory path = new address[](3);\n', '        path[0] = _token;\n', '        path[1] = WETH;\n', '        path[2] = chargeToken;\n', '\n', '        uint256 allowance = IERC20(_token).allowance(address(this), router);\n', '        if (allowance < tokenAmount) {\n', '            IERC20(_token).approve(router, uint256(-1));\n', '        }\n', '\n', '        IUniswapV2Router02(router).swapExactTokensForTokens(tokenAmount, chargePrice, path, address(this), block.timestamp + 200);\n', '\n', '        if (buyBackAndBurn) {\n', '            buyBackAndBurnTokens(chargePrice);\n', '        }\n', '\n', '    }\n', '\n', '    function addSaleToUserHistory(uint256 _id, address _token, uint256 tokenPrice, uint256 wethPrice, uint256 chargePrice) internal {\n', '        Sale memory sale = Sale(_id, _token, tokenPrice, wethPrice, chargePrice, block.timestamp);\n', '        history[msg.sender].push(sale);\n', '    }\n', '\n', '\n', '    // register to hash email into the internal map\n', '    // If the user calls again it replaces the information.\n', '    function register(string calldata email) public {\n', '        users[msg.sender] = getEmailHash(email);\n', '    }\n', '\n', '    // setFee modifies the fee for all tokens.\n', '    function setFee(uint256 newFee) public onlyOwner {\n', '        fee = newFee;\n', '    }\n', '\n', '    // setFeeForPrefToken modifies the fee for the preferable token.\n', '    function setFeeForPrefToken(uint256 newFee) public onlyOwner {\n', '        feeForPrefToken = newFee;\n', '    }\n', '\n', '    // claim sends the chargeToken to the owner\n', '    function claim() public onlyOwner {\n', '        uint256 balance = IERC20(chargeToken).balanceOf(address(this));\n', '        IERC20(chargeToken).safeTransfer(owner(), balance);\n', '    }\n', '\n', '    // addBulkProducts adds the products to the catalogue (Maximum of 200 products). Overrides if already exist.\n', '    function addBulkProducts(Product[] memory _products) public onlyOwner {\n', '        uint256 length = _products.length;\n', '        require(length < 200, "POS: addBulkProducts can only add a maximum of 200 products");\n', '        for (uint256 i = 0; i < length; i++) {\n', '            addProduct(_products[i]);\n', '        }\n', '    }\n', '\n', '    // addProduct adds a specific product to the catalogue, overrides if exist.\n', '    function addProduct(Product memory _product) public onlyOwner {\n', '        // Check if product already exist\n', '        if (products[_product.id].id == 0 && products[_product.id].price == 0) {\n', '            productsList.push(_product.id);\n', '        }\n', '        products[_product.id] = _product;\n', '    }\n', '}']