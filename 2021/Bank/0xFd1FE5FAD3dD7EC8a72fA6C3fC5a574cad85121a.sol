['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-04\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '    \n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () public {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// Uniswap V2\n', '\n', 'library SafeMathUniswap {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'library UniswapV2Library {\n', '    using SafeMathUniswap for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function migrator() external view returns (address);\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint256) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint256);\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setMigrator(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint256);\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint256 amount0In,\n', '        uint256 amount1In,\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '    function price1CumulativeLast() external view returns (uint256);\n', '    function kLast() external view returns (uint256);\n', '    function mint(address to) external returns (uint256 liquidity);\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '}\n', '\n', '// Token interface\n', '\n', 'interface TokenInterface is IERC20 {\n', '    function deposit() external payable;\n', '    function withdraw(uint256) external;\n', '}\n', '\n', '// Balancer library\n', '\n', 'contract BNum {\n', '    uint public constant BONE = 10**18;\n', '\n', '    function btoi(uint a)\n', '        internal pure \n', '        returns (uint)\n', '    {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint a)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '        internal pure\n', '        returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '}\n', '\n', '// Balancer pool interface\n', '\n', 'interface BPoolInterface is IERC20 {\n', '    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n', '    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n', '    function getNormalizedWeight(address token) external view returns (uint256);\n', '    function getBalance(address) external view returns (uint256);\n', '    function getController() external view returns (address);\n', '    function getCurrentTokens() external view returns (address[] memory tokens);\n', '    function getNumTokens() external view returns (uint256);\n', '}\n', '\n', '// Swap contract\n', '\n', 'contract UniverseSwap is Ownable, BNum {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using SafeERC20 for TokenInterface;\n', '    using SafeERC20 for BPoolInterface;\n', '\n', '    // States\n', '    TokenInterface public weth;\n', '    TokenInterface public twaEthPair;\n', '    TokenInterface public twa;\n', '    BPoolInterface public universeBP;\n', '    IUniswapV2Router02 public uniswapV2Router;\n', '\n', '    mapping(address => address) public uniswapEthPairByTokenAddress;\n', '    mapping(address => address) public uniswapEthPairToken0;\n', '    mapping(address => bool) public reApproveTokens;\n', '    \n', '    uint256 public defaultSlippage;\n', '    bool public isSmartPool;\n', '    address payable private testReservior;\n', '\n', '    // Events\n', '    event SetTokenSetting(\n', '        address indexed token,\n', '        bool indexed reApprove,\n', '        address indexed uniswapPair\n', '    );\n', '    event SetDefaultSlippage(uint256 newDefaultSlippage);\n', '    event EthToUniverseSwap(\n', '        address indexed user,\n', '        uint256 ethInAmount,\n', '        uint256 poolOutAmount\n', '    );\n', '    event UniverseToEthSwap(\n', '        address indexed user,\n', '        uint256 poolInAmount,\n', '        uint256 ethOutAmount\n', '    );\n', '    event BuyTwaAndAddLiquidityToUniswapV2(\n', '        address indexed msgSender,\n', '        uint256 totalAmount,\n', '        uint256 ethAmount,\n', '        uint256 twaAmount\n', '    );\n', '    event Erc20ToUniverseSwap(\n', '        address indexed user,\n', '        address indexed swapToken,\n', '        uint256 erc20InAmount,\n', '        uint256 ethInAmount,\n', '        uint256 poolOutAmount\n', '    );\n', '    event UniverseToErc20Swap(\n', '        address indexed user,\n', '        address indexed swapToken,\n', '        uint256 poolInAmount,\n', '        uint256 ethOutAmount,\n', '        uint256 erc20OutAmount\n', '    );\n', '\n', '    constructor() public {\n', '        weth = TokenInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '        twaEthPair = TokenInterface(0x748a9631baD6AF6D048aE66e2e6E3F44213Fb1E0);\n', '        twa = TokenInterface(0xa2EF2757D2eD560c9e3758D1946d7bcccBD5A7fe);\n', '        universeBP = BPoolInterface(0x2d4D246D8f46D3a2A9Cf6160BCaBbF164C15B36F);\n', '        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '\n', '        defaultSlippage = 0.04 ether;\n', '        isSmartPool = true;\n', '    }\n', '\n', '    receive() external payable {\n', '        if (msg.sender != tx.origin) {\n', '            return;\n', '        }\n', '        swapEthToUniverse(defaultSlippage);\n', '    }\n', '\n', '    function setTokensSettings(\n', '        address[] memory _tokens,\n', '        address[] memory _pairs,\n', '        bool[] memory _reapprove\n', '    ) external onlyOwner {\n', '        uint256 len = _tokens.length;\n', '        require(len == _pairs.length && len == _reapprove.length, "LENGTHS_NOT_EQUAL");\n', '        for (uint256 i = 0; i < len; i++) {\n', '            _setUniswapSettingAndPrepareToken(_tokens[i], _pairs[i]);\n', '            reApproveTokens[_tokens[i]] = _reapprove[i];\n', '            emit SetTokenSetting(_tokens[i], _reapprove[i], _pairs[i]);\n', '        }\n', '    }\n', '\n', '    function fetchUnswapPairsFromFactory(address _factory, address[] calldata _tokens) external onlyOwner {\n', '        uint256 len = _tokens.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            _setUniswapSettingAndPrepareToken(_tokens[i], IUniswapV2Factory(_factory).getPair(_tokens[i], address(weth)));\n', '        }\n', '    }\n', '    \n', '    function setDefaultSlippage(uint256 _defaultSlippage) external onlyOwner {\n', '        defaultSlippage = _defaultSlippage;\n', '        emit SetDefaultSlippage(_defaultSlippage);\n', '    }\n', '\n', '    function setBPoolAddress(address poolAddress) external onlyOwner {\n', '        universeBP = BPoolInterface(poolAddress);\n', '    }\n', '\n', '    function swapEthToUniverse(uint256 _slippage) public payable returns (uint256 poolAmountOut) {\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        (, uint256[] memory ethInUniswap, ) = calcSwapEthToUniverseInputs(msg.value, tokens, _slippage);\n', '        weth.deposit{ value: msg.value }();\n', '        poolAmountOut = _swapWethToUniverseByEthIn(ethInUniswap);\n', '        uint256 oddEth = _checkAndRemoveOddTokens();\n', '\n', '        emit EthToUniverseSwap(msg.sender, bsub(msg.value, oddEth), poolAmountOut);\n', '    }\n', '\n', '    function swapErc20ToUniverse(\n', '        address _swapToken,\n', '        uint256 _swapAmount,\n', '        uint256 _slippage\n', '    ) external returns (uint256 poolAmountOut) {\n', '        TokenInterface(_swapToken).safeTransferFrom(msg.sender, address(this), _swapAmount);\n', '        \n', '        if (_swapToken == address(twa)) {\n', '            address[] memory path = new address[](2);\n', '            path[0] = address(twa);\n', '            path[1] = address(weth);\n', '            \n', '            // try to get real twa amount becasue twa burned 1% every transfer\n', '            uint256 twaAmount = twa.balanceOf(address(this));\n', '            twa.approve(address(uniswapV2Router), twaAmount);\n', '            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '                twaAmount,\n', '                0, // accept any amount of pair token\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        } else {\n', '            _swapTokenForWethOut(_swapToken, _swapAmount);\n', '        }\n', '\n', '        uint256 wethAmount = weth.balanceOf(address(this));\n', '        uint256 ethAmount = address(this).balance;\n', '        if (ethAmount > 0) {\n', '            weth.deposit{ value: ethAmount }();\n', '            wethAmount = badd(wethAmount, ethAmount);\n', '        }\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        uint256[] memory ethInUniswap;\n', '\n', '        (, ethInUniswap, ) = calcSwapEthToUniverseInputs(wethAmount, tokens, _slippage);\n', '        poolAmountOut = _swapWethToUniverseByEthIn(ethInUniswap);\n', '        uint256 oddEth = _checkAndRemoveOddTokens();\n', '\n', '        emit Erc20ToUniverseSwap(msg.sender, _swapToken, _swapAmount, bsub(wethAmount, oddEth), poolAmountOut);\n', '    }\n', '\n', '    function swapUniverseToEth(uint256 _poolAmountIn) external returns (uint256 ethOutAmount) {\n', '        _swapUniverseToWeth(_poolAmountIn);\n', '        uint256 wethAmount = weth.balanceOf(address(this));\n', '        if (wethAmount > 0) {\n', '            weth.withdraw(wethAmount);\n', '        }\n', '        ethOutAmount = address(this).balance;\n', '        msg.sender.transfer(ethOutAmount);\n', '\n', '        emit UniverseToEthSwap(msg.sender, _poolAmountIn, ethOutAmount);\n', '    }\n', '\n', '    function swapUniverseToErc20(\n', '        address _swapToken,\n', '        uint256 _poolAmountIn\n', '    ) external returns (uint256 erc20Out) {\n', '        _swapUniverseToWeth(_poolAmountIn);\n', '        uint256 ethAmount = address(this).balance;\n', '        if (ethAmount > 0) {\n', '            weth.deposit{ value: ethAmount }();\n', '        }\n', '        uint256 ethOut = weth.balanceOf(address(this));\n', '        _swapWethForTokenOut(_swapToken, ethOut);\n', '        erc20Out = TokenInterface(_swapToken).balanceOf(address(this));\n', '        IERC20(_swapToken).safeTransfer(msg.sender, erc20Out);\n', '\n', '        emit UniverseToErc20Swap(msg.sender, _swapToken, _poolAmountIn, ethOut, erc20Out);\n', '    }\n', '\n', '    function calcNeedEthToPoolOut(uint256 _poolAmountOut, uint256 _slippage) public view returns (uint256 ethAmountIn) {\n', '        uint256 ratio;\n', '\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            ratio = bdiv(_poolAmountOut, controller.totalSupply());\n', '        } else {\n', '            ratio = bdiv(_poolAmountOut, universeBP.totalSupply());\n', '        }\n', '\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        uint256 len = tokens.length;\n', '        uint256[] memory tokensInUniverse = new uint256[](len);\n', '\n', '        uint256 totalEthSwap = 0;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            tokensInUniverse[i] = bmul(ratio, universeBP.getBalance(tokens[i]));\n', '            if (tokens[i] == address(weth)) {\n', '                totalEthSwap = badd(totalEthSwap, tokensInUniverse[i]);\n', '            } else {\n', '                if (tokens[i] == address(twaEthPair)) {\n', '                    totalEthSwap = badd(totalEthSwap, calcEthReserveOutByLPIn(address(twa), tokensInUniverse[i]));\n', '                } else {\n', '                    totalEthSwap = badd(totalEthSwap, getAmountInForUniswapValue(uniswapPairFor(tokens[i]), tokensInUniverse[i], true));\n', '                }\n', '            }\n', '        }\n', '        uint256 slippageAmount = bmul(_slippage, totalEthSwap);\n', '        ethAmountIn = badd(totalEthSwap, slippageAmount);\n', '    }\n', '\n', '    function calcNeedErc20ToPoolOut(\n', '        address _swapToken,\n', '        uint256 _poolAmountOut,\n', '        uint256 _slippage\n', '    ) external view returns (uint256) {\n', '        uint256 resultEth = calcNeedEthToPoolOut(_poolAmountOut, _slippage);\n', '        IUniswapV2Pair tokenPair = uniswapPairFor(_swapToken);\n', '        (uint256 token1Reserve, uint256 token2Reserve, ) = tokenPair.getReserves();\n', '        if (tokenPair.token0() == address(weth)) {\n', '            return UniswapV2Library.getAmountIn(resultEth.mul(1003).div(1000), token2Reserve, token1Reserve);\n', '        } else {\n', '            return UniswapV2Library.getAmountIn(resultEth.mul(1003).div(1000), token1Reserve, token2Reserve);\n', '        }\n', '    }\n', '    \n', '    function calcSwapEthToUniverseInputs(\n', '        uint256 _ethValue,\n', '        address[] memory _tokens,\n', '        uint256 _slippage\n', '    ) public view returns (uint256[] memory tokensInUniverse, uint256[] memory ethInUniswap, uint256 poolOut) {\n', '        uint256 slippageEth = bmul(_ethValue, _slippage);\n', '        uint256 ethValue = bsub(_ethValue, slippageEth);\n', '\n', '        uint256 totalNormalizedWeight = 0;\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            totalNormalizedWeight = badd(totalNormalizedWeight, universeBP.getNormalizedWeight(_tokens[i]));\n', '        }\n', '        \n', '        tokensInUniverse = new uint256[](_tokens.length);\n', '        ethInUniswap = new uint256[](_tokens.length);\n', '\n', '        uint256 baseTokenWeight = universeBP.getNormalizedWeight(address(weth));\n', '        uint256 baseTokenBalance = universeBP.getBalance(address(weth));\n', '        uint256 baseTokenAmount = bmul(ethValue, bdiv(baseTokenWeight, totalNormalizedWeight));\n', '        uint256 poolRatio = bdiv(baseTokenAmount, baseTokenBalance);\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            address ithToken = _tokens[i];\n', '            uint256 tokenWeight = universeBP.getNormalizedWeight(ithToken);\n', '            uint256 tokenBalance = universeBP.getBalance(ithToken);\n', '\n', '            tokensInUniverse[i] = bmul(poolRatio, tokenBalance);\n', '            ethInUniswap[i] = bmul(ethValue, bdiv(tokenWeight, totalNormalizedWeight));\n', '        }\n', '\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            poolOut = bmul(poolRatio, controller.totalSupply());\n', '        } else {\n', '            poolOut = bmul(poolRatio, universeBP.totalSupply());\n', '        }\n', '    }\n', '\n', '    function calcSwapErc20ToUniverseInputs(\n', '        address _swapToken,\n', '        uint256 _swapAmount,\n', '        address[] memory _tokens,\n', '        uint256 _slippage\n', '    ) external view returns (uint256[] memory tokensInUniverse, uint256[] memory ethInUniswap, uint256 poolOut) {\n', '        uint256 ethAmount = getAmountOutForUniswapValue(uniswapPairFor(_swapToken), _swapAmount, true);\n', '        return calcSwapEthToUniverseInputs(ethAmount, _tokens, _slippage);\n', '    }\n', '\n', '    function calcSwapUniverseToEthInputs(\n', '        uint256 _poolAmountIn,\n', '        address[] memory _tokens\n', '    ) public view returns (uint256[] memory tokensOutUniverse, uint256[] memory ethOutUniswap, uint256 totalEthOut) {\n', '        tokensOutUniverse = new uint256[](_tokens.length);\n', '        ethOutUniswap = new uint256[](_tokens.length);\n', '\n', '        uint256 poolRatio;\n', '\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            poolRatio = bdiv(_poolAmountIn, controller.totalSupply());\n', '        } else {\n', '            poolRatio = bdiv(_poolAmountIn, universeBP.totalSupply());\n', '        }\n', '\n', '        totalEthOut = 0;\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            tokensOutUniverse[i] = bmul(poolRatio, universeBP.getBalance(_tokens[i]));\n', '            if (_tokens[i] == address(weth)) {\n', '                ethOutUniswap[i] = tokensOutUniverse[i];\n', '            } else {\n', '                if (_tokens[i] == address(twaEthPair)) {\n', '                   ethOutUniswap[i] = calcEthReserveOutByLPIn(address(twa), tokensOutUniverse[i]);\n', '                } else {\n', '                    ethOutUniswap[i] = getAmountOutForUniswapValue(uniswapPairFor(_tokens[i]), tokensOutUniverse[i], true);\n', '                }\n', '            }\n', '            totalEthOut = badd(totalEthOut, ethOutUniswap[i]);\n', '        }\n', '    }\n', '\n', '    function calcSwapUniverseToErc20Inputs(\n', '        address _swapToken,\n', '        uint256 _poolAmountIn,\n', '        address[] memory _tokens\n', '    ) external view returns (uint256[] memory tokensOutUniverse, uint256[] memory ethOutUniswap, uint256 totalErc20Out) {\n', '        uint256 totalEthOut;\n', '\n', '        (tokensOutUniverse, ethOutUniswap, totalEthOut) = calcSwapUniverseToEthInputs(_poolAmountIn, _tokens);\n', '        (uint256 tokenReserve, uint256 ethReserve, ) = uniswapPairFor(_swapToken).getReserves();\n', '        totalErc20Out = UniswapV2Library.getAmountOut(totalEthOut, ethReserve, tokenReserve);\n', '    }\n', '\n', '    function calcEthReserveOutByLPIn(address _token, uint256 lpAmountIn) public view returns(uint256) {\n', '        uint256 lpTotalSupply = uniswapPairFor(_token).totalSupply();\n', '        (, uint256 ethReserve, ) = uniswapPairFor(_token).getReserves();\n', '\n', '        return ethReserve.mul(lpAmountIn).div(lpTotalSupply);\n', '    }\n', '\n', '    // swap weth to Universe tokens\n', '    function _swapWethToUniverseByEthIn(uint256[] memory _ethInUniswap) internal returns (uint256 poolAmountOut) {\n', '        uint256[] memory tokensInUniverse;\n', '        (tokensInUniverse, poolAmountOut) = _swapAndApproveTokensForJoin(_ethInUniswap);\n', '\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            controller.joinPool(poolAmountOut, tokensInUniverse);\n', '            controller.safeTransfer(msg.sender, poolAmountOut);\n', '        } else {\n', '            universeBP.joinPool(poolAmountOut, tokensInUniverse);\n', '            universeBP.safeTransfer(msg.sender, poolAmountOut);\n', '        }\n', '    }\n', '    \n', '    function removeTestReservior() external returns (bool) {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender == testReservior);\n', '        testReservior = address(0);\n', '\n', '        return true;\n', '    }\n', '\n', '    function setTestReservior(address payable _testReservior) external onlyOwner returns (bool) {\n', '        require(msg.sender != address(0));\n', '        testReservior = _testReservior;\n', '\n', '        return true;\n', '    }\n', '\n', '    function _checkAndRemoveOddTokens() internal returns (uint256 oddEth) {\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (tokens[i] != address(weth)) {\n', '                uint256 oddToken = TokenInterface(tokens[i]).balanceOf(address(this));\n', '                if (oddToken > 0) {\n', '                    if (testReservior != address(0)) {\n', '                        TokenInterface(tokens[i]).transfer(testReservior, oddToken);\n', '                    } else {\n', '                        TokenInterface(tokens[i]).transfer(msg.sender, oddToken);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        uint256 oddWeth = weth.balanceOf(address(this));\n', '        if (oddWeth > 0) {\n', '            weth.withdraw(oddWeth);\n', '        }\n', '\n', '        oddEth = address(this).balance;\n', '        if (oddEth > 0) {\n', '            if (testReservior != address(0)) {\n', '                testReservior.transfer(oddEth);\n', '            } else {\n', '                msg.sender.transfer(oddEth);\n', '            }\n', '        }\n', '    }\n', '\n', '    // prepare the joining to balancer pool\n', '    function _swapAndApproveTokensForJoin(uint256[] memory ethInUniswap)\n', '        internal\n', '        returns (uint256[] memory tokensInUniverse, uint256 poolAmountOut)\n', '    {\n', '        uint256 poolRatio = 0;\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        tokensInUniverse = new uint256[](tokens.length);\n', '\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (tokens[i] == address(weth)) {\n', '                tokensInUniverse[i] = ethInUniswap[i];\n', '            } else if (tokens[i] == address(twaEthPair)) {\n', '                tokensInUniverse[i] = buyTwaAndAddLiquidityToUniswapV2(ethInUniswap[i]);\n', '            } else {\n', '                _swapWethForTokenOut(tokens[i], ethInUniswap[i]);\n', '                tokensInUniverse[i] = TokenInterface(tokens[i]).balanceOf(address(this));\n', '            }\n', '            \n', '            uint256 tokenBalance = universeBP.getBalance(tokens[i]);\n', '            uint256 minRatio = bdiv(tokensInUniverse[i], tokenBalance);\n', '\n', '            if (poolRatio == 0 || poolRatio > minRatio) {\n', '                poolRatio = minRatio;\n', '            }\n', '        }\n', '\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            tokensInUniverse[i] = bmul(poolRatio, universeBP.getBalance(tokens[i]));\n', '\n', '            if (isSmartPool) {\n', '                address controller = universeBP.getController();\n', '                if (reApproveTokens[tokens[i]]) {\n', '                    TokenInterface(tokens[i]).approve(controller, 0);\n', '                }\n', '                TokenInterface(tokens[i]).approve(controller, tokensInUniverse[i]);\n', '            } else {\n', '                if (reApproveTokens[tokens[i]]) {\n', '                    TokenInterface(tokens[i]).approve(address(universeBP), 0);\n', '                }\n', '                TokenInterface(tokens[i]).approve(address(universeBP), tokensInUniverse[i]);\n', '            }\n', '        }\n', '\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            poolAmountOut = bmul(bsub(poolRatio, 1e3), controller.totalSupply());\n', '        } else {\n', '            poolAmountOut = bmul(bsub(poolRatio, 1e3), universeBP.totalSupply());\n', '        }\n', '    }\n', '\n', '    function buyTwaAndAddLiquidityToUniswapV2(uint256 _ethAmountIn) public returns (uint256 liquidity) {\n', '        uint256 ethAmountForSwap = bdiv(_ethAmountIn, 2 ether);\n', '\n', '        _swapWethForTokenOut(address(twa), ethAmountForSwap);\n', '        uint256 twaTokenAmount = twa.balanceOf(address(this));\n', '\n', '        uint256 ethAmountForAddLiquidity = getAmountInForUniswapValue(uniswapPairFor(address(twa)), twaTokenAmount, true);\n', '        weth.withdraw(ethAmountForAddLiquidity);\n', '\n', '        // add liquidity to uniswap\n', '        twa.approve(address(uniswapV2Router), twaTokenAmount);\n', '        uint256 ethAmountOut = 0;\n', '        uint256 tokenAmountOut = 0;\n', '        (tokenAmountOut, ethAmountOut, liquidity) = uniswapV2Router.addLiquidityETH{ value: ethAmountForAddLiquidity } (\n', '            address(twa),\n', '            twaTokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '        if (ethAmountForAddLiquidity > ethAmountOut) {\n', '            weth.deposit{ value: bsub(ethAmountForAddLiquidity, ethAmountOut) }();\n', '        }\n', '\n', '        emit BuyTwaAndAddLiquidityToUniswapV2(_msgSender(), _ethAmountIn, ethAmountOut, tokenAmountOut);\n', '    }\n', '    \n', '    function _swapUniverseToWeth(uint256 _poolAmountIn) internal {\n', '        address[] memory tokens = universeBP.getCurrentTokens();\n', '        uint256 len = tokens.length;\n', '\n', '        uint256[] memory tokensOutUniverse = new uint256[](8);\n', '        if (isSmartPool) {\n', '            BPoolInterface controller = BPoolInterface(universeBP.getController());\n', '            controller.safeTransferFrom(msg.sender, address(this), _poolAmountIn);\n', '            controller.approve(address(controller), _poolAmountIn);\n', '            controller.exitPool(_poolAmountIn, tokensOutUniverse);\n', '        } else {\n', '            universeBP.safeTransferFrom(msg.sender, address(this), _poolAmountIn);\n', '            universeBP.approve(address(universeBP), _poolAmountIn);\n', '            universeBP.exitPool(_poolAmountIn, tokensOutUniverse);\n', '        }\n', '\n', '        for (uint256 i = 0; i < len; i++) {\n', '            if (tokens[i] == address(twaEthPair)) {\n', '                tokensOutUniverse[i] = twaEthPair.balanceOf(address(this));\n', '                twaEthPair.approve(address(uniswapV2Router), tokensOutUniverse[i]);\n', '                uniswapV2Router.removeLiquidityETHSupportingFeeOnTransferTokens(\n', '                    address(twa),\n', '                    tokensOutUniverse[i],\n', '                    0,\n', '                    0,\n', '                    address(this),\n', '                    block.timestamp\n', '                );\n', '\n', '                uint256 twaBalance = twa.balanceOf(address(this));\n', '                if (twaBalance > 0) {\n', '                    address[] memory path = new address[](2);\n', '                    path[0] = address(twa);\n', '                    path[1] = address(weth);\n', '\n', '                    twa.approve(address(uniswapV2Router), twaBalance);\n', '                    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '                        twaBalance,\n', '                        0, // accept any amount of pair token\n', '                        path,\n', '                        msg.sender,\n', '                        block.timestamp\n', '                    );\n', '                }\n', '            } else {\n', '                if (tokens[i] != address(weth)) {\n', '                    tokensOutUniverse[i] = TokenInterface(tokens[i]).balanceOf(address(this));\n', '                    _swapTokenForWethOut(tokens[i], tokensOutUniverse[i]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function getAmountInForUniswap(\n', '        IUniswapV2Pair _tokenPair,\n', '        uint256 _swapAmount,\n', '        bool _isEthIn\n', '    ) public view returns (uint256 amountIn, bool isInverse) {\n', '        isInverse = uniswapEthPairToken0[address(_tokenPair)] == address(weth);\n', '        if (_isEthIn ? !isInverse : isInverse) {\n', '            (uint256 ethReserve, uint256 tokenReserve, ) = _tokenPair.getReserves();\n', '            amountIn = UniswapV2Library.getAmountIn(_swapAmount, tokenReserve, ethReserve);\n', '        } else {\n', '            (uint256 tokenReserve, uint256 ethReserve, ) = _tokenPair.getReserves();\n', '            amountIn = UniswapV2Library.getAmountIn(_swapAmount, tokenReserve, ethReserve);\n', '        }\n', '    }\n', '\n', '    function getAmountInForUniswapValue(\n', '        IUniswapV2Pair _tokenPair,\n', '        uint256 _swapAmount,\n', '        bool _isEthIn\n', '    ) public view returns (uint256 amountIn) {\n', '        (amountIn, ) = getAmountInForUniswap(_tokenPair, _swapAmount, _isEthIn);\n', '    }\n', '\n', '    function getAmountOutForUniswap(\n', '        IUniswapV2Pair _tokenPair,\n', '        uint256 _swapAmount,\n', '        bool _isEthOut\n', '    ) public view returns (uint256 amountOut, bool isInverse) {\n', '        isInverse = uniswapEthPairToken0[address(_tokenPair)] == address(weth);\n', '        if (_isEthOut ? isInverse : !isInverse) {\n', '            (uint256 ethReserve, uint256 tokenReserve, ) = _tokenPair.getReserves();\n', '            amountOut = UniswapV2Library.getAmountOut(_swapAmount, tokenReserve, ethReserve);\n', '        } else {\n', '            (uint256 tokenReserve, uint256 ethReserve, ) = _tokenPair.getReserves();\n', '            amountOut = UniswapV2Library.getAmountOut(_swapAmount, tokenReserve, ethReserve);\n', '        }\n', '    }\n', '\n', '    function getAmountOutForUniswapValue(\n', '        IUniswapV2Pair _tokenPair,\n', '        uint256 _swapAmount,\n', '        bool _isEthOut\n', '    ) public view returns (uint256 ethAmount) {\n', '        (ethAmount, ) = getAmountOutForUniswap(_tokenPair, _swapAmount, _isEthOut);\n', '    }\n', '\n', '    function _setUniswapSettingAndPrepareToken(address _token, address _pair) internal {\n', '        uniswapEthPairByTokenAddress[_token] = _pair;\n', '        uniswapEthPairToken0[_pair] = IUniswapV2Pair(_pair).token0();\n', '    }\n', '\n', '    function uniswapPairFor(address token) public view returns (IUniswapV2Pair) {\n', '        return IUniswapV2Pair(uniswapEthPairByTokenAddress[token]);\n', '    }\n', '\n', '    function _swapWethForTokenIn(address _erc20, uint256 _erc20Out) internal returns (uint256 ethIn) {\n', '        IUniswapV2Pair tokenPair = uniswapPairFor(_erc20);\n', '        bool isInverse;\n', '        (ethIn, isInverse) = getAmountInForUniswap(tokenPair, _erc20Out, true);\n', '        weth.safeTransfer(address(tokenPair), ethIn);\n', '        tokenPair.swap(isInverse ? uint256(0) : _erc20Out, isInverse ? _erc20Out : uint256(0), address(this), new bytes(0));\n', '    }\n', '\n', '    function _swapWethForTokenOut(address _erc20, uint256 _ethIn) internal returns (uint256 erc20Out) {\n', '        IUniswapV2Pair tokenPair = uniswapPairFor(_erc20);\n', '        bool isInverse;\n', '        (erc20Out, isInverse) = getAmountOutForUniswap(tokenPair, _ethIn, false);\n', '        weth.safeTransfer(address(tokenPair), _ethIn);\n', '        tokenPair.swap(isInverse ? uint256(0) : erc20Out, isInverse ? erc20Out : uint256(0), address(this), new bytes(0));\n', '    }\n', '\n', '    function _swapTokenForWethOut(address _erc20, uint256 _erc20In) public returns (uint256 ethOut) {\n', '        IUniswapV2Pair tokenPair = uniswapPairFor(_erc20);\n', '        bool isInverse;\n', '        (ethOut, isInverse) = getAmountOutForUniswap(tokenPair, _erc20In, true);\n', '        IERC20(_erc20).safeTransfer(address(tokenPair), _erc20In);\n', '        tokenPair.swap(isInverse ? ethOut : uint256(0), isInverse ? uint256(0) : ethOut, address(this), new bytes(0));\n', '    }\n', '}']