['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-01\n', '*/\n', '\n', 'pragma solidity 0.7.6;     \n', '\n', '// SPDX-License-Identifier: UNLICENSED \n', '\n', '\n', 'abstract contract ReentrancyGuard {\n', '\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'contract FSilver  {\n', '     function getColor()\n', '        external pure\n', '        returns (bytes32) {\n', '            return bytes32("BRONZE");\n', '        }\n', '}\n', '\n', '\n', 'contract FConst is FSilver, ReentrancyGuard {\n', '    uint public constant BASE              = 10**18;\n', '\n', '    uint public constant MIN_BOUND_TOKENS  = 2;\n', '    uint public constant MAX_BOUND_TOKENS  = 2;\n', '\n', '    uint public constant MIN_FEE           = 2000000000000000; \n', '    uint public constant MAX_FEE           = 2000000000000000; // FREE BUYS and sells pay 0.2% to liquidity providers\n', '    uint public constant EXIT_FEE          = BASE / 100;\n', '    uint public constant DEFAULT_RESERVES_RATIO = 0;\n', '\n', '    uint public constant MIN_WEIGHT        = BASE;\n', '    uint public constant MAX_WEIGHT        = BASE * 50;\n', '    uint public constant MAX_TOTAL_WEIGHT  = BASE * 50;\n', '    uint public constant MIN_BALANCE       = BASE / 10**12;\n', '\n', '    uint public constant INIT_POOL_SUPPLY  = BASE * 100;\n', '    \n', '    uint public  SM = 10;\n', '    address public FEGstake = 0x04788562Ab11eA3a5201d579e2b3Ee7A3F74F1fA;\n', '\n', '    uint public constant MIN_BPOW_BASE     = 1 wei;\n', '    uint public constant MAX_BPOW_BASE     = (2 * BASE) - 1 wei;\n', '    uint public constant BPOW_PRECISION    = BASE / 10**10;\n', '\n', '    uint public constant MAX_IN_RATIO      = BASE / 2;\n', '    uint public constant MAX_OUT_RATIO     = (BASE / 3) + 1 wei;\n', '    uint public MAX_SELL_RATIO             = BASE / SM;\n', '}\n', '\n', '\n', 'contract FNum is ReentrancyGuard, FConst {\n', '\n', '    function btoi(uint a)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        return a / BASE;\n', '    }\n', '\n', '    function bfloor(uint a)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        return btoi(a) * BASE;\n', '    }\n', '\n', '    function badd(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '        internal pure\n', '        returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint c1 = c0 + (BASE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / BASE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint c0 = a * BASE;\n', '        require(a == 0 || c0 / a == BASE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    function bpowi(uint a, uint n)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint z = n % 2 != 0 ? a : BASE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    function bpow(uint base, uint exp)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint whole  = bfloor(exp);\n', '        uint remain = bsub(exp, whole);\n', '\n', '        uint wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(uint base, uint exp, uint precision)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint a     = exp;\n', '        (uint x, bool xneg)  = bsubSign(base, BASE);\n', '        uint term = BASE;\n', '        uint sum   = term;\n', '        bool negative = false;\n', '\n', '\n', '        for (uint i = 1; term >= precision; i++) {\n', '            uint bigK = i * BASE;\n', '            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BASE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '}\n', '\n', 'contract FMath is FSilver, FConst, FNum {\n', '    \n', '        function calcSpotPrice(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint spotPrice)\n', '    {\n', '        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\n', '        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\n', '        uint ratio = bdiv(numer, denom);\n', '        uint scale = bdiv(BASE, bsub(BASE, swapFee));\n', '        return  (spotPrice = bmul(ratio, scale));\n', '    }\n', '\n', '\n', '    function calcOutGivenIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountOut, uint tokenInFee)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n', '        uint adjustedIn = bsub(BASE, swapFee);\n', '        adjustedIn = bmul(tokenAmountIn, adjustedIn);\n', '        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n', '        uint foo = bpow(y, weightRatio);\n', '        uint bar = bsub(BASE, foo);\n', '        tokenAmountOut = bmul(tokenBalanceOut, bar);\n', '        tokenInFee = bsub(tokenAmountIn, adjustedIn);\n', '        return (tokenAmountOut, tokenInFee);\n', '    }\n', '\n', '\n', '    function calcInGivenOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountOut,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountIn, uint tokenInFee)\n', '    {\n', '        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n', '        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\n', '        uint y = bdiv(tokenBalanceOut, diff);\n', '        uint foo = bpow(y, weightRatio);\n', '        foo = bsub(foo, BASE);\n', '        foo = bmul(tokenBalanceIn, foo);\n', '        tokenAmountIn = bsub(BASE, swapFee);\n', '        tokenAmountIn = bdiv(foo, tokenAmountIn);\n', '        tokenInFee = bdiv(foo, BASE);\n', '        tokenInFee = bsub(tokenAmountIn, tokenInFee);\n', '        return (tokenAmountIn, tokenInFee);\n', '    }\n', '\n', '\n', '    function calcPoolOutGivenSingleIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountIn,\n', '        uint swapFee,\n', '        uint reservesRatio\n', '    )\n', '        public pure\n', '        returns (uint poolAmountOut, uint reserves)\n', '    {\n', '\n', '        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\n', '         uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\n', '        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BASE, zaz));\n', '\n', '        reserves = calcReserves(tokenAmountIn, tokenAmountInAfterFee, reservesRatio);\n', '        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\n', '        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\n', '\n', ' \n', '        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\n', '        uint newPoolSupply = bmul(poolRatio, poolSupply);\n', '        poolAmountOut = bsub(newPoolSupply, poolSupply);\n', '        return (poolAmountOut, reserves);\n', '    }\n', '\n', '    function calcSingleOutGivenPoolIn(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint poolAmountIn,\n', '        uint swapFee\n', '    )\n', '        public pure\n', '        returns (uint tokenAmountOut)\n', '    {\n', '        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n', '\n', '        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BASE, EXIT_FEE));\n', '        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\n', '        uint poolRatio = bdiv(newPoolSupply, poolSupply);\n', '\n', '\n', '        uint tokenOutRatio = bpow(poolRatio, bdiv(BASE, normalizedWeight));\n', '        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\n', '\n', '        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\n', '        uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\n', '        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BASE, zaz));\n', '        return tokenAmountOut;\n', '    }\n', '\n', '\n', '    function calcPoolInGivenSingleOut(\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint poolSupply,\n', '        uint totalWeight,\n', '        uint tokenAmountOut,\n', '        uint swapFee,\n', '        uint reservesRatio\n', '    )\n', '        public pure\n', '        returns (uint poolAmountIn, uint reserves)\n', '    {\n', '\n', '\n', '        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\n', '        uint zar = bmul(bsub(BASE, normalizedWeight), swapFee);\n', '        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BASE, zar));\n', '        reserves = calcReserves(tokenAmountOutBeforeSwapFee, tokenAmountOut, reservesRatio);\n', '\n', '        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\n', '        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\n', '\n', '\n', '        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\n', '        uint newPoolSupply = bmul(poolRatio, poolSupply);\n', '        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\n', '\n', '\n', '        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BASE, EXIT_FEE));\n', '        return (poolAmountIn, reserves);\n', '    }\n', '\n', '    function calcReserves(uint amountWithFee, uint amountWithoutFee, uint reservesRatio)\n', '        internal pure\n', '        returns (uint reserves)\n', '    {\n', '        require(amountWithFee >= amountWithoutFee, "ERR_MATH_APPROX");\n', '        require(reservesRatio <= BASE, "ERR_INVALID_RESERVE");\n', '        uint swapFeeAndReserves = bsub(amountWithFee, amountWithoutFee);\n', '        reserves = bmul(swapFeeAndReserves, reservesRatio);\n', '        require(swapFeeAndReserves >= reserves, "ERR_MATH_APPROX");\n', '    }\n', '\n', '    function calcReservesFromFee(uint fee, uint reservesRatio)\n', '        internal pure\n', '        returns (uint reserves)\n', '    {\n', '        require(reservesRatio <= BASE, "ERR_INVALID_RESERVE");\n', '        reserves = bmul(fee, reservesRatio);\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address whom) external view returns (uint);\n', '    function allowance(address src, address dst) external view returns (uint);\n', '\n', '    function approve(address dst, uint amt) external returns (bool);\n', '    function transfer(address dst, uint amt) external returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint amt\n', '    ) external returns (bool);\n', '}\n', '\n', 'interface wrap {\n', '    function deposit() external payable;\n', '    function withdraw(uint amt) external;\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'contract FTokenBase is ReentrancyGuard, FNum {\n', '\n', '    mapping(address => uint)                   internal _balance;\n', '    mapping(address => mapping(address=>uint)) internal _allowance;\n', '    uint internal _totalSupply;\n', '\n', '    event Approval(address indexed src, address indexed dst, uint amt);\n', '    event Transfer(address indexed src, address indexed dst, uint amt);\n', '\n', '    function _mint(uint amt) internal {\n', '        _balance[address(this)] = badd(_balance[address(this)], amt);\n', '        _totalSupply = badd(_totalSupply, amt);\n', '        emit Transfer(address(0), address(this), amt);\n', '    }\n', '\n', '    function _burn(uint amt) internal {\n', '        require(_balance[address(this)] >= amt);\n', '        _balance[address(this)] = bsub(_balance[address(this)], amt);\n', '        _totalSupply = bsub(_totalSupply, amt);\n', '        emit Transfer(address(this), address(0), amt);\n', '    }\n', '\n', '    function _move(address src, address dst, uint amt) internal {\n', '        require(_balance[src] >= amt);\n', '        _balance[src] = bsub(_balance[src], amt);\n', '        _balance[dst] = badd(_balance[dst], amt);\n', '        emit Transfer(src, dst, amt);\n', '    }\n', '\n', '    function _push(address to, uint amt) internal {\n', '        _move(address(this), to, amt);\n', '    }\n', '\n', '    function _pull(address from, uint amt) internal {\n', '        _move(from, address(this), amt);\n', '    }\n', '}\n', '\n', 'contract FToken is ReentrancyGuard, FTokenBase {\n', '\n', '    string  private _name     = "FEGexV2";\n', '    string  private _symbol   = "TRYfETH";\n', '    uint8   private _decimals = 18;\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function allowance(address src, address dst) external view returns (uint) {\n', '        return _allowance[src][dst];\n', '    }\n', '\n', '    function balanceOf(address whom) external view returns (uint) {\n', '        return _balance[whom];\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function approve(address dst, uint amt) external returns (bool) {\n', '        _allowance[msg.sender][dst] = amt;\n', '        emit Approval(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval(address dst, uint amt) external returns (bool) {\n', '        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address dst, uint amt) external returns (bool) {\n', '        uint oldValue = _allowance[msg.sender][dst];\n', '        if (amt > oldValue) {\n', '            _allowance[msg.sender][dst] = 0;\n', '        } else {\n', '            _allowance[msg.sender][dst] = bsub(oldValue, amt);\n', '        }\n', '        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint amt) external returns (bool) {\n', '        FEGexV2 ulock;\n', '        bool getlock = ulock.getUserLock(msg.sender);\n', '        \n', "        require(getlock == true, 'Liquidity is locked, you cannot remove liquidity until after lock time.');\n", '        \n', '        _move(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n', '        require(msg.sender == src || amt <= _allowance[src][msg.sender]);\n', '        FEGexV2 ulock;\n', '        bool getlock = ulock.getUserLock(msg.sender);\n', '        \n', "        require(getlock == true, 'Transfer is Locked ');\n", '        \n', '        \n', '        _move(src, dst, amt);\n', '        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n', '            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n', '            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract FEGexV2 is FSilver, ReentrancyGuard, FToken, FMath {\n', '\n', '    struct Record {\n', '        bool bound;   // is token bound to pool\n', '        uint denorm;  // denormalized weight will always be even\n', '        uint index;\n', '        uint balance;\n', '    }\n', '    \n', '    struct userLock {\n', '        bool setLock; // true = locked, false = unlocked\n', '        uint unlockTime;\n', '    }\n', '    \n', '    function getUserLock(address usr) public view returns(bool lock){\n', '        return _userlock[usr].setLock;\n', '    }\n', '    \n', '    event LOG_SWAP(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        address indexed tokenOut,\n', '        uint256         tokenAmountIn,\n', '        uint256         tokenAmountOut\n', ');\n', '\n', '    event LOG_JOIN(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        uint256         tokenAmountIn,\n', '        uint256         reservesAmount\n', ');\n', '\n', '    event LOG_EXIT(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256         tokenAmountOut,\n', '        uint256         reservesAmount\n', '    );\n', '\n', '    event LOG_CLAIM_RESERVES(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256         tokenAmountOut\n', '    );\n', '\n', '    event LOG_ADD_RESERVES(\n', '        address indexed token,\n', '        uint256         reservesAmount\n', '    );\n', '\n', '    event LOG_CALL(\n', '        bytes4  indexed sig,\n', '        address indexed caller,\n', '        bytes           data\n', '    ) anonymous;\n', '\n', '    modifier _logs_() {\n', '        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n', '        _;\n', '    }\n', '\n', '    modifier _lock_() {\n', '        require(!_mutex);\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    } \n', '\n', '    modifier _viewlock_() {\n', '        require(!_mutex);\n', '        _;\n', '    }\n', '\n', '    bool private _mutex;\n', '\n', '    wrap wrapp;\n', '    address private _factory = 0x1Eb421973d639C3422904c65Cccc2972b37a17e8;    \n', '    address private _controller = 0x4c9BC793716e8dC05d1F48D8cA8f84318Ec3043C; \n', '    address private _poolOwner = 0x76EFf89CDe6ff68103E76dD492e8b25a058fcB2B;\n', '    address public Wrap = 0xf786c34106762Ab4Eeb45a51B42a62470E9D5332;\n', '    address public Token = 0xc12eCeE46ed65D970EE5C899FCC7AE133AfF9b03;\n', '    address public pairRewardPool = 0x4b06ee3d96Ff6568Cf0a779Cdf1190AB968D58d3;\n', '    address public burn = 0x000000000000000000000000000000000000dEaD;\n', '    uint public FSS = 25; // FEGstake Share\n', '    uint public PSS = 500; // pairRewardPool Share \n', '    uint public RPF = 1000; //Smart Rising Price Floor Setting\n', '    uint public SHR = 995; //p2p fee Token\n', '    uint public SHR1 = 997; //p2p fee Wrap\n', '    uint private _swapFee;\n', '    address[] private _tokens;\n', '    uint256 public _totalSupply1;\n', '    uint256 public _totalSupply2;\n', '    bool public live = false;\n', '    mapping(address=>Record) private  _records;\n', '    mapping(address=>userLock) public  _userlock;\n', '    mapping(address=>userLock) public  _unlockTime;\n', '    mapping(address=>bool) public whiteListContract;\n', '    mapping(address => uint256) private _balances1;\n', '    mapping(address => uint256) private _balances2;\n', '    \n', '    uint private _totalWeight;\n', '\n', '    constructor() {\n', '        wrapp = wrap(Wrap);\n', '        //_poolOwner = msg.sender;\n', '        //pairRewardPool = msg.sender;\n', '        _swapFee = MIN_FEE;\n', '    }\n', '    \n', '    receive() external payable {\n', '    }\n', '\n', '    function userBalanceInternal(address _addr) public view returns (uint256 token, uint256 fwrap) {\n', '        return (_balances1[_addr], _balances2[_addr]);\n', '    } \n', '    \n', '    function isContract(address account) internal view returns (bool) {\n', '        \n', '        if(IsWhiteListContract(account)) {  return false; }\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '    \n', '    function addWhiteListContract(address _addy, bool boolean) public {\n', '        require(msg.sender == _controller);\n', '        require(_addy != address(0), "setting 0 address;;");\n', '        \n', '        whiteListContract[_addy] = boolean;\n', '    }\n', '    \n', '    function IsWhiteListContract(address _addy) public view returns(bool){\n', '        require(_addy != address(0), "setting 0 address;;");\n', '        \n', '        return whiteListContract[_addy];\n', '    }\n', '    \n', '    modifier noContract() {\n', "        require(isContract(msg.sender) == false, 'Unapproved contracts are not allowed to interact with the swap');\n", '        _;\n', '    }\n', '    \n', '    function setMaxSellRatio(uint256 _amount) public {\n', '        require(msg.sender == _poolOwner, "You do not have permission");\n', '        require (_amount > 0, "cannot turn off");\n', '        require (_amount <= 100, "cannot set under 1%");\n', '        SM = _amount;\n', '    }\n', '    \n', '    function setStakePool(address _addy) public {\n', '        require(msg.sender == _controller);\n', '    FEGstake = _addy;\n', '    }\n', '    \n', '    function setPairRewardPool(address _addy) public {\n', '        require(msg.sender == _controller);\n', '    pairRewardPool = _addy;\n', '    }\n', '    \n', '    function setupWrap() public {\n', '        IERC20(address(this)).approve(address(Wrap), 100000000000000000e18);        \n', '    }  \n', '    \n', '    function isBound(address t)\n', '        external view\n', '        returns (bool)\n', '    {\n', '        return _records[t].bound;\n', '    }\n', '\n', '    function getFinalTokens()\n', '        external view\n', '        _viewlock_\n', '        returns (address[] memory tokens)\n', '    {\n', '        \n', '        return _tokens;\n', '    }\n', '\n', '    function getDenormalizedWeight(address token)\n', '        external view\n', '        _viewlock_\n', '    {\n', '\n', '        require(_records[token].bound);\n', '    }\n', '\n', '    function getTotalDenormalizedWeight()\n', '        external view\n', '        _viewlock_\n', '        returns (uint)\n', '    {\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getNormalizedWeight(address token)\n', '        external view\n', '        _viewlock_\n', '        returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound);\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getBalance(address token)\n', '        external view\n', '        _viewlock_\n', '        returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound);\n', '        return _records[token].balance;\n', '    }\n', '\n', '    function getSwapFee()\n', '        external view\n', '        _viewlock_\n', '        returns (uint)\n', '    {\n', '        return _swapFee;\n', '    }\n', '\n', '    function getController()\n', '        external view\n', '        _viewlock_\n', '        returns (address)\n', '    {\n', '        return _controller;\n', '    }\n', '\n', '    function setController(address manager)\n', '        external\n', '        _logs_\n', '        _lock_\n', '    {\n', '        require(msg.sender == _controller);\n', '        _controller = manager;\n', '    }\n', '\n', '    function deploySwap (uint256 amtoftoken, uint256 amtofwrap)\n', '        external\n', '        {\n', '        require(msg.sender == _poolOwner);\n', '        require(live == false);\n', '        address tokenIn = Token;\n', '        address tokenIn1 = Wrap;\n', '        \n', '        _records[Token] = Record({\n', '            bound: true,\n', '            denorm: BASE * 25,\n', '            index: _tokens.length,\n', '            balance: (amtoftoken * 98/100)\n', '            \n', '        });\n', '        \n', '        _records[Wrap] = Record({\n', '            bound: true,\n', '            denorm: BASE * 25,\n', '            index: _tokens.length,\n', '            balance: (amtofwrap * 99/100)\n', '        });\n', '        live = true;\n', '        _tokens.push(Token);\n', '        _tokens.push(Wrap);\n', '        _pullUnderlying(tokenIn, msg.sender, amtoftoken);\n', '        _pullUnderlying(tokenIn1, msg.sender, amtofwrap);\n', '        _mint(INIT_POOL_SUPPLY);\n', '        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY); \n', '        address user = msg.sender;\n', '        userLock storage ulock = _userlock[user];\n', '        userLock storage time = _unlockTime[user];\n', '        ulock.setLock = true;\n', '        time.unlockTime = block.timestamp + 365 days ; \n', '    }\n', '   \n', '    function saveLostTokens(address token, uint amount)\n', '        external\n', '        _logs_\n', '        _lock_\n', '    {\n', '        require(msg.sender == _controller);\n', '        require(!_records[token].bound);\n', '\n', '        uint bal = IERC20(token).balanceOf(address(this));\n', '        require(amount <= bal);\n', '\n', '        _pushUnderlying(token, msg.sender, amount);\n', '    }\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '        external view\n', '        _viewlock_\n', '        returns (uint spotPrice)\n', '    {\n', '        \n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '        return calcSpotPrice(inRecord.balance, BASE * 25, outRecord.balance, BASE * 25, _swapFee);}\n', '        \n', '\n', '    function depositToken(uint256 amt)  external noContract nonReentrant {\n', '        address tokenIn = Token;\n', '        _pullUnderlying(tokenIn, msg.sender, amt);\n', '        \n', '       \n', '        uint256 finalAmount = amt * 98/100;\n', '        _totalSupply1 = _totalSupply1 + finalAmount;\n', '        _balances1[msg.sender] = _balances1[msg.sender] + finalAmount;\n', '    }\n', '    \n', '    function depositWrap(uint256 amt)  external noContract nonReentrant {\n', '        address tokenIn = Wrap;\n', '        _pullUnderlying(tokenIn, msg.sender, amt);\n', '        \n', '       \n', '        uint256 finalAmount = amt * 99/100;\n', '        _totalSupply2  = _totalSupply2 + finalAmount;\n', '        _balances2[msg.sender] = _balances2[msg.sender] + finalAmount;\n', '    }\n', '    \n', '    function withdrawToken(uint256 amt) external noContract nonReentrant {\n', '        address tokenIn = Token;\n', '        require(_balances1[msg.sender] >= amt, "Not enough token");\n', '        \n', '        _totalSupply1 = _totalSupply1 - amt;\n', '        _balances1[msg.sender] = _balances1[msg.sender] - amt;\n', '        \n', '        _pushUnderlying(tokenIn, msg.sender, amt);\n', '        \n', '    }\n', '    \n', '    function withdrawWrap(uint256 amt) external noContract nonReentrant{\n', '        address tokenIn = Wrap;\n', '        require(_balances2[msg.sender] >= amt, "Not enough Wrap");\n', '        \n', '        _totalSupply2 = _totalSupply2 - amt;\n', '        _balances2[msg.sender] = _balances2[msg.sender] - amt;\n', '        \n', '        _pushUnderlying(tokenIn, msg.sender, amt);\n', '    }\n', '\n', '    function addBothLiquidity(uint poolAmountOut, uint[] calldata maxAmountsIn)\n', '    noContract nonReentrant\n', '        external\n', '        _logs_\n', '        _lock_\n', '    {\n', '        \n', '\n', '        uint poolTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "ERR_LIMIT_IN");\n', '            emit LOG_JOIN(msg.sender, t, tokenAmountIn * 98/100, 0);\n', '            _pullUnderlying(t, msg.sender, tokenAmountIn);\n', '            _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '            _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '        \n', '    }\n', '   \n', '    function removeBothLiquidity(uint poolAmountIn, uint[] calldata minAmountsOut)\n', '    noContract nonReentrant\n', '        external\n', '        _logs_\n', '        _lock_\n', '    {\n', '        \n', '        userLock storage ulock = _userlock[msg.sender];\n', '        \n', '        if(ulock.setLock == true) {\n', '            require(ulock.unlockTime <= block.timestamp, "Liquidity is locked, you cannot remove liquidity until after lock time.");\n', '        }\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\n', '        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\n', '        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        _pushPoolShare(_factory, exitFee);\n', '        _burnPoolShare(pAiAfterExitFee);\n', '        \n', '        \n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountOut = bmul(ratio, bal);\n', '            require(tokenAmountOut != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountOut >= minAmountsOut[i], "ERR_LIMIT_OUT");\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut, 0);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '            _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '            _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '        }\n', '\n', '    }\n', '\n', '\n', '    function BUYSmart(\n', '        uint tokenAmountIn,\n', '        uint minAmountOut\n', '    ) noContract nonReentrant\n', '        external \n', '        _logs_\n', '        _lock_\n', '        returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '        \n', '        address tokenIn = Wrap;\n', '        address tokenOut = Token;\n', '        require(_balances2[msg.sender] >= tokenAmountIn, "Not enough Wrap, deposit more");\n', '        \n', '        \n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");\n', '        uint spotPriceBefore = calcSpotPrice(\n', '                                    inRecord.balance ,\n', '                                    BASE * 25,\n', '                                    outRecord.balance,\n', '                                    BASE * 25,\n', '                                    _swapFee * 0\n', '                                );\n', '                                \n', '        uint tokenInFee;\n', '        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            tokenAmountIn * 99/100,\n', '                                            _swapFee * 0\n', '                                        );\n', '                                        \n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");                     \n', '        _balances2[msg.sender] = _balances2[msg.sender] - tokenAmountIn;\n', '        _balances1[msg.sender] = _balances1[msg.sender] + tokenAmountOut;\n', '        _totalSupply2 = _totalSupply2 - tokenAmountIn;\n', '        _totalSupply1 = _totalSupply1 + tokenAmountOut;\n', '        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '        \n', '        spotPriceAfter = calcSpotPrice(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            _swapFee * 0\n', '                            );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '    \n', '    function BUY(\n', '        address to,\n', '        uint minAmountOut\n', '    ) noContract nonReentrant\n', '        external payable\n', '        _logs_\n', '        _lock_\n', '        returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '        \n', '        address tokenIn = Wrap;\n', '        address tokenOut = Token;\n', '        \n', '        \n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(msg.value <= bmul(inRecord.balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '                                    inRecord.balance ,\n', '                                    BASE * 25,\n', '                                    outRecord.balance,\n', '                                    BASE * 25,\n', '                                    _swapFee * 0\n', '                                );\n', '\n', '        uint tokenInFee;\n', '        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            msg.value * 99/100,\n', '                                            _swapFee * 0\n', '                                        );\n', '                                        \n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(spotPriceBefore <= bdiv(msg.value * 99/100, tokenAmountOut), "ERR_MATH_APPROX");\n', '        wrap(Wrap).deposit{value: msg.value}();\n', '        _pushUnderlying(tokenOut, to, tokenAmountOut);\n', '        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '        \n', '        spotPriceAfter = calcSpotPrice(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            _swapFee * 0\n', '                            );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        \n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, msg.value * 99/100, tokenAmountOut * 98/100);\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '\n', '    function SELL(\n', '    address to,\n', '        uint tokenAmountIn,\n', '        uint minAmountOut\n', '    ) noContract nonReentrant \n', '        external\n', '        _logs_\n', '        _lock_\n', '        returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '        \n', '        address tokenIn = Token;\n', '        address tokenOut = Wrap;\n', '        \n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountIn <= bmul(inRecord.balance, MAX_SELL_RATIO), "ERR_SELL_RATIO");\n', '                                               \n', '        uint tokenInFee;\n', '        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            tokenAmountIn * 98/100,\n', '                                            _swapFee\n', '                                        );\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        \n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn * 98/100, tokenAmountOut * 99/100);\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '        uint256 toka = bmul(tokenAmountOut, bdiv(RPF, 1000));\n', '        uint256 tokAmountI  = bmul(tokenAmountOut, bdiv(FSS, 10000));\n', '        uint256 tokAmountI2 =  bmul(tokenAmountOut, bdiv(PSS, 10000));\n', '        uint256 tokAmountI1 = bsub(toka, badd(tokAmountI, tokAmountI2));\n', '        uint256 out1 = tokAmountI1;\n', '        wrap(Wrap).withdraw(out1); \n', '        TransferHelper.safeTransferETH(to, (out1 * 99/100)); \n', '        _pushUnderlying1(tokenOut, tokAmountI);\n', '        _balances2[pairRewardPool] = _balances2[pairRewardPool] + tokAmountI2;\n', '        _totalSupply2 = _totalSupply2 + tokAmountI2;\n', '        uint spotPriceBefore = calcSpotPrice(\n', '                                    inRecord.balance,\n', '                                    BASE * 25,\n', '                                    outRecord.balance,\n', '                                    BASE * 25,\n', '                                    _swapFee\n', '                                );\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");                        \n', '        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '        \n', '        spotPriceAfter = calcSpotPrice(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            _swapFee\n', '                            );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        \n', '        \n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '    \n', '     function SELLSmart(\n', '        uint tokenAmountIn,\n', '        uint minAmountOut\n', '    ) noContract nonReentrant\n', '        external\n', '        _logs_\n', '        _lock_\n', '        returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '        \n', '        address tokenIn = Token;\n', '        address tokenOut = Wrap;\n', '        \n', '        require(_balances1[msg.sender] >= tokenAmountIn, "Not enough Token");\n', '        \n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountIn <= bmul(inRecord.balance, MAX_SELL_RATIO), "ERR_SELL_RATIO");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '                                    inRecord.balance,\n', '                                    BASE * 25,\n', '                                    outRecord.balance,\n', '                                    BASE * 25,\n', '                                    _swapFee\n', '                                );\n', '\n', '        uint tokenInFee;\n', '        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            tokenAmountIn * 98/100,\n', '                                            _swapFee\n', '                                        );\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '        uint256 toka = bmul(tokenAmountOut, bdiv(RPF, 1000));\n', '        uint256 tokAmountI  = bmul(tokenAmountOut, bdiv(FSS, 10000));\n', '        uint256 tokAmountI2 =  bmul(tokenAmountOut, bdiv(PSS, 10000));\n', '        uint256 tokAmountI1 = bsub(toka, badd(tokAmountI, tokAmountI2));\n', '        uint256 tok2 = badd(tokAmountI1, tokAmountI2);\n', '        _balances1[msg.sender] = _balances1[msg.sender] - tokenAmountIn;\n', '        _balances2[msg.sender] = _balances2[msg.sender] + tokAmountI1;\n', '        _totalSupply2 = _totalSupply2 + tok2;\n', '        _totalSupply1 = _totalSupply1 - tokenAmountIn;\n', '        _pushUnderlying1(tokenOut, tokAmountI);\n', '        _balances2[pairRewardPool] = _balances2[pairRewardPool] + tokAmountI2;\n', '        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\n', '        _records[Wrap].balance = IERC20(Wrap).balanceOf(address(this)) - _totalSupply2;\n', '                          \n', '        spotPriceAfter = calcSpotPrice(\n', '                                            inRecord.balance,\n', '                                            BASE * 25,\n', '                                            outRecord.balance,\n', '                                            BASE * 25,\n', '                                            _swapFee\n', '                            );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        \n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '    \n', '    function setFSS(uint _FSS ) external {\n', '        require(msg.sender == _controller);\n', '        require(_FSS <= 100, " Cannot set over 1%");\n', '        require(_FSS > 0, " Cannot set to 0");\n', '        FSS = _FSS;\n', '    }\n', '    \n', '    function setPSS(uint _PSS ) external {\n', '        require(msg.sender == _poolOwner);\n', '         require(_PSS <= 100, " Cannot set over 1%"); \n', '         require(_PSS > 0, " Cannot set to 0");\n', '        PSS = _PSS;\n', '    }\n', '\n', '    function setRPF(uint _RPF ) external {\n', '        require(msg.sender == _poolOwner);\n', '         require(_RPF <= 200, " Cannot set over 20%"); \n', '         require(_RPF > 0, " Cannot set to 0");\n', '        RPF = _RPF;\n', '    }\n', '    \n', '    function setSHR(uint _SHR, uint _SHR1 ) external {\n', '        require(msg.sender == _controller);\n', '         require(_SHR <= 100 && _SHR1 <=100, " Cannot set over 10%"); \n', '         require(_SHR > 0 && _SHR1 > 0, " Cannot set to 0"); \n', '        SHR = _SHR;\n', '        SHR1 = _SHR1;\n', '    }\n', '    \n', '    function setLockLiquidity() external { //\n', '        address user = msg.sender;\n', '        userLock storage ulock = _userlock[user];\n', '        userLock storage time = _unlockTime[user];\n', '        ulock.setLock = true;\n', '        time.unlockTime = block.timestamp + 365 days ; \n', '        }\n', '    \n', '    function releaseLiquidity() external { // Allows removal of liquidity after the lock period is over\n', '        address user = msg.sender;\n', '        userLock storage ulock = _userlock[user];\n', '        userLock storage time = _unlockTime[user];\n', '        require (block.timestamp >= time.unlockTime, "Liquidity is locked, you cannot remove liquidity until after lock time.");\n', '        ulock.setLock = false; \n', '    }\n', '    \n', '    function emergencyLockOverride(address user, bool _bool, uint _time) external {\n', '        require(msg.sender == _controller);\n', '        userLock storage ulock = _userlock[user];\n', '        userLock storage time = _unlockTime[user];\n', '        ulock.setLock = _bool;\n', '        time.unlockTime = _time;\n', '    }\n', '\n', '    function _pullUnderlying(address erc20, address from, uint amount)\n', '        internal\n', '    {   \n', '        //require(amount > 0, "Cannot deposit nothing");\n', '        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\n', '        require(xfer, "ERR_ERC20_FALSE");\n', '        \n', '    }\n', '\n', '    function _pushUnderlying(address erc20, address to, uint amount)\n', '        internal\n', '    {   \n', '        //require(amount > 0, "Cannot withdraw nothing");\n', '        bool xfer = IERC20(erc20).transfer(to, amount);\n', '        require(xfer, "ERR_ERC20_FALSE");\n', '    }\n', '    \n', '    function _pushUnderlying1(address erc20, uint amount)\n', '        internal\n', '    {\n', '        bool xfer = IERC20(erc20).transfer(FEGstake, amount);\n', '        require(xfer, "ERR_ERC20_FALSE");\n', '    }\n', '\n', '    function _pullPoolShare(address from, uint amount)\n', '        internal\n', '    {\n', '        _pull(from, amount);\n', '    }\n', '\n', '    function _pushPoolShare(address to, uint amount)\n', '        internal\n', '    {\n', '        _push(to, amount);\n', '    }\n', '\n', '    function _mintPoolShare(uint amount)\n', '        internal\n', '    {\n', '        _mint(amount);\n', '    }\n', '\n', '    function _burnPoolShare(uint amount)\n', '        internal\n', '    {\n', '        _burn(amount);\n', '    }\n', '\n', '    function PayWrap(address payee, uint amount)\n', '        external noContract nonReentrant \n', '        \n', '    {   \n', '        require(_balances2[msg.sender] >= amount, "Not enough token");\n', '        uint256 amt = amount * SHR1/1000;\n', '        uint256 amt1 = amount - amt;\n', '        _balances2[msg.sender] = _balances2[msg.sender] - amount;\n', '        _balances2[payee] = _balances2[payee] + amt;\n', '        _balances2[_factory] = _balances2[_factory] + amt1;\n', '    }\n', '    \n', '    function PayToken(address payee, uint amount)\n', '        external noContract nonReentrant \n', '        \n', '    {\n', '        require(_balances1[msg.sender] >= amount, "Not enough token");\n', '        uint256 amt = amount * SHR/1000;\n', '        uint256 amt1 = amount - amt;\n', '        _balances1[msg.sender] = _balances1[msg.sender] - amount;\n', '        _balances1[payee] = _balances1[payee] + amt;\n', '        _pushUnderlying(Token, burn, amt1);\n', '        _totalSupply1 = _totalSupply1 - amt1;\n', '    }\n', '}']