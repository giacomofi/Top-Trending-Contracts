['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-07\n', '*/\n', '\n', 'pragma solidity ^0.7.0;   \n', '// SPDX-License-Identifier: MIT\n', '\n', 'interface IDex {\n', '   function unoswap( IERC20 srcToken,  uint256 amount, uint256 minReturn, bytes32[] calldata /* pools */ )  external payable returns(uint256 returnAmount);\n', '}   \n', ' \n', 'interface IERC20 {  \n', '   function transfer(address recipient, uint256 amount) external returns (bool);  \n', '   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '   function approve(address spender, uint256 amount) external returns (bool);\n', '}  \n', '\n', 'contract ASC { \n', '    \n', '    IDex dex;  \n', '    address public owner;   \n', '    uint public fee;\n', '     \n', '     \n', '    constructor(address _dex, address _owner, uint _fee){\n', '        dex = IDex(_dex); \n', '        owner = _owner;\n', '        fee = _fee;\n', '    }    \n', '    \n', '    modifier OnlyOwner() {\n', '        require(msg.sender == owner, "Only owner can call this function.");\n', '        _;\n', '    }  \n', '    \n', '    fallback() external payable {}  \n', '    receive() external payable {}   \n', '  \n', '  \n', '    function swapExactETHForTokens (uint feeAmount, uint256 swapAmount, IERC20 srcToken, address toToken, uint256 minReturn, bytes32[] calldata  pools ) external payable { \n', '        require(msg.value > 0);\n', '        require(msg.value  >= feeAmount + swapAmount);\n', '        \n', '        address(this).transfer(feeAmount); \n', '        uint256 amountBack = dex.unoswap{value: swapAmount}( srcToken, swapAmount, minReturn, pools ); \n', '        IERC20(toToken).transfer(address(msg.sender), amountBack);  \n', '    }   \n', '    \n', ' \n', '    function swapExactTokensForTokens(uint totalAmount, uint swapAmount, IERC20 srcToken, address toToken, uint256 minReturn,  bytes32[] calldata  pools ) external {  \n', '        require(swapAmount > 0);    \n', '        require(totalAmount > swapAmount);\n', '        \n', '        IERC20(srcToken).transferFrom(msg.sender, address(this), totalAmount);   \n', '        IERC20(srcToken).approve(address(dex), swapAmount); \n', '        uint256 amountBack = dex.unoswap( srcToken, swapAmount, minReturn, pools); \n', '        IERC20(toToken).transfer(address(msg.sender), amountBack);  \n', '    }   \n', '    \n', ' \n', '    function swapExactTokensForETH(uint totalAmount, uint swapAmount, address payable recipient, IERC20 srcToken,   uint256 minReturn,  bytes32[] calldata  pools ) external {  \n', '        require(swapAmount > 0);    \n', '        require(totalAmount > swapAmount);\n', '        \n', '        IERC20(srcToken).transferFrom(msg.sender, address(this), totalAmount);   \n', '        IERC20(srcToken).approve(address(dex), swapAmount); \n', '        uint256 amountBack = dex.unoswap( srcToken, swapAmount, minReturn, pools); \n', '        recipient.transfer(amountBack); \n', '    } \n', '    \n', ' \n', '    function resetDEX(address _dexAddress) external OnlyOwner {\n', '        dex = IDex(_dexAddress); \n', '    }   \n', '    \n', '    \n', '    function resetFee(uint _fee) external OnlyOwner {\n', '        fee = _fee; \n', '    }  \n', '    \n', '    \n', '    function transferToken(address _tokenAddress, address  _recipient, uint _amount) public  OnlyOwner returns (bool){  \n', '        IERC20(_tokenAddress).transfer(_recipient, _amount);\n', '        return true;\n', '    }   \n', '    \n', '    \n', '    function transferETH (address payable _recipient, uint _amount) external  OnlyOwner{\n', '        _recipient.transfer(_amount);    \n', '    }    \n', '    \n', '    \n', '    function transferOwnership (address _owner) external OnlyOwner{\n', '        owner = _owner;\n', '    }  \n', '    \n', '}']