['// SPDX-License-Identifier: No License (None)\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./TransferHelper.sol";\n', '\n', 'interface IERC20 {\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IValidator {\n', '    // returns rate (with 18 decimals) = Token B price / Token A price\n', '    function getRate(address tokenA, address tokenB) external returns (uint256);\n', '    // returns: user balance, native (foreign for us) encoded balance, foreign (native for us) encoded balance\n', '    function checkBalances(address factory, address[] calldata user) external returns(uint256);\n', '    // returns: user balance\n', '    function checkBalance(address factory, address user) external returns(uint256);\n', '    // returns: oracle fee\n', '    function getOracleFee(uint256 req) external returns(uint256);  //req: 1 - cancel, 2 - claim, returns: value\n', '}\n', '\n', 'interface ISmart {\n', '    function requestCompensation(address user, uint256 feeAmount) external returns(bool);\n', '}\n', '\n', 'interface IAuction {\n', '    function contributeFromSmartSwap(address payable user) external payable returns (bool);\n', '    function contributeFromSmartSwap(address token, uint256 amount, address user) external returns (bool);\n', '}\n', '\n', 'abstract contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '/*  we use proxy, so owner will be set in initialize() function\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '*/\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract SmartSwap is Ownable {\n', '\n', '    struct Cancel {\n', '        uint64 pairID; // pair ID\n', '        address sender; // user who has to receive canceled amount\n', '        uint256 amount; // amount of token user want to cancel from order\n', '        //uint128 foreignBalance; // amount of token already swapped (on other chain)\n', '    }\n', '\n', '    struct Claim {\n', '        uint64 pairID;     // pair ID\n', '        address sender;     // address who send tokens to swap\n', '        address receiver;   // address who has to receive swapped amount\n', '        uint64 claimID;     // uniq claim ID\n', '        bool isInvestment;  // is claim to contributeFromSmartSwap\n', '        uint128 amount;     // amount of foreign tokens user want to swap\n', '        uint128 currentRate;\n', '        uint256 foreignBalance;  //[0] foreignBalance, [1] foreignSpent, [2] nativeSpent, [3] nativeRate\n', '    }\n', '\n', '    struct Pair {\n', '        address tokenA;\n', '        address tokenB;        \n', '    }\n', '\n', '    address constant NATIVE_COINS = 0x0000000000000000000000000000000000000009; // 1 - BNB, 2 - ETH, 3 - BTC\n', '    uint256 constant NOMINATOR = 10**18;\n', '    uint256 constant MAX_AMOUNT = 2**128;\n', '\n', '    address public foreignFactory;\n', '    address payable public validator;\n', '    uint256 public rateDiffLimit;   // allowed difference (in percent) between LP provided rate and Oracle rate.\n', '    mapping(address => bool) public isSystem;  // system address mey change fee amount\n', '    address public auction; // auction address\n', '    address public contractSmart;  // the contract address to request Smart token in exchange of fee\n', '    mapping (address => uint256) licenseeFee;  // the licensee may set personal fee (in percent wih 2 decimals). It have to compensate this fee with own tokens.\n', '    mapping (address => address) licenseeCompensator;    // licensee contract which will compensate fee with tokens\n', ' \n', '    mapping(address => bool) public isExchange;         // is Exchange address\n', '    mapping(address => bool) public isExcludedSender;   // address excluded from receiving SMART token as fee compensation\n', '\n', '    // fees\n', '    uint256 public swapGasReimbursement;      // percentage of swap Gas Reimbursement by SMART tokens\n', '    uint256 public companyFeeReimbursement;   // percentage of company Fee Reimbursement by SMART tokens\n', '    uint256 public cancelGasReimbursement;    // percentage of cancel Gas Reimbursement by SMART tokens\n', '    uint256 public companyFee; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n', '    uint256 public processingFee; // the fee in base coin, to compensate Gas when back-end call claimTokenBehalf()\n', '    address public feeReceiver; // address which receive the fee (by default is validator)\n', '    uint256 private collectedFees; // amount of collected fee (starts from 1 to avoid additional gas usage)\n', '\n', '    mapping(address => uint256) public decimals;   // token address => token decimals\n', '    uint256 public pairIDCounter;\n', '    mapping(uint256 => Pair) public getPairByID;\n', '    mapping(address => mapping(address => uint256)) public getPairID;    // tokenA => tokenB => pair ID or 0 if not exist\n', '    mapping(uint256 => uint256) public totalSupply;    // pairID => totalSupply amount of tokenA on the pair\n', '\n', '    // hashAddress = address(keccak256(tokenA, tokenB, sender, receiver))\n', '    mapping(address => uint256) private _balanceOf;       // hashAddress => amount of tokenA\n', '    mapping(address => Cancel) public cancelRequest;    // hashAddress => amount of tokenA to cancel\n', '    mapping(address => Claim) public claimRequest;      // hashAddress => amount of tokenA to swap\n', '\n', '    mapping(address => bool) public isLiquidityProvider;    // list of Liquidity Providers\n', '    uint256 claimIdCounter;    // counter of claim requests\n', '\n', '// ============================ Events ============================\n', '\n', '    event PairAdded(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\n', '    event PairRemoved(address indexed tokenA, address indexed tokenB, uint256 indexed pairID);\n', '    event SwapRequest(\n', '        address indexed tokenA,\n', '        address indexed tokenB,\n', '        address indexed sender,\n', '        address receiver,\n', '        uint256 amountA,\n', '        bool isInvestment,\n', '        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n', '        uint128 limitPice   // Do not match user if token A price less this limit\n', '    );\n', '    event CancelRequest(address indexed hashAddress, uint256 amount);\n', '    event CancelApprove(address indexed hashAddress, uint256 newBalance);\n', '    event ClaimRequest(address indexed hashAddress, uint64 claimID, uint256 amount, bool isInvestment);\n', '    event ClaimApprove(address indexed hashAddress, uint64 claimID, uint256 nativeAmount, uint256 foreignAmount, bool isInvestment);\n', '    event ExchangeInvestETH(address indexed exchange, address indexed whom, uint256 value);\n', '    event SetSystem(address indexed system, bool active);\n', '    event SetLicensee(address indexed system, address indexed compensator);\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the system.\n', '    */\n', '    modifier onlySystem() {\n', '        require(isSystem[msg.sender] || owner() == msg.sender, "Caller is not the system");\n', '        _;\n', '    }\n', '\n', '\n', '    // run only once from proxy\n', '    function initialize(address newOwner) external {\n', '        require(newOwner != address(0) && _owner == address(0)); // run only once\n', '        _owner = newOwner;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '        rateDiffLimit = 5;   // allowed difference (in percent) between LP provided rate and Oracle rate.\n', '        swapGasReimbursement = 100;      // percentage of swap Gas Reimbursement by SMART tokens\n', '        companyFeeReimbursement = 100;   // percentage of company Fee Reimbursement by SMART tokens\n', '        cancelGasReimbursement = 100;    // percentage of cancel Gas Reimbursement by SMART tokens\n', '        companyFee = 0; // the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n', '        collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\n', '    }\n', '\n', '    // get amount of collected fees that can be claimed\n', '    function getColletedFees() external view returns (uint256) {\n', '        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\n', '        return collectedFees - 1;\n', '    }\n', '\n', '    // claim fees by feeReceiver\n', '    function claimFee() external returns (uint256 feeAmount)\n', '    {\n', '        require(msg.sender == feeReceiver);\n', '        feeAmount = collectedFees - 1;\n', '        collectedFees = 1;        \n', '        TransferHelper.safeTransferETH(msg.sender, feeAmount);\n', '    }\n', '\n', '    function balanceOf(address hashAddress) external view returns(uint256) {\n', '        return _balanceOf[hashAddress];\n', '    }\n', '\n', '    // return balance for swap\n', '    function getBalance(\n', '        address tokenA,\n', '        address tokenB, \n', '        address sender,\n', '        address receiver\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _balanceOf[_getHashAddress(tokenA, tokenB, sender, receiver)];\n', '    }\n', '\n', '    function getHashAddress(\n', '        address tokenA,\n', '        address tokenB, \n', '        address sender,\n', '        address receiver\n', '    )\n', '        external\n', '        pure\n', '        returns (address)\n', '    {\n', '        return _getHashAddress(tokenA, tokenB, sender, receiver);\n', '    }\n', '\n', '    //user should approve tokens transfer before calling this function.\n', '    //if no licensee set it to address(0)\n', '    function swap(\n', '        address tokenA,\n', '        address tokenB, \n', '        address receiver,\n', '        uint256 amountA,\n', '        address licensee,\n', '        bool isInvestment,\n', '        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n', '        uint128 limitPice   // Do not match user if token A price less this limit\n', '    )\n', '        external\n', '        payable\n', '        returns (bool)\n', '    {\n', '        _transferFee(tokenA, amountA, msg.sender, licensee);\n', '        _swap(tokenA, tokenB, msg.sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\n', '        return true;\n', '    }\n', '\n', '    function cancel(\n', '        address tokenA,\n', '        address tokenB, \n', '        address receiver,\n', '        uint256 amountA    //amount of tokenA to cancel\n', '    )\n', '        external\n', '        payable\n', '        returns (bool)\n', '    {\n', '        _cancel(tokenA, tokenB, msg.sender, receiver, amountA);\n', '        return true;\n', '    }\n', '\n', '    function claimTokenBehalf(\n', '        address tokenA, // foreignToken\n', '        address tokenB, // nativeToken\n', '        address sender,\n', '        address receiver,\n', '        bool isInvestment,\n', '        uint128 amountA,    //amount of tokenA that has to be swapped\n', '        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\n', '        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\n', '    )        \n', '        external\n', '        onlySystem\n', '        returns (bool) \n', '    {\n', '        _claimTokenBehalf(tokenA, tokenB, sender, receiver, isInvestment, amountA, currentRate, foreignBalance);\n', '        return true;\n', '    }\n', '\n', '    // add liquidity to counterparty \n', '    function addLiquidityAndClaimBehalf(\n', '        address tokenA, // Native token\n', '        address tokenB, // Foreign token\n', '        address receiver,\n', '        bool isInvestment,\n', '        uint128 amountA,    //amount of tokenA that has to be swapped\n', '        uint128 currentRate,     // rate with 18 decimals: tokenB price / tokenA price\n', '        uint256 foreignBalance,  // total tokens amount sent by user to pair on other chain\n', '        address senderCounterparty,\n', '        address receiverCounterparty\n', '    )\n', '        external\n', '        payable\n', '        onlySystem\n', '        returns (bool)\n', '    {\n', '\n', '        _transferFee(tokenA, amountA, msg.sender, address(0));\n', '        _swap(tokenA, tokenB, msg.sender, receiver, amountA, false,0,0);\n', '        uint256 amountB = amountA * 10**(18+decimals[tokenB]-decimals[tokenA]) / currentRate;\n', '        _claimTokenBehalf(tokenB, tokenA, senderCounterparty, receiverCounterparty, isInvestment, uint128(amountB), currentRate, foreignBalance);\n', '        return true;\n', '    }\n', '\n', '    function balanceCallback(address hashAddress, uint256 foreignBalance) external returns(bool) {\n', '        require (validator == msg.sender, "Not validator");\n', '        _cancelApprove(hashAddress, foreignBalance);\n', '        return true;\n', '    }\n', '\n', '    function balancesCallback(\n', '        address hashAddress, \n', "        uint256 foreignBalance, // total user's tokens balance on foreign chain\n", '        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\n', '        uint256 nativeEncoded   // (nativeRate, nativeSpent) = _decode(nativeEncoded)\n', '    ) \n', '        external \n', '        returns(bool) \n', '    {\n', '        require (validator == msg.sender, "Not validator");\n', '        _claimBehalfApprove(hashAddress, foreignBalance, foreignSpent, nativeEncoded);\n', '        return true;\n', '    }\n', '\n', '    // get system variables for debugging \n', '    function getPairVars(uint256 pairID) external view returns (uint256 native, uint256 foreign, uint256 foreignRate) {\n', '        address nativeHash = _getHashAddress(getPairByID[pairID].tokenA, getPairByID[pairID].tokenB, address(0), address(0));\n', '        address foreignHash = _getHashAddress(getPairByID[pairID].tokenB, getPairByID[pairID].tokenA, address(0), address(0));\n', '        // native - amount of native tokens that swapped from available foreign\n', '        native = _balanceOf[nativeHash];\n', '        // foreign = total foreign tokens already swapped\n', '        // foreignRate = rate (native price / foreign price) of available foreign tokens on other chain\n', '        (foreignRate, foreign) = _decode(_balanceOf[foreignHash]);\n', '        // Example: assume system vars = 0, rate of prices ETH/BNB = 2 (or BNB/ETH = 0.5)\n', '        // on ETH chain: \n', '        // 1. claim ETH for 60 BNB == 60 * 0.5 = 30 ETH, \n', '        // set: foreign = 60 BNB, foreignRate = 0.5 BNB/ETH prices (already swapped BNB)\n', '        //\n', '        // on BSC chain:\n', '        // 2. claim BNB for 20 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\n', '        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\n', '        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 0 BNB (native) = 60 BNB with rate 0.5 BNB/ETH\n', '        // claimed BNB amount = 20 ETH / 0.5 BNB/ETH = 40 BNB (we use rate of already swapped BNB)\n', '        // set: native = 40 BNB (we use BNB that was already swapped on step 1)\n', '        //\n', '        // 3. New claim BNB for 30 ETH, assume new rate of prices ETH/BNB = 4 (or BNB/ETH = 0.25)\n', '        // get from ETH chain foreign(ETH) = 60 BNB, foreignRate(ETH) = 0.5 BNB/ETH prices\n', '        // available amount of already swapped BNB = 60 BNB (foreign from ETH) - 40 BNB (native) = 20 BNB with rate 0.5 BNB/ETH\n', '        // 20 BNB * 0.5 = 10 ETH (we claimed 20 BNB for 10 ETH with already swapped rate)\n', '        // set: native = 40 BNB + 20 BNB = 60 BNB (we use all BNB that was already swapped on step 1)\n', '        // claimed rest BNB amount for (30-10) ETH = 20 ETH / 0.25 BNB/ETH = 80 BNB (we use new rate)\n', '        // set: foreign = 20 ETH, foreignRate = 0.25 BNB/ETH prices (already swapped ETH)\n', '    }\n', '// ================== For Jointer Auction =========================================================================\n', '\n', '    // ETH side\n', '    // function for invest ETH from from exchange on user behalf\n', '    function contributeWithEtherBehalf(address payable _whom) external payable returns (bool) {\n', '        require(isExchange[msg.sender], "Not an Exchange address");\n', '        address tokenA = address(2);    // ETH (native coin)\n', '        address tokenB = address(1);    // BNB (foreign coin)\n', '        uint256 amount = msg.value - processingFee;\n', '        emit ExchangeInvestETH(msg.sender, _whom, msg.value);\n', '        _transferFee(tokenA, amount, _whom, address(0));    // no licensee\n', '        _swap(tokenA, tokenB, _whom, auction, amount, true,0,0);\n', '        return true;\n', '    }\n', '\n', '    // BSC side\n', '    // tokenB - foreign token address or address(1) for ETH\n', '    // amountB - amount of foreign tokens or ETH\n', '    function claimInvestmentBehalf(\n', '        address tokenB, // foreignToken\n', '        address user, \n', '        uint128 amountB,    //amount of tokenB that has to be swapped\n', '        uint128 currentRate,     // rate with 18 decimals: tokenB price / Native coin price\n', '        uint256 foreignBalance  // total tokens amount sent by user to pair on other chain\n', '    ) \n', '        external \n', '        onlySystem \n', '        returns (bool) \n', '    {\n', '        address tokenA = address(1);    // BNB (native coin)\n', '        _claimTokenBehalf(tokenB, tokenA, user, auction, true, amountB, currentRate, foreignBalance);\n', '        return true;\n', '    }\n', '    \n', '// ================= END For Jointer Auction ===========================================================================\n', '\n', '// ============================ Restricted functions ============================\n', '\n', '    // set processing fee - amount that have to be paid on other chain to claimTokenBehalf.\n', '    // Set in amount of native coins (BNB or ETH)\n', '    function setProcessingFee(uint256 _fee) external onlySystem returns(bool) {\n', '        processingFee = _fee;\n', '        return true;\n', '    }\n', '\n', '    // set licensee compensator contract address, if this address is address(0) - remove licensee.\n', '    // compensator contract has to compensate the fee by other tokens.\n', '    // licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\n', '    function setLicensee(address _licensee, address _compensator, uint256 _fee) external onlySystem returns(bool) {\n', '        licenseeCompensator[_licensee] = _compensator;\n', '        require(_fee < 10000, "too big fee");    // fee should be less then 100%\n', '        licenseeFee[_licensee] = _fee;\n', '        emit SetLicensee(_licensee, _compensator);\n', '        return true;\n', '    }\n', '\n', '    // set licensee fee in percent with 2 decimals. I.e. 10 = 0.1%\n', '    function setLicenseeFee(uint256 _fee) external returns(bool) {\n', '        require(licenseeCompensator[msg.sender] != address(0), "licensee is not registered");\n', '        require(_fee < 10000, "too big fee");    // fee should be less then 100%\n', '        licenseeFee[msg.sender] = _fee;\n', '        return true;\n', '    }\n', '\n', "// ============================ Owner's functions ============================\n", '\n', '    //the fee (in percent wih 2 decimals) that received by company. 30 - means 0.3%\n', '    function setCompanyFee(uint256 _fee) external onlyOwner returns(bool) {\n', '        require(_fee < 10000, "too big fee");    // fee should be less then 100%\n', '        companyFee = _fee;\n', '        return true;\n', '    }\n', '\n', '    // Reimbursement Percentage without decimals: 100 = 100%\n', '    function setReimbursementPercentage (uint256 id, uint256 _fee) external onlyOwner returns(bool) {\n', '        if (id == 1) swapGasReimbursement = _fee;      // percentage of swap Gas Reimbursement by SMART tokens\n', '        else if (id == 2) cancelGasReimbursement = _fee;    // percentage of cancel Gas Reimbursement by SMART tokens\n', '        else if (id == 3) companyFeeReimbursement = _fee;   // percentage of company Fee Reimbursement by SMART tokens\n', '        return true;\n', '    }\n', '\n', '    function setSystem(address _system, bool _active) external onlyOwner returns(bool) {\n', '        isSystem[_system] = _active;\n', '        emit SetSystem(_system, _active);\n', '        return true;\n', '    }\n', '\n', '    function setValidator(address payable _validator) external onlyOwner returns(bool) {\n', '        validator = _validator;\n', '        return true;\n', '    }\n', '\n', '    function setForeignFactory(address _addr) external onlyOwner returns(bool) {\n', '        foreignFactory = _addr;\n', '        return true;\n', '    }\n', '\n', '    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\n', '        feeReceiver = _addr;\n', '        return true;\n', '    }\n', '\n', '    function setMSSContract(address _addr) external onlyOwner returns(bool) {\n', '        contractSmart = _addr;\n', '        return true;\n', '    }\n', '\n', '\n', '    function setAuction(address _addr) external onlyOwner returns(bool) {\n', '        auction = _addr;\n', '        return true;\n', '    }\n', '\n', '    // for ETH side only\n', '    function changeExchangeAddress(address _which,bool _bool) external onlyOwner returns(bool){\n', '        isExchange[_which] = _bool;\n', '        return true;\n', '    }\n', '    \n', '    function changeExcludedAddress(address _which,bool _bool) external onlyOwner returns(bool){\n', '        isExcludedSender[_which] = _bool;\n', '        return true;\n', '    }\n', '\n', '    function createPair(address tokenA, uint256 decimalsA, address tokenB, uint256 decimalsB) public onlyOwner returns (uint256) {\n', '        require(getPairID[tokenA][tokenB] == 0, "Pair exist");\n', '        uint256 pairID = ++pairIDCounter;\n', '        getPairID[tokenA][tokenB] = pairID;\n', '        getPairByID[pairID] = Pair(tokenA, tokenB);\n', '        if (decimals[tokenA] == 0) decimals[tokenA] = decimalsA;\n', '        if (decimals[tokenB] == 0) decimals[tokenB] = decimalsB;\n', '        return pairID;\n', '    }\n', '\n', '// ============================ Internal functions ============================\n', '    function _swap(\n', '        address tokenA, // nativeToken\n', '        address tokenB, // foreignToken\n', '        address sender,\n', '        address receiver,\n', '        uint256 amountA,\n', '        bool isInvestment,\n', '        uint128 minimumAmountToClaim,   // do not claim on user behalf less of this amount. Only exception if order fulfilled.\n', '        uint128 limitPice   // Do not match user if token A price less this limit\n', '    )\n', '        internal\n', '    {\n', '        uint256 pairID = getPairID[tokenA][tokenB];\n', '        require(pairID != 0, "Pair not exist");\n', '        if (tokenA > NATIVE_COINS) {\n', '            TransferHelper.safeTransferFrom(tokenA, sender, address(this), amountA);\n', '        }\n', '        // (amount >= msg.value) is checking when pay fee in the function transferFee()\n', '        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n', '        _balanceOf[hashAddress] += amountA;\n', '        totalSupply[pairID] += amountA;\n', '        emit SwapRequest(tokenA, tokenB, sender, receiver, amountA, isInvestment, minimumAmountToClaim, limitPice);\n', '    }\n', '\n', '    function _cancel(\n', '        address tokenA, // nativeToken\n', '        address tokenB, // foreignToken\n', '        address sender,\n', '        address receiver,\n', '        uint256 amountA    //amount of tokenA to cancel\n', '        //uint128 foreignBalance // amount of tokenA swapped by hashAddress (get by server-side)\n', '    )\n', '        internal\n', '    {\n', '        require(msg.value >= IValidator(validator).getOracleFee(1), "Insufficient fee");    // check oracle fee for Cancel request\n', '        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n', '        uint256 pairID = getPairID[tokenA][tokenB];\n', '        require(pairID != 0, "Pair not exist");\n', '        if (cancelRequest[hashAddress].amount == 0) {  // new cancel request\n', '            uint256 balance = _balanceOf[hashAddress];\n', '            require(balance >= amountA && amountA != 0, "Wrong amount");\n', '            totalSupply[pairID] = totalSupply[pairID] - amountA;\n', '            _balanceOf[hashAddress] = balance - amountA;\n', '        } else { // repeat cancel request in case oracle issues.\n', '            amountA = cancelRequest[hashAddress].amount;\n', '        }\n', '        cancelRequest[hashAddress] = Cancel(uint64(pairID), sender, amountA);\n', '        // transfer fee to validator. May be changed to request tokens for compensation\n', '        TransferHelper.safeTransferETH(feeReceiver, msg.value);\n', '        if(contractSmart != address(0) && !isExcludedSender[sender]) {\n', '            uint256 feeAmount = msg.value * cancelGasReimbursement / 100;\n', '            if (feeAmount != 0)\n', '                ISmart(contractSmart).requestCompensation(sender, feeAmount);\n', '        }\n', '        // request Oracle for fulfilled amount from hashAddress\n', '        IValidator(validator).checkBalance(foreignFactory, hashAddress);\n', '        emit CancelRequest(hashAddress, amountA);\n', '        //emit CancelRequest(tokenA, tokenB, sender, receiver, amountA);\n', '    }\n', '\n', '    function _cancelApprove(address hashAddress, uint256 foreignBalance) internal {\n', '        Cancel memory c = cancelRequest[hashAddress];\n', '        delete cancelRequest[hashAddress];\n', '        //require(c.foreignBalance == foreignBalance, "Oracle error");\n', '        uint256 balance = _balanceOf[hashAddress];\n', '        uint256 amount = uint256(c.amount);\n', '        uint256 pairID = uint256(c.pairID);\n', '        if (foreignBalance <= balance) {\n', '            //approved - transfer token to its sender\n', '            _transfer(getPairByID[pairID].tokenA, c.sender, amount);\n', '        } else {\n', '            //disapproved\n', '            balance += amount;\n', '            _balanceOf[hashAddress] = balance;\n', '            totalSupply[pairID] += amount;\n', '        }\n', '        emit CancelApprove(hashAddress, balance);\n', '    }\n', '\n', '    function _claimTokenBehalf(\n', '        address tokenA, // foreignToken\n', '        address tokenB, // nativeToken\n', '        address sender,\n', '        address receiver,\n', '        bool isInvestment,\n', '        uint128 amountA,    //amount of tokenA that has to be swapped\n', '        uint128 currentRate,     // rate with 18 decimals: tokenA price / tokenB price\n', '        uint256 foreignBalance  // total tokens amount sent bu user to pair on other chain\n', '        // [1] foreignSpent, [2] nativeSpent, [3] nativeRate\n', '    )\n', '        internal\n', '    {\n', '        uint256 pairID = getPairID[tokenB][tokenA]; // getPairID[nativeToken][foreignToken]\n', '        require(pairID != 0, "Pair not exist");\n', '        // check rate\n', '        uint256 diffRate = uint256(currentRate) * 100 / IValidator(validator).getRate(tokenB, tokenA);\n', '        uint256 diffLimit = rateDiffLimit;\n', '        require(diffRate >= 100 - diffLimit && diffRate <= 100 + diffLimit, "Wrong rate");\n', '\n', '        uint64 claimID;\n', '        address hashAddress = _getHashAddress(tokenA, tokenB, sender, receiver);\n', '        if (claimRequest[hashAddress].amount == 0) {  // new claim request\n', '            _balanceOf[hashAddress] += uint256(amountA); // total swapped amount of foreign token\n', '            claimID = uint64(++claimIdCounter);\n', '        } else { // repeat claim request in case oracle issues.\n', '            claimID = claimRequest[hashAddress].claimID;\n', '            if (amountA == 0) {    // cancel claim request\n', '                emit ClaimApprove(hashAddress, claimID, 0, 0, claimRequest[hashAddress].isInvestment);\n', '                _balanceOf[hashAddress] = _balanceOf[hashAddress] - claimRequest[hashAddress].amount;\n', '                delete claimRequest[hashAddress];\n', '                return;\n', '            }\n', '            amountA = claimRequest[hashAddress].amount;\n', '        }\n', '        address[] memory users = new address[](3);\n', '        users[0] = hashAddress;\n', '        users[1] = _getHashAddress(tokenA, tokenB, address(0), address(0)); // Native hash address on foreign chain\n', '        users[2] = _getHashAddress(tokenB, tokenA, address(0), address(0)); // Foreign hash address on foreign chain\n', '        claimRequest[hashAddress] = Claim(uint64(pairID), sender, receiver, claimID, isInvestment, amountA, currentRate, foreignBalance);\n', '        IValidator(validator).checkBalances(foreignFactory, users);\n', '        emit ClaimRequest(hashAddress, claimID, amountA, isInvestment);\n', '        //emit ClaimRequest(tokenA, tokenB, sender, receiver, amountA);\n', '    }\n', '\n', '    // Approve or disapprove claim request.\n', '    function _claimBehalfApprove(\n', '        address hashAddress, \n', "        uint256 foreignBalance, // total user's tokens balance on foreign chain\n", '        uint256 foreignSpent,   // total tokens spent by SmartSwap pair\n', '        uint256 nativeEncoded   // (nativeSpent, nativeRate) = _decode(nativeEncoded)\n', '    ) \n', '        internal \n', '    {\n', '        Claim memory c = claimRequest[hashAddress];\n', '        delete claimRequest[hashAddress];\n', '        //address hashSwap = _getHashAddress(getPairByID[c.pairID].tokenB, getPairByID[c.pairID].tokenA, c.sender, c.receiver);\n', '        uint256 balance = _balanceOf[hashAddress];   // swapped amount of foreign tokens (include current claim amount)\n', '        uint256 amount = uint256(c.amount);     // amount of foreign token to swap\n', '        require (amount != 0, "No active claim request");\n', '        require(foreignBalance == c.foreignBalance, "Oracle error");\n', '\n', '        uint256 nativeAmount;\n', '        uint256 rest;\n', '        if (foreignBalance >= balance) {\n', '            //approve, user deposited not less foreign tokens then want to swap\n', '            uint256 pairID = uint256(c.pairID);\n', '            (uint256 nativeRate, uint256 nativeSpent) = _decode(nativeEncoded);\n', '            (nativeAmount, rest) = _calculateAmount(\n', '                pairID,\n', '                amount, \n', '                uint256(c.currentRate),\n', '                foreignSpent,\n', '                nativeSpent,\n', '                nativeRate\n', '            );\n', '            if (rest != 0) {\n', '                _balanceOf[hashAddress] = balance - rest;    // not all amount swapped\n', '                amount = amount - rest;     // swapped amount\n', '            }\n', '            require(totalSupply[pairID] >= nativeAmount, "Not enough Total Supply");   // may be commented\n', '            totalSupply[pairID] = totalSupply[pairID] - nativeAmount;\n', '            if (c.isInvestment)\n', '                _contributeFromSmartSwap(getPairByID[pairID].tokenA, c.receiver, c.sender, nativeAmount);\n', '            else\n', '                _transfer(getPairByID[pairID].tokenA, c.receiver, nativeAmount);\n', '        } else {\n', '            //disapprove, discard claim\n', '            _balanceOf[hashAddress] = balance - amount;\n', '            amount = 0;\n', '        }\n', '        emit ClaimApprove(hashAddress, c.claimID, nativeAmount, amount, c.isInvestment);\n', '    }\n', '\n', '    // use structure to avoid stack too deep\n', '    struct CalcVariables {\n', '        // 18 decimals nominator with decimals converter: \n', '        // Foreign = Native * Rate(18) / nominatorNativeToForeign\n', '        uint256 nominatorForeignToNative; // 10**(18 + foreign decimals - native decimals)\n', '        uint256 nominatorNativeToForeign; // 10**(18 + native decimals - foreign decimals)\n', '        uint256 localNative;        // already swapped Native tokens = _balanceOf[hashNative]\n', '        uint256 localForeign;       // already swapped Foreign tokens = decoded _balanceOf[hashForeign]\n', '        uint256 localForeignRate;   // Foreign token price / Native token price = decoded _balanceOf[hashForeign]\n', '        address hashNative;         // _getHashAddress(tokenA, tokenB, address(0), address(0));\n', '        address hashForeign;        // _getHashAddress(tokenB, tokenA, address(0), address(0));\n', '    }\n', '\n', '    function _calculateAmount(\n', '        uint256 pairID,\n', '        uint256 foreignAmount,\n', '        uint256 rate,    // Foreign token price / Native token price = (Native amount / Foreign amount)\n', '        uint256 foreignSpent,   // already swapped Foreign tokens (got from foreign contract)\n', '        uint256 nativeSpent,    // already swapped Native tokens (got from foreign contract)\n', '        uint256 nativeRate  // Native token price / Foreign token price. I.e. on BSC side: BNB price / ETH price = 0.2\n', '    )\n', '        internal\n', '        returns(uint256 nativeAmount, uint256 rest)\n', '    {\n', '        CalcVariables memory vars;\n', '        {\n', '            address tokenA = getPairByID[pairID].tokenA;\n', '            address tokenB = getPairByID[pairID].tokenB;\n', '            uint256 nativeDecimals = decimals[tokenA];\n', '            uint256 foreignDecimals = decimals[tokenB];\n', '            vars.nominatorForeignToNative = 10**(18+foreignDecimals-nativeDecimals);\n', '            vars.nominatorNativeToForeign = 10**(18+nativeDecimals-foreignDecimals);\n', '            vars.hashNative = _getHashAddress(tokenA, tokenB, address(0), address(0));\n', '            vars.hashForeign = _getHashAddress(tokenB, tokenA, address(0), address(0));\n', '            vars.localNative = _balanceOf[vars.hashNative];\n', '            (vars.localForeignRate, vars.localForeign) = _decode(_balanceOf[vars.hashForeign]);\n', '        }\n', '\n', '        // step 1. Check is it enough unspent native tokens\n', '        {\n', '            require(nativeSpent >= vars.localNative, "NativeSpent balance higher then remote");\n', '            uint256 nativeAvailable = nativeSpent - vars.localNative;\n', '            // nativeAvailable - amount ready to spend native tokens\n', '            // nativeRate = Native token price / Foreign token price. I.e. on BSC side BNB price / ETH price = 0.2\n', '            if (nativeAvailable != 0) {\n', '                // ?\n', '                uint256 requireAmount = foreignAmount * vars.nominatorNativeToForeign / nativeRate;\n', '                if (requireAmount <= nativeAvailable) {\n', '                    nativeAmount = requireAmount;   // use already swapped tokens\n', '                    foreignAmount = 0;\n', '                }\n', '                else {\n', '                    nativeAmount = nativeAvailable;\n', '                    foreignAmount = (requireAmount - nativeAvailable) * nativeRate / vars.nominatorNativeToForeign;\n', '                }\n', '                _balanceOf[vars.hashNative] += nativeAmount;\n', '            }\n', '        }\n', '        require(totalSupply[pairID] >= nativeAmount,"ERR: Not enough Total Supply");\n', '        // step 2. recalculate rate for swapped tokens\n', '        if (foreignAmount != 0) {\n', '            // i.e. on BSC side: rate = ETH price / BNB price = 5\n', '            uint256 requireAmount = foreignAmount * rate / vars.nominatorForeignToNative;\n', '            if (totalSupply[pairID] < nativeAmount + requireAmount) {\n', '                requireAmount = totalSupply[pairID] - nativeAmount;\n', '                rest = foreignAmount - (requireAmount * vars.nominatorForeignToNative / rate);\n', '                foreignAmount = foreignAmount - rest;\n', '            }\n', '            nativeAmount = nativeAmount + requireAmount;\n', '            require(vars.localForeign >= foreignSpent, "ForeignSpent balance higher then local");\n', '            uint256 foreignAvailable = vars.localForeign - foreignSpent;\n', '            // vars.localForeignRate, foreignAvailable - rate and amount swapped foreign tokens\n', '            if (foreignAvailable != 0) { // recalculate avarage rate (native amount / foreign amount)\n', '                rate = ((foreignAvailable * vars.localForeignRate) + (requireAmount * vars.nominatorForeignToNative)) / (foreignAvailable + foreignAmount);\n', '            }\n', '            _balanceOf[vars.hashForeign] = _encode(rate, vars.localForeign + foreignAmount);\n', '        }\n', '    }\n', '\n', '    // transfer fee to receiver and request SMART token as compensation.\n', '    // tokenA - token that user send\n', '    // amount - amount of tokens that user send\n', '    // user - address of user\n', '    function _transferFee(address tokenA, uint256 amount, address user, address licensee) internal {\n', '        require(licensee == address(0) || licenseeCompensator[licensee] != address(0), "licensee is not registered");\n', '        uint256 feeAmount = msg.value;\n', '        uint256 compFee; // company fee\n', '        if (tokenA < NATIVE_COINS) {\n', '            require(feeAmount >= amount, "Insuficiant value");   // if native coin, then feeAmount = msg.value - swap amount\n', '            feeAmount -= amount;\n', '            compFee = amount * companyFee / 10000;    // company fee\n', '        }\n', '        require(feeAmount >= processingFee, "Insufficient processing fee");\n', '        uint256 otherFee = feeAmount - processingFee;\n', '        uint256 licenseeFeeAmount;\n', '        uint256 licenseeFeeRate = licenseeFee[licensee];\n', '        if (licenseeFeeRate != 0 && otherFee != 0) {\n', '            if (tokenA < NATIVE_COINS) {\n', '                licenseeFeeAmount = amount * licenseeFeeRate / 10000;\n', '            } else {\n', '                licenseeFeeAmount = (otherFee * licenseeFeeRate)/(licenseeFeeRate + companyFee);\n', '            }\n', '        }\n', '        require(otherFee >= compFee + licenseeFeeAmount, "Insuficiant fee");\n', '        feeAmount -= licenseeFeeAmount;\n', '\n', '        if (licenseeFeeAmount != 0) {\n', '            TransferHelper.safeTransferETH(licensee, licenseeFeeAmount);\n', '            ISmart(licenseeCompensator[licensee]).requestCompensation(user, licenseeFeeAmount);\n', '        }\n', '\n', '        //TransferHelper.safeTransferETH(feeReceiver, feeAmount);\n', '        collectedFees += feeAmount;\n', '        if(contractSmart != address(0) && !isExcludedSender[msg.sender]) {\n', '            feeAmount = ((feeAmount - processingFee) * companyFeeReimbursement + processingFee * swapGasReimbursement) / 100;\n', '            if (feeAmount != 0)\n', '                ISmart(contractSmart).requestCompensation(user, feeAmount);\n', '        }\n', '    }\n', '    \n', '    // contribute from SmartSwap on user behalf\n', '    function _contributeFromSmartSwap(address token, address to, address user, uint256 value) internal {\n', '        if (token < NATIVE_COINS) {\n', '            IAuction(to).contributeFromSmartSwap{value: value}(payable(user));\n', '        } else {\n', '            IERC20(token).approve(to, value);\n', '            IAuction(to).contributeFromSmartSwap(token, value, user);\n', '        }\n', '    }\n', '\n', '    // call appropriate transfer function\n', '    function _transfer(address token, address to, uint256 value) internal {\n', '        if (token < NATIVE_COINS) \n', '            TransferHelper.safeTransferETH(to, value);\n', '        else\n', '            TransferHelper.safeTransfer(token, to, value);\n', '    }\n', '\n', '    // encode 64 bits of rate (decimal = 9). and 192 bits of amount \n', '    // into uint256 where high 64 bits is rate and low 192 bit is amount\n', '    // rate = foreign token price / native token price\n', '    function _encode(uint256 rate, uint256 amount) internal pure returns(uint256 encodedBalance) {\n', '        require(amount < MAX_AMOUNT, "Amount overflow");\n', '        require(rate < MAX_AMOUNT, "Rate overflow");\n', '        encodedBalance = rate * MAX_AMOUNT + amount;\n', '    }\n', '\n', '    // decode from uint256 where high 64 bits is rate and low 192 bit is amount\n', '    // rate = foreign token price / native token price\n', '    function _decode(uint256 encodedBalance) internal pure returns(uint256 rate, uint256 amount) {\n', '        rate = encodedBalance / MAX_AMOUNT;\n', '        amount = uint128(encodedBalance);\n', '    }\n', '    \n', '    function _getHashAddress(\n', '        address tokenA,\n', '        address tokenB, \n', '        address sender,\n', '        address receiver\n', '    )\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        return address(uint160(uint256(keccak256(abi.encodePacked(tokenA, tokenB, sender, receiver)))));\n', '    }\n', '}']