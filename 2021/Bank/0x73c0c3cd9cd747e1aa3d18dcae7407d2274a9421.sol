['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', 'import "./Ecocelium_Initializer.sol";\n', '\n', '/*\n', '\n', '███████╗░█████╗░░█████╗░░█████╗░███████╗██╗░░░░░██╗██╗░░░██╗███╗░░░███╗\n', '██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝██║░░░░░██║██║░░░██║████╗░████║\n', '█████╗░░██║░░╚═╝██║░░██║██║░░╚═╝█████╗░░██║░░░░░██║██║░░░██║██╔████╔██║\n', '██╔══╝░░██║░░██╗██║░░██║██║░░██╗██╔══╝░░██║░░░░░██║██║░░░██║██║╚██╔╝██║\n', '███████╗╚█████╔╝╚█████╔╝╚█████╔╝███████╗███████╗██║╚██████╔╝██║░╚═╝░██║\n', '╚══════╝░╚════╝░░╚════╝░░╚════╝░╚══════╝╚══════╝╚═╝░╚═════╝░╚═╝░░░░░╚═╝\n', '\n', 'Brought to you by Kryptual Team */\n', '\n', 'contract EcoceliumDataManager is Initializable {\n', '    \n', '    IAbacusOracle abacus;\n', '    EcoMoneyManager EMM;\n', '    EcoceliumInit Init;\n', '    enum Status {OPENCREATOR, OPENBORROW, MATCHED, CLOSED} \n', '\n', '    /*============Mappings=============\n', '    ----------------------------------*/\n', '    mapping (string => uint64[]) public orderpool;  //is an always sorted array based on Yield Rate of Pending Orders for all currencies\n', '    mapping (string => uint[]) public poolIndex;  //Index of First Investor Bid for all currencies\n', '    mapping (address => User) public users;\n', '    //mapping (address => address) public sponsorAddress; //FOR TREASURY PLAN\n', '    mapping (uint64 => Status) public orderStatus;\n', '    mapping (uint64 => matchedOrder) public matchOrderMap;\n', '    mapping (uint64 => Order) public openOrderMap;\n', '    mapping (uint64 => uint) public orderUSDValue;\n', '    \n', '    /*=========Structs and Initializer================\n', '    --------------------------------*/    \n', '    \n', '    struct freeStorage{     //USER DEPOSIT / BORROW STRUCTURE\n', '        uint amount;\n', '        uint time;\n', '        string wtoken;\n', '        uint usdvalue;\n', '    }\n', '    \n', '    struct matchedOrder{            //RUNNING OR MATCHED ORDERS IN THIS FORM\n', '        address payable supplier;\n', '        address payable borrower;\n', '        uint time;\n', '        uint expiryDate;\n', '        uint duration;\n', '        uint amount;\n', '        uint usdvalue;\n', '        uint yield;\n', '        string wtoken;\n', '        uint duesPaid;\n', '    }\n', '\n', '    struct Order{       // PENDING ORDERS IN THIS FORMAT\n', '        address payable creator;\n', '        uint duration;\n', '        uint amount;\n', '        uint yield;\n', '        string wtoken;\n', '    }    \n', '    \n', '    struct User{\n', '        uint totalDeposit;  //USD VALUE OF TOTAL DEPOSIT AT DEPOSIT TIME\n', '        uint totalBorrowed; //USD VALUE OF TOTAL DEPOSIT AT BORROW TIME\n', '        freeStorage [] myDeposits; //DEPOSIT DATA\n', '        freeStorage [] myBorrows; //BORROW DATA\n', '        mapping(string => uint) deposits; //CURRENCY-WISE TOTAL DEPOSIT COUNT FULL VALUE \n', '        mapping(string => uint) borrows; //CURRENCY-WISE TOTAL BORROW COUNT FULL VALUE\n', '        uint64 [] borrowedOrders; //BORROWED ORDER - ORDER ID\n', '        uint64 [] createdOrders; //CREATED ORDER - ORDER ID\n', '        uint64 [] myOrders; //MATCHED ORDR - ORDER ID\n', '    }\n', '    \n', '    function initializeAddress(address payable EMMaddress,address AbacusAddress, address payable Initaddress) external initializer{\n', '            EMM = EcoMoneyManager(EMMaddress);\n', '            abacus = IAbacusOracle(AbacusAddress); \n', '            Init = EcoceliumInit(Initaddress);\n', '    }\n', '\n', '    /*============Main Functions===============\n', '    Key Notes - \n', '    1) Always call main functions of Data Manager with Wrapped Token\n', '    2) _status signifies (status == Status.OPENCREATOR) operation - Returns True for Deposit Functions and False for Borrow Function\n', '    3) require(Init.friendlyaddress(msg.sender) ,"Not Friendly Address"); - This is mentioned in the EcoceliumInit Contract\n', '    4) FreePusher/Popper are for Liquidity Pools and push/pop order and matchOrder is the Order Matching Engine\n', '    5) Fetch Token Price Returns Values in 10**8\n', '    6) Amounts are without setting off Token Decimals\n', '    ---------------------------------*/\n', '    \n', '    function freePusher(address userAddress, string memory token, uint _amount, bool _status) external {  //_status signifies (status == Status.OPENCREATOR) operation\n', '        require(Init.friendlyaddress(msg.sender) ,"Not Friendly Address");\n', '        uint _usdValue = USDValue(_amount, token);\n', '        freeStorage memory newStorage = freeStorage({  amount: _amount,\n', '                                                    time: now,\n', '                                                    wtoken: token,\n', '                                                    usdvalue: _usdValue   });\n', '        if(_status){\n', '            users[userAddress].myDeposits.push(newStorage);\n', '            users[userAddress].totalDeposit += _usdValue;\n', '            users[userAddress].deposits[token] += _amount;\n', '        }   else {\n', '            users[userAddress].myBorrows.push(newStorage);\n', '            users[userAddress].totalBorrowed += _usdValue;\n', '            users[userAddress].borrows[token] += _amount;\n', '        }\n', '    }\n', '    \n', '    function freePopper(address userAddress, string memory _tokenSymbol, uint _amount, bool _status) public returns (uint dues) {\n', '        require(Init.friendlyaddress(msg.sender),"Not Friendly Address");\n', '        if(_status) { \n', '            require(users[userAddress].deposits[_tokenSymbol]>=_amount, "Insufficient Deposits");\n', '            users[userAddress].deposits[_tokenSymbol] -= _amount;\n', '        } else {\n', '            require(users[userAddress].borrows[_tokenSymbol]>=_amount,"Insufficient Borrowings");\n', '            users[userAddress].borrows[_tokenSymbol] -= _amount;\n', '        }\n', '        uint amountLeft= _amount;\n', '        freeStorage [] storage mystorage = _status ?  users[userAddress].myDeposits : users[userAddress].myBorrows;\n', '        for( uint i= mystorage.length-1; amountLeft >0 ; i--){\n', '            if(keccak256(abi.encodePacked(mystorage[i].wtoken)) != keccak256(abi.encodePacked(_tokenSymbol))) { continue; }\n', '            if (mystorage[i].amount <= amountLeft){\n', '                amountLeft -= mystorage[i].amount;\n', '                _status ? users[userAddress].totalDeposit -= mystorage[i].usdvalue : users[userAddress].totalBorrowed -= mystorage[i].usdvalue;\n', '                dues+= calculateECOEarning(USDValue(mystorage[i].amount,_tokenSymbol), _tokenSymbol, mystorage[i].time);\n', '                mystorage.pop(); \n', '            } else {\n', '                _status ? users[userAddress].totalDeposit -= (mystorage[i].amount-amountLeft)*mystorage[i].usdvalue : users[userAddress].totalBorrowed -= (mystorage[i].amount-amountLeft)*mystorage[i].usdvalue;\n', '                mystorage[i].amount -= amountLeft;\n', '                dues += calculateECOEarning(USDValue(amountLeft,_tokenSymbol), _tokenSymbol, mystorage[i].time);\n', '                amountLeft = 0;\n', '            }\n', '        } \n', '        _status ? users[userAddress].myDeposits = mystorage :   users[userAddress].myBorrows = mystorage;\n', '    }\n', '    \n', '    function pushOrder(address payable userAddress,string memory _tokenSymbol ,uint _amount,uint _duration, uint _yield, bool _status) internal returns (uint){\n', '        (uint64 _orderId,uint newAmount,uint fee) = _ordersub(_amount, userAddress, _duration, _tokenSymbol);\n', '        openOrderMap[_orderId] = Order({       \n', '                                            creator : userAddress,\n', '                                            duration : _duration,\n', '                                            amount : newAmount,\n', '                                            yield : _yield,\n', '                                            wtoken : _tokenSymbol\n', '                                 });\n', '        if(_status) {\n', '            orderStatus[_orderId] = Status.OPENCREATOR;\n', '            users[userAddress].createdOrders.push(_orderId);\n', '        } else  {\n', '            orderStatus[_orderId] = Status.OPENBORROW;\n', '            users[userAddress].borrowedOrders.push(_orderId);  }\n', '        orderpool[_tokenSymbol].push(_orderId);\n', '        if(orderpool[_tokenSymbol].length>1000)   {   poolSorter(_orderId, _tokenSymbol, true);   }\n', '        orderUSDValue[_orderId]=USDValue(_amount,_tokenSymbol);\n', '        return fee;\n', '    }\n', '    \n', '    function poolSorter(uint64 _orderId, string memory _tokenSymbol, bool _status) public {        //Status here signifies Insertion if True, and Deletion if false\n', '        uint64 [] memory temp;\n', '        bool task = false;\n', '        bool pooltask = false;\n', '        uint pid;\n', '        if(orderStatus[_orderId] == Status.OPENCREATOR) { pid = (openOrderMap[_orderId].duration/6) - 1; \n', '        } else if(orderStatus[_orderId] == Status.OPENBORROW) { pid = (openOrderMap[_orderId].duration/6) + 5; }\n', '        poolIndex[_tokenSymbol][pid]=0;\n', '\t    if(orderpool[_tokenSymbol].length==1 && _status) { orderpool[_tokenSymbol][1] = _orderId;   } else {\n', '            for((uint i, uint j)=(0,0);i<orderpool[_tokenSymbol].length;(i++,j++)) {\n', '                if(openOrderMap[orderpool[_tokenSymbol][i]].yield < 1) { continue; }\n', '                temp[j]=orderpool[_tokenSymbol][i];\n', '                if(!task && _status && openOrderMap[temp[j]].yield > openOrderMap[_orderId].yield) {    //Insertion Case\n', '                        temp[j]=_orderId; temp[++j]=orderpool[_tokenSymbol][i]; task = true;\n', '                }else if(!task && !_status && _orderId == temp[j]){     //Deletion Case\n', '                    temp[j]=orderpool[_tokenSymbol][++i]; task = true;\n', '                }\n', '                if(uint(openOrderMap[temp[j]].duration/6) == uint(openOrderMap[_orderId].duration/6) && orderStatus[orderpool[_tokenSymbol][i]]==Status.OPENBORROW) {       //Assigns updatePoolIndex with Highest Value of Borrow\n', '                    poolIndex[_tokenSymbol][pid] = i;\n', '                    pooltask = true;\n', '                } else if(uint(openOrderMap[temp[j]].duration/6) == uint(openOrderMap[_orderId].duration/6) && orderStatus[orderpool[_tokenSymbol][i]]==Status.OPENCREATOR && !pooltask) {\n', '                    poolIndex[_tokenSymbol][pid] = i;\n', '                    pooltask = true;\n', '                }\n', '            }\n', '            orderpool[_tokenSymbol] = temp;\n', '\t    }\n', '    }\n', '    \n', '    function matchOrder(address payable userAddress, string memory _tokenSymbol ,uint _amount,uint _duration,uint _yield, uint64 _orderId) internal    {\n', '        matchOrderMap[_orderId] = matchedOrder({       \n', '                                            supplier : (orderStatus[_orderId] == Status.OPENBORROW) ? userAddress : openOrderMap[_orderId].creator,\n', '                                            borrower : (orderStatus[_orderId] == Status.OPENCREATOR) ? userAddress : openOrderMap[_orderId].creator,\n', '                                            time    : now,\n', '                                            expiryDate : now + _duration*(30 days),\n', '                                            duration : _duration,\n', '                                            amount : _amount,\n', '                                            usdvalue : USDValue(_amount,_tokenSymbol),\n', '                                            yield : _yield,\n', '                                            wtoken : _tokenSymbol,\n', '                                            duesPaid : 0\n', '                                            });\n', '        \n', '        for((uint i,uint j)=(0,0); i<users[matchOrderMap[_orderId].supplier].createdOrders.length; (i++,j++)) {\n', '            if(users[matchOrderMap[_orderId].supplier].createdOrders[i] == _orderId) { --j; continue; }\n', '            users[matchOrderMap[_orderId].supplier].createdOrders[j] = users[matchOrderMap[_orderId].supplier].createdOrders[i];\n', '        }\n', '        for((uint i,uint j)=(0,0); i<users[matchOrderMap[_orderId].borrower].borrowedOrders.length; (i++,j++)) {\n', '            if(users[matchOrderMap[_orderId].borrower].borrowedOrders[i] == _orderId) { continue; }\n', '            users[matchOrderMap[_orderId].borrower].borrowedOrders[j] = users[matchOrderMap[_orderId].borrower].borrowedOrders[i];\n', '        }\n', '        delete openOrderMap[_orderId];\n', '        poolSorter(_orderId, _tokenSymbol, false);\n', '        orderStatus[_orderId]=Status.MATCHED;\n', '        orderUSDValue[_orderId]=USDValue(_amount,_tokenSymbol);\n', '        users[matchOrderMap[_orderId].supplier].myOrders.push(_orderId);\n', '        users[matchOrderMap[_orderId].borrower].myOrders.push(_orderId);\n', '        scheduleExpiry(_orderId);\n', '        scheduleCheck(_orderId,matchOrderMap[_orderId].borrower,1);\n', '        EMM.WithdrawManager(EMM.wtormap(_tokenSymbol), _amount, matchOrderMap[_orderId].borrower);\n', '        Init.emitOrderCreated(userAddress,_duration,_yield,_amount,_tokenSymbol); \n', '    }\n', '    \n', '    function newOrder(address payable userAddress,string memory _tokenSymbol ,uint _amount,uint _duration, uint _yield, bool _status) external {\n', '        require(Init.friendlyaddress(msg.sender),"Not Friendly Address");\n', '        uint amountLeft= _amount;\n', '        uint index;\n', '        if(_status){\n', '           index = poolIndex[_tokenSymbol][(_duration/6)-1]; \n', '           users[userAddress].deposits[_tokenSymbol] +=_amount;\n', '           users[userAddress].totalDeposit += USDValue(_amount, _tokenSymbol);\n', '        }   else {\n', '           index = poolIndex[_tokenSymbol][(_duration/6)+5];\n', '           users[userAddress].borrows[_tokenSymbol] +=_amount;\n', '           users[userAddress].totalBorrowed += USDValue(_amount, _tokenSymbol);\n', '        }\n', '        while(amountLeft>0){\n', '            if(index == 0) { pushOrder(userAddress, _tokenSymbol, _amount, _duration, _yield, _status);  break; }\n', '            Order memory iOrder = openOrderMap[orderpool[_tokenSymbol][index]];\n', '            if((_status && _yield>iOrder.yield) || (!_status && _yield<iOrder.yield) || (_status)?(orderStatus[orderpool[_tokenSymbol][index]] == Status.OPENCREATOR):(orderStatus[orderpool[_tokenSymbol][index]] == Status.OPENBORROW)){\n', '                pushOrder(userAddress, _tokenSymbol, _amount, _duration, _yield, _status);\n', '                break;\n', '            } else if(orderStatus[orderpool[_tokenSymbol][index]]== (_status ? Status.OPENBORROW : Status.OPENCREATOR))  {\n', '                uint tduration = _duration > iOrder.duration ? _duration : iOrder.duration;\n', '                uint tyield = _yield > iOrder.yield ? iOrder.yield : _yield;\n', '                uint64 tID = orderpool[_tokenSymbol][index];\n', '                if(iOrder.amount>=amountLeft) { \n', '                    if(iOrder.amount != amountLeft) {\n', '                    pushOrder(iOrder.creator, _tokenSymbol, iOrder.amount-amountLeft, iOrder.duration, iOrder.yield, !_status);     }\n', '                    matchOrder(userAddress, _tokenSymbol, amountLeft, tduration, tyield, tID);\n', '                    amountLeft=0;\n', '                } else {\n', '                    pushOrder(userAddress, _tokenSymbol, amountLeft- iOrder.amount, _duration, _yield, _status);\n', '                    matchOrder(userAddress, _tokenSymbol, amountLeft, tduration, tyield, tID);\n', '                    amountLeft -= openOrderMap[orderpool[_tokenSymbol][index]].amount;    }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function orderExpired  (uint64 _orderId) public {\n', '        require(Init.friendlyaddress(msg.sender),"Not Friendly Address");\n', '        require (matchOrderMap[_orderId].expiryDate <= now);\n', '        EMM.releaseWrappedToken(matchOrderMap[_orderId].supplier,matchOrderMap[_orderId].amount, matchOrderMap[_orderId].wtoken);    \n', '        EMM.burnWrappedFrom(matchOrderMap[_orderId].supplier,matchOrderMap[_orderId].amount, matchOrderMap[_orderId].wtoken); \n', '        EMM.WithdrawManager(EMM.wtormap(matchOrderMap[_orderId].wtoken), matchOrderMap[_orderId].amount, matchOrderMap[_orderId].supplier); \n', '        users[matchOrderMap[_orderId].supplier].totalDeposit -= matchOrderMap[_orderId].usdvalue;\n', '        users[matchOrderMap[_orderId].borrower].totalBorrowed -= matchOrderMap[_orderId].usdvalue;\n', '        orderStatus[_orderId] = Status.CLOSED;\n', '        //Init.OrderExpired(_orderId,msgSender,orderMonthlyDue(_orderId,msgSender,_duration));\n', '    } \n', '\n', '    function payDue(uint64 _orderId,uint _duration,address msgSender) external returns (uint due){\n', '        due = orderMonthlyDue(_orderId,_duration);\n', '        uint fee = (due*Init.rewardFee())/100;\n', '        EMM.DepositManager(Init.ECO(), due+fee, msgSender);\n', '        Init.setOwnerFeeVault(Init.WRAP_ECO_SYMBOL(), fee);\n', '        matchOrderMap[_orderId].duesPaid += 1;\n', '        matchOrderMap[_orderId].duesPaid >= uint((now - matchOrderMap[_orderId].time)/30 days)  ? Init.setUserLocked(msgSender,false) :  Init.setUserLocked(msgSender,true);\n', '        Init.emitDuePaid(_orderId,msgSender,orderMonthlyDue(_orderId,_duration));\n', '    }\n', '\n', '    function dueCheck(uint64 _orderId,address borrower,uint month) external returns(uint) {\n', '        require (Init.friendlyaddress(msg.sender) && now >= matchOrderMap[_orderId].time + matchOrderMap[_orderId].duesPaid * 30 days);\n', '        uint due = orderMonthlyDue(_orderId,1);\n', '        EMM.mintECO(matchOrderMap[_orderId].supplier,due*(100-Init.rewardFee())/100);\n', '        EMM.lockECO(matchOrderMap[_orderId].supplier,due*(100-Init.rewardFee())/100);\n', '        if(matchOrderMap[_orderId].duesPaid < month && !Init.isRegistrar(borrower) && !Init.isUserLocked(borrower)){\n', '            Init.setUserLocked(borrower,true);\n', '            orderExpired(_orderId);\n', '        }   else {\n', '            Init.emitDuePaid(_orderId,borrower,orderMonthlyDue(_orderId,month+1));\n', '            scheduleCheck(_orderId,borrower,month+1);\n', '        }\n', '    }\n', '\n', '    function scheduleExpiry(uint64 _orderId) internal{\n', '        uint time = matchOrderMap[_orderId].expiryDate - matchOrderMap[_orderId].time;\n', "        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('orderExpired(uint256)')),_orderId);\n", '        uint callCost = 300000*1e9 + abacus.callFee();\n', '        abacus.scheduleFunc{value:callCost}(address(this), time ,data , abacus.callFee() ,300000 , 1e9 );\n', '    }    \n', '    \n', '    function scheduleCheck(uint _orderId,address borrower,uint month) internal{\n', "        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('dueCheck(uint256,address,uint256)')),_orderId,borrower,month);\n", '        uint callCost = 300000*1e9 + abacus.callFee();\n', '        abacus.scheduleFunc{value:callCost}(address(this), 30 days ,data , abacus.callFee() ,300000 , 1e9 );\n', '    } \n', '    \n', '    function cancelOrder(uint64 _orderId) external{\n', '        require(Init.friendlyaddress(msg.sender));\n', '        if(orderStatus[_orderId]==Status.OPENCREATOR) {\n', '            EMM.releaseWrappedToken(openOrderMap[_orderId].creator,openOrderMap[_orderId].amount, openOrderMap[_orderId].wtoken);\n', '            EMM.burnWrappedFrom(openOrderMap[_orderId].creator,openOrderMap[_orderId].amount, openOrderMap[_orderId].wtoken); \n', '            EMM.WithdrawManager(EMM.wtormap(openOrderMap[_orderId].wtoken),openOrderMap[_orderId].amount, openOrderMap[_orderId].creator); \n', '            users[openOrderMap[_orderId].creator].deposits[openOrderMap[_orderId].wtoken] -=openOrderMap[_orderId].amount;\n', '            users[openOrderMap[_orderId].creator].totalDeposit -= orderUSDValue[_orderId];\n', '            for((uint i,uint j)=(0,0); i<users[openOrderMap[_orderId].creator].createdOrders.length; (i++,j++)) {\n', '                if(users[openOrderMap[_orderId].creator].createdOrders[i] == _orderId) { --j; continue; }\n', '                    users[openOrderMap[_orderId].creator].createdOrders[j] = users[openOrderMap[_orderId].creator].createdOrders[i];\n', '            }\n', '        }   else if(orderStatus[_orderId]==Status.OPENBORROW){\n', '                users[openOrderMap[_orderId].creator].borrows[openOrderMap[_orderId].wtoken] -=openOrderMap[_orderId].amount;\n', '                users[openOrderMap[_orderId].creator].totalBorrowed -= orderUSDValue[_orderId];\n', '                for((uint i,uint j)=(0,0); i<users[openOrderMap[_orderId].creator].borrowedOrders.length; (i++,j++)) {\n', '                    if(users[openOrderMap[_orderId].creator].borrowedOrders[i] == _orderId) { continue; }\n', '                    users[openOrderMap[_orderId].creator].borrowedOrders[j] = users[openOrderMap[_orderId].creator].borrowedOrders[i];\n', '             }\n', '        }\n', '        poolSorter(_orderId, openOrderMap[_orderId].wtoken,false);\n', '        delete openOrderMap[_orderId];\n', '        if(orderUSDValue[_orderId] > 0)  {   delete orderUSDValue[_orderId]; }\n', '        orderStatus[_orderId] = Status.CLOSED;\n', '    }\n', '    \n', '     /*==============Helpers============\n', '    ---------------------------------*/   \n', '    \n', '    function USDValue(uint amount, string memory _token) public view returns (uint usdvalue) {\n', '        usdvalue = amount*fetchTokenPrice(_token)/(10**8)/(10**uint(wERC20(EMM.getwTokenAddress(_token)).decimals()));\n', '    }\n', '    \n', '    function orderMonthlyDue(uint64 _orderId, uint _duration) public view returns(uint due){\n', '        orderStatus[_orderId] == Status.MATCHED ?  due = USDValue (matchOrderMap[_orderId].amount, matchOrderMap[_orderId].wtoken) * matchOrderMap[_orderId].yield * _duration*30 days*fetchTokenPrice(Init.WRAP_ECO_SYMBOL())/3153600000/(10**8) : due = 0;\n', '    }\n', '    \n', '    function fetchTokenPrice(string memory _tokenSymbol) public view returns(uint){ //Put any Token Wrapped or Direct\n', '    \tuint response = uint(abacus.getJobResponse(EMM.getFetchId(_tokenSymbol))[0]);\n', '    \treturn response > 0 ? response : 0;\n', '    }\n', '    \n', '    /*function issueReward(address userAddress, string memory _tokenSymbol, uint time, uint tokenUsdValue) internal {\n', '        uint reward = calculateECOEarning(tokenUsdValue, _tokenSymbol, time);\n', '        EMM.mintECO(userAddress, reward);\n', '    }*/\n', '    \n', '    function calculateECOEarning(uint usdvalue, string memory _tokenSymbol, uint time) private view returns (uint){\n', '        uint _amount = usdvalue*(10**16)/fetchTokenPrice(Init.WRAP_ECO_SYMBOL());\n', '        uint reward = (_amount * Init.slabRateDeposit(_tokenSymbol) * (now - time))/3153600000; //decimal from Abacus is setoff by decimal from Eco\n', '        return reward;\n', '    }\n', '    \n', '    function getECOEarnings(address userAddress) public view returns (uint){\n', '        uint ecobalance;\n', '        for(uint i=0; i<users[userAddress].myDeposits.length; i++) {\n', '            ecobalance += calculateECOEarning(users[userAddress].myDeposits[i].usdvalue, users[userAddress].myDeposits[i].wtoken, users[userAddress].myDeposits[i].time);\n', '        }\n', '\t    for(uint i=0; i<users[userAddress].myBorrows.length; i++) {\n', '            ecobalance -= calculateECOEarning(users[userAddress].myBorrows[i].usdvalue, users[userAddress].myBorrows[i].wtoken, users[userAddress].myBorrows[i].time);\n', '        }\n', '        if(ecobalance > EMM.ecoWithdrawls(userAddress)) { return ecobalance - EMM.ecoWithdrawls(userAddress); } else {\n', '            return uint(0);\n', '        }\n', '    }\n', '    \n', '    function _ordersub(uint amount,address userAddress,uint _duration,string memory _tokenSymbol) internal view returns (uint64, uint, uint){\n', '        uint newAmount = amount - (amount*Init.tradeFee())/100;\n', '        uint fee = (amount*Init.tradeFee())/100;\n', '        uint64 _orderId = uint64(uint(keccak256(abi.encodePacked(userAddress,_tokenSymbol,_duration,now))));\n', '        return (_orderId,newAmount,fee);\n', '    }\n', '    \n', '    function getUserDepositsbyToken(address userAddress, string memory wtoken) public view returns(uint) {\n', '        return users[userAddress].deposits[wtoken];\n', '    }\n', '    \n', '    function getUserBorrowedOrderbyToken(address userAddress, string memory wtoken) public view returns(uint) {\n', '        return users[userAddress].borrows[wtoken];\n', '    }\n', '    \n', '    function getUserBorrowed(address userAddress) public view returns(uint) {\n', '        return users[userAddress].totalBorrowed;\n', '    }\n', '    \n', '    function getUserBorrowedOrder(address userAddress) public view returns (uint64 [] memory) {\n', '        return users[userAddress].borrowedOrders;\n', '    }\n', '    \n', '    function getUserDepositOrder(address userAddress) public view returns (uint64 [] memory) {\n', '        return users[userAddress].createdOrders;\n', '    }\n', '    \n', '    function getUserMatchOrder(address userAddress) public view returns (uint64 [] memory) {\n', '        return users[userAddress].myOrders;\n', '    }\n', '    \n', '    function getbuyPower(address userAddress) public view returns (uint buyPower){\n', '        if(Init.isRegistrar(userAddress)) { return (10**30);   }\n', '        if(Init.isUserLocked(userAddress)) { return 0; }\n', '        if(users[userAddress].totalBorrowed > 0) {    \n', '            return users[userAddress].totalDeposit - ((users[userAddress].totalDeposit*Init.CDSpercent())/100) - users[userAddress].totalBorrowed;\n', '        } else {\n', '            return users[userAddress].totalDeposit;\n', '        }\n', '    }\n', '    \n', '    /*function getOrderIds(string memory wtoken) public view returns (uint64 [] memory orderIds) {\n', '        return orderpool[wtoken];\n', '    }*/\n', '    \n', '    function getOrderLength(string memory wtoken) public view returns (uint) {\n', '        return orderpool[wtoken].length;\n', '    }\n', '    \n', '    function updatePoolIndex(string memory token, uint64 iVal, uint64 value) external {\n', '            poolIndex[token].push(iVal);\n', '            orderpool[token].push(value);\n', '    }\n', '}\n', '    \n', '    /*function deleteUserData(address userAddress) external {\n', '        if(Init.friendlyaddress(msg.sender)==true) {\n', '            delete users[userAddress];\n', '        }\n', '    }*/\n', '\n', '\n', '\n', 'contract Ecocelium is Initializable{\n', '\n', '    address public owner;\n', '    address payable EMMAddress;\n', '    IAbacusOracle abacus;\n', '    EcoMoneyManager EMM;\n', '    EcoceliumDataManager EDM;\n', '    EcoceliumInit Init;\n', '    \n', '    function initialize(address _owner,address payable EMMaddress,address payable AbacusAddress,address EDMaddress, address payable Initaddress)public payable initializer {\n', '        owner = _owner;\n', '        EMM = EcoMoneyManager(EMMaddress);\n', '        EMMAddress = EMMaddress;\n', '        abacus = IAbacusOracle(AbacusAddress);//0x323f81D9F57d2c3d5555b14d90651aCDc03F9d52\n', '        EDM = EcoceliumDataManager(EDMaddress);\n', '        Init = EcoceliumInit(Initaddress);\n', '    }\n', '    \n', '    function changeOwner(address _owner) public{\n', '        require(msg.sender==owner);\n', '        owner = _owner;\n', '    }\n', '    \n', '    function updateContracts() public{\n', '        require(msg.sender==owner);\n', '        EMM = EcoMoneyManager(Init.MONEYMANAGER());\n', '        abacus = IAbacusOracle(Init.ABACUS());\n', '        EDM = EcoceliumDataManager(Init.DATAMANAGER());\n', '    }\n', '    \n', '     /*===========Main functions============\n', '    -------------------------------------*/   \n', '\n', '    function Deposit(string memory rtoken, uint _amount) external payable {\n', '        address _msgSender = msg.sender;\n', '        string memory wtoken = EMM.getWrapped(rtoken);\n', '        _deposit(rtoken, _amount, _msgSender, wtoken);\n', '        EDM.freePusher(_msgSender, wtoken, _amount, true);\n', '        EMM.mintWrappedToken(_msgSender, _amount, wtoken);\n', '        EMM.lockWrappedToken(_msgSender, _amount,wtoken);\n', '    }\n', '    \n', '    function _deposit(string memory rtoken,uint _amount, address msgSender, string memory wtoken) internal {\n', '        require(EMM.getwTokenAddress(wtoken) != address(0),"not supported");\n', '        if(keccak256(abi.encodePacked(rtoken)) == keccak256(abi.encodePacked(Init.ETH_SYMBOL()))) { \n', '            require(msg.value >= _amount);\n', '            EMM.DepositManager{value:msg.value}(rtoken, _amount, msgSender);\n', '        }else {\n', '        EMM.DepositManager(rtoken, _amount, msgSender); }\n', '        Init.emitSwap(msgSender,rtoken,wtoken,_amount);\n', '    }\n', '    \n', '    function depositAndOrder(address payable userAddress,string memory rtoken ,uint _amount,uint _duration,uint _yield) external payable {\n', '        require(msg.sender == userAddress);\n', '        string memory wtoken = EMM.getWrapped(rtoken);\n', '        _deposit(rtoken, _amount, userAddress, wtoken);\n', '        EMM.mintWrappedToken(userAddress, _amount, wtoken);\n', '        EMM.lockWrappedToken(userAddress, _amount,wtoken);\n', '        EDM.newOrder(userAddress, EMM.getWrapped(rtoken), _amount, (_duration/6)-1, _yield, true);\n', '    }\n', '    \n', '    function createOrder(address payable userAddress,string memory _tokenSymbol ,uint _amount,uint _duration,uint _yield) external payable {\n', '        require(msg.sender == userAddress);\n', '        require(_duration>=6, "Duration should be atleast 6 Months");\n', '        string memory wtoken = EMM.getWrapped(_tokenSymbol);\n', '        require(EDM.getUserDepositsbyToken(userAddress, wtoken) >= _amount, "Insufficient Balance"); \n', '        uint ecoEarnings = EDM.freePopper(userAddress, wtoken , _amount, true);\n', '        if(ecoEarnings > EMM.ecoWithdrawls(userAddress)) {\n', '    \t\tecoEarnings-=EMM.ecoWithdrawls(userAddress);\n', '    \t\tEMM.adjustEcoEarning(userAddress, EMM.ecoWithdrawls(userAddress));\n', '    \t\tEMM.WithdrawManager(Init.ECO(), ecoEarnings, userAddress);\n', '    \t} else {\n', '    \t\tEMM.adjustEcoEarning(userAddress, ecoEarnings);\t}\n', '        EDM.newOrder(userAddress, wtoken, _amount, (_duration/6)-1, _yield, true); \n', '    }\n', '    \n', '    function getAggEcoBalance(address userAddress) public view returns(uint) {\n', '        return wERC20(EMM.getwTokenAddress(Init.WRAP_ECO_SYMBOL())).balanceOf(userAddress) + EDM.getECOEarnings(userAddress);\n', '    }\n', '    \n', '    function borrowOrder(address userAddress, string memory rtoken, uint amount, uint duration, uint yield) public {//Rewrite this part\n', '        require(isWithdrawEligible(userAddress, rtoken, amount));\n', '        EDM.newOrder(msg.sender,EMM.getWrapped(rtoken), amount,(duration/6)-1,yield,false);\n', '    }\n', '    \n', '    function payDueOrder(uint64 _orderId,uint _duration) external {\n', '        EDM.payDue(_orderId,_duration,msg.sender);\n', '    }\n', '    \n', '    function clearBorrow(string memory rtoken, uint _amount) external payable{\n', '        address msgSender = msg.sender;\n', '        string memory wtoken = EMM.getWrapped(rtoken);\n', '        uint dues = EDM.freePopper(msgSender, wtoken, _amount, false);\n', '\t    EMM.DepositManager(Init.ECO(), dues, msgSender);\n', '        if(keccak256(abi.encodePacked(rtoken)) == keccak256(abi.encodePacked(Init.ETH_SYMBOL()))) { \n', '            require(msg.value == _amount);\n', '            EMM.DepositManager{value:_amount}(rtoken, _amount, msgSender);\n', '        }else {\n', '        EMM.DepositManager(rtoken, _amount, msgSender);    }\n', '    }\n', '    \n', '    function Borrow(uint _amount, string memory _tokenSymbol) external {\n', '        require(isWithdrawEligible(msg.sender, _tokenSymbol, _amount));\n', '        EDM.freePusher(msg.sender, EMM.getWrapped(_tokenSymbol), _amount,false);\n', '        EMM.WithdrawManager(_tokenSymbol, _amount, msg.sender);\n', '    }\n', '    \n', '    function SwapWrapToWrap(string memory token1,string memory token2, uint token1amount)  external returns(uint) {\n', '        address payable msgSender = msg.sender;\n', '        uint token2price = fetchTokenPrice(token2);\n', '        uint token2amount = EDM.USDValue(token1amount,token1)*(100-Init.swapFee())*(10**uint(wERC20(EMM.getwTokenAddress(token2)).decimals()))*(10**8)/token2price/100;\n', '        EMM.w2wswap(msgSender, token1, token1amount, token2amount, token2);\n', '        uint ecoEarnings = EDM.freePopper(msgSender,token1,token1amount,true);\n', '\t    if(ecoEarnings>0) {\n', '    \t    if(ecoEarnings > EMM.ecoWithdrawls(msgSender)) {\n', '        \t\tecoEarnings-=EMM.ecoWithdrawls(msgSender);\n', '        \t\tif(EMM.ecoWithdrawls(msgSender) > 0) {  EMM.adjustEcoEarning(msgSender, EMM.ecoWithdrawls(msgSender));  }\n', '        \t\tEMM.WithdrawManager(Init.ECO(), ecoEarnings, msgSender);\n', '        \t} else {\n', '        \t\tEMM.adjustEcoEarning(msgSender, ecoEarnings);\t}\n', '    \t}\n', '\t    Init.setOwnerFeeVault(token1, token1amount*Init.swapFee()/100);\n', '        EDM.freePusher(msgSender, token2,token2amount,true);\n', '        Init.emitSwap(msgSender,token1,token2,token2amount);\n', '        return token2amount;\n', '    }\n', '    \n', '    function cancelOrder(uint64 _orderId) public{\n', '        (address creator,,,,) = EDM.openOrderMap(_orderId);\n', '        require(msg.sender==creator);\n', '        EDM.cancelOrder(_orderId);\n', '    }\n', '    \n', '    receive() external payable {  }\n', '\n', '    /*==============Helpers============\n', '    ---------------------------------*/    \n', '    \n', '    function orderMonthlyDue(uint64 _orderId,uint _duration) public view returns(uint){\n', '        return EDM.orderMonthlyDue(_orderId,_duration);\n', '    }\n', '    \n', '    function updateFees(uint _swapFee,uint _tradeFee,uint _rewardFee) public{\n', '        require(msg.sender == owner);\n', '        Init.updateFees(_swapFee,_tradeFee,_rewardFee);\n', '    }\n', '    \n', '    /*function getOrderIds(string memory wtoken) public view returns(uint64 [] memory){\n', '        return EDM.getOrderIds(wtoken);\n', '    }*/\n', '    \n', '    function fetchTokenPrice(string memory _tokenSymbol) public view returns(uint){\n', '        return EDM.fetchTokenPrice(_tokenSymbol);\n', '    }\n', '    \n', '    function Withdraw(string memory to, uint _amount) external {\n', '        address payable msgSender = msg.sender;\n', '        string memory from = EMM.getWrapped(to);\n', '        require(!Init.isUserLocked(msgSender), "Your Address is Locked Pay Dues");\n', '        if( EDM.getUserBorrowed(msgSender) > 0) { require(isWithdrawEligible(msgSender, to, _amount) , "Not Eligible for Withdraw"); }\n', '        if(keccak256(abi.encodePacked(to)) == keccak256(abi.encodePacked(Init.ECO()))) {\n', '            require( getAggEcoBalance(msgSender) >= _amount,"Insufficient Balance");\n', '                if(getAggEcoBalance(msgSender) - EDM.getUserDepositsbyToken(msgSender, from) >= _amount) {\n', '                    EMM.redeemEcoEarning(msgSender,_amount);\n', '                } else {\n', '                    uint diffAmount = _amount + EDM.getUserDepositsbyToken(msgSender, from) - getAggEcoBalance(msgSender);\n', '                    EMM.redeemEcoEarning(msgSender,(getAggEcoBalance(msgSender) - EDM.getUserDepositsbyToken(msgSender, from)));\n', '                    _withdraw(msgSender, from, diffAmount, to);        }  \n', '        } else  {  \n', '            require(EDM.getUserDepositsbyToken(msgSender, from)>=_amount,"Insufficient balance");\n', '            _withdraw(msgSender, from, _amount, to);\n', '        }\n', '        Init.emitSwap(msgSender,from,to,_amount);\n', '    }\n', '    \n', '    function _withdraw(address payable msgSender, string memory from, uint amount, string memory to) internal {\n', '        EMM.releaseWrappedToken(msgSender,amount, from);\n', '        EMM.burnWrappedFrom(msgSender, amount, from);\n', '        Init.setOwnerFeeVault(to,(amount*Init.rewardFee())/100);\n', '        uint ecoEarnings = EDM.freePopper(msgSender,from,amount, true);\n', '    \tif(ecoEarnings>0) {\n', '    \t    if(ecoEarnings > EMM.ecoWithdrawls(msgSender)) {\n', '        \t\tecoEarnings-=EMM.ecoWithdrawls(msgSender);\n', '        \t\tif(EMM.ecoWithdrawls(msgSender) > 0) {  EMM.adjustEcoEarning(msgSender, EMM.ecoWithdrawls(msgSender));  }\n', '        \t\tEMM.WithdrawManager(Init.ECO(), ecoEarnings, msgSender);\n', '        \t} else {\n', '        \t\tEMM.adjustEcoEarning(msgSender, ecoEarnings);\t}\n', '    \t}\n', '        uint newAmount = amount - (amount*Init.rewardFee())/100;\n', '        EMM.WithdrawManager(to,newAmount, msgSender);\n', '    }\n', '    \n', '    function isWithdrawEligible(address userAddress, string memory to, uint amount) public view returns (bool Eligible){\n', '        return (EDM.getbuyPower(userAddress) > EDM.USDValue(amount,EMM.getWrapped(to)));\n', '    }\n', '    \n', '    function setSponsor(address userAddress, address Sponsor) external {\n', '        require(msg.sender == userAddress, "Invalid User");\n', '        Init.setSponsor(userAddress, Sponsor);\n', '    }\n', '}']