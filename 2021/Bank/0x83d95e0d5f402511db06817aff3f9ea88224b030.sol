['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-15\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface ManagementList {\n', '    function isManager(address accountAddress) external returns (bool);\n', '}\n', '\n', 'contract Manageable {\n', '    ManagementList public managementList;\n', '\n', '    constructor(address _managementListAddress) {\n', '        managementList = ManagementList(_managementListAddress);\n', '    }\n', '\n', '    modifier onlyManagers() {\n', '        bool isManager = managementList.isManager(msg.sender);\n', '        require(isManager, "ManagementList: caller is not a manager");\n', '        _;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'contract Oracle is Manageable {\n', '    address[] private _calculations;\n', '    address public usdcAddress;\n', '    mapping(address => address) public tokenAliases;\n', '\n', '    event TokenAliasAdded(address tokenAddress, address tokenAliasAddress);\n', '    event TokenAliasRemoved(address tokenAddress);\n', '\n', '    struct TokenAlias {\n', '        address tokenAddress;\n', '        address tokenAliasAddress;\n', '    }\n', '\n', '    constructor(address _managementListAddress, address _usdcAddress)\n', '        Manageable(_managementListAddress)\n', '    {\n', '        usdcAddress = _usdcAddress;\n', '    }\n', '\n', '    /**\n', '     * The oracle supports an array of calculation contracts. Each calculation contract must implement getPriceUsdc().\n', '     * When setting calculation contracts all calculations must be set at the same time (we intentionally do not support for adding/removing calculations).\n', '     * The order of calculation contracts matters as it determines the order preference in the cascading fallback mechanism.\n', '     */\n', '    function setCalculations(address[] memory calculationAddresses)\n', '        external\n', '        onlyManagers\n', '    {\n', '        _calculations = calculationAddresses;\n', '    }\n', '\n', '    function calculations() external view returns (address[] memory) {\n', '        return (_calculations);\n', '    }\n', '\n', '    function addTokenAlias(address tokenAddress, address tokenAliasAddress)\n', '        public\n', '        onlyManagers\n', '    {\n', '        tokenAliases[tokenAddress] = tokenAliasAddress;\n', '        emit TokenAliasAdded(tokenAddress, tokenAliasAddress);\n', '    }\n', '\n', '    function addTokenAliases(TokenAlias[] memory _tokenAliases)\n', '        public\n', '        onlyManagers\n', '    {\n', '        for (uint256 i = 0; i < _tokenAliases.length; i++) {\n', '            addTokenAlias(\n', '                _tokenAliases[i].tokenAddress,\n', '                _tokenAliases[i].tokenAliasAddress\n', '            );\n', '        }\n', '    }\n', '\n', '    function removeTokenAlias(address tokenAddress) public onlyManagers {\n', '        delete tokenAliases[tokenAddress];\n', '        emit TokenAliasRemoved(tokenAddress);\n', '    }\n', '\n', '    function getNormalizedValueUsdc(\n', '        address tokenAddress,\n', '        uint256 amount,\n', '        uint256 priceUsdc\n', '    ) public view returns (uint256) {\n', '        IERC20 token = IERC20(tokenAddress);\n', '        uint256 tokenDecimals = token.decimals();\n', '\n', '        uint256 usdcDecimals = 6;\n', '        uint256 decimalsAdjustment;\n', '        if (tokenDecimals >= usdcDecimals) {\n', '            decimalsAdjustment = tokenDecimals - usdcDecimals;\n', '        } else {\n', '            decimalsAdjustment = usdcDecimals - tokenDecimals;\n', '        }\n', '        uint256 value;\n', '        if (decimalsAdjustment > 0) {\n', '            value =\n', '                (amount * priceUsdc * (10**decimalsAdjustment)) /\n', '                10**(decimalsAdjustment + tokenDecimals);\n', '        } else {\n', '            value = (amount * priceUsdc) / 10**usdcDecimals;\n', '        }\n', '        return value;\n', '    }\n', '\n', '    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 priceUsdc = getPriceUsdcRecommended(tokenAddress);\n', '        return getNormalizedValueUsdc(tokenAddress, amount, priceUsdc);\n', '    }\n', '\n', '    function getPriceUsdcRecommended(address tokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address tokenAddressAlias = tokenAliases[tokenAddress];\n', '        address tokenToQuery = tokenAddress;\n', '        if (tokenAddressAlias != address(0)) {\n', '            tokenToQuery = tokenAddressAlias;\n', '        }\n', '        (bool success, bytes memory data) =\n', '            address(this).staticcall(\n', '                abi.encodeWithSignature("getPriceUsdc(address)", tokenToQuery)\n', '            );\n', '        if (success) {\n', '            return abi.decode(data, (uint256));\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * Cascading fallback proxy\n', '     *\n', '     * Loop through all contracts in _calculations and attempt to forward the method call to each underlying contract.\n', '     * This allows users to call getPriceUsdc() on the oracle contract and the result of the first non-reverting contract that\n', '     * implements getPriceUsdc() will be returned.\n', '     *\n', '     * This mechanism also exposes all public methods for calculation contracts. This allows a user to\n', '     * call oracle.isIronBankMarket() or oracle.isCurveLpToken() even though these methods live on different contracts.\n', '     */\n', '    fallback() external {\n', '        for (uint256 i = 0; i < _calculations.length; i++) {\n', '            address calculation = _calculations[i];\n', '            assembly {\n', '                let _target := calculation\n', '                calldatacopy(0, 0, calldatasize())\n', '                let success := staticcall(\n', '                    gas(),\n', '                    _target,\n', '                    0,\n', '                    calldatasize(),\n', '                    0,\n', '                    0\n', '                )\n', '                returndatacopy(0, 0, returndatasize())\n', '                if success {\n', '                    return(0, returndatasize())\n', '                }\n', '            }\n', '        }\n', '        revert("Oracle: Fallback proxy failed to return data");\n', '    }\n', '}']