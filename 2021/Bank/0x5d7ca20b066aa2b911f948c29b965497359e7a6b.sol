['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract CoreSwapLimitOrder is Ownable {\n', '    using SafeMath for uint256;\n', '    \n', '    IUniswapV2Router02 public immutable uniswapV2Router;\n', '    IUniswapV2Factory public immutable uniswapV2Factory;\n', '    \n', '    \n', '    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\n', '    enum OrderState {Created, Cancelled, Finished}\n', '    \n', '    uint public ordersNum = 0;\n', '    uint[] public orders;\n', '    struct Order {\n', '        OrderState orderState;\n', '        OrderType orderType;\n', '        address payable traderAddress;\n', '        address assetIn;\n', '        address assetOut;\n', '        uint assetInOffered;\n', '        uint assetOutExpected;\n', '        uint executorFee;\n', '        uint id;\n', '        uint ordersI;\n', '    }\n', '\n', '\n', '    uint public EXECUTOR_FEE = 500000000000000;\n', '\n', '    event orderCreatedLog(uint id, OrderState orderState, OrderType orderType, address payable traderAddress, address assetIn, address assetOut, uint assetInOffered, uint assetOutExpected, uint executorFee);\n', '    event orderExecutedLog(uint id, address executor, uint[] amounts);\n', '    event orderCancelledLog(uint id, address payable traderAddress, address assetIn, address assetOut, uint refundETH, uint refundToken);\n', '    mapping(address => uint[]) private ordersForAddress;\n', '    mapping(uint => Order) public orderBook;\n', '    \n', '    \n', '    constructor(IUniswapV2Router02 _uniswapV2Router) {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '    }\n', '    \n', '    function setNewExecutorFee(uint256 _EXECUTOR_FEE) external onlyOwner {\n', '        EXECUTOR_FEE = _EXECUTOR_FEE;\n', '    }\n', '    \n', '    function getPair(address tokenA, address tokenB) internal view returns (address) {\n', '        address _tokenPair = uniswapV2Factory.getPair(tokenA, tokenB);\n', '        require(_tokenPair != address(0), "Unavailable token pair");\n', '        return _tokenPair;\n', '    }\n', '    \n', '    function updateOrderState(Order memory order, OrderState newState) internal {\n', '        if(orders.length > 1) {\n', '            uint openId = order.ordersI;\n', '            uint lastId = orders[orders.length-1];\n', '            Order memory lastOrder = orderBook[lastId];\n', '            lastOrder.ordersI = openId;\n', '            orderBook[lastId] = lastOrder;\n', '            orders[openId] = lastId;\n', '        }\n', '        orders.pop();\n', '        order.orderState = newState;\n', '        orderBook[order.id] = order;        \n', '    }\n', '    \n', '    function createOrder(OrderType orderType, address assetIn, address assetOut, uint assetInOffered, uint assetOutExpected, uint executorFee) external payable {\n', '        \n', '        uint payment = msg.value;\n', '        \n', '        require(assetInOffered > 0, "Asset in amount must be greater than 0");\n', '        require(assetOutExpected > 0, "Asset out amount must be greater than 0");\n', '        require(executorFee >= EXECUTOR_FEE, "Invalid fee");\n', '        \n', '        if(orderType == OrderType.EthForTokens) {\n', '            require(assetIn == uniswapV2Router.WETH(), "Use WETH as the assetIn");\n', '            require(payment >= assetInOffered.add(executorFee), "Payment = assetInOffered + executorFee");\n', '        }\n', '        else {\n', '            require(payment >= executorFee, "Transaction value must match executorFee");\n', '            if (orderType == OrderType.TokensForEth) { require(assetOut == uniswapV2Router.WETH(), "Use WETH as the assetOut"); }\n', '            TransferHelper.safeTransferFrom(assetIn, msg.sender, address(this), assetInOffered);\n', '        }\n', '        \n', '        \n', '        uint orderId = ordersNum;\n', '        ordersNum++;\n', '        \n', '        orderBook[orderId] = Order(OrderState.Created, orderType, msg.sender, assetIn, assetOut, assetInOffered, \n', '        assetOutExpected, executorFee, orderId, orders.length);\n', '        \n', '        ordersForAddress[msg.sender].push(orderId);\n', '        orders.push(orderId);\n', '        \n', '        emit orderCreatedLog( orderId, OrderState.Created, orderType, msg.sender, assetIn, assetOut, assetInOffered, assetOutExpected, executorFee);\n', '    }\n', '        \n', '    function cancelOrder(uint orderId) external {\n', '        Order memory order = orderBook[orderId];  \n', '        require(order.traderAddress != address(0), "Invalid order");\n', "        require(msg.sender == order.traderAddress, 'This order is not yours');\n", "        require(order.orderState == OrderState.Created, 'Invalid order state');\n", '        \n', '        updateOrderState(order, OrderState.Cancelled);\n', '        \n', '        uint refundETH = 0;\n', '        uint refundToken = 0;\n', '        \n', '        if (order.orderType != OrderType.EthForTokens) {\n', '            refundETH = order.executorFee;\n', '            refundToken = order.assetInOffered;\n', '            TransferHelper.safeTransferETH(order.traderAddress, refundETH);\n', '            TransferHelper.safeTransfer(order.assetIn, order.traderAddress, refundToken);\n', '        }\n', '        else {\n', '            refundETH = order.assetInOffered.add(order.executorFee);\n', '            TransferHelper.safeTransferETH(order.traderAddress, refundETH);  \n', '        }\n', '        \n', '        emit orderCancelledLog(order.id, order.traderAddress, order.assetIn, order.assetOut, refundETH, refundToken);        \n', '    }\n', '    \n', '    function executeOrder(uint orderId) external onlyOwner returns (uint[] memory) {\n', '        Order memory order = orderBook[orderId];  \n', '        require(order.traderAddress != address(0), "Invalid order");\n', "        require(order.orderState == OrderState.Created, 'Invalid order state');\n", '        \n', '        updateOrderState(order, OrderState.Finished);\n', '    \n', '        address[] memory pair = new address[](2);\n', '        pair[0] = order.assetIn;\n', '        pair[1] = order.assetOut;\n', '\n', '        uint[] memory swapResult;\n', '        \n', '        if (order.orderType == OrderType.EthForTokens) {\n', '            swapResult = uniswapV2Router.swapExactETHForTokens{value:order.assetInOffered}(order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '        } \n', '        else if (order.orderType == OrderType.TokensForEth) {\n', '            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\n', '            swapResult = uniswapV2Router.swapExactTokensForETH(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '        }\n', '        else if (order.orderType == OrderType.TokensForTokens) {\n', '            TransferHelper.safeApprove(order.assetIn, address(uniswapV2Router), order.assetInOffered);\n', '            swapResult = uniswapV2Router.swapExactTokensForTokens(order.assetInOffered, order.assetOutExpected, pair, order.traderAddress, block.timestamp);\n', '        }\n', '        \n', '        TransferHelper.safeTransferETH(msg.sender, order.executorFee);\n', '        emit orderExecutedLog(order.id, msg.sender, swapResult);\n', '        \n', '        return swapResult;\n', '    }\n', '    \n', '    function getOrdersLength() external view returns (uint) {\n', '        return orders.length;\n', '    }\n', '    \n', '    receive() external payable {}\n', '    \n', '}']