['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-06\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IPairFeeDistribution {\n', '    function addpair(address pair) external;\n', '}\n', '\n', 'library Math {\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        z = x < y ? x : y;\n', '    }\n', '\n', '    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'library SafeMath256 {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/*\n', 'This library defines a decimal floating point number. It has 8 decimal significant digits. Its maximum value is 9.9999999e+15.\n', 'And its minimum value is 1.0e-16. The following golang code explains its detail implementation.\n', '\n', 'func buildPrice(significant int, exponent int) uint32 {\n', '\tif !(10000000 <= significant && significant <= 99999999) {\n', '\t\tpanic("Invalid significant")\n', '\t}\n', '\tif !(-16 <= exponent && exponent <= 15) {\n', '\t\tpanic("Invalid exponent")\n', '\t}\n', '\treturn uint32(((exponent+16)<<27)|significant);\n', '}\n', '\n', 'func priceToFloat(price uint32) float64 {\n', '\texponent := int(price>>27)\n', '\tsignificant := float64(price&((1<<27)-1))\n', '\treturn significant * math.Pow10(exponent-23)\n', '}\n', '\n', '*/\n', '\n', '// A price presented as a rational number\n', 'struct RatPrice {\n', '    uint numerator;   // at most 54bits\n', '    uint denominator; // at most 76bits\n', '}\n', '\n', 'library DecFloat32 {\n', '    uint32 public constant MANTISSA_MASK = (1<<27) - 1;\n', '    uint32 public constant MAX_MANTISSA = 9999_9999;\n', '    uint32 public constant MIN_MANTISSA = 1000_0000;\n', '    uint32 public constant MIN_PRICE = MIN_MANTISSA;\n', '    uint32 public constant MAX_PRICE = (31<<27)|MAX_MANTISSA;\n', '\n', '    // 10 ** (i + 1)\n', '    function powSmall(uint32 i) internal pure returns (uint) {\n', '        uint x = 2695994666777834996822029817977685892750687677375768584125520488993233305610;\n', '        return (x >> (32*i)) & ((1<<32)-1);\n', '    }\n', '\n', '    // 10 ** (i * 8)\n', '    function powBig(uint32 i) internal pure returns (uint) {\n', '        uint y = 3402823669209384634633746076162356521930955161600000001;\n', '        return (y >> (64*i)) & ((1<<64)-1);\n', '    }\n', '\n', '    // if price32=( 0<<27)|12345678 then numerator=12345678 denominator=100000000000000000000000\n', '    // if price32=( 1<<27)|12345678 then numerator=12345678 denominator=10000000000000000000000\n', '    // if price32=( 2<<27)|12345678 then numerator=12345678 denominator=1000000000000000000000\n', '    // if price32=( 3<<27)|12345678 then numerator=12345678 denominator=100000000000000000000\n', '    // if price32=( 4<<27)|12345678 then numerator=12345678 denominator=10000000000000000000\n', '    // if price32=( 5<<27)|12345678 then numerator=12345678 denominator=1000000000000000000\n', '    // if price32=( 6<<27)|12345678 then numerator=12345678 denominator=100000000000000000\n', '    // if price32=( 7<<27)|12345678 then numerator=12345678 denominator=10000000000000000\n', '    // if price32=( 8<<27)|12345678 then numerator=12345678 denominator=1000000000000000\n', '    // if price32=( 9<<27)|12345678 then numerator=12345678 denominator=100000000000000\n', '    // if price32=(10<<27)|12345678 then numerator=12345678 denominator=10000000000000\n', '    // if price32=(11<<27)|12345678 then numerator=12345678 denominator=1000000000000\n', '    // if price32=(12<<27)|12345678 then numerator=12345678 denominator=100000000000\n', '    // if price32=(13<<27)|12345678 then numerator=12345678 denominator=10000000000\n', '    // if price32=(14<<27)|12345678 then numerator=12345678 denominator=1000000000\n', '    // if price32=(15<<27)|12345678 then numerator=12345678 denominator=100000000\n', '    // if price32=(16<<27)|12345678 then numerator=12345678 denominator=10000000\n', '    // if price32=(17<<27)|12345678 then numerator=12345678 denominator=1000000\n', '    // if price32=(18<<27)|12345678 then numerator=12345678 denominator=100000\n', '    // if price32=(19<<27)|12345678 then numerator=12345678 denominator=10000\n', '    // if price32=(20<<27)|12345678 then numerator=12345678 denominator=1000\n', '    // if price32=(21<<27)|12345678 then numerator=12345678 denominator=100\n', '    // if price32=(22<<27)|12345678 then numerator=12345678 denominator=10\n', '    // if price32=(23<<27)|12345678 then numerator=12345678 denominator=1\n', '    // if price32=(24<<27)|12345678 then numerator=123456780 denominator=1\n', '    // if price32=(25<<27)|12345678 then numerator=1234567800 denominator=1\n', '    // if price32=(26<<27)|12345678 then numerator=12345678000 denominator=1\n', '    // if price32=(27<<27)|12345678 then numerator=123456780000 denominator=1\n', '    // if price32=(28<<27)|12345678 then numerator=1234567800000 denominator=1\n', '    // if price32=(29<<27)|12345678 then numerator=12345678000000 denominator=1\n', '    // if price32=(30<<27)|12345678 then numerator=123456780000000 denominator=1\n', '    // if price32=(31<<27)|12345678 then numerator=1234567800000000 denominator=1\n', '    function expandPrice(uint32 price32) internal pure returns (RatPrice memory) {\n', '        uint s = price32&((1<<27)-1);\n', '        uint32 a = price32 >> 27;\n', '        RatPrice memory price;\n', '        if(a >= 24) {\n', '            uint32 b = a - 24;\n', '            price.numerator = s * powSmall(b);\n', '            price.denominator = 1;\n', '        } else if(a == 23) {\n', '            price.numerator = s;\n', '            price.denominator = 1;\n', '        } else {\n', '            uint32 b = 22 - a;\n', '            price.numerator = s;\n', '            price.denominator = powSmall(b&0x7) * powBig(b>>3);\n', '        }\n', '        return price;\n', '    }\n', '\n', '    function getExpandPrice(uint price) internal pure returns(uint numerator, uint denominator) {\n', '        uint32 m = uint32(price) & MANTISSA_MASK;\n', '        require(MIN_MANTISSA <= m && m <= MAX_MANTISSA, "Invalid Price");\n', '        RatPrice memory actualPrice = expandPrice(uint32(price));\n', '        return (actualPrice.numerator, actualPrice.denominator);\n', '    }\n', '\n', '}\n', '\n', 'library ProxyData {\n', '    uint public constant COUNT = 5;\n', '    uint public constant INDEX_FACTORY = 0;\n', '    uint public constant INDEX_MONEY_TOKEN = 1;\n', '    uint public constant INDEX_STOCK_TOKEN = 2;\n', '    uint public constant INDEX_GRA = 3;\n', '    uint public constant INDEX_OTHER = 4;\n', '    uint public constant OFFSET_PRICE_DIV = 0;\n', '    uint public constant OFFSET_PRICE_MUL = 64;\n', '    uint public constant OFFSET_STOCK_UNIT = 64+64;\n', '    uint public constant OFFSET_IS_ONLY_SWAP = 64+64+64;\n', '\n', '    function factory(uint[5] memory proxyData) internal pure returns (address) {\n', '         return address(proxyData[INDEX_FACTORY]);\n', '    }\n', '\n', '    function money(uint[5] memory proxyData) internal pure returns (address) {\n', '         return address(proxyData[INDEX_MONEY_TOKEN]);\n', '    }\n', '\n', '    function stock(uint[5] memory proxyData) internal pure returns (address) {\n', '         return address(proxyData[INDEX_STOCK_TOKEN]);\n', '    }\n', '\n', '    function graContract(uint[5] memory proxyData) internal pure returns (address) {\n', '         return address(proxyData[INDEX_GRA]);\n', '    }\n', '\n', '    function priceMul(uint[5] memory proxyData) internal pure returns (uint64) {\n', '        return uint64(proxyData[INDEX_OTHER]>>OFFSET_PRICE_MUL);\n', '    }\n', '\n', '    function priceDiv(uint[5] memory proxyData) internal pure returns (uint64) {\n', '        return uint64(proxyData[INDEX_OTHER]>>OFFSET_PRICE_DIV);\n', '    }\n', '\n', '    function stockUnit(uint[5] memory proxyData) internal pure returns (uint64) {\n', '        return uint64(proxyData[INDEX_OTHER]>>OFFSET_STOCK_UNIT);\n', '    }\n', '\n', '    function isOnlySwap(uint[5] memory proxyData) internal pure returns (bool) {\n', '        return uint8(proxyData[INDEX_OTHER]>>OFFSET_IS_ONLY_SWAP) != 0;\n', '    }\n', '\n', '    function fill(uint[5] memory proxyData, uint expectedCallDataSize) internal pure {\n', '        uint size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            size := calldatasize()\n', '        }\n', '        require(size == expectedCallDataSize, "INVALID_CALLDATASIZE");\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let offset := sub(size, 160)\n', '            calldatacopy(proxyData, offset, 160)\n', '        }\n', '    }\n', '}\n', '\n', 'interface IGraSwapFactory {\n', '    event PairCreated(address indexed pair, address stock, address money, bool isOnlySwap);\n', '\n', '    function createPair(address stock, address money, bool isOnlySwap) external returns (address pair);\n', '    function setFeeToAddresses(address _feeTo_1, address _feeTo_2, address _feeToPrivate) external;\n', '    function setFeeToSetter(address) external;\n', '    function setFeeBPS(uint32 bps) external;\n', '    function setPairLogic(address implLogic) external;\n', '\n', '    function allPairsLength() external view returns (uint);\n', '    function feeTo_1() external view returns (address);\n', '    function feeTo_2() external view returns (address);\n', '    function feeToPrivate() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function feeBPS() external view returns (uint32);\n', '    function pairLogic() external returns (address);\n', '    function getTokensFromPair(address pair) external view returns (address stock, address money);\n', '    function tokensToPair(address stock, address money, bool isOnlySwap) external view returns (address pair);\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'interface IGraSwapBlackList {\n', '    // event OwnerChanged(address);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event AddedBlackLists(address[]);\n', '    event RemovedBlackLists(address[]);\n', '\n', '    function owner()external view returns (address);\n', '    // function newOwner()external view returns (address);\n', '    function isBlackListed(address)external view returns (bool);\n', '\n', '    // function changeOwner(address ownerToSet) external;\n', '    // function updateOwner() external;\n', '    function transferOwnership(address newOwner) external;\n', '    function addBlackLists(address[] calldata  accounts)external;\n', '    function removeBlackLists(address[] calldata  accounts)external;\n', '}\n', '\n', 'interface IGraWhiteList {\n', '    event AppendWhiter(address adder);\n', '    event RemoveWhiter(address remover);\n', '    \n', '    function appendWhiter(address account) external;\n', '    function removeWhiter(address account) external;\n', '    function isWhiter(address account) external;\n', '    function isNotWhiter(address account) external;\n', '}\n', '\n', 'interface IGraSwapToken is IERC20, IGraSwapBlackList, IGraWhiteList{\n', '    function burn(uint256 amount) external;\n', '    function burnFrom(address account, uint256 amount) external;\n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n', '    // function multiTransfer(uint256[] calldata mixedAddrVal) external returns (bool);\n', '    function batchTransfer(address[] memory addressList, uint256[] memory amountList) external returns (bool);\n', '}\n', '\n', 'interface IGraSwapERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'interface IGraSwapPool {\n', '    // more liquidity was minted\n', '    event Mint(address indexed sender, uint stockAndMoneyAmount, address indexed to);\n', '    // liquidity was burned\n', '    event Burn(address indexed sender, uint stockAndMoneyAmount, address indexed to);\n', '    // amounts of reserved stock and money in this pair changed\n', '    event Sync(uint reserveStockAndMoney);\n', '\n', '    function internalStatus() external view returns(uint[3] memory res);\n', '    function getReserves() external view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID);\n', '    function getBooked() external view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID);\n', '    function stock() external returns (address);\n', '    function money() external returns (address);\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint stockAmount, uint moneyAmount);\n', '    function skim(address to) external;\n', '    function sync() external;\n', '}\n', '\n', 'interface IGraSwapPair {\n', '    event NewLimitOrder(uint data); // new limit order was sent by an account\n', '    event NewMarketOrder(uint data); // new market order was sent by an account\n', '    event OrderChanged(uint data); // old orders in orderbook changed\n', '    event DealWithPool(uint data); // new order deal with the AMM pool\n', '    event RemoveOrder(uint data); // an order was removed from the orderbook\n', '    \n', '    // Return three prices in rational number form, i.e., numerator/denominator.\n', "    // They are: the first sell order's price; the first buy order's price; the current price of the AMM pool.\n", '    function getPrices() external returns (\n', '        uint firstSellPriceNumerator,\n', '        uint firstSellPriceDenominator,\n', '        uint firstBuyPriceNumerator,\n', '        uint firstBuyPriceDenominator,\n', '        uint poolPriceNumerator,\n', '        uint poolPriceDenominator);\n', '\n', "    // This function queries a list of orders in orderbook. It starts from 'id' and iterates the single-linked list, util it reaches the end, \n", "    // or until it has found 'maxCount' orders. If 'id' is 0, it starts from the beginning of the single-linked list.\n", "    // It may cost a lot of gas. So you'd not to call in on chain. It is mainly for off-chain query.\n", "    // The first uint256 returned by this function is special: the lowest 24 bits is the first order's id and the the higher bits is block height.\n", '    // THe other uint256s are all corresponding to an order record of the single-linked list.\n', '    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external view returns (uint[] memory);\n', '\n', '    // remove an order from orderbook and return its booked (i.e. frozen) money to maker\n', "    // 'id' points to the order to be removed\n", '    // prevKey points to 3 previous orders in the single-linked list\n', '    function removeOrder(bool isBuy, uint32 id, uint72 positionID) external;\n', '\n', '    function removeOrders(uint[] calldata rmList) external;\n', '\n', '    // Try to deal a new limit order or insert it into orderbook\n', "    // its suggested order id is 'id' and suggested positions are in 'prevKey'\n", '    // prevKey points to 3 existing orders in the single-linked list\n', "    // the order's sender is 'sender'. the order's amount is amount*stockUnit, which is the stock amount to be sold or bought.\n", "    // the order's price is 'price32', which is decimal floating point value.\n", '    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32, uint32 id, uint72 prevKey) external payable;\n', '\n', "    // Try to deal a new market order. 'sender' pays 'inAmount' of 'inputToken', in exchange of the other token kept by this pair\n", '    function addMarketOrder(address inputToken, address sender, uint112 inAmount) external payable returns (uint);\n', '\n', "    // Given the 'amount' of stock and decimal floating point price 'price32', calculate the 'stockAmount' and 'moneyAmount' to be traded\n", '    function calcStockAndMoney(uint64 amount, uint32 price32) external pure returns (uint stockAmount, uint moneyAmount);\n', '}\n', '\n', 'abstract contract GraSwapERC20 is IGraSwapERC20 {\n', '    using SafeMath256 for uint;\n', '\n', '    uint internal _unusedVar0;\n', '    uint internal _unusedVar1;\n', '    uint internal _unusedVar2;\n', '    uint internal _unusedVar3;\n', '    uint internal _unusedVar4;\n', '    uint internal _unusedVar5;\n', '    uint internal _unusedVar6;\n', '    uint internal _unusedVar7;\n', '    uint internal _unusedVar8;\n', '    uint internal _unusedVar9;\n', '    uint internal _unlocked = 1;\n', '\n', '    modifier lock() {\n', '        require(_unlocked == 1, "GraSwap: LOCKED");\n', '        _unlocked = 0;\n', '        _;\n', '        _unlocked = 1;\n', '    }\n', '\n', '    string private constant _NAME = "GraSwap-Share";\n', '    uint8 private constant _DECIMALS = 18;\n', '    uint  public override totalSupply;\n', '    mapping(address => uint) public override balanceOf;\n', '    mapping(address => mapping(address => uint)) public override allowance;\n', '\n', '    function symbol() virtual external override returns (string memory);\n', '\n', '    function name() external view override returns (string memory) {\n', '        return _NAME;\n', '    }\n', '\n', '    function decimals() external view override returns (uint8) {\n', '        return _DECIMALS;\n', '    }\n', '\n', '    function _mint(address to, uint value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint value) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint value) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value) external override returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint value) external override returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value) external override returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(- 1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '}\n', '\n', '// An order can be compressed into 256 bits and saved using one SSTORE instruction\n', '// The orders form a single-linked list. The preceding order points to the following order with nextID\n', 'struct Order { //total 256 bits\n', '    address sender; //160 bits, sender creates this order\n', '    uint32 price; // 32-bit decimal floating point number\n', '    uint64 amount; // 42 bits are used, the stock amount to be sold or bought\n', '    uint32 nextID; // 22 bits are used\n', '}\n', '\n', '// When the match engine of orderbook runs, it uses follow context to cache data in memory\n', 'struct Context {\n', '    // this order is a limit order\n', '    bool isLimitOrder;\n', "    // the new order's id, it is only used when a limit order is not fully dealt\n", '    uint32 newOrderID;\n', "    // for buy-order, it's remained money amount; for sell-order, it's remained stock amount\n", '    uint remainAmount;\n', '    // it points to the first order in the opposite order book against current order\n', '    uint32 firstID;\n', '    // it points to the first order in the buy-order book\n', '    uint32 firstBuyID;\n', '    // it points to the first order in the sell-order book\n', '    uint32 firstSellID;\n', "    // the amount goes into the pool, for buy-order, it's money amount; for sell-order, it's stock amount\n", '    uint amountIntoPool;\n', '    // the total dealt money and stock in the order book\n', '    uint dealMoneyInBook;\n', '    uint dealStockInBook;\n', '    // cache these values from storage to memory\n', '    uint reserveMoney;\n', '    uint reserveStock;\n', '    uint bookedMoney;\n', '    uint bookedStock;\n', '    // reserveMoney or reserveStock is changed\n', '    bool reserveChanged;\n', '    // the taker has dealt in the orderbook\n', '    bool hasDealtInOrderBook;\n', '    // the current taker order\n', '    Order order;\n', '    // the following data come from proxy\n', '    uint64 stockUnit;\n', '    uint64 priceMul;\n', '    uint64 priceDiv;\n', '    address stockToken;\n', '    address moneyToken;\n', '    address graContract;\n', '    address factory;\n', '}\n', '\n', '// GraSwapPair combines a Uniswap-like AMM and an orderbook\n', 'abstract contract GraSwapPool is GraSwapERC20, IGraSwapPool {\n', '    using SafeMath256 for uint;\n', '\n', '    uint private constant _MINIMUM_LIQUIDITY = 10 ** 3;\n', '    bytes4 internal constant _SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));\n', '\n', '    // reserveMoney and reserveStock are both uint112, id is 22 bits; they are compressed into a uint256 word\n', '    uint internal _reserveStockAndMoneyAndFirstSellID;\n', '    // bookedMoney and bookedStock are both uint112, id is 22 bits; they are compressed into a uint256 word\n', '    uint internal _bookedStockAndMoneyAndFirstBuyID;\n', '\n', '    uint private _kLast;\n', '\n', "    uint32 private constant _OS = 2; // owner's share\n", "    uint32 private constant _LS = 3; // liquidity-provider's share\n", '\n', '    function internalStatus() external override view returns(uint[3] memory res) {\n', '        res[0] = _reserveStockAndMoneyAndFirstSellID;\n', '        res[1] = _bookedStockAndMoneyAndFirstBuyID;\n', '        res[2] = _kLast;\n', '    }\n', '\n', '    function stock() external override returns (address) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\n', '        return ProxyData.stock(proxyData);\n', '    }\n', '\n', '    function money() external override returns (address) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\n', '        return ProxyData.money(proxyData);\n', '    }\n', '\n', '    // the following 4 functions load&store compressed storage\n', '    function getReserves() public override view returns (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) {\n', '        uint temp = _reserveStockAndMoneyAndFirstSellID;\n', '        reserveStock = uint112(temp);\n', '        reserveMoney = uint112(temp>>112);\n', '        firstSellID = uint32(temp>>224);\n', '    }\n', '    function _setReserves(uint stockAmount, uint moneyAmount, uint32 firstSellID) internal {\n', '        require(stockAmount < uint(1<<112) && moneyAmount < uint(1<<112), "GraSwap: OVERFLOW");\n', '        uint temp = (moneyAmount<<112)|stockAmount;\n', '        emit Sync(temp);\n', '        temp = (uint(firstSellID)<<224)| temp;\n', '        _reserveStockAndMoneyAndFirstSellID = temp;\n', '    }\n', '    function getBooked() public override view returns (uint112 bookedStock, uint112 bookedMoney, uint32 firstBuyID) {\n', '        uint temp = _bookedStockAndMoneyAndFirstBuyID;\n', '        bookedStock = uint112(temp);\n', '        bookedMoney = uint112(temp>>112);\n', '        firstBuyID = uint32(temp>>224);\n', '    }\n', '    function _setBooked(uint stockAmount, uint moneyAmount, uint32 firstBuyID) internal {\n', '        require(stockAmount < uint(1<<112) && moneyAmount < uint(1<<112), "GraSwap: OVERFLOW");\n', '        _bookedStockAndMoneyAndFirstBuyID = (uint(firstBuyID)<<224)|(moneyAmount<<112)|stockAmount;\n', '    }\n', '\n', '    function _myBalance(address token) internal view returns (uint) {\n', '        if(token==address(0)) {\n', '            return address(this).balance;\n', '        } else {\n', '            return IERC20(token).balanceOf(address(this));\n', '        }\n', '    }\n', '\n', '    // safely transfer ERC20 tokens, or ETH (when token==0)\n', '    function _safeTransfer(address token, address to, uint value, address graContract) internal {\n', '        if(value==0) {return;}\n', '        if(token==address(0)) {\n', '            // limit gas to 9000 to prevent gastoken attacks\n', '            // solhint-disable-next-line avoid-low-level-calls \n', '            to.call{value: value, gas: 9000}(new bytes(0)); //we ignore its return value purposely\n', '            return;\n', '        }\n', '        // solhint-disable-next-line avoid-low-level-calls \n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(_SELECTOR, to, value));\n', '        success = success && (data.length == 0 || abi.decode(data, (bool)));\n', '        if(!success) { // for failsafe\n', '            address graContractOwner = IGraSwapToken(graContract).owner();\n', '            // solhint-disable-next-line avoid-low-level-calls \n', '            (success, data) = token.call(abi.encodeWithSelector(_SELECTOR, graContractOwner, value));\n', '            require(success && (data.length == 0 || abi.decode(data, (bool))), "GraSwap: TRANSFER_FAILED");\n', '        }\n', '    }\n', '\n', '    // Give feeToAddresses some liquidity tokens if K got increased since last liquidity-changing\n', '    function _mintFee(uint112 _reserve0, uint112 _reserve1, uint[5] memory proxyData) private returns (bool feeOn) {\n', '        address feeTo_1 = IGraSwapFactory(ProxyData.factory(proxyData)).feeTo_1();\n', '        address feeTo_2 = IGraSwapFactory(ProxyData.factory(proxyData)).feeTo_2();\n', '        address feeToPrivate = IGraSwapFactory(ProxyData.factory(proxyData)).feeToPrivate();\n', '        feeOn = (feeTo_1 != address(0) && feeTo_2 != address(0) && feeToPrivate != address(0));\n', '        uint kLast = _kLast;\n', '        // gas savings to use cached kLast\n', '        if (feeOn) {\n', '            if (kLast != 0) {\n', '                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n', '                uint rootKLast = Math.sqrt(kLast);\n', '                if (rootK > rootKLast) {\n', '                    uint numerator = totalSupply.mul(rootK.sub(rootKLast)).mul(_OS);\n', '                    uint denominator = rootK.mul(_LS).add(rootKLast.mul(_OS));\n', '                    uint liquidity = numerator / denominator;\n', '                    if (liquidity > 0) {\n', '                        uint liquidity_p1 = liquidity.div(4); // 10%  \n', '                        uint liquidity_p2 = liquidity.div(8); // 5%\n', '                        uint liquidity_p3 = liquidity.mul(5).div(8); // 25%\n', '                        if (liquidity_p1 > 0) {\n', '                            _mint(feeTo_1, liquidity_p1);\n', '                        }\n', '                        if (liquidity_p2 > 0) {\n', '                            _mint(feeTo_2, liquidity_p2);\n', '                        }\n', '                        if (liquidity_p2 > 0) {\n', '                            _mint(feeToPrivate, liquidity_p3);\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '        } else if (kLast != 0) {\n', '            _kLast = 0;\n', '        }\n', '    }\n', '\n', "    // mint new liquidity tokens to 'to'\n", '    function mint(address to) external override lock returns (uint liquidity) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\n', '        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\n', '        (uint112 bookedStock, uint112 bookedMoney, ) = getBooked();\n', '        uint stockBalance = _myBalance(ProxyData.stock(proxyData));\n', '        uint moneyBalance = _myBalance(ProxyData.money(proxyData));\n', '        require(stockBalance >= uint(bookedStock) + uint(reserveStock) &&\n', '                moneyBalance >= uint(bookedMoney) + uint(reserveMoney), "GraSwap: INVALID_BALANCE");\n', '        stockBalance -= uint(bookedStock);\n', '        moneyBalance -= uint(bookedMoney);\n', '        uint stockAmount = stockBalance - uint(reserveStock);\n', '        uint moneyAmount = moneyBalance - uint(reserveMoney);\n', '\n', '        bool feeOn = _mintFee(reserveStock, reserveMoney, proxyData);\n', '        uint _totalSupply = totalSupply;\n', '        // gas savings by caching totalSupply in memory,\n', '        // must be defined here since totalSupply can update in _mintFee\n', '        if (_totalSupply == 0) {\n', '            liquidity = Math.sqrt(stockAmount.mul(moneyAmount)).sub(_MINIMUM_LIQUIDITY);\n', '            _mint(address(0), _MINIMUM_LIQUIDITY);\n', '            // permanently lock the first _MINIMUM_LIQUIDITY tokens\n', '        } else {\n', '            liquidity = Math.min(stockAmount.mul(_totalSupply) / uint(reserveStock),\n', '                                 moneyAmount.mul(_totalSupply) / uint(reserveMoney));\n', '        }\n', '        require(liquidity > 0, "GraSwap: INSUFFICIENT_MINTED");\n', '        _mint(to, liquidity);\n', '\n', '        _setReserves(stockBalance, moneyBalance, firstSellID);\n', '        if (feeOn) _kLast = stockBalance.mul(moneyBalance);\n', '        emit Mint(msg.sender, (moneyAmount<<112)|stockAmount, to);\n', '    }\n', '\n', "    // burn liquidity tokens and send stock&money to 'to'\n", '    function burn(address to) external override lock returns (uint stockAmount, uint moneyAmount) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\n', '        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\n', '        (uint bookedStock, uint bookedMoney, ) = getBooked();\n', '        uint stockBalance = _myBalance(ProxyData.stock(proxyData)).sub(bookedStock);\n', '        uint moneyBalance = _myBalance(ProxyData.money(proxyData)).sub(bookedMoney);\n', '        require(stockBalance >= uint(reserveStock) && moneyBalance >= uint(reserveMoney), "GraSwap: INVALID_BALANCE");\n', '\n', '        bool feeOn = _mintFee(reserveStock, reserveMoney, proxyData);\n', '        {\n', '            uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n', "            uint liquidity = balanceOf[address(this)]; // we're sure liquidity < totalSupply\n", '            stockAmount = liquidity.mul(stockBalance) / _totalSupply;\n', '            moneyAmount = liquidity.mul(moneyBalance) / _totalSupply;\n', '            require(stockAmount > 0 && moneyAmount > 0, "GraSwap: INSUFFICIENT_BURNED");\n', '\n', '            //_burn(address(this), liquidity);\n', '            balanceOf[address(this)] = 0;\n', '            totalSupply = totalSupply.sub(liquidity);\n', '            emit Transfer(address(this), address(0), liquidity);\n', '        }\n', '\n', '        address graContract = ProxyData.graContract(proxyData);\n', '        _safeTransfer(ProxyData.stock(proxyData), to, stockAmount, graContract);\n', '        _safeTransfer(ProxyData.money(proxyData), to, moneyAmount, graContract);\n', '\n', '        stockBalance = stockBalance - stockAmount;\n', '        moneyBalance = moneyBalance - moneyAmount;\n', '\n', '        _setReserves(stockBalance, moneyBalance, firstSellID);\n', '        if (feeOn) _kLast = stockBalance.mul(moneyBalance);\n', '        emit Burn(msg.sender, (moneyAmount<<112)|stockAmount, to);\n', '    }\n', '\n', "    // take the extra money&stock in this pair to 'to'\n", '    function skim(address to) external override lock {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+1));\n', '        address stockToken = ProxyData.stock(proxyData);\n', '        address moneyToken = ProxyData.money(proxyData);\n', '        (uint112 reserveStock, uint112 reserveMoney, ) = getReserves();\n', '        (uint bookedStock, uint bookedMoney, ) = getBooked();\n', '        uint balanceStock = _myBalance(stockToken);\n', '        uint balanceMoney = _myBalance(moneyToken);\n', '        require(balanceStock >= uint(bookedStock) + uint(reserveStock) &&\n', '                balanceMoney >= uint(bookedMoney) + uint(reserveMoney), "GraSwap: INVALID_BALANCE");\n', '        address graContract = ProxyData.graContract(proxyData);\n', '        _safeTransfer(stockToken, to, balanceStock-reserveStock-bookedStock, graContract);\n', '        _safeTransfer(moneyToken, to, balanceMoney-reserveMoney-bookedMoney, graContract);\n', '    }\n', '\n', '    // sync-up reserve stock&money in pool according to real balance\n', '    function sync() external override lock {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\n', '        (, , uint32 firstSellID) = getReserves();\n', '        (uint bookedStock, uint bookedMoney, ) = getBooked();\n', '        uint balanceStock = _myBalance(ProxyData.stock(proxyData));\n', '        uint balanceMoney = _myBalance(ProxyData.money(proxyData));\n', '        require(balanceStock >= bookedStock && balanceMoney >= bookedMoney, "GraSwap: INVALID_BALANCE");\n', '        _setReserves(balanceStock-bookedStock, balanceMoney-bookedMoney, firstSellID);\n', '    }\n', '\n', '}\n', '\n', 'contract GraSwapPair is GraSwapPool, IGraSwapPair {\n', '    // the orderbooks. Gas is saved when using array to store them instead of mapping\n', '    uint[1<<22] private _sellOrders;\n', '    uint[1<<22] private _buyOrders;\n', '\n', '    uint32 private constant _MAX_ID = (1<<22)-1; // the maximum value of an order ID\n', '\n', '    function _expandPrice(uint32 price32, uint[5] memory proxyData) private pure returns (RatPrice memory price) {\n', '        price = DecFloat32.expandPrice(price32);\n', '        price.numerator *= ProxyData.priceMul(proxyData);\n', '        price.denominator *= ProxyData.priceDiv(proxyData);\n', '    }\n', '\n', '    function _expandPrice(Context memory ctx, uint32 price32) private pure returns (RatPrice memory price) {\n', '        price = DecFloat32.expandPrice(price32);\n', '        price.numerator *= ctx.priceMul;\n', '        price.denominator *= ctx.priceDiv;\n', '    }\n', '\n', '    function symbol() external override returns (string memory) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\n', '        string memory s = "ETH";\n', '        address stock = ProxyData.stock(proxyData);\n', '        if(stock != address(0)) {\n', '            s = IERC20(stock).symbol();\n', '        }\n', '        string memory m = "ETH";\n', '        address money = ProxyData.money(proxyData);\n', '        if(money != address(0)) {\n', '            m = IERC20(money).symbol();\n', '        }\n', '        return string(abi.encodePacked(s, "/", m));  //to concat strings\n', '    }\n', '\n', "    // when emitting events, solidity's ABI pads each entry to uint256, which is so wasteful\n", '    // we compress the entries into one uint256 to save gas\n', '    function _emitNewLimitOrder(\n', '        uint64 addressLow, /*255~192*/\n', '        uint64 totalStockAmount, /*191~128*/\n', '        uint64 remainedStockAmount, /*127~64*/\n', '        uint32 price, /*63~32*/\n', '        uint32 orderID, /*31~8*/\n', '        bool isBuy /*7~0*/) private {\n', '        uint data = uint(addressLow);\n', '        data = (data<<64) | uint(totalStockAmount);\n', '        data = (data<<64) | uint(remainedStockAmount);\n', '        data = (data<<32) | uint(price);\n', '        data = (data<<32) | uint(orderID<<8);\n', '        if(isBuy) {\n', '            data = data | 1;\n', '        }\n', '        emit NewLimitOrder(data);\n', '    }\n', '    function _emitNewMarketOrder(\n', '        uint136 addressLow, /*255~120*/\n', '        uint112 amount, /*119~8*/\n', '        bool isBuy /*7~0*/) private {\n', '        uint data = uint(addressLow);\n', '        data = (data<<112) | uint(amount);\n', '        data = data<<8;\n', '        if(isBuy) {\n', '            data = data | 1;\n', '        }\n', '        emit NewMarketOrder(data);\n', '    }\n', '    function _emitOrderChanged(\n', '        uint64 makerLastAmount, /*159~96*/\n', '        uint64 makerDealAmount, /*95~32*/\n', '        uint32 makerOrderID, /*31~8*/\n', '        bool isBuy /*7~0*/) private {\n', '        uint data = uint(makerLastAmount);\n', '        data = (data<<64) | uint(makerDealAmount);\n', '        data = (data<<32) | uint(makerOrderID<<8);\n', '        if(isBuy) {\n', '            data = data | 1;\n', '        }\n', '        emit OrderChanged(data);\n', '    }\n', '    function _emitDealWithPool(\n', '        uint112 inAmount, /*131~120*/\n', '        uint112 outAmount,/*119~8*/\n', '        bool isBuy/*7~0*/) private {\n', '        uint data = uint(inAmount);\n', '        data = (data<<112) | uint(outAmount);\n', '        data = data<<8;\n', '        if(isBuy) {\n', '            data = data | 1;\n', '        }\n', '        emit DealWithPool(data);\n', '    }\n', '    function _emitRemoveOrder(\n', '        uint64 remainStockAmount, /*95~32*/\n', '        uint32 orderID, /*31~8*/\n', '        bool isBuy /*7~0*/) private {\n', '        uint data = uint(remainStockAmount);\n', '        data = (data<<32) | uint(orderID<<8);\n', '        if(isBuy) {\n', '            data = data | 1;\n', '        }\n', '        emit RemoveOrder(data);\n', '    }\n', '\n', '    // compress an order into a 256b integer\n', '    function _order2uint(Order memory order) internal pure returns (uint) {\n', '        uint n = uint(order.sender);\n', '        n = (n<<32) | order.price;\n', '        n = (n<<42) | order.amount;\n', '        n = (n<<22) | order.nextID;\n', '        return n;\n', '    }\n', '\n', '    // extract an order from a 256b integer\n', '    function _uint2order(uint n) internal pure returns (Order memory) {\n', '        Order memory order;\n', '        order.nextID = uint32(n & ((1<<22)-1));\n', '        n = n >> 22;\n', '        order.amount = uint64(n & ((1<<42)-1));\n', '        n = n >> 42;\n', '        order.price = uint32(n & ((1<<32)-1));\n', '        n = n >> 32;\n', '        order.sender = address(n);\n', '        return order;\n', '    }\n', '\n', '    // returns true if this order exists\n', '    function _hasOrder(bool isBuy, uint32 id) internal view returns (bool) {\n', '        if(isBuy) {\n', '            return _buyOrders[id] != 0;\n', '        } else {\n', '            return _sellOrders[id] != 0;\n', '        }\n', '    }\n', '\n', '    // load an order from storage, converting its compressed form into an Order struct\n', '    function _getOrder(bool isBuy, uint32 id) internal view returns (Order memory order, bool findIt) {\n', '        if(isBuy) {\n', '            order = _uint2order(_buyOrders[id]);\n', '            return (order, order.price != 0);\n', '        } else {\n', '            order = _uint2order(_sellOrders[id]);\n', '            return (order, order.price != 0);\n', '        }\n', '    }\n', '\n', '    // save an order to storage, converting it into compressed form\n', '    function _setOrder(bool isBuy, uint32 id, Order memory order) internal {\n', '        if(isBuy) {\n', '            _buyOrders[id] = _order2uint(order);\n', '        } else {\n', '            _sellOrders[id] = _order2uint(order);\n', '        }\n', '    }\n', '\n', '    // delete an order from storage\n', '    function _deleteOrder(bool isBuy, uint32 id) internal {\n', '        if(isBuy) {\n', '            delete _buyOrders[id];\n', '        } else {\n', '            delete _sellOrders[id];\n', '        }\n', '    }\n', '\n', '    function _getFirstOrderID(Context memory ctx, bool isBuy) internal pure returns (uint32) {\n', '        if(isBuy) {\n', '            return ctx.firstBuyID;\n', '        }\n', '        return ctx.firstSellID;\n', '    }\n', '\n', '    function _setFirstOrderID(Context memory ctx, bool isBuy, uint32 id) internal pure {\n', '        if(isBuy) {\n', '            ctx.firstBuyID = id;\n', '        } else {\n', '            ctx.firstSellID = id;\n', '        }\n', '    }\n', '\n', '    function removeOrders(uint[] calldata rmList) external override lock {\n', '        uint[5] memory proxyData;\n', '        uint expectedCallDataSize = 4+32*(ProxyData.COUNT+2+rmList.length);\n', '        ProxyData.fill(proxyData, expectedCallDataSize);\n', '        for(uint i = 0; i < rmList.length; i++) {\n', '            uint rmInfo = rmList[i];\n', '            bool isBuy = uint8(rmInfo) != 0;\n', '            uint32 id = uint32(rmInfo>>8);\n', '            uint72 prevKey = uint72(rmInfo>>40);\n', '            _removeOrder(isBuy, id, prevKey, proxyData);\n', '        }\n', '    }\n', '\n', '    function removeOrder(bool isBuy, uint32 id, uint72 prevKey) external override lock {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+3));\n', '        _removeOrder(isBuy, id, prevKey, proxyData);\n', '    }\n', '\n', '    function _removeOrder(bool isBuy, uint32 id, uint72 prevKey, uint[5] memory proxyData) private {\n', '        Context memory ctx;\n', '        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\n', '        if(!isBuy) {\n', '            (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\n', '        }\n', '        Order memory order = _removeOrderFromBook(ctx, isBuy, id, prevKey); // this is the removed order\n', '        require(msg.sender == order.sender, "GraSwap: NOT_OWNER");\n', '        uint64 stockUnit = ProxyData.stockUnit(proxyData);\n', '        uint stockAmount = uint(order.amount)/*42bits*/ * uint(stockUnit);\n', '        address graContract = ProxyData.graContract(proxyData);\n', '        if(isBuy) {\n', '            RatPrice memory price = _expandPrice(order.price, proxyData);\n', '            uint moneyAmount = stockAmount * price.numerator/*54+64bits*/ / price.denominator;\n', '            ctx.bookedMoney -= moneyAmount;\n', '            _safeTransfer(ProxyData.money(proxyData), order.sender, moneyAmount, graContract);\n', '        } else {\n', '            ctx.bookedStock -= stockAmount;\n', '            _safeTransfer(ProxyData.stock(proxyData), order.sender, stockAmount, graContract);\n', '        }\n', '        _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\n', '    }\n', '\n', '    // remove an order from orderbook and return it\n', '    function _removeOrderFromBook(Context memory ctx, bool isBuy,\n', '                                 uint32 id, uint72 prevKey) internal returns (Order memory) {\n', '        (Order memory order, bool ok) = _getOrder(isBuy, id);\n', '        require(ok, "GraSwap: NO_SUCH_ORDER");\n', '        if(prevKey == 0) {\n', '            uint32 firstID = _getFirstOrderID(ctx, isBuy);\n', '            require(id == firstID, "GraSwap: NOT_FIRST");\n', '            _setFirstOrderID(ctx, isBuy, order.nextID);\n', '            if(!isBuy) {\n', '                _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\n', '            }\n', '        } else {\n', '            (uint32 currID, Order memory prevOrder, bool findIt) = _getOrder3Times(isBuy, prevKey);\n', '            require(findIt, "GraSwap: INVALID_POSITION");\n', '            while(prevOrder.nextID != id) {\n', '                currID = prevOrder.nextID;\n', '                require(currID != 0, "GraSwap: REACH_END");\n', '                (prevOrder, ) = _getOrder(isBuy, currID);\n', '            }\n', '            prevOrder.nextID = order.nextID;\n', '            _setOrder(isBuy, currID, prevOrder);\n', '        }\n', '        _emitRemoveOrder(order.amount, id, isBuy);\n', '        _deleteOrder(isBuy, id);\n', '        return order;\n', '    }\n', '\n', '    // insert an order at the head of single-linked list\n', '    // this function does not check price, use it carefully\n', '    function _insertOrderAtHead(Context memory ctx, bool isBuy, Order memory order, uint32 id) private {\n', '        order.nextID = _getFirstOrderID(ctx, isBuy);\n', '        _setOrder(isBuy, id, order);\n', '        _setFirstOrderID(ctx, isBuy, id);\n', '    }\n', '\n', '    // prevKey contains 3 orders. try to get the first existing order\n', '    function _getOrder3Times(bool isBuy, uint72 prevKey) private view returns (\n', '        uint32 currID, Order memory prevOrder, bool findIt) {\n', '        currID = uint32(prevKey&_MAX_ID);\n', '        (prevOrder, findIt) = _getOrder(isBuy, currID);\n', '        if(!findIt) {\n', '            currID = uint32((prevKey>>24)&_MAX_ID);\n', '            (prevOrder, findIt) = _getOrder(isBuy, currID);\n', '            if(!findIt) {\n', '                currID = uint32((prevKey>>48)&_MAX_ID);\n', '                (prevOrder, findIt) = _getOrder(isBuy, currID);\n', '            }\n', '        }\n', '    }\n', '\n', '    // Given a valid start position, find a proper position to insert order\n', '    // prevKey contains three suggested order IDs, each takes 24 bits.\n', '    // We try them one by one to find a valid start position\n', '    // can not use this function to insert at head! if prevKey is all zero, it will return false\n', '    function _insertOrderFromGivenPos(bool isBuy, Order memory order,\n', '                                     uint32 id, uint72 prevKey) private returns (bool inserted) {\n', '        (uint32 currID, Order memory prevOrder, bool findIt) = _getOrder3Times(isBuy, prevKey);\n', '        if(!findIt) {\n', '            return false;\n', '        }\n', '        return _insertOrder(isBuy, order, prevOrder, id, currID);\n', '    }\n', '    \n', '    // Starting from the head of orderbook, find a proper position to insert order\n', '    function _insertOrderFromHead(Context memory ctx, bool isBuy, Order memory order,\n', '                                 uint32 id) private returns (bool inserted) {\n', '        uint32 firstID = _getFirstOrderID(ctx, isBuy);\n', '        bool canBeFirst = (firstID == 0);\n', '        Order memory firstOrder;\n', '        if(!canBeFirst) {\n', '            (firstOrder, ) = _getOrder(isBuy, firstID);\n', '            canBeFirst = (isBuy && (firstOrder.price < order.price)) ||\n', '                (!isBuy && (firstOrder.price > order.price));\n', '        }\n', '        if(canBeFirst) {\n', '            order.nextID = firstID;\n', '            _setOrder(isBuy, id, order);\n', '            _setFirstOrderID(ctx, isBuy, id);\n', '            return true;\n', '        }\n', '        return _insertOrder(isBuy, order, firstOrder, id, firstID);\n', '    }\n', '\n', "    // starting from 'prevOrder', whose id is 'currID', find a proper position to insert order\n", '    function _insertOrder(bool isBuy, Order memory order, Order memory prevOrder,\n', '                         uint32 id, uint32 currID) private returns (bool inserted) {\n', '        while(currID != 0) {\n', '            bool canFollow = (isBuy && (order.price <= prevOrder.price)) ||\n', '                (!isBuy && (order.price >= prevOrder.price));\n', '            if(!canFollow) {break;} \n', '            Order memory nextOrder;\n', '            if(prevOrder.nextID != 0) {\n', '                (nextOrder, ) = _getOrder(isBuy, prevOrder.nextID);\n', '                bool canPrecede = (isBuy && (nextOrder.price < order.price)) ||\n', '                    (!isBuy && (nextOrder.price > order.price));\n', '                canFollow = canFollow && canPrecede;\n', '            }\n', '            if(canFollow) {\n', '                order.nextID = prevOrder.nextID;\n', '                _setOrder(isBuy, id, order);\n', '                prevOrder.nextID = id;\n', '                _setOrder(isBuy, currID, prevOrder);\n', '                return true;\n', '            }\n', '            currID = prevOrder.nextID;\n', '            prevOrder = nextOrder;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // to query the first sell price, the first buy price and the price of pool\n', '    function getPrices() external override returns (\n', '        uint firstSellPriceNumerator,\n', '        uint firstSellPriceDenominator,\n', '        uint firstBuyPriceNumerator,\n', '        uint firstBuyPriceDenominator,\n', '        uint poolPriceNumerator,\n', '        uint poolPriceDenominator) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+0));\n', '        (uint112 reserveStock, uint112 reserveMoney, uint32 firstSellID) = getReserves();\n', '        poolPriceNumerator = uint(reserveMoney);\n', '        poolPriceDenominator = uint(reserveStock);\n', '        firstSellPriceNumerator = 0;\n', '        firstSellPriceDenominator = 0;\n', '        firstBuyPriceNumerator = 0;\n', '        firstBuyPriceDenominator = 0;\n', '        if(firstSellID!=0) {\n', '            uint order = _sellOrders[firstSellID];\n', '            RatPrice memory price = _expandPrice(uint32(order>>64), proxyData);\n', '            firstSellPriceNumerator = price.numerator;\n', '            firstSellPriceDenominator = price.denominator;\n', '        }\n', '        uint32 id = uint32(_bookedStockAndMoneyAndFirstBuyID>>224);\n', '        if(id!=0) {\n', '            uint order = _buyOrders[id];\n', '            RatPrice memory price = _expandPrice(uint32(order>>64), proxyData);\n', '            firstBuyPriceNumerator = price.numerator;\n', '            firstBuyPriceDenominator = price.denominator;\n', '        }\n', '    }\n', '\n', "    // Get the orderbook's content, starting from id, to get no more than maxCount orders\n", '    function getOrderList(bool isBuy, uint32 id, uint32 maxCount) external override view returns (uint[] memory) {\n', '        if(id == 0) {\n', '            if(isBuy) {\n', '                id = uint32(_bookedStockAndMoneyAndFirstBuyID>>224);\n', '            } else {\n', '                id = uint32(_reserveStockAndMoneyAndFirstSellID>>224);\n', '            }\n', '        }\n', '        uint[1<<22] storage orderbook;\n', '        if(isBuy) {\n', '            orderbook = _buyOrders;\n', '        } else {\n', '            orderbook = _sellOrders;\n', '        }\n', '        //record block height at the first entry\n', '        uint order = (block.number<<24) | id;\n', '        uint addrOrig; // start of returned data\n', "        uint addrLen; // the slice's length is written at this address\n", '        uint addrStart; // the address of the first entry of returned slice\n', '        uint addrEnd; // ending address to write the next order\n', "        uint count = 0; // the slice's length\n", '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            addrOrig := mload(0x40) // There is a free memory pointer at address 0x40 in memory\n', '            mstore(addrOrig, 32) //the meaningful data start after offset 32\n', '        }\n', '        addrLen = addrOrig + 32;\n', '        addrStart = addrLen + 32;\n', '        addrEnd = addrStart;\n', '        while(count < maxCount) {\n', '            // solhint-disable-next-line no-inline-assembly\n', '            assembly {\n', '                mstore(addrEnd, order) //write the order\n', '            }\n', '            addrEnd += 32;\n', '            count++;\n', '            if(id == 0) {break;}\n', '            order = orderbook[id];\n', '            require(order!=0, "GraSwap: INCONSISTENT_BOOK");\n', '            id = uint32(order&_MAX_ID);\n', '        }\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', "            mstore(addrLen, count) // record the returned slice's length\n", '            let byteCount := sub(addrEnd, addrOrig)\n', '            return(addrOrig, byteCount)\n', '        }\n', '    }\n', '\n', '    // Get an unused id to be used with new order\n', '    function _getUnusedOrderID(bool isBuy, uint32 id) internal view returns (uint32) {\n', '        if(id == 0) { // 0 is reserved\n', '            // solhint-disable-next-line avoid-tx-origin\n', '            id = uint32(uint(blockhash(block.number-1))^uint(tx.origin)) & _MAX_ID; //get a pseudo random number\n', '        }\n', '        for(uint32 i = 0; i < 100 && id <= _MAX_ID; i++) { //try 100 times\n', '            if(!_hasOrder(isBuy, id)) {\n', '                return id;\n', '            }\n', '            id++;\n', '        }\n', '        require(false, "GraSwap: CANNOT_FIND_VALID_ID");\n', '        return 0;\n', '    }\n', '\n', '    function calcStockAndMoney(uint64 amount, uint32 price32) external pure override returns (uint stockAmount, uint moneyAmount) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+2));\n', '        (stockAmount, moneyAmount, ) = _calcStockAndMoney(amount, price32, proxyData);\n', '    }\n', '\n', '    function _calcStockAndMoney(uint64 amount, uint32 price32, uint[5] memory proxyData) private pure returns (uint stockAmount, uint moneyAmount, RatPrice memory price) {\n', '        price = _expandPrice(price32, proxyData);\n', '        uint64 stockUnit = ProxyData.stockUnit(proxyData);\n', '        stockAmount = uint(amount)/*42bits*/ * uint(stockUnit);\n', '        moneyAmount = stockAmount * price.numerator/*54+64bits*/ /price.denominator;\n', '    }\n', '\n', '    function addLimitOrder(bool isBuy, address sender, uint64 amount, uint32 price32,\n', '                           uint32 id, uint72 prevKey) external payable override lock {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+6));\n', '        require(ProxyData.isOnlySwap(proxyData)==false, "GraSwap: LIMIT_ORDER_NOT_SUPPORTED");\n', '        Context memory ctx;\n', '        ctx.stockUnit = ProxyData.stockUnit(proxyData);\n', '        ctx.graContract = ProxyData.graContract(proxyData);\n', '        ctx.factory = ProxyData.factory(proxyData);\n', '        ctx.stockToken = ProxyData.stock(proxyData);\n', '        ctx.moneyToken = ProxyData.money(proxyData);\n', '        ctx.priceMul = ProxyData.priceMul(proxyData);\n', '        ctx.priceDiv = ProxyData.priceDiv(proxyData);\n', '        ctx.hasDealtInOrderBook = false;\n', '        ctx.isLimitOrder = true;\n', '        ctx.order.sender = sender;\n', '        ctx.order.amount = amount;\n', '        ctx.order.price = price32;\n', '\n', '        ctx.newOrderID = _getUnusedOrderID(isBuy, id);\n', '        RatPrice memory price;\n', '    \n', '        {// to prevent "CompilerError: Stack too deep, try removing local variables."\n', '            require((amount >> 42) == 0, "GraSwap: INVALID_AMOUNT");\n', '            uint32 m = price32 & DecFloat32.MANTISSA_MASK;\n', '            require(DecFloat32.MIN_MANTISSA <= m && m <= DecFloat32.MAX_MANTISSA, "GraSwap: INVALID_PRICE");\n', '\n', '            uint stockAmount;\n', '            uint moneyAmount;\n', '            (stockAmount, moneyAmount, price) = _calcStockAndMoney(amount, price32, proxyData);\n', '            if(isBuy) {\n', '                ctx.remainAmount = moneyAmount;\n', '            } else {\n', '                ctx.remainAmount = stockAmount;\n', '            }\n', '        }\n', '\n', '        require(ctx.remainAmount < uint(1<<112), "GraSwap: OVERFLOW");\n', '        (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\n', '        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\n', '        _checkRemainAmount(ctx, isBuy);\n', '        if(prevKey != 0) { // try to insert it\n', '            bool inserted = _insertOrderFromGivenPos(isBuy, ctx.order, ctx.newOrderID, prevKey);\n', '            if(inserted) { //  if inserted successfully, record the booked tokens\n', '                _emitNewLimitOrder(uint64(ctx.order.sender), amount, amount, price32, ctx.newOrderID, isBuy);\n', '                if(isBuy) {\n', '                    ctx.bookedMoney += ctx.remainAmount;\n', '                } else {\n', '                    ctx.bookedStock += ctx.remainAmount;\n', '                }\n', '                _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\n', '                if(ctx.reserveChanged) {\n', '                    _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\n', '                }\n', '                return;\n', '            }\n', '            // if insertion failed, we try to match this order and make it deal\n', '        }\n', '        _addOrder(ctx, isBuy, price);\n', '    }\n', '\n', '    function addMarketOrder(address inputToken, address sender,\n', '                            uint112 inAmount) external payable override lock returns (uint) {\n', '        uint[5] memory proxyData;\n', '        ProxyData.fill(proxyData, 4+32*(ProxyData.COUNT+3));\n', '        Context memory ctx;\n', '        ctx.moneyToken = ProxyData.money(proxyData);\n', '        ctx.stockToken = ProxyData.stock(proxyData);\n', '        require(inputToken == ctx.moneyToken || inputToken == ctx.stockToken, "GraSwap: INVALID_TOKEN");\n', '        bool isBuy = inputToken == ctx.moneyToken;\n', '        ctx.stockUnit = ProxyData.stockUnit(proxyData);\n', '        ctx.priceMul = ProxyData.priceMul(proxyData);\n', '        ctx.priceDiv = ProxyData.priceDiv(proxyData);\n', '        ctx.graContract = ProxyData.graContract(proxyData);\n', '        ctx.factory = ProxyData.factory(proxyData);\n', '        ctx.hasDealtInOrderBook = false;\n', '        ctx.isLimitOrder = false;\n', '        ctx.remainAmount = inAmount;\n', '        (ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID) = getReserves();\n', '        (ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID) = getBooked();\n', '        _checkRemainAmount(ctx, isBuy);\n', '        ctx.order.sender = sender;\n', '        if(isBuy) {\n', '            ctx.order.price = DecFloat32.MAX_PRICE;\n', '        } else {\n', '            ctx.order.price = DecFloat32.MIN_PRICE;\n', '        }\n', '\n', '        RatPrice memory price; // leave it to zero, actually it will not be used;\n', '        _emitNewMarketOrder(uint136(ctx.order.sender), inAmount, isBuy);\n', '        return _addOrder(ctx, isBuy, price);\n', '    }\n', '\n', '    // Check router contract did send me enough tokens.\n', '    // If Router sent to much tokens, take them as reserve money&stock\n', '    function _checkRemainAmount(Context memory ctx, bool isBuy) private view {\n', '        ctx.reserveChanged = false;\n', '        uint diff;\n', '        if(isBuy) {\n', '            uint balance = _myBalance(ctx.moneyToken);\n', '            require(balance >= ctx.bookedMoney + ctx.reserveMoney, "GraSwap: MONEY_MISMATCH");\n', '            diff = balance - ctx.bookedMoney - ctx.reserveMoney;\n', '            if(ctx.remainAmount < diff) {\n', '                ctx.reserveMoney += (diff - ctx.remainAmount);\n', '                ctx.reserveChanged = true;\n', '            }\n', '        } else {\n', '            uint balance = _myBalance(ctx.stockToken);\n', '            require(balance >= ctx.bookedStock + ctx.reserveStock, "GraSwap: STOCK_MISMATCH");\n', '            diff = balance - ctx.bookedStock - ctx.reserveStock;\n', '            if(ctx.remainAmount < diff) {\n', '                ctx.reserveStock += (diff - ctx.remainAmount);\n', '                ctx.reserveChanged = true;\n', '            }\n', '        }\n', '        require(ctx.remainAmount <= diff, "GraSwap: DEPOSIT_NOT_ENOUGH");\n', '    }\n', '\n', '    // internal helper function to add new limit order & market order\n', '    // returns the amount of tokens which were sent to the taker (from AMM pool and booked tokens)\n', '    function _addOrder(Context memory ctx, bool isBuy, RatPrice memory price) private returns (uint) {\n', '        (ctx.dealMoneyInBook, ctx.dealStockInBook) = (0, 0);\n', '        ctx.firstID = _getFirstOrderID(ctx, !isBuy);\n', '        uint32 currID = ctx.firstID;\n', '        ctx.amountIntoPool = 0;\n', '        while(currID != 0) { // while not reaching the end of single-linked \n', '            (Order memory orderInBook, ) = _getOrder(!isBuy, currID);\n', '            bool canDealInOrderBook = (isBuy && (orderInBook.price <= ctx.order.price)) ||\n', '                (!isBuy && (orderInBook.price >= ctx.order.price));\n', '            if(!canDealInOrderBook) {break;} // no proper price in orderbook, stop here\n', '\n', '            // Deal in liquid pool\n', '            RatPrice memory priceInBook = _expandPrice(ctx, orderInBook.price);\n', '            bool allDeal = _tryDealInPool(ctx, isBuy, priceInBook);\n', '            if(allDeal) {break;}\n', '\n', '            // Deal in orderbook\n', '            _dealInOrderBook(ctx, isBuy, currID, orderInBook, priceInBook);\n', '\n', '            // if the order in book did NOT fully deal, then this new order DID fully deal, so stop here\n', '            if(orderInBook.amount != 0) {\n', '                _setOrder(!isBuy, currID, orderInBook);\n', '                break;\n', '            }\n', '            // if the order in book DID fully deal, then delete this order from storage and move to the next\n', '            _deleteOrder(!isBuy, currID);\n', '            currID = orderInBook.nextID;\n', '        }\n', '        // Deal in liquid pool\n', '        if(ctx.isLimitOrder) {\n', "            // use current order's price to deal with pool\n", '            _tryDealInPool(ctx, isBuy, price);\n', '            // If a limit order did NOT fully deal, we add it into orderbook\n', '            // Please note a market order always fully deals\n', '            _insertOrderToBook(ctx, isBuy, price);\n', '        } else {\n', '            // the AMM pool can deal with orders with any amount\n', '            ctx.amountIntoPool += ctx.remainAmount; // both of them are less than 112 bits\n', '            ctx.remainAmount = 0;\n', '        }\n', '        uint amountToTaker = _dealWithPoolAndCollectFee(ctx, isBuy);\n', '        if(isBuy) {\n', '            ctx.bookedStock -= ctx.dealStockInBook; //If this subtraction overflows, _setBooked will fail\n', '        } else {\n', '            ctx.bookedMoney -= ctx.dealMoneyInBook; //If this subtraction overflows, _setBooked will fail\n', '        }\n', '        if(ctx.firstID != currID) { //some orders DID fully deal, so the head of single-linked list change\n', '            _setFirstOrderID(ctx, !isBuy, currID);\n', '        }\n', '        // write the cached values to storage\n', '        _setBooked(ctx.bookedStock, ctx.bookedMoney, ctx.firstBuyID);\n', '        _setReserves(ctx.reserveStock, ctx.reserveMoney, ctx.firstSellID);\n', '        return amountToTaker;\n', '    }\n', '\n', '    // Given reserveMoney and reserveStock in AMM pool, calculate how much tokens will go into the pool if the\n', "    // final price is 'price'\n", '    function _intopoolAmountTillPrice(bool isBuy, uint reserveMoney, uint reserveStock,\n', '                                     RatPrice memory price) private pure returns (uint result) {\n', '        // sqrt(Pold/Pnew) = sqrt((2**32)*M_old*PnewDenominator / (S_old*PnewNumerator)) / (2**16)\n', '        // sell, stock-into-pool, Pold > Pnew\n', '        uint numerator = reserveMoney/*112bits*/ * price.denominator/*76+64bits*/;\n', '        uint denominator = reserveStock/*112bits*/ * price.numerator/*54+64bits*/;\n', '        if(isBuy) { // buy, money-into-pool, Pold < Pnew\n', '            // sqrt(Pnew/Pold) = sqrt((2**32)*S_old*PnewNumerator / (M_old*PnewDenominator)) / (2**16)\n', '            (numerator, denominator) = (denominator, numerator);\n', '        }\n', '        while(numerator >= (1<<192)) { // can not equal to (1<<192) !!!\n', '            numerator >>= 16;\n', '            denominator >>= 16;\n', '        }\n', '        require(denominator != 0, "GraSwapPair: DIV_BY_ZERO");\n', '        numerator = numerator * (1<<64);\n', '        uint quotient = numerator / denominator;\n', '        if(quotient <= (1<<64)) {\n', '            return 0;\n', '        } else if(quotient <= ((1<<64)*5/4)) {\n', '            // Taylor expansion: x/2 - x*x/8 + x*x*x/16\n', '            uint x = quotient - (1<<64);\n', '            uint y = x*x;\n', '            y = x/2 - y/(8*(1<<64)) + y*x/(16*(1<<128));\n', '            if(isBuy) {\n', '                result = reserveMoney * y;\n', '            } else {\n', '                result = reserveStock * y;\n', '            }\n', '            result /= (1<<64);\n', '            return result;\n', '        }\n', '        uint root = Math.sqrt(quotient); //root is at most 110bits\n', '        uint diff =  root - (1<<32);  //at most 110bits\n', '        if(isBuy) {\n', '            result = reserveMoney * diff;\n', '        } else {\n', '            result = reserveStock * diff;\n', '        }\n', '        result /= (1<<32);\n', '        return result;\n', '    }\n', '\n', '    // Current order tries to deal against the AMM pool. Returns whether current order fully deals.\n', '    function _tryDealInPool(Context memory ctx, bool isBuy, RatPrice memory price) private pure returns (bool) {\n', '        uint currTokenCanTrade = _intopoolAmountTillPrice(isBuy, ctx.reserveMoney, ctx.reserveStock, price);\n', '        require(currTokenCanTrade < uint(1<<112), "GraSwap: CURR_TOKEN_TOO_LARGE");\n', '        // all the below variables are less than 112 bits\n', '        if(!isBuy) {\n', '            currTokenCanTrade /= ctx.stockUnit; //to round\n', '            currTokenCanTrade *= ctx.stockUnit;\n', '        }\n', '        if(currTokenCanTrade > ctx.amountIntoPool) {\n', '            uint diffTokenCanTrade = currTokenCanTrade - ctx.amountIntoPool;\n', '            bool allDeal = diffTokenCanTrade >= ctx.remainAmount;\n', '            if(allDeal) {\n', '                diffTokenCanTrade = ctx.remainAmount;\n', '            }\n', '            ctx.amountIntoPool += diffTokenCanTrade;\n', '            ctx.remainAmount -= diffTokenCanTrade;\n', '            return allDeal;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // Current order tries to deal against the orders in book\n', '    function _dealInOrderBook(Context memory ctx, bool isBuy, uint32 currID,\n', '                             Order memory orderInBook, RatPrice memory priceInBook) internal {\n', '        ctx.hasDealtInOrderBook = true;\n', '        uint stockAmount;\n', '        if(isBuy) {\n', '            uint a = ctx.remainAmount/*112bits*/ * priceInBook.denominator/*76+64bits*/;\n', '            uint b = priceInBook.numerator/*54+64bits*/ * ctx.stockUnit/*64bits*/;\n', '            stockAmount = a/b;\n', '        } else {\n', '            stockAmount = ctx.remainAmount/ctx.stockUnit;\n', '        }\n', '        if(uint(orderInBook.amount) < stockAmount) {\n', '            stockAmount = uint(orderInBook.amount);\n', '        }\n', '        require(stockAmount < (1<<42), "GraSwap: STOCK_TOO_LARGE");\n', '        uint stockTrans = stockAmount/*42bits*/ * ctx.stockUnit/*64bits*/;\n', '        uint moneyTrans = stockTrans * priceInBook.numerator/*54+64bits*/ / priceInBook.denominator/*76+64bits*/;\n', '\n', '        _emitOrderChanged(orderInBook.amount, uint64(stockAmount), currID, isBuy);\n', '        orderInBook.amount -= uint64(stockAmount);\n', '        if(isBuy) { //subtraction cannot overflow: moneyTrans and stockTrans are calculated from remainAmount\n', '            ctx.remainAmount -= moneyTrans;\n', '        } else {\n', '            ctx.remainAmount -= stockTrans;\n', '        }\n', '        // following accumulations can not overflow, because stockTrans(moneyTrans) at most 106bits(160bits)\n', '        // we know for sure that dealStockInBook and dealMoneyInBook are less than 192 bits\n', '        ctx.dealStockInBook += stockTrans;\n', '        ctx.dealMoneyInBook += moneyTrans;\n', '        if(isBuy) {\n', '            _safeTransfer(ctx.moneyToken, orderInBook.sender, moneyTrans, ctx.graContract);\n', '        } else {\n', '            _safeTransfer(ctx.stockToken, orderInBook.sender, stockTrans, ctx.graContract);\n', '        }\n', '    }\n', '\n', '    // make real deal with the pool and then collect fee, which will be added to AMM pool\n', '    function _dealWithPoolAndCollectFee(Context memory ctx, bool isBuy) internal returns (uint) {\n', '        (uint outpoolTokenReserve, uint inpoolTokenReserve, uint otherToTaker) = (\n', '              ctx.reserveMoney, ctx.reserveStock, ctx.dealMoneyInBook);\n', '        if(isBuy) {\n', '            (outpoolTokenReserve, inpoolTokenReserve, otherToTaker) = (\n', '                ctx.reserveStock, ctx.reserveMoney, ctx.dealStockInBook);\n', '        }\n', '\n', '        // all these 4 varialbes are less than 112 bits\n', '        // outAmount is sure to less than outpoolTokenReserve (which is ctx.reserveStock or ctx.reserveMoney)\n', '        uint outAmount = (outpoolTokenReserve*ctx.amountIntoPool)/(inpoolTokenReserve+ctx.amountIntoPool);\n', '        if(ctx.amountIntoPool > 0) {\n', '            _emitDealWithPool(uint112(ctx.amountIntoPool), uint112(outAmount), isBuy);\n', '        }\n', '        uint32 feeBPS = IGraSwapFactory(ctx.factory).feeBPS();\n', '        // the token amount that should go to the taker, \n', "        // for buy-order, it's stock amount; for sell-order, it's money amount\n", '        uint amountToTaker = outAmount + otherToTaker;\n', '        require(amountToTaker < uint(1<<112), "GraSwap: AMOUNT_TOO_LARGE");\n', '        uint fee = (amountToTaker * feeBPS + 9999) / 10000;\n', '        amountToTaker -= fee;\n', '\n', '        if(isBuy) {\n', '            ctx.reserveMoney = ctx.reserveMoney + ctx.amountIntoPool;\n', '            ctx.reserveStock = ctx.reserveStock - outAmount + fee;\n', '        } else {\n', '            ctx.reserveMoney = ctx.reserveMoney - outAmount + fee;\n', '            ctx.reserveStock = ctx.reserveStock + ctx.amountIntoPool;\n', '        }\n', '\n', '        address token = ctx.moneyToken;\n', '        if(isBuy) {\n', '            token = ctx.stockToken;\n', '        }\n', '        _safeTransfer(token, ctx.order.sender, amountToTaker, ctx.graContract);\n', '        return amountToTaker;\n', '    }\n', '\n', '    // Insert a not-fully-deal limit order into orderbook\n', '    function _insertOrderToBook(Context memory ctx, bool isBuy, RatPrice memory price) internal {\n', '        (uint smallAmount, uint moneyAmount, uint stockAmount) = (0, 0, 0);\n', '        if(isBuy) {\n', '            uint tempAmount1 = ctx.remainAmount /*112bits*/ * price.denominator /*76+64bits*/;\n', '            uint temp = ctx.stockUnit * price.numerator/*54+64bits*/;\n', '            stockAmount = tempAmount1 / temp;\n', '            uint tempAmount2 = stockAmount * temp; // Now tempAmount1 >= tempAmount2\n', '            moneyAmount = (tempAmount2+price.denominator-1)/price.denominator; // round up\n', '            if(ctx.remainAmount > moneyAmount) {\n', '                // smallAmount is the gap where remainAmount can not buy an integer of stocks\n', '                smallAmount = ctx.remainAmount - moneyAmount;\n', '            } else {\n', '                moneyAmount = ctx.remainAmount;\n', '            } //Now ctx.remainAmount >= moneyAmount\n', '        } else {\n', '            // for sell orders, remainAmount were always decreased by integral multiple of StockUnit\n', '            // and we know for sure that ctx.remainAmount % StockUnit == 0\n', '            stockAmount = ctx.remainAmount / ctx.stockUnit;\n', '            smallAmount = ctx.remainAmount - stockAmount * ctx.stockUnit;\n', '        }\n', '        ctx.amountIntoPool += smallAmount; // Deal smallAmount with pool\n', '        //ctx.reserveMoney += smallAmount; // If this addition overflows, _setReserves will fail\n', '        _emitNewLimitOrder(uint64(ctx.order.sender), ctx.order.amount, uint64(stockAmount),\n', '                           ctx.order.price, ctx.newOrderID, isBuy);\n', '        if(stockAmount != 0) {\n', '            ctx.order.amount = uint64(stockAmount);\n', '            if(ctx.hasDealtInOrderBook) {\n', '                // if current order has ever dealt, it has the best price and can be inserted at head\n', '                _insertOrderAtHead(ctx, isBuy, ctx.order, ctx.newOrderID);\n', '            } else {\n', '                // if current order has NEVER dealt, we must find a proper position for it.\n', '                // we may scan a lot of entries in the single-linked list and run out of gas\n', '                _insertOrderFromHead(ctx, isBuy, ctx.order, ctx.newOrderID);\n', '            }\n', '        }\n', '        // Any overflow/underflow in following calculation will be caught by _setBooked\n', '        if(isBuy) {\n', '            ctx.bookedMoney += moneyAmount;\n', '        } else {\n', '            ctx.bookedStock += (ctx.remainAmount - smallAmount);\n', '        }\n', '    }\n', '}\n', '\n', '// solhint-disable-next-line max-states-count\n', 'contract GraSwapPairProxy {\n', '    uint internal _unusedVar0;\n', '    uint internal _unusedVar1;\n', '    uint internal _unusedVar2;\n', '    uint internal _unusedVar3;\n', '    uint internal _unusedVar4;\n', '    uint internal _unusedVar5;\n', '    uint internal _unusedVar6;\n', '    uint internal _unusedVar7;\n', '    uint internal _unusedVar8;\n', '    uint internal _unusedVar9;\n', '    uint internal _unlocked;\n', '\n', '    uint internal immutable _immuFactory;\n', '    uint internal immutable _immuMoneyToken;\n', '    uint internal immutable _immuStockToken;\n', '    uint internal immutable _immuGras;\n', '    uint internal immutable _immuOther;\n', '\n', '    constructor(address stockToken, address moneyToken, bool isOnlySwap, uint64 stockUnit, uint64 priceMul, uint64 priceDiv, address graContract) public {\n', '        _immuFactory = uint(msg.sender);\n', '        _immuMoneyToken = uint(moneyToken);\n', '        _immuStockToken = uint(stockToken);\n', '        _immuGras = uint(graContract);\n', '        uint temp = 0;\n', '        if(isOnlySwap) {\n', '            temp = 1;\n', '        }\n', '        temp = (temp<<64) | stockUnit;\n', '        temp = (temp<<64) | priceMul;\n', '        temp = (temp<<64) | priceDiv;\n', '        _immuOther = temp;\n', '        _unlocked = 1;\n', '    }\n', '\n', '    receive() external payable { }\n', '    // solhint-disable-next-line no-complex-fallback\n', '    fallback() payable external {\n', '        uint factory     = _immuFactory;\n', '        uint moneyToken  = _immuMoneyToken;\n', '        uint stockToken  = _immuStockToken;\n', '        uint graContract        = _immuGras;\n', '        uint other       = _immuOther;\n', '        address impl = IGraSwapFactory(address(_immuFactory)).pairLogic();\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            let size := calldatasize()\n', '            calldatacopy(ptr, 0, size)\n', '            let end := add(ptr, size)\n', '            // append immutable variables to the end of calldata\n', '            mstore(end, factory)\n', '            end := add(end, 32)\n', '            mstore(end, moneyToken)\n', '            end := add(end, 32)\n', '            mstore(end, stockToken)\n', '            end := add(end, 32)\n', '            mstore(end, graContract)\n', '            end := add(end, 32)\n', '            mstore(end, other)\n', '            size := add(size, 160)\n', '            let result := delegatecall(gas(), impl, ptr, size, 0, 0)\n', '            size := returndatasize()\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            switch result\n', '            case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract GraSwapFactory is IGraSwapFactory {\n', '    struct TokensInPair {\n', '        address stock;\n', '        address money;\n', '    }\n', '\n', '    address public override feeTo_1;\n', '    address public override feeTo_2;\n', '    address public override feeToPrivate;\n', '    address public override feeToSetter;\n', '    address public immutable gov;\n', '    address public immutable graContract;\n', '    uint32 public override feeBPS = 40;\n', '    address public override pairLogic;\n', '    mapping(address => TokensInPair) private _pairWithToken;\n', '    mapping(bytes32 => address) private _tokensToPair;\n', '    address[] public allPairs;\n', '    IPairFeeDistribution pfd; // pairFeeDistribution\n', '\n', '    constructor(address _feeToSetter, address _gov, address _graContract, address _pairLogic, address _distribution) public {\n', '        feeToSetter = _feeToSetter;\n', '        gov = _gov;\n', '        graContract = _graContract;\n', '        pairLogic = _pairLogic;\n', '        pfd = IPairFeeDistribution(_distribution);\n', '    }\n', '\n', '    function createPair(address stock, address money, bool isOnlySwap) external override returns (address pair) {\n', '        require(stock != money, "GraSwapFactory: IDENTICAL_ADDRESSES");\n', '        // not necessary //require(stock != address(0) || money != address(0), "GraSwapFactory: ZERO_ADDRESS");\n', '        uint moneyDec = _getDecimals(money);\n', '        uint stockDec = _getDecimals(stock);\n', '        require(23 >= stockDec && stockDec >= 0, "GraSwapFactory: STOCK_DECIMALS_NOT_SUPPORTED");\n', '        uint dec = 0;\n', '        if (stockDec >= 4) {\n', '            dec = stockDec - 4; // now 19 >= dec && dec >= 0\n', '        }\n', '        // 10**19 = 10000000000000000000\n', '        //  1<<64 = 18446744073709551616\n', '        uint64 priceMul = 1;\n', '        uint64 priceDiv = 1;\n', '        bool differenceTooLarge = false;\n', '        if (moneyDec > stockDec) {\n', '            if (moneyDec > stockDec + 19) {\n', '                differenceTooLarge = true;\n', '            } else {\n', '                priceMul = uint64(uint(10)**(moneyDec - stockDec));\n', '            }\n', '        }\n', '        if (stockDec > moneyDec) {\n', '            if (stockDec > moneyDec + 19) {\n', '                differenceTooLarge = true;\n', '            } else {\n', '                priceDiv = uint64(uint(10)**(stockDec - moneyDec));\n', '            }\n', '        }\n', '        require(!differenceTooLarge, "GraSwapFactory: DECIMALS_DIFF_TOO_LARGE");\n', '        bytes32 salt = keccak256(abi.encodePacked(stock, money, isOnlySwap));\n', '        require(_tokensToPair[salt] == address(0), "GraSwapFactory: PAIR_EXISTS");\n', '        GraSwapPairProxy Graswap = new GraSwapPairProxy{salt: salt}(stock, money, isOnlySwap, uint64(uint(10)**dec), priceMul, priceDiv, graContract);\n', '\n', '        pair = address(Graswap);\n', '        allPairs.push(pair);\n', '        _tokensToPair[salt] = pair;\n', '        _pairWithToken[pair] = TokensInPair(stock, money);\n', '        emit PairCreated(pair, stock, money, isOnlySwap);\n', '\n', '        // save pair info in pairFeeDistribution contract\n', '        pfd.addpair(pair);\n', '    }\n', '\n', '    function _getDecimals(address token) private view returns (uint) {\n', '        if (token == address(0)) { return 18; }\n', '        return uint(IERC20(token).decimals());\n', '    }\n', '\n', '    function allPairsLength() external override view returns (uint) {\n', '        return allPairs.length;\n', '    }\n', '\n', '    function setFeeToAddresses(address _feeTo_1, address _feeTo_2, address _feeToPrivate) external override {\n', '        require(msg.sender == feeToSetter, "GraSwapFactory: FORBIDDEN");\n', '        feeTo_1 = _feeTo_1;\n', '        feeTo_2 = _feeTo_2;\n', '        feeToPrivate = _feeToPrivate;\n', '    }\n', '\n', '    function setFeeToSetter(address _feeToSetter) external override {\n', '        require(msg.sender == feeToSetter, "GraSwapFactory: FORBIDDEN");\n', '        feeToSetter = _feeToSetter;\n', '    }\n', '\n', '    function setPairLogic(address implLogic) external override {\n', '        require(msg.sender == gov, "GraSwapFactory: SETTER_MISMATCH");\n', '        pairLogic = implLogic;\n', '    }\n', '\n', '    function setFeeBPS(uint32 _bps) external override {\n', '        require(msg.sender == gov, "GraSwapFactory: SETTER_MISMATCH");\n', '        require(0 <= _bps && _bps <= 50 , "GraSwapFactory: BPS_OUT_OF_RANGE");\n', '        feeBPS = _bps;\n', '    }\n', '    function setpdf(address _newpfd) external {\n', '        require(msg.sender == feeToSetter, "GraSwapFactory: FORBIDDEN");\n', '        pfd = IPairFeeDistribution(_newpfd);\n', '    }\n', '    function getTokensFromPair(address pair) external view override returns (address stock, address money) {\n', '        stock = _pairWithToken[pair].stock;\n', '        money = _pairWithToken[pair].money;\n', '    }\n', '\n', '    function tokensToPair(address stock, address money, bool isOnlySwap) external view override returns (address pair) {\n', '        bytes32 key = keccak256(abi.encodePacked(stock, money, isOnlySwap));\n', '        return _tokensToPair[key];\n', '    }\n', '}']