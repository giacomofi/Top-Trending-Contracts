['pragma solidity 0.5.12;\n', '\n', 'import "./MToken.sol";\n', 'import "./MMath.sol";\n', '\n', 'interface IMFactory {\n', '    function isWhiteList(address w) external view returns (bool);\n', '    function getMining() external returns (address lpMiningAdr, address swapMiningAdr);\n', '    function getFeeTo() external view returns (address);\n', '}\n', '\n', 'interface IMining {\n', '    // pair\n', '    function addLiquidity(bool isGp, address _user, uint256 _amount) external;\n', '    function removeLiquidity(bool isGp, address _user, uint256 _amount) external;\n', '    function updateGPInfo(address[] calldata gps, uint256[] calldata amounts) external;\n', '    // lp mining\n', '    function onTransferLiquidity(address from, address to, uint256 lpAmount) external;\n', '    function claimLiquidityShares(address user, address[] calldata tokens, uint256[] calldata balances, uint256[] calldata weights, uint256 amount, bool _add) external;\n', '    // swap mining\n', '    function claimSwapShare(address user, address tokenIn, uint256 amountIn, address tokenOut, uint256 amountOut) external;\n', '}\n', '\n', 'interface IPairFactory {\n', '    function newPair(address pool, uint256 perBlock, uint256 rate) external returns (IPairToken);\n', '    function getPairToken(address pool) external view returns (address);\n', '}\n', '\n', 'interface IPairToken {\n', '    function setController(address _controller) external ;\n', '}\n', '\n', 'contract MPool is MBronze, MToken, MMath {\n', '\n', '    struct Record {\n', '        bool bound;   // is token bound to pool\n', '        uint index;   // private\n', '        uint denorm;  // denormalized weight\n', '        uint balance;\n', '    }\n', '\n', '    event LOG_SWAP(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_JOIN(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        uint256 tokenAmountIn\n', '    );\n', '\n', '    event LOG_EXIT(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_CALL(\n', '        bytes4  indexed sig,\n', '        address indexed caller,\n', '        bytes data\n', '    ) anonymous;\n', '\n', '    modifier _logs_() {\n', '        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n', '        _;\n', '    }\n', '\n', '    modifier _lock_() {\n', '        require(!_mutex, "ERR_REENTRY");\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    }\n', '\n', '    modifier _viewlock_() {\n', '        require(!_mutex, "ERR_REENTRY");\n', '        _;\n', '    }\n', '\n', '    bool private _mutex;\n', '\n', '    IMFactory private _factory;    // MFactory address to push token exitFee to and check whitelist from factory\n', '    IMining private _pair;\n', '    address public controller;     // has CONTROL role\n', '\n', '    // `setSwapFee` and `finalize` require CONTROL\n', '    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\n', '    uint private _swapFee;\n', '    bool private _finalized;\n', '    bool private _publicSwap;     // true if PUBLIC can call SWAP functions\n', '\n', '    address[] private _tokens;\n', '    mapping(address => Record) private  _records;\n', '    uint private _totalWeight;\n', '\n', '    constructor() public {\n', '        controller = msg.sender;\n', '        _factory = IMFactory(msg.sender);\n', '\n', '        _swapFee = MIN_FEE;\n', '        _publicSwap = false;\n', '        _finalized = false;\n', '    }\n', '\n', '    function isPublicSwap()\n', '    external view\n', '    returns (bool)\n', '    {\n', '        return _publicSwap;\n', '    }\n', '\n', '    function isFinalized()\n', '    external view\n', '    returns (bool)\n', '    {\n', '        return _finalized;\n', '    }\n', '\n', '    function isBound(address t)\n', '    external view\n', '    returns (bool)\n', '    {\n', '        return _records[t].bound;\n', '    }\n', '\n', '    function getNumTokens()\n', '    external view\n', '    returns (uint)\n', '    {\n', '        return _tokens.length;\n', '    }\n', '\n', '    function getCurrentTokens()\n', '    external view _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        return _tokens;\n', '    }\n', '\n', '    function getFinalTokens()\n', '    external view\n', '    _viewlock_\n', '    returns (address[] memory tokens)\n', '    {\n', '        require(_finalized, "ERR_NOT_FINALIZED");\n', '        return _tokens;\n', '    }\n', '\n', '    function getDenormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        return _records[token].denorm;\n', '    }\n', '\n', '    function getTotalDenormalizedWeight()\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getNormalizedWeight(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        uint denorm = _records[token].denorm;\n', '        return bdiv(denorm, _totalWeight);\n', '    }\n', '\n', '    function getBalance(address token)\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        return _records[token].balance;\n', '    }\n', '\n', '    function getSwapFee()\n', '    external view\n', '    _viewlock_\n', '    returns (uint)\n', '    {\n', '        return _swapFee;\n', '    }\n', '\n', '    function getPair()\n', '    external view\n', '    _viewlock_\n', '    returns (address)\n', '    {\n', '        return address(_pair);\n', '    }\n', '\n', '    function setSwapFee(uint swapFee)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(!_finalized, "ERR_IS_FINALIZED");\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(swapFee >= MIN_FEE, "ERR_MIN_FEE");\n', '        require(swapFee <= MAX_FEE, "ERR_MAX_FEE");\n', '        _swapFee = swapFee;\n', '    }\n', '\n', '    function setController(address manager)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        controller = manager;\n', '    }\n', '\n', '    function setPair(IMining pair)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        _setPair(pair);\n', '    }\n', '\n', '    function _setPair(IMining pair)\n', '    internal\n', '    {\n', '        _pair = pair;\n', '    }\n', '\n', '    function finalize(address beneficiary, uint fixPoolSupply)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(!_finalized || totalSupply() == 0, "ERR_IS_FINALIZED");\n', '        require(_tokens.length >= MIN_BOUND_TOKENS, "ERR_MIN_TOKENS");\n', '\n', '        _finalized = true;\n', '        _publicSwap = true;\n', '\n', '        uint256 supply = fixPoolSupply == 0 ? INIT_POOL_SUPPLY : fixPoolSupply;\n', '\n', '        _mintPoolShare(supply);\n', '        _pushPoolShare(beneficiary, supply);\n', '        _lpChanging(true, beneficiary, supply);\n', '    }\n', '\n', '\n', '    function bind(address token, uint balance, uint denorm)\n', '    external\n', '    _logs_\n', '        // _lock_  Bind does not lock because it jumps to `rebind`, which does\n', '    {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(!_records[token].bound, "ERR_IS_BOUND");\n', '        require(!_finalized, "ERR_IS_FINALIZED");\n', '\n', '        require(_tokens.length < MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");\n', '\n', '        _records[token] = Record({\n', '        bound: true,\n', '        index: _tokens.length,\n', '        denorm: 0,    // balance and denorm will be validated\n', '        balance: 0    // and set by `rebind`\n', '        });\n', '        _tokens.push(token);\n', '        rebind(token, balance, denorm);\n', '    }\n', '\n', '    function rebind(address token, uint balance, uint denorm)\n', '    public\n', '    _logs_\n', '    _lock_\n', '    {\n', '\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        require(!_finalized || totalSupply() == 0, "ERR_IS_FINALIZED");\n', '\n', '        require(denorm >= MIN_WEIGHT, "ERR_MIN_WEIGHT");\n', '        require(denorm <= MAX_WEIGHT, "ERR_MAX_WEIGHT");\n', '        require(balance >= MIN_BALANCE, "ERR_MIN_BALANCE");\n', '\n', '        // Adjust the denorm and totalWeight\n', '        uint oldWeight = _records[token].denorm;\n', '        if (denorm > oldWeight) {\n', '            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\n', '            require(_totalWeight <= MAX_TOTAL_WEIGHT, "ERR_MAX_TOTAL_WEIGHT");\n', '        } else if (denorm < oldWeight) {\n', '            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\n', '        }\n', '        _records[token].denorm = denorm;\n', '\n', '        // Adjust the balance record and actual token balance\n', '        uint oldBalance = _records[token].balance;\n', '        _records[token].balance = balance;\n', '        if (balance > oldBalance) {\n', '            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n', '        } else if (balance < oldBalance) {\n', '            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\n', '            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn);\n', '        }\n', '    }\n', '\n', '    function unbind(address token)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        require(!_finalized, "ERR_IS_FINALIZED");\n', '\n', '        uint tokenBalance = _records[token].balance;\n', '        _totalWeight = bsub(_totalWeight, _records[token].denorm);\n', '\n', '        // Swap the token-to-unbind with the last token,\n', '        // then delete the last token\n', '        uint index = _records[token].index;\n', '        uint last = _tokens.length - 1;\n', '        _tokens[index] = _tokens[last];\n', '        _records[_tokens[index]].index = index;\n', '        _tokens.pop();\n', '        _records[token] = Record({\n', '        bound: false,\n', '        index: 0,\n', '        denorm: 0,\n', '        balance: 0\n', '        });\n', '\n', '        _pushUnderlying(token, msg.sender, tokenBalance);\n', '    }\n', '\n', '    // Absorb any tokens that have been sent to this contract into the pool\n', '    function gulp(address token)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        _records[token].balance = IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n', '    }\n', '\n', '    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n', '    external view\n', '    _viewlock_\n', '    returns (uint spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\n', '    }\n', '\n', '    function joinPool(address beneficiary, uint poolAmountOut)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(_finalized, "ERR_NOT_FINALIZED");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '            require(bsub(IERC20(_tokens[i]).balanceOf(address(this)), _records[t].balance) >= tokenAmountIn);\n', '            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\n', '            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(beneficiary, poolAmountOut);\n', '\n', '        _lpChanging(true, beneficiary, poolAmountOut);\n', '    }\n', '\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n', '    external\n', '    _logs_\n', '    _lock_\n', '    {\n', '        require(_finalized, "ERR_NOT_FINALIZED");\n', '\n', '        uint poolTotal = totalSupply();\n', '        uint ratio = bdiv(poolAmountIn, poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        _burnPoolShare(poolAmountIn);\n', '\n', '        for (uint i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint bal = _records[t].balance;\n', '            uint tokenAmountOut = bmul(ratio, bal);\n', '            require(tokenAmountOut != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountOut >= minAmountsOut[i], "ERR_LIMIT_OUT");\n', '            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '        }\n', '\n', '        _lpChanging(false, msg.sender, poolAmountIn);\n', '    }\n', '\n', '\n', '    function swapExactAmountIn(\n', '        address user,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint minAmountOut,\n', '        address to,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    returns (uint tokenAmountOut, uint spotPriceAfter)\n', '    {\n', '\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        require(_publicSwap, "ERR_SWAP_NOT_PUBLIC");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        uint tokenAmountIn = bsub(IERC20(tokenIn).balanceOf(address(this)), inRecord.balance);\n', '        require(tokenAmountIn > 0, "ERR_AMOUNTIN_NOT_IN_Pool");\n', '        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");\n', '\n', '        uint256 factoryFee = bmul(tokenAmountIn, bmul(bdiv(_swapFee, 6), 1));\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");\n', '\n', '        tokenAmountOut = calcOutGivenIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountIn,\n', '            _swapFee\n', '        );\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '\n', '        uint inAfterFee = bsub(tokenAmountIn, factoryFee);\n', '        inRecord.balance = badd(inRecord.balance, inAfterFee);\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pushUnderlying(tokenOut, to, tokenAmountOut);\n', '        _pushUnderlying(tokenIn, _factory.getFeeTo(), factoryFee);\n', '\n', '        _swapMining(user, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '\n', '    function swapExactAmountOut(\n', '        address user,\n', '        address tokenIn,\n', '        uint maxAmountIn,\n', '        address tokenOut,\n', '        uint tokenAmountOut,\n', '        address to,\n', '        uint maxPrice\n', '    )\n', '    external\n', '    _lock_\n', '    returns (uint tokenAmountIn, uint spotPriceAfter)\n', '    {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        require(_publicSwap, "ERR_SWAP_NOT_PUBLIC");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), "ERR_MAX_OUT_RATIO");\n', '\n', '        uint spotPriceBefore = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _swapFee\n', '        );\n', '        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");\n', '\n', '        tokenAmountIn = calcInGivenOut(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountOut,\n', '            _swapFee\n', '        );\n', '        uint user_deposit_amount = bsub(IERC20(tokenIn).balanceOf(address(this)), inRecord.balance);\n', '        require(tokenAmountIn == user_deposit_amount && user_deposit_amount <= maxAmountIn, "ERR_LIMIT_IN");\n', '\n', '        uint256 factoryFee = bmul(tokenAmountIn, bmul(bdiv(_swapFee, 6), 1));\n', '\n', '        inRecord.balance = badd(inRecord.balance, bsub(tokenAmountIn, factoryFee));\n', '        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\n', '\n', '        spotPriceAfter = calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");\n', '        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");\n', '\n', '        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '\n', '        _pushUnderlying(tokenOut, to, tokenAmountOut);\n', '        _pushUnderlying(tokenIn, _factory.getFeeTo(), factoryFee);\n', '\n', '        _swapMining(user, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\n', '        return (tokenAmountIn, spotPriceAfter);\n', '    }\n', '\n', '    function calcDesireByGivenAmount(address tokenIn, address tokenOut, uint256 inAmount, uint256 outAmount)\n', '    external view\n', '    returns (uint desireAmount)\n', '    {\n', '        require(inAmount != 0 || outAmount != 0, "ERR_AMOUNT_IS_ZERO");\n', '        Record memory inRecord = _records[address(tokenIn)];\n', '        Record memory outRecord = _records[address(tokenOut)];\n', '        if (inAmount != 0) {\n', '            desireAmount = calcOutGivenIn(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, inAmount, _swapFee);\n', '        } else {\n', '            desireAmount = calcInGivenOut(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, outAmount, _swapFee);\n', '        }\n', '    }\n', '    function calcPoolSpotPrice(address tokenIn, address tokenOut, uint256 inAmount, uint256 outAmount)\n', '    external view\n', '    returns (uint256 price)\n', '    {\n', '        Record memory inRecord = _records[address(tokenIn)];\n', '        Record memory outRecord = _records[address(tokenOut)];\n', '        if (inAmount != 0 && outAmount != 0) {\n', '            uint256 factoryFee = bmul(inAmount, bmul(bdiv(_swapFee, 6), 1));\n', '            price = calcSpotPrice(\n', '                badd(inRecord.balance, bsub(inAmount, factoryFee)),\n', '                inRecord.denorm,\n', '                bsub(outRecord.balance, outAmount),\n', '                outRecord.denorm,\n', '                _swapFee);\n', '        } else {\n', '            price = calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\n', '        }\n', '    }\n', '\n', '    function updatePairGPInfo(address[] calldata gps, uint[] calldata shares)\n', '    external\n', '    {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        if (address(_pair) != address(0))\n', '        {\n', '            _pair.updateGPInfo(gps, shares);\n', '        }\n', '    }\n', '\n', "    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n", '    // You must `_lock_` or otherwise ensure reentry-safety\n', '\n', '    function _pullUnderlying(address erc20, address from, uint amount)\n', '    internal\n', '    {\n', '        safeTransferFrom(erc20, from, address(this), amount);\n', '    }\n', '\n', '    function _pushUnderlying(address erc20, address to, uint amount)\n', '    internal\n', '    {\n', '        safeTransfer(erc20, to, amount);\n', '    }\n', '\n', '    function _pullPoolShare(address from, uint amount)\n', '    internal\n', '    {\n', '        _pull(from, amount);\n', '    }\n', '\n', '    function _pushPoolShare(address to, uint amount)\n', '    internal\n', '    {\n', '        _push(to, amount);\n', '    }\n', '\n', '    function _mintPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _mint(amount);\n', '    }\n', '\n', '    function _burnPoolShare(uint amount)\n', '    internal\n', '    {\n', '        _burn(amount);\n', '    }\n', '\n', '    function _lpChanging(bool add, address user, uint256 amount)\n', '    internal\n', '    {\n', '        if (address(_pair) != address(0))\n', '        {\n', '            add == true ? _pair.addLiquidity(false, user, amount) : _pair.removeLiquidity(false, user, amount);\n', '        }\n', '\n', '        (address lpMiningAdr, ) = _factory.getMining();\n', '        if (lpMiningAdr != address(0))\n', '        {\n', '            IMining mining = IMining(lpMiningAdr);\n', '            uint256[] memory balances = new uint256[](_tokens.length);\n', '            uint256[] memory weights = new uint256[](_tokens.length);\n', '            for (uint i = 0; i < _tokens.length; i++) {\n', '                balances[i] = _records[_tokens[i]].balance;\n', '                weights[i] = bdiv(_records[_tokens[i]].denorm, _totalWeight);\n', '            }\n', '\n', '            mining.claimLiquidityShares(user, _tokens, balances, weights, amount, add);\n', '        }\n', '\n', '    }\n', '\n', '    function _swapMining(address user, address tokenIn, address tokenOut, uint256 tokenAmountIn, uint256 tokenAmountOut)\n', '    internal\n', '    {\n', '        ( ,address swapMiningAdr) = _factory.getMining();\n', '        if (swapMiningAdr != address(0)){\n', '            IMining mining = IMining(swapMiningAdr);\n', '            mining.claimSwapShare(user, tokenIn, tokenAmountIn, tokenOut, tokenAmountOut);\n', '        }\n', '    }\n', '\n', '    function _transferLiquidity(address src, address dst, uint amt) internal {\n', '        (address lpMiningAdr, ) = _factory.getMining();\n', '        if (lpMiningAdr != address(0)){\n', '            IMining mining = IMining(lpMiningAdr);\n', '            mining.onTransferLiquidity(src, dst, amt);\n', '        }\n', '    }\n', '\n', '    function transfer(address dst, uint amt) external returns (bool) {\n', '        require(_factory.isWhiteList(msg.sender) || _factory.isWhiteList(dst), "ERR_NOT_WHITELIST");\n', '        _move(msg.sender, dst, amt);\n', '        if(dst != address(this)){\n', '            _transferLiquidity(msg.sender, dst, amt);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint amt) external returns (bool) {\n', '        require(_factory.isWhiteList(msg.sender) || _factory.isWhiteList(dst), "ERR_NOT_WHITELIST");\n', '        require(msg.sender == src || amt <= _allowance[src][msg.sender], "ERR_BTOKEN_BAD_CALLER");\n', '        _move(src, dst, amt);\n', '        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n', '            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\n', '            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n', '        }\n', '        if(dst != address(this)){\n', '            _transferLiquidity(src, dst, amt);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function bindPair(\n', '        IPairFactory pairFactory,\n', '        address[] calldata gps,\n', '        uint[] calldata shares,\n', '        uint gpRate\n', '    ) external {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        IPairToken pair = pairFactory.newPair(address(this), 4 * 10 ** 18, gpRate);\n', '        _setPair(IMining(address(pair)));\n', '        if (gpRate > 0 && gpRate <= 15 && gps.length != 0 && gps.length == shares.length) {\n', '            _pair.updateGPInfo(gps, shares);\n', '        }\n', '        pair.setController(msg.sender);\n', '    }\n', '}']