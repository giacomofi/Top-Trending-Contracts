['/**\n', '* SPDX-License-Identifier: LicenseRef-Aktionariat\n', '*\n', '* MIT License with Automated License Fee Payments\n', '*\n', '* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n', '*\n', '* Permission is hereby granted to any person obtaining a copy of this software\n', '* and associated documentation files (the "Software"), to deal in the Software\n', '* without restriction, including without limitation the rights to use, copy,\n', '* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n', '* Software, and to permit persons to whom the Software is furnished to do so,\n', '* subject to the following conditions:\n', '*\n', '* - The above copyright notice and this permission notice shall be included in\n', '*   all copies or substantial portions of the Software.\n', '* - All automated license fee payments integrated into this and related Software\n', '*   are preserved.\n', '*\n', '* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '* SOFTWARE.\n', '*/\n', 'pragma solidity >=0.8;\n', '\n', 'import "./Ownable.sol";\n', 'import "./IERC20.sol";\n', 'import "./ITokenReceiver.sol";\n', 'import "./IERC677Receiver.sol";\n', '\n', 'contract Market is Ownable {\n', '\n', '    address public paymenthub;\n', '\n', '    address public immutable base;  // ERC-20 currency\n', '    address public immutable token; // ERC-20 share token\n', '\n', '    address public constant copyright = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D; // Aktionariat AG\n', '\n', '    uint256 private price; // current offer price, without drift\n', '    uint256 public increment; // increment\n', '\n', '    uint256 public driftStart;\n', '    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n', '    int256 public driftIncrement;\n', '\n', '    uint8 private constant licenseFeeBps = 90;\n', '\n', '    uint8 private constant BUYING_ENABLED = 0x1;\n', '    uint8 private constant SELLING_ENABLED = 0x2;\n', '\n', '    // more bits to be used by payment hub\n', '    uint256 public settings = BUYING_ENABLED | SELLING_ENABLED;\n', '\n', '    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\n', '\n', '    constructor(address shareToken, uint256 price_, uint256 increment_, address baseCurrency, address owner) {\n', '        base = baseCurrency;\n', '        token = shareToken;\n', '        price = price_;\n', '        increment = increment_;\n', '        paymenthub = address(0x4d99F8e88BAB0BEe8cD840b1Ad3c0bE4f49c293A);\n', '        transferOwnership(owner);\n', '    }\n', '\n', '    function setPrice(uint256 newPrice, uint256 newIncrement) public onlyOwner {\n', '        anchorPrice(newPrice);\n', '        increment = newIncrement;\n', '    }\n', '\n', '    function hasDrift() public view returns (bool) {\n', '        return timeToDrift != 0;\n', '    }\n', '\n', '    // secondsPerStep should be negative for downwards drift\n', '    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) public onlyOwner {\n', '        anchorPrice(getPrice());\n', '        timeToDrift = secondsPerStep;\n', '        driftIncrement = newDriftIncrement;\n', '    }\n', '\n', '    function anchorPrice(uint256 currentPrice) private {\n', '        price = currentPrice;\n', '        driftStart = block.timestamp;\n', '    }\n', '\n', '    function getPrice() public view returns (uint256) {\n', '        return getPriceAtTime(block.timestamp);\n', '    }\n', '\n', '    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n', '        if (hasDrift()){\n', '            uint256 passed = timestamp - driftStart;\n', '            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n', '            int256 driftedPrice = int256(price) + drifted;\n', '            if (driftedPrice < 0){\n', '                return 0;\n', '            } else {\n', '                return uint256(driftedPrice);\n', '            }\n', '        } else {\n', '            return price;\n', '        }\n', '    }\n', '\n', '    function buy(address from, uint256 paid, bytes calldata ref) internal returns (uint256) {\n', '        uint shares = getShares(paid);\n', '        uint costs = notifyTraded(from, shares, ref);\n', '        if (costs < paid){\n', '            IERC20(base).transfer(from, paid - costs);\n', '        }\n', '        IERC20(token).transfer(from, shares);\n', '        return shares;\n', '    }\n', '\n', '    function notifyTraded(address from, uint256 shares, bytes calldata ref) internal returns (uint256) {\n', '        require(hasSetting(BUYING_ENABLED));\n', '        uint costs = getBuyPrice(shares);\n', '        price = price + (shares * increment);\n', '        emit Trade(token, from, ref, int256(shares), base, costs, 0, getPrice());\n', '        return costs;\n', '    }\n', '\n', '    function notifyTrade(address buyer, uint256 shares, bytes calldata ref) public onlyOwner {\n', '        notifyTraded(buyer, shares, ref);\n', '    }\n', '\n', '    function notifyTradeAndTransfer(address buyer, uint256 shares, bytes calldata ref) public onlyOwner {\n', '        notifyTraded(buyer, shares, ref);\n', '        IERC20(token).transfer(buyer, shares);\n', '    }\n', '\n', '    function notifyTrades(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) public onlyOwner {\n', '        for (uint i = 0; i < buyers.length; i++) {\n', '            notifyTraded(buyers[i], shares[i], ref[i]);\n', '        }\n', '    }\n', '\n', '    function notifyTradesAndTransfer(address[] calldata buyers, uint256[] calldata shares, bytes[] calldata ref) public onlyOwner {\n', '        for (uint i = 0; i < buyers.length; i++) {\n', '            notifyTradeAndTransfer(buyers[i], shares[i], ref[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Payment hub might actually have sent another accepted token, including Ether.\n', '     */\n', '    function processIncoming(address token_, address from, uint256 amount, bytes calldata ref) public payable returns (uint256) {\n', '        require(msg.sender == token_ || msg.sender == base || msg.sender == paymenthub);\n', '        if (token_ == token){\n', '            return sell(from, amount, ref);\n', '        } else if (token_ == base){\n', '            return buy(from, amount, ref);\n', '        } else {\n', '            require(false);\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // ERC-677 recipient\n', '    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) public returns (bool) {\n', '        processIncoming(msg.sender, from, amount, ref);\n', '        return true;\n', '    }\n', '\n', '    // ITokenReceiver\n', '    function onTokenTransfer(address token_, address from, uint256 amount, bytes calldata ref) public {\n', '        processIncoming(token_, from, amount, ref);\n', '    }\n', '\n', '    function buyingEnabled() public view returns (bool){\n', '        return hasSetting(BUYING_ENABLED);\n', '    }\n', '\n', '    function sellingEnabled() public view returns (bool){\n', '        return hasSetting(SELLING_ENABLED);\n', '    }\n', '\n', '    function hasSetting(uint256 setting) private view returns (bool) {\n', '        return settings & setting == setting;\n', '    }\n', '\n', '    function sell(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n', '        require(hasSetting(SELLING_ENABLED));\n', '        uint256 totPrice = getSellPrice(amount);\n', '        IERC20 baseToken = IERC20(base);\n', '        uint256 fee = getLicenseFee(totPrice);\n', '        if (fee > 0){\n', '            baseToken.transfer(copyright, fee);\n', '        }\n', '        baseToken.transfer(recipient, totPrice - fee);\n', '        price -= amount * increment;\n', '        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, fee, getPrice());\n', '        return totPrice;\n', '    }\n', '\n', '    function getLicenseFee(uint256 totPrice) public pure returns (uint256) {\n', '        return totPrice * licenseFeeBps / 10000;\n', '    }\n', '\n', '    function getSellPrice(uint256 shares) public view returns (uint256) {\n', '        return getPrice(getPrice() - (shares * increment), shares);\n', '    }\n', '\n', '    function getBuyPrice(uint256 shares) public view returns (uint256) {\n', '        return getPrice(getPrice(), shares);\n', '    }\n', '\n', '    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n', '        if (shares == 0) {\n', '            return 0;\n', '        } else {\n', '            uint256 highest = lowest + (shares - 1) * increment;\n', '            return ((lowest + highest) / 2) * shares;\n', '        }\n', '    }\n', '\n', '    function getShares(uint256 money) public view returns (uint256) {\n', '        uint256 currentPrice = getPrice();\n', '        uint256 min = 0;\n', '        uint256 max = money / currentPrice;\n', '        while (min < max){\n', '            uint256 middle = (min + max)/2;\n', '            uint256 totalPrice = getPrice(currentPrice, middle);\n', '            if (money > totalPrice){\n', '                min = middle + 1;\n', '            } else {\n', '                max = middle;\n', '            }\n', '        }\n', '        return min;\n', '    }\n', '\n', '    function withdrawEther(uint256 amount) public ownerOrHub() {\n', '        payable(msg.sender).transfer(amount); // return change\n', '    }\n', '\n', '    function approve(address erc20, address who, uint256 amount) public onlyOwner() {\n', '        IERC20(erc20).approve(who, amount);\n', '    }\n', '\n', '    function withdraw(address ercAddress, address to, uint256 amount) public ownerOrHub() {\n', '        IERC20(ercAddress).transfer(to, amount);\n', '    }\n', '\n', '    function setPaymentHub(address hub) public onlyOwner() {\n', '        paymenthub = hub;\n', '    }\n', '\n', '    function setSettings(uint256 settings_) public onlyOwner() {\n', '        settings = settings_;\n', '    }\n', '\n', '    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) public onlyOwner() {\n', '        if (newBuyingEnabled != hasSetting(BUYING_ENABLED)){\n', '            settings ^= BUYING_ENABLED;\n', '        }\n', '        if (newSellingEnabled != hasSetting(SELLING_ENABLED)){\n', '            settings ^= SELLING_ENABLED;\n', '        }\n', '    }\n', '    \n', '    modifier ownerOrHub() {\n', '        require(owner == msg.sender || paymenthub == msg.sender, "not owner");\n', '        _;\n', '    }\n', '}']