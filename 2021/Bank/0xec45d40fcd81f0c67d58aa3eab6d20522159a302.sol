['pragma solidity 0.4.25;\n', '\n', 'import "./multiOwnable.sol";\n', 'import "./IERC20.sol";\n', '\n', 'contract ethBridge is Multiownable {\n', '    IERC20 private token;\n', '\n', '    mapping(address => uint256) public tokensSent;\n', '    mapping(address => uint256) public tokensRecieved;\n', '    mapping(address => uint256) public tokensRecievedButNotSent;\n', '    address[] public feeOwners;\n', '    mapping(address => uint) public feeOwnersIndices;\n', '    uint256 public fee;\n', '\n', '    event FeeOwnersUpdated(address[] previousCallers, address[] newCallers);\n', '\n', '    constructor (address _token) public {\n', '        token = IERC20(_token);\n', '        feeOwners.push(msg.sender);\n', '        feeOwnersIndices[msg.sender] = 1;\n', '        fee = 150000 * 10**9;\n', '    }\n', '\n', '    uint256 amountToSent;\n', '    bool transferStatus;\n', '\n', '    bool avoidReentrancy = false;\n', '\n', '    function updateBaseFee(uint256 _feeGwei) public onlyAllOwners {\n', '        fee = _feeGwei * 10**9;\n', '    }\n', '\n', '    function setOwnersForFee(address[] _feeOwners) public onlyAllOwners {\n', '        for (uint j = 0; j < owners.length; j++) {\n', '            delete feeOwnersIndices[owners[j]];\n', '        }\n', '        for (uint i = 0; i < _feeOwners.length; i++) {\n', '            require(_feeOwners[i] != address(0), "FeeOwners: callers array contains zero");\n', '            require(feeOwnersIndices[_feeOwners[i]] == 0, "FeeOwners: callers array contains duplicates");\n', '            require(ownersIndices[_feeOwners[i]] > 0, "FeeOwners: owners not match to callers");\n', '            feeOwnersIndices[_feeOwners[i]] = i + 1;\n', '        }\n', '        emit FeeOwnersUpdated(feeOwners, _feeOwners);\n', '        feeOwners = _feeOwners;\n', '    }\n', '\n', '    function sendTokens(uint256 amount) public {\n', '        require(msg.sender != address(0), "Zero account");\n', '        require(amount > 0,"Amount of tokens should be more then 0");\n', '        require(token.balanceOf(msg.sender) >= amount,"Not enough balance");\n', '\n', '        transferStatus = token.transferFrom(msg.sender, address(this), amount);\n', '        if (transferStatus == true) {\n', '            tokensRecieved[msg.sender] += amount;\n', '        }\n', '    }\n', '\n', '    function writeTransaction(address user, uint256 amount) public onlySomeOwners(feeOwners.length) {\n', '        require(user != address(0), "Zero account");\n', '        require(amount > 0,"Amount of tokens should be more then 0");\n', '        require(!avoidReentrancy);\n', '\n', '        avoidReentrancy = true;\n', '        tokensRecievedButNotSent[user] += amount;\n', '        avoidReentrancy = false;\n', '    }\n', '\n', '    function recieveTokens(uint256[] memory commissions) public payable {\n', '        if (tokensRecievedButNotSent[msg.sender] != 0) {\n', '            require(commissions.length == feeOwners.length, "The number of commissions and owners does not match");\n', '            uint256 sum;\n', '            for(uint i = 0; i < commissions.length; i++) {\n', '                sum += commissions[i];\n', '            }\n', '            require(msg.value >= sum, "Not enough ETH (The amount of ETH is less than the amount of commissions.)");\n', '            require(msg.value >= feeOwners.length * fee, "Not enough ETH (The amount of ETH is less than the internal commission.)");\n', '\n', '            for (i = 0; i < feeOwners.length; i++) {\n', '                uint256 commission = commissions[i];\n', '                feeOwners[i].transfer(commission);\n', '            }\n', '\n', '            amountToSent = tokensRecievedButNotSent[msg.sender] - tokensSent[msg.sender];\n', '            token.transfer(msg.sender, amountToSent);\n', '            tokensSent[msg.sender] += amountToSent;\n', '        }\n', '    }\n', '\n', '    function withdrawTokens(uint256 amount, address reciever) public onlyAllOwners {\n', '        require(amount > 0,"Amount of tokens should be more then 0");\n', '        require(reciever != address(0), "Zero account");\n', '        require(token.balanceOf(address(this)) >= amount,"Not enough balance");\n', '\n', '        token.transfer(reciever, amount);\n', '    }\n', '\n', '    function withdrawETHer(uint256 amount, address reciever) public onlyAllOwners {\n', '        require(amount > 0,"Amount of tokens should be more then 0");\n', '        require(reciever != address(0), "Zero account");\n', '        require(address(this).balance >= amount,"Not enough balance");\n', '\n', '        reciever.transfer(amount);\n', '    }\n', '}']