['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./EnumerableMap.sol";\n', 'import "./Ownable.sol";\n', 'import "./IERC1155_EXT.sol";\n', 'import "./IMultiERC20Handler.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Math.sol";\n', 'import "./ERC1155Receiver.sol";\n', '\n', '// 0xc4E523243551359d71a2f2986D0EC3c388e7191B\n', '// binance - 0xF9a34a112357959a465b6d250dab294EDF69B72e\n', '\n', 'contract MuCitadelMarketPlace is  Ownable, ERC1155Receiver {\n', '    using EnumerableSet for EnumerableSet.UintSet;\n', '    using EnumerableMap for EnumerableMap.UintToAddressMap;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    IERC1155_EXT public nft;\n', '    IMultiERC20Handler public ERC20Handler;\n', '\n', '    uint256 private order;\n', '\n', '    EnumerableSet.UintSet internal _asksMap;\n', '\n', '    mapping(uint256 => Order) private _tokenSellers;\n', '\n', '    address payable public feeAddr;\n', '\t// a fee of 1 equals 0.1%, 10 to 1%, 100 to 10%, 1000 to 100%\n', '    uint256 public makerFee;\n', '\tuint256 public takerFee;\n', '\tuint256 constant public PERCENTS_DIVIDER = 1000;\n', '\n', '    mapping(address => EnumerableSet.UintSet) private _userSellingOrder;\n', '\n', '\tIERC20 public priorityToken;\n', '\n', '    struct TokenPrice {\n', '        string symbol;\n', '        uint256 price;\n', '    }\n', '\n', '    struct OrderShow {\n', '        address owner;\n', '        string _hash;\n', '        uint256 quantity;\n', '        uint256 tokenID;\n', '        uint256 ethPrice;\n', '        TokenPrice[] tokenPrices;\n', '    }\n', '\n', '    struct Order {\n', '        address owner;\n', '        uint256 quantity;\n', '        uint256 tokenID;\n', '        uint256 ethPrice;\n', '        mapping(string => uint256) tokenPrices;\n', '    }\n', '\n', '    event Ask(\n', '        address indexed seller,\n', '        uint256 indexed order,\n', '        uint256 ethPrice,\n', '        TokenPrice[] indexed tokenPrices,\n', '\t\tuint256 fee\n', '    );\n', '    event Trade(\n', '        address indexed seller,\n', '        address indexed buyer,\n', '        uint256 tokenId,\n', '        bool byToken,\n', '        string symbol,\n', '        uint256 quantity,\n', '        uint256 price,\n', '        uint256 fee\n', '    );\n', '    event CancelSellToken(address indexed seller, uint256 indexed order);\n', '    event FeeAddressTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '\tevent SetMakerFeePercent(address indexed setBy, uint256 oldFeePercent, uint256 newFeePercent);\n', '\n', '    event SetTakerFeeFeePercent(address indexed setBy, uint256 oldFeePercent, uint256 newFeePercent);\n', '\n', '    event setPrices(\n', '        address indexed seller,\n', '        uint256 indexed order,\n', '        uint256 ethPrice,\n', '        TokenPrice[] indexed tokenPrices\n', '    );\n', '\n', '    event SetPriorityToken (string priorityToken);\n', '\n', '    constructor(\n', '        address _nftAddress,\n', '        address _tokenHandler,\n', '        address _priorityToken,\n', '        address _feeAddr,\n', '\t\tuint256 _makerFee,\n', '        uint256 _takerFee\n', '    ) {\n', '        require(_nftAddress.isContract() && _nftAddress != address(0) && _nftAddress != address(this));\n', '        require(_tokenHandler.isContract() && _tokenHandler != address(this));\n', '        require(_priorityToken.isContract());\n', '        setPriorityToken(_priorityToken);\n', '        nft = IERC1155_EXT(_nftAddress);\n', '        ERC20Handler = IMultiERC20Handler(_tokenHandler);\n', '        feeAddr = payable(_feeAddr);\n', '\t\tmakerFee = _makerFee;\n', '        takerFee = _takerFee;\n', '\n', '        emit SetMakerFeePercent(_msgSender(), 0, _takerFee);\n', '        emit SetTakerFeeFeePercent(_msgSender(), 0, _makerFee);\n', '    }\n', '\n', '    function setCurrentPrice(\n', '        uint256 _order,\n', '        uint256 ethPrice,\n', '        string[] memory _symbols,\n', '        uint256[] memory _prices\n', '    ) external  {\n', '        require(\n', '            _userSellingOrder[_msgSender()].contains(_order),\n', '            "Only Seller can update price"\n', '        );\n', '        require(\n', '            _symbols.length == _prices.length,\n', '            "diferent number of symbols and prices"\n', '        );\n', '        Order storage order_ = _tokenSellers[_order];\n', '        order_.ethPrice = ethPrice;\n', '        uint256 priceCount = ethPrice;\n', '        TokenPrice[] memory PriceDAta = new TokenPrice[](_prices.length);\n', '        if (_symbols.length > 0) {\n', '            for (uint256 i = 0; i < _prices.length; i++) {\n', '                require(\n', '                    ERC20Handler.isValidSymbol(_symbols[i]),\n', '                    "token is not valid"\n', '                );\n', '                order_.tokenPrices[_symbols[i]] = _prices[i];\n', '                priceCount = priceCount.add(_prices[i]);\n', '                PriceDAta[i].price = _prices[i];\n', '                PriceDAta[i].symbol = _symbols[i];\n', '            }\n', '        }\n', '        require(ethPrice > 0, "Price must be granter than zero");\n', '\n', '        emit setPrices(order_.owner, _order, ethPrice, PriceDAta);\n', '    }\n', '\n', '    function readyToSellToken (\n', '        uint256 _tokenId,\n', '        uint256 _quantity,\n', '        uint256 ethPrice,\n', '        string[] memory _symbols,\n', '        uint256[] memory _prices\n', '    ) external  payable {\n', '        readyToSellTokenTo(\n', '            _tokenId,\n', '            _quantity,\n', '            ethPrice,\n', '            _symbols,\n', '            _prices,\n', '            _msgSender()\n', '        );\n', '    }\n', '\n', '\t//this function is used to change the priority token.\n', '    function setPriorityToken(address Addrs) public {\n', '        priorityToken = IERC20(Addrs);\n', '        emit SetPriorityToken(PRIORITY_TOKEN());\n', '    }\n', '\n', '    function PRIORITY_TOKEN() public view returns(string memory) {\n', '        return priorityToken.symbol();\n', '    }\n', '\n', '    function readyToSellTokenTo(\n', '        uint256 _tokenId,\n', '        uint256 _quantity,\n', '        uint256 ethPrice,\n', '        string[] memory _symbols,\n', '        uint256[] memory _prices,\n', '        address _from\n', '    ) internal  {\n', '        require(\n', '            nft.ownerOf(_from, _tokenId),\n', '            "Only Token Owner can sell token"\n', '        );\n', '        require(\n', '            _symbols.length == _prices.length,\n', '            "diferent number of symbols and prices"\n', '        );\n', '        require(_quantity > 0, "insufficient quantity");\n', '\n', '        TokenPrice[] memory PriceDAta = new TokenPrice[](_prices.length);\n', '        order++;\n', '        Order storage nft_ = _tokenSellers[order];\n', '        if (_prices.length == 0) {\n', '            require(ethPrice > 0, "Price must be granter than zero");\n', '        } else {\n', '            for (uint256 i = 0; i < _prices.length; i++) {\n', '                require(_prices[i] > 0, "Price must be granter than zero");\n', '                require(\n', '                    ERC20Handler.isValidSymbol(_symbols[i]),\n', '                    "token is not valid"\n', '                );\n', '                PriceDAta[i].price = _prices[i];\n', '                PriceDAta[i].symbol = _symbols[i];\n', '                nft_.tokenPrices[_symbols[i]] = _prices[i];\n', '            }\n', '        }\n', '\n', '\t\tbool hasPriorityToken = nft_.tokenPrices[PRIORITY_TOKEN()] > 0;\n', '\t\tbool hasEthPrice = ethPrice > 0;\n', '\t\tuint256 feeAmt;\n', '\t\tif(hasEthPrice && !hasPriorityToken) {\n', '\t\t\tfeeAmt = ethPrice.mul(makerFee).div(PERCENTS_DIVIDER);\n', '\t\t\trequire(msg.value == feeAmt, "invalid pay amount");\n', '            if (feeAmt > 0) {\n', '                feeAddr.transfer(feeAmt);\n', '            }\n', '\t\t}\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "invalid pay amount");\n', '\t\t\tstring memory _symbol;\n', '\t\t\tif(!hasPriorityToken) {\n', '\t\t\t\t_symbol = _symbols[0];\n', '\t\t\t\tfeeAmt = _prices[0].mul(makerFee).div(PERCENTS_DIVIDER);\n', '\t\t\t}\n', '\t\t\telse {\n', '\t\t\t\t_symbol = PRIORITY_TOKEN();\n', '\t\t\t\tfeeAmt = nft_.tokenPrices[_symbol].mul(makerFee).div(PERCENTS_DIVIDER);\n', '\t\t\t}\n', '\n', '\t\t\tIERC20 token = ERC20Handler.symbolToIERC20(_symbol);\n', '\t\t\tif(feeAmt > 0) {\n', '\t\t\t\ttoken.safeTransferFrom(_from, feeAddr, feeAmt);\n', '            }\n', '\n', '\t\t}\n', '\n', '        _asksMap.add(order);\n', '        nft_.owner = _from;\n', '        nft_.tokenID = _tokenId;\n', '        nft_.quantity = _quantity;\n', '        nft_.ethPrice = ethPrice;\n', '        _userSellingOrder[_from].add(order);\n', '\n', '        nft.safeTransferFrom(_from, address(this), _tokenId, _quantity, "0x");\n', '\n', '        emit Ask(_from, order, ethPrice, PriceDAta, feeAmt);\n', '    }\n', '\n', '    function buyToken(\n', '        uint256 _order,\n', '        string memory symbol,\n', '        uint256 _quantity\n', '    ) external payable  {\n', '        buyTokenTo(_order, _msgSender(), symbol, _quantity);\n', '    }\n', '\n', '    function buyTokenTo(\n', '        uint256 _order,\n', '        address _to,\n', '        string memory symbol,\n', '        uint256 _quantity\n', '    ) internal  {\n', '        require(_to != address(0) && (_to != address(this)), "Wrong buyer");\n', '        require(_asksMap.contains(_order), "Token not in sell book");\n', '        require(_quantity > 0, "insufficient quantity");\n', '        Order storage nft_ = _tokenSellers[_order];\n', '        uint256 quantityOrder = nft_.quantity;\n', '        require(quantityOrder >= _quantity, "excessive quantity");\n', '        uint256 price = nft_.tokenPrices[symbol];\n', '        bool byToken = true;\n', '        if (price == 0) {\n', '            price = nft_.ethPrice;\n', '            require(price > 0, "token no valid");\n', '            byToken = false;\n', '        }\n', '        price = price.mul(_quantity);\n', '        uint256 feeAmount = price.mul(takerFee).div(PERCENTS_DIVIDER);\n', '        if (!byToken) {\n', '            require(msg.value == price, "invalid pay amount");\n', '            if (feeAmount > 0) {\n', '                feeAddr.transfer(feeAmount);\n', '            }\n', '            payable(nft_.owner).transfer(price.sub(feeAmount));\n', '        } else {\n', '            require(ERC20Handler.isValidSymbol(symbol), "token no valid");\n', '            IERC20 token = ERC20Handler.symbolToIERC20(symbol);\n', '            if (feeAmount > 0) {\n', '                token.safeTransferFrom(_to, feeAddr, feeAmount);\n', '            }\n', '            token.safeTransferFrom(_to, nft_.owner, price.sub(feeAmount));\n', '        }\n', '        uint256 _tokenId = nft_.tokenID;\n', '        uint256 deltaQuantity = quantityOrder.sub(_quantity);\n', '\n', '        if (deltaQuantity == 0) {\n', '            _asksMap.remove(_order);\n', '            _userSellingOrder[nft_.owner].remove(_order);\n', '            delete _tokenSellers[_order];\n', '        } else {\n', '            nft_.quantity = deltaQuantity;\n', '        }\n', '\n', '        nft.safeTransferFrom(address(this), _to, _tokenId, _quantity, "0x");\n', '        emit Trade(\n', '            nft_.owner,\n', '            _to,\n', '            _tokenId,\n', '            byToken,\n', '            symbol,\n', '            _quantity,\n', '            price,\n', '            feeAmount\n', '        );\n', '    }\n', '\n', '    function cancelSellToken(uint256 _order) external  {\n', '        require(\n', '            _userSellingOrder[_msgSender()].contains(_order),\n', '            "Only Seller can cancel sell token"\n', '        );\n', '        Order storage order_ = _tokenSellers[_order];\n', '        nft.safeTransferFrom(\n', '            address(this),\n', '            _msgSender(),\n', '            order_.tokenID,\n', '            order_.quantity,\n', '            "0x"\n', '        );\n', '        _asksMap.remove(_order);\n', '        _userSellingOrder[_msgSender()].remove(_order);\n', '        delete _tokenSellers[_order];\n', '        emit CancelSellToken(_msgSender(), _order);\n', '    }\n', '\n', '    function convertOrderToOrderShow(Order storage _order)\n', '        internal\n', '        view\n', '        returns (OrderShow memory orderShow)\n', '    {\n', '        orderShow.owner = _order.owner;\n', '\t\tuint256 _id = _order.tokenID;\n', '        orderShow._hash = nft.getHashFromTokenID(_id);\n', '        orderShow.quantity = _order.quantity;\n', '        orderShow.tokenID = _id;\n', '        orderShow.ethPrice = _order.ethPrice;\n', '        string[] memory simbols = ERC20Handler.getAllSymbols();\n', '        uint256 j;\n', '        orderShow.tokenPrices = new TokenPrice[](simbols.length);\n', '        for (uint256 i; i < simbols.length; i++) {\n', '            if (_order.tokenPrices[simbols[i]] == 0) continue;\n', '            orderShow.tokenPrices[j].symbol = simbols[i];\n', '            orderShow.tokenPrices[j].price = _order.tokenPrices[simbols[i]];\n', '            j++;\n', '        }\n', '\n', '        return orderShow;\n', '    }\n', '\n', '    function getAskLength() external view returns (uint256) {\n', '        return _asksMap.length();\n', '    }\n', '\n', '    function getAsks() external view returns (OrderShow[] memory) {\n', '        OrderShow[] memory asks = new OrderShow[](_asksMap.length());\n', '\n', '        for (uint256 i; i < _asksMap.length(); i++) {\n', '            uint256 orderNum = _asksMap.at(i);\n', '            asks[i] = convertOrderToOrderShow(_tokenSellers[orderNum]);\n', '        }\n', '        return asks;\n', '    }\n', '\n', '    function transferFeeAddress(address _feeAddr) external onlyOwner {\n', '        require(_feeAddr != feeAddr, "Not need update");\n', '        feeAddr = payable(_feeAddr);\n', '        emit FeeAddressTransferred(_msgSender(), feeAddr);\n', '    }\n', '\n', '    function setMakerFee(uint256 _makerPercent) external onlyOwner {\n', '        require(makerFee != _makerPercent, "Not need update");\n', '        emit SetMakerFeePercent(_msgSender(), makerFee, _makerPercent);\n', '        makerFee = _makerPercent;\n', '    }\n', '\n', '    function setFeeTakerFee(uint256 _takerPercent) external onlyOwner {\n', '        require(takerFee != _takerPercent, "Not need update");\n', '        emit SetTakerFeeFeePercent(_msgSender(), takerFee, _takerPercent);\n', '        takerFee = _takerPercent;\n', '    }\n', '\n', '    function getAsksByUser(address user)\n', '        external\n', '        view\n', '        returns (OrderShow[] memory)\n', '    {\n', '        OrderShow[] memory asks =\n', '            new OrderShow[](_userSellingOrder[user].length());\n', '\n', '        for (uint256 i; i < _userSellingOrder[user].length(); i++) {\n', '            uint256 orderNum = _userSellingOrder[user].at(i);\n', '            asks[i] = convertOrderToOrderShow(_tokenSellers[orderNum]);\n', '        }\n', '        return asks;\n', '    }\n', '\n', '\n', '    function getOrdersKeyFromUser(address user)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256[] memory keys = new uint256[](_userSellingOrder[user].length());\n', '        for (uint256 i; i < keys.length; i++) {\n', '            keys[i] = _userSellingOrder[user].at(i);\n', '        }\n', '        return keys;\n', '    }\n', '\n', '    function getOrder(uint256 _order) external view returns (OrderShow memory) {\n', '        Order storage order_ = _tokenSellers[_order];\n', '        if (order_.quantity == 0)\n', '            return convertOrderToOrderShow(_tokenSellers[0]);\n', '        return convertOrderToOrderShow(_tokenSellers[_order]);\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    ) external override returns (bytes4) {\n', '        return (\n', '            bytes4(\n', '                keccak256(\n', '                    "onERC1155Received(address,address,uint256,uint256,bytes)"\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    ) external override returns (bytes4) {\n', '        //Not allowed\n', '        revert();\n', '        return "";\n', '    }\n', '}']