['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-01\n', '*/\n', '\n', '// File: contracts\\SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity  ^0.6.0;\n', '\n', 'contract SafeMath {\n', '   /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return safeSub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function safeSub(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n', '        require(b <= a, error);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return safeDiv(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function safeDiv(uint256 a, uint256 b, string memory error) internal pure returns (uint256) {\n', '        require(b > 0, error);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function safeExponent(uint256 a,uint256 b) internal pure returns (uint256) {\n', '        uint256 result;\n', '        assembly {\n', '            result:=exp(a, b)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts\\DateTime.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', 'contract DateTime {\n', '        /*\n', '         *  Date and Time utilities for ethereum contracts\n', '         *\n', '         */\n', '        struct _DateTime {\n', '                uint16 year;\n', '                uint8 month;\n', '                uint8 day;\n', '                uint8 hour;\n', '                uint8 minute;\n', '                uint8 second;\n', '                uint8 weekday;\n', '        }\n', '\n', '        uint constant DAY_IN_SECONDS = 86400;\n', '        uint constant YEAR_IN_SECONDS = 31536000;\n', '        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n', '\n', '        uint constant HOUR_IN_SECONDS = 3600;\n', '        uint constant MINUTE_IN_SECONDS = 60;\n', '\n', '        uint16 constant ORIGIN_YEAR = 1970;\n', '\n', '        function isLeapYear(uint16 year) public pure returns (bool) {\n', '                if (year % 4 != 0) {\n', '                        return false;\n', '                }\n', '                if (year % 100 != 0) {\n', '                        return true;\n', '                }\n', '                if (year % 400 != 0) {\n', '                        return false;\n', '                }\n', '                return true;\n', '        }\n', '\n', '        function leapYearsBefore(uint year) public pure returns (uint) {\n', '                year -= 1;\n', '                return year / 4 - year / 100 + year / 400;\n', '        }\n', '\n', '        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n', '                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '                        return 31;\n', '                }\n', '                else if (month == 4 || month == 6 || month == 9 || month == 11) {\n', '                        return 30;\n', '                }\n', '                else if (isLeapYear(year)) {\n', '                        return 29;\n', '                }\n', '                else {\n', '                        return 28;\n', '                }\n', '        }\n', '\n', '        function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {\n', '                uint secondsAccountedFor = 0;\n', '                uint buf;\n', '                uint8 i;\n', '\n', '                // Year\n', '                dt.year = getYear(timestamp);\n', '                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n', '\n', '                // Month\n', '                uint secondsInMonth;\n', '                for (i = 1; i <= 12; i++) {\n', '                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n', '                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n', '                                dt.month = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += secondsInMonth;\n', '                }\n', '\n', '                // Day\n', '                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n', '                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n', '                                dt.day = i;\n', '                                break;\n', '                        }\n', '                        secondsAccountedFor += DAY_IN_SECONDS;\n', '                }\n', '\n', '                // Hour\n', '                dt.hour = getHour(timestamp);\n', '\n', '                // Minute\n', '                dt.minute = getMinute(timestamp);\n', '\n', '                // Second\n', '                dt.second = getSecond(timestamp);\n', '\n', '                // Day of week.\n', '                dt.weekday = getWeekday(timestamp);\n', '        }\n', '\n', '        function getYear(uint timestamp) public pure returns (uint16) {\n', '                uint secondsAccountedFor = 0;\n', '                uint16 year;\n', '                uint numLeapYears;\n', '\n', '                // Year\n', '                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n', '                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n', '\n', '                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n', '                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n', '\n', '                while (secondsAccountedFor > timestamp) {\n', '                        if (isLeapYear(uint16(year - 1))) {\n', '                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                secondsAccountedFor -= YEAR_IN_SECONDS;\n', '                        }\n', '                        year -= 1;\n', '                }\n', '                return year;\n', '        }\n', '\n', '        function getMonth(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).month;\n', '        }\n', '\n', '        function getDay(uint timestamp) public pure returns (uint8) {\n', '                return parseTimestamp(timestamp).day;\n', '        }\n', '\n', '        function getHour(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60 / 60) % 24);\n', '        }\n', '\n', '        function getMinute(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / 60) % 60);\n', '        }\n', '\n', '        function getSecond(uint timestamp) public pure returns (uint8) {\n', '                return uint8(timestamp % 60);\n', '        }\n', '\n', '        function getWeekday(uint timestamp) public pure returns (uint8) {\n', '                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, 0, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, 0, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n', '                return toTimestamp(year, month, day, hour, minute, 0);\n', '        }\n', '\n', '        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n', '                uint16 i;\n', '\n', '                // Year\n', '                for (i = ORIGIN_YEAR; i < year; i++) {\n', '                        if (isLeapYear(i)) {\n', '                                timestamp += LEAP_YEAR_IN_SECONDS;\n', '                        }\n', '                        else {\n', '                                timestamp += YEAR_IN_SECONDS;\n', '                        }\n', '                }\n', '\n', '                // Month\n', '                uint8[12] memory monthDayCounts;\n', '                monthDayCounts[0] = 31;\n', '                if (isLeapYear(year)) {\n', '                        monthDayCounts[1] = 29;\n', '                }\n', '                else {\n', '                        monthDayCounts[1] = 28;\n', '                }\n', '                monthDayCounts[2] = 31;\n', '                monthDayCounts[3] = 30;\n', '                monthDayCounts[4] = 31;\n', '                monthDayCounts[5] = 30;\n', '                monthDayCounts[6] = 31;\n', '                monthDayCounts[7] = 31;\n', '                monthDayCounts[8] = 30;\n', '                monthDayCounts[9] = 31;\n', '                monthDayCounts[10] = 30;\n', '                monthDayCounts[11] = 31;\n', '\n', '                for (i = 1; i < month; i++) {\n', '                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n', '                }\n', '\n', '                // Day\n', '                timestamp += DAY_IN_SECONDS * (day - 1);\n', '\n', '                // Hour\n', '                timestamp += HOUR_IN_SECONDS * (hour);\n', '\n', '                // Minute\n', '                timestamp += MINUTE_IN_SECONDS * (minute);\n', '\n', '                // Second\n', '                timestamp += second;\n', '\n', '                return timestamp;\n', '        }\n', '}\n', '\n', '// File: contracts\\STYK_I.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', 'contract STYK_I is SafeMath, DateTime {\n', '    constructor(\n', '        uint256 _lockTime,\n', '        uint256 _auctionExpiryTime,\n', '        uint256 _auctionLimit,\n', '        uint256 _stakeAmount\n', '    ) public {\n', '        STYK_REWARD_TOKENS = safeMul(200000, 1e18);\n', '        MONTHLY_REWARD_TOKENS = safeMul(100000, 1e18);\n', '\n', '        tokenBalanceLedger_[address(this)] = safeAdd(\n', '            STYK_REWARD_TOKENS,\n', '            MONTHLY_REWARD_TOKENS\n', '        );\n', '        // time lock for 100 years\n', '        lockTime = _lockTime;\n', '        auctionExpiryTime = _auctionExpiryTime;\n', '        auctionEthLimit = _auctionLimit;\n', '        stakingRequirement = _stakeAmount;\n', '        inflationPayOutDays = safeAdd(now, 500 days);\n', '    }\n', '\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlybelievers() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    // only people with profits\n', '    modifier onlyhodler() {\n', '        require(myDividends(true) > 0);\n', '        _;\n', '    }\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    // ERC20\n', '    event Transfer(address indexed from, address indexed to, uint256 tokens);\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "STYK I";\n', '    string public symbol = "STYK";\n', '    uint256 public constant decimals = 18;\n', '    uint8 internal constant dividendFee_ = 10;\n', '    uint256 internal constant tokenPriceInitial_ = 0.0000001 ether;\n', '    uint256 internal constant tokenPriceIncremental_ = 0.00000001 ether;\n', '    uint256 internal constant magnitude = 2**64;\n', '    uint256 STYK_REWARD_TOKENS;\n', '\n', '    uint256 MONTHLY_REWARD_TOKENS;\n', '\n', '    uint256 internal inflationTime;\n', '\n', '    uint256 internal lockTime;\n', '    uint256 internal inflationPayOutDays;\n', '    uint56 internal userCount = 0;\n', '    uint256 public inflationCounter = 0;\n', '\n', '    // proof of stake (defaults at 1 token)\n', '    uint256 internal stakingRequirement;\n', '\n', '    /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal referralBalance_;\n', '    mapping(address => bool) public rewardQualifier;\n', '    mapping(address => uint256) internal stykRewards;\n', '    mapping(address => address[]) internal referralUsers;\n', '    mapping(address => mapping(address => bool)) internal userExists;\n', '    mapping(address => bool) internal earlyadopters;\n', '    mapping(address => bool) internal userAdded;\n', '    mapping(address => uint256) internal userIndex;\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal totalMonthRewards;\n', '    mapping(address => uint256) internal earlyadopterBonus;\n', '    mapping(address => uint256) internal userDeposit;\n', '    mapping(address => bool) internal auctionAddressTracker;\n', '    mapping(address => mapping(uint256 => mapping (uint256 => bool)))public monthlyRewardsClaimed;\n', '    mapping(address =>mapping(uint256 => bool))public stykclaimMap;\n', '\n', '    address[] internal userAddress;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 public auctionEthLimit;\n', '    uint256 public auctionExpiryTime;\n', '    uint256 internal profitPerShare_;\n', '    uint256 internal auctionProfitPerShare_;\n', '\n', '    /**\n', '     * Converts all incoming Ethereum to tokens for the caller, and passes down the referral address (if any)\n', '     */\n', '    function buy(address _referredBy) public payable returns (uint256) {\n', '        purchaseTokens(msg.value, _referredBy);\n', '    }\n', '\n', '    //Cannot directly deposit ethers\n', '    fallback() external payable {\n', '        revert("ERR_CANNOT_FORCE_ETHERS");\n', '    }\n', '\n', '    //Cannot directly deposit ethers\n', '    receive() external payable {\n', '        revert("ERR_CANNOT_FORCE_ETHERS");\n', '    }\n', '\n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    function reinvest() public onlyhodler() {\n', '        // pay out the dividends virtually\n', '        address _customerAddress = msg.sender;\n', '        // fetch dividends\n', '        uint256 _dividends = totalDividends(_customerAddress);\n', '        userDeposit[_customerAddress] = 0;\n', '        payoutsTo_[_customerAddress] += (int256)(\n', '            _dividendsOf(_customerAddress) * magnitude\n', '        );\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        //determine whether user qualify for early adopter bonus or not\n', '        if (\n', '            earlyadopters[_customerAddress] &&\n', '            (now > safeAdd(auctionExpiryTime, 24 hours))\n', '        ) {\n', '            if (tokenBalanceLedger_[_customerAddress] == 0) {\n', '                earlyadopterBonus[_customerAddress] = 0;\n', '            }\n', '            earlyadopters[_customerAddress] = false;\n', '        }\n', '\n', '        //determine whether user qualify for styk bonus or not\n', '        if (\n', '            rewardQualifier[_customerAddress] &&\n', '            _calculateInflationMinutes() > 4320\n', '        ) {\n', '            stykRewards[_customerAddress] = 0;\n', '            rewardQualifier[_customerAddress] = false;\n', '        }\n', '        if (totalMonthRewards[_customerAddress] != 0) {\n', '            totalMonthRewards[_customerAddress] = 0;\n', '        }\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens = purchaseTokens(_dividends, address(0));\n', '\n', '        // fire event\n', '        emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '\n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit() public {\n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '\n', '        if (_tokens > 0) sell(_tokens);\n', '\n', '        withdraw();\n', '        userAdded[_customerAddress] = false;\n', '\n', '        uint256 index = getUserAddressIndex(_customerAddress);\n', '        address _lastAddress = userAddress[userAddress.length - 1];\n', '        uint256 _lastindex = getUserAddressIndex(_lastAddress);\n', '        userAddress[index] = _lastAddress;\n', '        userAddress[userAddress.length - 1] = _customerAddress;\n', '\n', '        userIndex[_lastAddress] = index;\n', '        userIndex[_customerAddress] = _lastindex;\n', '        delete userIndex[_customerAddress];\n', '        userAddress.pop();\n', '        userCount--;\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw() public onlyhodler() {\n', '        // setup data\n', '        address payable _customerAddress = msg.sender;\n', '        uint256 _dividends = totalDividends(_customerAddress);\n', '\n', '        userDeposit[_customerAddress] = 0;\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256)(\n', '            _dividendsOf(_customerAddress) * magnitude\n', '        );\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        //determine whether user qualify for early adopter bonus or not\n', '        if (\n', '            earlyadopters[_customerAddress] &&\n', '            (now > safeAdd(auctionExpiryTime, 24 hours))\n', '        ) {\n', '            if (tokenBalanceLedger_[_customerAddress] == 0) {\n', '                earlyadopterBonus[_customerAddress] = 0;\n', '            }\n', '            earlyadopters[_customerAddress] = false;\n', '        }\n', '\n', '        //determine whether user qualify for styk bonus or not\n', '        if (\n', '            rewardQualifier[_customerAddress] &&\n', '            _calculateInflationMinutes() > 4320\n', '        ) {\n', '            stykRewards[_customerAddress] = 0;\n', '            rewardQualifier[_customerAddress] = false;\n', '        }\n', '        if (totalMonthRewards[_customerAddress] != 0) {\n', '            totalMonthRewards[_customerAddress] = 0;\n', '        }\n', '        // delivery service\n', '        _customerAddress.transfer(_dividends);\n', '\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '    /**\n', '     * Liquifies tokens to ethereum.\n', '     */\n', '    function sell(uint256 _amountOfTokens) public onlybelievers() {\n', '        address _customerAddress = msg.sender;\n', '\n', '        require(\n', '            now > auctionExpiryTime,\n', '            "ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION"\n', '        );\n', '\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n', '\n', '        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\n', '            if (earlyadopters[_customerAddress]) {\n', '                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\n', '                    _customerAddress\n', '                );\n', '            }\n', '            if (rewardQualifier[_customerAddress]) {\n', '                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\n', '            }\n', '        }\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = safeSub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = safeSub(\n', '            tokenBalanceLedger_[_customerAddress],\n', '            _tokens\n', '        );\n', '\n', '        if (auctionAddressTracker[_customerAddress]) {\n', '            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\n', '            payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '        } else {\n', '            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\n', '            payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '        }\n', '\n', '        // dividing by zero is a bad idea\n', '        if (tokenSupply_ > 0) {\n', '            // update the amount of dividends per token\n', '            auctionProfitPerShare_ = safeAdd(\n', '                auctionProfitPerShare_,\n', '                (_dividends * magnitude) /\n', '                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n', '            );\n', '\n', '            profitPerShare_ = safeAdd(\n', '                profitPerShare_,\n', '                (_dividends * magnitude) /\n', '                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n', '            );\n', '        }\n', '\n', '        userDeposit[_customerAddress] = safeAdd(\n', '            userDeposit[_customerAddress],\n', '            _taxedEthereum\n', '        );\n', '\n', '        // fire events\n', '        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n', '        emit Transfer(_customerAddress, address(0), _amountOfTokens);\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     * Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     */\n', '    function myDividends(bool _includeReferralBonus)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return\n', '            _includeReferralBonus\n', '                ? _dividendsOf(_customerAddress) +\n', '                    referralBalance_[_customerAddress]\n', '                : _dividendsOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function _dividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (auctionAddressTracker[_customerAddress]) {\n', '            return\n', '                safeAdd(\n', '                    (uint256)(\n', '                        (int256)(\n', '                            auctionProfitPerShare_ *\n', '                                (tokenBalanceLedger_[_customerAddress])\n', '                        ) - payoutsTo_[_customerAddress]\n', '                    ) / magnitude,\n', '                    userDeposit[_customerAddress]\n', '                );\n', '        } else {\n', '            return\n', '                safeAdd(\n', '                    (uint256)(\n', '                        (int256)(\n', '                            profitPerShare_ *\n', '                                (tokenBalanceLedger_[_customerAddress])\n', '                        ) - payoutsTo_[_customerAddress]\n', '                    ) / magnitude,\n', '                    userDeposit[_customerAddress]\n', '                );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the buy price of 1 individual token.\n', '     */\n', '    function sellPrice() external view returns (uint256) {\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n', '            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the sell price of 1 individual token.\n', '     */\n', '    function buyPrice() public view returns (uint256) {\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n', '            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    function calculateTokensReceived(uint256 _ethereumToSpend)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _dividends = safeDiv(_ethereumToSpend, dividendFee_);\n', '        uint256 _taxedEthereum = safeSub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    function calculateEthereumReceived(uint256 _tokensToSell)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n', '        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '    /*==========================================\n', '    =            Methods Developed By Minddeft    =\n', '    ==========================================*/\n', '\n', '    function _inflation() internal view returns (uint256) {\n', '        uint256 buyPrice_ = buyPrice();\n', '        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\n', '        return inflation_factor;\n', '    }\n', '\n', '    // chainlink already give data as 10**8 so convert to 18 decimal\n', '    function checkInflation() external view returns (uint256) {\n', '        return _inflation();\n', '    }\n', '\n', '    //To set inflationTime when inflation factor reaches 2% of ethereum\n', '    function setInflationTime() internal {\n', '        if (_inflation() >= 20000 || now > inflationPayOutDays) {\n', '            inflationTime = now;\n', '            inflationPayOutDays = safeAdd(inflationTime, 500 days);\n', '             ++inflationCounter;\n', '        }\n', '    }\n', '\n', '    //To calculate Inflation minutes (72 hours converted into minutes)\n', '    function _calculateInflationMinutes() internal view returns (uint256) {\n', '        if (inflationTime == 0) {\n', '            return 0;\n', '        }\n', '        return safeDiv(safeSub(now, inflationTime), 60);\n', '    }\n', '\n', '    function calculateInflationMinutes() external view returns (uint256) {\n', '        return _calculateInflationMinutes();\n', '    }\n', '\n', '    //To calculate Token Percentage\n', '    function _calculateTokenPercentage(address _customerAddress)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (tokenBalanceLedger_[_customerAddress] > 0) {\n', '            uint256 token_percent =\n', '                safeDiv(\n', '                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\n', '                    totalSupply()\n', '                );\n', '            return token_percent;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    //To calculate Token Percentage\n', '    function calculateTokenPercentage(address _customerAddress)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _calculateTokenPercentage(_customerAddress);\n', '    }\n', '\n', "    //To calculate user's STYK rewards\n", '    function _calculateSTYKReward(address _customerAddress)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (now > auctionExpiryTime) {\n', '            uint256 token_percent = _calculateTokenPercentage(_customerAddress);\n', '            if (token_percent > 0) {\n', '                uint256 rewards =\n', '                    safeDiv(\n', '                        safeMul(\n', '                            _dividendsOfPremintedTokens(STYK_REWARD_TOKENS),\n', '                            token_percent\n', '                        ),\n', '                        1000000\n', '                    );\n', '                return rewards;\n', '            }\n', '            return 0;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function calculateSTYKReward(address _customerAddress)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _calculateSTYKReward(_customerAddress);\n', '    }\n', '\n', '    //To activate deflation\n', '    function deflationSell() external {\n', '        uint256 inflationMinutes = _calculateInflationMinutes();\n', '        require(\n', '            inflationMinutes <= 4320,\n', '            "ERR_INFLATION_MINUTES_SHOULD_BE_LESS_THAN_4320"\n', '        );\n', '\n', '        require(!stykclaimMap[msg.sender][inflationCounter], "ERR_REWARD_ALREADY_CLAIMED");\n', '\n', '        if (_calculateSTYKReward(msg.sender) > 0) {\n', '            rewardQualifier[msg.sender] = true;\n', '            stykclaimMap[msg.sender][inflationCounter] = true;\n', '            uint256 rewards = _calculateSTYKReward(msg.sender);\n', '\n', '            stykRewards[msg.sender] = safeAdd(stykRewards[msg.sender], rewards);\n', '\n', '            uint256 userToken =\n', '                safeDiv(safeMul(tokenBalanceLedger_[msg.sender], 25), 100);\n', '\n', '            sell(userToken);\n', '        }\n', '    }\n', '\n', '    //To accumulate rewards of non qualifying after deflation sell\n', '    function _deflationAccumulatedRewards() internal view returns (uint256) {\n', '        uint256 stykRewardPoolBalance = 0;\n', '\n', '        for (uint256 i = 0; i < userAddress.length; i++) {\n', '            if (userAddress[i] != address(0)) {\n', '                address _user = userAddress[i];\n', '                if (!rewardQualifier[_user]) {\n', '                    stykRewardPoolBalance = safeAdd(\n', '                        _calculateSTYKReward(_user),\n', '                        stykRewardPoolBalance\n', '                    );\n', '                }\n', '            }\n', '        }\n', '        return stykRewardPoolBalance;\n', '    }\n', '\n', '    //To pay STYK Rewards\n', '    function STYKRewards(address _to) internal view returns (uint256) {\n', '        if (_calculateTokenPercentage(_to) > 0) {\n', '            uint256 _rewards = stykRewards[_to];\n', '            uint256 accumulatedRewards =\n', '                safeDiv(\n', '                    safeMul(\n', '                        _deflationAccumulatedRewards(),\n', '                        _calculateTokenPercentage(_to)\n', '                    ),\n', '                    1000000\n', '                );\n', '            uint256 finalRewards = safeAdd(_rewards, accumulatedRewards);\n', '            return finalRewards;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    //To calculate team token holder percent\n', '    function _teamTokenHolder(address _to) internal view returns (uint256) {\n', '        uint256 useractivecount = 0;\n', '        uint256 usertotaltokens = 0;\n', '        if (profitPerShare_ > 0) {\n', '            for (uint256 i = 0; i < referralUsers[_to].length; i++) {\n', '                address _userAddress = referralUsers[_to][i];\n', '                if (_checkUserActiveStatus(_userAddress)) {\n', '                    ++useractivecount;\n', '                }\n', '            }\n', '\n', '            if (useractivecount >= 3) {\n', '                for (uint256 i = 0; i < referralUsers[_to].length; i++) {\n', '                    address _addr = referralUsers[_to][i];\n', '                    usertotaltokens = safeAdd(\n', '                        tokenBalanceLedger_[_addr],\n', '                        usertotaltokens\n', '                    );\n', '                }\n', '                return\n', '                    safeDiv(safeMul(usertotaltokens, 1000000), totalSupply());\n', '            } else {\n', '                return 0;\n', '            }\n', '        } else return 0;\n', '    }\n', '\n', '    function teamTokenHolder(address _to) external view returns (uint256) {\n', '        return _teamTokenHolder(_to);\n', '    }\n', '\n', '    // To calculate monthly  rewards\n', '    function _calculateMonthlyRewards(address _to)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 token_percent = _teamTokenHolder(_to);\n', '        if (token_percent != 0) {\n', '            uint256 rewards =\n', '                safeDiv(\n', '                    safeMul(\n', '                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\n', '                        token_percent\n', '                    ),\n', '                    1000000\n', '                );\n', '\n', '            return rewards;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function calculateMonthlyRewards(address _to)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _calculateMonthlyRewards(_to);\n', '    }\n', '\n', "    // To check the user's  status\n", '    function _checkUserActiveStatus(address _user)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        if (tokenBalanceLedger_[_user] > safeMul(10, 1e18)) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    //To distribute rewards to early adopters\n', '    function earlyAdopterBonus(address _user) public view returns (uint256) {\n', '        if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\n', '            uint256 token_percent = _calculateTokenPercentage(_user);\n', '            uint256 _earlyadopterDividends =\n', '                (uint256)(\n', '                    (int256)(\n', '                        auctionProfitPerShare_ *\n', '                            tokenBalanceLedger_[address(this)]\n', '                    )\n', '                ) / magnitude;\n', '            uint256 rewards =\n', '                safeDiv(\n', '                    safeMul(_earlyadopterDividends, token_percent),\n', '                    1000000\n', '                );\n', '            return rewards;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    //To get user affiliate rewards\n', '    function getUserAffiliateBalance(address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return referralBalance_[_user];\n', '    }\n', '\n', "    //To retrieve the index of user's address\n", '    function getUserAddressIndex(address _customerAddress)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return userIndex[_customerAddress];\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividends from pre-minted tokens.\n', '     */\n', '    function _dividendsOfPremintedTokens(uint256 _tokens)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return (uint256)((int256)(profitPerShare_ * _tokens)) / magnitude;\n', '    }\n', '\n', '    //To calculate total dividends of user\n', '    function totalDividends(address _customerAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _dividends = _dividendsOf(_customerAddress);\n', '\n', '        uint256 qualifying_rewards;\n', '        if (\n', '            earlyadopters[_customerAddress] &&\n', '            (now > safeAdd(auctionExpiryTime, 24 hours))\n', '        ) {\n', '            if (tokenBalanceLedger_[_customerAddress] > 0) {\n', '                qualifying_rewards = safeAdd(\n', '                    qualifying_rewards,\n', '                    earlyAdopterBonus(_customerAddress)\n', '                );\n', '            } else {\n', '                qualifying_rewards = safeAdd(\n', '                    qualifying_rewards,\n', '                    earlyadopterBonus[_customerAddress]\n', '                );\n', '            }\n', '        }\n', '        if (\n', '            rewardQualifier[_customerAddress] &&\n', '            _calculateInflationMinutes() > 4320\n', '        ) {\n', '            if (tokenBalanceLedger_[_customerAddress] > 0) {\n', '                qualifying_rewards = safeAdd(\n', '                    qualifying_rewards,\n', '                    STYKRewards(_customerAddress)\n', '                );\n', '            } else {\n', '                qualifying_rewards = safeAdd(\n', '                    qualifying_rewards,\n', '                    stykRewards[_customerAddress]\n', '                );\n', '            }\n', '        }\n', '\n', '        if (totalMonthRewards[_customerAddress] != 0) {\n', '            qualifying_rewards = safeAdd(\n', '                qualifying_rewards,\n', '                totalMonthRewards[_customerAddress]\n', '            );\n', '        }\n', '\n', '        return (\n', '            safeAdd(\n', '                safeAdd(_dividends, qualifying_rewards),\n', '                referralBalance_[_customerAddress]\n', '            )\n', '        );\n', '    }\n', '\n', '    //To Claim Monthly Rewards\n', '    function claimMonthlyRewards() external {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require(_calculateMonthlyRewards(_customerAddress) > 0 ,"ERR_YOU_DONT_QUALIFY");\n', '        \n', '        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\n', '\n', '        require(\n', '            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\n', '            "ERR_CANNOT_CLAIM_BEFORE_PAYOUT"\n', '        );\n', '        \n', '        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],"ERR_REWARD_ALREADY_CLAIMED");\n', '        \n', '        if (_calculateTokenPercentage(_customerAddress) != 0) {\n', '            totalMonthRewards[_customerAddress] = safeAdd(\n', '                totalMonthRewards[_customerAddress],\n', '                _calculateMonthlyRewards(_customerAddress)\n', '            );\n', '            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\n', '        \n', '        }\n', '    }\n', '\n', '    //To release the pre-minted tokens after the lock time\n', '    function release() external {\n', '        require(now > lockTime, "ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME");\n', '\n', '        uint256 amount = tokenBalanceLedger_[address(this)];\n', '        tokenSupply_ = safeAdd(tokenSupply_, amount);\n', '    }\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        // data setup\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = safeDiv(_incomingEthereum, dividendFee_);\n', '        uint256 _referralBonus = safeDiv(_undividedDividends, 2);\n', '        uint256 _dividends = safeSub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum =\n', '            safeSub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        uint256 _fee = _dividends * magnitude;\n', '\n', '        require(\n', '            _amountOfTokens > 0 &&\n', '                (safeAdd(_amountOfTokens, tokenSupply_) > tokenSupply_)\n', '        );\n', '\n', '        // is the user referred by a karmalink?\n', '        if (\n', '            _referredBy != address(0) &&\n', '            // no cheating!\n', '            _referredBy != _customerAddress &&\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = safeAdd(\n', '                referralBalance_[_referredBy],\n', '                _referralBonus\n', '            );\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = safeAdd(_dividends, _referralBonus);\n', '            _fee = _dividends * magnitude;\n', '        }\n', '\n', '        // add tokens to the pool\n', '        tokenSupply_ = safeAdd(tokenSupply_, _amountOfTokens);\n', '\n', '        // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '        if (now > auctionExpiryTime) {\n', '            profitPerShare_ += ((_dividends * magnitude) /\n', '                safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\n', '        }\n', '        auctionProfitPerShare_ += ((_dividends * magnitude) /\n', '            safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)]));\n', '\n', '        // calculate the amount of tokens the customer receives over his purchase\n', '        _fee =\n', '            _fee -\n', '            (_fee -\n', '                (_amountOfTokens *\n', '                    ((_dividends * magnitude) /\n', '                        safeAdd(\n', '                            tokenSupply_,\n', '                            tokenBalanceLedger_[address(this)]\n', '                        ))));\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = safeAdd(\n', '            tokenBalanceLedger_[_customerAddress],\n', '            _amountOfTokens\n', '        );\n', '\n', '        if (\n', '            !userExists[_referredBy][_customerAddress] &&\n', '            _referredBy != address(0) &&\n', '            _referredBy != _customerAddress\n', '        ) {\n', '            userExists[_referredBy][_customerAddress] = true;\n', '            referralUsers[_referredBy].push(_customerAddress);\n', '        }\n', '\n', '        if (now <= auctionExpiryTime) {\n', '            if (\n', '                totalEthereumBalance() <= auctionEthLimit &&\n', '                safeAdd(totalEthereumBalance(), _incomingEthereum) <=\n', '                auctionEthLimit\n', '            ) {\n', '                if (!earlyadopters[_customerAddress]) {\n', '                    earlyadopters[_customerAddress] = true;\n', '                }\n', '                if (!auctionAddressTracker[_customerAddress]) {\n', '                    auctionAddressTracker[_customerAddress] = true;\n', '                }\n', '            }\n', '        }\n', '\n', '        if (auctionAddressTracker[_customerAddress]) {\n', '            int256 _updatedPayouts =\n', '                (int256)((auctionProfitPerShare_ * _amountOfTokens) - _fee);\n', '            payoutsTo_[_customerAddress] += _updatedPayouts;\n', '        } else {\n', '            int256 _updatedPayouts =\n', '                (int256)((profitPerShare_ * _amountOfTokens) - _fee);\n', '            payoutsTo_[_customerAddress] += _updatedPayouts;\n', '        }\n', '\n', '        if (!userAdded[_customerAddress]) {\n', '            userAddress.push(_customerAddress);\n', '            userAdded[_customerAddress] = true;\n', '            userIndex[_customerAddress] = userCount;\n', '            userCount++;\n', '        }\n', '\n', '        // fire event\n', '        emit onTokenPurchase(\n', '            _customerAddress,\n', '            _incomingEthereum,\n', '            _amountOfTokens,\n', '            _referredBy\n', '        );\n', '        if (now > auctionExpiryTime) {\n', '            if (inflationTime == 0 || _calculateInflationMinutes() > 4320)\n', '                setInflationTime();\n', '        }\n', '        emit Transfer(address(this), _customerAddress, _amountOfTokens);\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', "     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '            ((\n', '                // underflow attempts BTFO\n', '                safeSub(\n', '                    (\n', '                        sqrt(\n', '                            (_tokenPriceInitial**2) +\n', '                                (2 *\n', '                                    (tokenPriceIncremental_ * 1e18) *\n', '                                    (_ethereum * 1e18)) +\n', '                                (((tokenPriceIncremental_)**2) *\n', '                                    (tokenSupply_**2)) +\n', '                                (2 *\n', '                                    (tokenPriceIncremental_) *\n', '                                    _tokenPriceInitial *\n', '                                    tokenSupply_)\n', '                        )\n', '                    ),\n', '                    _tokenPriceInitial\n', '                )\n', '            ) / (tokenPriceIncremental_)) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * Calculate token sell value.\n', '     */\n', '    function tokensToEthereum_(uint256 _tokens)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _etherReceived =\n', '            (// underflow attempts BTFO\n', '            safeSub(\n', '                (((tokenPriceInitial_ +\n', '                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\n', '                    tokenPriceIncremental_) * (tokens_ - 1e18)),\n', '                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\n', '            ) / 1e18);\n', '        return _etherReceived;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/*================================================================================================================================\n', '                                      \n', '                                       CREDITS        \n', '    \n', '   credit goes to POWH, GANDHIJI, HEX, WISE & ECLIPSE CITY smart contracts" All charity work is inspired by BI Phakathi (Youtuber)\n', '  \n', '     \n', '================================================================================================================================*/']