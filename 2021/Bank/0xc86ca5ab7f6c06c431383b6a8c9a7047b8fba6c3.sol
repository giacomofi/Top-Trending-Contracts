['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '\n', 'interface ISorbettoFragola {\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '    \n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '\n', '    /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '    /// to the ERC20 specification\n', '    /// @return The address of the Uniswap V3 Pool\n', '    function pool() external view returns (IUniswapV3Pool);\n', '\n', '    /// @notice The lower tick of the range\n', '    function tickLower() external view returns (int24);\n', '\n', '    /// @notice The upper tick of the range\n', '    function tickUpper() external view returns (int24);\n', '\n', '    /**\n', "     * @notice Deposits tokens in proportion to the Sorbetto's current ticks.\n", '     * @param amount0Desired Max amount of token0 to deposit\n', '     * @param amount1Desired Max amount of token1 to deposit\n', '     * @return shares minted\n', '     * @return amount0 Amount of token0 deposited\n', '     * @return amount1 Amount of token1 deposited\n', '     */\n', '    function deposit(uint256 amount0Desired, uint256 amount1Desired) external payable returns (uint256 shares, uint256 amount0,uint256 amount1);\n', '\n', '    /**\n', "     * @notice Withdraws tokens in proportion to the Sorbetto's holdings.\n", '     * @dev Removes proportional amount of liquidity from Uniswap.\n', '     * @param shares burned by sender\n', '     * @return amount0 Amount of token0 sent to recipient\n', '     * @return amount1 Amount of token1 sent to recipient\n', '     */\n', '    function withdraw(uint256 shares) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /**\n', "     * @notice Updates sorbetto's positions.\n", '     * @dev Finds base position and limit position for imbalanced token\n', '     * mints all amounts to this position(including earned fees)\n', '     */\n', '    function rerange() external;\n', '\n', '    /**\n', "     * @notice Updates sorbetto's positions. Can only be called by the governance.\n", '     * @dev Swaps imbalanced token. Finds base position and limit position for imbalanced token if\n', "     * we don't have balance during swap because of price impact.\n", '     * mints all amounts to this position(including earned fees)\n', '     */\n', '    function rebalance() external;\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface ISorbettoStrategy {\n', '    /// @notice Period of time that we observe for price slippage\n', '    /// @return time in seconds\n', '    function twapDuration() external view returns (uint32);\n', '\n', '    /// @notice Maximum deviation of time waited avarage price in ticks\n', '    function maxTwapDeviation() external view returns (int24);\n', '\n', '    /// @notice Tick multuplier for base range calculation\n', '    function tickRangeMultiplier() external view returns (int24);\n', '\n', "    /// @notice The protocol's fee denominated in hundredths of a bip, i.e. 1e-6\n", '    /// @return The fee\n', '    function protocolFee() external view returns (uint24);\n', '\n', '    /// @notice The price impact percentage during swap denominated in hundredths of a bip, i.e. 1e-6\n', '    /// @return The max price impact percentage\n', '    function priceImpactPercentage() external view returns (uint24);\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'library PositionKey {\n', '    /// @dev Returns the key of the position in the core library\n', '    function compute(\n', '        address owner,\n', '        int24 tickLower,\n', '        int24 tickUpper\n', '    ) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Math library for computing sqrt prices from ticks and vice versa\n', '/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n', '/// prices between 2**-128 and 2**128\n', 'library TickMath {\n', '    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n', '    int24 internal constant MIN_TICK = -887272;\n', '    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n', '    int24 internal constant MAX_TICK = -MIN_TICK;\n', '\n', '    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n', '    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n', '    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n', '    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n', '\n', '    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n', '    /// @dev Throws if |tick| > max tick\n', '    /// @param tick The input tick for the above formula\n', '    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n', '    /// at the given tick\n', '    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n', '        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n', "        require(absTick <= uint256(MAX_TICK), 'T');\n", '\n', '        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n', '        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n', '        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n', '        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n', '        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n', '        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n', '        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n', '        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n', '        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n', '        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n', '        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n', '        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n', '        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n', '        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n', '        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n', '        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n', '        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n', '        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n', '        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n', '        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n', '\n', '        if (tick > 0) ratio = type(uint256).max / ratio;\n', '\n', '        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n', '        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n', '        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n', '        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n', '    }\n', '\n', '    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n', '    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n', '    /// ever return.\n', '    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n', '    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n', '    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n', '        // second inequality must be < because the price can never reach the price at the max tick\n', "        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n", '        uint256 ratio = uint256(sqrtPriceX96) << 32;\n', '\n', '        uint256 r = ratio;\n', '        uint256 msb = 0;\n', '\n', '        assembly {\n', '            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(5, gt(r, 0xFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(4, gt(r, 0xFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(3, gt(r, 0xFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(2, gt(r, 0xF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(1, gt(r, 0x3))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := gt(r, 0x1)\n', '            msb := or(msb, f)\n', '        }\n', '\n', '        if (msb >= 128) r = ratio >> (msb - 127);\n', '        else r = ratio << (127 - msb);\n', '\n', '        int256 log_2 = (int256(msb) - 128) << 64;\n', '\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(63, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(62, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(61, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(60, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(59, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(58, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(57, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(56, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(55, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(54, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(53, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(52, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(51, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(50, f))\n', '        }\n', '\n', '        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n', '\n', '        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n', '        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n', '\n', '        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '/// @title Liquidity amount functions\n', '/// @notice Provides functions for computing liquidity amounts from token amounts and prices\n', 'library LiquidityAmounts {\n', '    /// @notice Downcasts uint256 to uint128\n', '    /// @param x The uint258 to be downcasted\n', '    /// @return y The passed value, downcasted to uint128\n', '    function toUint128(uint256 x) private pure returns (uint128 y) {\n', '        require((y = uint128(x)) == x);\n', '    }\n', '\n', '    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n', '    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param amount0 The amount0 being sent in\n', '    /// @return liquidity The amount of returned liquidity\n', '    function getLiquidityForAmount0(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount0\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n', '        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n', '    }\n', '\n', '    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n', '    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param amount1 The amount1 being sent in\n', '    /// @return liquidity The amount of returned liquidity\n', '    function getLiquidityForAmount1(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount1\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n', '    }\n', '\n', '    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n', '    /// pool prices and the prices at the tick boundaries\n', '    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param amount0 The amount of token0 being sent in\n', '    /// @param amount1 The amount of token1 being sent in\n', '    /// @return liquidity The maximum amount of liquidity received\n', '    function getLiquidityForAmounts(\n', '        uint160 sqrtRatioX96,\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        if (sqrtRatioX96 <= sqrtRatioAX96) {\n', '            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n', '        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n', '            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n', '            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n', '\n', '            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n', '        } else {\n', '            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n', '        }\n', '    }\n', '\n', '    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param liquidity The liquidity being valued\n', '    /// @return amount0 The amount of token0\n', '    function getAmount0ForLiquidity(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount0) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        return\n', '            FullMath.mulDiv(\n', '                uint256(liquidity) << FixedPoint96.RESOLUTION,\n', '                sqrtRatioBX96 - sqrtRatioAX96,\n', '                sqrtRatioBX96\n', '            ) / sqrtRatioAX96;\n', '    }\n', '\n', '    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param liquidity The liquidity being valued\n', '    /// @return amount1 The amount of token1\n', '    function getAmount1ForLiquidity(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount1) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n', '    }\n', '\n', '    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n', '    /// pool prices and the prices at the tick boundaries\n', '    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n', '    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n', '    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n', '    /// @param liquidity The liquidity being valued\n', '    /// @return amount0 The amount of token0\n', '    /// @return amount1 The amount of token1\n', '    function getAmountsForLiquidity(\n', '        uint160 sqrtRatioX96,\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount0, uint256 amount1) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        if (sqrtRatioX96 <= sqrtRatioAX96) {\n', '            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n', '        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n', '            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n', '            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n', '        } else {\n', '            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Liquidity and ticks functions\n', '/// @notice Provides functions for computing liquidity and ticks for token amounts and prices\n', 'library PoolVariables {\n', '    using LowGasSafeMath for uint256;\n', '\n', '    // Cache struct for calculations\n', '    struct Info {\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0;\n', '        uint256 amount1;\n', '        uint128 liquidity;\n', '        int24 tickLower;\n', '        int24 tickUpper;\n', '    }\n', '\n', '    /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param liquidity  The liquidity being valued\n', '    /// @param _tickLower The lower tick of the range\n', '    /// @param _tickUpper The upper tick of the range\n', '    /// @return amounts of token0 and token1 that corresponds to liquidity\n', '    function amountsForLiquidity(\n', '        IUniswapV3Pool pool,\n', '        uint128 liquidity,\n', '        int24 _tickLower,\n', '        int24 _tickUpper\n', '    ) internal view returns (uint256, uint256) {\n', '        //Get current price from the pool\n', '        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n', '        return\n', '            LiquidityAmounts.getAmountsForLiquidity(\n', '                sqrtRatioX96,\n', '                TickMath.getSqrtRatioAtTick(_tickLower),\n', '                TickMath.getSqrtRatioAtTick(_tickUpper),\n', '                liquidity\n', '            );\n', '    }\n', '\n', '    /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param amount0 The amount of token0\n', '    /// @param amount1 The amount of token1\n', '    /// @param _tickLower The lower tick of the range\n', '    /// @param _tickUpper The upper tick of the range\n', '    /// @return The maximum amount of liquidity that can be held amount0 and amount1\n', '    function liquidityForAmounts(\n', '        IUniswapV3Pool pool,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        int24 _tickLower,\n', '        int24 _tickUpper\n', '    ) internal view returns (uint128) {\n', '        //Get current price from the pool\n', '        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();\n', '\n', '        return\n', '            LiquidityAmounts.getLiquidityForAmounts(\n', '                sqrtRatioX96,\n', '                TickMath.getSqrtRatioAtTick(_tickLower),\n', '                TickMath.getSqrtRatioAtTick(_tickUpper),\n', '                amount0,\n', '                amount1\n', '            );\n', '    }\n', '\n', '    /// @dev Amounts of token0 and token1 held in contract position.\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param _tickLower The lower tick of the range\n', '    /// @param _tickUpper The upper tick of the range\n', '    /// @return amount0 The amount of token0 held in position\n', '    /// @return amount1 The amount of token1 held in position\n', '    function positionAmounts(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper)\n', '        internal\n', '        view\n', '        returns (uint256 amount0, uint256 amount1)\n', '    {   \n', '        //Compute position key\n', '        bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);\n', '        //Get Position.Info for specified ticks\n', '        (uint128 liquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) =\n', '            pool.positions(positionKey);\n', '        // Calc amounts of token0 and token1 including fees\n', '        (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);\n', '        amount0 = amount0.add(uint256(tokensOwed0));\n', '        amount1 = amount1.add(uint256(tokensOwed1));\n', '    }\n', '\n', '    /// @dev Amount of liquidity in contract position.\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param _tickLower The lower tick of the range\n', '    /// @param _tickUpper The upper tick of the range\n', '    /// @return liquidity stored in position\n', '    function positionLiquidity(IUniswapV3Pool pool, int24 _tickLower, int24 _tickUpper)\n', '        internal\n', '        view\n', '        returns (uint128 liquidity)\n', '    {\n', '        //Compute position key\n', '        bytes32 positionKey = PositionKey.compute(address(this), _tickLower, _tickUpper);\n', '        //Get liquidity stored in position\n', '        (liquidity, , , , ) = pool.positions(positionKey);\n', '    }\n', '\n', '    /// @dev Common checks for valid tick inputs.\n', '    /// @param tickLower The lower tick of the range\n', '    /// @param tickUpper The upper tick of the range\n', '    function checkRange(int24 tickLower, int24 tickUpper) internal pure {\n', '        require(tickLower < tickUpper, "TLU");\n', '        require(tickLower >= TickMath.MIN_TICK, "TLM");\n', '        require(tickUpper <= TickMath.MAX_TICK, "TUM");\n', '    }\n', '\n', "    /// @dev Rounds tick down towards negative infinity so that it's a multiple\n", '    /// of `tickSpacing`.\n', '    function floor(int24 tick, int24 tickSpacing) internal pure returns (int24) {\n', '        int24 compressed = tick / tickSpacing;\n', '        if (tick < 0 && tick % tickSpacing != 0) compressed--;\n', '        return compressed * tickSpacing;\n', '    }\n', '\n', '    /// @dev Gets ticks with proportion equivalent to desired amount\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param amount0Desired The desired amount of token0\n', '    /// @param amount1Desired The desired amount of token1\n', '    /// @param baseThreshold The range for upper and lower ticks\n', '    /// @param tickSpacing The pool tick spacing\n', '    /// @return tickLower The lower tick of the range\n', '    /// @return tickUpper The upper tick of the range\n', '    function getPositionTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 baseThreshold, int24 tickSpacing) internal view returns(int24 tickLower, int24 tickUpper) {\n', '        Info memory cache = \n', '            Info(amount0Desired, amount1Desired, 0, 0, 0, 0, 0);\n', '        // Get current price and tick from the pool\n', '        ( uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n', '        //Calc base ticks \n', '        (cache.tickLower, cache.tickUpper) = baseTicks(currentTick, baseThreshold, tickSpacing);\n', '        //Calc amounts of token0 and token1 that can be stored in base range\n', '        (cache.amount0, cache.amount1) = amountsForTicks(pool, cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n', '        //Liquidity that can be stored in base range\n', '        cache.liquidity = liquidityForAmounts(pool, cache.amount0, cache.amount1, cache.tickLower, cache.tickUpper);\n', '        //Get imbalanced token\n', '        bool zeroGreaterOne = amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n', '        //Calc new tick(upper or lower) for imbalanced token\n', '        if ( zeroGreaterOne) {\n', '            uint160 nextSqrtPrice0 = SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp(sqrtPriceX96, cache.liquidity, cache.amount0Desired, false);\n', '            cache.tickUpper = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice0), tickSpacing);\n', '        }\n', '        else{\n', '            uint160 nextSqrtPrice1 = SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown(sqrtPriceX96, cache.liquidity, cache.amount1Desired, false);\n', '            cache.tickLower = PoolVariables.floor(TickMath.getTickAtSqrtRatio(nextSqrtPrice1), tickSpacing);\n', '        }\n', '        checkRange(cache.tickLower, cache.tickUpper);\n', '        \n', '        tickLower = cache.tickLower;\n', '        tickUpper = cache.tickUpper;\n', '    }\n', '\n', '    /// @dev Gets amounts of token0 and token1 that can be stored in range of upper and lower ticks\n', '    /// @param pool Uniswap V3 pool\n', '    /// @param amount0Desired The desired amount of token0\n', '    /// @param amount1Desired The desired amount of token1\n', '    /// @param _tickLower The lower tick of the range\n', '    /// @param _tickUpper The upper tick of the range\n', '    /// @return amount0 amounts of token0 that can be stored in range\n', '    /// @return amount1 amounts of token1 that can be stored in range\n', '    function amountsForTicks(IUniswapV3Pool pool, uint256 amount0Desired, uint256 amount1Desired, int24 _tickLower, int24 _tickUpper) internal view returns(uint256 amount0, uint256 amount1) {\n', '        uint128 liquidity = liquidityForAmounts(pool, amount0Desired, amount1Desired, _tickLower, _tickUpper);\n', '\n', '        (amount0, amount1) = amountsForLiquidity(pool, liquidity, _tickLower, _tickUpper);\n', '    }\n', '\n', '    /// @dev Calc base ticks depending on base threshold and tickspacing\n', '    function baseTicks(int24 currentTick, int24 baseThreshold, int24 tickSpacing) internal pure returns(int24 tickLower, int24 tickUpper) {\n', '        \n', '        int24 tickFloor = floor(currentTick, tickSpacing);\n', '\n', '        tickLower = tickFloor - baseThreshold;\n', '        tickUpper = tickFloor + baseThreshold;\n', '    }\n', '\n', '    /// @dev Get imbalanced token\n', '    /// @param amount0Desired The desired amount of token0\n', '    /// @param amount1Desired The desired amount of token1\n', '    /// @param amount0 Amounts of token0 that can be stored in base range\n', '    /// @param amount1 Amounts of token1 that can be stored in base range\n', '    /// @return zeroGreaterOne true if token0 is imbalanced. False if token1 is imbalanced\n', '    function amountsDirection(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0, uint256 amount1) internal pure returns (bool zeroGreaterOne) {\n', '        zeroGreaterOne =  amount0Desired.sub(amount0).mul(amount1Desired) > amount1Desired.sub(amount1).mul(amount0Desired) ?  true : false;\n', '    }\n', '\n', '    // Check price has not moved a lot recently. This mitigates price\n', '    // manipulation during rebalance and also prevents placing orders\n', "    // when it's too volatile.\n", '    function checkDeviation(IUniswapV3Pool pool, int24 maxTwapDeviation, uint32 twapDuration) internal view {\n', '        (, int24 currentTick, , , , , ) = pool.slot0();\n', '        int24 twap = getTwap(pool, twapDuration);\n', '        int24 deviation = currentTick > twap ? currentTick - twap : twap - currentTick;\n', '        require(deviation <= maxTwapDeviation, "PSC");\n', '    }\n', '\n', '    /// @dev Fetches time-weighted average price in ticks from Uniswap pool for specified duration\n', '    function getTwap(IUniswapV3Pool pool, uint32 twapDuration) internal view returns (int24) {\n', '        uint32 _twapDuration = twapDuration;\n', '        uint32[] memory secondsAgo = new uint32[](2);\n', '        secondsAgo[0] = _twapDuration;\n', '        secondsAgo[1] = 0;\n', '\n', '        (int56[] memory tickCumulatives, ) = pool.observe(secondsAgo);\n', '        return int24((tickCumulatives[1] - tickCumulatives[0]) / _twapDuration);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissionless pool actions\n', '/// @notice Contains pool methods that can be called by anyone\n', 'interface IUniswapV3PoolActions {\n', '\n', '    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n', '    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n', '    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n', '    /// @param recipient The address for which the liquidity will be created\n', '    /// @param tickLower The lower tick of the position in which to add liquidity\n', '    /// @param tickUpper The upper tick of the position in which to add liquidity\n', '    /// @param amount The amount of liquidity to mint\n', '    /// @param data Any data that should be passed through to the callback\n', '    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    function mint(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount,\n', '        bytes calldata data\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Collects tokens owed to a position\n', '    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n', '    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n', '    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n', '    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n', '    /// @param recipient The address which should receive the fees collected\n', '    /// @param tickLower The lower tick of the position for which to collect fees\n', '    /// @param tickUpper The upper tick of the position for which to collect fees\n', '    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n', '    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '\n', '    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n', '    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n', '    /// @dev Fees must be collected separately via a call to #collect\n', '    /// @param tickLower The lower tick of the position for which to burn liquidity\n', '    /// @param tickUpper The upper tick of the position for which to burn liquidity\n', '    /// @param amount How much liquidity to burn\n', '    /// @return amount0 The amount of token0 sent to the recipient\n', '    /// @return amount1 The amount of token1 sent to the recipient\n', '    function burn(\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Swap token0 for token1, or token1 for token0\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n', '    /// @param recipient The address to receive the output of the swap\n', '    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n', '    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n', '    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n', '    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n', '    /// @param data Any data to be passed through to the callback\n', '    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n', '    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n', '    function swap(\n', '        address recipient,\n', '        bool zeroForOne,\n', '        int256 amountSpecified,\n', '        uint160 sqrtPriceLimitX96,\n', '        bytes calldata data\n', '    ) external returns (int256 amount0, int256 amount1);\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '    /// you must call it with secondsAgos = [3600, 0].\n', '    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '    /// timestamp\n', '    function observe(uint32[] calldata secondsAgos)\n', '        external\n', '        view\n', '        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that can change\n', "/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n", '/// per transaction\n', 'interface IUniswapV3PoolState {\n', '    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n', '    /// when accessed externally.\n', '    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n', '    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n', '    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n', '    /// boundary.\n', '    /// observationIndex The index of the last oracle observation that was written,\n', '    /// observationCardinality The current maximum number of observations stored in the pool,\n', '    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n', '    /// feeProtocol The protocol fee for both tokens of the pool.\n', '    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n', '    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n', '    /// unlocked Whether the pool is currently locked to reentrancy\n', '    function slot0()\n', '        external\n', '        view\n', '        returns (\n', '            uint160 sqrtPriceX96,\n', '            int24 tick,\n', '            uint16 observationIndex,\n', '            uint16 observationCardinality,\n', '            uint16 observationCardinalityNext,\n', '            uint8 feeProtocol,\n', '            bool unlocked\n', '        );\n', '\n', "    /// @notice Returns the information about a position by the position's key\n", "    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n", '    /// @return _liquidity The amount of liquidity in the position,\n', '    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n', '    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n', '    function positions(bytes32 key)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 _liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '\n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title The interface for a Uniswap V3 Pool\n', '/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '/// to the ERC20 specification\n', '/// @dev The pool interface is broken up into many smaller pieces\n', 'interface IUniswapV3Pool is\n', '    IUniswapV3PoolImmutables,\n', '    IUniswapV3PoolState,\n', '    IUniswapV3PoolDerivedState,\n', '    IUniswapV3PoolActions\n', '{\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', '\n', '/// @title This library is created to conduct a variety of burn liquidity methods\n', 'library PoolActions {\n', '    using PoolVariables for IUniswapV3Pool;\n', '    using LowGasSafeMath for uint256;\n', '    using SafeCast for uint256;\n', '\n', '    /**\n', "     * @notice Withdraws liquidity in share proportion to the Sorbetto's totalSupply.\n", '     * @param pool Uniswap V3 pool\n', '     * @param tickLower The lower tick of the range\n', '     * @param tickUpper The upper tick of the range\n', '     * @param totalSupply The amount of total shares in existence\n', '     * @param share to burn\n', '     * @param to Recipient of amounts\n', '     * @return amount0 Amount of token0 withdrawed\n', '     * @return amount1 Amount of token1 withdrawed\n', '     */\n', '    function burnLiquidityShare(\n', '        IUniswapV3Pool pool,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint256 totalSupply,\n', '        uint256 share,\n', '        address to\n', '    ) internal returns (uint256 amount0, uint256 amount1) {\n', '        require(totalSupply > 0, "TS");\n', '        uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);\n', '        uint256 liquidity = uint256(liquidityInPool).mul(share) / totalSupply;\n', '        \n', '\n', '        if (liquidity > 0) {\n', '            (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());\n', '\n', '            if (amount0 > 0 || amount1 > 0) {\n', '            // collect liquidity share\n', '                (amount0, amount1) = pool.collect(\n', '                    to,\n', '                    tickLower,\n', '                    tickUpper,\n', '                    amount0.toUint128(),\n', '                    amount1.toUint128()\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraws exact amount of liquidity\n', '     * @param pool Uniswap V3 pool\n', '     * @param tickLower The lower tick of the range\n', '     * @param tickUpper The upper tick of the range\n', '     * @param liquidity to burn\n', '     * @param to Recipient of amounts\n', '     * @return amount0 Amount of token0 withdrawed\n', '     * @return amount1 Amount of token1 withdrawed\n', '     */\n', '    function burnExactLiquidity(\n', '        IUniswapV3Pool pool,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 liquidity,\n', '        address to\n', '    ) internal returns (uint256 amount0, uint256 amount1) {\n', '        uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);\n', '        require(liquidityInPool >= liquidity, "TML");\n', '        (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity);\n', '\n', '        if (amount0 > 0 || amount1 > 0) {\n', '            // collect liquidity share including earned fees\n', '            (amount0, amount0) = pool.collect(\n', '                to,\n', '                tickLower,\n', '                tickUpper,\n', '                amount0.toUint128(),\n', '                amount1.toUint128()\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraws all liquidity in a range from Uniswap pool\n', '     * @param pool Uniswap V3 pool\n', '     * @param tickLower The lower tick of the range\n', '     * @param tickUpper The upper tick of the range\n', '     */\n', '    function burnAllLiquidity(\n', '        IUniswapV3Pool pool,\n', '        int24 tickLower,\n', '        int24 tickUpper\n', '    ) internal {\n', '        \n', '        // Burn all liquidity in this range\n', '        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n', '        if (liquidity > 0) {\n', '            pool.burn(tickLower, tickUpper, liquidity);\n', '        }\n', '        \n', '         // Collect all owed tokens\n', '        pool.collect(\n', '            address(this),\n', '            tickLower,\n', '            tickUpper,\n', '            type(uint128).max,\n', '            type(uint128).max\n', '        );\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.4.0;\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'library Babylonian {\n', '    // credit for this implementation goes to\n', '    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n', '    function sqrt(uint256 x) internal pure returns (uint256) {\n', '        if (x == 0) return 0;\n', '        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n', '        // however that code costs significantly more gas\n', '        uint256 xx = x;\n', '        uint256 r = 1;\n', '        if (xx >= 0x100000000000000000000000000000000) {\n', '            xx >>= 128;\n', '            r <<= 64;\n', '        }\n', '        if (xx >= 0x10000000000000000) {\n', '            xx >>= 64;\n', '            r <<= 32;\n', '        }\n', '        if (xx >= 0x100000000) {\n', '            xx >>= 32;\n', '            r <<= 16;\n', '        }\n', '        if (xx >= 0x10000) {\n', '            xx >>= 16;\n', '            r <<= 8;\n', '        }\n', '        if (xx >= 0x100) {\n', '            xx >>= 8;\n', '            r <<= 4;\n', '        }\n', '        if (xx >= 0x10) {\n', '            xx >>= 4;\n', '            r <<= 2;\n', '        }\n', '        if (xx >= 0x8) {\n', '            r <<= 1;\n', '        }\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1;\n', '        r = (r + x / r) >> 1; // Seven iterations should be enough\n', '        uint256 r1 = x / r;\n', '        return (r < r1 ? r : r1);\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @title Counters\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', ' * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n', ' *\n', ' * Include with `using Counters for Counters.Counter;`\n', ' * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {LowGasSafeMAth}\n', ' * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', ' * directly accessed.\n', ' */\n', 'library Counters {\n', '    using LowGasSafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        // The {LowGasSafeMath} overflow check can be skipped here, see the comment at the top\n', '        counter._value += 1;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.7.0;\n', '\n', '/// @title Function for getting the current chain ID\n', 'library ChainId {\n', '    /// @dev Gets the current chain ID\n', '    /// @return chainId The current chain ID\n', '    function get() internal pure returns (uint256 chainId) {\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity =0.7.6;\n', '\n', '/**\n', ' * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n', ' *\n', ' * These functions can be used to verify that a message was signed by the holder\n', ' * of the private keys of a given address.\n', ' */\n', 'library ECDSA {\n', '    /**\n', '     * @dev Overload of {ECDSA-recover} that receives the `v`,\n', '     * `r` and `s` signature fields separately.\n', '     */\n', '    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n', '        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n', '        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n', '        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n', '        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n', '        //\n', '        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n', '        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n', '        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n', '        // these malleable signatures as well.\n', '        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ISS");\n', '        require(v == 27 || v == 28, "ISV");\n', '\n', '        // If the signature is valid (and not malleable), return the signer address\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer != address(0), "IS");\n', '\n', '        return signer;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an Ethereum Signed Typed Data, created from a\n', '     * `domainSeparator` and a `structHash`. This produces hash corresponding\n', '     * to the one signed with the\n', '     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n', '     * JSON-RPC method as part of EIP-712.\n', '     *\n', '     * See {recover}.\n', '     */\n', '    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '    }\n', '}\n', '\n', 'pragma solidity =0.7.6;\n', '\n', '\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n', ' *\n', ' * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n', ' * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n', ' * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n', ' *\n', ' * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n', ' * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n', ' * ({_hashTypedDataV4}).\n', ' *\n', ' * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n', ' * the chain id to protect against replay attacks on an eventual fork of the chain.\n', ' *\n', ' * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method\n', ' * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'abstract contract EIP712 {\n', '    /* solhint-disable var-name-mixedcase */\n', '    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n', '    // invalidate the cached domain separator if the chain id changes.\n', '    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n', '    uint256 private immutable _CACHED_CHAIN_ID;\n', '\n', '    bytes32 private immutable _HASHED_NAME;\n', '    bytes32 private immutable _HASHED_VERSION;\n', '    bytes32 private immutable _TYPE_HASH;\n', '    /* solhint-enable var-name-mixedcase */\n', '\n', '    /**\n', '     * @dev Initializes the domain separator and parameter caches.\n', '     *\n', '     * The meaning of `name` and `version` is specified in\n', '     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n', '     *\n', '     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n', '     * - `version`: the current major version of the signing domain.\n', '     *\n', '     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n', '     * contract upgrade].\n', '     */\n', '    constructor(string memory name, string memory version) {\n', '        bytes32 hashedName = keccak256(bytes(name));\n', '        bytes32 hashedVersion = keccak256(bytes(version));\n', '        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n', '        _HASHED_NAME = hashedName;\n', '        _HASHED_VERSION = hashedVersion;\n', '        _CACHED_CHAIN_ID = ChainId.get();\n', '        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n', '        _TYPE_HASH = typeHash;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the domain separator for the current chain.\n', '     */\n', '    function _domainSeparatorV4() internal view returns (bytes32) {\n', '        if (ChainId.get() == _CACHED_CHAIN_ID) {\n', '            return _CACHED_DOMAIN_SEPARATOR;\n', '        } else {\n', '            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n', '        }\n', '    }\n', '\n', '    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n', '        return keccak256(\n', '            abi.encode(\n', '                typeHash,\n', '                name,\n', '                version,\n', '                ChainId.get(),\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n', '     * function returns the hash of the fully encoded EIP712 message for this domain.\n', '     *\n', '     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n', '     *\n', '     * ```solidity\n', '     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n', '     *     keccak256("Mail(address to,string contents)"),\n', '     *     mailTo,\n', '     *     keccak256(bytes(mailContents))\n', '     * )));\n', '     * address signer = ECDSA.recover(digest, signature);\n', '     * ```\n', '     */\n', '    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n', '        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n', ' * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n', ' *\n', " * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n", " * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n", ' * need to send a transaction, and thus is not required to hold Ether at all.\n', ' */\n', 'interface IERC20Permit {\n', '    /**\n', "     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n", "     * given `owner`'s signed approval.\n", '     *\n', '     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n', '     * ordering also apply here.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `deadline` must be a timestamp in the future.\n', '     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n', '     * over the EIP712-formatted function arguments.\n', "     * - the signature must use ``owner``'s current nonce (see {nonces}).\n", '     *\n', '     * For more information on the signature format, see the\n', '     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n', '     * section].\n', '     */\n', '    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    /**\n', '     * @dev Returns the current nonce for `owner`. This value must be\n', '     * included whenever a signature is generated for {permit}.\n', '     *\n', "     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n", '     * prevents a signature from being used multiple times.\n', '     */\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n', '     */\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '}\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using LowGasSafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "TEA"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "DEB"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "FZA");\n', '        require(recipient != address(0), "TZA");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "TEB");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "MZA");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "BZA");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "BEB");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "AFZA");\n', '        require(spender != address(0), "ATZA");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal virtual {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', 'pragma solidity =0.7.6;\n', '\n', '/**\n', ' * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n', ' * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n', ' *\n', " * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n", " * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n", ' * need to send a transaction, and thus is not required to hold Ether at all.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n', '    using Counters for Counters.Counter;\n', '\n', '    mapping (address => Counters.Counter) private _nonces;\n', ' \n', '    //keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 private immutable _PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    /**\n', '     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.\n', '     *\n', "     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n", '     */\n', '    constructor(string memory name) EIP712(name, "1") {\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20Permit-permit}.\n', '     */\n', '    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(block.timestamp <= deadline, "ED");\n', '\n', '        bytes32 structHash = keccak256(\n', '            abi.encode(\n', '                _PERMIT_TYPEHASH,\n', '                owner,\n', '                spender,\n', '                value,\n', '                _useNonce(owner),\n', '                deadline\n', '            )\n', '        );\n', '\n', '        bytes32 hash = _hashTypedDataV4(structHash);\n', '\n', '        address signer = ECDSA.recover(hash, v, r, s);\n', '        require(signer == owner, "IS");\n', '\n', '        _approve(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20Permit-nonces}.\n', '     */\n', '    function nonces(address owner) public view virtual override returns (uint256) {\n', '        return _nonces[owner].current();\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n', '     */\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n', '        return _domainSeparatorV4();\n', '    }\n', '\n', '    /**\n', '     * @dev "Consume a nonce": return the current value and increment.\n', '     */\n', '    function _useNonce(address owner) internal virtual returns (uint256 current) {\n', '        Counters.Counter storage nonce = _nonces[owner];\n', '        current = nonce.current();\n', '        nonce.increment();\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.4.0;\n', '\n', '/// @title FixedPoint96\n', '/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n', '/// @dev Used in SqrtPriceMath.sol\n', 'library FixedPoint96 {\n', '    uint8 internal constant RESOLUTION = 96;\n', '    uint256 internal constant Q96 = 0x1000000000000000000000000;\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Math functions that do not check inputs or outputs\n', '/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\n', 'library UnsafeMath {\n', '    /// @notice Returns ceil(x / y)\n', '    /// @dev division by 0 has unspecified behavior, and must be checked externally\n', '    /// @param x The dividend\n', '    /// @param y The divisor\n', '    /// @return z The quotient, ceil(x / y)\n', '    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assembly {\n', '            z := add(div(x, y), gt(mod(x, y), 0))\n', '        }\n', '    }\n', '\n', '    /// @notice Returns floor(x / y)\n', '    /// @dev division by 0 has unspecified behavior, and must be checked externally\n', '    /// @param x The dividend\n', '    /// @param y The divisor\n', '    /// @return z The quotient, floor(x / y)\n', '    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assembly {\n', '            z := div(x, y)\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.4.0;\n', '\n', '/// @title Contains 512-bit math functions\n', '/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n', '/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n', 'library FullMath {\n', '    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n', '    function mulDiv(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        // 512-bit multiply [prod1 prod0] = a * b\n', '        // Compute the product mod 2**256 and mod 2**256 - 1\n', '        // then use the Chinese Remainder Theorem to reconstruct\n', '        // the 512 bit result. The result is stored in two 256\n', '        // variables such that product = prod1 * 2**256 + prod0\n', '        uint256 prod0; // Least significant 256 bits of the product\n', '        uint256 prod1; // Most significant 256 bits of the product\n', '        assembly {\n', '            let mm := mulmod(a, b, not(0))\n', '            prod0 := mul(a, b)\n', '            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n', '        }\n', '\n', '        // Handle non-overflow cases, 256 by 256 division\n', '        if (prod1 == 0) {\n', '            require(denominator > 0);\n', '            assembly {\n', '                result := div(prod0, denominator)\n', '            }\n', '            return result;\n', '        }\n', '\n', '        // Make sure the result is less than 2**256.\n', '        // Also prevents denominator == 0\n', '        require(denominator > prod1);\n', '\n', '        ///////////////////////////////////////////////\n', '        // 512 by 256 division.\n', '        ///////////////////////////////////////////////\n', '\n', '        // Make division exact by subtracting the remainder from [prod1 prod0]\n', '        // Compute remainder using mulmod\n', '        uint256 remainder;\n', '        assembly {\n', '            remainder := mulmod(a, b, denominator)\n', '        }\n', '        // Subtract 256 bit number from 512 bit number\n', '        assembly {\n', '            prod1 := sub(prod1, gt(remainder, prod0))\n', '            prod0 := sub(prod0, remainder)\n', '        }\n', '\n', '        // Factor powers of two out of denominator\n', '        // Compute largest power of two divisor of denominator.\n', '        // Always >= 1.\n', '        uint256 twos = -denominator & denominator;\n', '        // Divide denominator by power of two\n', '        assembly {\n', '            denominator := div(denominator, twos)\n', '        }\n', '\n', '        // Divide [prod1 prod0] by the factors of two\n', '        assembly {\n', '            prod0 := div(prod0, twos)\n', '        }\n', '        // Shift in bits from prod1 into prod0. For this we need\n', '        // to flip `twos` such that it is 2**256 / twos.\n', '        // If twos is zero, then it becomes one\n', '        assembly {\n', '            twos := add(div(sub(0, twos), twos), 1)\n', '        }\n', '        prod0 |= prod1 * twos;\n', '\n', '        // Invert denominator mod 2**256\n', '        // Now that denominator is an odd number, it has an inverse\n', '        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n', '        // Compute the inverse by starting with a seed that is correct\n', '        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n', '        uint256 inv = (3 * denominator) ^ 2;\n', '        // Now use Newton-Raphson iteration to improve the precision.\n', "        // Thanks to Hensel's lifting lemma, this also works in modular\n", '        // arithmetic, doubling the correct bits in each step.\n', '        inv *= 2 - denominator * inv; // inverse mod 2**8\n', '        inv *= 2 - denominator * inv; // inverse mod 2**16\n', '        inv *= 2 - denominator * inv; // inverse mod 2**32\n', '        inv *= 2 - denominator * inv; // inverse mod 2**64\n', '        inv *= 2 - denominator * inv; // inverse mod 2**128\n', '        inv *= 2 - denominator * inv; // inverse mod 2**256\n', '\n', '        // Because the division is now exact we can divide by multiplying\n', '        // with the modular inverse of denominator. This will give us the\n', '        // correct result modulo 2**256. Since the precoditions guarantee\n', '        // that the outcome is less than 2**256, this is the final result.\n', "        // We don't need to compute the high bits of the result and prod1\n", '        // is no longer required.\n', '        result = prod0 * inv;\n', '        return result;\n', '    }\n', '\n', '    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    function mulDivRoundingUp(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        result = mulDiv(a, b, denominator);\n', '        if (mulmod(a, b, denominator) > 0) {\n', '            require(result < type(uint256).max);\n', '            result++;\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Safe casting methods\n', '/// @notice Contains methods for safely casting between types\n', 'library SafeCast {\n', '    /// @notice Cast a uint256 to a uint160, revert on overflow\n', '    /// @param y The uint256 to be downcasted\n', '    /// @return z The downcasted integer, now type uint160\n', '    function toUint160(uint256 y) internal pure returns (uint160 z) {\n', '        require((z = uint160(y)) == y);\n', '    }\n', '\n', '    /// @notice Cast a uint256 to a uint128, revert on overflow\n', '    /// @param y The uint256 to be downcasted\n', '    /// @return z The downcasted integer, now type uint128\n', '    function toUint128(uint256 y) internal pure returns (uint128 z) {\n', '        require((z = uint128(y)) == y);\n', '    }\n', '\n', '    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n', '    /// @param y The int256 to be downcasted\n', '    /// @return z The downcasted integer, now type int128\n', '    function toInt128(int256 y) internal pure returns (int128 z) {\n', '        require((z = int128(y)) == y);\n', '    }\n', '\n', '    /// @notice Cast a uint256 to a int256, revert on overflow\n', '    /// @param y The uint256 to be casted\n', '    /// @return z The casted integer, now type int256\n', '    function toInt256(uint256 y) internal pure returns (int256 z) {\n', '        require(y < 2**255);\n', '        z = int256(y);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.7.0;\n', '\n', '/// @title Optimized overflow and underflow safe math operations\n', '/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\n', 'library LowGasSafeMath {\n', '    /// @notice Returns x + y, reverts if sum overflows uint256\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    /// @notice Returns x * y, reverts if overflows\n', '    /// @param x The multiplicand\n', '    /// @param y The multiplier\n', '    /// @return z The product of x and y\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(x == 0 || (z = x * y) / x == y);\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub(uint256 x, uint256 y, string memory errorMessage) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, errorMessage);\n', '    }\n', '\n', '    /// @notice Returns x + y, reverts if overflows or underflows\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add(int256 x, int256 y) internal pure returns (int256 z) {\n', '        require((z = x + y) >= x == (y >= 0));\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if overflows or underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n', '        require((z = x - y) <= x == (y >= 0));\n', '    }\n', '\n', '    /// @notice Returns x + y, reverts if sum overflows uint128\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    /// @notice Returns x * y, reverts if overflows\n', '    /// @param x The multiplicand\n', '    /// @param y The multiplier\n', '    /// @return z The product of x and y\n', '    function mul128(uint128 x, uint128 y) internal pure returns (uint128 z) {\n', '        require(x == 0 || (z = x * y) / x == y);\n', '    }\n', '\n', '    /// @notice Returns x + y, reverts if sum overflows uint128\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add160(uint160 x, uint160 y) internal pure returns (uint160 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub160(uint160 x, uint160 y) internal pure returns (uint160 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    /// @notice Returns x * y, reverts if overflows\n', '    /// @param x The multiplicand\n', '    /// @param y The multiplier\n', '    /// @return z The product of x and y\n', '    function mul160(uint160 x, uint160 y) internal pure returns (uint160 z) {\n', '        require(x == 0 || (z = x * y) / x == y);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Functions based on Q64.96 sqrt price and liquidity\n', '/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\n', 'library SqrtPriceMath {\n', '    using LowGasSafeMath for uint256;\n', '    using SafeCast for uint256;\n', '\n', '    /// @notice Gets the next sqrt price given a delta of token0\n', '    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n', '    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n', '    /// price less in order to not send too much output.\n', '    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n', '    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n', '    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amount How much of token0 to add or remove from virtual reserves\n', '    /// @param add Whether to add or remove the amount of token0\n', '    /// @return The price after adding or removing amount, depending on add\n', '    function getNextSqrtPriceFromAmount0RoundingUp(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amount,\n', '        bool add\n', '    ) internal pure returns (uint160) {\n', '        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n', '        if (amount == 0) return sqrtPX96;\n', '        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n', '\n', '        if (add) {\n', '            uint256 product;\n', '            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n', '                uint256 denominator = numerator1 + product;\n', '                if (denominator >= numerator1)\n', '                    // always fits in 160 bits\n', '                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n', '            }\n', '\n', '            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n', '        } else {\n', '            uint256 product;\n', '            // if the product overflows, we know the denominator underflows\n', '            // in addition, we must check that the denominator does not underflow\n', '            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n', '            uint256 denominator = numerator1 - product;\n', '            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n', '        }\n', '    }\n', '\n', '    /// @notice Gets the next sqrt price given a delta of token1\n', '    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n', '    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n', '    /// price less in order to not send too much output.\n', '    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n', '    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amount How much of token1 to add, or remove, from virtual reserves\n', '    /// @param add Whether to add, or remove, the amount of token1\n', '    /// @return The price after adding or removing `amount`\n', '    function getNextSqrtPriceFromAmount1RoundingDown(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amount,\n', '        bool add\n', '    ) internal pure returns (uint160) {\n', "        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n", '        // in both cases, avoid a mulDiv for most inputs\n', '        if (add) {\n', '            uint256 quotient =\n', '                (\n', '                    amount <= type(uint160).max\n', '                        ? (amount << FixedPoint96.RESOLUTION) / liquidity\n', '                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n', '                );\n', '\n', '            return uint256(sqrtPX96).add(quotient).toUint160();\n', '        } else {\n', '            uint256 quotient =\n', '                (\n', '                    amount <= type(uint160).max\n', '                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n', '                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n', '                );\n', '\n', '            require(sqrtPX96 > quotient);\n', '            // always fits 160 bits\n', '            return uint160(sqrtPX96 - quotient);\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.6.0;\n', '\n', '\n', 'library TransferHelper {\n', '    /// @notice Transfers tokens from the targeted address to the given destination\n', "    /// @notice Errors with 'STF' if transfer fails\n", '    /// @param token The contract address of the token to be transferred\n', '    /// @param from The originating address from which the tokens will be transferred\n', '    /// @param to The destination address of the transfer\n', '    /// @param value The amount to be transferred\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n", '    }\n', '\n', '    /// @notice Transfers tokens from msg.sender to a recipient\n', '    /// @dev Errors with ST if transfer fails\n', '    /// @param token The contract address of the token which will be transferred\n', '    /// @param to The recipient of the transfer\n', '    /// @param value The value of the transfer\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n", '    }\n', '\n', '    /// @notice Transfers ETH to the recipient address\n', '    /// @dev Fails with `STE`\n', '    /// @param to The destination of the transfer\n', '    /// @param value The value to be transferred\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'STE');\n", '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "RC");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'pragma solidity =0.7.6;\n', '\n', '\n', '/// @title Interface for WETH9\n', 'interface IWETH9 is IERC20 {\n', '    /// @notice Deposit ether to get wrapped ether\n', '    function deposit() external payable;\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '/// @title Sorbetto Fragola is a yield enchancement v3 contract\n', '/// @dev Sorbetto fragola is a Uniswap V3 yield enchancement contract which acts as\n', '/// intermediary between the user who wants to provide liquidity to specific pools\n', '/// and earn fees from such actions. The contract ensures that user position is in \n', '/// range and earns maximum amount of fees available at current liquidity utilization\n', '/// rate. \n', 'contract SorbettoFragola is ERC20Permit, ReentrancyGuard, ISorbettoFragola {\n', '    using LowGasSafeMath for uint256;\n', '    using LowGasSafeMath for uint160;\n', '    using LowGasSafeMath for uint128;\n', '    using UnsafeMath for uint256;\n', '    using SafeCast for uint256;\n', '    using PoolVariables for IUniswapV3Pool;\n', '    using PoolActions for IUniswapV3Pool;\n', '    \n', '    //Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n', '    struct MintCallbackData {\n', '        address payer;\n', '    }\n', '    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n', '    struct SwapCallbackData {\n', '        bool zeroForOne;\n', '    }\n', '    // Info of each user\n', '    struct UserInfo {\n', '        uint256 token0Rewards; // The amount of fees in token 0\n', '        uint256 token1Rewards; // The amount of fees in token 1\n', '        uint256 token0PerSharePaid; // Token 0 reward debt \n', '        uint256 token1PerSharePaid; // Token 1 reward debt\n', '    }\n', '\n', '    /// @notice Emitted when user adds liquidity\n', '    /// @param sender The address that minted the liquidity\n', '    /// @param liquidity The amount of liquidity added by the user to position\n', '    /// @param amount0 How much token0 was required for the added liquidity\n', '    /// @param amount1 How much token1 was required for the added liquidity\n', '    event Deposit(\n', '        address indexed sender,\n', '        uint256 liquidity,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '    \n', '    /// @notice Emitted when user withdraws liquidity\n', '    /// @param sender The address that minted the liquidity\n', '    /// @param shares of liquidity withdrawn by the user from the position\n', '    /// @param amount0 How much token0 was required for the added liquidity\n', '    /// @param amount1 How much token1 was required for the added liquidity\n', '    event Withdraw(\n', '        address indexed sender,\n', '        uint256 shares,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '    \n', '    /// @notice Emitted when fees was collected from the pool\n', '    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n', '    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n', '    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n', '    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n', '    event CollectFees(\n', '        uint256 feesFromPool0,\n', '        uint256 feesFromPool1,\n', '        uint256 usersFees0,\n', '        uint256 usersFees1\n', '    );\n', '\n', '    /// @notice Emitted when sorbetto fragola changes the position in the pool\n', '    /// @param tickLower Lower price tick of the positon\n', '    /// @param tickUpper Upper price tick of the position\n', '    /// @param amount0 Amount of token 0 deposited to the position\n', '    /// @param amount1 Amount of token 1 deposited to the position\n', '    event Rerange(\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '    \n', '    /// @notice Emitted when user collects his fee share\n', '    /// @param sender User address\n', '    /// @param fees0 Exact amount of fees claimed by the users in terms of token 0 \n', '    /// @param fees1 Exact amount of fees claimed by the users in terms of token 1\n', '    event RewardPaid(\n', '        address indexed sender,\n', '        uint256 fees0,\n', '        uint256 fees1\n', '    );\n', '    \n', "    /// @notice Shows current Sorbetto's balances\n", "    /// @param totalAmount0 Current token0 Sorbetto's balance\n", "    /// @param totalAmount1 Current token1 Sorbetto's balance\n", '    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n', '\n', '    event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);\n', '    \n', '    /// @notice Prevents calls from users\n', '    modifier onlyGovernance {\n', '        require(msg.sender == governance, "OG");\n', '        _;\n', '    }\n', '    \n', '    mapping(address => UserInfo) public userInfo; // Info of each user that provides liquidity tokens.\n', '    /// @inheritdoc ISorbettoFragola\n', '    address public immutable override token0;\n', '    /// @inheritdoc ISorbettoFragola\n', '    address public immutable override token1;\n', '    // WETH address\n', '    address public immutable weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    // @inheritdoc ISorbettoFragola\n', '    int24 public immutable override tickSpacing;\n', '    uint24 immutable GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n', '\n', '    // @inheritdoc ISorbettoFragola\n', '    IUniswapV3Pool public override pool;\n', '    // Accrued protocol fees in terms of token0\n', '    uint256 public accruedProtocolFees0;\n', '    // Accrued protocol fees in terms of token1\n', '    uint256 public accruedProtocolFees1;\n', '    // Total lifetime accrued users fees in terms of token0\n', '    uint256 public usersFees0;\n', '    // Total lifetime accrued users fees in terms of token1\n', '    uint256 public usersFees1;\n', '    // intermediate variable for user fee token0 calculation\n', '    uint256 public token0PerShareStored;\n', '    // intermediate variable for user fee token1 calculation\n', '    uint256 public token1PerShareStored;\n', '    \n', "    // Address of the Sorbetto's owner\n", '    address public governance;\n', '    // Pending to claim ownership address\n', '    address public pendingGovernance;\n', '    //Sorbetto fragola settings address\n', '    address public strategy;\n', '    // Current tick lower of sorbetto pool position\n', '    int24 public override tickLower;\n', '    // Current tick higher of sorbetto pool position\n', '    int24 public override tickUpper;\n', '    // Checks if sorbetto is initialized\n', '    bool public finalized;\n', '    \n', '    /**\n', '     * @dev After deploying, strategy can be set via `setStrategy()`\n', '     * @param _pool Underlying Uniswap V3 pool with fee = 3000\n', '     * @param _strategy Underlying Sorbetto Strategy for Sorbetto settings\n', '     */\n', '     constructor(\n', '        address _pool,\n', '        address _strategy\n', '    ) ERC20("Popsicle LP V3 USDC/USDT", "PLP") ERC20Permit("Popsicle LP V3 USDC/USDT") {\n', '        pool = IUniswapV3Pool(_pool);\n', '        strategy = _strategy;\n', '        token0 = pool.token0();\n', '        token1 = pool.token1();\n', '        tickSpacing = pool.tickSpacing();\n', '        governance = msg.sender;\n', '    }\n', '    //initialize strategy\n', '    function init() external onlyGovernance {\n', '        require(!finalized, "F");\n', '        finalized = true;\n', '        int24 baseThreshold = tickSpacing * ISorbettoStrategy(strategy).tickRangeMultiplier();\n', '        ( , int24 currentTick, , , , , ) = pool.slot0();\n', '        int24 tickFloor = PoolVariables.floor(currentTick, tickSpacing);\n', '        \n', '        tickLower = tickFloor - baseThreshold;\n', '        tickUpper = tickFloor + baseThreshold;\n', '        PoolVariables.checkRange(tickLower, tickUpper); //check ticks also for overflow/underflow\n', '    }\n', '    \n', '    /// @inheritdoc ISorbettoFragola\n', '     function deposit(\n', '        uint256 amount0Desired,\n', '        uint256 amount1Desired\n', '    )\n', '        external\n', '        payable\n', '        override\n', '        nonReentrant\n', '        checkDeviation\n', '        updateVault(msg.sender)\n', '        returns (\n', '            uint256 shares,\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        )\n', '    {\n', '        require(amount0Desired > 0 && amount1Desired > 0, "ANV");\n', '\n', '        // compute the liquidity amount\n', '        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n', '        \n', '        (amount0, amount1) = pool.mint(\n', '            address(this),\n', '            tickLower,\n', '            tickUpper,\n', '            liquidity,\n', '            abi.encode(MintCallbackData({payer: msg.sender})));\n', '\n', '        shares = _calcShare(liquidity);\n', '\n', '        _mint(msg.sender, shares);\n', '        refundETH();\n', '        emit Deposit(msg.sender, shares, amount0, amount1);\n', '    }\n', '    \n', '    /// @inheritdoc ISorbettoFragola\n', '    function withdraw(\n', '        uint256 shares\n', '    ) \n', '        external\n', '        override\n', '        nonReentrant\n', '        checkDeviation\n', '        updateVault(msg.sender)\n', '        returns (\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        )\n', '    {\n', '        require(shares > 0, "S");\n', '\n', '\n', '        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  msg.sender);\n', '        \n', '        // Burn shares\n', '        _burn(msg.sender, shares);\n', '        emit Withdraw(msg.sender, shares, amount0, amount1);\n', '    }\n', '    \n', '    /// @inheritdoc ISorbettoFragola\n', '    function rerange() external override nonReentrant checkDeviation updateVault(address(0)) {\n', '\n', "        //Burn all liquidity from pool to rerange for Sorbetto's balances.\n", '        pool.burnAllLiquidity(tickLower, tickUpper);\n', '        \n', '\n', '        // Emit snapshot to record balances\n', '        uint256 balance0 = _balance0();\n', '        uint256 balance1 = _balance1();\n', '        emit Snapshot(balance0, balance1);\n', '\n', '        int24 baseThreshold = tickSpacing * ISorbettoStrategy(strategy).tickRangeMultiplier();\n', '\n', "        //Get exact ticks depending on Sorbetto's balances\n", '        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n', '\n', "        //Get Liquidity for Sorbetto's balances\n", '        uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n', '        \n', '        // Add liquidity to the pool\n', '        (uint256 amount0, uint256 amount1) = pool.mint(\n', '            address(this),\n', '            tickLower,\n', '            tickUpper,\n', '            liquidity,\n', '            abi.encode(MintCallbackData({payer: address(this)})));\n', '        \n', '        emit Rerange(tickLower, tickUpper, amount0, amount1);\n', '    }\n', '\n', '    /// @inheritdoc ISorbettoFragola\n', '    function rebalance() external override onlyGovernance nonReentrant checkDeviation updateVault(address(0))  {\n', '\n', "        //Burn all liquidity from pool to rerange for Sorbetto's balances.\n", '        pool.burnAllLiquidity(tickLower, tickUpper);\n', '        \n', '        //Calc base ticks\n', '        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n', '        PoolVariables.Info memory cache = \n', '            PoolVariables.Info(0, 0, 0, 0, 0, 0, 0);\n', '        int24 baseThreshold = tickSpacing * ISorbettoStrategy(strategy).tickRangeMultiplier();\n', '        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);\n', '        \n', '        cache.amount0Desired = _balance0();\n', '        cache.amount1Desired = _balance1();\n', '        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n', '        // Calc liquidity for base ticks\n', '        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n', '\n', '        // Get exact amounts for base ticks\n', '        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);\n', '\n', '        // Get imbalanced token\n', '        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n', '        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio\n', '        int256 amountSpecified = \n', '            zeroForOne\n', '                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))\n', '                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. "overflow" safe convertion cuz we are dividing by 2\n', '\n', '        // Calculate Price limit depending on price impact\n', '        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(ISorbettoStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;\n', '        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);\n', '\n', "        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n", '        pool.swap(\n', '            address(this),\n', '            zeroForOne,\n', '            amountSpecified,\n', '            sqrtPriceLimitX96,\n', '            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n', '        );\n', '\n', '\n', '        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();\n', '\n', '        // Emit snapshot to record balances\n', '        cache.amount0Desired = _balance0();\n', '        cache.amount1Desired = _balance1();\n', '        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n', "        //Get exact ticks depending on Sorbetto's new balances\n", '        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);\n', '\n', '        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);\n', '\n', '        // Add liquidity to the pool\n', '        (cache.amount0, cache.amount1) = pool.mint(\n', '            address(this),\n', '            tickLower,\n', '            tickUpper,\n', '            cache.liquidity,\n', '            abi.encode(MintCallbackData({payer: address(this)})));\n', '        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);\n', '    }\n', '\n', '    // Calcs user share depending on deposited amounts\n', '    function _calcShare(uint128 liquidity)\n', '        internal\n', '        view\n', '        returns (\n', '            uint256 shares\n', '        )\n', '    {\n', '        shares = totalSupply() == 0 ? uint256(liquidity) : uint256(liquidity).mul(totalSupply()).unsafeDiv(uint256(pool.positionLiquidity(tickLower, tickUpper)));\n', '    }\n', '    \n', '    /// @dev Amount of token0 held as unused balance.\n', '    function _balance0() internal view returns (uint256) {\n', '        return IERC20(token0).balanceOf(address(this));\n', '    }\n', '\n', '    /// @dev Amount of token1 held as unused balance.\n', '    function _balance1() internal view returns (uint256) {\n', '        return IERC20(token1).balanceOf(address(this));\n', '    }\n', '    \n', '    /// @dev collects fees from the pool\n', '    function _earnFees() internal returns (uint256 userCollect0, uint256 userCollect1) {\n', '         // Do zero-burns to poke the Uniswap pools so earned fees are updated\n', '        pool.burn(tickLower, tickUpper, 0);\n', '        \n', '        (uint256 collect0, uint256 collect1) =\n', '            pool.collect(\n', '                address(this),\n', '                tickLower,\n', '                tickUpper,\n', '                type(uint128).max,\n', '                type(uint128).max\n', '            );\n', '\n', "        // Calculate protocol's and users share of fees\n", '        uint256 feeToProtocol0 = collect0.mul(ISorbettoStrategy(strategy).protocolFee()).unsafeDiv(GLOBAL_DIVISIONER);\n', '        uint256 feeToProtocol1 = collect1.mul(ISorbettoStrategy(strategy).protocolFee()).unsafeDiv(GLOBAL_DIVISIONER);\n', '        accruedProtocolFees0 = accruedProtocolFees0.add(feeToProtocol0);\n', '        accruedProtocolFees1 = accruedProtocolFees1.add(feeToProtocol1);\n', '        userCollect0 = collect0.sub(feeToProtocol0);\n', '        userCollect1 = collect1.sub(feeToProtocol1);\n', '        usersFees0 = usersFees0.add(userCollect0);\n', '        usersFees1 = usersFees1.add(userCollect1);\n', '        emit CollectFees(collect0, collect1, usersFees0, usersFees1);\n', '    }\n', '\n', "    /// @notice Returns current Sorbetto's position in pool\n", '    function position() external view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) {\n', '        bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);\n', '        (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1) = pool.positions(positionKey);\n', '    }\n', '    \n', '    /// @notice Pull in tokens from sender. Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n', '    /// @dev In the implementation you must pay to the pool for the minted liquidity.\n', '    /// @param amount0 The amount of token0 due to the pool for the minted liquidity\n', '    /// @param amount1 The amount of token1 due to the pool for the minted liquidity\n', '    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n', '    function uniswapV3MintCallback(\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external {\n', '        require(msg.sender == address(pool), "FP");\n', '        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n', '        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n', '        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n', '    }\n', '\n', '    /// @notice Called to `msg.sender` after minting swaping from IUniswapV3Pool#swap.\n', '    /// @dev In the implementation you must pay to the pool for swap.\n', '    /// @param amount0 The amount of token0 due to the pool for the swap\n', '    /// @param amount1 The amount of token1 due to the pool for the swap\n', '    /// @param _data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n', '    function uniswapV3SwapCallback(\n', '        int256 amount0,\n', '        int256 amount1,\n', '        bytes calldata _data\n', '    ) external {\n', '        require(msg.sender == address(pool), "FP");\n', '        require(amount0 > 0 || amount1 > 0); // swaps entirely within 0-liquidity regions are not supported\n', '        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n', '        bool zeroForOne = data.zeroForOne;\n', '\n', '        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n', '        else pay(token1, address(this), msg.sender, uint256(amount1));\n', '    }\n', '\n', '    /// @param token The token to pay\n', '    /// @param payer The entity that must pay\n', '    /// @param recipient The entity that will receive payment\n', '    /// @param value The amount to pay\n', '    function pay(\n', '        address token,\n', '        address payer,\n', '        address recipient,\n', '        uint256 value\n', '    ) internal {\n', '        if (token == weth && address(this).balance >= value) {\n', '            // pay with WETH9\n', '            IWETH9(weth).deposit{value: value}(); // wrap only what is needed to pay\n', '            IWETH9(weth).transfer(recipient, value);\n', '        } else if (payer == address(this)) {\n', '            // pay with tokens already in the contract (for the exact input multihop case)\n', '            TransferHelper.safeTransfer(token, recipient, value);\n', '        } else {\n', '            // pull payment\n', '            TransferHelper.safeTransferFrom(token, payer, recipient, value);\n', '        }\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @notice Used to withdraw accumulated protocol fees.\n', '     */\n', '    function collectProtocolFees(\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    ) external nonReentrant onlyGovernance updateVault(address(0)) {\n', '        require(accruedProtocolFees0 >= amount0, "A0F");\n', '        require(accruedProtocolFees1 >= amount1, "A1F");\n', '        \n', '        uint256 balance0 = _balance0();\n', '        uint256 balance1 = _balance1();\n', '        \n', '        if (balance0 >= amount0 && balance1 >= amount1)\n', '        {\n', '            if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n', '            if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n', '        }\n', '        else\n', '        {\n', '            uint128 liquidity = pool.liquidityForAmounts(amount0, amount1, tickLower, tickUpper);\n', '            pool.burnExactLiquidity(tickLower, tickUpper, liquidity, msg.sender);\n', '        \n', '        }\n', '        \n', '        accruedProtocolFees0 = accruedProtocolFees0.sub(amount0);\n', '        accruedProtocolFees1 = accruedProtocolFees1.sub(amount1);\n', '        emit RewardPaid(msg.sender, amount0, amount1);\n', '    }\n', '    \n', '    /**\n', "     * @notice Used to withdraw accumulated user's fees.\n", '     */\n', '    function collectFees(uint256 amount0, uint256 amount1) external nonReentrant updateVault(msg.sender) {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '\n', '        require(user.token0Rewards >= amount0, "A0R");\n', '        require(user.token1Rewards >= amount1, "A1R");\n', '\n', '        uint256 balance0 = _balance0();\n', '        uint256 balance1 = _balance1();\n', '\n', '        if (balance0 >= amount0 && balance1 >= amount1) {\n', '\n', '            if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n', '            if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n', '        }\n', '        else {\n', '            \n', '            uint128 liquidity = pool.liquidityForAmounts(amount0, amount1, tickLower, tickUpper);\n', '            (amount0, amount1) = pool.burnExactLiquidity(tickLower, tickUpper, liquidity, msg.sender);\n', '        }\n', '        user.token0Rewards = user.token0Rewards.sub(amount0);\n', '        user.token1Rewards = user.token1Rewards.sub(amount1);\n', '        emit RewardPaid(msg.sender, amount0, amount1);\n', '    }\n', '    \n', '    // Function modifier that calls update fees reward function\n', '    modifier updateVault(address account) {\n', '        _updateFeesReward(account);\n', '        _;\n', '    }\n', '\n', '    // Function modifier that checks if price has not moved a lot recently.\n', '    // This mitigates price manipulation during rebalance and also prevents placing orders\n', "    // when it's too volatile.\n", '    modifier checkDeviation() {\n', '        pool.checkDeviation(ISorbettoStrategy(strategy).maxTwapDeviation(), ISorbettoStrategy(strategy).twapDuration());\n', '        _;\n', '    }\n', '    \n', "    // Updates user's fees reward\n", '    function _updateFeesReward(address account) internal {\n', '        uint liquidity = pool.positionLiquidity(tickLower, tickUpper);\n', "        if (liquidity == 0) return; // we can't poke when liquidity is zero\n", '        (uint256 collect0, uint256 collect1) = _earnFees();\n', '        \n', '        \n', '        token0PerShareStored = _tokenPerShare(collect0, token0PerShareStored);\n', '        token1PerShareStored = _tokenPerShare(collect1, token1PerShareStored);\n', '\n', '        if (account != address(0)) {\n', '            UserInfo storage user = userInfo[msg.sender];\n', '            user.token0Rewards = _fee0Earned(account, token0PerShareStored);\n', '            user.token0PerSharePaid = token0PerShareStored;\n', '            \n', '            user.token1Rewards = _fee1Earned(account, token1PerShareStored);\n', '            user.token1PerSharePaid = token1PerShareStored;\n', '        }\n', '    }\n', '    \n', '    // Calculates how much token0 is entitled for a particular user\n', '    function _fee0Earned(address account, uint256 fee0PerShare_) internal view returns (uint256) {\n', '        UserInfo memory user = userInfo[account];\n', '        return\n', '            balanceOf(account)\n', '            .mul(fee0PerShare_.sub(user.token0PerSharePaid))\n', '            .unsafeDiv(1e18)\n', '            .add(user.token0Rewards);\n', '    }\n', '    \n', '    // Calculates how much token1 is entitled for a particular user\n', '    function _fee1Earned(address account, uint256 fee1PerShare_) internal view returns (uint256) {\n', '        UserInfo memory user = userInfo[account];\n', '        return\n', '            balanceOf(account)\n', '            .mul(fee1PerShare_.sub(user.token1PerSharePaid))\n', '            .unsafeDiv(1e18)\n', '            .add(user.token1Rewards);\n', '    }\n', '    \n', '    // Calculates how much token is provided per LP token \n', '    function _tokenPerShare(uint256 collected, uint256 tokenPerShareStored) internal view returns (uint256) {\n', '        uint _totalSupply = totalSupply();\n', '        if (_totalSupply > 0) {\n', '            return tokenPerShareStored\n', '            .add(\n', '                collected\n', '                .mul(1e18)\n', '                .unsafeDiv(_totalSupply)\n', '            );\n', '        }\n', '        return tokenPerShareStored;\n', '    }\n', '    \n', '    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n', '    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n', '    /// that use ether for the input amount\n', '    function refundETH() internal {\n', '        if (address(this).balance > 0) TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n', '    }\n', '\n', '    /**\n', '     * @notice `setGovernance()` should be called by the existing governance\n', '     * address prior to calling this function.\n', '     */\n', '    function setGovernance(address _governance) external onlyGovernance {\n', '        pendingGovernance = _governance;\n', '    }\n', '\n', '    /**\n', '     * @notice Governance address is not updated until the new governance\n', '     * address has called `acceptGovernance()` to accept this responsibility.\n', '     */\n', '    function acceptGovernance() external {\n', '        require(msg.sender == pendingGovernance, "PG");\n', '        emit TransferGovernance(governance, pendingGovernance);\n', '        pendingGovernance = address(0);\n', '        governance = msg.sender;\n', '    }\n', '\n', '    // Sets new strategy contract address for new settings\n', '    function setStrategy(address _strategy) external onlyGovernance {\n', '        require(_strategy != address(0), "NA");\n', '        strategy = _strategy;\n', '    }\n', '}']