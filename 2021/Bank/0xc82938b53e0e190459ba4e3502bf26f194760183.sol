['// SPDX-License-Identifier: GPL-3.0-or-later\n', '// Deployed with donations via Gitcoin GR9\n', '\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '// Deployed with donations via Gitcoin GR9\n', '\n', 'pragma solidity =0.7.5;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function withdraw(uint256) external;\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '// Deployed with donations via Gitcoin GR9\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "        require((z = x + y) >= x, 'SM_ADD_OVERFLOW');\n", '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "        z = sub(x, y, 'SM_SUB_UNDERFLOW');\n", '    }\n', '\n', '    function sub(\n', '        uint256 x,\n', '        uint256 y,\n', '        string memory message\n', '    ) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, message);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'SM_MUL_OVERFLOW');\n", '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b > 0, 'SM_DIV_BY_ZERO');\n", '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '// Deployed with donations via Gitcoin GR9\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH_TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{ value: value }(new bytes(0));\n', "        require(success, 'TH_ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '// Deployed with donations via Gitcoin GR9\n', '\n', 'pragma solidity 0.7.5;\n', '\n', "import 'IERC20.sol';\n", "import 'IWETH.sol';\n", "import 'SafeMath.sol';\n", "import 'TransferHelper.sol';\n", '\n', 'library TokenShares {\n', '    using SafeMath for uint256;\n', '    using TransferHelper for address;\n', '\n', '    event UnwrapFailed(address to, uint256 amount);\n', '\n', '    struct Data {\n', '        mapping(address => uint256) totalShares;\n', '        address weth;\n', '    }\n', '\n', '    function setWeth(Data storage data, address _weth) internal {\n', '        data.weth = _weth;\n', '    }\n', '\n', '    function sharesToAmount(\n', '        Data storage data,\n', '        address token,\n', '        uint256 share\n', '    ) external returns (uint256) {\n', '        if (share == 0) {\n', '            return 0;\n', '        }\n', '        if (token == data.weth) {\n', '            return share;\n', '        }\n', "        require(data.totalShares[token] >= share, 'TS_INSUFFICIENT_BALANCE');\n", '        uint256 balance = IERC20(token).balanceOf(address(this));\n', '        uint256 value = balance.mul(share).div(data.totalShares[token]);\n', '        data.totalShares[token] = data.totalShares[token].sub(share);\n', '        return value;\n', '    }\n', '\n', '    function amountToShares(\n', '        Data storage data,\n', '        address token,\n', '        uint256 amount,\n', '        bool wrap\n', '    ) external returns (uint256) {\n', '        if (amount == 0) {\n', '            return 0;\n', '        }\n', '        if (token == data.weth) {\n', '            if (wrap) {\n', "                require(msg.value >= amount, 'TS_INSUFFICIENT_AMOUNT');\n", '                IWETH(token).deposit{ value: amount }();\n', '            } else {\n', '                token.safeTransferFrom(msg.sender, address(this), amount);\n', '            }\n', '            return amount;\n', '        } else {\n', '            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n', "            require(balanceBefore > 0 || data.totalShares[token] == 0, 'TS_INVALID_SHARES');\n", '            if (data.totalShares[token] == 0) {\n', '                data.totalShares[token] = balanceBefore;\n', '            }\n', '            token.safeTransferFrom(msg.sender, address(this), amount);\n', '            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n', "            require(balanceAfter > balanceBefore, 'TS_INVALID_TRANSFER');\n", '            if (balanceBefore > 0) {\n', '                uint256 lastShares = data.totalShares[token];\n', '                data.totalShares[token] = lastShares.mul(balanceAfter).div(balanceBefore);\n', '                return data.totalShares[token] - lastShares;\n', '            } else {\n', '                data.totalShares[token] = balanceAfter;\n', '                data.totalShares[token] = balanceAfter;\n', '                return balanceAfter;\n', '            }\n', '        }\n', '    }\n', '\n', '    function onUnwrapFailed(\n', '        Data storage data,\n', '        address to,\n', '        uint256 amount\n', '    ) external {\n', '        emit UnwrapFailed(to, amount);\n', '        IWETH(data.weth).deposit{ value: amount }();\n', '        TransferHelper.safeTransfer(data.weth, to, amount);\n', '    }\n', '}\n', '\n', '{\n', '  "libraries": {\n', '    "IERC20.sol": {},\n', '    "IWETH.sol": {},\n', '    "SafeMath.sol": {},\n', '    "TransferHelper.sol": {},\n', '    "TokenShares.sol": {}\n', '  },\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']