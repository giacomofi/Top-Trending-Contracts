['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-23\n', '*/\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', 'contract Singing {\n', '    mapping (address => uint256) internal _rOwned;\n', '    mapping (address => uint256) internal _tOwned;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '    mapping(address => bool) public isTaxedAsSender;\n', '\tmapping(address => bool) public isTaxedAsRecipient;\n', '    mapping (address => bool) public isExcluded;\n', '    address[] internal _excluded;\n', '\n', '    string public constant name = "Singing";\n', '    string public constant symbol = "SING";\n', '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public constant totalSupply = 1_000_000_000 * (10 ** decimals);\n', '    uint256 internal _rTotal = (type(uint256).max - (type(uint256).max % totalSupply));\n', '    uint256 internal _tFeeTotal;\n', '    uint256 constant internal _reflectBasisPoints = 5000;  // 0.01% = 1 basis point, 4.00% = 400 basis points\n', '    uint256 internal reflectDisabledBlock;\n', '\n', '    address public owner;\n', '    address public pendingOwner;\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed account, address indexed spender, uint256 value);\n', '    \n', '    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        owner = msg.sender;\n', '        _rOwned[msg.sender] = _rTotal;\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '    \n', '    modifier isOwner() {\n', '        require(msg.sender == owner, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function balanceOf(address account) external view returns (uint256) {\n', '        return isExcluded[account] ? _tOwned[account] : tokenFromReflection(_rOwned[account]);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, allowance[sender][msg.sender] - amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n', '        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n', '        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\n', '        return true;\n', '    }\n', '\n', '    function totalFees() external view returns (uint256) {\n', '        return _tFeeTotal;\n', '    }\n', '    \n', '    function reflect(uint256 tAmount) external {\n', '        require(!isExcluded[msg.sender], "IS_EXCLUDED");\n', '        \n', '        (uint256 rAmount,,,,) = _getValues(address(0), address(0), tAmount);\n', '        \n', '        _rOwned[msg.sender] -= rAmount;\n', '        _rTotal -= rAmount;\n', '        _tFeeTotal += tAmount;\n', '    }\n', '\n', '    function reflectionFromToken(address sender, address recipient, uint256 tAmount, bool deductTransferFee) external view returns (uint256) {\n', '        require(tAmount <= totalSupply, "AMOUNT_>_SUPPLY");\n', '        \n', '        (uint256 rAmount,uint256 rTransferAmount,,,) = _getValues(sender, recipient, tAmount);\n', '        \n', '        return deductTransferFee ? rTransferAmount : rAmount;\n', '    }\n', '\n', '    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n', '        require(rAmount <= _rTotal, "AMOUNT_>_TOTAL_REFLECTIONS");\n', '        return rAmount / _getRate();\n', '    }\n', '\n', '    function setSenderTaxed(address account, bool taxed) external isOwner {\n', '        // by default, all senders are not taxed\n', '        isTaxedAsSender[account] = taxed;\n', '\t}\n', '\t\n', '\tfunction setRecipientTaxed(address account, bool taxed) external isOwner {\n', '\t    // by default, all recipients are not taxed\n', '        isTaxedAsRecipient[account] = taxed;\n', '\t}\n', '\n', '    function excludeAccountFromRewards(address account) external isOwner {\n', '        require(!isExcluded[account], "IS_EXCLUDED");\n', '        if(_rOwned[account] > 0) {\n', '            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '        }\n', '        \n', '        isExcluded[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '\n', '    function includeAccountFromRewards(address account) external isOwner {\n', '        require(isExcluded[account], "IS_INCLUDED");\n', '        \n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _tOwned[account] = 0;\n', '                isExcluded[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _approve(address account, address spender, uint256 amount) internal {\n', '        allowance[account][spender] = amount;\n', '        emit Approval(account, spender, amount);\n', '    }\n', '    \n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(amount > 0, "INVALID_AMOUNT");\n', '        \n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(sender, recipient, amount);\n', '        \n', '        _rOwned[sender] -= rAmount;\n', '        _rOwned[recipient] += rTransferAmount;\n', '        \n', '        if (isExcluded[sender] && !isExcluded[recipient]) {\n', '            _tOwned[sender] -= amount;\n', '        } else if (!isExcluded[sender] && isExcluded[recipient]) {\n', '            _tOwned[recipient] += tTransferAmount;\n', '        } else if (isExcluded[sender] && isExcluded[recipient]) {\n', '            _tOwned[sender] -= amount;\n', '            _tOwned[recipient] += tTransferAmount;\n', '        }\n', '        \n', '        _reflectFee(rFee, tFee);\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '\n', '    function _reflectFee(uint256 rFee, uint256 tFee) internal {\n', '        _rTotal -= rFee;\n', '        _tFeeTotal += tFee;\n', '    }\n', '\n', '    function _getValues(address sender, address recipient, uint256 tAmount) internal view returns (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) {\n', '        (tTransferAmount, tFee) = _getTValues(sender, recipient, tAmount);\n', '        (rAmount, rTransferAmount, rFee) = _getRValues(tAmount, tFee, _getRate());\n', '    }\n', '\n', '    function _getTValues(address sender, address recipient, uint256 tAmount) internal view returns (uint256 tTransferAmount, uint256 tFee) {\n', '        tFee = (block.number != reflectDisabledBlock) && (isTaxedAsSender[sender] || isTaxedAsRecipient[recipient])\n', '            ? (tAmount * _reflectBasisPoints) / 10_000\n', '            : 0;\n', '        \n', '        tTransferAmount = tAmount - tFee;\n', '    }\n', '\n', '    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) internal pure returns (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) {\n', '        rAmount = tAmount * currentRate;\n', '        rFee = tFee * currentRate;\n', '        rTransferAmount = rAmount - rFee;\n', '    }\n', '\n', '    function _getRate() internal view returns (uint256) {\n', '        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '        return rSupply / tSupply;\n', '    }\n', '\n', '    function _getCurrentSupply() internal view returns (uint256 rSupply, uint256 tSupply) {\n', '        rSupply = _rTotal;\n', '        tSupply = totalSupply; \n', '        \n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, totalSupply);\n', '            \n', '            rSupply -= _rOwned[_excluded[i]];\n', '            tSupply -= _tOwned[_excluded[i]];\n', '        }\n', '        \n', '        if (rSupply < (_rTotal / totalSupply)) {\n', '            (rSupply, tSupply) = (_rTotal, totalSupply);\n', '        }\n', '    }\n', '    \n', '    function changeOwner(address newOwner) external isOwner {\n', '        pendingOwner = newOwner;\n', '\t}\n', '\t\n', '\tfunction acceptOwnership() external {\n', '        require(msg.sender == pendingOwner, "NOT_PENDING_OWNER");\n', '        \n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        \n', '        owner = msg.sender;\n', '        pendingOwner = address(0);\n', '\t}\n', '\t\n', '\tfunction disableReflectionForCurrentBlock() external isOwner {\n', '\t    reflectDisabledBlock = block.number;\n', '\t}\n', '\t\n', '\tfunction resetReflectDisabledBlock() external isOwner {\n', '\t    reflectDisabledBlock = 0;\n', '\t}\n', '}\n', '\n', 'interface UniswapRouterV202 {\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    \n', '    function factory() external pure returns (address);\n', '}\n', '\n', 'interface UniswapPairV2 {\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function transfer(address to, uint value) external returns (bool);\n', '}\n', '\n', 'contract SingingOwner {\n', '    Singing immutable public token;\n', '    address public owner;\n', '    address public pendingOwner;\n', '    \n', '    UniswapRouterV202 public router;\n', '    UniswapPairV2 public pair;\n', '    \n', '    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '    \n', '    constructor (address tokenAddress, address routerAddress, address pairAddress) {\n', '        owner = msg.sender;\n', '        token = Singing(tokenAddress);\n', '        router = UniswapRouterV202(routerAddress);\n', '        pair = UniswapPairV2(pairAddress);\n', '    }\n', '    \n', '    modifier isOwner() {\n', '        require(msg.sender == owner, "NOT_OWNER");\n', '        _;\n', '    }\n', '    \n', '    function changeOwner(address newOwner) external isOwner {\n', '        pendingOwner = newOwner;\n', '\t}\n', '\t\n', '\tfunction acceptOwner() external {\n', '        require(msg.sender == pendingOwner, "NOT_PENDING_OWNER");\n', '        \n', '        emit OwnershipTransferred(owner, msg.sender);\n', '        \n', '        owner = msg.sender;\n', '        pendingOwner = address(0);\n', '\t}\n', '\t\n', '\tfunction changeOwnerOfToken(address newOwner) external isOwner {\n', '        token.changeOwner(newOwner);\n', '\t}\n', '\t\n', '\tfunction acceptOwnershipOfToken() external isOwner {\n', '\t    token.acceptOwnership();\n', '\t}\n', '    \n', '    function setSenderTaxed(address account, bool taxed) external isOwner {\n', '        token.setSenderTaxed(account, taxed);\n', '\t}\n', '\t\n', '\tfunction setRecipientTaxed(address account, bool taxed) external isOwner {\n', '\t    token.setRecipientTaxed(account, taxed);\n', '\t}\n', '\n', '    function setAccountGetsRewards(address account, bool getsRewards) external isOwner {\n', '        getsRewards ? token.includeAccountFromRewards(account) : token.excludeAccountFromRewards(account);\n', '    }\n', '    \n', '    function addLiquidityETH(\n', '        address tokenAddress,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity) {\n', '        require(tokenAddress == address(token), "NOT_TOKEN");\n', '        \n', '        // Turn off tax for this block\n', '        token.disableReflectionForCurrentBlock();\n', '        \n', '        // Transfer token from caller to this\n', '        token.transferFrom(msg.sender, address(this), amountTokenDesired);\n', '        \n', '        // Approve Router on the amount of token\n', '        token.approve(address(router), amountTokenDesired);\n', '        \n', '        // Perform the liquidity add\n', '        (amountToken, amountETH, liquidity) = router.addLiquidityETH{value: msg.value}(tokenAddress, amountTokenDesired, amountTokenMin, amountETHMin, to, deadline);\n', '        \n', '        uint256 leftOver = token.balanceOf(address(this));\n', '\n', '        if (leftOver > 0) {\n', '            // Transfer leftover ETH or tokens to the caller\n', '            token.transfer(msg.sender, leftOver);\n', '        }\n', '\n', '        leftOver = address(this).balance;\n', '\n', '        if (leftOver > 0) {\n', '            payable(msg.sender).transfer(leftOver);\n', '        }\n', '        \n', '        // Turn on tax for this block\n', '        token.resetReflectDisabledBlock();\n', '    }\n', '    \n', '    function setRouterAndPair(address routerAddress, address pairAddress) external isOwner {\n', '        router = UniswapRouterV202(routerAddress);\n', '        pair = UniswapPairV2(pairAddress);\n', '    }\n', '    \n', '    receive() external payable {}\n', '}']