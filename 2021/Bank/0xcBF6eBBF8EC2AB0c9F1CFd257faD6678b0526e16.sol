['// SPDX-License-Identifier: U-U-U-UPPPPP!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./TokensRecoverable.sol";\n', 'import "./IERC31337.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IERC20.sol";\n', 'import "./RootedTransferGate.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./ILiquidityController.sol";\n', 'import "./IFloorCalculator.sol";\n', '\n', 'contract LiquidityController is TokensRecoverable, ILiquidityController\n', '{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20; \n', '\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    IERC20 immutable rooted;\n', '    IERC20 immutable base;\n', '    IERC20 immutable fiat;\n', '    IERC31337 immutable elite;\n', '    IERC20 immutable rootedEliteLP;\n', '    IERC20 immutable rootedBaseLP;\n', '    IERC20 immutable rootedFiatLP;\n', '    IFloorCalculator public calculator;\n', '    RootedTransferGate public gate;\n', '    mapping(address => bool) public liquidityControllers;\n', '\n', '    constructor(IUniswapV2Router02 _uniswapV2Router, IERC20 _base, IERC20 _rooted, IERC31337 _elite, IERC20 _fiat, IFloorCalculator _calculator, RootedTransferGate _gate) \n', '    {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        base = _base;\n', '        elite = _elite;\n', '        rooted = _rooted;\n', '        fiat = _fiat;\n', '        calculator = _calculator;\n', '        gate = _gate;\n', '\n', '        IUniswapV2Factory _uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '        uniswapV2Factory = _uniswapV2Factory;        \n', '        \n', '        _base.safeApprove(address(_uniswapV2Router), uint256(-1));\n', '        _base.safeApprove(address(_elite), uint256(-1));\n', '        _rooted.approve(address(_uniswapV2Router), uint256(-1));\n', '        IERC20 _rootedBaseLP = IERC20(_uniswapV2Factory.getPair(address(_base), address(_rooted)));\n', '        _rootedBaseLP.approve(address(_uniswapV2Router), uint256(-1));\n', '        rootedBaseLP = _rootedBaseLP;\n', '        _elite.approve(address(_uniswapV2Router), uint256(-1));\n', '        IERC20 _rootedEliteLP = IERC20(_uniswapV2Factory.getPair(address(_elite), address(_rooted)));\n', '        _rootedEliteLP.approve(address(_uniswapV2Router), uint256(-1));\n', '        rootedEliteLP = _rootedEliteLP;\n', '        _fiat.approve(address(_uniswapV2Router), uint256(-1));\n', '        IERC20 _rootedFiatLP = IERC20(_uniswapV2Factory.getPair(address(_fiat), address(_rooted)));\n', '        _rootedFiatLP.approve(address(_uniswapV2Router), uint256(-1));\n', '        rootedFiatLP = _rootedFiatLP;\n', '    }\n', '\n', '    modifier liquidityControllerOnly()\n', '    {\n', '        require(liquidityControllers[msg.sender], "Not a Liquidity Controller");\n', '        _;\n', '    }\n', '\n', '    // Owner function to enable other contracts or addresses to use the Liquidity Controller\n', '    function setLiquidityController(address controlAddress, bool controller) public ownerOnly()\n', '    {\n', '        liquidityControllers[controlAddress] = controller;\n', '    }\n', '\n', '    function setCalculatorAndGate(IFloorCalculator _calculator, RootedTransferGate _gate) public ownerOnly()\n', '    {\n', '        calculator = _calculator;\n', '        gate = _gate;\n', '    }\n', '\n', '    // Use Base tokens held by this contract to buy from the Base Pool and sell in the Elite Pool\n', '    function balancePriceBase(uint256 amount) public override liquidityControllerOnly()\n', '    {\n', '        amount = buyRootedToken(address(base), amount);\n', '        amount = sellRootedToken(address(elite), amount);\n', '        elite.withdrawTokens(amount);\n', '    }\n', '\n', '    // Use Base tokens held by this contract to buy from the Elite Pool and sell in the Base Pool\n', '    function balancePriceElite(uint256 amount) public override liquidityControllerOnly()\n', '    {        \n', '        elite.depositTokens(amount);\n', '        amount = buyRootedToken(address(elite), amount);\n', '        amount = sellRootedToken(address(base), amount);\n', '    }\n', '\n', '    // Removes liquidity, buys from either pool, sets a temporary dump tax\n', '    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) public override liquidityControllerOnly()\n', '    {\n', '        gate.setUnrestricted(true);\n', '        amount = removeLiq(token, amount);\n', '        buyRootedToken(token, amount);\n', '        gate.setDumpTax(tax, time);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    // Uses value in the controller to buy\n', '    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) public override liquidityControllerOnly()\n', '    {\n', '        buyRootedToken(token, amountToSpend);\n', '        gate.setDumpTax(tax, time);\n', '    }\n', '\n', '    // Sweeps the Base token under the floor to this address\n', '    function sweepFloor() public override liquidityControllerOnly()\n', '    {\n', '        elite.sweepFloor(address(this));\n', '    }\n', '\n', '    // Move liquidity from Elite pool --->> Base pool\n', '    function zapEliteToBase(uint256 liquidity) public override liquidityControllerOnly() \n', '    {       \n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(elite), liquidity);\n', '        elite.withdrawTokens(liquidity);\n', '        addLiq(address(base), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    // Move liquidity from Base pool --->> Elite pool\n', '    function zapBaseToElite(uint256 liquidity) public override liquidityControllerOnly() \n', '    {\n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(base), liquidity);\n', '        elite.depositTokens(liquidity);\n', '        addLiq(address(elite), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function wrapToElite(uint256 baseAmount) public override liquidityControllerOnly() \n', '    {\n', '        elite.depositTokens(baseAmount);\n', '    }\n', '\n', '    function unwrapElite(uint256 eliteAmount) public override liquidityControllerOnly() \n', '    {\n', '        elite.withdrawTokens(eliteAmount);\n', '    }\n', '\n', '    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override liquidityControllerOnly() \n', '    {\n', '        gate.setUnrestricted(true);\n', '        addLiq(eliteOrBase, baseAmount);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function removeLiquidity(address eliteOrBase, uint256 tokens) public override liquidityControllerOnly()\n', '    {\n', '        gate.setUnrestricted(true);\n', '        removeLiq(eliteOrBase, tokens);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function buyRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly()\n', '    {\n', '        buyRootedToken(token, amountToSpend);\n', '    }\n', '\n', '    function sellRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly()\n', '    {\n', '        sellRootedToken(token, amountToSpend);\n', '    }\n', '\n', '    function addLiq(address eliteOrBase, uint256 baseAmount) internal \n', '    {\n', '        uniswapV2Router.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n', '    }\n', '\n', '    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256)\n', '    {\n', '        (tokens, ) = uniswapV2Router.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\n', '        return tokens;\n', '    }\n', '\n', '    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256)\n', '    {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1];\n', '        return amountToSpend;\n', '    }\n', '\n', '    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256)\n', '    {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1];\n', '        return amountToSpend;\n', '    }\n', '\n', '    function buyPath(address token) internal view returns (address[] memory) \n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(token);\n', '        path[1] = address(rooted);\n', '        return path;\n', '    }\n', '\n', '    function sellPath(address token) internal view returns (address[] memory) \n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(rooted);\n', '        path[1] = address(token);\n', '        return path;\n', '    }\n', '}']