['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IUniswapV2Router {\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '}\n', '\n', 'contract AuthorisedTokenSwap {\n', '    mapping(bytes32 => uint) approvals;\n', '    \n', '    event Approval(address indexed owner, address indexed trader, address indexed router, address[] path, uint amount);\n', '    event Swap(address indexed owner, address indexed trader, address indexed router, address[] path, uint[] amounts);\n', '    \n', '    function approval(address owner, address trader, address router, address[] calldata path) public view returns(uint) {\n', '        return approvals[getApprovalHash(owner, trader, router, path)];\n', '    }\n', '    \n', '    function setApproval(address trader, address router, address[] calldata path, uint amount) public {\n', '        approvals[getApprovalHash(msg.sender, trader, router, path)] = amount;\n', '        emit Approval(msg.sender, trader, router, path, amount);\n', '    }\n', '    \n', '    function swapExactTokensForTokens(address owner, IUniswapV2Router router, uint amountIn, uint amountOutMin, address[] calldata path, uint deadline)\n', '        external returns (uint[] memory swapAmounts) \n', '    {\n', '        require(path.length >= 2);\n', '        approvals[getApprovalHash(owner, msg.sender, address(router), path)] -= amountIn; // 0.8.x uses safemath by default\n', '        \n', '        IERC20 sourceToken = IERC20(path[0]);\n', '        uint balanceBefore = sourceToken.balanceOf(address(this));\n', '\n', '        require(sourceToken.transferFrom(owner, address(this), amountIn), "Transfer in failed");\n', '        require(sourceToken.approve(address(router), amountIn), "Approve failed");\n', '        swapAmounts = router.swapExactTokensForTokens(amountIn, amountOutMin, path, owner, deadline);\n', '        emit Swap(owner, msg.sender, address(router), path, swapAmounts);\n', '        \n', '        // Check the swap was successful\n', '        require(swapAmounts[0] == amountIn, "Wrong number of source tokens deducted");\n', '        require(swapAmounts[swapAmounts.length - 1] >= amountOutMin, "Insufficient destination tokens received");\n', '        require(sourceToken.balanceOf(address(this)) == balanceBefore, "Tokens left in contract");\n', '    }\n', '    \n', '    function getApprovalHash(address owner, address trader, address router, address[] calldata path) internal pure returns(bytes32) {\n', '        return keccak256(abi.encodePacked(owner, trader, router, path));\n', '    }\n', '}']