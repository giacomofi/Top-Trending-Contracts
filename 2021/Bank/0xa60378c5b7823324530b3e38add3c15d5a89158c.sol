['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-29\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'library SafeMath {\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', "    require(c >= a, 'SafeMath: addition overflow');\n", '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    return sub(a, b, 'SafeMath: subtraction overflow');\n", '  }\n', '\n', '  function sub(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b <= a, errorMessage);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', "    require(c / a == b, 'SafeMath: multiplication overflow');\n", '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    return div(a, b, 'SafeMath: division by zero');\n", '  }\n', '\n', '  function div(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    return mod(a, b, 'SafeMath: modulo by zero');\n", '  }\n', '\n', '  function mod(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IWeth is IERC20 {\n', '    function deposit() external payable;\n', '    function withdraw(uint amount) external;\n', '}\n', '\n', 'interface IWstEth is IERC20{\n', '    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n', '    function stETH() external view returns (IERC20);\n', '}\n', '\n', '\n', 'interface IUniswapV2Pair{\n', '\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '}\n', '\n', 'library Math {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Library Functions ============\n', '\n', '    /*\n', '     * Return target * (numerator / denominator).\n', '     */\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    function to128(\n', '        uint256 number\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint128)\n', '    {\n', '        uint128 result = uint128(number);\n', '        require(\n', '            result == number,\n', '            "Math: Unsafe cast to uint128"\n', '        );\n', '        return result;\n', '    }\n', '\n', '    function min(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', 'library Decimal {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function one()\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: BASE });\n', '    }\n', '\n', '    function onePlus(\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: d.value.add(BASE) });\n', '    }\n', '\n', '    function mul(\n', '        uint256 target,\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, d.value, BASE);\n', '    }\n', '\n', '    function mul(\n', '        D256 memory d1,\n', '        D256 memory d2\n', '    )\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return Decimal.D256({ value: Math.getPartial(d1.value, d2.value, BASE) });\n', '    }\n', '\n', '    function div(\n', '        uint256 target,\n', '        D256 memory d\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, BASE, d.value);\n', '    }\n', '\n', '    function add(\n', '        D256 memory d,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: d.value.add(amount) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory d,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        pure\n', '        returns (D256 memory)\n', '    {\n', '        return D256({ value: d.value.sub(amount) });\n', '    }\n', '\n', '}\n', '\n', 'interface IStructs{\n', '    enum Operation {\n', '        Open,\n', '        Borrow,\n', '        Repay,\n', '        Liquidate,\n', '        TransferOwnership\n', '    }\n', '\n', '    struct Principal {\n', '        bool sign; // true if positive\n', '        uint256 value;\n', '    }\n', '\n', '    struct Position {\n', '        address owner;\n', '        Principal collateralAmount;\n', '        Principal borrowedAmount;\n', '    }\n', '\n', '    struct OperationParams {\n', '        uint256 id;\n', '        uint256 amountOne;\n', '        uint256 amountTwo;\n', '        address addressOne;\n', '    }\n', '\n', '}\n', '\n', 'interface IOracle is IStructs{\n', '     function fetchCurrentPrice()\n', '        external\n', '        view\n', '        returns (Decimal.D256 memory);\n', '}\n', '\n', 'interface IarcxPool is IStructs{\n', '\n', '    function operateAction(\n', '        Operation operation,\n', '        OperationParams memory params\n', '    ) external ;\n', '\n', '    function getCurrentOracle() external view returns(address);\n', '\n', '    function calculateLiquidationPrice(Decimal.D256 memory currentPrice) external view returns(Decimal.D256 memory);\n', '\n', '    function calculateCollateralDelta(\n', '        Principal memory parSupply,\n', '        uint256 borrowedAmount,\n', '        Decimal.D256 memory price\n', '    )\n', '        external\n', '        view\n', '        returns (Principal memory);\n', '\n', '    function getPosition(uint256 position) external view returns (Position memory);\n', '\n', '    function getFees()\n', '    external\n', '    view\n', '    returns (\n', '        Decimal.D256 memory _liquidationUserFee,\n', '        Decimal.D256 memory _liquidationArcRatio\n', '    );\n', '}\n', '\n', 'interface ICurvePool {\n', '\n', '    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\n', '\n', '    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256); \n', '    // i = 1 to send, j = 0 to receive, \n', '}\n', '\n', 'contract ArcxLiquidations is IStructs {\n', '    \n', '    using SafeMath for uint256;\n', '    using Math for uint256;\n', '\n', '    IUniswapV2Pair stablexPair = IUniswapV2Pair(address(0x1BccE9E2Fd56E8311508764519d28E6ec22D4a47));\n', '\n', '    IUniswapV2Pair ethUsdcPair = IUniswapV2Pair(address(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc));\n', '\n', '    IarcxPool arcxPool = IarcxPool(address(0xC466Ec062D554BEB42f1766488F7345261C63616));\n', '\n', '    IERC20 stablex = IERC20(address(0xcD91538B91B4ba7797D39a2f66E63810b50A33d0));\n', '\n', '    IERC20 usdc = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));\n', '\n', '    IWstEth wsteth = IWstEth(address(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0));\n', '\n', '    IWeth weth = IWeth(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n', '    \n', '    ICurvePool curvePool = ICurvePool(address(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022));\n', '\n', '    address owner;\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '        wsteth.stETH().approve(address(curvePool), uint256(-1));\n', '    }\n', '    \n', '    fallback() external payable {\n', '        \n', '    }\n', '    \n', '    receive() external payable {\n', '        \n', '    }\n', '\n', '    function uniswapV2Call(address pair, uint256 amount0Out, uint256 amount1Out, bytes memory data) external {\n', '\n', '        if(msg.sender != address(stablexPair)){\n', '            return;\n', '        }\n', '\n', '        (uint256 amount, uint256 amountUSDC, uint256 position) = abi.decode(data, (uint256, uint256, uint256));\n', '\n', '        OperationParams memory params = OperationParams({\n', '            id: position,\n', '            amountOne: 1,\n', '            amountTwo: 1,\n', '            addressOne: address(0)\n', '        });\n', '\n', '        arcxPool.operateAction(Operation.Liquidate, params);\n', '\n', '        require(wsteth.balanceOf(address(this)) > 0, "!no collateral received");\n', '        \n', '        // unwraps wsteth\n', '        uint256 stethBalance = wsteth.unwrap(wsteth.balanceOf(address(this)));\n', '        // get amountOut for steth on curve\n', '        uint256 ethAmountOut = curvePool.get_dy(1, 0, stethBalance);\n', '        // swap steth for eth on curve\n', '        curvePool.exchange(1, 0, stethBalance, ethAmountOut);\n', '\n', '        (uint256 _amount0Out, uint256 _amount1Out) = ethUsdcPair.token0() == address(weth)?\n', '            (uint256(0), amountUSDC):(amountUSDC, uint256(0));\n', '\n', '        (uint256 reserve0, uint256 reserve1, ) = ethUsdcPair.getReserves();\n', '\n', '        (uint256 reserveIn, uint256 reserveOut) = ethUsdcPair.token0() == address(weth)? \n', '        (reserve0, reserve1) : (reserve1, reserve0); \n', '        \n', '        uint256 wethAmount = getAmountIn(amountUSDC, reserveIn, reserveOut);\n', '\n', '        weth.deposit{value: wethAmount}();\n', '\n', '        bytes memory empty;\n', '\n', '        weth.transfer(address(ethUsdcPair), wethAmount);\n', '\n', '        ethUsdcPair.swap(_amount0Out, _amount1Out, address(this), empty);\n', '\n', '        usdc.transfer(msg.sender, amountUSDC);\n', '        \n', '    }\n', '\n', '    function withdrawErc20(address token) external {\n', '\n', '        require(msg.sender == owner, "!owner");\n', '        \n', '        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\n', '        \n', '    }\n', '    \n', '    function withdraw() external {\n', '        \n', '        require(msg.sender == owner, "!owner");\n', '        \n', '        payable(msg.sender).transfer(address(this).balance);\n', '        \n', '    }\n', '\n', '\n', '    function getAmountOfStableXNeeded(uint256 posIndex) public view returns(uint256 borrowToLiquidate){\n', '\n', '        Decimal.D256 memory currentPrice = IOracle(arcxPool.getCurrentOracle()).fetchCurrentPrice();\n', '\n', '        Decimal.D256 memory liquidationPrice = arcxPool.calculateLiquidationPrice(currentPrice);\n', '\n', '        Position memory position = arcxPool.getPosition(posIndex);\n', '\n', '        Principal memory collateralDelta = arcxPool.calculateCollateralDelta(\n', '            position.collateralAmount,\n', '            position.borrowedAmount.value,\n', '            liquidationPrice\n', '        );\n', '\n', '        (Decimal.D256 memory liquidateUserFees, Decimal.D256 memory liquidateArcxFees) = arcxPool.getFees();\n', '\n', '        collateralDelta.value = Decimal.mul(\n', '            collateralDelta.value,\n', '            Decimal.add(\n', '                liquidateUserFees,\n', '                Decimal.one().value\n', '            )\n', '        );\n', '\n', '\n', '        borrowToLiquidate = Decimal.mul(\n', '            collateralDelta.value,\n', '            liquidationPrice\n', '        );\n', '\n', '    }\n', '\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) private returns (uint amountIn) {\n', "        require(amountOut > 0, 'ArcxLiquidation: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'ArcxLiquidation: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '\n', '    function run(uint256 posIndex) external {\n', '\n', '        require(msg.sender == owner, "!owner");\n', '\n', '        uint256 amount = getAmountOfStableXNeeded(posIndex);\n', '\n', '        (uint256 amount0Out, uint256 amount1Out) = stablexPair.token0() == address(stablex)?\n', '            (amount, uint256(0)):(uint256(0), amount);\n', '\n', '        (uint256 reserve0, uint256 reserve1, ) = stablexPair.getReserves();\n', '\n', '        (uint256 reserveIn, uint256 reserveOut) = stablexPair.token0() == address(stablex)? \n', '        (reserve1, reserve0) : (reserve0, reserve1); \n', '\n', '        uint256 amountIn = getAmountIn(amount, reserveIn, reserveOut);\n', '\n', '        bytes memory data = abi.encode(amount, amountIn, posIndex);\n', '\n', '        stablexPair.swap(amount0Out, amount1Out, address(this), data);\n', '\n', '    }\n', '\n', '\n', '}']