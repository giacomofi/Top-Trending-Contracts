['// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity >=0.8.0 <0.9.0;\n', '\n', 'import "./ICoinvestingDeFiFactory.sol";\n', 'import "./IERC20.sol";\n', "import './SafeMath.sol';\n", 'import "./ICoinvestingDeFiRouter.sol";\n', 'import "./IWETH.sol";\n', 'import "./CoinvestingDeFiLibrary.sol";\n', 'import "./TransferHelper.sol";\n', '\n', 'contract CoinvestingDeFiRouter is ICoinvestingDeFiRouter {\n', '    using SafeMath for uint;\n', '    // Variables\n', '    address public immutable override factory;\n', '    address public immutable override WETH;\n', '    \n', '    // Modifiers\n', '    modifier ensure(uint deadline) {\n', '        require(deadline >= block.timestamp, "RTR: EXPD");\n', '        _;\n', '    }\n', '\n', '    // Constructor\n', '    constructor(address _factory, address _WETH) {\n', '        factory = _factory;\n', '        WETH = _WETH;\n', '    }\n', '\n', '    // Receive function\n', '    receive() external payable {\n', '        // only accept ETH via fallback from the WETH contract\n', '        assert(msg.sender == WETH); \n', '    }\n', '\n', '    // External functions\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (\n', '        uint amountA,\n', '        uint amountB,\n', '        uint liquidity\n', '    )\n', '    {\n', '        (amountA, amountB) = _addLiquidity(\n', '            tokenA,\n', '            tokenB,\n', '            amountADesired,\n', '            amountBDesired,\n', '            amountAMin,\n', '            amountBMin\n', '        );\n', '\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            tokenA,\n', '            tokenB\n', '        );\n', '        \n', '        TransferHelper.safeTransferFrom(\n', '            tokenA,\n', '            msg.sender,\n', '            pair,\n', '            amountA\n', '        );\n', '\n', '        TransferHelper.safeTransferFrom(\n', '            tokenB,\n', '            msg.sender,\n', '            pair,\n', '            amountB\n', '        );\n', '\n', '        liquidity = ICoinvestingDeFiPair(pair).mint(to);\n', '    }\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    payable\n', '    ensure(deadline)\n', '    returns (\n', '        uint amountToken,\n', '        uint amountETH,\n', '        uint liquidity\n', '    )\n', '    {\n', '        (amountToken, amountETH) = _addLiquidity(\n', '            token,\n', '            WETH,\n', '            amountTokenDesired,\n', '            msg.value,\n', '            amountTokenMin,\n', '            amountETHMin\n', '        );\n', '\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            token,\n', '            WETH\n', '        );\n', '\n', '        TransferHelper.safeTransferFrom(\n', '            token,\n', '            msg.sender,\n', '            pair,\n', '            amountToken\n', '        );\n', '\n', '        IWETH(WETH).deposit{value: amountETH}();\n', '        assert(IWETH(WETH).transfer(\n', '                pair,\n', '                amountETH\n', '            )\n', '        );\n', '\n', '        liquidity = ICoinvestingDeFiPair(pair).mint(to);        \n', '        if (msg.value > amountETH) {\n', '            TransferHelper.safeTransferETH(\n', '                msg.sender,\n', '                msg.value - amountETH\n', '            );\n', '        }\n', '    }\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    returns (\n', '        uint amountToken,\n', '        uint amountETH\n', '    )\n', '    {\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            token,\n', '            WETH\n', '        );\n', '\n', '        uint value = approveMax ? type(uint).max : liquidity;\n', '        ICoinvestingDeFiPair(pair).permit(\n', '            msg.sender,\n', '            address(this),\n', '            value,\n', '            deadline,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '\n', '        (amountToken, amountETH) = removeLiquidityETH(\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    returns (uint amountETH)\n', '    {\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            token,\n', '            WETH\n', '        );\n', '\n', '        uint value = approveMax ? type(uint).max : liquidity;\n', '        ICoinvestingDeFiPair(pair).permit(\n', '            msg.sender,\n', '            address(this),\n', '            value,\n', '            deadline,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        \n', '        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    returns (\n', '        uint amountA,\n', '        uint amountB\n', '    )\n', '    {\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            tokenA,\n', '            tokenB\n', '        );\n', '\n', '        uint value = approveMax ? type(uint).max : liquidity;\n', '        ICoinvestingDeFiPair(pair).permit(\n', '            msg.sender,\n', '            address(this),\n', '            value,\n', '            deadline,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '\n', '        (amountA, amountB) = removeLiquidity(\n', '            tokenA,\n', '            tokenB,\n', '            liquidity,\n', '            amountAMin,\n', '            amountBMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function swapETHForExactTokens(\n', '        uint amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    payable\n', '    ensure(deadline)\n', '    returns (uint[] memory amounts)\n', '    {\n', '        require(path[0] == WETH, "RTR: INV_P");\n', '        amounts = CoinvestingDeFiLibrary.getAmountsIn(\n', '            factory,\n', '            amountOut,\n', '            path\n', '        );\n', '\n', '        require(amounts[0] <= msg.value, "RTR: XS_IN_AMT");\n', '        IWETH(WETH).deposit{value: amounts[0]}();\n', '        assert(IWETH(WETH).transfer(\n', '                CoinvestingDeFiLibrary.pairFor(\n', '                    factory,\n', '                    path[0],\n', '                    path[1]\n', '                ),\n', '                amounts[0]\n', '            )\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            to\n', '        );\n', '\n', '        if (msg.value > amounts[0]) {\n', '            TransferHelper.safeTransferETH(\n', '                msg.sender,\n', '                msg.value - amounts[0]\n', '            );\n', '        }            \n', '    }\n', '\n', '    function swapExactETHForTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '        external\n', '        virtual\n', '        override\n', '        payable\n', '        ensure(deadline)\n', '        returns (uint[] memory amounts)\n', '    {\n', '        require(path[0] == WETH, "RTR: INV_P");\n', '        amounts = CoinvestingDeFiLibrary.getAmountsOut(\n', '            factory,\n', '            msg.value,\n', '            path\n', '        );\n', '        require(amounts[amounts.length - 1] >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '        \n', '        IWETH(WETH).deposit{value: amounts[0]}();\n', '        assert(IWETH(WETH).transfer(\n', '                CoinvestingDeFiLibrary.pairFor(\n', '                    factory,\n', '                    path[0],\n', '                    path[1]\n', '                ),\n', '                amounts[0]\n', '            )\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            to\n', '        );\n', '    }\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    payable\n', '    ensure(deadline)\n', '    {\n', '        require(path[0] == WETH, "RTR: INV_P");\n', '        uint amountIn = msg.value;\n', '        IWETH(WETH).deposit{value: amountIn}();\n', '        assert(IWETH(WETH).transfer(\n', '                CoinvestingDeFiLibrary.pairFor(\n', '                    factory,\n', '                    path[0],\n', '                    path[1]\n', '                ), \n', '                amountIn\n', '            )\n', '        );\n', '        \n', '        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n', '        _swapSupportingFeeOnTransferTokens(\n', '            path,\n', '            to\n', '        );\n', '\n', '        require(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '    }\n', '\n', '    function swapExactTokensForETH(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (uint[] memory amounts)\n', '    {\n', '        require(path[path.length - 1] == WETH, "RTR: INV_P");\n', '        amounts = CoinvestingDeFiLibrary.getAmountsOut(\n', '            factory,\n', '            amountIn,\n', '            path\n', '        );\n', '\n', '        require(amounts[amounts.length - 1] >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ),\n', '            amounts[0]\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            address(this)\n', '        );\n', '\n', '        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(\n', '            to,\n', '            amounts[amounts.length - 1]\n', '        );\n', '    }\n', '    \n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    {\n', '        require(path[path.length - 1] == WETH, "RTR: INV_P");\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ),\n', '            amountIn\n', '        );\n', '\n', '        _swapSupportingFeeOnTransferTokens(\n', '            path,\n', '            address(this)\n', '        );\n', '        \n', '        uint amountOut = IERC20(WETH).balanceOf(address(this));\n', '        require(amountOut >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '\n', '        IWETH(WETH).withdraw(amountOut);\n', '        TransferHelper.safeTransferETH(\n', '            to,\n', '            amountOut\n', '        );\n', '    }\n', '\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (uint[] memory amounts) \n', '    {\n', '        amounts = CoinvestingDeFiLibrary.getAmountsOut(\n', '            factory,\n', '            amountIn,\n', '            path\n', '        );\n', '\n', '        require(amounts[amounts.length - 1] >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '        \n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ), \n', '            amounts[0]\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            to\n', '        );\n', '    }\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    {\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ),\n', '            amountIn\n', '        );\n', '\n', '        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n', '        _swapSupportingFeeOnTransferTokens(\n', '            path,\n', '            to\n', '        );\n', '\n', '        require(IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin, "RTR: INSUF_OUT_AMT");\n', '    }\n', '\n', '    function swapTokensForExactETH(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (uint[] memory amounts)\n', '    {\n', '        require(path[path.length - 1] == WETH, "RTR: INV_P");\n', '        amounts = CoinvestingDeFiLibrary.getAmountsIn(\n', '            factory,\n', '            amountOut,\n', '            path\n', '        );\n', '\n', '        require(amounts[0] <= amountInMax, "RTR: XS_IN_AMT");\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ),\n', '            amounts[0]\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            address(this)\n', '        );\n', '\n', '        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(\n', '            to,\n', '            amounts[amounts.length - 1]\n', '        );\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    external\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (uint[] memory amounts)\n', '    {\n', '        amounts = CoinvestingDeFiLibrary.getAmountsIn(\n', '            factory,\n', '            amountOut,\n', '            path\n', '        );\n', '\n', '        require(amounts[0] <= amountInMax, "RTR: XS_IN_AMT");\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            CoinvestingDeFiLibrary.pairFor(\n', '                factory,\n', '                path[0],\n', '                path[1]\n', '            ),\n', '            amounts[0]\n', '        );\n', '\n', '        _swap(\n', '            amounts,\n', '            path,\n', '            to\n', '        );\n', '    }\n', '\n', '    // Public functions\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    public\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (\n', '        uint amountA,\n', '        uint amountB\n', '    )\n', '    {\n', '        address pair = CoinvestingDeFiLibrary.pairFor(\n', '            factory,\n', '            tokenA,\n', '            tokenB\n', '        );\n', '\n', '        ICoinvestingDeFiPair(pair).transferFrom(\n', '            msg.sender,\n', '            pair,\n', '            liquidity\n', '        );\n', '\n', '        (uint amount0, uint amount1) = ICoinvestingDeFiPair(pair).burn(to);\n', '        (address token0,) = CoinvestingDeFiLibrary.sortTokens(\n', '            tokenA,\n', '            tokenB\n', '        );\n', '\n', '        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n', '        require(amountA >= amountAMin, "RTR: INSUF_A_AMT");\n', '        require(amountB >= amountBMin, "RTR: INSUF_B_AMT");\n', '    }\n', '\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    public\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (\n', '        uint amountToken,\n', '        uint amountETH\n', '    ) \n', '    {\n', '        (amountToken, amountETH) = removeLiquidity(\n', '            token,\n', '            WETH,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            address(this),\n', '            deadline\n', '        );\n', '\n', '        TransferHelper.safeTransfer(\n', '            token,\n', '            to,\n', '            amountToken\n', '        );\n', '\n', '        IWETH(WETH).withdraw(amountETH);\n', '        TransferHelper.safeTransferETH(\n', '            to,\n', '            amountETH\n', '        );\n', '    }\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    )\n', '    public\n', '    virtual\n', '    override\n', '    ensure(deadline)\n', '    returns (uint amountETH)\n', '    {\n', '        (, amountETH) = removeLiquidity(\n', '            token,\n', '            WETH,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            address(this),\n', '            deadline\n', '        );\n', '\n', '        TransferHelper.safeTransfer(\n', '            token,\n', '            to,\n', '            IERC20(token).balanceOf(address(this))\n', '        );\n', '\n', '        IWETH(WETH).withdraw(amountETH);\n', '        TransferHelper.safeTransferETH(\n', '            to,\n', '            amountETH\n', '        );\n', '    }\n', '\n', '    // Internal functions\n', '    function _addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin\n', '    )\n', '    internal\n', '    virtual\n', '    returns (\n', '        uint amountA,\n', '        uint amountB\n', '    )\n', '    {\n', '        if (ICoinvestingDeFiFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n', '            ICoinvestingDeFiFactory(factory).createPair(tokenA, tokenB);\n', '        }\n', '            \n', '        (uint reserveA, uint reserveB) = CoinvestingDeFiLibrary.getReserves(\n', '            factory,\n', '            tokenA,\n', '            tokenB\n', '        );\n', '\n', '        if (reserveA == 0 && reserveB == 0) {\n', '            (amountA, amountB) = (amountADesired, amountBDesired);\n', '        } else {\n', '            uint amountBOptimal = CoinvestingDeFiLibrary.quote(\n', '                amountADesired,\n', '                reserveA,\n', '                reserveB\n', '            );\n', '            if (amountBOptimal <= amountBDesired) {\n', '                require(amountBOptimal >= amountBMin, "RTR: INSUF_B_AMT");\n', '                (amountA, amountB) = (amountADesired, amountBOptimal);\n', '            } else {\n', '                uint amountAOptimal = CoinvestingDeFiLibrary.quote(\n', '                    amountBDesired,\n', '                    reserveB,\n', '                    reserveA\n', '                );\n', '                assert(amountAOptimal <= amountADesired);\n', '                require(amountAOptimal >= amountAMin, "RTR: INSUF_A_AMT");\n', '                (amountA, amountB) = (amountAOptimal, amountBDesired);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _swap(\n', '        uint[] memory amounts,\n', '        address[] memory path,\n', '        address _to\n', '    )\n', '    internal\n', '    virtual\n', '    {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0,) = CoinvestingDeFiLibrary.sortTokens(input, output);\n', '            uint amountOut = amounts[i + 1];\n', '            (uint amount0Out, uint amount1Out) = \n', '                input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n', '\n', '            address to = \n', '                i < path.length - 2 ? \n', '                CoinvestingDeFiLibrary.pairFor(factory, output, path[i + 2]) : _to;\n', '\n', '            ICoinvestingDeFiPair(CoinvestingDeFiLibrary.pairFor(\n', '                    factory,\n', '                    input,\n', '                    output\n', '                )\n', '            ).swap(\n', '                amount0Out,\n', '                amount1Out,\n', '                to,\n', '                new bytes(0)\n', '            );\n', '        }\n', '    }\n', '\n', '    function _swapSupportingFeeOnTransferTokens(\n', '        address[] memory path,\n', '        address _to\n', '    )\n', '    internal\n', '    virtual\n', '    {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0,) = CoinvestingDeFiLibrary.sortTokens(input, output);\n', '            ICoinvestingDeFiPair pair = ICoinvestingDeFiPair(CoinvestingDeFiLibrary.pairFor(\n', '                    factory,\n', '                    input,\n', '                    output\n', '                )\n', '            );\n', '\n', '            uint amountInput;\n', '            uint amountOutput;\n', '            {\n', '                (uint reserve0, uint reserve1,) = pair.getReserves();\n', '                (uint reserveInput, uint reserveOutput) = \n', '                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '                \n', '                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n', '                amountOutput = CoinvestingDeFiLibrary.getAmountOut(\n', '                    amountInput,\n', '                    reserveInput,\n', '                    reserveOutput\n', '                );\n', '            }\n', '\n', '            (uint amount0Out, uint amount1Out) = \n', '                input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n', '            \n', '            address to = \n', '                i < path.length - 2 ? \n', '                CoinvestingDeFiLibrary.pairFor(factory, output, path[i + 2]) : _to;\n', '            \n', '            pair.swap(\n', '                amount0Out,\n', '                amount1Out,\n', '                to,\n', '                new bytes(0)\n', '            );\n', '        }\n', '    }\n', '\n', '    // Public functions that are view\n', '    function getAmountsIn(\n', '        uint amountOut,\n', '        address[] memory path\n', '    )\n', '    public\n', '    view\n', '    virtual\n', '    override\n', '    returns (uint[] memory amounts)\n', '    {\n', '        return CoinvestingDeFiLibrary.getAmountsIn(\n', '            factory,\n', '            amountOut,\n', '            path\n', '        );\n', '    }\n', '\n', '    function getAmountsOut(\n', '        uint amountIn,\n', '        address[] memory path\n', '    )\n', '    public \n', '    view\n', '    virtual\n', '    override\n', '    returns (uint[] memory amounts)\n', '    {\n', '        return CoinvestingDeFiLibrary.getAmountsOut(\n', '            factory,\n', '            amountIn,\n', '            path\n', '        );\n', '    }\n', '\n', '    // Public functions that are pure\n', '    function getAmountIn(\n', '        uint amountOut,\n', '        uint reserveIn,\n', '        uint reserveOut\n', '    )\n', '    public\n', '    pure\n', '    virtual\n', '    override\n', '    returns (uint amountIn)\n', '    {\n', '        return CoinvestingDeFiLibrary.getAmountIn(\n', '            amountOut,\n', '            reserveIn,\n', '            reserveOut\n', '        );\n', '    }\n', '\n', '    function getAmountOut(\n', '        uint amountIn,\n', '        uint reserveIn,\n', '        uint reserveOut\n', '    ) \n', '    public\n', '    pure\n', '    virtual\n', '    override\n', '    returns (uint amountOut)\n', '    {\n', '        return CoinvestingDeFiLibrary.getAmountOut(\n', '            amountIn,\n', '            reserveIn,\n', '            reserveOut\n', '        );\n', '    }\n', '\n', '    function quote(\n', '        uint amountA,\n', '        uint reserveA,\n', '        uint reserveB\n', '    )\n', '    public\n', '    pure\n', '    virtual\n', '    override\n', '    returns (uint amountB)\n', '    {\n', '        return CoinvestingDeFiLibrary.quote(\n', '            amountA,\n', '            reserveA,\n', '            reserveB\n', '        );\n', '    }\n', '}']