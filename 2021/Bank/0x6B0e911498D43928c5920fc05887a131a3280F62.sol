['pragma solidity =0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@uniswap/v2-periphery/contracts/interfaces/IERC20.sol";\n', 'import "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol";\n', '\n', 'import "./UniswapV2Router02.sol";\n', '\n', 'interface NFT {\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) external;\n', '\n', '    // (not part of the ERC721 spec, added to the 5D.co NFT.sol contract)\n', '    function tokensOfOwner(address owner)\n', '        external\n', '        view\n', '        returns (uint256[] memory, string[] memory);\n', '}\n', '\n', 'interface Redeem {\n', '    struct Series {\n', '        uint256 id;\n', '        uint256 limit;\n', '        uint256 minted;\n', '        uint256 initialPrice;\n', '        int256 priceChange;\n', '        // Only set in `getCollections`.\n', '        uint256 currentPrice;\n', '        uint256 nextPrice;\n', '    }\n', '\n', '    struct CollectionFlat {\n', '        uint256 id;\n', '        string title;\n', '        string uriBase;\n', '        uint256 priceChangeTime;\n', '        uint256 initialTimestamp;\n', '        address paymentToken;\n', '        Series[] series;\n', '    }\n', '\n', '    function currentPrice(uint256 collectionId, uint256 seriesId)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function redeem(\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount\n', '    ) external payable;\n', '\n', '    function nft() external returns (NFT);\n', '\n', '    function getCollections() external view returns (CollectionFlat[] memory);\n', '}\n', '\n', 'contract SwapAndRedeem is UniswapV2Router02 {\n', '    using SafeMath for uint256;\n', '\n', '    Redeem public redeem;\n', '    NFT public nft;\n', '\n', '    constructor(\n', '        Redeem _redeem,\n', '        address _factory,\n', '        address _WETH\n', '    ) public UniswapV2Router02(_factory, _WETH) {\n', '        redeem = _redeem;\n', '        nft = redeem.nft();\n', '    }\n', '\n', '    function onERC721Received(\n', '        address operator,\n', '        address from,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external returns (bytes4) {\n', '        return\n', '            bytes4(\n', '                keccak256("onERC721Received(address,address,uint256,bytes)")\n', '            );\n', '    }\n', '\n', '    function forwardNFTsToMsgSender() internal {\n', '        (uint256[] memory tokenIDs, ) = nft.tokensOfOwner(address(this));\n', '        for (uint256 i = 0; i < tokenIDs.length; i++) {\n', '            nft.safeTransferFrom(address(this), msg.sender, tokenIDs[i]);\n', '        }\n', '    }\n', '\n', '    function swapAndRedeem(\n', '        // Redeem parameters\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount,\n', '        // Uniswap parameters\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        uint256 deadline\n', '    ) public payable {\n', '        uint256 price = redeem.currentPrice(collectionId, seriesId);\n', '        uint256 cost = price * amount;\n', '\n', '        UniswapV2Router02.swapTokensForExactTokens(\n', '            cost,\n', '            amountInMax,\n', '            path,\n', '            address(this),\n', '            deadline\n', '        );\n', '\n', '        IERC20 token = IERC20(path[path.length - 1]);\n', '        token.approve(address(redeem), cost);\n', '        redeem.redeem(collectionId, seriesId, amount);\n', '\n', '        forwardNFTsToMsgSender();\n', '    }\n', '\n', '    function swapToEthAndRedeem(\n', '        // Redeem parameters\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount,\n', '        // Uniswap parameters\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        uint256 deadline\n', '    ) public payable {\n', '        uint256 price = redeem.currentPrice(collectionId, seriesId);\n', '        uint256 cost = price * amount;\n', '\n', '        UniswapV2Router02.swapTokensForExactETH(\n', '            cost,\n', '            amountInMax,\n', '            path,\n', '            address(this),\n', '            deadline\n', '        );\n', '\n', '        redeem.redeem.value(cost)(collectionId, seriesId, amount);\n', '\n', '        forwardNFTsToMsgSender();\n', '    }\n', '\n', '    function swapFromEthAndRedeem(\n', '        // Redeem parameters\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount,\n', '        // Uniswap parameters\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        uint256 deadline\n', '    ) public payable {\n', '        uint256 price = redeem.currentPrice(collectionId, seriesId);\n', '        uint256 cost = price * amount;\n', '\n', '        UniswapV2Router02.swapETHForExactTokens(\n', '            cost,\n', '            path,\n', '            address(this),\n', '            deadline\n', '        );\n', '\n', '        IERC20 token = IERC20(path[path.length - 1]);\n', '        token.approve(address(redeem), cost);\n', '        redeem.redeem(collectionId, seriesId, amount);\n', '\n', '        forwardNFTsToMsgSender();\n', '    }\n', '\n', '    function wrapAndRedeem(\n', '        // Redeem parameters\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount\n', '    ) public payable {\n', '        uint256 price = redeem.currentPrice(collectionId, seriesId);\n', '        uint256 cost = price * amount;\n', '\n', '        IWETH(WETH).deposit{value: cost}();\n', '        if (msg.value > cost) {\n', '            // Return change\n', '            payable(msg.sender).transfer(msg.value.sub(cost));\n', '        }\n', '\n', '        IERC20 token = IERC20(WETH);\n', '        token.approve(address(redeem), cost);\n', '        redeem.redeem(collectionId, seriesId, amount);\n', '\n', '        forwardNFTsToMsgSender();\n', '    }\n', '\n', '    function unwrapAndRedeem(\n', '        // Redeem parameters\n', '        uint256 collectionId,\n', '        uint256 seriesId,\n', '        uint256 amount\n', '    ) public payable {\n', '        uint256 price = redeem.currentPrice(collectionId, seriesId);\n', '        uint256 cost = price * amount;\n', '\n', '        IERC20(WETH).transferFrom(msg.sender, address(this), cost);\n', '        IWETH(WETH).withdraw(cost);\n', '\n', '        redeem.redeem{value: cost}(collectionId, seriesId, amount);\n', '\n', '        forwardNFTsToMsgSender();\n', '    }\n', '}\n', '\n', 'pragma solidity =0.6.6;\n', '\n', 'import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";\n', 'import "@uniswap/lib/contracts/libraries/TransferHelper.sol";\n', '\n', 'import "@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol";\n', 'import "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol";\n', 'import "@uniswap/v2-periphery/contracts/interfaces/IERC20.sol";\n', 'import "@uniswap/v2-periphery/contracts/interfaces/IWETH.sol";\n', '\n', 'contract UniswapV2Router02 {\n', '    using SafeMath for uint256;\n', '\n', '    address public immutable factory;\n', '    address public immutable WETH;\n', '\n', '    modifier ensure(uint256 deadline) {\n', '        require(deadline >= block.timestamp, "UniswapV2Router: EXPIRED");\n', '        _;\n', '    }\n', '\n', '    constructor(address _factory, address _WETH) public {\n', '        factory = _factory;\n', '        WETH = _WETH;\n', '    }\n', '\n', '    receive() external payable {\n', '        // require(msg.sender == WETH, "UniswapV2Router: CANNOT_RECEIVE_ETH"); // only accept ETH via fallback from the WETH contract\n', '    }\n', '\n', '    // **** SWAP ****\n', '    // requires the initial amount to have already been sent to the first pair\n', '    function _swap(\n', '        uint256[] memory amounts,\n', '        address[] memory path,\n', '        address _to\n', '    ) internal virtual {\n', '        for (uint256 i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n', '            uint256 amountOut = amounts[i + 1];\n', '            (uint256 amount0Out, uint256 amount1Out) =\n', '                input == token0\n', '                    ? (uint256(0), amountOut)\n', '                    : (amountOut, uint256(0));\n', '            address to =\n', '                i < path.length - 2\n', '                    ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n', '                    : _to;\n', '            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output))\n', '                .swap(amount0Out, amount1Out, to, new bytes(0));\n', '        }\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public virtual ensure(deadline) returns (uint256[] memory amounts) {\n', '        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', '        require(\n', '            amounts[0] <= amountInMax,\n', '            "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT"\n', '        );\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            UniswapV2Library.pairFor(factory, path[0], path[1]),\n', '            amounts[0]\n', '        );\n', '        _swap(amounts, path, to);\n', '    }\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    ) public virtual ensure(deadline) returns (uint256[] memory amounts) {\n', '        require(path[path.length - 1] == WETH, "UniswapV2Router: INVALID_PATH");\n', '        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', '        require(\n', '            amounts[0] <= amountInMax,\n', '            "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT"\n', '        );\n', '        TransferHelper.safeTransferFrom(\n', '            path[0],\n', '            msg.sender,\n', '            UniswapV2Library.pairFor(factory, path[0], path[1]),\n', '            amounts[0]\n', '        );\n', '        _swap(amounts, path, address(this));\n', '        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] memory path,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        public\n', '        payable\n', '        virtual\n', '        ensure(deadline)\n', '        returns (uint256[] memory amounts)\n', '    {\n', '        require(path[0] == WETH, "UniswapV2Router: INVALID_PATH");\n', '        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', '        require(\n', '            amounts[0] <= msg.value,\n', '            "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT"\n', '        );\n', '        IWETH(WETH).deposit{value: amounts[0]}();\n', '        require(\n', '            IWETH(WETH).transfer(\n', '                UniswapV2Library.pairFor(factory, path[0], path[1]),\n', '                amounts[0]\n', '            ),\n', '            "UniswapV2Router: WETH_TRANSFER_FAILED"\n', '        );\n', '        _swap(amounts, path, to);\n', '        // refund dust eth, if any\n', '        if (msg.value > amounts[0])\n', '            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n', '    }\n', '\n', '    // **** LIBRARY FUNCTIONS ****\n', '    function quote(\n', '        uint256 amountA,\n', '        uint256 reserveA,\n', '        uint256 reserveB\n', '    ) public pure virtual returns (uint256 amountB) {\n', '        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n', '    }\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) public pure virtual returns (uint256 amountOut) {\n', '        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) public pure virtual returns (uint256 amountIn) {\n', '        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] memory path)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint256[] memory amounts)\n', '    {\n', '        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n', '    }\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] memory path)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint256[] memory amounts)\n', '    {\n', '        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.6.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', 'pragma solidity =0.6.6;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', "import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\n", '\n', 'import "./SafeMath.sol";\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']