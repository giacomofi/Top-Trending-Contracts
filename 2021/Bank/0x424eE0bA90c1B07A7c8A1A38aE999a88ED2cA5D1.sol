['// SPDX-License-Identifier: P-P-P-PONZO!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./TokensRecoverable.sol";\n', 'import "./IERC31337.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./IERC20.sol";\n', 'import "./RootKitTransferGate.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ILiquidityController.sol";\n', 'import "./IFloorCalculator.sol";\n', '\n', '\n', 'contract LiquidityController is TokensRecoverable, ILiquidityController\n', '\n', '{\n', '    using SafeMath for uint256;\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    IERC20 immutable rooted;\n', '    IERC20 immutable base;\n', '    IERC31337 immutable elite;\n', '    IERC20 immutable rootedEliteLP;\n', '    IERC20 immutable rootedBaseLP;\n', '    IFloorCalculator calculator;\n', '    RootKitTransferGate gate;\n', '    mapping (address => bool) public liquidityControllers;\n', '\n', '    constructor(IUniswapV2Router02 _uniswapV2Router, IERC20 _base, IERC20 _rootedToken, IERC31337 _elite, IFloorCalculator _calculator, RootKitTransferGate _gate)\n', '    {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        IUniswapV2Factory _uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '        \n', '        base = _base;       \n', '        gate = _gate;\n', '        elite = _elite;\n', '        rooted = _rootedToken;\n', '        calculator = _calculator;\n', '\n', '        IERC20 _rootedBaseLP = IERC20(_uniswapV2Factory.getPair(address(_base), address(_rootedToken)));\n', '        IERC20 _rootedEliteLP = IERC20(_uniswapV2Factory.getPair(address(_elite), address(_rootedToken)));\n', '\n', '        _base.approve(address(_uniswapV2Router), uint256(-1));\n', '        _base.approve(address(_elite), uint256(-1));\n', '        _elite.approve(address(_uniswapV2Router), uint256(-1));       \n', '        _rootedToken.approve(address(_uniswapV2Router), uint256(-1));       \n', '        _rootedBaseLP.approve(address(_uniswapV2Router), uint256(-1));       \n', '        _rootedEliteLP.approve(address(_uniswapV2Router), uint256(-1));\n', '\n', '        rootedBaseLP = _rootedBaseLP;\n', '        rootedEliteLP = _rootedEliteLP;\n', '    }\n', '    \n', '    function setCalculatorAndGate(IFloorCalculator _calculator, RootKitTransferGate _gate) public ownerOnly(){\n', '        calculator = _calculator;\n', '        gate = _gate;\n', '    }\n', '    \n', '    function setLiquidityController(address controlAddress, bool controller) public ownerOnly(){\n', '        liquidityControllers[controlAddress] = controller;\n', '    }\n', '\n', '    modifier liquidityControllerOnly(){\n', '        require(liquidityControllers[msg.sender], "Not a Liquidity Controller");\n', '        _;\n', '    }\n', '\n', '    function balancePriceBase(uint256 amount) public override liquidityControllerOnly() {\n', '        amount = buyRootedToken(address(base), amount);\n', '        amount = sellRootedToken(address(elite), amount);\n', '        elite.withdrawTokens(amount);\n', '    }\n', '\n', '    function balancePriceElite(uint256 amount) public override liquidityControllerOnly() {\n', '        elite.depositTokens(amount);\n', '        amount = buyRootedToken(address(elite), amount);\n', '        amount = sellRootedToken(address(base), amount);\n', '    }\n', '\n', '    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) public override liquidityControllerOnly() {\n', '        gate.setUnrestricted(true);\n', '        amount = removeLiq(token, amount);\n', '        buyRootedToken(token, amount);\n', '        gate.setDumpTax(tax, time);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) public override liquidityControllerOnly() { \n', '        buyRootedToken(token, amountToSpend);\n', '        gate.setDumpTax(tax, time);\n', '    }\n', '\n', '    function sweepFloor() public override liquidityControllerOnly() {\n', '        elite.sweepFloor(address(this));\n', '    }\n', '\n', '    function zapEliteToBase(uint256 liquidity) public override liquidityControllerOnly() {\n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(elite), liquidity);\n', '        elite.withdrawTokens(liquidity);\n', '        addLiq(address(base), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function zapBaseToElite(uint256 liquidity) public override liquidityControllerOnly() {\n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(base), liquidity);\n', '        elite.depositTokens(liquidity);\n', '        addLiq(address(elite), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function wrapToElite(uint256 baseAmount) public override liquidityControllerOnly() {\n', '        elite.depositTokens(baseAmount);\n', '    }\n', '    \n', '    function unwrapElite(uint256 eliteAmount) public override liquidityControllerOnly() {\n', '       elite.withdrawTokens(eliteAmount);\n', '    }\n', '\n', '    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override liquidityControllerOnly() {\n', '        gate.setUnrestricted(true);\n', '        addLiq(eliteOrBase, baseAmount);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function removeLiquidity (address eliteOrBase, uint256 tokens) public override liquidityControllerOnly() {\n', '        gate.setUnrestricted(true);\n', '        removeLiq(eliteOrBase, tokens);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    function buyRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\n', '        buyRootedToken(token, amountToSpend);\n', '    }\n', '    \n', '    function sellRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\n', '        sellRootedToken(token, amountToSpend);\n', '    }\n', '\n', '    function addLiq(address eliteOrBase, uint256 baseAmount) internal {\n', '        uniswapV2Router.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n', '    }\n', '    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256) {\n', '        (tokens,) = uniswapV2Router.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\n', '        return tokens;\n', '    }\n', '    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1]; \n', '        return amountToSpend;\n', '    }\n', '    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1]; \n', '        return amountToSpend;\n', '    }\n', '    function buyPath(address token) internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(token);\n', '        path[1] = address(rooted);\n', '        return path;\n', '    }\n', '    function sellPath(address token) internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(rooted);\n', '        path[1] = address(token);\n', '        return path;\n', '    }\n', '}']