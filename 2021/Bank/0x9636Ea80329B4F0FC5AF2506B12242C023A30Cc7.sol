['// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./PriceConfig.sol";\n', 'import "./IUniswapV2Pair.sol";\n', '\n', '/// @title Kine Protocol Oracle V2\n', '/// @author Kine Technology\n', 'contract KineOracleV2 is PriceConfig {\n', '    /// @notice The latest mcd update time\n', '    uint public mcdLastUpdatedAt;\n', '\n', '    /// @notice The scale constant\n', '    uint public constant priceScale = 1e36;\n', '\n', '    /// @notice The kaptain address allowed to operate oracle prices\n', '    address public kaptain;\n', '\n', '    /// @notice The symbol hash of the string "MCD"\n', '    bytes32 public constant mcdHash = keccak256(abi.encodePacked("MCD"));\n', '\n', '    /// @notice The kaptain prices mapped by symbol hash\n', '    mapping(bytes32 => uint) public prices;\n', '\n', '    /// @notice Kaptain post price event\n', '    event PriceUpdated(string symbol, uint price);\n', '\n', '    /// @notice The event emitted when Kaptain is updated\n', '    event KaptainUpdated(address fromAddress, address toAddress);\n', '\n', '    /// @notice Only kaptain can update kaptain price and mcd price\n', '    modifier onlyKaptain(){\n', '        require(kaptain == _msgSender(), "caller is not Kaptain");\n', '        _;\n', '    }\n', '\n', '    constructor(address kaptain_, KTokenConfig[] memory configs) public {\n', '        kaptain = kaptain_;\n', '        for (uint i = 0; i < configs.length; i++) {\n', '            KTokenConfig memory config = configs[i];\n', '            _pushConfig(config);\n', '        }\n', '    }\n', '\n', '    /*********************************************************************************************\n', '     * Price controller needs\n', '     * gup = getUnderlyingPrice                          Pr * 1e36\n', '     * Pr = realPricePerToken                 gup  =  ---------------\n', '     * Ub = baseUnit                                        Ub\n', '     *********************************************************************************************/\n', '    /**\n', '     * @notice Get the underlying price of a kToken\n', '     * @param kToken The kToken address for price retrieval\n', '     * @return Price denominated in USD\n', '     */\n', '    function getUnderlyingPrice(address kToken) public view returns (uint){\n', '        KTokenConfig memory config = getKConfigByKToken(kToken);\n', '        uint price;\n', '        if (config.priceSource == PriceSource.CHAINLINK) {\n', '            price = _calcPrice(_getChainlinkPrice(config), config);\n', '        }else if (config.priceSource == PriceSource.KAPTAIN) {\n', '            price = _calcPrice(_getKaptainPrice(config), config);\n', '        }else if (config.priceSource == PriceSource.LP){\n', '            price = _calcLpPrice(config);\n', '        }else{\n', '            revert("invalid price source");\n', '        }\n', '\n', '        require(price != 0, "invalid price 0");\n', '\n', '        return price;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying price with a token symbol\n', '     * @param symbol The token symbol for price retrieval\n', '     * @return Price denominated in USD\n', '     */\n', '    function getUnderlyingPriceBySymbol(string memory symbol) external view returns (uint){\n', '        KTokenConfig memory config = getKConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n', '        return getUnderlyingPrice(config.kToken);\n', '    }\n', '\n', '    /*********************************************************************************************\n', '     * gup = getUnderlyingPrice\n', '     * Ps = priceFromPriceSource                                  Ps * 1e36\n', '     * Up = priceUnit                                   gup  =  -------------\n', '     * Ub = baseUnit                                                 PM\n', '     * PM = Up * Ub\n', '     *********************************************************************************************/\n', '    /**\n', '     * @notice Calculate the price to fit the price Kine controller needs\n', '     * @param price The price from price source such as chainlink\n', '     * @param config The kToken configuration\n', '     * @return Price denominated in USD\n', '     */\n', '    function _calcPrice(uint price, KTokenConfig memory config) internal pure returns (uint){\n', '        return price.mul(priceScale).div(config.priceMantissa);\n', '    }\n', '\n', '    /*********************************************************************************************\n', '     *  Pl = lpPrice\n', '     *  p0 = token0_PriceFromPriceSource\n', '     *  p1 = token1_PriceFromPriceSource\n', '     *  r0 = reserve0                                 2 * sqrt(p0 * r0) * sqrt(p1 * r1) * 1e36\n', '     *  r1 = reserve1                          Pl = --------------------------------------------\n', '     *  PM0 = Token0_PriceMantissa                         totalSupply * sqrt(PM0 * PM1)\n', '     *  PM1 = Token1_PriceMantissa\n', '     *  totalSupply = LP totalSupply\n', '     *  PriceMantissa = priceUnit * baseUnit\n', '     *********************************************************************************************/\n', '    function _calcLpPrice(KTokenConfig memory config) internal view returns (uint){\n', '        uint numerator;\n', '        uint denominator;\n', '        KTokenConfig memory config0;\n', '        KTokenConfig memory config1;\n', '\n', '        {\n', '            address token0 = IUniswapV2Pair(config.underlying).token0();\n', '            address token1 = IUniswapV2Pair(config.underlying).token1();\n', '            config0 = getKConfigByUnderlying(token0);\n', '            config1 = getKConfigByUnderlying(token1);\n', '        }\n', '\n', '        {\n', '            (uint r0, uint r1, ) = IUniswapV2Pair(config.underlying).getReserves();\n', '            numerator = (_getSourcePrice(config0).mul(r0).sqrt())\n', '                            .mul(_getSourcePrice(config1).mul(r1).sqrt())\n', '                            .mul(2).mul(priceScale);\n', '        }\n', '\n', '        {\n', '            uint totalSupply = IUniswapV2Pair(config.underlying).totalSupply();\n', '            uint pmMultiplier = config0.priceMantissa.mul(config1.priceMantissa);\n', '            denominator = totalSupply.mul(pmMultiplier.sqrt());\n', '        }\n', '\n', '        return numerator.div(denominator);\n', '    }\n', '\n', '    function _getSourcePrice(KTokenConfig memory config) internal view returns (uint){\n', '        if (config.priceSource == PriceSource.CHAINLINK) {\n', '            return _getChainlinkPrice(config);\n', '        }\n', '        if (config.priceSource == PriceSource.KAPTAIN) {\n', '            return _getKaptainPrice(config);\n', '        }\n', '\n', '        revert("invalid config");\n', '    }\n', '\n', '    function _getChainlinkPrice(KTokenConfig memory config) internal view returns (uint){\n', '        // Check aggregator address\n', '        AggregatorV3Interface agg = aggregators[config.symbolHash];\n', '        require(address(agg) != address(0), "aggregator address not found");\n', '        (, int price, , ,) = agg.latestRoundData();\n', '        return uint(price);\n', '    }\n', '\n', '    function _getKaptainPrice(KTokenConfig memory config) internal view returns (uint){\n', '        return prices[config.symbolHash];\n', '    }\n', '\n', '    /// @notice Only Kaptain allowed to operate prices\n', '    function postPrices(string[] calldata symbolArray, uint[] calldata priceArray) external onlyKaptain {\n', '        require(symbolArray.length == priceArray.length, "length mismatch");\n', '        // iterate and set\n', '        for (uint i = 0; i < symbolArray.length; i++) {\n', '            KTokenConfig memory config = getKConfigBySymbolHash(keccak256(abi.encodePacked(symbolArray[i])));\n', '            require(config.priceSource == PriceSource.KAPTAIN, "can only post kaptain price");\n', '            require(config.symbolHash != mcdHash, "cannot post mcd price here");\n', '            require(priceArray[i] != 0, "price cannot be 0");\n', '            prices[config.symbolHash] = priceArray[i];\n', '        }\n', '    }\n', '\n', '    /// @notice Kaptain call to set the latest mcd price\n', '    function postMcdPrice(uint mcdPrice) external onlyKaptain {\n', '        require(mcdPrice != 0, "MCD price cannot be 0");\n', '        mcdLastUpdatedAt = block.timestamp;\n', '        prices[mcdHash] = mcdPrice;\n', '        emit PriceUpdated("MCD", mcdPrice);\n', '    }\n', '\n', '    function changeKaptain(address kaptain_) external onlyOwner {\n', '        require(kaptain != kaptain_, "same kaptain");\n', '        address oldKaptain = kaptain;\n', '        kaptain = kaptain_;\n', '        emit KaptainUpdated(oldKaptain, kaptain);\n', '    }\n', '\n', '    function addConfig(address kToken_, address underlying_, bytes32 symbolHash_, uint baseUnit_, uint priceUnit_,\n', '        PriceSource priceSource_) external onlyOwner {\n', '        KTokenConfig memory config = KTokenConfig({\n', '        kToken : kToken_,\n', '        underlying : underlying_,\n', '        symbolHash : symbolHash_,\n', '        baseUnit : baseUnit_,\n', '        priceUnit : priceUnit_,\n', '        priceMantissa: baseUnit_.mul(priceUnit_),\n', '        priceSource : priceSource_\n', '        });\n', '\n', '        _pushConfig(config);\n', '    }\n', '\n', '    function removeConfigByKToken(address kToken) external onlyOwner {\n', '        KTokenConfig memory configToDelete = _deleteConfigByKToken(kToken);\n', '        // remove all token related information\n', '        delete prices[configToDelete.symbolHash];\n', '    }\n', '}']