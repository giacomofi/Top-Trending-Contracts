['// SPDX-License-Identifier: UNLICENSED\n', '// ALL RIGHTS RESERVED\n', '// Unicrypt by SDDTech reserves all rights on this code. You may NOT copy these contracts.\n', '\n', '// This contract locks ERC20 tokens. This can be used for:\n', '// - Token developers to prove they have locked tokens\n', '// - Presale projects or investors to lock a portion of tokens for a vesting period\n', '// - Farming platforms to lock a percentage of the farmed rewards for a period of time\n', '// - To lock tokens until a specific unlock date.\n', '// - To send tokens to someone under a time lock.\n', '\n', '// This contract is for ERC20 tokens, and supports high deflationary and rebasing tokens by using a pooling and share issuing mechanism.\n', '// This is NOT for AMM LP tokens (such as UNIV2), Please use our liquidity lockers for this.\n', '// Locking LP tokens in this contract will not show in the Unicrypt browser.\n', '\n', '// *** LOCK TYPES ***\n', '// Lock Type 1: when startEmission == 0 the lock is considered lockType 1. This is a normal lock\n', '// whereby tokens can be withdrawn on the due date (endEmission).\n', '\n', '// Lock Type 2: when startEmission != 0. Lock tokens over a period, with an amount withdrawable every block. \n', '// This scales linearly over time from startEmission -> endEmission. \n', '// e.g. If the lock period is 100 seconds, 50 seconds after the startEmission you can withdraw 50% of the lock.\n', '// Instead of making 10 locks for 10 months to withdraw tokens at the end of each month, you can now make 1 linear scaling lock with a period\n', '// of 10 months and withdraw the relative share every block.\n', '\n', '// *** CUSTOM PREMATURE UNLOCKING CONDITIONS ***\n', '// All locks support premature unlocking conditions. A premature unlock condition can be anything that implements the IUnlockCondition interface\n', '// If IUnlockCondition(address).unlockTokens() returns true, the lock withdraw date is overriden and the entire lock value can be withdrawn.\n', '// The key here is this is for premature unlocks, locks always fall back to the endEmission date \n', '// even if unlockTokens() returns false, and are therefore always withdrawble in full by the unlockDate.\n', '// Example use cases, Imagine a presale is 1 week long. Marketers tokens are locked for 1 week to prevent them initiating\n', '// markets and setting initial prices on an AMM. The presale concludes within 5 minuites. Marketers now need to wait 1 week,\n', '// to access their tokens. With conditional unlocks a condition can be set to return true once a presale has concluded\n', '// and override the 1 week lock making their tokens instantly withdrawble post presale. \n', '// Another use case could be to allow token developers or investors to prematurely unlock their tokens\n', '// if the price reaches a specified target, or for governance to vote for developers to unlock tokens prematurely \n', '// for development purposes met or raodmap goals met.\n', '// Get creative!\n', '\n', '// Please be aware if you are locking tokens to prove to your community you have locked tokens for long term you should not use a premature unlocking condition \n', '// as these types of locks will be shown differently in the browser to a normal lock with no unlocking condition.\n', '// Unlocking conditions can always be revoked by the lock owner to give more credibility to the lock.\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./TransferHelper.sol";\n', "import './VestingMathLibrary.sol';\n", "import './FullMath.sol';\n", '\n', 'import "./EnumerableSet.sol";\n', 'import "./Ownable.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./IERC20.sol";\n', '\n', 'interface IMigrator {\n', '    function migrate(address token, uint256 sharesDeposited, uint256 sharesWithdrawn, uint256 startEmission, uint256 endEmission, uint256 lockID, address owner, address condition, uint256 amountInTokens, uint256 option) external returns (bool);\n', '}\n', '\n', 'interface IUnicryptAdmin {\n', '    function userIsAdmin(address _user) external view returns (bool);\n', '}\n', '\n', 'interface ITokenBlacklist {\n', '    function checkToken(address _token) external view;\n', '}\n', '\n', 'contract TokenVesting is Ownable, ReentrancyGuard {\n', '  using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '  struct UserInfo {\n', '    EnumerableSet.AddressSet lockedTokens; // records all token addresses the user has locked\n', '    mapping(address => uint256[]) locksForToken; // map erc20 address to lockId for that token\n', '  }\n', '\n', '  struct TokenLock {\n', '    address tokenAddress; // The token address\n', '    uint256 sharesDeposited; // the total amount of shares deposited\n', '    uint256 sharesWithdrawn; // amount of shares withdrawn\n', '    uint256 startEmission; // date token emission begins\n', '    uint256 endEmission; // the date the tokens can be withdrawn\n', '    uint256 lockID; // lock id per token lock\n', '    address owner; // the owner who can edit or withdraw the lock\n', '    address condition; // address(0) = no condition, otherwise the condition contract must implement IUnlockCondition\n', '  }\n', '  \n', '  struct LockParams {\n', '    address payable owner; // the user who can withdraw tokens once the lock expires.\n', '    uint256 amount; // amount of tokens to lock\n', '    uint256 startEmission; // 0 if lock type 1, else a unix timestamp\n', '    uint256 endEmission; // the unlock date as a unix timestamp (in seconds)\n', '    address condition; // address(0) = no condition, otherwise the condition must implement IUnlockCondition\n', '  }\n', '\n', '  EnumerableSet.AddressSet private TOKENS; // list of all unique tokens that have a lock\n', '  mapping(uint256 => TokenLock) public LOCKS; // map lockID nonce to the lock\n', '  uint256 public NONCE = 0; // incremental lock nonce counter, this is the unique ID for the next lock\n', '  uint256 public MINIMUM_DEPOSIT = 100; // minimum divisibility per lock at time of locking\n', '  \n', '  mapping(address => uint256[]) private TOKEN_LOCKS; // map token address to array of lockIDs for that token\n', '  mapping(address => UserInfo) private USERS;\n', '\n', '  mapping(address => uint) public SHARES; // map token to number of shares per token, shares allow rebasing and deflationary tokens to compute correctly\n', '  \n', '  EnumerableSet.AddressSet private ZERO_FEE_WHITELIST; // Tokens that have been whitelisted to bypass all fees\n', '  EnumerableSet.AddressSet private TOKEN_WHITELISTERS; // whitelisting contracts and users who can enable no fee for tokens.\n', '  \n', '  struct FeeStruct {\n', '    uint256 tokenFee;\n', '    uint256 freeLockingFee;\n', '    address payable feeAddress;\n', '    address freeLockingToken; // if this is address(0) then it is the gas token of the network (e.g ETH, BNB, Matic)\n', '  }\n', '  \n', '  FeeStruct public FEES;\n', '  \n', '  IUnicryptAdmin UNCX_ADMINS;\n', '  IMigrator public MIGRATOR;\n', '  ITokenBlacklist public BLACKLIST; // prevent AMM tokens with a blacklisting contract\n', '\n', '  event onLock(uint256 lockID, address token, address owner, uint256 amountInTokens, uint256 startEmission, uint256 endEmission);\n', '  event onWithdraw(address lpToken, uint256 amountInTokens);\n', '  event onRelock(uint256 lockID, uint256 unlockDate);\n', '  event onTransferLock(uint256 lockIDFrom, uint256 lockIDto, address oldOwner, address newOwner);\n', '  event onSplitLock(uint256 fromLockID, uint256 toLockID, uint256 amountInTokens);\n', '  event onMigrate(uint256 lockID, uint256 amountInTokens);\n', '\n', '  constructor (IUnicryptAdmin _uncxAdmins) {\n', '    UNCX_ADMINS = _uncxAdmins;\n', '    FEES.tokenFee = 35;\n', '    FEES.feeAddress = payable(0xAA3d85aD9D128DFECb55424085754F6dFa643eb1);\n', '    FEES.freeLockingFee = 10e18;\n', '  }\n', '  \n', '  /**\n', '   * @notice set the migrator contract which allows the lock to be migrated\n', '   */\n', '  function setMigrator(IMigrator _migrator) external onlyOwner {\n', '    MIGRATOR = _migrator;\n', '  }\n', '  \n', '  function setBlacklistContract(ITokenBlacklist _contract) external onlyOwner {\n', '    BLACKLIST = _contract;\n', '  }\n', '  \n', '  function setFees(uint256 _tokenFee, uint256 _freeLockingFee, address payable _feeAddress, address _freeLockingToken) external onlyOwner {\n', '    FEES.tokenFee = _tokenFee;\n', '    FEES.freeLockingFee = _freeLockingFee;\n', '    FEES.feeAddress = _feeAddress;\n', '    FEES.freeLockingToken = _freeLockingToken;\n', '  }\n', '  \n', '  /**\n', '   * @notice whitelisted accounts and contracts who can call the editZeroFeeWhitelist function\n', '   */\n', '  function adminSetWhitelister(address _user, bool _add) external onlyOwner {\n', '    if (_add) {\n', '      TOKEN_WHITELISTERS.add(_user);\n', '    } else {\n', '      TOKEN_WHITELISTERS.remove(_user);\n', '    }\n', '  }\n', '  \n', '  // Pay a once off fee to have free use of the lockers for the token\n', '  function payForFreeTokenLocks (address _token) external payable {\n', "      require(!ZERO_FEE_WHITELIST.contains(_token), 'PAID');\n", '      // charge Fee\n', '      if (FEES.freeLockingToken == address(0)) {\n', "          require(msg.value == FEES.freeLockingFee, 'FEE NOT MET');\n", '          FEES.feeAddress.transfer(FEES.freeLockingFee);\n', '      } else {\n', '          TransferHelper.safeTransferFrom(address(FEES.freeLockingToken), address(msg.sender), FEES.feeAddress, FEES.freeLockingFee);\n', '      }\n', '      ZERO_FEE_WHITELIST.add(_token);\n', '  }\n', '  \n', '  // Callable by UNCX_ADMINS or whitelisted contracts (such as presale contracts)\n', '  function editZeroFeeWhitelist (address _token, bool _add) external {\n', "    require(UNCX_ADMINS.userIsAdmin(msg.sender) || TOKEN_WHITELISTERS.contains(msg.sender), 'ADMIN');\n", '    if (_add) {\n', '      ZERO_FEE_WHITELIST.add(_token);\n', '    } else {\n', '      ZERO_FEE_WHITELIST.remove(_token);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Creates one or multiple locks for the specified token\n', '   * @param _token the erc20 token address\n', '   * @param _lock_params an array of locks with format: [LockParams[owner, amount, startEmission, endEmission, condition]]\n', '   * owner: user or contract who can withdraw the tokens\n', '   * amount: must be >= 100 units\n', '   * startEmission = 0 : LockType 1\n', '   * startEmission != 0 : LockType 2 (linear scaling lock)\n', '   * use address(0) for no premature unlocking condition\n', '   * Fails if startEmission is not less than EndEmission\n', '   * Fails is amount < 100\n', '   */\n', '  function lock (address _token, LockParams[] calldata _lock_params) external nonReentrant {\n', "    require(_lock_params.length > 0, 'NO PARAMS');\n", '    if (address(BLACKLIST) != address(0)) {\n', '        BLACKLIST.checkToken(_token);\n', '    }\n', '    uint256 totalAmount = 0;\n', '    for (uint256 i = 0; i < _lock_params.length; i++) {\n', '        totalAmount += _lock_params[i].amount;\n', '    }\n', '\n', '    uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n', '    TransferHelper.safeTransferFrom(_token, address(msg.sender), address(this), totalAmount);\n', '    uint256 amountIn = IERC20(_token).balanceOf(address(this)) - balanceBefore;\n', '\n', '    // Fees\n', '    if (!ZERO_FEE_WHITELIST.contains(_token)) {\n', '      uint256 lockFee = FullMath.mulDiv(amountIn, FEES.tokenFee, 10000);\n', '      TransferHelper.safeTransfer(_token, FEES.feeAddress, lockFee);\n', '      amountIn -= lockFee;\n', '    }\n', '    \n', '    uint256 shares = 0;\n', '    for (uint256 i = 0; i < _lock_params.length; i++) {\n', '        LockParams memory lock_param = _lock_params[i];\n', "        require(lock_param.startEmission < lock_param.endEmission, 'PERIOD');\n", "        require(lock_param.endEmission < 1e10, 'TIMESTAMP INVALID'); // prevents errors when timestamp entered in milliseconds\n", "        require(lock_param.amount >= MINIMUM_DEPOSIT, 'MIN DEPOSIT');\n", '        uint256 amountInTokens = FullMath.mulDiv(lock_param.amount, amountIn, totalAmount);\n', '\n', '        if (SHARES[_token] == 0) {\n', '          shares = amountInTokens;\n', '        } else {\n', '          shares = FullMath.mulDiv(amountInTokens, SHARES[_token], balanceBefore == 0 ? 1 : balanceBefore);\n', '        }\n', "        require(shares > 0, 'SHARES');\n", '        SHARES[_token] += shares;\n', '        balanceBefore += amountInTokens;\n', '\n', '        TokenLock memory token_lock;\n', '        token_lock.tokenAddress = _token;\n', '        token_lock.sharesDeposited = shares;\n', '        token_lock.startEmission = lock_param.startEmission;\n', '        token_lock.endEmission = lock_param.endEmission;\n', '        token_lock.lockID = NONCE;\n', '        token_lock.owner = lock_param.owner;\n', '        if (lock_param.condition != address(0)) {\n', '            // if the condition contract does not implement the interface and return a bool\n', '            // the below line will fail and revert the tx as the conditional contract is invalid\n', '            IUnlockCondition(lock_param.condition).unlockTokens();\n', '            token_lock.condition = lock_param.condition;\n', '        }\n', '    \n', '        // record the lock globally\n', '        LOCKS[NONCE] = token_lock;\n', '        TOKENS.add(_token);\n', '        TOKEN_LOCKS[_token].push(NONCE);\n', '    \n', '        // record the lock for the user\n', '        UserInfo storage user = USERS[lock_param.owner];\n', '        user.lockedTokens.add(_token);\n', '        user.locksForToken[_token].push(NONCE);\n', '        \n', '        NONCE ++;\n', '        emit onLock(token_lock.lockID, _token, token_lock.owner, amountInTokens, token_lock.startEmission, token_lock.endEmission);\n', '    }\n', '  }\n', '  \n', '   /**\n', '   * @notice withdraw a specified amount from a lock. _amount is the ideal amount to be withdrawn.\n', '   * however, this amount might be slightly different in rebasing tokens due to the conversion to shares,\n', '   * then back into an amount\n', '   * @param _lockID the lockID of the lock to be withdrawn\n', '   * @param _amount amount of tokens to withdraw\n', '   */\n', '  function withdraw (uint256 _lockID, uint256 _amount) external nonReentrant {\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(userLock.owner == msg.sender, 'OWNER');\n", '    // convert _amount to its representation in shares\n', '    uint256 balance = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '    uint256 shareDebit = FullMath.mulDiv(SHARES[userLock.tokenAddress], _amount, balance);\n', '    // round _amount up to the nearest whole share if the amount of tokens specified does not translate to\n', '    // at least 1 share.\n', '    if (shareDebit == 0 && _amount > 0) {\n', '      shareDebit ++;\n', '    }\n', "    require(shareDebit > 0, 'ZERO WITHDRAWL');\n", '    uint256 withdrawableShares = getWithdrawableShares(userLock.lockID);\n', '    // dust clearance block, as mulDiv rounds down leaving one share stuck, clear all shares for dust amounts\n', '    if (shareDebit + 1 == withdrawableShares) {\n', '      if (FullMath.mulDiv(SHARES[userLock.tokenAddress], balance / SHARES[userLock.tokenAddress], balance) == 0){\n', '        shareDebit++;\n', '      }\n', '    }\n', "    require(withdrawableShares >= shareDebit, 'AMOUNT');\n", '    userLock.sharesWithdrawn += shareDebit;\n', '\n', '    // now convert shares to the actual _amount it represents, this may differ slightly from the \n', '    // _amount supplied in this methods arguments.\n', '    uint256 amountInTokens = FullMath.mulDiv(shareDebit, balance, SHARES[userLock.tokenAddress]);\n', '    SHARES[userLock.tokenAddress] -= shareDebit;\n', '    \n', '    TransferHelper.safeTransfer(userLock.tokenAddress, msg.sender, amountInTokens);\n', '    emit onWithdraw(userLock.tokenAddress, amountInTokens);\n', '  }\n', '  \n', '  /**\n', '   * @notice extend a lock with a new unlock date, if lock is Type 2 it extends the emission end date\n', '   */\n', '  function relock (uint256 _lockID, uint256 _unlock_date) external nonReentrant {\n', "    require(_unlock_date < 1e10, 'TIME'); // prevents errors when timestamp entered in milliseconds\n", '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(userLock.owner == msg.sender, 'OWNER');\n", "    require(userLock.endEmission < _unlock_date, 'END');\n", '    // percent fee\n', '    if (!ZERO_FEE_WHITELIST.contains(userLock.tokenAddress)) {\n', '        uint256 remainingShares = userLock.sharesDeposited - userLock.sharesWithdrawn;\n', '        uint256 feeInShares = FullMath.mulDiv(remainingShares, FEES.tokenFee, 10000);\n', '        uint256 balance = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '        uint256 feeInTokens = FullMath.mulDiv(feeInShares, balance, SHARES[userLock.tokenAddress] == 0 ? 1 : SHARES[userLock.tokenAddress]);\n', '        TransferHelper.safeTransfer(userLock.tokenAddress, FEES.feeAddress, feeInTokens);\n', '        userLock.sharesWithdrawn += feeInShares;\n', '        SHARES[userLock.tokenAddress] -= feeInShares;\n', '    }\n', '    userLock.endEmission = _unlock_date;\n', '    emit onRelock(_lockID, _unlock_date);\n', '  }\n', '  \n', '  /**\n', '   * @notice increase the amount of tokens per a specific lock, this is preferable to creating a new lock\n', '   * Its possible to increase someone elses lock here it does not need to be your own, useful for contracts\n', '   */\n', '  function incrementLock (uint256 _lockID, uint256 _amount) external nonReentrant {\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(_amount >= MINIMUM_DEPOSIT, 'MIN DEPOSIT');\n", '    \n', '    uint256 balanceBefore = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '    TransferHelper.safeTransferFrom(userLock.tokenAddress, address(msg.sender), address(this), _amount);\n', '    uint256 amountInTokens = IERC20(userLock.tokenAddress).balanceOf(address(this)) - balanceBefore;\n', '\n', '    // percent fee\n', '    if (!ZERO_FEE_WHITELIST.contains(userLock.tokenAddress)) {\n', '        uint256 lockFee = FullMath.mulDiv(amountInTokens, FEES.tokenFee, 10000);\n', '        TransferHelper.safeTransfer(userLock.tokenAddress, FEES.feeAddress, lockFee);\n', '        amountInTokens -= lockFee;\n', '    }\n', '    uint256 shares;\n', '    if (SHARES[userLock.tokenAddress] == 0) {\n', '      shares = amountInTokens;\n', '    } else {\n', '      shares = FullMath.mulDiv(amountInTokens, SHARES[userLock.tokenAddress], balanceBefore);\n', '    }\n', "    require(shares > 0, 'SHARES');\n", '    SHARES[userLock.tokenAddress] += shares;\n', '    userLock.sharesDeposited += shares;\n', '    emit onLock(userLock.lockID, userLock.tokenAddress, userLock.owner, amountInTokens, userLock.startEmission, userLock.endEmission);\n', '  }\n', '  \n', '  /**\n', '   * @notice transfer a lock to a new owner, e.g. presale project -> project owner\n', '   * Please be aware this generates a new lock, and nulls the old lock, so a new ID is assigned to the new lock.\n', '   */\n', '  function transferLockOwnership (uint256 _lockID, address payable _newOwner) external nonReentrant {\n', "    require(msg.sender != _newOwner, 'SELF');\n", '    TokenLock storage transferredLock = LOCKS[_lockID];\n', "    require(transferredLock.owner == msg.sender, 'OWNER');\n", '    \n', '    TokenLock memory token_lock;\n', '    token_lock.tokenAddress = transferredLock.tokenAddress;\n', '    token_lock.sharesDeposited = transferredLock.sharesDeposited;\n', '    token_lock.sharesWithdrawn = transferredLock.sharesWithdrawn;\n', '    token_lock.startEmission = transferredLock.startEmission;\n', '    token_lock.endEmission = transferredLock.endEmission;\n', '    token_lock.lockID = NONCE;\n', '    token_lock.owner = _newOwner;\n', '    token_lock.condition = transferredLock.condition;\n', '    \n', '    // record the lock globally\n', '    LOCKS[NONCE] = token_lock;\n', '    TOKEN_LOCKS[transferredLock.tokenAddress].push(NONCE);\n', '    \n', '    // record the lock for the new owner \n', '    UserInfo storage newOwner = USERS[_newOwner];\n', '    newOwner.lockedTokens.add(transferredLock.tokenAddress);\n', '    newOwner.locksForToken[transferredLock.tokenAddress].push(token_lock.lockID);\n', '    NONCE ++;\n', '    \n', '    // zero the lock from the old owner\n', '    transferredLock.sharesWithdrawn = transferredLock.sharesDeposited;\n', '    emit onTransferLock(_lockID, token_lock.lockID, msg.sender, _newOwner);\n', '  }\n', '  \n', '  /**\n', '   * @notice split a lock into two seperate locks, useful when a lock is about to expire and youd like to relock a portion\n', '   * and withdraw a smaller portion\n', '   * Only works on lock type 1, this feature does not work with lock type 2\n', '   * @param _amount the amount in tokens\n', '   */\n', '  function splitLock (uint256 _lockID, uint256 _amount) external nonReentrant {\n', "    require(_amount > 0, 'ZERO AMOUNT');\n", '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(userLock.owner == msg.sender, 'OWNER');\n", "    require(userLock.startEmission == 0, 'LOCK TYPE 2');\n", '\n', '    // convert _amount to its representation in shares\n', '    uint256 balance = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '    uint256 amountInShares = FullMath.mulDiv(SHARES[userLock.tokenAddress], _amount, balance);\n', '\n', '    require(userLock.sharesWithdrawn + amountInShares <= userLock.sharesDeposited);\n', '    \n', '    TokenLock memory token_lock;\n', '    token_lock.tokenAddress = userLock.tokenAddress;\n', '    token_lock.sharesDeposited = amountInShares;\n', '    token_lock.endEmission = userLock.endEmission;\n', '    token_lock.lockID = NONCE;\n', '    token_lock.owner = msg.sender;\n', '    token_lock.condition = userLock.condition;\n', '    \n', '    // debit previous lock\n', '    userLock.sharesWithdrawn += amountInShares;\n', '    \n', '    // record the new lock globally\n', '    LOCKS[NONCE] = token_lock;\n', '    TOKEN_LOCKS[userLock.tokenAddress].push(NONCE);\n', '    \n', '    // record the new lock for the owner \n', '    USERS[msg.sender].locksForToken[userLock.tokenAddress].push(token_lock.lockID);\n', '    NONCE ++;\n', '    emit onSplitLock(_lockID, token_lock.lockID, _amount);\n', '  }\n', '  \n', '  /**\n', '   * @notice migrates to the next locker version, only callable by lock owners\n', '   */\n', '  function migrate (uint256 _lockID, uint256 _option) external nonReentrant {\n', '    require(address(MIGRATOR) != address(0), "NOT SET");\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(userLock.owner == msg.sender, 'OWNER');\n", '    uint256 sharesAvailable = userLock.sharesDeposited - userLock.sharesWithdrawn;\n', "    require(sharesAvailable > 0, 'AMOUNT');\n", '\n', '    uint256 balance = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '    uint256 amountInTokens = FullMath.mulDiv(sharesAvailable, balance, SHARES[userLock.tokenAddress]);\n', '    \n', '    TransferHelper.safeApprove(userLock.tokenAddress, address(MIGRATOR), amountInTokens);\n', '    MIGRATOR.migrate(userLock.tokenAddress, userLock.sharesDeposited, userLock.sharesWithdrawn, userLock.startEmission,\n', '    userLock.endEmission, userLock.lockID, userLock.owner, userLock.condition, amountInTokens, _option);\n', '    \n', '    userLock.sharesWithdrawn = userLock.sharesDeposited;\n', '    SHARES[userLock.tokenAddress] -= sharesAvailable;\n', '    emit onMigrate(_lockID, amountInTokens);\n', '  }\n', '  \n', '  /**\n', '   * @notice premature unlock conditions can be malicous (prevent withdrawls by failing to evalaute or return non bools)\n', '   * or not give community enough insurance tokens will remain locked until the end date, in such a case, it can be revoked\n', '   */\n', '  function revokeCondition (uint256 _lockID) external nonReentrant {\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', "    require(userLock.owner == msg.sender, 'OWNER');\n", '    require(userLock.condition != address(0)); // already set to address(0)\n', '    userLock.condition = address(0);\n', '  }\n', '  \n', '  // test a condition on front end, added here for convenience in UI, returns unlockTokens() bool, or fails\n', '  function testCondition (address condition) external view returns (bool) {\n', '      return (IUnlockCondition(condition).unlockTokens());\n', '  }\n', '  \n', '  // returns withdrawable share amount from the lock, taking into consideration start and end emission\n', '  function getWithdrawableShares (uint256 _lockID) public view returns (uint256) {\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', '    uint8 lockType = userLock.startEmission == 0 ? 1 : 2;\n', '    uint256 amount = lockType == 1 ? userLock.sharesDeposited - userLock.sharesWithdrawn : userLock.sharesDeposited;\n', '    uint256 withdrawable;\n', '    withdrawable = VestingMathLibrary.getWithdrawableAmount (\n', '      userLock.startEmission, \n', '      userLock.endEmission, \n', '      amount, \n', '      block.timestamp, \n', '      userLock.condition\n', '    );\n', '    if (lockType == 2) {\n', '      withdrawable -= userLock.sharesWithdrawn;\n', '    }\n', '    return withdrawable;\n', '  }\n', '  \n', '  // convenience function for UI, converts shares to the current amount in tokens\n', '  function getWithdrawableTokens (uint256 _lockID) external view returns (uint256) {\n', '    TokenLock storage userLock = LOCKS[_lockID];\n', '    uint256 withdrawableShares = getWithdrawableShares(userLock.lockID);\n', '    uint256 balance = IERC20(userLock.tokenAddress).balanceOf(address(this));\n', '    uint256 amountTokens = FullMath.mulDiv(withdrawableShares, balance, SHARES[userLock.tokenAddress] == 0 ? 1 : SHARES[userLock.tokenAddress]);\n', '    return amountTokens;\n', '  }\n', '\n', '  // For UI use\n', '  function convertSharesToTokens (address _token, uint256 _shares) external view returns (uint256) {\n', '    uint256 balance = IERC20(_token).balanceOf(address(this));\n', '    return FullMath.mulDiv(_shares, balance, SHARES[_token]);\n', '  }\n', '\n', '  function convertTokensToShares (address _token, uint256 _tokens) external view returns (uint256) {\n', '    uint256 balance = IERC20(_token).balanceOf(address(this));\n', '    return FullMath.mulDiv(SHARES[_token], _tokens, balance);\n', '  }\n', '  \n', '  // For use in UI, returns more useful lock Data than just querying LOCKS,\n', '  // such as the real-time token amount representation of a locks shares\n', '  function getLock (uint256 _lockID) external view returns (uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, address, address) {\n', '      TokenLock memory tokenLock = LOCKS[_lockID];\n', '\n', '      uint256 balance = IERC20(tokenLock.tokenAddress).balanceOf(address(this));\n', '      uint256 totalSharesOr1 = SHARES[tokenLock.tokenAddress] == 0 ? 1 : SHARES[tokenLock.tokenAddress];\n', '      // tokens deposited and tokens withdrawn is provided for convenience in UI, with rebasing these amounts will change\n', '      uint256 tokensDeposited = FullMath.mulDiv(tokenLock.sharesDeposited, balance, totalSharesOr1);\n', '      uint256 tokensWithdrawn = FullMath.mulDiv(tokenLock.sharesWithdrawn, balance, totalSharesOr1);\n', '      return (tokenLock.lockID, tokenLock.tokenAddress, tokensDeposited, tokensWithdrawn, tokenLock.sharesDeposited, tokenLock.sharesWithdrawn, tokenLock.startEmission, tokenLock.endEmission, \n', '      tokenLock.owner, tokenLock.condition);\n', '  }\n', '  \n', '  function getNumLockedTokens () external view returns (uint256) {\n', '    return TOKENS.length();\n', '  }\n', '  \n', '  function getTokenAtIndex (uint256 _index) external view returns (address) {\n', '    return TOKENS.at(_index);\n', '  }\n', '  \n', '  function getTokenLocksLength (address _token) external view returns (uint256) {\n', '    return TOKEN_LOCKS[_token].length;\n', '  }\n', '  \n', '  function getTokenLockIDAtIndex (address _token, uint256 _index) external view returns (uint256) {\n', '    return TOKEN_LOCKS[_token][_index];\n', '  }\n', '  \n', '  // user functions\n', '  function getUserLockedTokensLength (address _user) external view returns (uint256) {\n', '    return USERS[_user].lockedTokens.length();\n', '  }\n', '  \n', '  function getUserLockedTokenAtIndex (address _user, uint256 _index) external view returns (address) {\n', '    return USERS[_user].lockedTokens.at(_index);\n', '  }\n', '  \n', '  function getUserLocksForTokenLength (address _user, address _token) external view returns (uint256) {\n', '    return USERS[_user].locksForToken[_token].length;\n', '  }\n', '  \n', '  function getUserLockIDForTokenAtIndex (address _user, address _token, uint256 _index) external view returns (uint256) {\n', '    return USERS[_user].locksForToken[_token][_index];\n', '  }\n', '  \n', '  // no Fee Tokens\n', '  function getZeroFeeTokensLength () external view returns (uint256) {\n', '    return ZERO_FEE_WHITELIST.length();\n', '  }\n', '  \n', '  function getZeroFeeTokenAtIndex (uint256 _index) external view returns (address) {\n', '    return ZERO_FEE_WHITELIST.at(_index);\n', '  }\n', '  \n', '  function tokenOnZeroFeeWhitelist (address _token) external view returns (bool) {\n', '    return ZERO_FEE_WHITELIST.contains(_token);\n', '  }\n', '  \n', '  // whitelist\n', '  function getTokenWhitelisterLength () external view returns (uint256) {\n', '    return TOKEN_WHITELISTERS.length();\n', '  }\n', '  \n', '  function getTokenWhitelisterAtIndex (uint256 _index) external view returns (address) {\n', '    return TOKEN_WHITELISTERS.at(_index);\n', '  }\n', '  \n', '  function getTokenWhitelisterStatus (address _user) external view returns (bool) {\n', '    return TOKEN_WHITELISTERS.contains(_user);\n', '  }\n', '}']