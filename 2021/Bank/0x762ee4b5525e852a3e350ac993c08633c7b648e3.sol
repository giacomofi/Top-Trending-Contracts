['# Copyright (C) 2021 VolumeFi Software, Inc.\n', '\n', '#  This program is free software: you can redistribute it and/or modify\n', '#  it under the terms of the Apache 2.0 License. \n', '#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\n', '#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n', '#  @author VolumeFi, Software inc.\n', '#  @notice This Vyper contract is for Dancing Bananas.\n', '#  SPDX-License-Identifier: Apache-2.0\n', '\n', '# @version ^0.2.12\n', '\n', 'struct MintParams:\n', '    token0: address\n', '    token1: address\n', '    fee: uint256\n', '    tickLower: int128\n', '    tickUpper: int128\n', '    amount0Desired: uint256\n', '    amount1Desired: uint256\n', '    amount0Min: uint256\n', '    amount1Min: uint256\n', '    recipient: address\n', '    deadline: uint256\n', '\n', 'struct SingleMintParams:\n', '    token0: address\n', '    token1: address\n', '    fee: uint256\n', '    tickLower: int128\n', '    tickUpper: int128\n', '    sqrtPriceAX96: uint256\n', '    sqrtPriceBX96: uint256\n', '    liquidityMin: uint256\n', '    recipient: address\n', '    deadline: uint256\n', '\n', 'struct RemoveParams:\n', '    liquidity: uint256\n', '    recipient: address\n', '    deadline: uint256\n', '\n', 'interface WrappedEth:\n', '    def deposit(): payable\n', '    def withdraw(amount: uint256): nonpayable\n', '\n', 'interface NonfungiblePositionManager:\n', '    def burn(tokenId: uint256): payable\n', '\n', 'interface ERC20:\n', '    def approve(account: address, amount: uint256): nonpayable\n', '    def transfer(account: address, amount: uint256): nonpayable\n', '    def transferFrom(_from: address, _to: address, amount: uint256): nonpayable\n', '\n', 'interface UniswapV2Factory:\n', '    def getPair(tokenA: address, tokenB: address) -> address: view\n', '\n', 'interface UniswapV2Pair:\n', '    def token0() -> address: view\n', '    def getReserves() -> (uint256, uint256, uint256): view\n', '\n', 'event AddedLiquidity:\n', '    tokenId: indexed(uint256)\n', '    token0: indexed(address)\n', '    token1: indexed(address)\n', '    liquidity: uint256\n', '    amount0: uint256\n', '    amount1: uint256\n', '\n', 'event RemovedLiquidity:\n', '    tokenId: indexed(uint256)\n', '    token0: indexed(address)\n', '    token1: indexed(address)\n', '    liquidity: uint256\n', '    amount0: uint256\n', '    amount1: uint256\n', '\n', 'event Paused:\n', '    paused: bool\n', '\n', 'event FeeChanged:\n', '    newFee: uint256\n', '\n', 'NONFUNGIBLEPOSITIONMANAGER: constant(address) = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n', 'UNISWAPV3FACTORY: constant(address) = 0x1F98431c8aD98523631AE4a59f267346ea31F984\n', 'UNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\n', 'UNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', 'VETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', 'WETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', '\n', 'CAIPIN_MID: constant(Bytes[4]) = method_id("createAndInitializePoolIfNecessary(address,address,uint24,uint160)")\n', 'GETPOOL_MID: constant(Bytes[4]) = method_id("getPool(address,address,uint24)")\n', 'SLOT0_MID: constant(Bytes[4]) = method_id("slot0()")\n', 'MINT_MID: constant(Bytes[4]) = method_id("mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))")\n', 'INCREASELIQUIDITY_MID: constant(Bytes[4]) = method_id("increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))")\n', 'DECREASELIQUIDITY_MID: constant(Bytes[4]) = method_id("decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))")\n', 'POSITIONS_MID: constant(Bytes[4]) = method_id("positions(uint256)")\n', 'COLLECT_MID: constant(Bytes[4]) = method_id("collect((uint256,address,uint128,uint128))")\n', 'SWAPETFT_MID: constant(Bytes[4]) = method_id("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")\n', '\n', 'ADDLIQETH_MID: constant(Bytes[4]) = method_id("addLiquidityEthForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256))")\n', '_ADDLIQETH_MID: constant(Bytes[4]) = method_id("_addLiquidityEthForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256),address,uint256)")\n', 'ADDLIQ_MID: constant(Bytes[4]) = method_id("addLiquidityForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256))")\n', '_ADDLIQ_MID: constant(Bytes[4]) = method_id("_addLiquidityForUniV3(uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,uint256,address,uint256),address)")\n', 'INVEST_MID: constant(Bytes[4]) = method_id("investTokenForUniPair(uint256,address,uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,address,uint256))")\n', '_INVEST_MID: constant(Bytes[4]) = method_id("_investTokenForUniPair(uint256,address,uint256,(address,address,uint256,int128,int128,uint256,uint256,uint256,address,uint256),address,uint256)")\n', 'REMOVELIQ_MID: constant(Bytes[4]) = method_id("removeLiquidityFromUniV3NFLP(uint256,(uint256,address,uint256))")\n', '_REMOVELIQ_MID: constant(Bytes[4]) = method_id("_removeLiquidityFromUniV3NFLP(uint256,(uint256,address,uint256))")\n', 'REMOVELIQETH_MID: constant(Bytes[4]) = method_id("removeLiquidityEthFromUniV3NFLP(uint256,(uint256,address,uint256))")\n', '_REMOVELIQETH_MID: constant(Bytes[4]) = method_id("_removeLiquidityEthFromUniV3NFLP(uint256,(uint256,address,uint256))")\n', 'DIVEST_MID: constant(Bytes[4]) = method_id("divestUniV3NFLPToToken(uint256,address,(uint256,address,uint256),uint256)")\n', '_DIVEST_MID: constant(Bytes[4]) = method_id("_divestUniV3NFLPToToken(uint256,address,(uint256,address,uint256),uint256)")\n', '\n', 'paused: public(bool)\n', 'admin: public(address)\n', 'feeAddress: public(address)\n', 'feeAmount: public(uint256)\n', '\n', '@external\n', 'def __init__():\n', '    self.paused = False\n', '    self.admin = msg.sender\n', '    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\n', '    self.feeAmount = 5 * 10 ** 15\n', '\n', '@internal\n', '@pure\n', 'def getCurrentSqrtPriceX96(token0: address, token1: address, feeLevel: uint256) -> uint256:\n', '    _response32: Bytes[32] = raw_call(\n', '        UNISWAPV3FACTORY,\n', '        concat(\n', '            GETPOOL_MID,\n', '            convert(token0, bytes32),\n', '            convert(token1, bytes32),\n', '            convert(feeLevel, bytes32)\n', '        ),\n', '        max_outsize=32,\n', '        is_static_call=True\n', '    )\n', '    pool: address = convert(convert(_response32, bytes32), address)\n', '    assert pool != ZERO_ADDRESS\n', '    _response224: Bytes[224] = raw_call(\n', '        pool,\n', '        SLOT0_MID,\n', '        max_outsize=224,\n', '        is_static_call=True\n', '    )\n', '    sqrtPriceX96: uint256 = convert(slice(_response224, 0, 32), uint256)\n', '    assert sqrtPriceX96 != 0\n', '    return sqrtPriceX96\n', '\n', '@internal\n', 'def addLiquidity(_tokenId: uint256, sender: address, uniV3Params: MintParams, _sqrtPriceX96: uint256 = 0) -> (uint256, uint256, uint256):\n', '    ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount0Desired)\n', '    ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount1Desired)\n', '    if _tokenId == 0:\n', '        sqrtPriceX96: uint256 = _sqrtPriceX96\n', '        if sqrtPriceX96 == 0:\n', '            sqrtPriceX96 = self.getCurrentSqrtPriceX96(uniV3Params.token0, uniV3Params.token1, uniV3Params.fee)\n', '        _response32: Bytes[32] = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                CAIPIN_MID,\n', '                convert(uniV3Params.token0, bytes32),\n', '                convert(uniV3Params.token1, bytes32),\n', '                convert(uniV3Params.fee, bytes32),\n', '                convert(sqrtPriceX96, bytes32)\n', '            ),\n', '            max_outsize=32\n', '        )\n', '        assert convert(convert(_response32, bytes32), address) != ZERO_ADDRESS\n', '        _response128: Bytes[128] = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                MINT_MID,\n', '                convert(uniV3Params.token0, bytes32),\n', '                convert(uniV3Params.token1, bytes32),\n', '                convert(uniV3Params.fee, bytes32),\n', '                convert(uniV3Params.tickLower, bytes32),\n', '                convert(uniV3Params.tickUpper, bytes32),\n', '                convert(uniV3Params.amount0Desired, bytes32),\n', '                convert(uniV3Params.amount1Desired, bytes32),\n', '                convert(uniV3Params.amount0Min, bytes32),\n', '                convert(uniV3Params.amount1Min, bytes32),\n', '                convert(uniV3Params.recipient, bytes32),\n', '                convert(uniV3Params.deadline, bytes32)\n', '            ),\n', '            max_outsize=128\n', '        )\n', '        tokenId: uint256 = convert(slice(_response128, 0, 32), uint256)\n', '        liquidity: uint256 = convert(slice(_response128, 32, 32), uint256)\n', '        amount0: uint256 = convert(slice(_response128, 64, 32), uint256)\n', '        amount1: uint256 = convert(slice(_response128, 96, 32), uint256)\n', '        log AddedLiquidity(tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\n', '        return (amount0, amount1, liquidity)\n', '    else:\n', '        liquidity: uint256 = 0\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        _response96: Bytes[96] = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                INCREASELIQUIDITY_MID,\n', '                convert(_tokenId, bytes32),\n', '                convert(uniV3Params.amount0Desired, bytes32),\n', '                convert(uniV3Params.amount1Desired, bytes32),\n', '                convert(uniV3Params.amount0Min, bytes32),\n', '                convert(uniV3Params.amount1Min, bytes32),\n', '                convert(uniV3Params.deadline, bytes32)\n', '            ),\n', '            max_outsize=96\n', '        )\n', '        liquidity = convert(slice(_response96, 0, 32), uint256)\n', '        amount0 = convert(slice(_response96, 32, 32), uint256)\n', '        amount1 = convert(slice(_response96, 64, 32), uint256)\n', '        log AddedLiquidity(_tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\n', '        return (amount0, amount1, liquidity)\n', '\n', '@internal\n', 'def removeLiquidity(_tokenId: uint256, _removeParams: RemoveParams, _recipient: address=ZERO_ADDRESS) -> (address, address, uint256, uint256):\n', '    _response384: Bytes[384] = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            POSITIONS_MID,\n', '            convert(_tokenId, bytes32)\n', '        ),\n', '        max_outsize=384,\n', '        is_static_call=True\n', '    )\n', '    token0: address = convert(convert(slice(_response384, 64, 32), uint256), address)\n', '    token1: address = convert(convert(slice(_response384, 96, 32), uint256), address)\n', '    liquidity: uint256 = convert(slice(_response384, 224, 32), uint256)\n', '    isBurn: bool = False\n', '    if liquidity <= _removeParams.liquidity:\n', '        isBurn = True\n', '    else:\n', '        liquidity = _removeParams.liquidity\n', '    _response64: Bytes[64] = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            DECREASELIQUIDITY_MID,\n', '            convert(_tokenId, bytes32),\n', '            convert(liquidity, bytes32),\n', '            convert(0, bytes32),\n', '            convert(0, bytes32),\n', '            convert(_removeParams.deadline, bytes32)\n', '        ),\n', '        max_outsize=64\n', '    )\n', '    recipient: address = _recipient\n', '    if _recipient == ZERO_ADDRESS:\n', '        recipient = _removeParams.recipient\n', '\n', '    _response64 = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            COLLECT_MID,\n', '            convert(_tokenId, bytes32),\n', '            convert(recipient, bytes32),\n', '            convert(2 ** 128 - 1, bytes32),\n', '            convert(2 ** 128 - 1, bytes32)\n', '        ),\n', '        max_outsize=64\n', '    )\n', '    amount0: uint256 = convert(slice(_response64, 0, 32), uint256)\n', '    amount1: uint256 = convert(slice(_response64, 32, 32), uint256)\n', '    if isBurn:\n', '        NonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).burn(_tokenId)\n', '\n', '    log RemovedLiquidity(_tokenId, token0, token1, liquidity, amount0, amount1)\n', '\n', '    return (token0, token1, amount0, amount1)\n', '\n', '@external\n', 'def _addLiquidityEthForUniV3(_tokenId: uint256, uniV3Params: MintParams, msg_sender: address, msg_value: uint256):\n', '    assert msg.sender == self\n', '    assert not self.paused\n', '    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\n', '    if uniV3Params.token0 == WETH:\n', '        if msg_value > uniV3Params.amount0Desired:\n', '            send(msg_sender, msg_value - uniV3Params.amount0Desired)\n', '        else:\n', '            assert msg_value == uniV3Params.amount0Desired\n', '        WrappedEth(WETH).deposit(value=uniV3Params.amount0Desired)\n', '        ERC20(uniV3Params.token1).transferFrom(msg_sender, self, uniV3Params.amount1Desired)\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        liquidity: uint256 = 0\n', '        (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\n', '        amount0 = uniV3Params.amount0Desired - amount0\n', '        amount1 = uniV3Params.amount1Desired - amount1\n', '        if amount0 > 0:\n', '            WrappedEth(WETH).withdraw(amount0)\n', '            send(msg_sender, amount0)\n', '            ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '        if amount1 > 0:\n', '            ERC20(uniV3Params.token1).transfer(msg_sender, amount1)\n', '            ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    else:\n', '        assert uniV3Params.token1 == WETH\n', '        if msg_value > uniV3Params.amount1Desired:\n', '            send(msg_sender, msg_value - uniV3Params.amount1Desired)\n', '        else:\n', '            assert msg_value == uniV3Params.amount1Desired\n', '        WrappedEth(WETH).deposit(value=uniV3Params.amount1Desired)\n', '        ERC20(uniV3Params.token0).transferFrom(msg_sender, self, uniV3Params.amount0Desired)\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        liquidity: uint256 = 0\n', '        (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\n', '        amount0 = uniV3Params.amount0Desired - amount0\n', '        amount1 = uniV3Params.amount1Desired - amount1\n', '        if amount0 > 0:\n', '            ERC20(uniV3Params.token0).transfer(msg_sender, amount0)\n', '            ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '        if amount1 > 0:\n', '            WrappedEth(WETH).withdraw(amount1)\n', '            send(msg_sender, amount1)\n', '            ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '\n', '@external\n', 'def _addLiquidityForUniV3(_tokenId: uint256, uniV3Params: MintParams, msg_sender: address):\n', '    assert msg.sender == self\n', '    assert not self.paused\n', '    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\n', '    ERC20(uniV3Params.token0).transferFrom(msg_sender, self, uniV3Params.amount0Desired)\n', '    ERC20(uniV3Params.token1).transferFrom(msg_sender, self, uniV3Params.amount1Desired)\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    liquidity: uint256 = 0\n', '    (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params)\n', '    amount0 = uniV3Params.amount0Desired - amount0\n', '    amount1 = uniV3Params.amount1Desired - amount1\n', '    if amount0 > 0:\n', '        ERC20(uniV3Params.token0).transfer(msg_sender, amount0)\n', '        ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    if amount1 > 0:\n', '        ERC20(uniV3Params.token1).transfer(msg_sender, amount1)\n', '        ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '\n', '@external\n', 'def _removeLiquidityFromUniV3NFLP(_tokenId: uint256, _removeParams: RemoveParams):\n', '    assert msg.sender == self\n', '    assert _tokenId != 0\n', '    self.removeLiquidity(_tokenId, _removeParams)\n', '\n', '@external\n', 'def _removeLiquidityEthFromUniV3NFLP(_tokenId: uint256, _removeParams: RemoveParams):\n', '    assert msg.sender == self\n', '    assert _tokenId != 0\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    (token0, token1, amount0, amount1) = self.removeLiquidity(_tokenId, _removeParams, self)\n', '    if token0 == WETH and token1 != WETH:\n', '        WrappedEth(token0).withdraw(amount0)\n', '        send(_removeParams.recipient, amount0)\n', '        ERC20(token1).transfer(_removeParams.recipient, amount1)\n', '    elif token1 == WETH and token0 != WETH:\n', '        WrappedEth(token1).withdraw(amount1)\n', '        send(_removeParams.recipient, amount1)\n', '        ERC20(token0).transfer(_removeParams.recipient, amount0)\n', '    else:\n', '        raise "Not Eth Pair"\n', '\n', '@internal\n', 'def token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\n', '    if fromToken == toToken:\n', '        return tokens2Trade\n', '    ERC20(fromToken).approve(UNISWAPV2ROUTER02, tokens2Trade)\n', '    _response: Bytes[128] = raw_call(\n', '        UNISWAPV2ROUTER02,\n', '        concat(\n', '            SWAPETFT_MID,\n', '            convert(tokens2Trade, bytes32),\n', '            convert(0, bytes32),\n', '            convert(160, bytes32),\n', '            convert(self, bytes32),\n', '            convert(deadline, bytes32),\n', '            convert(2, bytes32),\n', '            convert(fromToken, bytes32),\n', '            convert(toToken, bytes32)\n', '        ),\n', '        max_outsize=128\n', '    )\n', '    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\n', '    ERC20(fromToken).approve(UNISWAPV2ROUTER02, 0)\n', '    assert tokenBought > 0\n', '    return tokenBought\n', '\n', '@internal\n', '@view\n', 'def getVirtualPriceX96(sqrtPriceAX96: uint256, sqrtPriceX96: uint256, sqrtPriceBX96: uint256) -> uint256:\n', '    ret: uint256 = (sqrtPriceBX96 - sqrtPriceX96) * 2 ** 96 / sqrtPriceBX96 * 2 ** 96 / sqrtPriceX96 * 2 ** 96 / (sqrtPriceX96 - sqrtPriceAX96)\n', '    if ret > 2 ** 160:\n', '        return 2 ** 160\n', '    else:\n', '        return ret\n', '\n', '@internal\n', '@pure\n', 'def uintSqrt(x: uint256) -> uint256:\n', '    if x > 3:\n', '        z: uint256 = (x + 1) / 2\n', '        y: uint256 = x\n', '        for i in range(256):\n', '            if y == z:\n', '                return y\n', '            y = z\n', '            z = (x / z + z) / 2\n', '        raise "Did not coverage"\n', '    elif x == 0:\n', '        return 0\n', '    else:\n', '        return 1\n', '\n', '@internal\n', '@view\n', 'def getUserInForSqrtPriceX96(reserveIn: uint256, reserveOut: uint256, priceX96: uint256, toInvest: uint256) -> uint256:\n', '    b: uint256 = reserveIn + (reserveOut * 997 / 1000 * 2 ** 96 / priceX96) - toInvest * 997 / 1000\n', '    return (self.uintSqrt(b * b + 4 * reserveIn * toInvest * 997 / 1000) - b) * 1000 / 1994\n', '\n', '@internal\n', '@pure\n', 'def _getLiquidityInPool(midToken: address, pair: address) -> uint256:\n', '    res0: uint256 = 0\n', '    res1: uint256 = 0\n', '    blockTimestampLast: uint256 = 0\n', '    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '    token0: address = UniswapV2Pair(pair).token0()\n', '    if token0 == midToken:\n', '        return res0\n', '    else:\n', '        return res1\n', '\n', '@internal\n', '@view\n', 'def getMidToken(midToken: address, token0: address, token1: address) -> address:\n', '    if midToken == token0 or midToken == token1:\n', '        return midToken\n', '    pair0: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token0)\n', '    pair1: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token1)\n', '    eth0: uint256 = self._getLiquidityInPool(midToken, pair0)\n', '    eth1: uint256 = self._getLiquidityInPool(midToken, pair1)\n', '    if eth0 > eth1:\n', '        return token0\n', '    else:\n', '        return token1\n', '\n', '@external\n', 'def _investTokenForUniPair(_tokenId: uint256, _token: address, amount: uint256, _uniV3Params: SingleMintParams, msg_sender: address, msg_value: uint256):\n', '    assert msg.sender == self\n', '    assert not self.paused\n', '    assert amount > 0\n', '    uniV3Params: MintParams = MintParams({\n', '        token0: _uniV3Params.token0,\n', '        token1: _uniV3Params.token1,\n', '        fee: _uniV3Params.fee,\n', '        tickLower: _uniV3Params.tickLower,\n', '        tickUpper: _uniV3Params.tickUpper,\n', '        amount0Desired: 0,\n', '        amount1Desired: 0,\n', '        amount0Min: 0,\n', '        amount1Min: 0,\n', '        recipient: _uniV3Params.recipient,\n', '        deadline: _uniV3Params.deadline\n', '    })\n', '    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256)\n', '    token: address = _token\n', '    toInvest: uint256 = 0\n', '    midToken: address = WETH\n', '    if token == VETH or token == ZERO_ADDRESS:\n', '        if msg_value > amount:\n', '            send(msg_sender, msg_value - amount)\n', '        else:\n', '            assert msg_value == amount\n', '        WrappedEth(WETH).deposit(value=amount)\n', '        token = WETH\n', '        toInvest = amount\n', '    else:\n', '        ERC20(token).transferFrom(msg_sender, self, amount)\n', '        if msg_value > 0:\n', '            send(msg_sender, msg_value)\n', '        if token == WETH:\n', '            toInvest = amount\n', '        elif token != uniV3Params.token0 and token != uniV3Params.token1:\n', '            toInvest = self.token2Token(token, WETH, amount, uniV3Params.deadline)\n', '        else:\n', '            midToken = token\n', '            toInvest = amount\n', '\n', '    if uniV3Params.token0 != WETH and uniV3Params.token1 != WETH and token != uniV3Params.token0 and token != uniV3Params.token1:\n', '        midToken = self.getMidToken(WETH, uniV3Params.token0, uniV3Params.token1)\n', '        toInvest = self.token2Token(WETH, midToken, toInvest, uniV3Params.deadline)\n', '\n', '    res0: uint256 = 0\n', '    res1: uint256 = 0\n', '    blockTimestampLast: uint256 = 0\n', '    pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(uniV3Params.token0, uniV3Params.token1)\n', '    endToken: address = ZERO_ADDRESS\n', '    if midToken == uniV3Params.token0:\n', '        (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '        endToken = uniV3Params.token1\n', '    else:\n', '        (res1, res0, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '        endToken = uniV3Params.token0\n', '\n', '    sqrtPriceX96: uint256 = 0\n', '\n', '    sqrtPriceX96 = self.getCurrentSqrtPriceX96(uniV3Params.token0, uniV3Params.token1, uniV3Params.fee)\n', '\n', '    retAmount: uint256 = 0\n', '    swapAmount: uint256 = 0\n', '    if sqrtPriceX96 <= _uniV3Params.sqrtPriceAX96:\n', '        if convert(midToken, uint256) > convert(endToken, uint256):\n', '            swapAmount = toInvest\n', '    elif sqrtPriceX96 >= _uniV3Params.sqrtPriceBX96:\n', '        if convert(midToken, uint256) < convert(endToken, uint256):\n', '            swapAmount = toInvest\n', '    else:\n', '        virtualPriceX96: uint256 = self.getVirtualPriceX96(_uniV3Params.sqrtPriceAX96, sqrtPriceX96, _uniV3Params.sqrtPriceBX96)\n', '        if convert(midToken, uint256) > convert(endToken, uint256):\n', '            swapAmount = self.getUserInForSqrtPriceX96(res0, res1, virtualPriceX96, toInvest)\n', '        else:\n', '            swapAmount = self.getUserInForSqrtPriceX96(res0, res1, 2 ** 192 / virtualPriceX96, toInvest)\n', '\n', '    if swapAmount > toInvest:\n', '        swapAmount = toInvest\n', '\n', '    if swapAmount > 0:\n', '        retAmount = self.token2Token(midToken, endToken, swapAmount, uniV3Params.deadline)\n', '\n', '    if uniV3Params.token0 == midToken:\n', '        uniV3Params.amount0Desired = toInvest - swapAmount\n', '        uniV3Params.amount1Desired = retAmount\n', '    else:\n', '        uniV3Params.amount1Desired = toInvest - swapAmount\n', '        uniV3Params.amount0Desired = retAmount\n', '\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    liquidity: uint256 = 0\n', '    (amount0, amount1, liquidity) = self.addLiquidity(_tokenId, msg_sender, uniV3Params, sqrtPriceX96)\n', '    assert liquidity >= _uniV3Params.liquidityMin\n', '    amount0 = uniV3Params.amount0Desired - amount0\n', '    amount1 = uniV3Params.amount1Desired - amount1\n', '    if amount0 > 0:\n', '        ERC20(uniV3Params.token0).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    if amount1 > 0:\n', '        ERC20(uniV3Params.token1).approve(NONFUNGIBLEPOSITIONMANAGER, 0)\n', '\n', '@external\n', 'def _divestUniV3NFLPToToken(_tokenId: uint256, _token: address, _removeParams: RemoveParams, minTokenAmount: uint256):\n', '    assert msg.sender == self\n', '    deadline: uint256 = MAX_UINT256\n', '    assert not self.paused\n', '\n', '    token: address = _token\n', '    if token == VETH or token == ZERO_ADDRESS:\n', '        token = WETH\n', '\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    (token0, token1, amount0, amount1) = self.removeLiquidity(_tokenId, _removeParams, self)\n', '\n', '    amount: uint256 = 0\n', '    if token0 == token:\n', '        amount = self.token2Token(token1, token0, amount1, MAX_UINT256) + amount0\n', '    elif token1 == token:\n', '        amount = self.token2Token(token0, token1, amount0, MAX_UINT256) + amount1\n', '    else:\n', '        midToken: address = self.getMidToken(WETH, token0, token1)\n', '        if midToken == token0:\n', '            amount = self.token2Token(token1, token0, amount1, MAX_UINT256)\n', '            amount = self.token2Token(token0, WETH, amount + amount0, MAX_UINT256)\n', '            amount = self.token2Token(WETH, token, amount, MAX_UINT256)\n', '        else:\n', '            amount = self.token2Token(token0, token1, amount0, MAX_UINT256)\n', '            amount = self.token2Token(token1, WETH, amount + amount1, MAX_UINT256)\n', '            amount = self.token2Token(WETH, token, amount, MAX_UINT256)\n', '\n', '    assert amount >= minTokenAmount\n', '\n', '    if token != _token:\n', '        WrappedEth(WETH).withdraw(amount)\n', '        send(_removeParams.recipient, amount)\n', '    else:\n', '        ERC20(token).transfer(_removeParams.recipient, amount)\n', '\n', '@external\n', '@payable\n', "@nonreentrant('lock')\n", 'def batchRun(data: Bytes[3616]):\n', '    fee: uint256 = self.feeAmount\n', '    assert msg.value >= fee\n', '    send(self.feeAddress, fee)\n', '    cursor: uint256 = 0\n', '    usedValue: uint256 = fee\n', '    for i in range(8):\n', '        if len(data) < cursor + 4:\n', '            break\n', '        mid: Bytes[4] = slice(data, cursor, 4)\n', '        cursor += 4\n', '        if mid == ADDLIQ_MID:\n', '            raw_call(self,\n', '                concat(\n', '                    _ADDLIQ_MID,\n', '                    slice(data, cursor, 384),\n', '                    convert(msg.sender, bytes32)\n', '                )\n', '            )\n', '            cursor += 384\n', '        elif mid == ADDLIQETH_MID:\n', '            if convert(convert(slice(data, cursor + 32, 32), uint256), address) == WETH:\n', '                raw_call(self,\n', '                    concat(\n', '                        _ADDLIQETH_MID,\n', '                        slice(data, cursor, 384),\n', '                        convert(msg.sender, bytes32),\n', '                        slice(data, cursor + 192, 32)\n', '                    )\n', '                )\n', '                usedValue += convert(slice(data, cursor + 192, 32), uint256)\n', '            else:\n', '                assert convert(convert(slice(data, cursor + 64, 32), uint256), address) == WETH\n', '                raw_call(self,\n', '                    concat(\n', '                        _ADDLIQETH_MID,\n', '                        slice(data, cursor, 384),\n', '                        convert(msg.sender, bytes32),\n', '                        slice(data, cursor + 224, 32)\n', '                    )\n', '                )\n', '                usedValue += convert(slice(data, cursor + 224, 32), uint256)\n', '            cursor += 384\n', '        elif mid == REMOVELIQ_MID:\n', '            raw_call(self,\n', '                concat(\n', '                    _REMOVELIQ_MID,\n', '                    slice(data, cursor, 128)\n', '                )\n', '            )\n', '            cursor += 128\n', '        elif mid == REMOVELIQETH_MID:\n', '            raw_call(self,\n', '                concat(\n', '                    _REMOVELIQETH_MID,\n', '                    slice(data, cursor, 128)\n', '                )\n', '            )\n', '            cursor += 128\n', '        elif mid == INVEST_MID:\n', '            token: address = convert(convert(slice(data, cursor + 32, 32), uint256), address)\n', '            if token == VETH or token == ZERO_ADDRESS:\n', '                raw_call(self,\n', '                    concat(\n', '                        _INVEST_MID,\n', '                        slice(data, cursor, 416),\n', '                        convert(msg.sender, bytes32),\n', '                        slice(data, cursor + 64, 32)\n', '                    )\n', '                )\n', '                usedValue += convert(slice(data, cursor + 64, 32), uint256)\n', '            else:\n', '                raw_call(self,\n', '                    concat(\n', '                        _INVEST_MID,\n', '                        slice(data, cursor, 416),\n', '                        convert(msg.sender, bytes32),\n', '                        convert(0, bytes32)\n', '                    )\n', '                )\n', '            cursor += 416\n', '        elif mid == DIVEST_MID:\n', '            raw_call(self,\n', '                concat(\n', '                    _DIVEST_MID,\n', '                    slice(data, cursor, 192)\n', '                )\n', '            )\n', '            cursor += 192\n', '        else:\n', '            assert convert(mid, uint256) == 0\n', '            break\n', '\n', '    if msg.value - usedValue > 0:\n', '        send(msg.sender, msg.value - usedValue)\n', '\n', '# Admin functions\n', '@external\n', 'def pause(_paused: bool):\n', '    assert msg.sender == self.admin\n', '    self.paused = _paused\n', '    log Paused(_paused)\n', '\n', '@external\n', 'def newAdmin(_admin: address):\n', '    assert msg.sender == self.admin\n', '    self.admin = _admin\n', '\n', '@external\n', 'def newFeeAmount(_feeAmount: uint256):\n', '    assert msg.sender == self.admin\n', '    self.feeAmount = _feeAmount\n', '    log FeeChanged(_feeAmount)\n', '\n', '@external\n', 'def newFeeAddress(_feeAddress: address):\n', '    assert msg.sender == self.admin\n', '    self.feeAddress = _feeAddress\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def batchWithdraw(token: address[8], amount: uint256[8], to: address[8]):\n', '    assert msg.sender == self.admin\n', '    for i in range(8):\n', '        if token[i] == VETH:\n', '            send(to[i], amount[i])\n', '        elif token[i] != ZERO_ADDRESS:\n', '            ERC20(token[i]).transfer(to[i], amount[i])\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw(token: address, amount: uint256, to: address):\n', '    assert msg.sender == self.admin\n', '    if token == VETH:\n', '        send(to, amount)\n', '    elif token != ZERO_ADDRESS:\n', '        ERC20(token).transfer(to, amount)\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    assert msg.sender == WETH']