['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-11\n', '*/\n', '\n', 'pragma solidity 0.5.13;  /*\n', ' \n', ' \n', ' \n', ' \n', '    ___________________________________________________________________\n', '      _      _                                        ______           \n', '      |  |  /          /                                /              \n', '    --|-/|-/-----__---/----__----__---_--_----__-------/-------__------\n', "      |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \n", '    __/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\n', '    \n', '        \n', '       \n', '\n', '██╗   ██╗███╗   ██╗██╗████████╗██╗   ██╗    ██████╗ ███████╗██╗  ██╗\n', '██║   ██║████╗  ██║██║╚══██╔══╝╚██╗ ██╔╝    ██╔══██╗██╔════╝╚██╗██╔╝\n', '██║   ██║██╔██╗ ██║██║   ██║    ╚████╔╝     ██║  ██║█████╗   ╚███╔╝ \n', '██║   ██║██║╚██╗██║██║   ██║     ╚██╔╝      ██║  ██║██╔══╝   ██╔██╗ \n', '╚██████╔╝██║ ╚████║██║   ██║      ██║       ██████╔╝███████╗██╔╝ ██╗\n', ' ╚═════╝ ╚═╝  ╚═══╝╚═╝   ╚═╝      ╚═╝       ╚═════╝ ╚══════╝╚═╝  ╚═╝\n', '                                                                    \n', '\n', '\n', '\n', '\n', '                                                                                     \n', '                                                                                     \n', '------------------------------------------------------------------------------------------------------\n', ' Copyright (c) 2021 Onwards Unity DEX Inc. ( https://unity-dex.io )\n', ' Contract designed with ❤ by EtherAuthority  ( https://EtherAuthority.io )\n', '------------------------------------------------------------------------------------------------------\n', '*/\n', '\n', '\n', '//*******************************************************************\n', '//------------------------ SafeMath Library -------------------------\n', '//*******************************************************************\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20Essential \n', '{\n', '\n', '    function transfer(address _to, uint256 _amount) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n', '\n', '}\n', '\n', '\n', '\n', '\n', '//*******************************************************************//\n', '//------------------ Contract to Manage Ownership -------------------//\n', '//*******************************************************************//\n', '    \n', 'contract owned {\n', '    address public owner;\n', '    address private newOwner;\n', '\n', '\n', '    event OwnershipTransferred(uint256 curTime, address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', "        require(msg.sender == owner, 'Only owner can call this function');\n", '        _;\n', '    }\n', '\n', '\n', '    function onlyOwnerTransferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    //this flow is to prevent transferring ownership to wrong wallet by mistake\n', '    function acceptOwnership() public {\n', "        require(msg.sender == newOwner, 'Only new owner can call this function');\n", '        emit OwnershipTransferred(now, owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract UnityDEX is owned {\n', '  using SafeMath for uint256;\n', '  bool public safeGuard; // To hault all non owner functions in case of imergency - by default false\n', '  address public feeAccount; //the account that will receive fees\n', '  uint public tradingFee = 300; // 300 = 0.3%\n', '  \n', '  //referrals\n', '  uint256 public refPercent = 10;  // percent to calculate referal bonous - by default 10% of trading fee\n', '  \n', '  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\n', '  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n', '  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n', '  \n', '  /* Mapping to track referrer. The second address is the address of referrer, the Up-line/ Sponsor */\n', '  mapping (address => address) public referrers;\n', '  /* Mapping to track referrer bonus for all the referrers */\n', '  mapping (address => uint) public referrerBonusBalance;\n', '  \n', '  event Order(uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires,  address user);\n', '  event Cancel(uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s);\n', '  event Trade( uint256 curTime, address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give, uint256 orderBookID);\n', '  event Deposit(uint256 curTime, address token, address user, uint amount, uint balance);\n', '  event Withdraw(uint256 curTime, address token, address user, uint amount, uint balance);\n', '  event OwnerWithdrawCommission(address indexed owner, address indexed tokenAddress, uint256 amount);\n', '  \n', '  // Events to track ether transfer to referrers\n', '  event ReferrerBonus(address indexed referer, address indexed trader, uint256 referralBonus, uint256 timestamp );\n', '  event ReferrerBonusWithdrawn(address indexed referrer, uint256 indexed amount);\n', '\n', '  \n', '\n', '    constructor() public {\n', '        feeAccount = msg.sender;\n', '    }\n', '\n', '    function changeSafeguardStatus() onlyOwner public\n', '    {\n', '        if (safeGuard == false)\n', '        {\n', '            safeGuard = true;\n', '        }\n', '        else\n', '        {\n', '            safeGuard = false;    \n', '        }\n', '    }\n', '\n', '    //Calculate percent and return result\n', '    function calculatePercentage(uint256 PercentOf, uint256 percentTo ) internal pure returns (uint256) \n', '    {\n', '        uint256 factor = 100000;    //so to make 1000 = 1%\n', "        require(percentTo <= factor, 'percentTo must be less than factor');\n", '        uint256 c = PercentOf.mul(percentTo).div(factor);\n', '        return c;\n', '    }  \n', '\n', '\n', '\n', '    \n', '  // contract accepts incoming ether -  this needed in case owner want to fund refPool\n', '  function() payable external {  }\n', '\n', '\n', '  function changeFeeAccount(address feeAccount_) public onlyOwner {\n', '    feeAccount = feeAccount_;\n', '  }\n', '\n', '  function changetradingFee(uint tradingFee_) public onlyOwner{\n', "    require(tradingFee_ <= 10000, 'trading fee can not be more than 100%');\n", '    tradingFee = tradingFee_;\n', '  }\n', '  \n', '  function availableOwnerCommissionEther() public view returns(uint256){\n', '      //assress 0x0 only holds ether as fee\n', '      return tokens[address(0)][feeAccount];\n', '  }\n', '  \n', '  function availableOwnerCommissionToken(address tokenAddress) public view returns(uint256){\n', '      //assress 0x0 only holds ether as fee\n', '      return tokens[tokenAddress][feeAccount];\n', '  }\n', '  \n', '  function withdrawOwnerCommissoinEther() public  returns (string memory){\n', "      require(msg.sender == feeAccount, 'Invalid caller');\n", '      uint256 amount = availableOwnerCommissionEther();\n', "      require (amount > 0, 'Nothing to withdraw');\n", '      tokens[address(0)][feeAccount] = 0;\n', '      msg.sender.transfer(amount);\n', '      emit OwnerWithdrawCommission(msg.sender, address(0), amount);\n', '      return "Ether withdrawn successfully";\n', '  }\n', '  \n', '  function withdrawOwnerCommissoinToken(address tokenAddress) public  returns (string memory){\n', "      require(msg.sender == feeAccount, 'Invalid caller');\n", '      uint256 amount = availableOwnerCommissionToken(tokenAddress);\n', "      require (amount > 0, 'Nothing to withdraw');\n", '      tokens[tokenAddress][feeAccount] = 0;\n', '      ERC20Essential(tokenAddress).transfer(msg.sender, amount);\n', '      emit OwnerWithdrawCommission(msg.sender, tokenAddress, amount);\n', '      return "Token withdrawn successfully";\n', '  }\n', '\n', '  function deposit() public payable {\n', '    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\n', '    emit Deposit(now, address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', '  function withdraw(uint amount) public {\n', '    require(!safeGuard,"System Paused by Admin");\n', "    require(tokens[address(0)][msg.sender] >= amount, 'Not enough balance');\n", '    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].sub(amount);\n', '    msg.sender.transfer(amount);\n', '    emit Withdraw(now, address(0), msg.sender, amount, tokens[address(0)][msg.sender]);\n', '  }\n', '\n', '  function depositToken(address token, uint amount) public {\n', '    //remember to call Token(address).approve(address(this), amount) or this contract will not be able to do the transfer on your behalf.\n', "    require(token!=address(0), 'Invalid token address');\n", "    require(ERC20Essential(token).transferFrom(msg.sender, address(this), amount), 'tokens could not be transferred');\n", '    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n', '    emit Deposit(now, token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\t\n', '  function withdrawToken(address token, uint amount) public {\n', '    require(!safeGuard,"System Paused by Admin");\n', "    require(token!=address(0), 'Invalid token address');\n", "    require(tokens[token][msg.sender] >= amount, 'not enough token balance');\n", '    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n', '\t  ERC20Essential(token).transfer(msg.sender, amount);\n', '    emit Withdraw(now, token, msg.sender, amount, tokens[token][msg.sender]);\n', '  }\n', '\n', '  function balanceOf(address token, address user) public view returns (uint) {\n', '    return tokens[token][user];\n', '  }\n', '\n', '  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires) public {\n', '    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\n', '    orders[msg.sender][hash] = true;\n', '    emit Order(now, tokenGet, amountGet, tokenGive, amountGive, expires, msg.sender);\n', '  }\n', '\n', '\n', '    /* address[4] addressArray elements\n', '        0 = tokenGet\n', '        1 = tokenGive\n', '        2 = tradeMaker\n', '        3 = referrer\n', '    */\n', '  function trade(address[4] memory addressArray, uint amountGet, uint amountGive, uint expires, uint8 v, bytes32 r, bytes32 s, uint amount, uint orderBookID) public {\n', '    require(!safeGuard,"System Paused by Admin");\n', '    //amount is in amountGet terms\n', '    bytes32 hash = keccak256(abi.encodePacked(address(this), addressArray[0], amountGet, addressArray[1], amountGive, expires));\n', '    require(orders[addressArray[2]][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == addressArray[2], \'Invalid trade parameters\');\n', "    require(block.number <= expires, 'Trade is expired');\n", "    require(orderFills[addressArray[2]][hash].add(amount) <= amountGet, 'Trade order is filled');\n", '\n', '    tradeBalances(addressArray, amountGet, amountGive, amount );\n', '    orderFills[addressArray[2]][hash] = orderFills[addressArray[2]][hash].add(amount);\n', '    \n', '    emit Trade(now, addressArray[0], amount, addressArray[1], amountGive * amount / amountGet, addressArray[2], msg.sender, orderBookID);\n', '  }\n', '    \n', '    /**\n', '        addressArray array elements\n', '        0 = tokenGet\n', '        1 = tokenGive\n', '        2 = user\n', '        3 = referrer\n', '    */\n', '  function tradeBalances(address[4] memory addressArray, uint amountGet, uint amountGive, uint amount) internal {\n', '    \n', '    uint tradingFeeXfer = calculatePercentage(amount,tradingFee);\n', '    \n', '    //processing referrers bonus - which is % of the trading fee\n', '    processReferrerBonus(addressArray[3], tradingFeeXfer);\n', '\n', '    tokens[addressArray[0]][msg.sender] = tokens[addressArray[0]][msg.sender].sub(amount.add(tradingFeeXfer));\n', '    tokens[addressArray[0]][addressArray[2]] = tokens[addressArray[0]][addressArray[2]].add(amount);\n', '    tokens[addressArray[0]][feeAccount] = tokens[addressArray[0]][feeAccount].add(tradingFeeXfer);\n', '\n', '    tokens[addressArray[1]][addressArray[2]] = tokens[addressArray[1]][addressArray[2]].sub(amountGive.mul(amount) / amountGet);\n', '    tokens[addressArray[1]][msg.sender] = tokens[addressArray[1]][msg.sender].add(amountGive.mul(amount) / amountGet);\n', '  }\n', '  \n', '  \n', '\n', '  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public view returns(bool) {\n', '    \n', '    if (!(\n', '      tokens[tokenGet][sender] >= amount &&\n', '      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, user, v, r, s) >= amount\n', '    )) return false;\n', '    return true;\n', '  }\n', '  \n', '  function testVRS(address tokenGet, uint256 amountGet, address tokenGive, uint256 amountGive, uint256 expires, uint8 v, bytes32 r, bytes32 s ) public view returns(address){\n', '      \n', '      bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\n', '     \n', '      return ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s);\n', '    \n', '  }\n', '\n', '  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user, uint8 v, bytes32 r, bytes32 s) public view returns(uint) {\n', '    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\n', '    uint available1;\n', '    if (!(\n', '      (orders[user][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == user) &&\n', '      block.number <= expires\n', '    )) return 0;\n', '    available1 = tokens[tokenGive][user].mul(amountGet) / amountGive;\n', '    \n', '    if (amountGet.sub(orderFills[user][hash])<available1) return amountGet.sub(orderFills[user][hash]);\n', '    return available1;\n', '    \n', '  }\n', '\n', '  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, address user) public view returns(uint) {\n', '    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\n', '    return orderFills[user][hash];\n', '  }\n', '\n', '  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint8 v, bytes32 r, bytes32 s) public {\n', '    require(!safeGuard,"System Paused by Admin");\n', '    bytes32 hash = keccak256(abi.encodePacked(address(this), tokenGet, amountGet, tokenGive, amountGive, expires));\n', '    require(orders[msg.sender][hash] || ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == msg.sender, \'Invalid trade order\');\n', '    orderFills[msg.sender][hash] = amountGet;\n', '    emit Cancel(now, tokenGet, amountGet, tokenGive, amountGive, expires, msg.sender, v, r, s);\n', '  }\n', '\n', '\n', '\n', '//==================================================//\n', '//              REFERRAL SECTION CODE               //\n', '//==================================================//\n', '\n', 'function processReferrerBonus(address _referrer, uint256 _tradingFeeLocal) internal {\n', '      \n', '      address existingReferrer = referrers[msg.sender];\n', '      \n', '      if(_referrer != address(0) && existingReferrer != address(0) ){\n', '        referrerBonusBalance[existingReferrer] += _tradingFeeLocal * refPercent / 100;\n', '        emit ReferrerBonus(_referrer, msg.sender, _tradingFeeLocal * refPercent / 100, now );\n', '      }\n', '      else if(_referrer != address(0) && existingReferrer == address(0) ){\n', '        //no referrer exist, but provided in trade function call\n', '        referrerBonusBalance[_referrer] += _tradingFeeLocal * refPercent / 100;\n', '        referrers[msg.sender] = _referrer;\n', '        emit ReferrerBonus(_referrer, msg.sender, _tradingFeeLocal * refPercent / 100, now );\n', '      }\n', '  }\n', '  \n', '  function changeRefPercent(uint256 newRefPercent) public onlyOwner returns (string memory){\n', "      require(newRefPercent <= 100, 'newRefPercent can not be more than 100');\n", '      refPercent = newRefPercent;\n', '      return "refPool fee updated successfully";\n', '  }\n', '  \n', '  /**\n', '        * Function will allow users to withdraw their referrer bonus  \n', '    */\n', '    function claimReferrerBonus() public returns(bool) {\n', '        \n', '        address payable msgSender = msg.sender;\n', '        \n', '        uint256 referralBonus = referrerBonusBalance[msgSender];\n', '        \n', "        require(referralBonus > 0, 'Insufficient referrer bonus');\n", '        referrerBonusBalance[msgSender] = 0;\n', '        \n', '        \n', '        //transfer the referrer bonus\n', '        msgSender.transfer(referralBonus);\n', '        \n', '        //fire event\n', '        emit ReferrerBonusWithdrawn(msgSender, referralBonus);\n', '        \n', '        return true;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '}']