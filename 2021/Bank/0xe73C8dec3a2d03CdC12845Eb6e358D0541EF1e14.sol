['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', 'pragma solidity =0.7.6;\n', 'pragma abicoder v2;\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\n', '/// @title The interface for the Uniswap V3 Factory\n', '/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\n', 'interface IUniswapV3Factory {\n', '    /// @notice Emitted when the owner of the factory is changed\n', '    /// @param oldOwner The owner before the owner was changed\n', '    /// @param newOwner The owner after the owner was changed\n', '    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n', '\n', '    /// @notice Emitted when a pool is created\n', '    /// @param token0 The first token of the pool by address sort order\n', '    /// @param token1 The second token of the pool by address sort order\n', '    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n', '    /// @param tickSpacing The minimum number of ticks between initialized ticks\n', '    /// @param pool The address of the created pool\n', '    event PoolCreated(\n', '        address indexed token0,\n', '        address indexed token1,\n', '        uint24 indexed fee,\n', '        int24 tickSpacing,\n', '        address pool\n', '    );\n', '\n', '    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n', '    /// @param fee The enabled fee, denominated in hundredths of a bip\n', '    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n', '    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n', '\n', '    /// @notice Returns the current owner of the factory\n', '    /// @dev Can be changed by the current owner via setOwner\n', '    /// @return The address of the factory owner\n', '    function owner() external view returns (address);\n', '\n', '    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n', '    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n', '    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n', '    /// @return The tick spacing\n', '    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n', '\n', '    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n', '    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n', '    /// @param tokenA The contract address of either token0 or token1\n', '    /// @param tokenB The contract address of the other token\n', '    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n', '    /// @return pool The pool address\n', '    function getPool(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) external view returns (address pool);\n', '\n', '    /// @notice Creates a pool for the given two tokens and fee\n', '    /// @param tokenA One of the two tokens in the desired pool\n', '    /// @param tokenB The other of the two tokens in the desired pool\n', '    /// @param fee The desired fee for the pool\n', '    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n', '    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n', '    /// are invalid.\n', '    /// @return pool The address of the newly created pool\n', '    function createPool(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) external returns (address pool);\n', '\n', '    /// @notice Updates the owner of the factory\n', '    /// @dev Must be called by the current owner\n', '    /// @param _owner The new owner of the factory\n', '    function setOwner(address _owner) external;\n', '\n', '    /// @notice Enables a fee amount with the given tickSpacing\n', '    /// @dev Fee amounts may never be removed once enabled\n', '    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n', '    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n', '    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n', '    /// @return The contract address\n', '    function factory() external view returns (address);\n', '\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '\n', "    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n", '    /// @return The fee\n', '    function fee() external view returns (uint24);\n', '\n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '\n', '    /// @notice The maximum amount of position liquidity that can use any tick in the range\n', '    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n', '    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n', '    /// @return The max amount of liquidity per tick\n', '    function maxLiquidityPerTick() external view returns (uint128);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\n', '/// @title Pool state that can change\n', "/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n", '/// per transaction\n', 'interface IUniswapV3PoolState {\n', '    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n', '    /// when accessed externally.\n', '    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n', '    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n', '    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n', '    /// boundary.\n', '    /// observationIndex The index of the last oracle observation that was written,\n', '    /// observationCardinality The current maximum number of observations stored in the pool,\n', '    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n', '    /// feeProtocol The protocol fee for both tokens of the pool.\n', '    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n', '    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n', '    /// unlocked Whether the pool is currently locked to reentrancy\n', '    function slot0()\n', '        external\n', '        view\n', '        returns (\n', '            uint160 sqrtPriceX96,\n', '            int24 tick,\n', '            uint16 observationIndex,\n', '            uint16 observationCardinality,\n', '            uint16 observationCardinalityNext,\n', '            uint8 feeProtocol,\n', '            bool unlocked\n', '        );\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal0X128() external view returns (uint256);\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal1X128() external view returns (uint256);\n', '\n', '    /// @notice The amounts of token0 and token1 that are owed to the protocol\n', '    /// @dev Protocol fees will never exceed uint128 max in either token\n', '    function protocolFees() external view returns (uint128 token0, uint128 token1);\n', '\n', '    /// @notice The currently in range liquidity available to the pool\n', '    /// @dev This value has no relationship to the total liquidity across all ticks\n', '    function liquidity() external view returns (uint128);\n', '\n', '    /// @notice Look up information about a specific tick in the pool\n', '    /// @param tick The tick to look up\n', '    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n', '    /// tick upper,\n', '    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n', '    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n', '    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n', '    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n', '    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n', '    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n', '    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n', '    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n', '    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n', '    /// a specific position.\n', '    function ticks(int24 tick)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 liquidityGross,\n', '            int128 liquidityNet,\n', '            uint256 feeGrowthOutside0X128,\n', '            uint256 feeGrowthOutside1X128,\n', '            int56 tickCumulativeOutside,\n', '            uint160 secondsPerLiquidityOutsideX128,\n', '            uint32 secondsOutside,\n', '            bool initialized\n', '        );\n', '\n', '    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n', '    function tickBitmap(int16 wordPosition) external view returns (uint256);\n', '\n', "    /// @notice Returns the information about a position by the position's key\n", "    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n", '    /// @return _liquidity The amount of liquidity in the position,\n', '    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n', '    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n', '    function positions(bytes32 key)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 _liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '\n', '    /// @notice Returns data about a specific observation index\n', '    /// @param index The element of the observations array to fetch\n', '    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n', '    /// ago, rather than at a specific index in the array.\n', '    /// @return blockTimestamp The timestamp of the observation,\n', '    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n', '    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n', '    /// Returns initialized whether the observation has been initialized and the values are safe to use\n', '    function observations(uint256 index)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 blockTimestamp,\n', '            int56 tickCumulative,\n', '            uint160 secondsPerLiquidityCumulativeX128,\n', '            bool initialized\n', '        );\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '    /// you must call it with secondsAgos = [3600, 0].\n', '    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '    /// timestamp\n', '    function observe(uint32[] calldata secondsAgos)\n', '        external\n', '        view\n', '        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n', '\n', '    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n', '    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n', '    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n', '    /// snapshot is taken and the second snapshot is taken.\n', '    /// @param tickLower The lower tick of the range\n', '    /// @param tickUpper The upper tick of the range\n', '    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n', '    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n', '    /// @return secondsInside The snapshot of seconds per liquidity for the range\n', '    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n', '        external\n', '        view\n', '        returns (\n', '            int56 tickCumulativeInside,\n', '            uint160 secondsPerLiquidityInsideX128,\n', '            uint32 secondsInside\n', '        );\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol\n', '/// @title Permissionless pool actions\n', '/// @notice Contains pool methods that can be called by anyone\n', 'interface IUniswapV3PoolActions {\n', '    /// @notice Sets the initial price for the pool\n', '    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n', '    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n', '    function initialize(uint160 sqrtPriceX96) external;\n', '\n', '    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n', '    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n', '    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n', '    /// @param recipient The address for which the liquidity will be created\n', '    /// @param tickLower The lower tick of the position in which to add liquidity\n', '    /// @param tickUpper The upper tick of the position in which to add liquidity\n', '    /// @param amount The amount of liquidity to mint\n', '    /// @param data Any data that should be passed through to the callback\n', '    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    function mint(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount,\n', '        bytes calldata data\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Collects tokens owed to a position\n', '    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n', '    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n', '    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n', '    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n', '    /// @param recipient The address which should receive the fees collected\n', '    /// @param tickLower The lower tick of the position for which to collect fees\n', '    /// @param tickUpper The upper tick of the position for which to collect fees\n', '    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n', '    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '\n', '    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n', '    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n', '    /// @dev Fees must be collected separately via a call to #collect\n', '    /// @param tickLower The lower tick of the position for which to burn liquidity\n', '    /// @param tickUpper The upper tick of the position for which to burn liquidity\n', '    /// @param amount How much liquidity to burn\n', '    /// @return amount0 The amount of token0 sent to the recipient\n', '    /// @return amount1 The amount of token1 sent to the recipient\n', '    function burn(\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Swap token0 for token1, or token1 for token0\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n', '    /// @param recipient The address to receive the output of the swap\n', '    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n', '    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n', '    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n', '    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n', '    /// @param data Any data to be passed through to the callback\n', '    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n', '    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n', '    function swap(\n', '        address recipient,\n', '        bool zeroForOne,\n', '        int256 amountSpecified,\n', '        uint160 sqrtPriceLimitX96,\n', '        bytes calldata data\n', '    ) external returns (int256 amount0, int256 amount1);\n', '\n', '    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n', '    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n', '    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n', '    /// @param recipient The address which will receive the token0 and token1 amounts\n', '    /// @param amount0 The amount of token0 to send\n', '    /// @param amount1 The amount of token1 to send\n', '    /// @param data Any data to be passed through to the callback\n', '    function flash(\n', '        address recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n', '    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n', '    /// the input observationCardinalityNext.\n', '    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n', '    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\n', '/// @title Permissioned pool actions\n', '/// @notice Contains pool methods that may only be called by the factory owner\n', 'interface IUniswapV3PoolOwnerActions {\n', "    /// @notice Set the denominator of the protocol's % share of the fees\n", '    /// @param feeProtocol0 new protocol fee for token0 of the pool\n', '    /// @param feeProtocol1 new protocol fee for token1 of the pool\n', '    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n', '\n', '    /// @notice Collect the protocol fee accrued to the pool\n', '    /// @param recipient The address to which collected protocol fees should be sent\n', '    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n', '    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n', '    /// @return amount0 The protocol fee collected in token0\n', '    /// @return amount1 The protocol fee collected in token1\n', '    function collectProtocol(\n', '        address recipient,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\n', '/// @title Events emitted by a pool\n', '/// @notice Contains all events emitted by the pool\n', 'interface IUniswapV3PoolEvents {\n', '    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n', '    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n', '    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n', '    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n', '    event Initialize(uint160 sqrtPriceX96, int24 tick);\n', '\n', '    /// @notice Emitted when liquidity is minted for a given position\n', '    /// @param sender The address that minted the liquidity\n', '    /// @param owner The owner of the position and recipient of any minted liquidity\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity minted to the position range\n', '    /// @param amount0 How much token0 was required for the minted liquidity\n', '    /// @param amount1 How much token1 was required for the minted liquidity\n', '    event Mint(\n', '        address sender,\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted when fees are collected by the owner of a position\n', '    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n', '    /// @param owner The owner of the position for which fees are collected\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount0 The amount of token0 fees collected\n', '    /// @param amount1 The amount of token1 fees collected\n', '    event Collect(\n', '        address indexed owner,\n', '        address recipient,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount0,\n', '        uint128 amount1\n', '    );\n', '\n', "    /// @notice Emitted when a position's liquidity is removed\n", '    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n', '    /// @param owner The owner of the position for which liquidity is removed\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity to remove\n', '    /// @param amount0 The amount of token0 withdrawn\n', '    /// @param amount1 The amount of token1 withdrawn\n', '    event Burn(\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any swaps between token0 and token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the output of the swap\n', '    /// @param amount0 The delta of the token0 balance of the pool\n', '    /// @param amount1 The delta of the token1 balance of the pool\n', '    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n', '    /// @param liquidity The liquidity of the pool after the swap\n', '    /// @param tick The log base 1.0001 of price of the pool after the swap\n', '    event Swap(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        int256 amount0,\n', '        int256 amount1,\n', '        uint160 sqrtPriceX96,\n', '        uint128 liquidity,\n', '        int24 tick\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any flashes of token0/token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the tokens from flash\n', '    /// @param amount0 The amount of token0 that was flashed\n', '    /// @param amount1 The amount of token1 that was flashed\n', '    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n', '    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n', '    event Flash(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        uint256 paid0,\n', '        uint256 paid1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n', '    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n', '    /// just before a mint/swap/burn.\n', '    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n', '    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n', '    event IncreaseObservationCardinalityNext(\n', '        uint16 observationCardinalityNextOld,\n', '        uint16 observationCardinalityNextNew\n', '    );\n', '\n', '    /// @notice Emitted when the protocol fee is changed by the pool\n', '    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n', '    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n', '    /// @param feeProtocol0New The updated value of the token0 protocol fee\n', '    /// @param feeProtocol1New The updated value of the token1 protocol fee\n', '    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n', '\n', '    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n', '    /// @param sender The address that collects the protocol fees\n', '    /// @param recipient The address that receives the collected protocol fees\n', '    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n', '    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n', '    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\n', '/// @title The interface for a Uniswap V3 Pool\n', '/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '/// to the ERC20 specification\n', '/// @dev The pool interface is broken up into many smaller pieces\n', 'interface IUniswapV3Pool is\n', '    IUniswapV3PoolImmutables,\n', '    IUniswapV3PoolState,\n', '    IUniswapV3PoolDerivedState,\n', '    IUniswapV3PoolActions,\n', '    IUniswapV3PoolOwnerActions,\n', '    IUniswapV3PoolEvents\n', '{\n', '\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\n', '/// @title Callback for IUniswapV3PoolActions#swap\n', '/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\n', 'interface IUniswapV3SwapCallback {\n', '    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n', '    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n', '    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n', '    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n', '    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n', '    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n', '    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n', '    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n', '    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n', '    function uniswapV3SwapCallback(\n', '        int256 amount0Delta,\n', '        int256 amount1Delta,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File: @uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\n', '/// @title Router token swapping functionality\n', '/// @notice Functions for swapping tokens via Uniswap V3\n', 'interface ISwapRouter is IUniswapV3SwapCallback {\n', '    struct ExactInputSingleParams {\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint24 fee;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountIn;\n', '        uint256 amountOutMinimum;\n', '        uint160 sqrtPriceLimitX96;\n', '    }\n', '\n', '    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n', '    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n', '    /// @return amountOut The amount of the received token\n', '    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n', '\n', '    struct ExactInputParams {\n', '        bytes path;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountIn;\n', '        uint256 amountOutMinimum;\n', '    }\n', '\n', '    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n', '    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n', '    /// @return amountOut The amount of the received token\n', '    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n', '\n', '    struct ExactOutputSingleParams {\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint24 fee;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountOut;\n', '        uint256 amountInMaximum;\n', '        uint160 sqrtPriceLimitX96;\n', '    }\n', '\n', '    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n', '    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n', '    /// @return amountIn The amount of the input token\n', '    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n', '\n', '    struct ExactOutputParams {\n', '        bytes path;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountOut;\n', '        uint256 amountInMaximum;\n', '    }\n', '\n', '    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n', '    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n', '    /// @return amountIn The amount of the input token\n', '    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\n', 'library TransferHelper {\n', '    /// @notice Transfers tokens from the targeted address to the given destination\n', "    /// @notice Errors with 'STF' if transfer fails\n", '    /// @param token The contract address of the token to be transferred\n', '    /// @param from The originating address from which the tokens will be transferred\n', '    /// @param to The destination address of the transfer\n', '    /// @param value The amount to be transferred\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n", '    }\n', '\n', '    /// @notice Transfers tokens from msg.sender to a recipient\n', '    /// @dev Errors with ST if transfer fails\n', '    /// @param token The contract address of the token which will be transferred\n', '    /// @param to The recipient of the transfer\n', '    /// @param value The value of the transfer\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n", '    }\n', '\n', '    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n', "    /// @dev Errors with 'SA' if transfer fails\n", '    /// @param token The contract address of the token to be approved\n', '    /// @param to The target of the approval\n', '    /// @param value The amount of the given token the target will be allowed to spend\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n", '    }\n', '\n', '    /// @notice Transfers ETH to the recipient address\n', '    /// @dev Fails with `STE`\n', '    /// @param to The destination of the transfer\n', '    /// @param value The value to be transferred\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'STE');\n", '    }\n', '}\n', '\n', '// File: @uniswap/v3-periphery/contracts/libraries/BytesLib.sol\n', '/*\n', ' * @title Solidity Bytes Arrays Utils\n', ' * @author Gonçalo Sá <[email\xa0protected]>\n', ' *\n', ' * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n', ' *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n', ' */\n', 'library BytesLib {\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint256 _start,\n', '        uint256 _length\n', '    ) internal pure returns (bytes memory) {\n', "        require(_length + 31 >= _length, 'slice_overflow');\n", "        require(_start + _length >= _start, 'slice_overflow');\n", "        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\n", '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '                case 0 {\n', '                    // Get a location of some free memory and store it in tempBytes as\n', '                    // Solidity does for memory variables.\n', '                    tempBytes := mload(0x40)\n', '\n', '                    // The first word of the slice result is potentially a partial\n', '                    // word read from the original array. To read it, we calculate\n', '                    // the length of that partial word and start copying that many\n', '                    // bytes into the array. The first word we copy will start with\n', "                    // data we don't care about, but the last `lengthmod` bytes will\n", '                    // land at the beginning of the contents of the new array. When\n', "                    // we're done copying, we overwrite the full first word with\n", '                    // the actual length of the slice.\n', '                    let lengthmod := and(_length, 31)\n', '\n', '                    // The multiplication in the next line is necessary\n', '                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                    // the following copy loop was copying the origin's length\n", '                    // and then ending prematurely not copying everything it should.\n', '                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                    let end := add(mc, _length)\n', '\n', '                    for {\n', '                        // The multiplication in the next line has the same exact purpose\n', '                        // as the one above.\n', '                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                    } lt(mc, end) {\n', '                        mc := add(mc, 0x20)\n', '                        cc := add(cc, 0x20)\n', '                    } {\n', '                        mstore(mc, mload(cc))\n', '                    }\n', '\n', '                    mstore(tempBytes, _length)\n', '\n', '                    //update free-memory pointer\n', '                    //allocating the array padded to 32 bytes like the compiler does now\n', '                    mstore(0x40, and(add(mc, 31), not(31)))\n', '                }\n', "                //if we want a zero-length slice let's just return a zero-length array\n", '                default {\n', '                    tempBytes := mload(0x40)\n', '                    //zero out the 32 bytes slice we are about to return\n', '                    //we need to do it because Solidity does not garbage collect\n', '                    mstore(tempBytes, 0)\n', '\n', '                    mstore(0x40, add(tempBytes, 0x20))\n', '                }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n', "        require(_start + 20 >= _start, 'toAddress_overflow');\n", "        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\n", '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n', "        require(_start + 3 >= _start, 'toUint24_overflow');\n", "        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\n", '        uint24 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x3), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '}\n', '\n', '// File: @uniswap/v3-periphery/contracts/libraries/Path.sol\n', '/// @title Functions for manipulating path data for multihop swaps\n', 'library Path {\n', '    using BytesLib for bytes;\n', '\n', '    /// @dev The length of the bytes encoded address\n', '    uint256 private constant ADDR_SIZE = 20;\n', '    /// @dev The length of the bytes encoded fee\n', '    uint256 private constant FEE_SIZE = 3;\n', '\n', '    /// @dev The offset of a single token address and pool fee\n', '    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n', '    /// @dev The offset of an encoded pool key\n', '    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n', '    /// @dev The minimum length of an encoding that contains 2 or more pools\n', '    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\n', '\n', '    /// @notice Returns true iff the path contains two or more pools\n', '    /// @param path The encoded swap path\n', '    /// @return True if path contains two or more pools, otherwise false\n', '    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n', '        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n', '    }\n', '\n', '    /// @notice Decodes the first pool in path\n', '    /// @param path The bytes encoded swap path\n', '    /// @return tokenA The first token of the given pool\n', '    /// @return tokenB The second token of the given pool\n', '    /// @return fee The fee level of the pool\n', '    function decodeFirstPool(bytes memory path)\n', '        internal\n', '        pure\n', '        returns (\n', '            address tokenA,\n', '            address tokenB,\n', '            uint24 fee\n', '        )\n', '    {\n', '        tokenA = path.toAddress(0);\n', '        fee = path.toUint24(ADDR_SIZE);\n', '        tokenB = path.toAddress(NEXT_OFFSET);\n', '    }\n', '\n', '    /// @notice Gets the segment corresponding to the first pool in the path\n', '    /// @param path The bytes encoded swap path\n', '    /// @return The segment containing all data necessary to target the first pool in the path\n', '    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\n', '        return path.slice(0, POP_OFFSET);\n', '    }\n', '\n', '    /// @notice Skips a token + fee element from the buffer and returns the remainder\n', '    /// @param path The swap path\n', '    /// @return The remaining token + fee elements in the path\n', '    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n', '        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IHotPotV2FundERC20.sol\n', '/// @title Hotpot V2 基金份额代币接口定义\n', 'interface IHotPotV2FundERC20 is IERC20{\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts/interfaces/fund/IHotPotV2FundEvents.sol\n', '/// @title Hotpot V2 事件接口定义\n', 'interface IHotPotV2FundEvents {\n', '    /// @notice 当存入基金token时，会触发该事件\n', '    event Deposit(address indexed owner, uint amount, uint share);\n', '\n', '    /// @notice 当取走基金token时，会触发该事件\n', '    event Withdraw(address indexed owner, uint amount, uint share);\n', '}\n', '\n', '// File: contracts/interfaces/fund/IHotPotV2FundState.sol\n', '/// @title Hotpot V2 状态变量及只读函数\n', 'interface IHotPotV2FundState {\n', '    /// @notice 控制器合约地址\n', '    function controller() external view returns (address);\n', '\n', '    /// @notice 基金经理地址\n', '    function manager() external view returns (address);\n', '\n', '    /// @notice 基金本币地址\n', '    function token() external view returns (address);\n', '\n', '    /// @notice 8 bytes 基金经理 + 24 bytes 简要描述\n', '    function descriptor() external view returns (bytes32);\n', '\n', '    /// @notice 总投入数量\n', '    function totalInvestment() external view returns (uint);\n', '\n', '    /// @notice owner的投入数量\n', '    /// @param owner 用户地址\n', '    /// @return 投入本币的数量\n', '    function investmentOf(address owner) external view returns (uint);\n', '\n', '    /// @notice 指定头寸的资产数量\n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @return 以本币计价的头寸资产数量\n', '    function assetsOfPosition(uint poolIndex, uint positionIndex) external view returns(uint);\n', '\n', '    /// @notice 指定pool的资产数量\n', '    /// @param poolIndex 池子索引号\n', '    /// @return 以本币计价的池子资产数量\n', '    function assetsOfPool(uint poolIndex) external view returns(uint);\n', '\n', '    /// @notice 总资产数量\n', '    /// @return 以本币计价的总资产数量\n', '    function totalAssets() external view returns (uint);\n', '\n', '    /// @notice 基金本币->目标代币 的购买路径\n', '    /// @param _token 目标代币地址\n', '    /// @return 符合uniswap v3格式的目标代币购买路径\n', '    function buyPath(address _token) external view returns (bytes memory);\n', '\n', '    /// @notice 目标代币->基金本币 的购买路径\n', '    /// @param _token 目标代币地址\n', '    /// @return 符合uniswap v3格式的目标代币销售路径\n', '    function sellPath(address _token) external view returns (bytes memory);\n', '\n', '    /// @notice 获取池子地址\n', '    /// @param index 池子索引号\n', '    /// @return 池子地址\n', '    function pools(uint index) external view returns(address);\n', '\n', '    /// @notice 头寸信息\n', '    /// @dev 由于基金需要遍历头寸，所以用二维动态数组存储头寸\n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @return isEmpty 是否空头寸，tickLower 价格刻度下届，tickUpper 价格刻度上届\n', '    function positions(uint poolIndex, uint positionIndex) \n', '        external \n', '        view \n', '        returns(\n', '            bool isEmpty,\n', '            int24 tickLower,\n', '            int24 tickUpper \n', '        );\n', '\n', '    /// @notice pool数组长度\n', '    function poolsLength() external view returns(uint);\n', '\n', '    /// @notice 指定池子的头寸数组长度\n', '    /// @param poolIndex 池子索引号\n', '    /// @return 头寸数组长度\n', '    function positionsLength(uint poolIndex) external view returns(uint);\n', '}\n', '\n', '// File: contracts/interfaces/fund/IHotPotV2FundUserActions.sol\n', '/// @title Hotpot V2 用户操作接口定义\n', '/// @notice 存入(deposit)函数适用于ERC20基金; 如果是ETH基金(内部会转换为WETH9)，应直接向基金合约转账; \n', 'interface IHotPotV2FundUserActions {\n', '    /// @notice 用户存入基金本币\n', '    /// @param amount 存入数量\n', '    /// @return share 用户获得的基金份额\n', '    function deposit(uint amount) external returns(uint share);\n', '    \n', '    /// @notice 用户取出指定份额的本币\n', '    /// @param share 取出的基金份额数量\n', '    /// @return amount 返回本币数量\n', '    function withdraw(uint share) external returns(uint amount);\n', '}\n', '\n', '// File: contracts/interfaces/fund/IHotPotV2FundManagerActions.sol\n', '/// @notice 基金经理操作接口定义\n', 'interface IHotPotV2FundManagerActions {\n', '    /// @notice 设置代币交易路径\n', '    /// @dev This function can only be called by controller \n', '    /// @dev 设置路径时不能修改为0地址，且path路径里的token必须验证是否受信任\n', '    /// @param distToken 目标代币地址\n', '    /// @param buy 购买路径(本币->distToken)\n', '    /// @param sell 销售路径(distToken->本币)\n', '    function setPath(\n', '        address distToken, \n', '        bytes memory buy,\n', '        bytes memory sell\n', '    ) external;\n', '\n', '    /// @notice 初始化头寸, 允许投资额为0.\n', '    /// @dev This function can only be called by controller\n', '    /// @param token0 token0 地址\n', '    /// @param token1 token1 地址\n', '    /// @param fee 手续费率\n', '    /// @param tickLower 价格刻度下届\n', '    /// @param tickUpper 价格刻度上届\n', '    /// @param amount 初始化投入金额，允许为0, 为0表示仅初始化头寸，不作实质性投资\n', '    function init(\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint amount\n', '    ) external;\n', '\n', '    /// @notice 投资指定头寸，可选复投手续费\n', '    /// @dev This function can only be called by controller \n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @param amount 投资金额\n', '    /// @param collect 是否收集已产生的手续费并复投\n', '    function add(\n', '        uint poolIndex, \n', '        uint positionIndex, \n', '        uint amount, \n', '        bool collect\n', '    ) external;\n', '\n', '    /// @notice 撤资指定头寸\n', '    /// @dev This function can only be called by controller \n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @param proportionX128 撤资比例，左移128位; 允许为0，为0表示只收集手续费\n', '    function sub(\n', '        uint poolIndex, \n', '        uint positionIndex, \n', '        uint proportionX128\n', '    ) external;\n', '\n', '    /// @notice 调整头寸投资\n', '    /// @dev This function can only be called by controller \n', '    /// @param poolIndex 池子索引号\n', '    /// @param subIndex 要移除的头寸索引号\n', '    /// @param addIndex 要添加的头寸索引号\n', '    /// @param proportionX128 调整比例，左移128位\n', '    function move(\n', '        uint poolIndex,\n', '        uint subIndex, \n', '        uint addIndex, \n', '        uint proportionX128 //以前是按LP数量移除，现在改成按总比例移除，这样前端就不用管实际LP是多少了\n', '    ) external;\n', '}\n', '\n', '// File: contracts/interfaces/IHotPotV2Fund.sol\n', '/// @title Hotpot V2 基金接口\n', '/// @notice 接口定义分散在多个接口文件\n', 'interface IHotPotV2Fund is \n', '    IHotPotV2FundERC20, \n', '    IHotPotV2FundEvents, \n', '    IHotPotV2FundState, \n', '    IHotPotV2FundUserActions, \n', '    IHotPotV2FundManagerActions\n', '{    \n', '}\n', '\n', '// File: contracts/interfaces/IHotPot.sol\n', '/// @title HPT (Hotpot Funds) 代币接口定义.\n', 'interface IHotPot is IERC20{\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '\n', '    function burn(uint value) external returns (bool) ;\n', '    function burnFrom(address from, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/controller/IManagerActions.sol\n', '/// @title 控制器合约基金经理操作接口定义\n', 'interface IManagerActions {\n', '    /// @notice 设置代币交易路径\n', '    /// @dev This function can only be called by manager \n', '    /// @dev 设置路径时不能修改为0地址，且path路径里的token必须验证是否受信任\n', '    /// @param fund 基金地址\n', '    /// @param distToken 目标代币地址\n', '    /// @param path 符合uniswap v3格式的交易路径\n', '    function setPath(\n', '        address fund, \n', '        address distToken, \n', '        bytes memory path\n', '    ) external;\n', '\n', '    /// @notice 初始化头寸, 允许投资额为0.\n', '    /// @dev This function can only be called by manager\n', '    /// @param fund 基金地址\n', '    /// @param token0 token0 地址\n', '    /// @param token1 token1 地址\n', '    /// @param fee 手续费率\n', '    /// @param tickLower 价格刻度下届\n', '    /// @param tickUpper 价格刻度上届\n', '    /// @param amount 初始化投入金额，允许为0, 为0表示仅初始化头寸，不作实质性投资\n', '    function init(\n', '        address fund,\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint amount\n', '    ) external;\n', '\n', '    /// @notice 投资指定头寸，可选复投手续费\n', '    /// @dev This function can only be called by manager \n', '    /// @param fund 基金地址\n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @param amount 投资金额\n', '    /// @param collect 是否收集已产生的手续费并复投\n', '    function add(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint positionIndex, \n', '        uint amount, \n', '        bool collect\n', '    ) external;\n', '\n', '    /// @notice 撤资指定头寸\n', '    /// @dev This function can only be called by manager \n', '    /// @param fund 基金地址\n', '    /// @param poolIndex 池子索引号\n', '    /// @param positionIndex 头寸索引号\n', '    /// @param proportionX128 撤资比例，左移128位; 允许为0，为0表示只收集手续费\n', '    function sub(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint positionIndex,\n', '        uint proportionX128\n', '    ) external;\n', '\n', '    /// @notice 调整头寸投资\n', '    /// @dev This function can only be called by manager \n', '    /// @param fund 基金地址\n', '    /// @param poolIndex 池子索引号\n', '    /// @param subIndex 要移除的头寸索引号\n', '    /// @param addIndex 要添加的头寸索引号\n', '    /// @param proportionX128 调整比例，左移128位\n', '    function move(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint subIndex, \n', '        uint addIndex,\n', '        uint proportionX128\n', '    ) external;\n', '}\n', '\n', '// File: contracts/interfaces/controller/IGovernanceActions.sol\n', '/// @title 治理操作接口定义\n', 'interface IGovernanceActions {\n', '    /// @notice Change governance\n', '    /// @dev This function can only be called by governance\n', '    /// @param account 新的governance地址\n', '    function setGovernance(address account) external;\n', '\n', '    /// @notice Set the token to be verified for all fund, vice versa\n', '    /// @dev This function can only be called by governance\n', '    /// @param token 目标代币\n', '    /// @param isVerified 是否受信任\n', '    function setVerifiedToken(address token, bool isVerified) external;\n', '\n', '    /// @notice Set the swap path for harvest\n', '    /// @dev This function can only be called by governance\n', '    /// @param token 目标代币\n', '    /// @param path 路径\n', '    function setHarvestPath(address token, bytes memory path) external;\n', '}\n', '\n', '// File: contracts/interfaces/controller/IControllerState.sol\n', '/// @title HotPotV2Controller 状态变量及只读函数\n', 'interface IControllerState {\n', '    /// @notice Returns the address of the Uniswap V3 router\n', '    function uniV3Router() external view returns (address);\n', '\n', '    /// @notice Returns the address of the Uniswap V3 facotry\n', '    function uniV3Factory() external view returns (address);\n', '\n', '    /// @notice 本项目治理代币HPT的地址\n', '    function hotpot() external view returns (address);\n', '\n', '    /// @notice 治理账户地址\n', '    function governance() external view returns (address);\n', '\n', '    /// @notice Returns the address of WETH9\n', '    function WETH9() external view returns (address);\n', '\n', '    /// @notice 代币是否受信任\n', '    /// @dev The call will revert if the the token argument is address 0.\n', '    /// @param token 要查询的代币地址\n', '    function verifiedToken(address token) external view returns (bool);\n', '\n', '    /// @notice harvest时交易路径\n', '    /// @param token 要兑换的代币\n', '    function harvestPath(address token) external view returns (bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/controller/IControllerEvents.sol\n', '/// @title HotPotV2Controller 事件接口定义\n', 'interface IControllerEvents {\n', '    /// @notice 当设置受信任token时触发\n', '    event ChangeVerifiedToken(address indexed token, bool isVerified);\n', '\n', '    /// @notice 当调用Harvest时触发\n', '    event Harvest(address indexed token, uint amount, uint burned);\n', '\n', '    /// @notice 当调用setHarvestPath时触发\n', '    event SetHarvestPath(address indexed token, bytes path);\n', '\n', '    /// @notice 当调用setGovernance时触发\n', '    event SetGovernance(address indexed account);\n', '\n', '    /// @notice 当调用setPath时触发\n', '    event SetPath(address indexed fund, address indexed distToken, bytes path);\n', '}\n', '\n', '// File: contracts/interfaces/IHotPotV2FundController.sol\n', '/// @title Hotpot V2 控制合约接口定义.\n', '/// @notice 基金经理和治理均需通过控制合约进行操作.\n', 'interface IHotPotV2FundController is IManagerActions, IGovernanceActions, IControllerState, IControllerEvents {\n', '    /// @notice 基金分成全部用于销毁HPT\n', '    /// @dev 任何人都可以调用本函数\n', '    /// @param token 用于销毁时购买HPT的代币类型\n', '    /// @param amount 代币数量\n', '    /// @return burned 销毁数量\n', '    function harvest(address token, uint amount) external returns(uint burned);\n', '}\n', '\n', '// File: contracts/interfaces/IMulticall.sol\n', '/// @title Multicall\n', '/// @notice Enables calling multiple methods in a single call to the contract\n', 'interface IMulticall {\n', '    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n', '    /// @param data The encoded function data for each of the calls to make to this contract\n', '    /// @return results The results from each of the calls passed in via data\n', '    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n', '    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n', '}\n', '\n', '// File: contracts/base/Multicall.sol\n', '/// @title Multicall\n', '/// @notice Enables calling multiple methods in a single call to the contract\n', 'abstract contract Multicall is IMulticall {\n', '    /// @inheritdoc IMulticall\n', '    function multicall(bytes[] calldata data) external payable override returns (bytes[] memory results) {\n', '        results = new bytes[](data.length);\n', '        for (uint256 i = 0; i < data.length; i++) {\n', '            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n', '\n', '            if (!success) {\n', '                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n', '                if (result.length < 68) revert();\n', '                assembly {\n', '                    result := add(result, 0x04)\n', '                }\n', '                revert(abi.decode(result, (string)));\n', '            }\n', '\n', '            results[i] = result;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/HotPotV2FundController.sol\n', '// SPDX-License-Identifier: BUSL-1.1\n', '\n', 'contract HotPotV2FundController is IHotPotV2FundController, Multicall {\n', '    using Path for bytes;\n', '\n', '    address public override immutable uniV3Factory;\n', '    address public override immutable uniV3Router;\n', '    address public override immutable hotpot;\n', '    address public override governance;\n', '    address public override immutable WETH9;\n', '\n', '    mapping (address => bool) public override verifiedToken;\n', '    mapping (address => bytes) public override harvestPath;\n', '\n', '    modifier onlyManager(address fund){\n', '        require(msg.sender == IHotPotV2Fund(fund).manager(), "OMC");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovernance{\n', '        require(msg.sender == governance, "OGC");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address _hotpot,\n', '        address _governance,\n', '        address _uniV3Router,\n', '        address _uniV3Factory,\n', '        address _weth9\n', '    ) {\n', '        hotpot = _hotpot;\n', '        governance = _governance;\n', '        uniV3Router = _uniV3Router;\n', '        uniV3Factory = _uniV3Factory;\n', '        WETH9 = _weth9;\n', '    }\n', '\n', '    /// @inheritdoc IGovernanceActions\n', '    function setHarvestPath(address token, bytes memory path) external override onlyGovernance {\n', '        bytes memory _path = path;\n', '        (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();\n', '        while (true) {\n', '            // pool is exist\n', '            require(IUniswapV3Factory(uniV3Factory).getPool(tokenIn, tokenOut, fee) != address(0), "PIE");\n', '            if (path.hasMultiplePools()) {\n', '                path = path.skipToken();\n', '                (tokenIn, tokenOut, fee) = path.decodeFirstPool();\n', '            } else {\n', '                //最后一个交易对：输入WETH9, 输出hotpot\n', '                require(tokenIn == WETH9 && tokenOut == hotpot, "IOT");\n', '                break;\n', '            }\n', '        }\n', '        harvestPath[token] = _path;\n', '        emit SetHarvestPath(token, _path);\n', '    }\n', '\n', '    /// @inheritdoc IHotPotV2FundController\n', '    function harvest(address token, uint amount) external override returns(uint burned) {\n', '        uint value = amount <= IERC20(token).balanceOf(address(this)) ? amount : IERC20(token).balanceOf(address(this));\n', '        TransferHelper.safeApprove(token, uniV3Router, value);\n', '\n', '        ISwapRouter.ExactInputParams memory args = ISwapRouter.ExactInputParams({\n', '            path: harvestPath[token],\n', '            recipient: address(this),\n', '            deadline: block.timestamp,\n', '            amountIn: value,\n', '            amountOutMinimum: 0\n', '        });\n', '        burned = ISwapRouter(uniV3Router).exactInput(args);\n', '        IHotPot(hotpot).burn(burned);\n', '        emit Harvest(token, amount, burned);\n', '    }\n', '\n', '    /// @inheritdoc IGovernanceActions\n', '    function setGovernance(address account) external override onlyGovernance {\n', '        require(account != address(0));\n', '        governance = account;\n', '        emit SetGovernance(account);\n', '    }\n', '\n', '    /// @inheritdoc IGovernanceActions\n', '    function setVerifiedToken(address token, bool isVerified) external override onlyGovernance {\n', '        verifiedToken[token] = isVerified;\n', '        emit ChangeVerifiedToken(token, isVerified);\n', '    }\n', '\n', '    /// @inheritdoc IManagerActions\n', '    function setPath(\n', '        address fund,\n', '        address distToken,\n', '        bytes memory path\n', '    ) external override onlyManager(fund){\n', '        require(verifiedToken[distToken]);\n', '\n', '        address fundToken = IHotPotV2Fund(fund).token();\n', '        bytes memory _path = path;\n', '        bytes memory _reverse;\n', '        (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();\n', '        _reverse = abi.encodePacked(tokenOut, fee, tokenIn);\n', '        bool isBuy;\n', '        // 第一个tokenIn是基金token，那么就是buy路径\n', '        if(tokenIn == fundToken){\n', '            isBuy = true;\n', '        } \n', '        // 如果是sellPath, 第一个需要是目标代币\n', '        else{\n', '            require(tokenIn == distToken);\n', '        }\n', '\n', '        while (true) {\n', '            require(verifiedToken[tokenIn], "VIT");\n', '            require(verifiedToken[tokenOut], "VOT");\n', '            // pool is exist\n', '            address pool = IUniswapV3Factory(uniV3Factory).getPool(tokenIn, tokenOut, fee);\n', '            require(pool != address(0), "PIE");\n', '            // at least 2 observations\n', '            (,,,uint16 observationCardinality,,,) = IUniswapV3Pool(pool).slot0();\n', '            require(observationCardinality >= 2, "OC");\n', '\n', '            if (path.hasMultiplePools()) {\n', '                path = path.skipToken();\n', '                (tokenIn, tokenOut, fee) = path.decodeFirstPool();\n', '                _reverse = abi.encodePacked(tokenOut, fee, _reverse);\n', '            } else {\n', '                /// @dev 如果是buy, 最后一个token要是目标代币;\n', '                /// @dev 如果是sell, 最后一个token要是基金token.\n', '                if(isBuy)\n', '                    require(tokenOut == distToken, "OID");\n', '                else\n', '                    require(tokenOut == fundToken, "OIF");\n', '                break;\n', '            }\n', '        }\n', '        emit SetPath(fund, distToken, _path);\n', '        if(!isBuy) (_path, _reverse) = (_reverse, _path);\n', '        IHotPotV2Fund(fund).setPath(distToken, _path, _reverse);\n', '    }\n', '\n', '    /// @inheritdoc IManagerActions\n', '    function init(\n', '        address fund,\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint amount\n', '    ) external override onlyManager(fund){\n', '        IHotPotV2Fund(fund).init(token0, token1, fee, tickLower, tickUpper, amount);\n', '    }\n', '\n', '    /// @inheritdoc IManagerActions\n', '    function add(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint positionIndex,\n', '        uint amount,\n', '        bool collect\n', '    ) external override onlyManager(fund){\n', '        IHotPotV2Fund(fund).add(poolIndex, positionIndex, amount, collect);\n', '    }\n', '\n', '    /// @inheritdoc IManagerActions\n', '    function sub(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint positionIndex,\n', '        uint proportionX128\n', '    ) external override onlyManager(fund){\n', '        IHotPotV2Fund(fund).sub(poolIndex, positionIndex, proportionX128);\n', '    }\n', '\n', '    /// @inheritdoc IManagerActions\n', '    function move(\n', '        address fund,\n', '        uint poolIndex,\n', '        uint subIndex,\n', '        uint addIndex,\n', '        uint proportionX128\n', '    ) external override onlyManager(fund){\n', '        IHotPotV2Fund(fund).move(poolIndex, subIndex, addIndex, proportionX128);\n', '    }\n', '}']