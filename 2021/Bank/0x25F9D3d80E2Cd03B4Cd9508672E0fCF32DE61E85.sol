['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./Ownable.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', '\n', 'contract Bridge is Ownable{\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public feeAmount;\n', '\n', '    struct TxInfo{\n', '        address from;\n', '        address to;\n', '        uint256 amount;\n', '    }\n', '\n', '    mapping(bytes32 => bool) depositTxHash;\n', '    mapping(address => bool) verifier;\n', '    mapping(bytes32 => TxInfo) txInfo;\n', '    mapping(address => address) tokenOwner;\n', '    mapping(address => address) tokenPair;\n', '    mapping(address => address) reTokenPair;\n', '\n', '    event Deposit(address indexed tokenAddr, address indexed from, address indexed to, uint256 amount);\n', '    event Withdraw(address indexed tokenAddr, address indexed from, address to, uint256 amount, bytes32 indexed txHash);\n', '    event WithdrawInit(address indexed tokenAddr, address indexed to, uint256 amount);\n', '    event WithdrawFee(address indexed to, uint256 amount);\n', '\n', '    constructor (\n', '       address _homeToken,\n', '       address _foreignToken,\n', '       address _verifier,\n', '       uint256 _feeAmount\n', '    ) public {\n', '        tokenPair[_foreignToken] = _homeToken;\n', '        reTokenPair[_homeToken] = _foreignToken;\n', '        verifier[_verifier] = true;\n', '        feeAmount = _feeAmount;\n', '    }\n', '\n', '    function deposit(address _homeToken, address _to, uint256 _amount) public payable {\n', '        require(reTokenPair[_homeToken] != address(0), "deposit: pair not exist");\n', '        IERC20 token = IERC20(_homeToken);\n', '        require(msg.value >= feeAmount, "deposit: insufficient for fee");\n', '        require(token.balanceOf(msg.sender) >= _amount, "deposit: insufficient token balance");\n', '        token.transferFrom(msg.sender, address(this), _amount);\n', '        emit Deposit(_homeToken, msg.sender, _to, _amount);\n', '    }\n', '\n', '    function withdraw(address _foreignToken, address _from, address _to, uint256 _amount, bytes32 _txHash) public {\n', '        require(tokenPair[_foreignToken] != address(0), "withdraw: pair not exist");\n', '        require(verifier[msg.sender] == true, "withdraw: permission denied");\n', '        require(depositTxHash[_txHash] == false, "withdraw: duplicated hash");\n', '        address homeTokenAddr = tokenPair[_foreignToken];\n', '        safeTenTransfer(homeTokenAddr, _to, _amount);\n', '        depositTxHash[_txHash] = true;\n', '        TxInfo storage info = txInfo[_txHash];\n', '        info.from = _from;\n', '        info.to = _to;\n', '        info.amount = _amount;\n', '        emit Withdraw(homeTokenAddr, _from, _to, _amount, _txHash);\n', '    }\n', '\n', '    function withdrawInit(address _tokenAddr, address _to) public {\n', '        require(tokenOwner[_tokenAddr] == msg.sender, "withdrawInit: permission denied");\n', '        IERC20 token = IERC20(_tokenAddr);\n', '        uint256 amount = token.balanceOf(address(this));\n', '        safeTenTransfer(_tokenAddr, _to, amount);\n', '        emit WithdrawInit(_tokenAddr, _to, amount);\n', '    }\n', '\n', '    function withdrawFee(address payable _to) public onlyOwner {\n', '        _to.transfer(address(this).balance);\n', '        emit WithdrawFee(_to, address(this).balance);\n', '    } \n', '\n', '    function addVerifier(address _verifier) public onlyOwner {\n', '        verifier[_verifier] = true;\n', '    }\n', '\n', '    function subVerifier(address _verifier) public onlyOwner {\n', '        verifier[_verifier] = false;\n', '    }\n', '\n', '    function setFee(uint256 _feeAmount) public onlyOwner {\n', '        feeAmount = _feeAmount;\n', '    }\n', '\n', '    function setTokenOwner(address _tokenAddr, address _tokenOwner) public onlyOwner {\n', '        tokenOwner[_tokenAddr] = _tokenOwner;\n', '    }\n', '\n', '    function setTokenPair(address _homeAddr, address _foreignAddr) public onlyOwner {\n', '        tokenPair[_foreignAddr] = _homeAddr;\n', '        reTokenPair[_homeAddr] = _foreignAddr;\n', '    }\n', '\n', '    function getBalance(address _tokenAddr) public view returns (uint256) {\n', '        return IERC20(tokenPair[_tokenAddr]).balanceOf(address(this));\n', '    }\n', '\n', '    function safeTenTransfer(address _tokenAddr, address _to, uint256 _amount) internal {\n', '        IERC20 token = IERC20(_tokenAddr);\n', '        uint256 bal = token.balanceOf(address(this));\n', '        if (_amount > bal) {\n', '            token.transfer(_to, bal);\n', '        } else {\n', '            token.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '}']