['pragma solidity 0.6.11; // 5ef660b1\n', 'import "Uniswap.sol";\n', '/* BAEX - Roulette Smart-Contract v.1.1 (Â© 2021 - baex.com)\n', '    \n', 'A smart contract source code of an American Rolette game, default interface at https://baex.com/#roulette\n', '\n', 'Spin number generation in the function _spinRoulette:\n', '\n', 'uint256 spin_number = uint256(keccak256(abi.encodePacked(_bid_param,ifaceRandomSeed(seed_contract).getRandomSeed(),tx.origin.balance,tx.origin,blockhash(0)))) % 38;\n', '\n', 'Using this smart contract, you can earn from providing liquidity or play.\n', '*/\n', '\n', 'interface ifaceBAEXToken {\n', '    function transferOptions(address _from, address _to, uint256 _value, bool _burn_to_assets) external returns (bool);\n', '    function issuePrice() external view returns (uint256);\n', '\tfunction burnPrice() external view returns (uint256);\n', '\tfunction collateral() external view returns (uint256);\n', '}\n', '\n', 'interface ifaceRandomSeed {\n', '    function getRandomSeed() external returns(uint256);\n', '}\n', '\n', '/* BAEX - smart-contract of BAEX options */\n', 'contract BAEXRoulette {\n', '    // Fixed point math factor is 10^10\n', '    uint256 constant public fmk = 10**10;\n', '    // ALL STORED IN THIS CONTRACT BALANCES AND AMOUNTS HAVE PRECISION * 10\n', '    uint256 constant public tfmk = 10**9;\n', '    address constant private super_owner = 0x2B2fD898888Fa3A97c7560B5ebEeA959E1Ca161A;\n', '    address private owner;\n', '    \n', '    string public name;\n', '\n', '    // Min bid volume\n', '    uint256 public min_bid_vol;\n', '    // Max bid volume\n', '    uint256 public max_bid_vol;\n', '    \n', '    // Size of liquidity pool\n', '    uint256 public liquidity_pool;\n', '    \n', '    // Balancing factors\n', '    uint256 public liquidity_in;\n', '    uint256 public liquidity_ratio;\n', '    \n', '    uint32 public num_of_bids;\n', '    uint256 public total_games_in;\n', '    uint256 public total_games_out;\n', '    \n', '    uint256 public max_bid_k;\n', '    uint256 public max_win_k;\n', '    \n', '    address baex;\n', '    address seed_contract;\n', '    \n', '    mapping(address => uint256 ) public liquidity;\n', '    mapping(uint256 => uint256) public chips;\n', '    \n', '    constructor() public {\n', '\t\tname = "BAEX - Roulette Smart-Contract";\n', '\t\t\n', '\t\tliquidity_in = 0;\n', '\t\tliquidity_pool = 0;\n', '\t\tliquidity_ratio = 1 * fmk;\n', '\t\t\n', '\t\tmin_bid_vol = 25 * tfmk / 100;\n', '\t\tmax_bid_vol = 25 * tfmk / 100;\n', '\t\t\n', '\t\tchips[1] = 25 * tfmk / 100; // 0.25 BAEX\n', '        chips[2] = 50 * tfmk / 100; // 0.5  BAEX\n', '        chips[3] = 1 * tfmk;\n', '        chips[4] = 2 * tfmk;\n', '        chips[5] = 4 * tfmk;\n', '        chips[6] = 8 * tfmk;\n', '        chips[7] = 16 * tfmk;\n', '        chips[8] = 24 * tfmk;\n', '        chips[9] = 32 * tfmk;\n', '        chips[10] = 48 * tfmk;\n', '        chips[12] = 64 * tfmk;\n', '        chips[13] = 96 * tfmk;\n', '        chips[14] = 128 * tfmk;\n', '        chips[15] = 256 * tfmk;\n', '        \n', '        max_bid_k = 720;\n', '        max_win_k = 128;\n', '        \n', '\t\towner = msg.sender;\n', '\t\tnum_of_bids = 0;\n', '\t\tbaex = 0x889A3a814181536822e83373b4017e1122B01932;\n', '\t\tseed_contract = 0x205E8C8Cd03141b136B9e4361E4F5891174CB30B;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner() {\n', '\t\trequire( (msg.sender == owner) || (msg.sender == super_owner), "You don\'t have permissions to call it" );\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction afterChangeLiquidityPool() private {\n', '\t    if ( liquidity_pool == 0 ) {\n', '\t        liquidity_in = 0;\n', '\t\t    liquidity_pool = 0;\n', '\t\t    liquidity_ratio = 1 * fmk;\n', '\t\t    min_bid_vol = 25 * tfmk / 100;\n', '\t\t    max_bid_vol = 50 * tfmk / 100;\n', '\t\t    return;\n', '\t    }\n', '        max_bid_vol = liquidity_pool / max_bid_k;\n', '\t    liquidity_ratio = liquidity_in * fmk / liquidity_pool;\n', '\t    log2(bytes20(address(this)),bytes4("LPC"),bytes32(liquidity_pool<<128));\n', '\t}\n', '    \n', '    function placeLiquidity(uint256 _vol) public {\n', '        _placeLiquidity( msg.sender, _vol, true );\n', '    }\n', '\tfunction _placeLiquidity(address _sender, uint256 _vol, bool _need_transfer) private {\n', '\t    require( _vol > 0, "Vol must be greater than zero" );\n', '\t    require( _vol < 10**21, "Too big volume" );\n', '\t    if ( _need_transfer ) {\n', '\t        ifaceBAEXToken(baex).transferOptions(_sender,address(this),_vol,false);\n', '\t    }\n', '\t    _vol = _vol * 10;\n', '        uint256 in_vol = _vol;\n', '        if ( liquidity_pool != 0 ) {\n', '            in_vol = _vol * liquidity_ratio / fmk;\n', '        }\n', '        liquidity_in = liquidity_in + in_vol;\n', '        liquidity_pool = liquidity_pool + _vol;\n', '        liquidity[_sender] = liquidity[_sender] + in_vol;\n', '        afterChangeLiquidityPool();\n', '\t}\n', '\t\n', '\tfunction balanceOf(address _sender) public view returns (uint256) {\n', '        return liquidityBalanceOf(_sender);\n', '    }\n', '    \n', '    function getMinMaxBidVol() public view returns (uint256, uint256) {\n', '        return (min_bid_vol/10, max_bid_vol/10);\n', '    }\n', '    \n', '    function liquidityBalanceOf(address _sender) public view returns (uint256) {\n', '\t    return liquidity[_sender] * fmk / liquidity_ratio / 10;\n', '\t}\n', '\t\n', '\tfunction withdrawLiquidity(uint256 _vol, bool _burn_to_eth) public {\n', '\t    _withdrawLiquidity( msg.sender, _vol, _burn_to_eth );\n', '\t}\n', '\tfunction _withdrawLiquidity(address _sender, uint256 _vol, bool _burn_to_eth) private {\n', '\t    require( _vol > 0, "Vol must be greater than zero" );\n', '\t    require( _vol < 10**21, "Too big volume" );\n', '\t    _vol = _vol * 10;\n', '\t    require( _vol <= liquidity_pool, "Not enough volume for withdrawal, please decrease volume to withdraw (1)" );\n', '\t    uint256 in_vol = _vol * liquidity_ratio / fmk;\n', '\t    uint256 in_bal = liquidity[_sender];\n', '\t    require( in_vol <= in_bal, "Not enough volume for withdrawal, please decrease volume to withdraw (2)" );\n', '\t    ifaceBAEXToken(baex).transferOptions(address(this),_sender,_vol/10,_burn_to_eth);\n', '\t    if ( liquidity_pool - _vol < 3 ) {\n', '            liquidity[_sender] = 0;\n', '            liquidity_pool = 0;\n', '            liquidity_in = 0;\n', '            liquidity_ratio = fmk;\n', '        } else {\n', '            if ( in_bal - in_vol < 3 ) {\n', '\t            in_vol = in_bal;\n', '\t        }\n', '            liquidity[_sender] = in_bal - in_vol;\n', '            liquidity_pool = liquidity_pool - _vol;\n', '            liquidity_in = liquidity_in - in_vol;\n', '        }\n', '        afterChangeLiquidityPool();\n', '\t}\n', '\t\n', '\tfunction getChipVolume(  uint256 _chip_id  ) public view returns(uint256){\n', '\t    if ( _chip_id == 0 ) return 0;\n', '        return chips[_chip_id];\n', '\t}\n', '\t\n', '\tfunction getBidVolFromParam( uint256 _bid_param ) public view returns(uint256) {\n', '\t    uint256 vol = 0;\n', '\t    uint256 cid = _bid_param >> 252;\n', '\t    vol = getChipVolume(cid);\n', '\t    for (uint i=0; i<49; i++) {\n', '    \t    _bid_param = _bid_param << 4;\n', '    \t    cid = _bid_param >> 252;\n', '    \t    vol = vol + getChipVolume(cid);\n', '\t    }\n', '\t    return vol;\n', '\t}\n', '\t\n', '\tfunction calcTotalResultBySpinNumberAndParam( uint256 spin_number, uint256 _bid_param ) private view returns(uint256) {\n', '\t    uint256 result = 0;\n', '\t    uint256 cid = ( _bid_param << (spin_number*4) ) >> 252;\n', '\t    result = getChipVolume( cid ) * 36;\n', '\t    if ( spin_number > 0 && spin_number < 37 ) {\n', '    \t    // from 1 to 18\n', '    \t    if ( spin_number >= 1 && spin_number <= 18 ) {\n', '    \t        cid = ( _bid_param << 38 * 4 ) >> 252;\n', '    \t    } else { // from 18 to 36\n', '    \t        cid = ( _bid_param << 39 * 4 ) >> 252;\n', '    \t    }\n', '    \t    result = result + getChipVolume( cid ) * 2;\n', '    \t    // Red \n', '    \t    if ( (spin_number == 1) || (spin_number == 3) || (spin_number == 5) || (spin_number == 7) || (spin_number == 9) || (spin_number == 12) ||\n', '    \t        (spin_number == 14) || (spin_number == 16) || (spin_number == 18) || (spin_number == 19) || (spin_number == 21) || (spin_number == 23) ||\n', '    \t        (spin_number == 25) || (spin_number == 27) || (spin_number == 30) || (spin_number == 32) || (spin_number == 34) || (spin_number == 36) \n', '    \t    ) { \n', '    \t        cid = ( _bid_param << 41 * 4 ) >> 252;\n', '    \t    } else { // Black\n', '    \t        cid = ( _bid_param << 40 * 4 ) >> 252;\n', '    \t    }\n', '    \t    result = result + getChipVolume( cid ) * 2;\n', '    \t    // Even\n', '    \t    if ( spin_number % 2 == 0 ) {\n', '    \t        cid = ( _bid_param << 42 * 4 ) >> 252;\n', '    \t    } else { // Odd\n', '    \t        cid = ( _bid_param << 43 * 4 ) >> 252;\n', '    \t    }\n', '    \t    result = result + getChipVolume( cid ) * 2;\n', '    \t    // Dozen 1\n', '    \t    if ( spin_number >= 1 && spin_number <= 12 ) {\n', '    \t        cid = ( _bid_param << 44 * 4 ) >> 252;\n', '    \t    } else if ( spin_number >= 13 && spin_number <= 24 ) { // Dozen 2\n', '    \t        cid = ( _bid_param << 45 * 4 ) >> 252;\n', '    \t    } else { // Dozen 3\n', '    \t        cid = ( _bid_param << 46 * 4 ) >> 252;\n', '    \t    }\n', '    \t    result = result + getChipVolume( cid ) * 3;\n', '    \t    // Third 1\n', '    \t    if ( spin_number % 3 == 1 ) {\n', '    \t        cid = ( _bid_param << 47 * 4 ) >> 252;\n', '    \t    } else if ( spin_number % 3 == 2) { // Third 2\n', '    \t        cid = ( _bid_param << 48 * 4 ) >> 252;\n', '    \t    } else { // Third 3\n', '    \t        cid = ( _bid_param << 49 * 4 ) >> 252;\n', '    \t    }\n', '    \t    result = result + getChipVolume( cid ) * 3;\n', '    \t}\n', '\t    return result;\n', '\t}\n', '\t\n', '\t\n', '\t/**\n', '    * @dev Spin the roullete\n', '\t* @dev uint256 _bid_param - coded as 4 bits per one field (one hex number from 0 to F, 256 bits cointains 64 hex digits) from high bits\n', '\t* @dev                      every 4 bits store ID of the chip, you can find volumes of every chip in the chips variable\n', '    * @dev  0       - ZERO\n', '    * @dev  1-36    - 1-36\n', '    * @dev  37      - Double ZERO\n', '    * @dev  38      - Numbers from 1 to 18\n', '    * @dev  39      - Numbers from 19 to 36\n', '    * @dev  40-41   - Black / Red\n', '    * @dev  42-43   - Even / Odd\n', '    * @dev  44-46   - Dozens\n', '    * @dev  47-49   - Thirds\n', '    * @dev  50-63   - Not used\n', '    * @dev \n', '    * @dev  Example of the _bid_param :\n', '    * @dev    0000000000000000000000000000000000000000300000500000000000000000\n', '    * @dev    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^     ^\n', '    * @dev    0123456789111......................330  B     3nd                             \n', '    * @dev              012                      560  L     D\n', '    * @dev                                            A     O\n', '    * @dev                                            C     Z\n', '    * @dev                                            K     E \n', '    * @dev                                                  N\n', '    * @dev\n', "    * @dev  That's mean chip with id 3 (default volume is 1 BAEX) on BLACK\n", '    * @dev    and chip with id 5 (default volume is 4 BAEX) on 2nd DOZEN\n', '    * @dev \n', '    */\n', '\tfunction spinRoulette(uint256 _bid_param) public {\n', '\t    _spinRoulette(msg.sender, _bid_param);\n', '\t}\n', '\tfunction _spinRoulette(address _sender, uint256 _bid_param) private {\n', '\t    uint256 _vol = getBidVolFromParam( _bid_param );\n', '\t    require( tx.origin == msg.sender, "Only origin addresses can call it" );\n', '\t    require( _vol > 0, "Bid volume must be greater than zero" );\n', '\t    require( _vol < 10**21, "Too big bid volume" );\n', '\t    require( _vol >= min_bid_vol, "Your bid volume less than minimal bid volume" );\n', '\t    require( _vol <= max_bid_vol, "Your bid volume greater than maximum bid volume" );\n', '\t    require( IERC20(baex).balanceOf(_sender) >= _vol/10, "Not enough balance to place this bid" );\n', '\t    require( liquidity_pool/max_bid_k >= _vol, "Not enough liquidity in the pool" );\n', '\t    // GENERATE ROULETTE SPIN RANDOM\n', '\t    uint256 spin_number = uint256(keccak256(abi.encodePacked(_bid_param,ifaceRandomSeed(seed_contract).getRandomSeed(),tx.origin.balance,tx.origin,blockhash(0)))) % 38;\n', '\t    // ---\n', '\t    uint256 result = calcTotalResultBySpinNumberAndParam( spin_number, _bid_param );\n', '\t    require( result <= (liquidity_pool / max_win_k), "Your bid volume is too high" );\n', '\t    total_games_in = total_games_in + _vol/10;\n', '\t    ifaceBAEXToken(baex).transferOptions(_sender,address(this),_vol/10,false);\n', '\t    if ( spin_number == 37 ) {\n', '\t        ifaceBAEXToken(baex).transferOptions(address(this),owner,_vol/10,false);\n', '\t    } else {\n', '\t        liquidity_pool = liquidity_pool + _vol;\n', '\t    }\n', '\t    if ( result > 0 ) {\n', '\t        liquidity_pool = liquidity_pool - result;\n', '\t        ifaceBAEXToken(baex).transferOptions(address(this),_sender,result/10,false);\n', '\t        total_games_out = total_games_out + result/10;\n', '\t    }\n', '\t    afterChangeLiquidityPool();\n', '\t    // LOG THE RESULT OF THE SPIN\n', '\t    log3(bytes20(address(this)),bytes8("ROLL"),bytes32(uint256(msg.sender)),bytes32((spin_number<<224) | result));\n', '\t    num_of_bids++;\n', '\t}\n', '\t\n', '\t/* Admin functions */\n', '\tfunction transferOwnership(address newOwner) public onlyOwner {\n', '\t\trequire(newOwner != address(0));\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\tfunction setTokenAddress(address _token_address) public onlyOwner {\n', '\t    baex = _token_address;\n', '\t}\n', '\t\n', '\tfunction setSeedContract(address _seed_contract) public onlyOwner {\n', '\t    seed_contract = _seed_contract;\n', '\t}\n', '\t\n', '\tfunction setMaxBidAndWin(uint256 _max_bid_k, uint256 _max_win_k) public onlyOwner {\n', '\t    max_bid_k = _max_bid_k;\n', '\t    max_win_k = _max_win_k;\n', '\t}\n', '\t\n', '\tfunction setChip(uint256 _chip_id, uint256 _vol) public onlyOwner {\n', '\t    chips[_chip_id] = _vol;\n', '\t    if (_chip_id == 1) {\n', '\t        min_bid_vol = _vol;\n', '\t    }\n', '\t}\n', '\t\n', '\tfunction onTransferTokens(address _from, address _to, uint256 _value) public returns (bool) {\n', '\t    require( msg.sender == address(baex), "You don\'t have permission to call it" );\n', '\t    if ( _to == address(this) ) {\n', '\t        _placeLiquidity( _from, _value, false );\n', '\t    }\n', '\t}\n', '\t\n', '\t// This function can transfer any of wrong sended ERC20 tokens to the contract exclude BAEX tokens,\n', '\t// because sendeding of the BAEX tokens to this contract is the valid operation\n', '\tfunction transferWrongSendedERC20FromContract(address _contract) public {\n', '\t    require( _contract != address(baex), "Transfer of BAEX token is fortradeen");\n', '\t    require( msg.sender == super_owner, "Your are not super owner");\n', '\t    IERC20(_contract).transfer( super_owner, IERC20(_contract).balanceOf(address(this)) );\n', '\t}\n', '\t\n', '\t// If someone send ETH to this contract it will send it back\n', '\treceive() external payable  {\n', '        msg.sender.transfer(msg.value);\n', '\t}\n', '\t/*------------------*/\n', '\t\n', '}\n', '/* END of: Smart-contract */\n', '\n', '// SPDX-License-Identifier: UNLICENSED']