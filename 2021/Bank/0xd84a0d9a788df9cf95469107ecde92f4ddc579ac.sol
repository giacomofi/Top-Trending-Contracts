['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-26\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '//   _    _ _   _                __ _                            \n', '//  | |  (_) | | |              / _(_)                           \n', '//  | | ___| |_| |_ ___ _ __   | |_ _ _ __   __ _ _ __   ___ ___ \n', "//  | |/ / | __| __/ _ \\ '_ \\  |  _| | '_ \\ / _` | '_ \\ / __/ _ \\\n", '//  |   <| | |_| ||  __/ | | |_| | | | | | | (_| | | | | (_|  __/\n', '//  |_|\\_\\_|\\__|\\__\\___|_| |_(_)_| |_|_| |_|\\__,_|_| |_|\\___\\___|\n', '//\n', '//  KittenSwap Lending v0\n', '//\n', '//  https://www.KittenSwap.org/\n', '//\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require (c >= a, "!!add");\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require (b <= a, "!!sub");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require (b <= a, errorMessage);\n', '        uint c = a - b;\n', '        return c;\n', '    }    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require (c / a == b, "!!mul");\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require (b > 0, "!!div");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract ERC20Detailed {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', 'interface LIQUID_TOKEN {\n', '    function totalSupply (  ) external view returns ( uint256 );\n', '    function getTokenReserve (  ) external view returns ( uint256 );\n', '    function getEthReserve (  ) external view returns ( uint256 );\n', '    \n', '    function balanceOf ( address account ) external view returns ( uint256 );\n', '    function transfer ( address recipient, uint256 amount ) external returns ( bool );\n', '    function transferFrom ( address sender, address recipient, uint256 amount ) external returns ( bool );    \n', '    \n', '    function buyToken ( uint256 minTokenAmt, uint256 expireTimestamp ) external payable;    \n', '    function sellToken ( uint256 tokenAmt, uint256 minEthAmt, uint256 expireTimestamp ) external;\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', 'contract KittenETHv0 is ERC20Detailed\n', '{\n', '    using SafeMath for uint;\n', '    \n', '    address public constant LIQUID_ADDR = 0xC618D56b6D606E59c6B87Af724AB5a91eb40D1cb;\n', '    uint public MIGRATION_TIMESTAMP = 0;               // for migration\n', '    uint public MIGRATION_LIQUIDATION_WAIT = 14 days;  // gov can liquidate forgotten loans some days after migration starts\n', '    uint public FLASH_LOAN_BP = 10;                    // in terms of basis points\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    LIQUID_TOKEN private constant LIQUID = LIQUID_TOKEN(LIQUID_ADDR);\n', '    address public govAddr;\n', '        \n', '    constructor () public ERC20Detailed("KittenETHv0", "KittenETHv0", 18) {\n', '        govAddr = msg.sender;\n', '    }\n', '    \n', '    modifier govOnly() {\n', '    \trequire (msg.sender == govAddr, "!gov");\n', '    \t_;\n', '    }\n', '    \n', '    function govTransferAddr(address newAddr) external govOnly {\n', '    \trequire (newAddr != address(0), "!addr");\n', '    \tgovAddr = newAddr;\n', '    }\n', '    \n', '    function govSetMIGRATION_TIMESTAMP(uint $MIGRATION_TIMESTAMP) external govOnly {\n', '        require ($MIGRATION_TIMESTAMP > block.timestamp);\n', '    \tMIGRATION_TIMESTAMP = $MIGRATION_TIMESTAMP;\n', '    }\n', '    \n', '    function govSetFLASH_LOAN_BP(uint $FLASH_LOAN_BP) external govOnly {\n', '        require (FLASH_LOAN_BP <= 60);\n', '    \tFLASH_LOAN_BP = $FLASH_LOAN_BP;\n', '    }    \n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    \n', '    mapping (address => uint) private _balances;\n', '    mapping (address => mapping (address => uint)) private _allowances;\n', '\n', '    uint private _totalSupply;\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '    function balanceOf(address account) public view returns (uint) {\n', '        return _balances[account];\n', '    }\n', '    function transfer(address recipient, uint amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '    function _transfer(address sender, address recipient, uint amount) internal {\n', '        require (sender != address(0), "ERC20: transfer from the zero address");\n', '        require (recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        \n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '    \n', '    //------------------------------------------------------------------------------\n', '    \n', '    function allowance(address owner, address spender) public view returns (uint) {\n', '        return _allowances[owner][spender];\n', '    }\n', '    function approve(address spender, uint amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '    function _approve(address owner, address spender, uint amount) internal {\n', '        require (owner != address(0), "ERC20: approve from the zero address");\n', '        require (spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    \n', '    //------------------------------------------------------------------------------\n', '    \n', '    function _mint(address account, uint amount) internal {\n', '        require (account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _balances[account] = _balances[account].add(amount);\n', '        _totalSupply = _totalSupply.add(amount);\n', '\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '    function _burn(address account, uint amount) internal {\n', '        require (account != address(0), "ERC20: burn from the zero address");\n', '        \n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    uint constant PRICE_SCALE = 10 ** 10;\n', '    function getLiqEthFloorPriceScaled() internal view returns (uint)\n', '    {\n', '        uint AMM_PRODUCT = (LIQUID.getTokenReserve()).mul(LIQUID.getEthReserve());\n', '        uint TOTAL_SUPPLY = LIQUID.totalSupply();\n', '\n', '        return PRICE_SCALE.mul(AMM_PRODUCT).div(TOTAL_SUPPLY).div(TOTAL_SUPPLY);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    event LOCK_ETH(address indexed user, uint ethAmt, uint kethAmt);\n', '    event UNLOCK_ETH(address indexed user, uint ethAmt, uint kethAmt);\n', '    \n', '    function getContractValueInEth() public view returns (uint)\n', '    {\n', '        uint ethValue = (address(this).balance);\n', '        \n', '        uint liqValue = (LIQUID.balanceOf(address(this))).mul(getLiqEthFloorPriceScaled()) / (PRICE_SCALE);\n', '        \n', '        return ethValue.add(liqValue);\n', '    }\n', '\n', '    function lockEth() external payable // lock ETH for lending, and mint KittenEth\n', '    {\n', '        //-------- receive ETH from user --------\n', '        address user = msg.sender;\n', '        uint ethInAmt = msg.value;\n', "        require (ethInAmt > 0, '!ethInAmt');\n", '        \n', '        //-------- compute KittenETH mint amt --------\n', '        uint kethMintAmt = 0;\n', '        if (_totalSupply == 0) { \n', '            kethMintAmt = ethInAmt; // initial price: 1 kETH = 1 ETH\n', '        }\n', '        else {                \n', '            kethMintAmt = ethInAmt.mul(_totalSupply).div(getContractValueInEth().sub(ethInAmt));\n', '        }\n', '        \n', '        //-------- mint KittenETH to user --------\n', '        _mint(user, kethMintAmt);\n', '        emit LOCK_ETH(user, ethInAmt, kethMintAmt);\n', '    }\n', '    \n', '    function unlockEth(uint kethBurnAmt) external // unlock ETH, and burn KittenEth\n', '    {\n', "        require (kethBurnAmt > 0, '!kethBurnAmt');\n", '        address payable user = msg.sender;\n', '\n', '        //-------- compute ETH out amt --------\n', '        uint ethOutAmt = kethBurnAmt.mul(getContractValueInEth()).div(_totalSupply);\n', "        require (address(this).balance >= ethOutAmt, '!ethInContract');\n", '\n', '        //-------- burn KittenETH from user --------\n', '        _burn(user, kethBurnAmt);\n', '        \n', '        //-------- send ETH to user --------\n', '        user.transfer(ethOutAmt);\n', '        emit UNLOCK_ETH(user, ethOutAmt, kethBurnAmt);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    mapping (address => uint) public liqLocked;\n', '    \n', '    event LOCK_LIQ(address indexed user, uint liqAmt, uint ethAmt);\n', '    event UNLOCK_LIQ(address indexed user, uint liqAmt, uint ethAmt);    \n', '    \n', '    function lockLiq(uint liqInAmt) external // lock LIQUID to borrow ETH\n', '    {\n', "        require (liqInAmt > 0, '!liqInAmt');\n", "        require (block.timestamp < MIGRATION_TIMESTAMP, '!migration'); // can't lock after migration starts\n", '        address payable user = msg.sender;\n', '\n', '        //-------- compute ETH out amt --------\n', '        uint ethOutAmt = liqInAmt.mul(getLiqEthFloorPriceScaled()) / (PRICE_SCALE);\n', "        require (address(this).balance >= ethOutAmt, '!ethInContract');\n", '\n', '        //--------  send LIQUID to contract --------\n', '        LIQUID.transferFrom(user, address(this), liqInAmt); \n', '        liqLocked[user] = liqLocked[user].add(liqInAmt);\n', '        \n', '        //-------- send ETH to user --------\n', '        user.transfer(ethOutAmt);\n', '        emit LOCK_LIQ(user, liqInAmt, ethOutAmt);\n', '    }\n', '    \n', '    function unlockLiq() external payable // payback ETH to unlock LIQUID\n', '    {\n', '        //-------- receive ETH from user --------\n', '        uint ethInAmt = msg.value;\n', "        require (ethInAmt > 0, '!ethInAmt');\n", '        uint ethReturnAmt = 0;\n', '        address payable user = msg.sender;\n', '\n', '        //-------- compute LIQUID out amt --------\n', '        uint LiqEthFloorPriceScaled = getLiqEthFloorPriceScaled();\n', '\n', '        uint liqOutAmt = ethInAmt.mul(PRICE_SCALE).div(LiqEthFloorPriceScaled);\n', '        if (liqOutAmt > liqLocked[user])\n', '        {\n', '            liqOutAmt = liqLocked[user];\n', '            ethReturnAmt = ethInAmt.sub(\n', '                    liqOutAmt.mul(LiqEthFloorPriceScaled) / (PRICE_SCALE)\n', '                );\n', '        }\n', '        \n', '        //--------  send LIQUID to user --------\n', '        liqLocked[user] = liqLocked[user].sub(liqOutAmt);\n', '        LIQUID.transfer(user, liqOutAmt);\n', '        \n', '        //-------- return extra ETH to user --------\n', '        if (ethReturnAmt > 10 ** 8) { // ignore dust\n', '            user.transfer(ethReturnAmt);\n', '        }\n', '        emit UNLOCK_LIQ(user, liqOutAmt, ethInAmt.sub(ethReturnAmt));\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    receive() external payable { // receive ETH (from selling LIQUID)\n', "        require(msg.sender == LIQUID_ADDR, '!sender');\n", '    }\n', '\n', '    function flashUnlockLiqAndSell(address payable user, uint liqUnlockAmt, uint liqSellAmt, uint liqSellMinEthAmt, uint liqSellExpireTimestamp) external payable\n', '    {\n', '        require (\n', '            (user == msg.sender) \n', '            || // gov can liquidate forgotten loans some days after migration starts\n', '            ((block.timestamp.sub(MIGRATION_LIQUIDATION_WAIT) > MIGRATION_TIMESTAMP) && (govAddr == msg.sender))\n', "        , '!user');\n", '        \n', '        if (liqUnlockAmt > liqLocked[user])\n', '            liqUnlockAmt = liqLocked[user];\n', '        if (liqSellAmt > liqUnlockAmt)\n', '            liqSellAmt = liqUnlockAmt;\n', '\n', '        //-------- receive ETH from user --------\n', '        uint ethInAmt = msg.value;\n', '        \n', '        //-------- compute ETH required for unlocking LIQUID --------\n', '        uint ethBorrowAmt = 0;\n', '        uint ethOutAmt = 0;\n', '        \n', '        uint ethRequiredForUnlock = liqUnlockAmt.mul(getLiqEthFloorPriceScaled()) / (PRICE_SCALE);\n', '        if (ethRequiredForUnlock > ethInAmt) {\n', '            ethBorrowAmt = (ethRequiredForUnlock - ethInAmt).mul(10000 + FLASH_LOAN_BP) / 10000; // add FLASH_LOAN_BP fee\n', '        } else {\n', '            ethOutAmt = ethInAmt - ethRequiredForUnlock;\n', '        }\n', '\n', '        //-------- sell LIQUID --------\n', '        uint liqLoss = 0;\n', '        uint ethGain = 0;\n', '        if (liqSellAmt > 0)\n', '        {\n', '            uint liqBefore = LIQUID.balanceOf(address(this));\n', '            uint ethBefore = address(this).balance;\n', '            \n', '            LIQUID.sellToken(liqSellAmt, liqSellMinEthAmt, liqSellExpireTimestamp); // sell LIQUID\n', '    \n', "            liqLoss = liqBefore.sub(LIQUID.balanceOf(address(this)), '!liqLoss'); // now contract has less LIQUID\n", "            ethGain = (address(this).balance).sub(ethBefore, '!ethGain'); // now contract has more ETH            \n", '        }\n', '        \n', '        //-------- payback flash-loan (if occured) --------\n', '        if (ethBorrowAmt > 0) { // ethOutAmt = 0\n', "            ethOutAmt = ethGain.sub(ethBorrowAmt, '!ethBorrowAmt'); // will throw if not enough\n", '        } else { // ethBorrowAmt = 0\n', '            ethOutAmt = ethOutAmt.add(ethGain);\n', '        }\n', '\n', '        //-------- unlock LIQUID --------\n', "        liqLocked[user] = liqLocked[user].sub(liqUnlockAmt, '!liqUnlockAmt');\n", '        \n', '        //-------- send LIQUID to user --------\n', '        if (liqUnlockAmt > liqLoss) {\n', '            LIQUID.transfer(user, liqUnlockAmt - liqLoss);\n', '        }\n', '        //-------- send ETH to user --------\n', '        if (ethOutAmt > 10 ** 8) { // ignore dust\n', '            user.transfer(ethOutAmt);\n', '        }\n', '        \n', '        emit UNLOCK_LIQ(user, liqUnlockAmt, ethRequiredForUnlock);\n', '    }\n', '    \n', '    function flashBuyLiqAndLock(uint ethBorrowAmt, uint liqLockAmt, uint liqBuyMinAmt, uint liqBuyExpireTimestamp) external payable\n', '    {\n', "        require (block.timestamp < MIGRATION_TIMESTAMP, '!migration'); // can't lock after migration starts        \n", '        address payable user = msg.sender;\n', '        \n', '        //-------- receive ETH from user --------\n', '        uint ethInAmt = msg.value;\n', '        \n', '        //-------- buy LIQUID --------\n', '        uint liqGain = 0;\n', '        uint ethLoss = 0;\n', '        {\n', '            uint liqBefore = LIQUID.balanceOf(address(this));\n', '            uint ethBefore = address(this).balance;\n', '            \n', '            //-------- borrow flash-loan --------\n', '            uint ethTotalInAmt = ethInAmt.add(ethBorrowAmt);\n', '            \n', "            require (ethBefore >= ethTotalInAmt, '!ethInContract');\n", '            LIQUID.buyToken {value: ethTotalInAmt} (liqBuyMinAmt, liqBuyExpireTimestamp); // buy LIQUID\n', '    \n', "            liqGain = (LIQUID.balanceOf(address(this))).sub(liqBefore, '!liqGain'); // now contract has more LIQUID\n", "            ethLoss = ethBefore.sub(address(this).balance, '!ethLoss'); // now contract has less ETH            \n", '        }\n', '        \n', '        //-------- compute ETH gain from locking LIQUID --------\n', '        if (liqLockAmt > liqGain) {\n', '            liqLockAmt = liqGain;\n', '        }\n', '        uint ethLockOutAmt = liqLockAmt.mul(getLiqEthFloorPriceScaled()) / (PRICE_SCALE);\n', '        \n', '        //-------- payback flash-loan --------\n', "        uint ethOutAmt = ethInAmt.add(ethLockOutAmt).sub(ethLoss, '!ethLockOutAmt'); // will throw if not enough\n", "        ethOutAmt = ethOutAmt.sub(ethBorrowAmt.mul(FLASH_LOAN_BP) / 10000, '!ethBorrowAmt');\n", '\n', '        //-------- lock LIQUID --------\n', '        liqLocked[user] = liqLocked[user].add(liqLockAmt);\n', '        \n', '        //-------- send LIQUID to user --------\n', '        if (liqGain > liqLockAmt) {\n', '            LIQUID.transfer(user, liqGain - liqLockAmt);\n', '        }\n', '        //-------- send ETH to user --------\n', '        if (ethOutAmt > 10 ** 8) { // ignore dust\n', "            require (address(this).balance >= ethOutAmt, '!ethOutAmt');\n", '            user.transfer(ethOutAmt);\n', '        }\n', '        \n', '        emit LOCK_LIQ(user, liqLockAmt, ethLockOutAmt);\n', '    }\n', '}']