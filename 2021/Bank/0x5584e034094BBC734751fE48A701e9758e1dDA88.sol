['# @version 0.2.11\n', '# @author banteg\n', '# @notice Calculate voting power from productive YFI\n', 'from vyper.interfaces import ERC20\n', '\n', 'struct VotingBalances:\n', '    wallet: uint256\n', '    vault: uint256\n', '    bancor: uint256\n', '    balancer: uint256\n', '    uniswap: uint256\n', '    sushiswap: uint256\n', '    makerdao: uint256\n', '    unit: uint256\n', '\n', '\n', 'struct List:\n', '    prev: uint256\n', '    next: uint256\n', '\n', '\n', 'struct Urn:\n', '    ink: uint256\n', '    art: uint256\n', '\n', '\n', 'struct ProtectedLiquidity:\n', '    provider: address\n', '    poolToken: address\n', '    reserveToken: address\n', '    poolAmount: uint256\n', '    reserveAmount: uint256\n', '    reserveRateN: uint256\n', '    reserveRateD: uint256\n', '    time: uint256\n', '\n', '\n', 'struct UserInfo:\n', '    amount: uint256\n', '    rewardDebt: uint256\n', '\n', '\n', 'interface Vault:\n', '    def pricePerShare() -> uint256: view\n', '\n', '\n', 'interface DSProxyRegistry:\n', '    def proxies(user: address) -> address: view\n', '\n', '\n', 'interface DssCdpManager:\n', '    def count(user: address) -> uint256: view\n', '    def first(user: address) -> uint256: view\n', '    def list(cdp: uint256) -> List: view\n', '    def ilks(cdp: uint256) -> bytes32: view\n', '    def urns(cdp: uint256) -> address: view\n', '\n', '\n', 'interface Vat:\n', '    def urns(ilk: bytes32, user: address) -> Urn: view\n', '\n', '\n', 'interface Bancor:\n', '    def protectedLiquidityCount(provider: address) -> uint256: view\n', '    def protectedLiquidityId(provider: address, index: uint256) -> uint256: view\n', '    def protectedLiquidity(_id: uint256) -> ProtectedLiquidity: view\n', '\n', '\n', 'interface MasterChef:\n', '    def userInfo(pid: uint256, user: address) -> UserInfo: view\n', '\n', '\n', 'interface Unit:\n', '    def collaterals(token: address, user: address) -> uint256: view\n', '\n', '\n', 'yfi: constant(address) = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e\n', 'vault: constant(address) = 0xE14d13d8B3b85aF791b2AADD661cDBd5E6097Db1\n', 'balancer: constant(address) = 0x41284a88D970D3552A26FaE680692ED40B34010C\n', 'masterchef: constant(address) = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd\n', 'sushiswap: constant(address) = 0x088ee5007C98a9677165D78dD2109AE4a3D04d0C\n', 'uniswap: constant(address) = 0x2fDbAdf3C4D5A8666Bc06645B8358ab803996E28\n', 'bancor: constant(address) = 0xf5FAB5DBD2f3bf675dE4cB76517d4767013cfB55\n', 'unit: constant(address) = 0xb1cFF81b9305166ff1EFc49A129ad2AfCd7BCf19\n', 'proxy_registry: constant(address) = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4\n', 'cdp_manager: constant(address) = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39\n', 'vat: constant(address) = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B\n', '\n', '\n', '@view\n', '@internal\n', 'def makerdao_collateral(user: address) -> uint256:\n', '    yfi_a: bytes32 = 0x5946492d41000000000000000000000000000000000000000000000000000000\n', '    proxy: address = DSProxyRegistry(proxy_registry).proxies(user)\n', '    if proxy == ZERO_ADDRESS:\n', '        return 0\n', '    cdp: uint256 = DssCdpManager(cdp_manager).first(proxy)\n', '    urn: address = ZERO_ADDRESS\n', '    total: uint256 = 0\n', '    for i in range(100):\n', '        if cdp == 0:\n', '            break\n', '        if DssCdpManager(cdp_manager).ilks(cdp) == yfi_a:\n', '            urn = DssCdpManager(cdp_manager).urns(cdp)\n', '            total += Vat(vat).urns(yfi_a, urn).ink\n', '        cdp = DssCdpManager(cdp_manager).list(cdp).next\n', '    return total\n', '\n', '\n', '@view\n', '@internal\n', 'def lp_balance(pool: address, user: address) -> uint256:\n', '    return ERC20(yfi).balanceOf(pool) * ERC20(pool).balanceOf(user) / ERC20(pool).totalSupply()\n', '\n', '\n', '@view\n', '@internal\n', 'def sushiswap_balance(user: address) -> uint256:\n', '    # yfi balance of slp * slp in masterchef / slp total supply\n', '    staked: uint256 = MasterChef(masterchef).userInfo(11, user).amount + ERC20(sushiswap).balanceOf(user)\n', '    return ERC20(yfi).balanceOf(sushiswap) * staked / ERC20(sushiswap).totalSupply()\n', '\n', '\n', '@view\n', '@internal\n', 'def vault_balance(user: address) -> uint256:\n', '    return ERC20(vault).balanceOf(user) * Vault(vault).pricePerShare() / 10 ** 18\n', '\n', '\n', '@view\n', '@internal\n', 'def yfi_in_bancor(user: address) -> uint256:\n', '    total: uint256 = 0\n', '    id: uint256 = 0\n', '    count: uint256 = Bancor(bancor).protectedLiquidityCount(user)\n', '    liquidity: ProtectedLiquidity = empty(ProtectedLiquidity)\n', '    for i in range(100):\n', '        if i == count:\n', '            break\n', '        id = Bancor(bancor).protectedLiquidityId(user, i)\n', '        liquidity = Bancor(bancor).protectedLiquidity(id)\n', '        if liquidity.reserveToken == yfi:\n', '            total += liquidity.reserveAmount\n', '    return total\n', '\n', '\n', '@view\n', '@internal\n', 'def _voting_balances(user: address) -> VotingBalances:\n', '    return VotingBalances({\n', '        wallet: ERC20(yfi).balanceOf(user),\n', '        vault: self.vault_balance(user),\n', '        bancor: self.yfi_in_bancor(user),\n', '        balancer: self.lp_balance(balancer, user),\n', '        uniswap: self.lp_balance(uniswap, user),\n', '        sushiswap: self.sushiswap_balance(user),\n', '        makerdao: self.makerdao_collateral(user),\n', '        unit: Unit(unit).collaterals(yfi, user),\n', '    })\n', '\n', '\n', '@view\n', '@external\n', 'def balanceOf(user: address) -> uint256:\n', '    bal: VotingBalances = self._voting_balances(user)\n', '    return (\n', '        bal.wallet\n', '        + bal.vault\n', '        + bal.bancor\n', '        + bal.balancer\n', '        + bal.uniswap\n', '        + bal.sushiswap\n', '        + bal.makerdao\n', '        + bal.unit\n', '    )\n', '\n', '\n', '@view\n', '@external\n', 'def voting_balances(user: address) -> VotingBalances:\n', '    return self._voting_balances(user)']