['// SPDX-License-Identifier: GPL-3.0\n', '\n', 'pragma solidity ^0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./OpenOraclePriceData.sol";\n', 'import "./ICompoundOracle.sol";\n', 'import "./PriceConfig.sol";\n', 'import "./UniswapConfig.sol";\n', '\n', '/// @title Oracle for Kine Protocol\n', '/// @author Kine Technology\n', 'contract KineOracle is PriceConfig {\n', '    struct Observation {\n', '        uint timestamp;\n', '        uint acc;\n', '    }\n', '\n', '    struct KineOracleConfig{\n', '        address reporter; // The reporter that signs the price\n', '        address kaptain; // The kine kaptain contract\n', '        address uniswapFactory; // The uniswap factory address\n', '        address wrappedETHAddress; // The WETH contract address\n', '        uint anchorToleranceMantissa; // The percentage tolerance that the reporter may deviate from the uniswap anchor\n', '        uint anchorPeriod; // The minimum amount of time required for the old uniswap price accumulator to be replaced\n', '    }\n', '\n', '    using FixedPoint for *;\n', '\n', '    /// @notice The Open Oracle Price Data contract\n', '    OpenOraclePriceData public immutable priceData;\n', '\n', '    /// @notice The Compound Oracle Price contract\n', '    ICompoundOracle public compoundOracle;\n', '\n', '    /// @notice The number of wei in 1 ETH\n', '    uint public constant ethBaseUnit = 1e18;\n', '\n', '    /// @notice A common scaling factor to maintain precision\n', '    uint public constant expScale = 1e18;\n', '\n', '    /// @notice The Open Oracle Reporter\n', '    address public reporter;\n', '\n', '    /// @notice The Kaptain contract address that steers the MCD price and kUSD minter\n', '    address public kaptain;\n', '\n', '    /// @notice The mcd last update timestamp\n', '    uint public mcdLastUpdatedAt;\n', '\n', '    /// @notice The highest ratio of the new price to the anchor price that will still trigger the price to be updated\n', '    uint public immutable upperBoundAnchorRatio;\n', '\n', '    /// @notice The lowest ratio of the new price to the anchor price that will still trigger the price to be updated\n', '    uint public immutable lowerBoundAnchorRatio;\n', '\n', '    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n', '    uint public immutable anchorPeriod;\n', '\n', '    /// @notice Official prices by symbol hash\n', '    mapping(bytes32 => uint) public prices;\n', '\n', '    /// @notice Circuit breaker for using anchor price oracle directly, ignoring reporter\n', '    bool public reporterInvalidated;\n', '\n', '    /// @notice The old observation for each symbolHash\n', '    mapping(bytes32 => Observation) public oldObservations;\n', '\n', '    /// @notice The new observation for each symbolHash\n', '    mapping(bytes32 => Observation) public newObservations;\n', '\n', '    /// @notice The event emitted when new prices are posted but the stored price is not updated due to the anchor\n', '    event PriceGuarded(string symbol, uint reporter, uint anchor);\n', '\n', '    /// @notice The event emitted when the stored price is updated\n', '    event PriceUpdated(string symbol, uint price);\n', '\n', '    /// @notice The event emitted when anchor price is updated\n', '    event AnchorPriceUpdated(string symbol, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\n', '\n', '    /// @notice The event emitted when the uniswap window changes\n', '    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n', '\n', '    /// @notice The event emitted when reporter invalidates itself\n', '    event ReporterInvalidated(address reporter);\n', '\n', '    /// @notice The event emitted when reporter is updated\n', '    event ReporterUpdated(address oldReporter, address newReporter);\n', '\n', '    /// @notice The event emitted when compound oracle is updated\n', '    event CompoundOracleUpdated(address fromAddress, address toAddress);\n', '\n', '    /// @notice The event emitted when Kaptain is updated\n', '    event KaptainUpdated(address fromAddress, address toAddress);\n', '\n', '    /// @notice The event emitted when new config added\n', '    event TokenConfigAdded(address kToken, address underlying, bytes32 symbolHash,\n', '        uint baseUnit, KPriceSource priceSource, uint fixedPrice, address uniswapMarket, bool isUniswapReversed);\n', '\n', '    /// @notice The event emitted when config removed\n', '    event TokenConfigRemoved(address kToken, address underlying, bytes32 symbolHash,\n', '        uint baseUnit, KPriceSource priceSource, uint fixedPrice, address uniswapMarket, bool isUniswapReversed);\n', '\n', '    bytes32 constant ethHash = keccak256(abi.encodePacked("ETH"));\n', '    bytes32 constant mcdHash = keccak256(abi.encodePacked("MCD"));\n', '    bytes32 constant rotateHash = keccak256(abi.encodePacked("rotate"));\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the Kaptain.\n', '     */\n', '    modifier onlyKaptain() {\n', '        require(kaptain == _msgSender(), "caller is not the Kaptain");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Construct a uniswap anchored view for a set of token configurations\n', '     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\n', '     * @param priceData_ The open oracle price data contract\n', '     * @param kineOracleConfig_ The configurations for kine oracle init\n', '     * @param configs The static token configurations which define what prices are supported and how\n', '     * @param compoundOracle_ The address of compound oracle\n', '     */\n', '    constructor(OpenOraclePriceData priceData_,\n', '        KineOracleConfig memory kineOracleConfig_,\n', '        KTokenConfig[] memory configs,\n', '        ICompoundOracle compoundOracle_) public {\n', '        priceData = priceData_;\n', '        reporter = kineOracleConfig_.reporter;\n', '        kaptain = kineOracleConfig_.kaptain;\n', '        uniswapFactory = kineOracleConfig_.uniswapFactory;\n', '        wrappedETHAddress = kineOracleConfig_.wrappedETHAddress;\n', '        anchorPeriod = kineOracleConfig_.anchorPeriod;\n', '        compoundOracle = compoundOracle_;\n', '        emit CompoundOracleUpdated(address(0), address(compoundOracle_));\n', '\n', '        uint anchorToleranceMantissa = kineOracleConfig_.anchorToleranceMantissa;\n', '        // Allow the tolerance to be whatever the deployer chooses, but prevent under/overflow (and prices from being 0)\n', '        upperBoundAnchorRatio = anchorToleranceMantissa > uint(-1) - 100e16 ? uint(-1) : 100e16 + anchorToleranceMantissa;\n', '        lowerBoundAnchorRatio = anchorToleranceMantissa < 100e16 ? 100e16 - anchorToleranceMantissa : 1;\n', '\n', '        for (uint i = 0; i < configs.length; i++) {\n', '            KTokenConfig memory config = configs[i];\n', '\n', '            // configuration integrity check\n', '            if(config.symbolHash != ethHash && config.priceSource == KPriceSource.REPORTER){\n', '                checkConfig(config);\n', '            }\n', '\n', '            kTokenConfigs.push(config);\n', '            emit TokenConfigAdded(config.kToken, config.underlying, config.symbolHash, config.baseUnit,\n', '                config.priceSource, config.fixedPrice, config.uniswapMarket, config.isUniswapReversed);\n', '\n', '            require(config.baseUnit > 0, "baseUnit must be greater than zero");\n', '            address uniswapMarket = config.uniswapMarket;\n', '            if (config.priceSource == KPriceSource.REPORTER || config.symbolHash == ethHash) {\n', '                require(uniswapMarket != address(0), "prices must have an anchor");\n', '                bytes32 symbolHash = config.symbolHash;\n', '                uint cumulativePrice = currentCumulativePrice(config);\n', '                oldObservations[symbolHash].timestamp = block.timestamp;\n', '                newObservations[symbolHash].timestamp = block.timestamp;\n', '                oldObservations[symbolHash].acc = cumulativePrice;\n', '                newObservations[symbolHash].acc = cumulativePrice;\n', '                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n', '            } else {\n', '                require(uniswapMarket == address(0), "only reported prices utilize an anchor");\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the official price for a symbol\n', '     * @param symbol The symbol to fetch the price of\n', '     * @return Price denominated in USD, with 6 decimals\n', '     */\n', '    function price(string memory symbol) external view returns (uint) {\n', '        KTokenConfig memory config = getKTokenConfigBySymbol(symbol);\n', '        // not kine configuration, redirect to compound oracle\n', '        if(config.underlying == address(0)){\n', '            return compoundOracle.price(symbol);\n', '        }\n', '        return priceInternal(config);\n', '    }\n', '\n', '    function priceInternal(KTokenConfig memory config) internal view returns (uint) {\n', '        if (config.priceSource == KPriceSource.KAPTAIN || config.priceSource == KPriceSource.REPORTER) {\n', '            return prices[config.symbolHash];\n', '        }\n', '        if (config.priceSource == KPriceSource.FIXED_USD) return config.fixedPrice;\n', '        if (config.priceSource == KPriceSource.FIXED_ETH) {\n', '            uint usdPerEth = prices[ethHash];\n', '            require(usdPerEth > 0, "ETH price not set, cannot convert to dollars");\n', '            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying price of a kToken\n', '     * @dev Implements the PriceOracle interface for Kine.\n', '     * @param kToken The kToken address for price retrieval\n', '     * @return Price denominated in USD, with 18 decimals, for the given kToken address\n', '     */\n', '    function getUnderlyingPrice(address kToken) external view returns (uint) {\n', '        // check if this is kinedPrice\n', '        KTokenConfig memory config = getKConfigByKToken(kToken);\n', '        // is not kine owned price token, fetch compound config and use cToken to get compound price\n', '        // ETH underlying is also address(0), so logic still works\n', '        if (config.underlying == address(0)) {\n', '            UniswapConfig.TokenConfig memory cConfig = compoundOracle.getTokenConfigBySymbolHash(config.symbolHash);\n', '            require(cConfig.cToken != address(0), "token config not found in compound");\n', '            return compoundOracle.getUnderlyingPrice(cConfig.cToken);\n', '        }\n', '\n', '        // Controller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n', '        // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\n', '        return mul(1e30, priceInternal(config)) / config.baseUnit;\n', '    }\n', '\n', '    /**\n', '     * @notice Post kine supported prices, and recalculate stored reporter price by comparing to anchor\n', '     * @dev only priceSource not configured as "COMPOUND"  will be stored in the view.\n', '     * @param messages The messages to post to the oracle\n', '     * @param signatures The signatures for the corresponding messages\n', '     * @param symbols The symbols to compare to anchor for authoritative reading\n', '     */\n', '    function postPrices(bytes[] calldata messages, bytes[] calldata signatures, string[] calldata symbols) external onlyKaptain{\n', '        require(messages.length == signatures.length, "messages and signatures must be 1:1");\n', '\n', '        // Save the prices\n', '        for (uint i = 0; i < messages.length; i++) {\n', '            priceData.put(messages[i], signatures[i]);\n', '        }\n', '\n', '        uint ethPrice = fetchEthPrice();\n', '\n', '        // Try to update the view storage\n', '        for (uint i = 0; i < symbols.length; i++) {\n', '            KTokenConfig memory config = getKTokenConfigBySymbol(symbols[i]);\n', '            require(config.symbolHash != mcdHash, "MCD price goes to postMcdPrice");\n', '            // skip for non-kine config, which should have valid underlying address\n', '            if(config.underlying != address(0)){\n', '                uint reporterPrice = priceData.getPrice(reporter, symbols[i]);\n', '                if(config.priceSource != KPriceSource.COMPOUND)\n', '                    postPriceInternal(symbols[i], ethPrice, config, reporterPrice);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev MCD price can only come from Kaptain\n', '     */\n', '    function postMcdPrice(uint mcdPrice) external onlyKaptain{\n', '        require(!reporterInvalidated, "reporter invalidated");\n', '        require(mcdPrice != 0, "MCD price cannot be 0");\n', '        mcdLastUpdatedAt = block.timestamp;\n', '        prices[mcdHash] = mcdPrice;\n', '        emit PriceUpdated("MCD", mcdPrice);\n', '    }\n', '\n', '    function postReporterOnlyPriceInternal(string memory symbol, KTokenConfig memory config, uint reporterPrice) internal {\n', '        require(!reporterInvalidated, "reporter invalidated");\n', '        require(reporterPrice != 0, "price cannot be 0");\n', '        prices[config.symbolHash] = reporterPrice;\n', '        emit PriceUpdated(symbol, reporterPrice);\n', '    }\n', '\n', '    function postPriceInternal(string memory symbol, uint ethPrice, KTokenConfig memory config, uint reporterPrice) internal {\n', '        require(config.priceSource == KPriceSource.REPORTER, "only reporter prices get posted");\n', '\n', '        uint anchorPrice;\n', '\n', '        if (config.symbolHash == ethHash) {\n', '            anchorPrice = ethPrice;\n', '        } else {\n', '            anchorPrice = fetchAnchorPrice(symbol, config, ethPrice);\n', '        }\n', '\n', '        if (reporterInvalidated) {\n', '            prices[config.symbolHash] = anchorPrice;\n', '            emit PriceUpdated(symbol, anchorPrice);\n', '        } else if (isWithinAnchor(reporterPrice, anchorPrice)) {\n', '            prices[config.symbolHash] = reporterPrice;\n', '            emit PriceUpdated(symbol, reporterPrice);\n', '        } else {\n', '            emit PriceGuarded(symbol, reporterPrice, anchorPrice);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Check if the reported price is within the range allowed by anchor ratio and anchor price from uniswap.\n', '     */\n', '    function isWithinAnchor(uint reporterPrice, uint anchorPrice) internal view returns (bool) {\n', '        if (reporterPrice > 0) {\n', '            uint anchorRatio = mul(reporterPrice, 100e16) / anchorPrice;\n', '            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/eth price accumulator from uniswap.\n', '     */\n', '    function currentCumulativePrice(KTokenConfig memory config) internal view returns (uint) {\n', '        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n', '        if (config.isUniswapReversed) {\n', '            return cumulativePrice1;\n', '        } else {\n', '            return cumulativePrice0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\n', '     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n', '     */\n', '    function fetchEthPrice() internal returns (uint) {\n', '        return fetchAnchorPrice("ETH", getKTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n', '     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n', '     */\n', '    function fetchAnchorPrice(string memory symbol, KTokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n', '        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n', '\n', '        // This should be impossible, but better safe than sorry\n', '        require(block.timestamp > oldTimestamp, "now must come after before");\n', '        uint timeElapsed = block.timestamp - oldTimestamp;\n', '\n', '        // Calculate uniswap time-weighted average price\n', '        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n', '        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n', '        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n', '        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\n', '        uint anchorPrice;\n', '\n', '        // Adjust rawUniswapPrice according to the units of the non-ETH asset\n', '        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n', '\n', '        // In the case of non-ETH tokens\n', '        // a. pokeWindowValues already handled uniswap reversed cases, so priceAverage will always be Token/ETH TWAP price.\n', '        // b. conversionFactor = ETH price * 1e6\n', '        // unscaledPriceMantissa = priceAverage(token/ETH TWAP price) * expScale * conversionFactor\n', '        // so ->\n', '        // anchorPrice = priceAverage * tokenBaseUnit / ethBaseUnit * ETH_price * 1e6\n', '        //             = priceAverage * conversionFactor * tokenBaseUnit / ethBaseUnit\n', '        //             = unscaledPriceMantissa / expScale * tokenBaseUnit / ethBaseUnit\n', '        anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\n', '\n', '        emit AnchorPriceUpdated(symbol, anchorPrice, oldTimestamp, block.timestamp);\n', '\n', '        return anchorPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Get time-weighted average prices for a token at the current timestamp.\n', '     *  Update new and old observations of lagging window if period elapsed.\n', '     */\n', '    function pokeWindowValues(KTokenConfig memory config) internal returns (uint, uint, uint) {\n', '        bytes32 symbolHash = config.symbolHash;\n', '        uint cumulativePrice = currentCumulativePrice(config);\n', '\n', '        Observation memory newObservation = newObservations[symbolHash];\n', '\n', '        // Update new and old observations if elapsed time is greater than or equal to anchor period\n', '        uint timeElapsed = block.timestamp - newObservation.timestamp;\n', '        if (timeElapsed >= anchorPeriod) {\n', '            oldObservations[symbolHash].timestamp = newObservation.timestamp;\n', '            oldObservations[symbolHash].acc = newObservation.acc;\n', '\n', '            newObservations[symbolHash].timestamp = block.timestamp;\n', '            newObservations[symbolHash].acc = cumulativePrice;\n', '            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n', '        }\n', '        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n', '    }\n', '\n', '    /**\n', '     * @notice Invalidate the reporter, and fall back to using anchor directly in all cases\n', '     * @dev Only the reporter may sign a message which allows it to invalidate itself.\n', '     *  To be used in cases of emergency, if the reporter thinks their key may be compromised.\n', '     * @param message The data that was presumably signed\n', '     * @param signature The fingerprint of the data + private key\n', '     */\n', '    function invalidateReporter(bytes memory message, bytes memory signature) external {\n', '        (string memory decodedMessage,) = abi.decode(message, (string, address));\n', '        require(keccak256(abi.encodePacked(decodedMessage)) == rotateHash, "invalid message must be \'rotate\'");\n', '        require(source(message, signature) == reporter, "invalidation message must come from the reporter");\n', '        if(!reporterInvalidated){\n', '            reporterInvalidated = true;\n', '            emit ReporterInvalidated(reporter);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Recovers the source address which signed a message\n', '     * @dev Comparing to a claimed address would add nothing,\n', '     *  as the caller could simply perform the recover and claim that address.\n', '     * @param message The data that was presumably signed\n', '     * @param signature The fingerprint of the data + private key\n', '     * @return The source address which signed the message, presumably\n', '     */\n', '    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n', '        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n', '        bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", keccak256(message)));\n', '        return ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    /// @dev Overflow proof multiplication\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) return 0;\n', '        uint c = a * b;\n', '        require(c / a == b, "multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev The admin function used to redirect to new compound oracle\n', '     */\n', '    function setCompoundOracle(address oracleAddress) public onlyOwner {\n', '        address oldCompoundOracle = address(compoundOracle);\n', '        compoundOracle = ICompoundOracle(oracleAddress);\n', '        emit CompoundOracleUpdated(oldCompoundOracle, oracleAddress);\n', '    }\n', '\n', '    /// @dev The admin function to add config for supporting more token prices\n', '    function addConfig(address kToken_, address underlying_, bytes32 symbolHash_, uint baseUnit_,\n', '        KPriceSource priceSource_, uint fixedPrice_, address uniswapMarket_, bool isUniswapReversed_) public onlyOwner {\n', '        KTokenConfig memory config =\n', '        KTokenConfig({\n', '        kToken: kToken_,\n', '        underlying: underlying_,\n', '        symbolHash: symbolHash_,\n', '        baseUnit: baseUnit_,\n', '        priceSource: priceSource_,\n', '        fixedPrice: fixedPrice_,\n', '        uniswapMarket: uniswapMarket_,\n', '        isUniswapReversed: isUniswapReversed_\n', '        });\n', '        require(config.baseUnit > 0, "baseUnit must be greater than zero");\n', '\n', '        // configuration integrity check\n', '        if(config.symbolHash != ethHash && config.priceSource == KPriceSource.REPORTER){\n', '            checkConfig(config);\n', '        }\n', '\n', '        address uniswapMarket = config.uniswapMarket;\n', '        if (config.priceSource == KPriceSource.REPORTER || config.symbolHash == ethHash) {\n', '            require(uniswapMarket != address(0), "prices must have an anchor");\n', '            bytes32 symbolHash = config.symbolHash;\n', '            uint cumulativePrice = currentCumulativePrice(config);\n', '            oldObservations[symbolHash].timestamp = block.timestamp;\n', '            newObservations[symbolHash].timestamp = block.timestamp;\n', '            oldObservations[symbolHash].acc = cumulativePrice;\n', '            newObservations[symbolHash].acc = cumulativePrice;\n', '            emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n', '        } else {\n', '            require(uniswapMarket == address(0), "only reported prices utilize an anchor");\n', '        }\n', '        kTokenConfigs.push(config);\n', '        emit TokenConfigAdded(config.kToken, config.underlying, config.symbolHash, config.baseUnit,\n', '            config.priceSource, config.fixedPrice, config.uniswapMarket, config.isUniswapReversed);\n', '    }\n', '\n', '    /// @dev The admin function to remove config by its kToken address\n', '    function removeConfigByKToken(address kToken) public onlyOwner {\n', '        uint index = getKConfigIndexByKToken(kToken);\n', '        if (index == uint(-1)) {\n', '            revert("not found");\n', '        }\n', '        KTokenConfig memory tmpConfig = kTokenConfigs[index];\n', '        kTokenConfigs[index] = kTokenConfigs[kTokenConfigs.length - 1];\n', '\n', '        // remove all token related information\n', '        delete oldObservations[tmpConfig.symbolHash];\n', '        delete newObservations[tmpConfig.symbolHash];\n', '        delete prices[tmpConfig.symbolHash];\n', '\n', '        kTokenConfigs.pop();\n', '        emit TokenConfigRemoved(tmpConfig.kToken, tmpConfig.underlying, tmpConfig.symbolHash, tmpConfig.baseUnit,\n', '            tmpConfig.priceSource, tmpConfig.fixedPrice, tmpConfig.uniswapMarket, tmpConfig.isUniswapReversed);\n', '    }\n', '\n', '    /**\n', '     * @dev The admin function to change price reporter\n', '     * This function will set the new price reporter and set the reporterInvalidated flag to false\n', '     */\n', '    function changeReporter(address reporter_) public onlyOwner{\n', '        require(reporter_ != reporter, "same reporter");\n', '        address oldReporter = reporter;\n', '        reporter = reporter_;\n', '        if(reporterInvalidated){\n', '            reporterInvalidated = false;\n', '        }\n', '        emit ReporterUpdated(oldReporter, reporter_);\n', '    }\n', '\n', '    /**\n', '     * @dev The admin function to change the kaptain contract address\n', '     */\n', '    function changeKaptain(address kaptain_) public onlyOwner{\n', '        require(kaptain != kaptain_, "same kaptain");\n', '        address oldKaptain = kaptain;\n', '        kaptain = kaptain_;\n', '        emit KaptainUpdated(oldKaptain, kaptain_);\n', '    }\n', '}']