['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-18\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '\n', '  function _msgData() internal view virtual returns (bytes memory) {\n', '    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '    return msg.data;\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/access/Ownable.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Initializes the contract setting the deployer as the initial owner.\n', '   */\n', '  constructor() {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Leaves the contract without owner. It will not be possible to call\n', '   * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '   *\n', '   * NOTE: Renouncing ownership will leave the contract without an owner,\n', '   * thereby removing any functionality that is only available to the owner.\n', '   */\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '  /**\n', '   * @dev Returns the amount of tokens in existence.\n', '   */\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the amount of tokens owned by `account`.\n', '   */\n', '  function balanceOf(address account) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Returns the remaining number of tokens that `spender` will be\n', '   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '   * zero by default.\n', '   *\n', '   * This value changes when {approve} or {transferFrom} are called.\n', '   */\n', '  function allowance(address owner, address spender)\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', "   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '   * that someone may use both the old and the new allowance by unfortunate\n', '   * transaction ordering. One possible solution to mitigate this race\n', "   * condition is to first reduce the spender's allowance to 0 and set the\n", '   * desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   * Emits an {Approval} event.\n', '   */\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "   * allowance mechanism. `amount` is then deducted from the caller's\n", '   * allowance.\n', '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transferFrom(\n', '    address sender,\n', '    address recipient,\n', '    uint256 amount\n', '  ) external returns (bool);\n', '\n', '  /**\n', '   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '   * another (`to`).\n', '   *\n', '   * Note that `value` may be zero.\n', '   */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '   * a call to {approve}. `value` is the new allowance.\n', '   */\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/library/SafeMath96.sol\n', '\n', 'pragma solidity ^0.7.1;\n', '\n', 'library SafeMath96 {\n', '  /**\n', '   * @dev Returns the addition of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `+` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Addition cannot overflow.\n', '   */\n', '  function add(uint96 a, uint96 b) internal pure returns (uint96) {\n', '    uint96 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(uint96 a, uint96 b) internal pure returns (uint96) {\n', '    return sub(a, b, "SafeMath: subtraction overflow");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    require(b <= a, errorMessage);\n', '    uint96 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the multiplication of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `*` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Multiplication cannot overflow.\n', '   */\n', '  function mul(uint96 a, uint96 b) internal pure returns (uint96) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint96 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(uint96 a, uint96 b) internal pure returns (uint96) {\n', '    return div(a, b, "SafeMath: division by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    require(b > 0, errorMessage);\n', '    uint96 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(uint96 a, uint96 b) internal pure returns (uint96) {\n', '    return mod(a, b, "SafeMath: modulo by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts with custom message when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// File: contracts/library/SafeCast96.sol\n', '\n', 'pragma solidity ^0.7.1;\n', '\n', 'library SafeCast96 {\n', '  function toUint96(uint256 value) internal pure returns (uint96) {\n', '    require(value < 2**96, "SafeCast: value doesn\'t fit in 96 bits");\n', '    return uint96(value);\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/SafeCast.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '  /**\n', '   * @dev Returns the downcasted uint128 from uint256, reverting on\n', '   * overflow (when the input is greater than largest uint128).\n', '   *\n', "   * Counterpart to Solidity's `uint128` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 128 bits\n', '   */\n', '  function toUint128(uint256 value) internal pure returns (uint128) {\n', '    require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits");\n', '    return uint128(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted uint64 from uint256, reverting on\n', '   * overflow (when the input is greater than largest uint64).\n', '   *\n', "   * Counterpart to Solidity's `uint64` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 64 bits\n', '   */\n', '  function toUint64(uint256 value) internal pure returns (uint64) {\n', '    require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits");\n', '    return uint64(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted uint32 from uint256, reverting on\n', '   * overflow (when the input is greater than largest uint32).\n', '   *\n', "   * Counterpart to Solidity's `uint32` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 32 bits\n', '   */\n', '  function toUint32(uint256 value) internal pure returns (uint32) {\n', '    require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits");\n', '    return uint32(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted uint16 from uint256, reverting on\n', '   * overflow (when the input is greater than largest uint16).\n', '   *\n', "   * Counterpart to Solidity's `uint16` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 16 bits\n', '   */\n', '  function toUint16(uint256 value) internal pure returns (uint16) {\n', '    require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits");\n', '    return uint16(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted uint8 from uint256, reverting on\n', '   * overflow (when the input is greater than largest uint8).\n', '   *\n', "   * Counterpart to Solidity's `uint8` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 8 bits.\n', '   */\n', '  function toUint8(uint256 value) internal pure returns (uint8) {\n', '    require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits");\n', '    return uint8(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Converts a signed int256 into an unsigned uint256.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - input must be greater than or equal to 0.\n', '   */\n', '  function toUint256(int256 value) internal pure returns (uint256) {\n', '    require(value >= 0, "SafeCast: value must be positive");\n', '    return uint256(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted int128 from int256, reverting on\n', '   * overflow (when the input is less than smallest int128 or\n', '   * greater than largest int128).\n', '   *\n', "   * Counterpart to Solidity's `int128` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 128 bits\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function toInt128(int256 value) internal pure returns (int128) {\n', '    require(\n', '      value >= -2**127 && value < 2**127,\n', '      "SafeCast: value doesn\'t fit in 128 bits"\n', '    );\n', '    return int128(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted int64 from int256, reverting on\n', '   * overflow (when the input is less than smallest int64 or\n', '   * greater than largest int64).\n', '   *\n', "   * Counterpart to Solidity's `int64` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 64 bits\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function toInt64(int256 value) internal pure returns (int64) {\n', '    require(\n', '      value >= -2**63 && value < 2**63,\n', '      "SafeCast: value doesn\'t fit in 64 bits"\n', '    );\n', '    return int64(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted int32 from int256, reverting on\n', '   * overflow (when the input is less than smallest int32 or\n', '   * greater than largest int32).\n', '   *\n', "   * Counterpart to Solidity's `int32` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 32 bits\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function toInt32(int256 value) internal pure returns (int32) {\n', '    require(\n', '      value >= -2**31 && value < 2**31,\n', '      "SafeCast: value doesn\'t fit in 32 bits"\n', '    );\n', '    return int32(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted int16 from int256, reverting on\n', '   * overflow (when the input is less than smallest int16 or\n', '   * greater than largest int16).\n', '   *\n', "   * Counterpart to Solidity's `int16` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 16 bits\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function toInt16(int256 value) internal pure returns (int16) {\n', '    require(\n', '      value >= -2**15 && value < 2**15,\n', '      "SafeCast: value doesn\'t fit in 16 bits"\n', '    );\n', '    return int16(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the downcasted int8 from int256, reverting on\n', '   * overflow (when the input is less than smallest int8 or\n', '   * greater than largest int8).\n', '   *\n', "   * Counterpart to Solidity's `int8` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - input must fit into 8 bits.\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function toInt8(int256 value) internal pure returns (int8) {\n', '    require(\n', '      value >= -2**7 && value < 2**7,\n', '      "SafeCast: value doesn\'t fit in 8 bits"\n', '    );\n', '    return int8(value);\n', '  }\n', '\n', '  /**\n', '   * @dev Converts an unsigned uint256 into a signed int256.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - input must be less than or equal to maxInt256.\n', '   */\n', '  function toInt256(uint256 value) internal pure returns (int256) {\n', '    require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '    return int256(value);\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '  /**\n', '   * @dev Returns the addition of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `+` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Addition cannot overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return sub(a, b, "SafeMath: subtraction overflow");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b <= a, errorMessage);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the multiplication of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `*` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Multiplication cannot overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return div(a, b, "SafeMath: division by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return mod(a, b, "SafeMath: modulo by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts with custom message when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// File: contracts/Interfaces/BaseUniswapV3.sol\n', '\n', 'pragma solidity ^0.7.1;\n', '\n', 'library BaseUniswapV3 {\n', '  struct MintParams {\n', '    address token0;\n', '    address token1;\n', '    uint24 fee;\n', '    int24 tickLower;\n', '    int24 tickUpper;\n', '    uint256 amount0Desired;\n', '    uint256 amount1Desired;\n', '    uint256 amount0Min;\n', '    uint256 amount1Min;\n', '    address recipient;\n', '    uint256 deadline;\n', '  }\n', '\n', '  struct DecreaseLiquidityParams {\n', '    uint256 tokenId;\n', '    uint128 liquidity;\n', '    uint256 amount0Min;\n', '    uint256 amount1Min;\n', '    uint256 deadline;\n', '  }\n', '\n', '  struct CollectParams {\n', '    uint256 tokenId;\n', '    address recipient;\n', '    uint128 amount0Max;\n', '    uint128 amount1Max;\n', '  }\n', '}\n', '\n', '// File: contracts/Interfaces/LiquidityManagementInterface.sol\n', '\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface LiquidityManagementInterface {\n', '  /// @notice Returns the position information associated with a given token ID.\n', '  /// @dev Throws if the token ID is not valid.\n', '  /// @param tokenId The ID of the token that represents the position\n', '  /// @return nonce The nonce for permits\n', '  /// @return operator The address that is approved for spending\n', '  /// @return token0 The address of the token0 for a specific pool\n', '  /// @return token1 The address of the token1 for a specific pool\n', '  /// @return fee The fee associated with the pool\n', '  /// @return tickLower The lower end of the tick range for the position\n', '  /// @return tickUpper The higher end of the tick range for the position\n', '  /// @return liquidity The liquidity of the position\n', '  /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n', '  /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n', '  /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n', '  /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n', '  function positions(uint256 tokenId)\n', '    external\n', '    view\n', '    returns (\n', '      uint96 nonce,\n', '      address operator,\n', '      address token0,\n', '      address token1,\n', '      uint24 fee,\n', '      int24 tickLower,\n', '      int24 tickUpper,\n', '      uint128 liquidity,\n', '      uint256 feeGrowthInside0LastX128,\n', '      uint256 feeGrowthInside1LastX128,\n', '      uint128 tokensOwed0,\n', '      uint128 tokensOwed1\n', '    );\n', '\n', '  /// @notice Creates a new position wrapped in a NFT\n', '  /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n', '  /// a method does not exist, i.e. the pool is assumed to be initialized.\n', '  /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n', '  /// @return tokenId The ID of the token that represents the minted position\n', '  /// @return liquidity The amount of liquidity for this position\n', '  /// @return amount0 The amount of token0\n', '  /// @return amount1 The amount of token1\n', '  function mint(BaseUniswapV3.MintParams calldata params)\n', '    external\n', '    payable\n', '    returns (\n', '      uint256 tokenId,\n', '      uint128 liquidity,\n', '      uint256 amount0,\n', '      uint256 amount1\n', '    );\n', '\n', '  /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n', '  /// @param params tokenId The ID of the token for which liquidity is being decreased,\n', '  /// amount The amount by which liquidity will be decreased,\n', '  /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n', '  /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n', '  /// deadline The time by which the transaction must be included to effect the change\n', "  /// @return amount0 The amount of token0 accounted to the position's tokens owed\n", "  /// @return amount1 The amount of token1 accounted to the position's tokens owed\n", '  function decreaseLiquidity(\n', '    BaseUniswapV3.DecreaseLiquidityParams calldata params\n', '  ) external payable returns (uint256 amount0, uint256 amount1);\n', '\n', '  function collect(BaseUniswapV3.CollectParams calldata params)\n', '    external\n', '    payable\n', '    returns (uint256 amount0, uint256 amount1);\n', '}\n', '\n', '// File: contracts/Interfaces/CalculatorInterface.sol\n', '\n', 'pragma solidity ^0.7.1;\n', '\n', 'interface DogeV3CalculatorInterface {\n', '  function newTicks(\n', '    int24 currentTick,\n', '    int24 startTick,\n', '    int24 endTick,\n', '    int24 denominator,\n', '    uint32 startTimestamp\n', '  )\n', '    external\n', '    view\n', '    returns (\n', '      int24 upperTick,\n', '      int24 lowerTick,\n', '      bool isSafeIncrement\n', '    );\n', '\n', '  function setInitialTicks(int24 currentTick, int24 denominator)\n', '    external\n', '    view\n', '    returns (int24 upperTick, int24 lowerTick);\n', '\n', '  function getCurrentLiquidity(\n', '    uint160 sqrtRatioX96,\n', '    int24 upperTick,\n', '    int24 lowerTick,\n', '    uint256 amount0,\n', '    uint256 amount1\n', '  ) external pure returns (uint128 fullLiquidity, uint128 limitedLiquidity);\n', '\n', '  function ratioE8() external view returns (uint64);\n', '\n', '  function getPriceE8FromSQRTPrice(uint160 sqrtPriceX96)\n', '    external\n', '    pure\n', '    returns (uint256 priceE8);\n', '\n', '  function getPriceE8FromTick(int24 tick)\n', '    external\n', '    pure\n', '    returns (uint256 priceE8);\n', '\n', '  function roundDown(int24 tick, int24 denominator)\n', '    external\n', '    pure\n', '    returns (int24 ans);\n', '\n', '  function getTickFromSQRTPrice(uint160 sqrtPriceX96)\n', '    external\n', '    pure\n', '    returns (int24);\n', '\n', '  function getDifference() external view returns (int24 tickDifference);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n', '  /// @return The contract address\n', '  function factory() external view returns (address);\n', '\n', '  /// @notice The first of the two tokens of the pool, sorted by address\n', '  /// @return The token contract address\n', '  function token0() external view returns (address);\n', '\n', '  /// @notice The second of the two tokens of the pool, sorted by address\n', '  /// @return The token contract address\n', '  function token1() external view returns (address);\n', '\n', "  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n", '  /// @return The fee\n', '  function fee() external view returns (uint24);\n', '\n', '  /// @notice The pool tick spacing\n', '  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '  /// This value is an int24 to avoid casting even though it is always positive.\n', '  /// @return The tick spacing\n', '  function tickSpacing() external view returns (int24);\n', '\n', '  /// @notice The maximum amount of position liquidity that can use any tick in the range\n', '  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n', '  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n', '  /// @return The max amount of liquidity per tick\n', '  function maxLiquidityPerTick() external view returns (uint128);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that can change\n', "/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n", '/// per transaction\n', 'interface IUniswapV3PoolState {\n', '  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n', '  /// when accessed externally.\n', '  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n', '  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n', '  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n', '  /// boundary.\n', '  /// observationIndex The index of the last oracle observation that was written,\n', '  /// observationCardinality The current maximum number of observations stored in the pool,\n', '  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n', '  /// feeProtocol The protocol fee for both tokens of the pool.\n', '  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n', '  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n', '  /// unlocked Whether the pool is currently locked to reentrancy\n', '  function slot0()\n', '    external\n', '    view\n', '    returns (\n', '      uint160 sqrtPriceX96,\n', '      int24 tick,\n', '      uint16 observationIndex,\n', '      uint16 observationCardinality,\n', '      uint16 observationCardinalityNext,\n', '      uint8 feeProtocol,\n', '      bool unlocked\n', '    );\n', '\n', '  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n', '  /// @dev This value can overflow the uint256\n', '  function feeGrowthGlobal0X128() external view returns (uint256);\n', '\n', '  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n', '  /// @dev This value can overflow the uint256\n', '  function feeGrowthGlobal1X128() external view returns (uint256);\n', '\n', '  /// @notice The amounts of token0 and token1 that are owed to the protocol\n', '  /// @dev Protocol fees will never exceed uint128 max in either token\n', '  function protocolFees()\n', '    external\n', '    view\n', '    returns (uint128 token0, uint128 token1);\n', '\n', '  /// @notice The currently in range liquidity available to the pool\n', '  /// @dev This value has no relationship to the total liquidity across all ticks\n', '  function liquidity() external view returns (uint128);\n', '\n', '  /// @notice Look up information about a specific tick in the pool\n', '  /// @param tick The tick to look up\n', '  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n', '  /// tick upper,\n', '  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n', '  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n', '  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n', '  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n', '  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n', '  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n', '  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n', '  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n', '  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n', '  /// a specific position.\n', '  function ticks(int24 tick)\n', '    external\n', '    view\n', '    returns (\n', '      uint128 liquidityGross,\n', '      int128 liquidityNet,\n', '      uint256 feeGrowthOutside0X128,\n', '      uint256 feeGrowthOutside1X128,\n', '      int56 tickCumulativeOutside,\n', '      uint160 secondsPerLiquidityOutsideX128,\n', '      uint32 secondsOutside,\n', '      bool initialized\n', '    );\n', '\n', '  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n', '  function tickBitmap(int16 wordPosition) external view returns (uint256);\n', '\n', "  /// @notice Returns the information about a position by the position's key\n", "  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n", '  /// @return _liquidity The amount of liquidity in the position,\n', '  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n', '  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n', '  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n', '  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n', '  function positions(bytes32 key)\n', '    external\n', '    view\n', '    returns (\n', '      uint128 _liquidity,\n', '      uint256 feeGrowthInside0LastX128,\n', '      uint256 feeGrowthInside1LastX128,\n', '      uint128 tokensOwed0,\n', '      uint128 tokensOwed1\n', '    );\n', '\n', '  /// @notice Returns data about a specific observation index\n', '  /// @param index The element of the observations array to fetch\n', '  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n', '  /// ago, rather than at a specific index in the array.\n', '  /// @return blockTimestamp The timestamp of the observation,\n', '  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n', '  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n', '  /// Returns initialized whether the observation has been initialized and the values are safe to use\n', '  function observations(uint256 index)\n', '    external\n', '    view\n', '    returns (\n', '      uint32 blockTimestamp,\n', '      int56 tickCumulative,\n', '      uint160 secondsPerLiquidityCumulativeX128,\n', '      bool initialized\n', '    );\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '  /// you must call it with secondsAgos = [3600, 0].\n', '  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '  /// timestamp\n', '  function observe(uint32[] calldata secondsAgos)\n', '    external\n', '    view\n', '    returns (\n', '      int56[] memory tickCumulatives,\n', '      uint160[] memory secondsPerLiquidityCumulativeX128s\n', '    );\n', '\n', '  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n', '  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n', '  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n', '  /// snapshot is taken and the second snapshot is taken.\n', '  /// @param tickLower The lower tick of the range\n', '  /// @param tickUpper The upper tick of the range\n', '  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n', '  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n', '  /// @return secondsInside The snapshot of seconds per liquidity for the range\n', '  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n', '    external\n', '    view\n', '    returns (\n', '      int56 tickCumulativeInside,\n', '      uint160 secondsPerLiquidityInsideX128,\n', '      uint32 secondsInside\n', '    );\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissionless pool actions\n', '/// @notice Contains pool methods that can be called by anyone\n', 'interface IUniswapV3PoolActions {\n', '  /// @notice Sets the initial price for the pool\n', '  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n', '  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n', '  function initialize(uint160 sqrtPriceX96) external;\n', '\n', '  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n', '  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n', '  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n', '  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n', '  /// @param recipient The address for which the liquidity will be created\n', '  /// @param tickLower The lower tick of the position in which to add liquidity\n', '  /// @param tickUpper The upper tick of the position in which to add liquidity\n', '  /// @param amount The amount of liquidity to mint\n', '  /// @param data Any data that should be passed through to the callback\n', '  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '  function mint(\n', '    address recipient,\n', '    int24 tickLower,\n', '    int24 tickUpper,\n', '    uint128 amount,\n', '    bytes calldata data\n', '  ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '  /// @notice Collects tokens owed to a position\n', '  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n', '  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n', '  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n', '  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n', '  /// @param recipient The address which should receive the fees collected\n', '  /// @param tickLower The lower tick of the position for which to collect fees\n', '  /// @param tickUpper The upper tick of the position for which to collect fees\n', '  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n', '  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n', '  /// @return amount0 The amount of fees collected in token0\n', '  /// @return amount1 The amount of fees collected in token1\n', '  function collect(\n', '    address recipient,\n', '    int24 tickLower,\n', '    int24 tickUpper,\n', '    uint128 amount0Requested,\n', '    uint128 amount1Requested\n', '  ) external returns (uint128 amount0, uint128 amount1);\n', '\n', '  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n', '  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n', '  /// @dev Fees must be collected separately via a call to #collect\n', '  /// @param tickLower The lower tick of the position for which to burn liquidity\n', '  /// @param tickUpper The upper tick of the position for which to burn liquidity\n', '  /// @param amount How much liquidity to burn\n', '  /// @return amount0 The amount of token0 sent to the recipient\n', '  /// @return amount1 The amount of token1 sent to the recipient\n', '  function burn(\n', '    int24 tickLower,\n', '    int24 tickUpper,\n', '    uint128 amount\n', '  ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '  /// @notice Swap token0 for token1, or token1 for token0\n', '  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n', '  /// @param recipient The address to receive the output of the swap\n', '  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n', '  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n', '  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n', '  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n', '  /// @param data Any data to be passed through to the callback\n', '  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n', '  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n', '  function swap(\n', '    address recipient,\n', '    bool zeroForOne,\n', '    int256 amountSpecified,\n', '    uint160 sqrtPriceLimitX96,\n', '    bytes calldata data\n', '  ) external returns (int256 amount0, int256 amount1);\n', '\n', '  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n', '  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n', '  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n', '  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n', '  /// @param recipient The address which will receive the token0 and token1 amounts\n', '  /// @param amount0 The amount of token0 to send\n', '  /// @param amount1 The amount of token1 to send\n', '  /// @param data Any data to be passed through to the callback\n', '  function flash(\n', '    address recipient,\n', '    uint256 amount0,\n', '    uint256 amount1,\n', '    bytes calldata data\n', '  ) external;\n', '\n', '  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n', '  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n', '  /// the input observationCardinalityNext.\n', '  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n', '  function increaseObservationCardinalityNext(uint16 observationCardinalityNext)\n', '    external;\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissioned pool actions\n', '/// @notice Contains pool methods that may only be called by the factory owner\n', 'interface IUniswapV3PoolOwnerActions {\n', "  /// @notice Set the denominator of the protocol's % share of the fees\n", '  /// @param feeProtocol0 new protocol fee for token0 of the pool\n', '  /// @param feeProtocol1 new protocol fee for token1 of the pool\n', '  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n', '\n', '  /// @notice Collect the protocol fee accrued to the pool\n', '  /// @param recipient The address to which collected protocol fees should be sent\n', '  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n', '  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n', '  /// @return amount0 The protocol fee collected in token0\n', '  /// @return amount1 The protocol fee collected in token1\n', '  function collectProtocol(\n', '    address recipient,\n', '    uint128 amount0Requested,\n', '    uint128 amount1Requested\n', '  ) external returns (uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Events emitted by a pool\n', '/// @notice Contains all events emitted by the pool\n', 'interface IUniswapV3PoolEvents {\n', '  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n', '  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n', '  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n', '  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n', '  event Initialize(uint160 sqrtPriceX96, int24 tick);\n', '\n', '  /// @notice Emitted when liquidity is minted for a given position\n', '  /// @param sender The address that minted the liquidity\n', '  /// @param owner The owner of the position and recipient of any minted liquidity\n', '  /// @param tickLower The lower tick of the position\n', '  /// @param tickUpper The upper tick of the position\n', '  /// @param amount The amount of liquidity minted to the position range\n', '  /// @param amount0 How much token0 was required for the minted liquidity\n', '  /// @param amount1 How much token1 was required for the minted liquidity\n', '  event Mint(\n', '    address sender,\n', '    address indexed owner,\n', '    int24 indexed tickLower,\n', '    int24 indexed tickUpper,\n', '    uint128 amount,\n', '    uint256 amount0,\n', '    uint256 amount1\n', '  );\n', '\n', '  /// @notice Emitted when fees are collected by the owner of a position\n', '  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n', '  /// @param owner The owner of the position for which fees are collected\n', '  /// @param tickLower The lower tick of the position\n', '  /// @param tickUpper The upper tick of the position\n', '  /// @param amount0 The amount of token0 fees collected\n', '  /// @param amount1 The amount of token1 fees collected\n', '  event Collect(\n', '    address indexed owner,\n', '    address recipient,\n', '    int24 indexed tickLower,\n', '    int24 indexed tickUpper,\n', '    uint128 amount0,\n', '    uint128 amount1\n', '  );\n', '\n', "  /// @notice Emitted when a position's liquidity is removed\n", '  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n', '  /// @param owner The owner of the position for which liquidity is removed\n', '  /// @param tickLower The lower tick of the position\n', '  /// @param tickUpper The upper tick of the position\n', '  /// @param amount The amount of liquidity to remove\n', '  /// @param amount0 The amount of token0 withdrawn\n', '  /// @param amount1 The amount of token1 withdrawn\n', '  event Burn(\n', '    address indexed owner,\n', '    int24 indexed tickLower,\n', '    int24 indexed tickUpper,\n', '    uint128 amount,\n', '    uint256 amount0,\n', '    uint256 amount1\n', '  );\n', '\n', '  /// @notice Emitted by the pool for any swaps between token0 and token1\n', '  /// @param sender The address that initiated the swap call, and that received the callback\n', '  /// @param recipient The address that received the output of the swap\n', '  /// @param amount0 The delta of the token0 balance of the pool\n', '  /// @param amount1 The delta of the token1 balance of the pool\n', '  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n', '  /// @param liquidity The liquidity of the pool after the swap\n', '  /// @param tick The log base 1.0001 of price of the pool after the swap\n', '  event Swap(\n', '    address indexed sender,\n', '    address indexed recipient,\n', '    int256 amount0,\n', '    int256 amount1,\n', '    uint160 sqrtPriceX96,\n', '    uint128 liquidity,\n', '    int24 tick\n', '  );\n', '\n', '  /// @notice Emitted by the pool for any flashes of token0/token1\n', '  /// @param sender The address that initiated the swap call, and that received the callback\n', '  /// @param recipient The address that received the tokens from flash\n', '  /// @param amount0 The amount of token0 that was flashed\n', '  /// @param amount1 The amount of token1 that was flashed\n', '  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n', '  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n', '  event Flash(\n', '    address indexed sender,\n', '    address indexed recipient,\n', '    uint256 amount0,\n', '    uint256 amount1,\n', '    uint256 paid0,\n', '    uint256 paid1\n', '  );\n', '\n', '  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n', '  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n', '  /// just before a mint/swap/burn.\n', '  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n', '  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n', '  event IncreaseObservationCardinalityNext(\n', '    uint16 observationCardinalityNextOld,\n', '    uint16 observationCardinalityNextNew\n', '  );\n', '\n', '  /// @notice Emitted when the protocol fee is changed by the pool\n', '  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n', '  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n', '  /// @param feeProtocol0New The updated value of the token0 protocol fee\n', '  /// @param feeProtocol1New The updated value of the token1 protocol fee\n', '  event SetFeeProtocol(\n', '    uint8 feeProtocol0Old,\n', '    uint8 feeProtocol1Old,\n', '    uint8 feeProtocol0New,\n', '    uint8 feeProtocol1New\n', '  );\n', '\n', '  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n', '  /// @param sender The address that collects the protocol fees\n', '  /// @param recipient The address that receives the collected protocol fees\n', '  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n', '  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n', '  event CollectProtocol(\n', '    address indexed sender,\n', '    address indexed recipient,\n', '    uint128 amount0,\n', '    uint128 amount1\n', '  );\n', '}\n', '\n', '// File: @uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title The interface for a Uniswap V3 Pool\n', '/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '/// to the ERC20 specification\n', '/// @dev The pool interface is broken up into many smaller pieces\n', 'interface IUniswapV3Pool is\n', '  IUniswapV3PoolImmutables,\n', '  IUniswapV3PoolState,\n', '  IUniswapV3PoolDerivedState,\n', '  IUniswapV3PoolActions,\n', '  IUniswapV3PoolOwnerActions,\n', '  IUniswapV3PoolEvents\n', '{\n', '\n', '}\n', '\n', '// File: contracts/Interfaces/DogeV3Interface.sol\n', '\n', 'pragma solidity 0.7.1;\n', '\n', 'interface DogeV3Interface {\n', '  /*\n', '  function getNFTInfo(uint16 stageID)\n', '    external\n', '    view\n', '    returns (\n', '      uint96 nonce,\n', '      address operator,\n', '      address token0,\n', '      address token1,\n', '      uint24 fee,\n', '      int24 tickLower,\n', '      int24 tickUpper,\n', '      uint128 liquidity,\n', '      uint256 feeGrowthInside0LastX128,\n', '      uint256 feeGrowthInside1LastX128,\n', '      uint128 tokensOwed0,\n', '      uint128 tokensOwed1\n', '    );\n', '*/\n', '\n', '  function currentStage() external view returns (uint16);\n', '\n', '  function incrementStage() external;\n', '\n', '  function changeCalculator(DogeV3CalculatorInterface newCalc) external;\n', '\n', '  function depositFirstStage(uint256 amount, IUniswapV3Pool _swap) external;\n', '\n', '  function getSwapInfo()\n', '    external\n', '    view\n', '    returns (int24 tick, address swapAddress);\n', '\n', '  function isReversedSwap() external view returns (bool);\n', '\n', '  function getStageInfo(uint16 stageID)\n', '    external\n', '    view\n', '    returns (\n', '      bool isReversedSwap,\n', '      int24 upterTick,\n', '      int24 lowerTick,\n', '      uint32 startTimestamp,\n', '      uint128 tokenId,\n', '      uint128 tokenId2\n', '    );\n', '\n', '  function isUpgradable() external view returns (bool upgradable);\n', '\n', '  function currentStatus()\n', '    external\n', '    view\n', '    returns (\n', '      uint16 currentStageId,\n', '      uint32 startTimestamp,\n', '      uint128 tokenId,\n', '      uint128 tokenId2,\n', '      uint256 upperPrice,\n', '      uint256 lowerPrice,\n', '      uint256 currentPrice\n', '    );\n', '}\n', '\n', '// File: contracts/DogeV3.sol\n', '\n', 'pragma solidity 0.7.1;\n', '\n', 'contract DogeV3 is Ownable, DogeV3Interface, IERC20 {\n', '  using SafeMath96 for uint96;\n', '  using SafeCast96 for uint256;\n', '  using SafeCast for uint256;\n', '  using SafeMath for uint256;\n', '  enum LEGENDS { VITALIK, UNISWAP_DEPLOYER, NONE }\n', '  struct Balance {\n', '    uint96 balance;\n', '    bool getBonusFromVitalik;\n', '    bool getBonusFromUniswapDeployer;\n', '  }\n', '\n', '  struct StageInfo {\n', '    int24 upperTick;\n', '    int24 lowerTick;\n', '    uint32 startTimestamp;\n', '    uint96 tokenId;\n', '    uint96 tokenId2;\n', '  }\n', '\n', '  uint96 public constant BonusAmount = 15000 * 10**8;\n', '\n', '  uint16 public override currentStage;\n', '  bool isGameContinuing = true;\n', '  mapping(address => Balance) public balance;\n', '  mapping(uint16 => StageInfo) public stage;\n', '  mapping(address => mapping(address => uint96)) private _allowances;\n', '  mapping(LEGENDS => bool) public isAcceptedByLegend;\n', '  mapping(LEGENDS => address) public addresses;\n', '\n', '  uint96 constant _totalSupply = 13 * 10**18;\n', '  uint96 public constant donateAmount = 200000000 * 10**8;\n', '  LiquidityManagementInterface public immutable LiquidityManager;\n', '  IERC20 public immutable pair;\n', '  DogeV3CalculatorInterface public calcs;\n', '  IUniswapV3Pool public swap;\n', '\n', '  uint8 public constant decimals = 8;\n', '  uint96 public circulatingSupply;\n', '  string public constant name = "DogeV3";\n', '  string public constant symbol = "DOGEV3";\n', '\n', '  address public immutable IndiaCovid;\n', '  bool internal isReversed;\n', '\n', '  event StageIncrement(\n', '    uint16 newStage,\n', '    int24 nextUpperTick,\n', '    int24 nextLowerTick,\n', '    bool isSeccess\n', '  );\n', '  event LegendAccepted(LEGENDS indexed Legend);\n', '  event GetBonusFromLegends(address indexed recipient, LEGENDS Legend);\n', '  event CheerForIndia(LEGENDS indexed Legend, uint96 amount);\n', '\n', '  modifier onlyLegends() {\n', '    require(isLegend(msg.sender), "ERROR: You are not legend");\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    LiquidityManagementInterface _LiquidityManager,\n', '    address vitalik,\n', '    address deployer,\n', '    address indiaCovid,\n', '    IERC20 _pair,\n', '    DogeV3CalculatorInterface _calcs\n', '  ) {\n', '    LiquidityManager = _LiquidityManager;\n', '    pair = _pair;\n', '    addresses[LEGENDS.VITALIK] = vitalik;\n', '    addresses[LEGENDS.UNISWAP_DEPLOYER] = deployer;\n', '    IndiaCovid = indiaCovid;\n', '    balance[address(this)].balance = _totalSupply - 10**12;\n', '    balance[msg.sender].balance = 10**12;\n', '    calcs = _calcs;\n', '    if (address(this) > address(_pair)) {\n', '      isReversed = true;\n', '    }\n', '  }\n', '\n', '  function totalSupply() public pure override returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  function depositFirstStage(uint256 amount, IUniswapV3Pool _swap)\n', '    external\n', '    override\n', '    onlyOwner\n', '  {\n', '    uint96 beforeBalance = balance[address(this)].balance;\n', '    require(address(swap) == address(0), "Invalid swap Address");\n', '    swap = _swap;\n', '    (, int24 tick, , , , , ) = swap.slot0();\n', '    (int24 upperTick, int24 lowerTick) =\n', '      calcs.setInitialTicks(tick, _swap.tickSpacing());\n', '    require(\n', '      pair.transferFrom(msg.sender, address(this), amount),\n', '      "Cannot transfer WETH"\n', '    );\n', '    IERC20(address(this)).approve(address(LiquidityManager), uint96(-1));\n', '    pair.approve(address(LiquidityManager), uint256(-1));\n', '    (uint256 tokenId, , , ) =\n', '      LiquidityManager.mint(\n', '        _getMintParams(\n', '          upperTick,\n', '          lowerTick,\n', '          balance[address(this)].balance,\n', '          (amount * 9) / 10\n', '        )\n', '      );\n', '    LiquidityManager.mint(\n', '      _getMintParams(\n', '        887220,\n', '        -887220,\n', '        balance[address(this)].balance,\n', '        (amount * 1) / 10\n', '      )\n', '    );\n', '    uint96 afterBalance = balance[address(this)].balance;\n', '    int96 balanceDiff = int96(beforeBalance) - int96(afterBalance);\n', '    if (balanceDiff < 0) {\n', '      circulatingSupply -= uint96(-1 * balanceDiff);\n', '    } else {\n', '      circulatingSupply += uint96(balanceDiff);\n', '    }\n', '    stage[1] = StageInfo(\n', '      upperTick,\n', '      lowerTick,\n', '      block.timestamp.toUint32(),\n', '      uint96(tokenId),\n', '      0\n', '    );\n', '    currentStage = 1;\n', '  }\n', '\n', '  function changeCalculator(DogeV3CalculatorInterface newCalc)\n', '    public\n', '    override\n', '    onlyOwner\n', '  {\n', '    calcs = newCalc;\n', '  }\n', '\n', '  function acceptByLegend() external onlyLegends {\n', '    LEGENDS legendName = LegendToAddress(msg.sender);\n', '    require(!isAcceptedByLegend[legendName], "Already Accepted");\n', '    isAcceptedByLegend[legendName] = true;\n', '    _transfer(address(this), IndiaCovid, donateAmount);\n', '    emit LegendAccepted(legendName);\n', '    emit CheerForIndia(legendName, donateAmount);\n', '  }\n', '\n', '  function getBonusFromLegend() external returns (uint96 bonusAmount) {\n', '    require(balance[msg.sender].balance != 0, "ERROR: You have no DOGEV3");\n', '    Balance memory recipient = balance[msg.sender];\n', '    if (!recipient.getBonusFromVitalik && isAcceptedByLegend[LEGENDS.VITALIK]) {\n', '      bonusAmount += BonusAmount;\n', '      recipient.getBonusFromVitalik = true;\n', '      emit GetBonusFromLegends(msg.sender, LEGENDS.VITALIK);\n', '    }\n', '\n', '    if (\n', '      !recipient.getBonusFromUniswapDeployer &&\n', '      isAcceptedByLegend[LEGENDS.UNISWAP_DEPLOYER]\n', '    ) {\n', '      bonusAmount += BonusAmount;\n', '      recipient.getBonusFromUniswapDeployer = true;\n', '      emit GetBonusFromLegends(msg.sender, LEGENDS.UNISWAP_DEPLOYER);\n', '    }\n', '\n', '    require(\n', '      _transfer(address(this), msg.sender, bonusAmount),\n', '      "Bonus Transfer failed"\n', '    );\n', '  }\n', '\n', '  function checkTokenMove(Balance memory sender, Balance memory recipient)\n', '    public\n', '    pure\n', '    returns (Balance memory)\n', '  {\n', '    if (sender.getBonusFromVitalik) {\n', '      recipient.getBonusFromVitalik = true;\n', '    }\n', '    if (sender.getBonusFromUniswapDeployer) {\n', '      recipient.getBonusFromUniswapDeployer = true;\n', '    }\n', '    return recipient;\n', '  }\n', '\n', '  function transfer(address to, uint256 value)\n', '    external\n', '    override\n', '    returns (bool)\n', '  {\n', '    return _transfer(msg.sender, to, value);\n', '  }\n', '\n', '  function LegendToAddress(address legendAddress)\n', '    public\n', '    view\n', '    returns (LEGENDS)\n', '  {\n', '    if (legendAddress == addresses[LEGENDS.VITALIK]) {\n', '      return LEGENDS.VITALIK;\n', '    } else if (legendAddress == addresses[LEGENDS.UNISWAP_DEPLOYER]) {\n', '      return LEGENDS.UNISWAP_DEPLOYER;\n', '    }\n', '    return LEGENDS.NONE;\n', '  }\n', '\n', '  function transferFrom(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  ) external override returns (bool) {\n', '    _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(\n', '      value.toUint96()\n', '    );\n', '    return _transfer(from, to, value);\n', '  }\n', '\n', '  function approve(address to, uint256 value) external override returns (bool) {\n', '    if (value > uint96(-1)) {\n', '      value = uint96(-1);\n', '    }\n', '    _allowances[msg.sender][to] = value.toUint96();\n', '    emit Approval(msg.sender, to, value);\n', '    return true;\n', '  }\n', '\n', '  function balanceOf(address account) external view override returns (uint256) {\n', '    return (balance[account].balance);\n', '  }\n', '\n', '  function allowance(address owner, address spender)\n', '    external\n', '    view\n', '    override\n', '    returns (uint256)\n', '  {\n', '    return _allowances[owner][spender];\n', '  }\n', '\n', '  function incrementStage() external override {\n', '    int24 tick;\n', '    {\n', '      (uint160 price, , , , , , ) = swap.slot0();\n', '      tick = calcs.getTickFromSQRTPrice(price);\n', '    }\n', '    StageInfo memory stageInfo = stage[currentStage];\n', '    int24 spacing = swap.tickSpacing();\n', '    (int24 upperTick, int24 lowerTick, bool isSafeIncrement) =\n', '      calcs.newTicks(\n', '        tick,\n', '        stageInfo.upperTick,\n', '        stageInfo.lowerTick,\n', '        spacing,\n', '        stageInfo.startTimestamp\n', '      );\n', '    require(isSafeIncrement, "Invalid Incrementation of the stage");\n', '    {\n', '      (, , , , , , , uint128 liquidity, , , , ) =\n', '        LiquidityManager.positions(stageInfo.tokenId);\n', '      LiquidityManager.decreaseLiquidity(\n', '        BaseUniswapV3.DecreaseLiquidityParams(\n', '          stageInfo.tokenId,\n', '          liquidity,\n', '          0,\n', '          0,\n', '          block.timestamp + 1000000\n', '        )\n', '      );\n', '      LiquidityManager.collect(\n', '        BaseUniswapV3.CollectParams({\n', '          tokenId: stageInfo.tokenId,\n', '          recipient: address(this),\n', '          amount0Max: uint128(-1),\n', '          amount1Max: uint128(-1)\n', '        })\n', '      );\n', '      if (stageInfo.tokenId2 != 0) {\n', '        (, , , , , , , liquidity, , , , ) = LiquidityManager.positions(\n', '          stageInfo.tokenId2\n', '        );\n', '        LiquidityManager.decreaseLiquidity(\n', '          BaseUniswapV3.DecreaseLiquidityParams(\n', '            stageInfo.tokenId2,\n', '            liquidity,\n', '            0,\n', '            0,\n', '            block.timestamp + 1000000\n', '          )\n', '        );\n', '        LiquidityManager.collect(\n', '          BaseUniswapV3.CollectParams({\n', '            tokenId: stageInfo.tokenId2,\n', '            recipient: address(this),\n', '            amount0Max: uint128(-1),\n', '            amount1Max: uint128(-1)\n', '          })\n', '        );\n', '      }\n', '    }\n', '    (uint256 tokenId, uint256 tokenId2) =\n', '      _mint(upperTick, lowerTick, calcs.roundDown(tick, spacing));\n', '\n', '    stage[currentStage + 1] = StageInfo(\n', '      upperTick,\n', '      lowerTick,\n', '      block.timestamp.toUint32(),\n', '      tokenId.toUint96(),\n', '      tokenId2.toUint96()\n', '    );\n', '\n', '    currentStage += 1;\n', '  }\n', '\n', '  function _transfer(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  ) internal returns (bool) {\n', '    require(from != address(0), "ERC20: transfer from the zero address");\n', '    require(to != address(0), "ERC20: transfer to the zero address");\n', '    Balance memory recipient = balance[to];\n', '    recipient.balance = recipient.balance.add(value.toUint96());\n', '    balance[from].balance = balance[from].balance.sub(value.toUint96());\n', '    if (from != address(swap) && from != address(LiquidityManager)) {\n', '      recipient = checkTokenMove(balance[from], recipient);\n', '    }\n', '    balance[to] = recipient;\n', '    emit Transfer(from, to, value);\n', '    return true;\n', '  }\n', '\n', '  function isLegend(address _legend) public view returns (bool) {\n', '    return (_legend == addresses[LEGENDS.VITALIK] ||\n', '      _legend == addresses[LEGENDS.UNISWAP_DEPLOYER]);\n', '  }\n', '\n', '  function _mint(\n', '    int24 tickUpper,\n', '    int24 tickLower,\n', '    int24 currentTick\n', '  ) internal returns (uint256 tokenId, uint256 tokenId2) {\n', '    uint256 dogeAmount = balance[address(this)].balance;\n', '    uint256 ethAmount = pair.balanceOf(address(this));\n', '    uint256 tokenAmount;\n', '    int24 secondUpperTick;\n', '    int24 secondLowerTick;\n', '    if (!isReversed) {\n', '      tokenAmount = getFirstLiquidity(ethAmount);\n', '      secondUpperTick = currentTick;\n', '      secondLowerTick = tickLower;\n', '    } else {\n', '      tokenAmount = getFirstLiquidity(ethAmount);\n', '      secondUpperTick = tickUpper;\n', '      secondLowerTick = currentTick;\n', '    }\n', '\n', '    (tokenId, , , ) = LiquidityManager.mint(\n', '      _getMintParams(tickUpper, tickLower, dogeAmount, tokenAmount)\n', '    );\n', '    if (pair.balanceOf(address(this)) != 0) {\n', '      (tokenId2, , , ) = LiquidityManager.mint(\n', '        _getMintParams(\n', '          secondUpperTick,\n', '          secondLowerTick,\n', '          dogeAmount,\n', '          ethAmount - tokenAmount\n', '        )\n', '      );\n', '    }\n', '  }\n', '\n', '  function _getMintParams(\n', '    int24 tickUpper,\n', '    int24 tickLower,\n', '    uint256 dogeBalance,\n', '    uint256 wethbalance\n', '  ) internal view returns (BaseUniswapV3.MintParams memory) {\n', '    if (!isReversed) {\n', '      return\n', '        BaseUniswapV3.MintParams({\n', '          token0: address(this),\n', '          token1: address(pair),\n', '          fee: swap.fee(),\n', '          tickUpper: tickUpper,\n', '          tickLower: tickLower,\n', '          amount0Desired: dogeBalance,\n', '          amount1Desired: wethbalance,\n', '          amount0Min: 0,\n', '          amount1Min: 0,\n', '          recipient: address(this),\n', '          deadline: block.timestamp + 1000000\n', '        });\n', '    }\n', '\n', '    return\n', '      BaseUniswapV3.MintParams({\n', '        token0: address(pair),\n', '        token1: address(this),\n', '        fee: swap.fee(),\n', '        tickUpper: tickUpper,\n', '        tickLower: tickLower,\n', '        amount0Desired: wethbalance,\n', '        amount1Desired: dogeBalance,\n', '        amount0Min: 0,\n', '        amount1Min: 0,\n', '        recipient: address(this),\n', '        deadline: block.timestamp + 1000000\n', '      });\n', '  }\n', '\n', '  function getStageInfo(uint16 stageID)\n', '    external\n', '    view\n', '    override\n', '    returns (\n', '      bool isReversedSwap,\n', '      int24 upperTick,\n', '      int24 lowerTick,\n', '      uint32 startTimestamp,\n', '      uint128 tokenId,\n', '      uint128 tokenId2\n', '    )\n', '  {\n', '    return (\n', '      isReversed,\n', '      stage[stageID].upperTick,\n', '      stage[stageID].lowerTick,\n', '      stage[stageID].startTimestamp,\n', '      stage[stageID].tokenId,\n', '      stage[stageID].tokenId2\n', '    );\n', '  }\n', '\n', '  function currentStatus()\n', '    external\n', '    view\n', '    override\n', '    returns (\n', '      uint16 currentStageId,\n', '      uint32 startTimestamp,\n', '      uint128 tokenId,\n', '      uint128 tokenId2,\n', '      uint256 upperPrice,\n', '      uint256 lowerPrice,\n', '      uint256 currentPrice\n', '    )\n', '  {\n', '    currentStageId = currentStage;\n', '    (uint160 price, , , , , , ) = swap.slot0();\n', '    if (isReversed) {\n', '      lowerPrice = uint256(10**36)\n', '        .div(\n', '        calcs.getPriceE8FromTick(\n', '          stage[currentStageId].upperTick - calcs.getDifference()\n', '        )\n', '      )\n', '        .div(10**10);\n', '      upperPrice = uint256(10**36)\n', '        .div(\n', '        calcs.getPriceE8FromTick(\n', '          stage[currentStageId].lowerTick + calcs.getDifference()\n', '        )\n', '      )\n', '        .div(10**10);\n', '      currentPrice = uint256(10**36)\n', '        .div(calcs.getPriceE8FromSQRTPrice(price))\n', '        .div(10**10);\n', '    } else {\n', '      upperPrice = calcs\n', '        .getPriceE8FromTick(stage[currentStageId].upperTick)\n', '        .div(10**10);\n', '      lowerPrice = calcs\n', '        .getPriceE8FromTick(stage[currentStageId].lowerTick)\n', '        .div(10**10);\n', '      currentPrice = calcs.getPriceE8FromSQRTPrice(price).div(10**10);\n', '    }\n', '    startTimestamp = stage[currentStageId].startTimestamp;\n', '    tokenId = stage[currentStageId].tokenId;\n', '    tokenId2 = stage[currentStageId].tokenId2;\n', '  }\n', '\n', '  function getFirstLiquidity(uint256 wethAmount) public view returns (uint256) {\n', '    uint64 ratioE8 = calcs.ratioE8();\n', '    if (ratioE8 >= 10**8) {\n', '      return wethAmount;\n', '    }\n', '    return wethAmount.mul(ratioE8).div(10**8);\n', '  }\n', '\n', '  function isReversedSwap() public view override returns (bool) {\n', '    return isReversed;\n', '  }\n', '\n', '  function getSwapInfo()\n', '    public\n', '    view\n', '    override\n', '    returns (int24 tick, address swapAddress)\n', '  {\n', '    swapAddress = address(swap);\n', '    (, tick, , , , , ) = swap.slot0();\n', '  }\n', '\n', '  function isUpgradable() external view override returns (bool upgradable) {\n', '    (uint160 price, , , , , , ) = swap.slot0();\n', '    int24 tick = calcs.getTickFromSQRTPrice(price);\n', '    StageInfo memory stageInfo = stage[currentStage];\n', '    (, , upgradable) = calcs.newTicks(\n', '      tick,\n', '      stageInfo.upperTick,\n', '      stageInfo.lowerTick,\n', '      swap.tickSpacing(),\n', '      stageInfo.startTimestamp\n', '    );\n', '  }\n', '}']