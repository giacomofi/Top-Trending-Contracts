['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.3;\n', '\n', 'import "./util.sol";\n', '\n', 'contract KOMAINU is Context, IBEP20, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _rOwned;\n', '    mapping (address => uint256) private _tOwned;\n', '    mapping (address => bool)    private _isExcludedFromFee;\n', '    mapping (address => bool)    private _isExcluded;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '    mapping (address => bool) public _isExcludedFromAutoLiquidity;\n', '    mapping (address => bool) public _isExcludedToAutoLiquidity;\n', '    mapping (address => bool) private _isBlacklisted;\n', '\tmapping (address => bool) private _isExcludedFromTransactionlock;\n', '    mapping(address => uint256) private _transactionCheckpoint;\n', '\n', '    address[] private _excluded;\n', '    address public _developerWallet = 0x85A7A3bEDE7B86B4145CE7525336DdE69d4CfBf0;\n', '    address public _developer2Wallet = 0x9019312749308b5162D111e3c3728459B88c069F;\n', '   \n', '    uint256 private constant MAX = ~uint256(0);\n', '    uint256 private _tTotal = 1000000000000 * 10**18;\n', '    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '    uint256 private _tFeeTotal;\n', '\n', '    string private constant _name     = "KOMAINU";\n', '    string private constant _symbol   = "KINU";\n', '    uint8  private constant _decimals = 18;\n', '    \n', '    uint256 public _burnFee      = 200; // 2% of every transaction is burned\n', '    uint256 public _taxFee       = 700; // 5% of every transaction is redistributed to holders + 2% burn Fee\n', '    uint256 public _liquidityFee = 0;   // 5% of every transaction is kept for liquidity\n', '    uint256 public _developerFee = 200; // 2% of every transaction is sent to developer wallet\n', '\n', '    uint256 private _previousBurnFee = _burnFee;\n', '    uint256 private _previousTaxFee       = _taxFee;\n', '    uint256 private _previousLiquidityFee = _liquidityFee;\n', '    uint256 private _previousDeveloperFee = _developerFee;\n', '\n', '    uint256 public _maxTxAmount                   = 10000000000 * 10**18;\n', '    uint256 public _numTokensSellToAddToLiquidity = 5000000000000000 * 10**18;\n', '    uint256 public _transactionLockTime           = 10;\n', '    \n', '    \n', '    // liquidity\n', '    bool public  _swapAndLiquifyEnabled = true;\n', '    bool private _inSwapAndLiquify;\n', '    IUniswapV2Router02 public _uniswapV2Router;\n', '    address            public _uniswapV2Pair;\n', '    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n', '    event SwapAndLiquifyEnabledUpdated(bool enabled);\n', '    event SwapAndLiquify(\n', '        uint256 tokensSwapped,\n', '        uint256 bnbReceived,\n', '        uint256 tokensIntoLiqudity\n', '    );\n', '    \n', '\n', '    modifier transactionIsUnlocked(){\n', '\t\trequire(block.timestamp - _transactionCheckpoint[_msgSender()] >= _transactionLockTime\n', '\t\t|| _isExcludedFromTransactionlock[_msgSender()]\n', '\t\t,"User not allowed to make transaction at this time");\n', '\t\t_;\n', '\t}\n', '    modifier lockTheSwap {\n', '        _inSwapAndLiquify = true;\n', '        _;\n', '        _inSwapAndLiquify = false;\n', '    }\n', '    \n', '    constructor (address cOwner) Ownable(cOwner) {\n', '\n', '        _rOwned[cOwner] = _rTotal;\n', '        \n', '        // Create a uniswap pair for this new token\n', '        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\n', '        _uniswapV2Router = uniswapV2Router;\n', '\n', '        // exclude system addresses from fee\n', '        _isExcludedFromFee[owner()]          = true;\n', '        _isExcludedFromFee[address(this)]    = true;\n', '        _isExcludedFromFee[_developerWallet] = true;\n', '        _isExcludedFromFee[_developer2Wallet] = true;\n', '\n', '        _isExcludedFromAutoLiquidity[_uniswapV2Pair]                = true;\n', '        _isExcludedFromAutoLiquidity[address(_uniswapV2Router)]     = true;\n', '\n', '        _isExcludedFromTransactionlock[owner()]                     = true;\n', '        _isExcludedFromTransactionlock[address(this)]               = true;\n', '        _isExcludedFromTransactionlock[_uniswapV2Pair]              = true;\n', '        _isExcludedFromTransactionlock[_developerWallet]            = true;\n', '        _isExcludedFromTransactionlock[_developer2Wallet]           = true;\n', '        _isExcludedFromTransactionlock[address(_uniswapV2Router)]   = true;\n', '\n', '        emit Transfer(address(0), cOwner, _tTotal);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // BEP20\n', '    function name() public pure returns (string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() public pure returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    function decimals() public pure returns (uint8) {\n', '        return _decimals;\n', '    }\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _tTotal;\n', '    }\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        if (_isExcluded[account]) return _tOwned[account];\n', '        return tokenFromReflection(_rOwned[account]);\n', '    }\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '    function _approve(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "BEP20: approve from the zero address");\n', '        require(spender != address(0), "BEP20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    // REFLECTION\n', '    function deliver(uint256 tAmount) public {\n', '        address sender = _msgSender();\n', '        require(!_isExcluded[sender], "Excluded addresses cannot call this function");\n', '\n', '        (, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount,,) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _rTotal         = _rTotal.sub(rAmount);\n', '        _tFeeTotal      = _tFeeTotal.add(tAmount);\n', '    }\n', '    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n', '        require(tAmount <= _tTotal, "Amount must be less than supply");\n', '\n', '        if (!deductTransferFee) {\n', '            (, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '            uint256 currentRate = _getRate();\n', '            (uint256 rAmount,,) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '            return rAmount;\n', '\n', '        } else {\n', '            (, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '            uint256 currentRate = _getRate();\n', '            (, uint256 rTransferAmount,) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '            return rTransferAmount;\n', '        }\n', '    }\n', '    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n', '        require(rAmount <= _rTotal, "Amount must be less than total reflections");\n', '\n', '        uint256 currentRate = _getRate();\n', '        return rAmount.div(currentRate);\n', '    }\n', '    function excludeFromReward(address account) public onlyOwner {\n', '        require(!_isExcluded[account], "Account is already excluded");\n', '\n', '        if (_rOwned[account] > 0) {\n', '            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '        }\n', '        _isExcluded[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '    function includeInReward(address account) external onlyOwner {\n', '        require(_isExcluded[account], "Account is already excluded");\n', '\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _tOwned[account] = 0;\n', '                _isExcluded[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    function totalFees() public view returns (uint256) {\n', '        return _tFeeTotal;\n', '    }\n', '    function excludeFromFee(address account) public onlyOwner {\n', '        _isExcludedFromFee[account] = true;\n', '    }\n', '    function includeInFee(address account) public onlyOwner {\n', '        _isExcludedFromFee[account] = false;\n', '    }\n', '    function setTaxFeePercent(uint256 taxFee) external onlyOwner {\n', '        _taxFee = _burnFee.add(taxFee);\n', '    }\n', '    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner {\n', '        _liquidityFee = liquidityFee;\n', '    }\n', '    function setBurnFeePercent(uint256 Fee) external onlyOwner() {\n', '        _burnFee = Fee;\n', '        _taxFee = _burnFee.add(_taxFee);\n', '    }\n', '    function setDeveloperFeePercent(uint256 developerFee) external onlyOwner {\n', '        _developerFee = developerFee;\n', '    }\n', '    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\n', '        _maxTxAmount = _tTotal.mul(maxTxPercent).div(100);\n', '    }\n', '    function setMinLiquidityPercent(uint256 minLiquidityPercent) external onlyOwner {\n', '        _numTokensSellToAddToLiquidity = _tTotal.mul(minLiquidityPercent).div(100);\n', '    }\n', '    function setSwapAndLiquifyEnabled(bool enabled) public onlyOwner {\n', '        _swapAndLiquifyEnabled = enabled;\n', '        emit SwapAndLiquifyEnabledUpdated(enabled);\n', '    }\n', '    function isExcludedFromFee(address account) public view returns(bool) {\n', '        return _isExcludedFromFee[account];\n', '    }\n', '    function isExcludedFromReward(address account) public view returns (bool) {\n', '        return _isExcluded[account];\n', '    }\n', '    function setExcludedFromAutoLiquidity(address a, bool b) external onlyOwner {\n', '        _isExcludedFromAutoLiquidity[a] = b;\n', '    }\n', '    function setExcludedToAutoLiquidity(address a, bool b) external onlyOwner {\n', '        _isExcludedToAutoLiquidity[a] = b;\n', '    }\n', '    function setTransactionlockTime(uint256 transactiontime) public onlyOwner {\n', '\t\t_transactionLockTime = transactiontime;\n', '\t}\n', '    function excludedFromTransactionlockTime(address excludeAddress) public onlyOwner {\n', '\t\t_isExcludedFromTransactionlock[excludeAddress] = true;\n', '\t}\n', '    function includedInTransactionlockTime(address excludeAddress) public onlyOwner {\n', '\t\t_isExcludedFromTransactionlock[excludeAddress] = false;\n', '\t}\n', '\tfunction getIsExcludedFromTransactionlock(address excludeAddress) public view returns (bool){\n', '\t\treturn _isExcludedFromTransactionlock[excludeAddress];\n', '\t}\n', '    function setUniswapRouter(address r) external onlyOwner {\n', '        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(r);\n', '        _uniswapV2Router = uniswapV2Router;\n', '    }\n', '    function blacklistSingleWallet(address addresses) public onlyOwner(){\n', '        if(_isBlacklisted[addresses] == true) return;\n', '        _isBlacklisted[addresses] = true;\n', '    }\n', '    function blacklistMultipleWallets(address[] calldata addresses) public onlyOwner(){\n', '        for (uint256 i; i < addresses.length; ++i) {\n', '            _isBlacklisted[addresses[i]] = true;\n', '        }\n', '    }\n', '    function isBlacklisted(address addresses) public view returns (bool){\n', '        if(_isBlacklisted[addresses] == true) return true;\n', '        else return false;\n', '    }\n', '    function unBlacklistSingleWallet(address addresses) external onlyOwner(){\n', '         if(_isBlacklisted[addresses] == false) return;\n', '        _isBlacklisted[addresses] = false;\n', '    }\n', '    function unBlacklistMultipleWallets(address[] calldata addresses) public onlyOwner(){\n', '        for (uint256 i; i < addresses.length; ++i) {\n', '            _isBlacklisted[addresses[i]] = false;\n', '        }\n', '    }\n', '    function setUniswapPair(address p) external onlyOwner {\n', '        _uniswapV2Pair = p;\n', '    }\n', '\n', '    // TRANSFER\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) private transactionIsUnlocked {\n', '        require(from != address(0), "BEP20: transfer from the zero address");\n', '        require(to != address(0), "BEP20: transfer to the zero address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        require(_isBlacklisted[from] == false, "You are banned");\n', '        require(_isBlacklisted[to] == false, "The recipient is banned");\n', '\n', '        if (from != owner() && to != owner()) {\n', '            require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n', '        }\n', '\n', '        /*\n', '            - swapAndLiquify will be initiated when token balance of this contract\n', '            has accumulated enough over the minimum number of tokens required.\n', "            - don't get caught in a circular liquidity event.\n", "            - don't swapAndLiquify if sender is uniswap pair.\n", '        */\n', '\n', '        uint256 contractTokenBalance = balanceOf(address(this));\n', '        \n', '        if (contractTokenBalance >= _maxTxAmount) {\n', '            contractTokenBalance = _maxTxAmount;\n', '        }\n', '        \n', '        bool isOverMinTokenBalance = contractTokenBalance >= _numTokensSellToAddToLiquidity;\n', '        if (\n', '            isOverMinTokenBalance &&\n', '            !_inSwapAndLiquify &&\n', '            !_isExcludedFromAutoLiquidity[from] &&\n', '            !_isExcludedToAutoLiquidity[to] &&\n', '            _swapAndLiquifyEnabled\n', '        ) {\n', '            contractTokenBalance = _numTokensSellToAddToLiquidity;\n', '            swapAndLiquify(contractTokenBalance);\n', '        }\n', '        \n', '        bool takeFee = true;\n', '        // if sender or recipient is excluded from fees, remove fees\n', '        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n', '            takeFee = false;\n', '        }\n', '        \n', '        _transactionCheckpoint[_msgSender()] = block.timestamp;\n', '        _tokenTransfer(from, to, amount, takeFee);\n', '    }\n', '    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n', '        // split contract balance into halves\n', '        uint256 half      = contractTokenBalance.div(2);\n', '        uint256 otherHalf = contractTokenBalance.sub(half);\n', '\n', '        /*\n', "            capture the contract's current BNB balance.\n", '            this is so that we can capture exactly the amount of BNB that\n', '            the swap creates, and not make the liquidity event include any BNB\n', '            that has been manually sent to the contract.\n', '        */\n', '        uint256 initialBalance = address(this).balance;\n', '\n', '        // swap tokens for BNB\n', '        swapTokensForBnb(half);\n', '\n', '        // this is the amount of BNB that we just swapped into\n', '        uint256 newBalance = address(this).balance.sub(initialBalance);\n', '\n', '        // add liquidity to uniswap\n', '        addLiquidity(otherHalf, newBalance);\n', '        \n', '        emit SwapAndLiquify(half, newBalance, otherHalf);\n', '    }\n', '    function swapTokensForBnb(uint256 tokenAmount) private {\n', '        // generate the uniswap pair path of token -> weth\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = _uniswapV2Router.WETH();\n', '\n', '        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n', '\n', '        // make the swap\n', '        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0, // accept any amount of BNB\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '    function addLiquidity(uint256 tokenAmount, uint256 bnbAmount) private {\n', '        // approve token transfer to cover all possible scenarios\n', '        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n', '\n', '        // add the liquidity\n', '        _uniswapV2Router.addLiquidityETH{value: bnbAmount}(\n', '            address(this),\n', '            tokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n', '        if (!takeFee) {\n', '            removeAllFee();\n', '        }\n', '        \n', '        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n', '            _transferFromExcluded(sender, recipient, amount);\n', '\n', '        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n', '            _transferToExcluded(sender, recipient, amount);\n', '\n', '        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n', '            _transferStandard(sender, recipient, amount);\n', '\n', '        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n', '            _transferBothExcluded(sender, recipient, amount);\n', '\n', '        } else {\n', '            _transferStandard(sender, recipient, amount);\n', '        }\n', '        \n', '        if (!takeFee) {\n', '            restoreAllFee();\n', '        }\n', '    }\n', '    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n', '        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '        _rOwned[sender]    = _rOwned[sender].sub(rAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\n', '        if(_burnFee > 0 && _taxFee > 0) _burn(sender, tFee.div(_taxFee).mul(_burnFee));\n', '        takeTransactionFee(address(this), tLiquidity, currentRate);\n', '        takeTransactionFee(address(_developerWallet), tDeveloper.div(2), currentRate);\n', '        takeTransactionFee(address(_developer2Wallet), tDeveloper.div(2), currentRate);\n', '        reflectFee(rFee, tFee);\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n', '        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\n', '        if(_burnFee > 0 && _taxFee > 0) _burn(sender, tFee.div(_taxFee).mul(_burnFee));\n', '        takeTransactionFee(address(this), tLiquidity, currentRate);\n', '        takeTransactionFee(address(_developerWallet), tDeveloper.div(2), currentRate);\n', '        takeTransactionFee(address(_developer2Wallet), tDeveloper.div(2), currentRate);\n', '        reflectFee(rFee, tFee);\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n', '        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\n', '        if(_burnFee > 0 && _taxFee > 0) _burn(sender, tFee.div(_taxFee).mul(_burnFee));\n', '        takeTransactionFee(address(this), tLiquidity, currentRate);\n', '        takeTransactionFee(address(_developerWallet), tDeveloper.div(2), currentRate);\n', '        takeTransactionFee(address(_developer2Wallet), tDeveloper.div(2), currentRate);\n', '        reflectFee(rFee, tFee);\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n', '        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper) = _getTValues(tAmount);\n', '        uint256 currentRate = _getRate();\n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, tDeveloper, currentRate);\n', '\n', '        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\n', '        if(_burnFee > 0 && _taxFee > 0) _burn(sender, tFee.div(_taxFee).mul(_burnFee));\n', '        takeTransactionFee(address(this), tLiquidity, currentRate);\n', '        takeTransactionFee(address(_developerWallet), tDeveloper.div(2), currentRate);\n', '        takeTransactionFee(address(_developer2Wallet), tDeveloper.div(2), currentRate);\n', '        reflectFee(rFee, tFee);\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    function reflectFee(uint256 rFee, uint256 tFee) private {\n', '        _rTotal    = _rTotal.sub(rFee);\n', '        _tFeeTotal = _tFeeTotal.add(tFee);\n', '    }\n', '    function removeAllFee() private {\n', '        if (_taxFee == 0 && _liquidityFee == 0 && _developerFee == 0 && _burnFee == 0) return;\n', '        \n', '        _previousBurnFee      = _burnFee;\n', '        _previousTaxFee       = _taxFee;\n', '        _previousLiquidityFee = _liquidityFee;\n', '        _previousDeveloperFee = _developerFee;\n', '        \n', '        _taxFee       = 0;\n', '        _burnFee      = 0;\n', '        _liquidityFee = 0;\n', '        _developerFee = 0;\n', '    }\n', '    function restoreAllFee() private {\n', '        _taxFee       = _previousTaxFee;\n', '        _burnFee      = _previousBurnFee;\n', '        _liquidityFee = _previousLiquidityFee;\n', '        _developerFee = _previousDeveloperFee;\n', '    }\n', '    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\n', '        uint256 tFee       = tAmount.mul(_taxFee).div(10000);\n', '        uint256 tLiquidity = tAmount.mul(_liquidityFee).div(10000);\n', '        uint256 tDeveloper = tAmount.mul(_developerFee).div(10000);\n', '        uint256 tTransferAmount = tAmount.sub(tFee);\n', '        tTransferAmount = tTransferAmount.sub(tLiquidity);\n', '        tTransferAmount = tTransferAmount.sub(tDeveloper);\n', '        return (tTransferAmount, tFee, tLiquidity, tDeveloper);\n', '    }\n', '    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 tDeveloper, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n', '        uint256 rAmount     = tAmount.mul(currentRate);\n', '        uint256 rFee        = tFee.mul(currentRate);\n', '        uint256 rLiquidity  = tLiquidity.mul(currentRate);\n', '        uint256 rDeveloper  = tDeveloper.mul(currentRate);\n', '        uint256 rTransferAmount = rAmount.sub(rFee);\n', '        rTransferAmount = rTransferAmount.sub(rLiquidity);\n', '        rTransferAmount = rTransferAmount.sub(rDeveloper);\n', '        return (rAmount, rTransferAmount, rFee);\n', '    }\n', '    function _getRate() private view returns(uint256) {\n', '        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '        return rSupply.div(tSupply);\n', '    }\n', '    function _getCurrentSupply() private view returns(uint256, uint256) {\n', '        uint256 rSupply = _rTotal;\n', '        uint256 tSupply = _tTotal;      \n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n', '            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n', '            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n', '        }\n', '        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '        return (rSupply, tSupply);\n', '    }\n', '    function takeTransactionFee(address to, uint256 tAmount, uint256 currentRate) private {\n', '        if (tAmount <= 0) { return; }\n', '\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '        _rOwned[to] = _rOwned[to].add(rAmount);\n', '        if (_isExcluded[to]) {\n', '            _tOwned[to] = _tOwned[to].add(tAmount);\n', '        }\n', '    }\n', '    function _burn(address account, uint256 amount) private {\n', '        require(account != address(0), "BEP20: burn from the zero address");\n', '        _tOwned[address(0)] = _tOwned[address(0)].add(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '}']