['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.8;\n', '\n', 'import "./imports.sol";\n', '\n', '\n', 'contract LiquidityMigrator {\n', '    \n', '    using SafeMath for uint;\n', '\n', '    IUniswapV2Router02 router;\n', '    address token;\n', '    uint constant MIN_ETH = 5e17;\n', '\n', '    constructor(address _token,address _router) public {\n', '        token = _token;\n', '        router = IUniswapV2Router02(_router);\n', '    }\n', '\n', '    function migrate(address pair,uint amount, uint slippage,uint deadline) external returns (uint,uint) {\n', '        require(IUniswapV2Pair(pair).token0() == router.WETH() || IUniswapV2Pair(pair).token1() == router.WETH());\n', '        SafeERC20.safeTransferFrom(IERC20(pair),msg.sender,address(this),amount);\n', '        removeLiquidity(pair,amount);\n', '        uint samount0;\n', '        uint samount1;\n', '        address changeToken = IUniswapV2Pair(pair).token0() == router.WETH() ? (IUniswapV2Pair(pair).token1()) : (IUniswapV2Pair(pair).token0());\n', '        (uint ethAmount,uint changeAmount) = (IERC20(router.WETH()).balanceOf(address(this)),IERC20(changeToken).balanceOf(address(this)));\n', '        if (checkReserves(changeToken,router.WETH(),changeAmount) && swapPrice(changeToken,router.WETH(),changeAmount) >= MIN_ETH) {\n', '            samount0 = swap(router.WETH(),token,ethAmount,slippage,deadline);\n', '            samount1 = swap(changeToken,router.WETH(),changeAmount,slippage,deadline);\n', '        } else {\n', '            samount0 = swap(router.WETH(),token,ethAmount.div(2),slippage,deadline);\n', '            samount1 = ethAmount.div(2);\n', '            SafeERC20.safeTransfer(IERC20(changeToken), msg.sender, changeAmount);\n', '        }\n', '        addLiquidity(token,router.WETH(),samount0,samount1,msg.sender);\n', '        \n', '        return (samount0, samount1);\n', '    }\n', '    \n', '    function removeLiquidity(address pair,uint amount) internal returns (uint,uint) {\n', '        SafeERC20.safeTransfer(IERC20(pair),pair,amount);\n', '        return IUniswapV2Pair(pair).burn(address(this));\n', '    }\n', '    \n', '    function addLiquidity(address token0,address token1,uint amount0,uint amount1,address to) internal returns (uint) {\n', '        (amount0,amount1) = shapeReservesChange(token,router.WETH(),amount0,amount1);\n', '        address pair = UniswapV2Library.pairFor(router.factory(),token0,token1);\n', '        SafeERC20.safeTransfer(IERC20(token0),pair,amount0);\n', '        SafeERC20.safeTransfer(IERC20(token1),pair,amount1);\n', '        return IUniswapV2Pair(pair).mint(to);\n', '    }\n', '    \n', '    function swap(address tokenIn,address tokenOut,uint amount,uint slippagePercent,uint deadline) internal returns (uint) {\n', '        address pair = UniswapV2Library.pairFor(router.factory(),tokenIn,tokenOut);\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenIn;\n', '        path[1] = tokenOut;\n', '        (uint reserveIn,uint reserveOut) = UniswapV2Library.getReserves(router.factory(),tokenIn,tokenOut);\n', '        uint out = slippage(UniswapV2Library.getAmountOut(IERC20(tokenIn).balanceOf(pair),reserveIn,reserveOut),slippagePercent);\n', '        SafeERC20.safeApprove(IERC20(tokenIn),address(router),amount);\n', '        IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(amount,out,path,address(this),deadline);\n', '        return IERC20(tokenOut).balanceOf(address(this));\n', '    }\n', '\n', '    function checkReserves(address tokenIn,address tokenOut,uint amount) internal view returns (bool) {\n', '        (,uint reserveOut) = UniswapV2Library.getReserves(router.factory(),tokenIn,tokenOut);\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenIn;\n', '        path[1] = tokenOut;\n', '        uint out = UniswapV2Library.getAmountsOut(router.factory(),amount,path)[1];\n', '        if (reserveOut >= out) {\n', '            return true;\n', '        }\n', '        \n', '        return false;\n', '    }\n', '    \n', '    function checkReserves(address tokenIn,address tokenOut,uint amount,uint reserveOut) internal view returns (bool) {\n', '        if (tokenIn == tokenOut) {\n', '            return true;\n', '        }\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenIn;\n', '        path[1] = tokenOut;\n', '        uint out = UniswapV2Library.getAmountsOut(router.factory(),amount,path)[1];\n', '        if (reserveOut >= out) {\n', '            return true;\n', '        }\n', '        \n', '        return false;\n', '    }\n', '\n', '    function slippage(uint amount,uint percent) internal pure returns (uint) {\n', '        return amount.sub(amount.mul(percent).div(100));\n', '}\n', '\n', '    function shapeReservesChange(address token0,address token1,uint amount0,uint amount1) internal returns (uint,uint) {\n', '        (uint reserve0,uint reserve1) = UniswapV2Library.getReserves(router.factory(),token0,token1);\n', '        if (amount0 > amount1.mul(reserve0).div(reserve1)) {\n', '            SafeERC20.safeTransfer(IERC20(token0),msg.sender,amount0.sub(amount1.mul(reserve0).div(reserve1)));\n', '            amount0 = amount1.mul(reserve0).div(reserve1);\n', '        } else if (amount1 > amount0.mul(reserve1).div(reserve0)) {\n', '            SafeERC20.safeTransfer(IERC20(token1),msg.sender,amount1.sub(amount0.mul(reserve1).div(reserve0)));\n', '            amount1 = amount0.mul(reserve1).div(reserve0);\n', '        }\n', '        return (amount0,amount1);\n', '    }\n', '\n', '    function shapeReserves(address token0,address token1,uint amount0,uint amount1) internal view returns (uint,uint) {\n', '        (uint reserve0,uint reserve1) = UniswapV2Library.getReserves(router.factory(),token0,token1);\n', '        if (amount0 > amount1.mul(reserve0).div(reserve1)) {\n', '            amount0 = amount1.mul(reserve0).div(reserve1);\n', '        } else if (amount1 > amount0.mul(reserve1).div(reserve0)) {\n', '            amount1 = amount0.mul(reserve1).div(reserve0);\n', '        }\n', '        return (amount0,amount1);\n', '    }\n', '\n', '    function fromPair(address pair,uint amount) external view returns (uint) {\n', '        require(IUniswapV2Pair(pair).token0() == router.WETH() || IUniswapV2Pair(pair).token1() == router.WETH());\n', '        (uint amount0,uint amount1) = UniswapV2LiquidityMathLibrary.getLiquidityValue(router.factory(),IUniswapV2Pair(pair).token0(),IUniswapV2Pair(pair).token1(),amount);\n', '        uint samount0;\n', '        uint samount1;\n', '        address changeToken = IUniswapV2Pair(pair).token0() == router.WETH() ? (IUniswapV2Pair(pair).token1()) : (IUniswapV2Pair(pair).token0());\n', '        (uint ethAmount,uint changeAmount) = IUniswapV2Pair(pair).token0() == router.WETH() ? (amount0,amount1) : (amount1,amount0);\n', '        (,uint reserve) = UniswapV2Library.getReserves(router.factory(),changeToken,router.WETH());\n', '        (uint reserveIn,uint reserveOut) = UniswapV2Library.getReserves(router.factory(),changeToken,router.WETH());\n', '        (uint reserve0,uint reserve1) = UniswapV2Library.getReserves(router.factory(),token,router.WETH());\n', '        if (checkReserves(changeToken,router.WETH(),changeAmount,reserve.sub(ethAmount)) && UniswapV2Library.getAmountOut(changeAmount,reserveIn.sub(changeAmount),reserveOut.sub(ethAmount)) >= MIN_ETH) {\n', '            samount0 = swapPrice(router.WETH(),token,ethAmount);\n', '            reserve0 = reserve0.sub(samount0);\n', '            reserve1 = reserve1.add(ethAmount);\n', '            samount1 = UniswapV2Library.getAmountOut(changeAmount,reserveIn.sub(changeAmount),reserveOut.sub(ethAmount));\n', '        } else {\n', '            samount0 = swapPrice(router.WETH(),token,ethAmount.div(2));\n', '            reserve0 = reserve0.sub(samount0);\n', '            reserve1 = reserve1.add(ethAmount.div(2));\n', '            samount1 = ethAmount.div(2);\n', '        }\n', '        (samount0,samount0) = shapeReserves(token,router.WETH(),samount0,samount1);\n', '        return calculateLiquidity(pair,samount0,samount1,reserve0,reserve1);\n', '    }\n', '    \n', '    function calculateLiquidity(address pair,uint samount0,uint samount1,uint _reserve0,uint _reserve1) internal view returns (uint) {\n', '        uint _totalSupply = IERC20(pair).totalSupply();\n', '        uint liquidity;\n', '        if (_totalSupply == 0) {\n', '            liquidity = Math.sqrt(samount0.mul(samount1)).sub(10**3);\n', '        } else {\n', '            liquidity = Math.min(samount0.mul(_totalSupply) / _reserve0, samount1.mul(_totalSupply) / _reserve1);\n', '        }\n', '        return liquidity;\n', '    }\n', '    \n', '    function swapPrice(address tokenIn,address tokenOut,uint amount) internal view returns (uint) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenIn;\n', '        path[1] = tokenOut;\n', '        return UniswapV2Library.getAmountsOut(router.factory(),amount,path)[1];\n', '    }\n', '    \n', '\n', '    function getTokenPrice(address pair) external view returns (uint) {\n', '        require(IUniswapV2Pair(pair).token0() == router.WETH() || IUniswapV2Pair(pair).token1() == router.WETH());\n', '        address pairtoken = IUniswapV2Pair(pair).token0() == router.WETH() ? (IUniswapV2Pair(pair).token1()) : (IUniswapV2Pair(pair).token0());\n', '        (uint reserve0,uint reserve1) = UniswapV2Library.getReserves(router.factory(),IUniswapV2Pair(pair).token0(),IUniswapV2Pair(pair).token1());\n', '        uint price = IUniswapV2Pair(pair).token0() == router.WETH() ? (reserve0.mul(1e18).div(reserve1)) : (reserve1.mul(1e18).div(reserve0));\n', '        return price.div(1 ** IERC20(pairtoken).decimals());\n', '    }\n', '    \n', '    function getTokenSymbol(address pair) external view returns (string memory) {\n', '        require(IUniswapV2Pair(pair).token0() == router.WETH() || IUniswapV2Pair(pair).token1() == router.WETH());\n', '        address pairtoken = IUniswapV2Pair(pair).token0() == router.WETH() ? (IUniswapV2Pair(pair).token1()) : (IUniswapV2Pair(pair).token0());\n', '        return IERC20(pairtoken).symbol();\n', '    }\n', '}']