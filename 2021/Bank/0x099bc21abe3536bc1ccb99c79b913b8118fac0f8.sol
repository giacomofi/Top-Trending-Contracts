['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', '/*\n', '                                       `.-:+osyhhhhhhyso+:-.`\n', '                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n', '                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n', '                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n', '                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n', '                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n', '                        :dNNNNNNh/`                              `/hNNNNNNd:\n', '                      `oNNNNNNh:                     /-/.           :hNNNNNNo`\n', '                     `yNNNNNm+`                      mNNm-           `+mNNNNNy`\n', '                    `hNNNNNd-                        hNNNm.            -dNNNNNh`\n', '                    yNNNNNd.                         .ymNNh             .dNNNNNy\n', '                   /NNNNNm.                            -mNNys+.          .mNNNNN/\n', '                  `mNNNNN:                           `:hNNNNNNNs`         :NNNNNm`\n', '                  /NNNNNh                          `+dNNNNNNNNNNd.         hNNNNN/\n', '                  yNNNNN/               .:+syyhhhhhmNNNNNNNNNNNNNm`        /NNNNNy\n', '                  dNNNNN.            `+dNNNNNNNNNNNNNNNNNNNNNNNmd+         .NNNNNd\n', '                  mNNNNN`           -dNNNNNNNNNNNNNNNNNNNNNNm-             `NNNNNm\n', '                  dNNNNN.          -NNNNNNNNNNNNNNNNNNNNNNNN+              .NNNNNd\n', '                  yNNNNN/          dNNNNNNNNNNNNNNNNNNNNNNNN:              /NNNNNy\n', '                  /NNNNNh         .NNNNNNNNNNNNNNNNNNNNNNNNd`              hNNNNN/\n', '                  `mNNNNN:        -NNNNNNNNNNNNNNNNNNNNNNNh.              :NNNNNm`\n', '                   /NNNNNm.       `NNNNNNNNNNNNNNNNNNNNNh:               .mNNNNN/\n', '                    yNNNNNd.      .yNNNNNNNNNNNNNNNdmNNN/               .dNNNNNy\n', '                    `hNNNNNd-    `dmNNNNNNNNNNNNdo-`.hNNh              -dNNNNNh`\n', '                     `yNNNNNm+`   oNNmmNNNNNNNNNy.   `sNNdo.         `+mNNNNNy`\n', '                      `oNNNNNNh:   ....++///+++++.     -+++.        :hNNNNNNo`\n', '                        :dNNNNNNh/`                              `/hNNNNNNd:\n', '                         `omNNNNNNdo-`                        `-odNNNNNNmo`\n', '                           .odNNNNNNNdy+-.`              `.-+ydNNNNNNNdo.\n', '                             `/hmNNNNNNNNmdys+//:::://+sydmNNNNNNNNmh/`\n', '                                .+ymNNNNNNNNNNNNNNNNNNNNNNNNNNNNmy+.\n', '                                   .:+ydmNNNNNNNNNNNNNNNNNNmdy+:.\n', '                                       `.-:+yourewelcome+:-.`\n', ' /$$$$$$$  /$$                                               /$$      /$$\n', '| $$__  $$| $$                                              | $$$    /$$$\n', '| $$  \\ $$| $$  /$$$$$$  /$$   /$$ /$$   /$$  /$$$$$$$      | $$$$  /$$$$  /$$$$$$  /$$$$$$$   /$$$$$$  /$$   /$$\n', '| $$$$$$$/| $$ /$$__  $$|  $$ /$$/| $$  | $$ /$$_____/      | $$ $$/$$ $$ /$$__  $$| $$__  $$ /$$__  $$| $$  | $$\n', '| $$____/ | $$| $$$$$$$$ \\  $$$$/ | $$  | $$|  $$$$$$       | $$  $$$| $$| $$  \\ $$| $$  \\ $$| $$$$$$$$| $$  | $$\n', '| $$      | $$| $$_____/  >$$  $$ | $$  | $$ \\____  $$      | $$\\  $ | $$| $$  | $$| $$  | $$| $$_____/| $$  | $$\n', '| $$      | $$|  $$$$$$$ /$$/\\  $$|  $$$$$$/ /$$$$$$$/      | $$ \\/  | $$|  $$$$$$/| $$  | $$|  $$$$$$$|  $$$$$$$\n', '|__/      |__/ \\_______/|__/  \\__/ \\______/ |_______/       |__/     |__/ \\______/ |__/  |__/ \\_______/ \\____  $$\n', '                                                                                                        /$$  | $$\n', '                                                                                                       |  $$$$$$/\n', '                                                                                                       \\______/\n', '*/\n', '\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '\n', '\n', 'pragma solidity 0.7.4;\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns(uint supply);\n', '\n', '    function balanceOf(address _owner) external view returns(uint balance);\n', '\n', '    function transfer(address _to, uint _value) external returns(bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n', '\n', '    function approve(address _spender, uint _value) external returns(bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns(uint remaining);\n', '\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'interface WrappedETH {\n', '    function totalSupply() external view returns(uint supply);\n', '\n', '    function balanceOf(address _owner) external view returns(uint balance);\n', '\n', '    function transfer(address _to, uint _value) external returns(bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint _value) external returns(bool success);\n', '\n', '    function approve(address _spender, uint _value) external returns(bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns(uint remaining);\n', '\n', '    function decimals() external view returns(uint digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function deposit() external payable;\n', '\n', '    function withdraw(uint256 wad) external;\n', '\n', '}\n', '\n', 'interface UniswapFactory{\n', '  function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface LPERC20{\n', '\n', '    function token0() external view returns(address);\n', '    function token1() external view returns(address);\n', '}\n', '\n', '\n', '\n', 'interface SushiV2{\n', '\n', '\n', '   function addLiquidity ( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB, uint256 liquidity );\n', '   function addLiquidityETH ( address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH, uint256 liquidity );\n', '   function removeLiquidityETH ( address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline ) external returns ( uint256 amountToken, uint256 amountETH );\n', '   function removeLiquidity ( address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline ) external returns ( uint256 amountA, uint256 amountB );\n', '\n', '   function swapExactTokensForTokens ( uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline ) external returns ( uint256[] memory amounts );\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '   function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal view returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal view returns (uint256) {\n', '    assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '\n', '\n', '  function sub(uint256 a, uint256 b) internal view returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal view returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', 'contract WrapAndUnWrap{\n', '\n', '  using SafeMath\n', '    for uint256;\n', '\n', '  address payable public owner;\n', '  //placehodler token address for specifying eth tokens\n', '  address public ETH_TOKEN_ADDRESS  = address(0x0);\n', '  address public WETH_TOKEN_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '  WrappedETH wethToken = WrappedETH(WETH_TOKEN_ADDRESS);\n', '  uint256 approvalAmount = 1000000000000000000000000000000;\n', '  uint256 longTimeFromNow = 1000000000000000000000000000;\n', '  address sushiAddress = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n', '  address uniFactoryAddress = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '  SushiV2 sushiExchange = SushiV2(sushiAddress);\n', '  UniswapFactory factory = UniswapFactory(uniFactoryAddress);\n', '  mapping (address => address[]) public lpTokenAddressToPairs;\n', '  mapping(string=>address) public stablecoins;\n', '  mapping(address=>mapping(address=>address[])) public presetPaths;\n', '  bool public changeRecpientIsOwner;\n', '  uint256 public fee = 0;\n', '  uint256 public maxfee = 0;\n', '\n', '\n', '  modifier onlyOwner {\n', '        require(\n', '            msg.sender == owner,\n', '            "Only owner can call this function."\n', '        );\n', '        _;\n', '}\n', '\n', '    fallback() external payable {\n', '    }\n', '\n', '  constructor() public payable {\n', '         stablecoins["DAI"] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '         stablecoins["USDT"] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '         stablecoins["USDC"] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '         changeRecpientIsOwner = false;\n', '        owner= msg.sender;\n', '\n', '  }\n', '\n', '  function wrap(address sourceToken, address[] memory destinationTokens, uint256 amount) public payable returns(address, uint256){\n', '\n', '\n', '    ERC20 sToken = ERC20(sourceToken);\n', '    ERC20 dToken = ERC20(destinationTokens[0]);\n', '\n', '      if(destinationTokens.length==1){\n', '\n', '        if(sourceToken != ETH_TOKEN_ADDRESS){\n', '          require(sToken.transferFrom(msg.sender, address(this), amount), "You have not approved this contract or do not have enough token for this transfer 1");\n', '          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n', '                  sToken.approve(sushiAddress, amount.mul(3));\n', '            }\n', '        }\n', '\n', '        conductUniswap(sourceToken, destinationTokens[0], amount);\n', '        uint256 thisBalance = dToken.balanceOf(address(this));\n', '        dToken.transfer(msg.sender, thisBalance);\n', '        return (destinationTokens[0], thisBalance);\n', '\n', '      }\n', '\n', '      else{\n', '\n', '        bool updatedweth =false;\n', '        if(sourceToken == ETH_TOKEN_ADDRESS){\n', '          WrappedETH sToken1 = WrappedETH(WETH_TOKEN_ADDRESS);\n', '          sToken1.deposit{value:msg.value}();\n', '          sToken = ERC20(WETH_TOKEN_ADDRESS);\n', '          amount = msg.value;\n', '          sourceToken = WETH_TOKEN_ADDRESS;\n', '          updatedweth =true;\n', '        }\n', '\n', '\n', '        if(sourceToken != ETH_TOKEN_ADDRESS && updatedweth==false){\n', '          require(sToken.transferFrom(msg.sender, address(this), amount), "You have not approved this contract or do not have enough token for this transfer  2");\n', '          if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n', '                  sToken.approve(sushiAddress, amount.mul(3));\n', '            }\n', '        }\n', '\n', '        if(destinationTokens[0] == ETH_TOKEN_ADDRESS){\n', '              destinationTokens[0] = WETH_TOKEN_ADDRESS;\n', '        }\n', '        if(destinationTokens[1] == ETH_TOKEN_ADDRESS){\n', '            destinationTokens[1] = WETH_TOKEN_ADDRESS;\n', '        }\n', '\n', '\n', '\n', '        if(sourceToken !=destinationTokens[0]){\n', '            conductUniswap(sourceToken, destinationTokens[0], amount.div(2));\n', '        }\n', '        if(sourceToken !=destinationTokens[1]){\n', '\n', '            conductUniswap(sourceToken, destinationTokens[1], amount.div(2));\n', '        }\n', '\n', '        ERC20 dToken2 = ERC20(destinationTokens[1]);\n', '        uint256 dTokenBalance = dToken.balanceOf(address(this));\n', '        uint256 dTokenBalance2 = dToken2.balanceOf(address(this));\n', '\n', '        if(dToken.allowance(address(this), sushiAddress) < dTokenBalance.mul(2)){\n', '             dToken.approve(sushiAddress, dTokenBalance.mul(3));\n', '        }\n', '\n', '        if(dToken2.allowance(address(this), sushiAddress) < dTokenBalance2.mul(2)){\n', '            dToken2.approve(sushiAddress, dTokenBalance2.mul(3));\n', '        }\n', '\n', '        (,,uint liquidityCoins)  = sushiExchange.addLiquidity(destinationTokens[0],destinationTokens[1], dTokenBalance, dTokenBalance2, 1,1, address(this), longTimeFromNow);\n', '\n', '        address thisPairAddress = factory.getPair(destinationTokens[0],destinationTokens[1]);\n', '        ERC20 lpToken = ERC20(thisPairAddress);\n', '        lpTokenAddressToPairs[thisPairAddress] =[destinationTokens[0], destinationTokens[1]];\n', '        uint256 thisBalance =lpToken.balanceOf(address(this));\n', '\n', '        if(fee>0){\n', '            uint256 totalFee = (thisBalance.mul(fee)).div(10000);\n', '            if(totalFee >0){\n', '                lpToken.transfer(owner, totalFee);\n', '            }\n', '            thisBalance =lpToken.balanceOf(address(this));\n', '            lpToken.transfer(msg.sender, thisBalance);\n', '\n', '        }\n', '        else{\n', '            lpToken.transfer(msg.sender, thisBalance);\n', '        }\n', '\n', '\n', '        //transfer any change to changeRecipient (from a pair imbalance. Should never be more than a few basis points)\n', '        address changeRecipient = msg.sender;\n', '        if(changeRecpientIsOwner == true){\n', '            changeRecipient = owner;\n', '        }\n', '        if(dToken.balanceOf(address(this)) >0){\n', '            dToken.transfer(changeRecipient, dToken.balanceOf(address(this)));\n', '        }\n', '        if(dToken2.balanceOf(address(this)) >0){\n', '            dToken2.transfer(changeRecipient, dToken2.balanceOf(address(this)));\n', '        }\n', '\n', '        return (thisPairAddress,thisBalance) ;\n', '      }\n', '\n', '\n', '\n', '    }\n', '\n', '    function updateStableCoinAddress(string memory coinName, address newAddress) public onlyOwner returns(bool){\n', '        stablecoins[coinName] = newAddress;\n', '        return true;\n', '\n', '    }\n', '\n', '    function updatePresetPaths(address sellToken, address buyToken, address[] memory newPath ) public onlyOwner returns(bool){\n', '        presetPaths[sellToken][buyToken] = newPath;\n', '        return true;\n', '    }\n', '\n', '    //owner can turn on ability to collect a small fee from trade imbalances on LP conversions\n', '    function updateChangeRecipientBool(bool changeRecpientIsOwnerBool ) public onlyOwner returns(bool){\n', '        changeRecpientIsOwner = changeRecpientIsOwnerBool;\n', '        return true;\n', '    }\n', '\n', '\n', '\n', '      function unwrap(address sourceToken, address destinationToken, uint256 amount) public payable returns( uint256){\n', '\n', '        address originalDestinationToken = destinationToken;\n', '        ERC20 sToken = ERC20(sourceToken);\n', '        if(destinationToken == ETH_TOKEN_ADDRESS){\n', '            destinationToken = WETH_TOKEN_ADDRESS;\n', '        }\n', '        ERC20 dToken = ERC20(destinationToken);\n', '\n', '        if(sourceToken != ETH_TOKEN_ADDRESS){\n', '          require(sToken.transferFrom(msg.sender, address(this), amount), "You have not approved this contract or do not have enough token for this transfer  3 unwrapping");\n', '        }\n', '\n', '        LPERC20 thisLpInfo = LPERC20(sourceToken);\n', '        lpTokenAddressToPairs[sourceToken] = [thisLpInfo.token0(), thisLpInfo.token1()];\n', '\n', '          if(lpTokenAddressToPairs[sourceToken].length !=0){\n', '            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n', '                  sToken.approve(sushiAddress, amount.mul(3));\n', '            }\n', '\n', '          sushiExchange.removeLiquidity(lpTokenAddressToPairs[sourceToken][0], lpTokenAddressToPairs[sourceToken][1], amount, 0,0, address(this), longTimeFromNow);\n', '\n', '          ERC20 pToken1 = ERC20(lpTokenAddressToPairs[sourceToken][0]);\n', '          ERC20 pToken2 = ERC20(lpTokenAddressToPairs[sourceToken][1]);\n', '\n', '          uint256 pTokenBalance = pToken1.balanceOf(address(this));\n', '          uint256 pTokenBalance2 = pToken2.balanceOf(address(this));\n', '\n', '           if(pToken1.allowance(address(this), sushiAddress) < pTokenBalance.mul(2)){\n', '                  pToken1.approve(sushiAddress, pTokenBalance.mul(3));\n', '            }\n', '\n', '            if(pToken2.allowance(address(this), sushiAddress) < pTokenBalance2.mul(2)){\n', '                  pToken2.approve(sushiAddress, pTokenBalance2.mul(3));\n', '            }\n', '\n', '          if(lpTokenAddressToPairs[sourceToken][0] != destinationToken){\n', '              conductUniswap(lpTokenAddressToPairs[sourceToken][0], destinationToken, pTokenBalance);\n', '          }\n', '          if(lpTokenAddressToPairs[sourceToken][1] != destinationToken){\n', '              conductUniswap(lpTokenAddressToPairs[sourceToken][1], destinationToken, pTokenBalance2);\n', '          }\n', '\n', '\n', '          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\n', '\n', '          if(originalDestinationToken == ETH_TOKEN_ADDRESS){\n', '              wethToken.withdraw(destinationTokenBalance);\n', '              if(fee >0){\n', '                  uint256 totalFee = (address(this).balance.mul(fee)).div(10000);\n', '                  if(totalFee >0){\n', '                      owner.transfer(totalFee);\n', '                  }\n', '                  msg.sender.transfer(address(this).balance);\n', '              }\n', '              else{\n', '                msg.sender.transfer(address(this).balance);\n', '              }\n', '          }\n', '          else{\n', '              if(fee >0){\n', '                   uint256 totalFee = (destinationTokenBalance.mul(fee)).div(10000);\n', '                   if(totalFee >0){\n', '                       dToken.transfer(owner, totalFee);\n', '                   }\n', '                   destinationTokenBalance = dToken.balanceOf(address(this));\n', '                   dToken.transfer(msg.sender, destinationTokenBalance);\n', '\n', '              }\n', '              else{\n', '               dToken.transfer(msg.sender, destinationTokenBalance);\n', '              }\n', '          }\n', '\n', '\n', '          return destinationTokenBalance;\n', '\n', '        }\n', '\n', '        else{\n', '\n', '            if(sToken.allowance(address(this), sushiAddress) < amount.mul(2)){\n', '                  sToken.approve(sushiAddress, amount.mul(3));\n', '            }\n', '            if(sourceToken != destinationToken){\n', '                conductUniswap(sourceToken, destinationToken, amount);\n', '            }\n', '          uint256 destinationTokenBalance = dToken.balanceOf(address(this));\n', '          dToken.transfer(msg.sender, destinationTokenBalance);\n', '          return destinationTokenBalance;\n', '        }\n', '\n', '      }\n', '\n', '  function updateOwnerAddress(address payable newOwner) onlyOwner public returns (bool){\n', '     owner = newOwner;\n', '     return true;\n', '   }\n', '\n', '   function updateSushiExchange(address newAddress ) public onlyOwner returns (bool){\n', '\n', '    sushiExchange = SushiV2( newAddress);\n', '    sushiAddress = newAddress;\n', '    return true;\n', '\n', '  }\n', '\n', '  function updateUniswapFactory(address newAddress ) public onlyOwner returns (bool){\n', '\n', '   factory = UniswapFactory( newAddress);\n', '   uniFactoryAddress = newAddress;\n', '   return true;\n', '\n', ' }\n', '\n', '\n', '  function conductUniswap(address sellToken, address buyToken, uint amount) internal returns (uint256 amounts1){\n', '\n', '            if(sellToken ==ETH_TOKEN_ADDRESS && buyToken == WETH_TOKEN_ADDRESS){\n', '                wethToken.deposit{value:msg.value}();\n', '            }\n', '            else if(sellToken == address(0x0)){\n', '\n', '               // address [] memory addresses = new address[](2);\n', '               address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n', '                //addresses[0] = WETH_TOKEN_ADDRESS;\n', '                //addresses[1] = buyToken;\n', '                sushiExchange.swapExactETHForTokens{value:msg.value}(0, addresses, address(this), 1000000000000000 );\n', '\n', '            }\n', '\n', '            else if(sellToken == WETH_TOKEN_ADDRESS){\n', '                wethToken.withdraw(amount);\n', '\n', '                //address [] memory addresses = new address[](2);\n', '                address [] memory addresses = getBestPath(WETH_TOKEN_ADDRESS, buyToken, amount);\n', '                //addresses[0] = WETH_TOKEN_ADDRESS;\n', '                //addresses[1] = buyToken;\n', '                sushiExchange.swapExactETHForTokens{value:amount}(0, addresses, address(this), 1000000000000000 );\n', '\n', '            }\n', '\n', '\n', '\n', '            else{\n', '\n', '          address [] memory addresses = getBestPath(sellToken, buyToken, amount);\n', '           uint256 [] memory amounts = conductUniswapT4T(addresses, amount );\n', '           uint256 resultingTokens = amounts[amounts.length-1];\n', '           return resultingTokens;\n', '            }\n', '    }\n', '\n', '\n', '    //gets the best path to route the transaction on Uniswap\n', '    function getBestPath(address sellToken, address buyToken, uint256 amount) public view returns (address[] memory){\n', '\n', '        address [] memory defaultPath =new address[](2);\n', '        defaultPath[0]=sellToken;\n', '        defaultPath[1] = buyToken;\n', '\n', '\n', '        if(presetPaths[sellToken][buyToken].length !=0){\n', '            return presetPaths[sellToken][buyToken];\n', '        }\n', '\n', '\n', '        if(sellToken == stablecoins["DAI"] || sellToken == stablecoins["USDC"] || sellToken == stablecoins["USDT"]){\n', '            return defaultPath;\n', '        }\n', '        if(buyToken == stablecoins["DAI"] || buyToken == stablecoins["USDC"] || buyToken == stablecoins["USDT"]){\n', '            return defaultPath;\n', '        }\n', '\n', '\n', '\n', '        address[] memory daiPath = new address[](3);\n', '        address[] memory usdcPath =new address[](3);\n', '        address[] memory usdtPath =new address[](3);\n', '\n', '        daiPath[0] = sellToken;\n', '        daiPath[1] = stablecoins["DAI"];\n', '        daiPath[2] = buyToken;\n', '\n', '        usdcPath[0] = sellToken;\n', '        usdcPath[1] = stablecoins["USDC"];\n', '        usdcPath[2] = buyToken;\n', '\n', '        usdtPath[0] = sellToken;\n', '        usdtPath[1] = stablecoins["USDT"];\n', '        usdtPath[2] = buyToken;\n', '\n', '\n', '        uint256 directPathOutput =  getPriceFromUniswap(defaultPath, amount)[1];\n', '\n', '\n', '        uint256[] memory daiPathOutputRaw = getPriceFromUniswap(daiPath, amount);\n', '        uint256[]  memory usdtPathOutputRaw = getPriceFromUniswap(usdtPath, amount);\n', '        uint256[]  memory usdcPathOutputRaw = getPriceFromUniswap(usdcPath, amount);\n', '\n', '        //uint256 directPathOutput = directPathOutputRaw[directPathOutputRaw.length-1];\n', '        uint256 daiPathOutput = daiPathOutputRaw[daiPathOutputRaw.length-1];\n', '        uint256 usdtPathOutput = usdtPathOutputRaw[usdtPathOutputRaw.length-1];\n', '        uint256 usdcPathOutput = usdcPathOutputRaw[usdcPathOutputRaw.length-1];\n', '\n', '        uint256 bestPathOutput = directPathOutput;\n', '        address[] memory bestPath = new address[](2);\n', '        address[] memory bestPath3 = new address[](3);\n', '        //return defaultPath;\n', '        bestPath = defaultPath;\n', '\n', '        bool isTwoPath = true;\n', '\n', '        if(directPathOutput < daiPathOutput){\n', '            isTwoPath=false;\n', '            bestPathOutput = daiPathOutput;\n', '            bestPath3 = daiPath;\n', '        }\n', '        if(bestPathOutput < usdcPathOutput){\n', '            isTwoPath=false;\n', '            bestPathOutput = usdcPathOutput;\n', '            bestPath3 = usdcPath;\n', '        }\n', '         if(bestPathOutput < usdtPathOutput){\n', '             isTwoPath=false;\n', '            bestPathOutput = usdtPathOutput;\n', '            bestPath3 = usdtPath;\n', '        }\n', '\n', '        require(bestPathOutput >0, "This trade will result in getting zero tokens back. Reverting");\n', '\n', '        if(isTwoPath==true){\n', '              return bestPath;\n', '        }\n', '        else{\n', '            return bestPath3;\n', '        }\n', '\n', '\n', '\n', '    }\n', '\n', '    function getPriceFromUniswap(address  [] memory theAddresses, uint amount) public view returns (uint256[] memory amounts1){\n', '\n', '\n', '        try sushiExchange.getAmountsOut(amount,theAddresses ) returns (uint256[] memory amounts){\n', '            return amounts;\n', '        }\n', '        catch  {\n', '            uint256 [] memory amounts2= new uint256[](2);\n', '            amounts2[0]=0;\n', '            amounts2[1]=0;\n', '            return amounts2;\n', '\n', '        }\n', '\n', '    }\n', '\n', '    function conductUniswapT4T(address  [] memory theAddresses, uint amount) internal returns (uint256[] memory amounts1){\n', '\n', '           uint256 deadline = 1000000000000000;\n', '           uint256 [] memory amounts =  sushiExchange.swapExactTokensForTokens(amount, 0, theAddresses, address(this),deadline );\n', '           return amounts;\n', '\n', '    }\n', '\n', '    function adminEmergencyWithdrawTokens(address token, uint amount, address payable destination) public onlyOwner returns(bool) {\n', '\n', '      if (address(token) == ETH_TOKEN_ADDRESS) {\n', '          destination.transfer(amount);\n', '      }\n', '      else {\n', '          ERC20 tokenToken = ERC20(token);\n', '          require(tokenToken.transfer(destination, amount));\n', '      }\n', '      return true;\n', '  }\n', '\n', '\n', '  function setFee(uint256 newFee) public onlyOwner returns (bool){\n', '    require(newFee<=maxfee, "Admin cannot set the fee higher than the current maxfee");\n', '    fee = newFee;\n', '    return true;\n', '  }\n', '\n', '\n', '  function setMaxFee(uint256 newMax) public onlyOwner returns (bool){\n', '    require(maxfee==0, "Admin can only set max fee once and it is perm");\n', '    maxfee = newMax;\n', '    return true;\n', '  }\n', '\n', '  function addLPPair(address lpAddress, address token1, address token2) onlyOwner public returns (bool){\n', '      lpTokenAddressToPairs[lpAddress] = [token1, token2];\n', '      return true;\n', '  }\n', '\n', '  function getLPTokenByPair(address token1, address token2) view public returns (address lpAddr){\n', '      address thisPairAddress = factory.getPair(token1,token2);\n', '      return thisPairAddress;\n', '  }\n', '\n', '   function getUserTokenBalance(address userAddress, address tokenAddress) public view returns (uint256){\n', '    ERC20 token = ERC20(tokenAddress);\n', '    return token.balanceOf(userAddress);\n', '\n', '  }\n', '\n', '}']