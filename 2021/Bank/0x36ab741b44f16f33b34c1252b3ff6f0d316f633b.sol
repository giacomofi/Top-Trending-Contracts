['pragma solidity = 0.5.16;\n', 'import "SafeMath.sol";\n', 'import "Pausable.sol";\n', 'contract Management is Pausable {\n', '    mapping(address => uint8) private _managers;\n', '    modifier isManager{\n', '        require(_managers[msg.sender] == 1, "CALLER_IS_NOT_A_MANAGER");\n', '        _;\n', '    }\n', '\n', '    function addManager(address manager) external onlyOwner {\n', '        _managers[manager] = 1;\n', '    }\n', '\n', '    function removeManager(address manager) external onlyOwner {\n', '        _managers[manager] = 0;\n', '    }\n', '\n', '    function manager(address account) external view returns (bool) {\n', '        return _managers[account] == 1;\n', '    }\n', '}\n', '\n', 'contract YouBridge is Management {\n', '    using SafeMath for uint256;\n', '\n', '    struct Order {\n', '        uint8 toChain;// 1:ETH 2:HECO 3:BSC 4:TRX\n', '        address sender;\n', '        address recipient;\n', '        uint256 amount;\n', '        uint256 fee;\n', '        uint8 state;// 1:WAITING 2:TRANSFERRED 101:CANCELED\n', '    }\n', '\n', '    struct Ledger {\n', '        uint8 fromChain;//1:ETH 2:HECO 3:BSC 4:TRX\n', '        address recipient;\n', '        uint256 amount;\n', '        uint8 state;// 2:TRANSFERRED\n', '        string proof;\n', '    }\n', '\n', '    event OrderConsumed(\n', '        uint256 orderId,\n', '        uint8 fromChain, //1:ETH 2:HECO 3:BSC 4:TRX\n', '        address recipient,\n', '        uint256 amount,\n', '        string proof\n', '    );\n', '\n', '    mapping(uint256 => Order) public orders;\n', '    mapping(uint256 => Ledger) public ledgers;\n', '    address public feeTo;\n', '    uint256 public feeRate = 30;// 30/10000\n', '    uint256 _nonce = 0;\n', '\n', '    uint256 private constant oneDay = 1 days;\n', '    uint256 private _dayBegin;\n', '    uint256 private _limitOfOneDay = 10 ** 10;//200 000YOU\n', '    uint256 private _remainingOfDay;\n', '\n', '    address public constant youToken = 0x1d32916CFA6534D261AD53E2498AB95505bd2510;\n', '\n', '    event Transfer(\n', '        uint256 orderId,\n', '        uint8 chainId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    event Transferred(\n', '        uint256 orderId,\n', '        uint8 chainId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    event OrderCanceled(\n', '        uint256 orderId,\n', '        uint8 chainId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'YouSwap: LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    constructor() public {\n', '        feeTo = 0x19B571eB4FbaD642b08E932055ca0e4dbc32fF69;\n', '        _remainingOfDay = _limitOfOneDay;\n', '        _dayBegin = 1617984000;\n', '    }\n', '\n', '    function limitOfOneDay() external view returns (uint256) {\n', '        return _limitOfOneDay;\n', '    }\n', '\n', '    function remainingOfDay() external view returns (uint256) {\n', '        if (now.sub(_dayBegin) > oneDay) {\n', '            return _limitOfOneDay;\n', '        }\n', '        return _remainingOfDay;\n', '    }\n', '\n', '    function setLimitOfOneDay(uint256 newVal) onlyOwner external {\n', "        require(newVal >= 10 ** 9, 'YouSwap:1000YOU_AT_LEAST');\n", '        _limitOfOneDay = newVal;\n', '    }\n', '\n', '    function setFeeTo(address account) onlyOwner external {\n', '        feeTo = account;\n', '    }\n', '\n', '    function setFeeRate(uint256 rate) onlyOwner external {\n', "        require(rate < 10000, 'YouSwap: NOT_ALLOWED');\n", '        feeRate = rate;\n', '    }\n', '\n', '    function exchange(uint8 chainId, address recipient, uint256 amount) external lock whenNotPaused returns (bool)  {\n', "        require(amount >= 10 ** 9, 'YouSwap:1000YOU_AT_LEAST');\n", '        if (now.sub(_dayBegin) > oneDay) {\n', '            _remainingOfDay = _limitOfOneDay;\n', '            uint256 deltaDays = now.sub(_dayBegin).div(oneDay);\n', '            _dayBegin = _dayBegin.add(oneDay.mul(deltaDays));\n', '        }\n', '\n', '        _remainingOfDay = _remainingOfDay.sub(amount);\n', "        require(_remainingOfDay >= 0, 'YouSwap:EXCEEDS_THE_LIMIT_OF_ONE_DAY');\n", '\n', '        uint256 orderId = ++_nonce;\n', '        Order storage order = orders[orderId];\n', "        require(order.state == 0, 'YouSwap:FORBIDDEN');\n", '\n', '        order.toChain = chainId;\n', '        order.state = 1;\n', '        order.sender = msg.sender;\n', '        order.recipient = recipient;\n', '        order.fee = amount.mul(feeRate).div(10000);\n', '        order.amount = amount.sub(order.fee);\n', '\n', '        _burnFrom(msg.sender, order.amount);\n', '        _transferFrom(msg.sender, feeTo, order.fee);\n', '\n', '        emit Transfer(orderId, chainId, order.sender, order.recipient, order.amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function cancelOrder(uint256 orderId) public onlyOwner whenPaused returns (bool)  {\n', '        Order storage order = orders[orderId];\n', "        require(order.state == 1, 'YouSwap:FORBIDDEN');\n", '        order.state = 101;\n', '\n', '        _mint(order.sender, order.amount);\n', '        emit OrderCanceled(orderId, order.toChain, order.recipient, order.amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function completeOrder(uint256 orderId) isManager public returns (bool)  {\n', '        Order storage order = orders[orderId];\n', "        require(order.state == 1, 'YouSwap:NOT_AVAILABLE');\n", '        order.state = 2;\n', '        emit Transferred(orderId, order.toChain, order.sender, order.recipient, order.amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function completeOrders(uint256[] calldata orderIds) external returns (bool)  {\n', "        require(orderIds.length < 256, 'YouSwap:NOT_ALLOWED');\n", '        for (uint8 i = 0; i < orderIds.length; i++) {\n', '            completeOrder(orderIds[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function consumeOrder(uint256 orderId, uint8 fromChain, address recipient, uint256 amount, string calldata proof, bytes32 orderHash) isManager external lock whenNotPaused {\n', '        require(orderHash == keccak256((abi.encodePacked(orderId, fromChain, recipient, amount, proof))), "YouSwap:WRONG_ORDER_HASH");\n', '        Ledger storage ledger = ledgers[orderId];\n', "        require(ledger.state != 2, 'YouSwap:CONSUMED_ALREADY');\n", '        ledger.fromChain = fromChain;\n', '        ledger.recipient = recipient;\n', '        ledger.amount = amount;\n', '        ledger.state = 2;\n', '        ledger.proof = proof;\n', '\n', '        _mint(recipient, amount);\n', '        emit OrderConsumed(orderId, fromChain, recipient, amount, proof);\n', '    }\n', '\n', '    function _mint(address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('mint(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = youToken.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: MINT_FAILED');\n", '    }\n', '\n', '    function _burnFrom(address account, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('burnFrom(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = youToken.call(abi.encodeWithSelector(methodId, account, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: BURN_FROM_FAILED');\n", '    }\n', '\n', '    function _transferFrom(address sender, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = youToken.call(abi.encodeWithSelector(methodId, sender, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function _transfer(address recipient, uint amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = youToken.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FAILED');\n", '    }\n', '}']