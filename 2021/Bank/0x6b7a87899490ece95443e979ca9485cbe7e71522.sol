['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-18\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at FtmScan.com on 2021-05-31\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at BscScan.com on 2021-04-15\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at BscScan.com on 2021-04-08\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at hecoinfo.com on 2021-04-08\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface ISushiswapV2Pair {\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMathSushiswap {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'library SushiswapV2Library {\n', '    using SafeMathSushiswap for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint160(uint256(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n", '            )))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferNative(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'interface IwNATIVE {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', 'interface AnyswapV1ERC20 {\n', '    function mint(address to, uint256 amount) external returns (bool);\n', '    function burn(address from, uint256 amount) external returns (bool);\n', '    function changeVault(address newVault) external returns (bool);\n', '    function depositVault(uint amount, address to) external returns (uint);\n', '    function withdrawVault(address from, uint amount, address to) external returns (uint);\n', '    function underlying() external view returns (address);\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract AnyswapV4Router {\n', '    using SafeMathSushiswap for uint;\n', '\n', '    address public immutable factory;\n', '    address public immutable wNATIVE;\n', '\n', '    modifier ensure(uint deadline) {\n', "        require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n", '        _;\n', '    }\n', '\n', '    constructor(address _factory, address _wNATIVE, address _mpc) {\n', '        _newMPC = _mpc;\n', '        _newMPCEffectiveTime = block.timestamp;\n', '        factory = _factory;\n', '        wNATIVE = _wNATIVE;\n', '    }\n', '\n', '    receive() external payable {\n', '        assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n', '    }\n', '\n', '    address private _oldMPC;\n', '    address private _newMPC;\n', '    uint256 private _newMPCEffectiveTime;\n', '\n', '\n', '    event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n', '    event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n', '    event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n', '    event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n', '    event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n', '    event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n', '\n', '    modifier onlyMPC() {\n', '        require(msg.sender == mpc(), "AnyswapV3Router: FORBIDDEN");\n', '        _;\n', '    }\n', '\n', '    function mpc() public view returns (address) {\n', '        if (block.timestamp >= _newMPCEffectiveTime) {\n', '            return _newMPC;\n', '        }\n', '        return _oldMPC;\n', '    }\n', '\n', '    function cID() public view returns (uint id) {\n', '        assembly {id := chainid()}\n', '    }\n', '\n', '    function changeMPC(address newMPC) public onlyMPC returns (bool) {\n', '        require(newMPC != address(0), "AnyswapV3Router: address(0x0)");\n', '        _oldMPC = mpc();\n', '        _newMPC = newMPC;\n', '        _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n', '        emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n', '        return true;\n', '    }\n', '\n', '    function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n', '        require(newVault != address(0), "AnyswapV3Router: address(0x0)");\n', '        return AnyswapV1ERC20(token).changeVault(newVault);\n', '    }\n', '\n', '    function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n', '        AnyswapV1ERC20(token).burn(from, amount);\n', '        emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n', '    }\n', '\n', '    // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n', '    function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n', '        _anySwapOut(msg.sender, token, to, amount, toChainID);\n', '    }\n', '\n', '    // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n', '    function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n', '        TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n', '        AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n', '        _anySwapOut(msg.sender, token, to, amount, toChainID);\n', '    }\n', '\n', '    function anySwapOutUnderlyingWithPermit(\n', '        address from,\n', '        address token,\n', '        address to,\n', '        uint amount,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external {\n', '        address _underlying = AnyswapV1ERC20(token).underlying();\n', '        IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n', '        TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n', '        AnyswapV1ERC20(token).depositVault(amount, from);\n', '        _anySwapOut(from, token, to, amount, toChainID);\n', '    }\n', '\n', '    function anySwapOutUnderlyingWithTransferPermit(\n', '        address from,\n', '        address token,\n', '        address to,\n', '        uint amount,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external {\n', '        IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n', '        AnyswapV1ERC20(token).depositVault(amount, from);\n', '        _anySwapOut(from, token, to, amount, toChainID);\n', '    }\n', '\n', '    function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n', '        }\n', '    }\n', '\n', '    // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n', '    function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n', '        AnyswapV1ERC20(token).mint(to, amount);\n', '        emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n', '    }\n', '\n', '    // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n', '    // triggered by `anySwapOut`\n', '    function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n', '        _anySwapIn(txs, token, to, amount, fromChainID);\n', '    }\n', '\n', '    // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n', '    function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n', '        _anySwapIn(txs, token, to, amount, fromChainID);\n', '        AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n', '    }\n', '\n', '    // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n', '    function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n', '        _anySwapIn(txs, token, to, amount, fromChainID);\n', '        AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n', '        address _underlying = _anyToken.underlying();\n', '        if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n', '            _anyToken.withdrawVault(to, amount, to);\n', '        }\n', '    }\n', '\n', '    // extracts mpc fee from bridge fees\n', '    function anySwapFeeTo(address token, uint amount) external onlyMPC {\n', '        address _mpc = mpc();\n', '        AnyswapV1ERC20(token).mint(_mpc, amount);\n', '        AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n', '    }\n', '\n', '    function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n', '        }\n', '    }\n', '\n', '    // **** SWAP ****\n', '    // requires the initial amount to have already been sent to the first pair\n', '    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0,) = SushiswapV2Library.sortTokens(input, output);\n', '            uint amountOut = amounts[i + 1];\n', '            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n', '            address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n', '            ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n', '                amount0Out, amount1Out, to, new bytes(0)\n', '            );\n', '        }\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n', '        emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForTokensUnderlying(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n', '        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n', '        emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n', '        address from,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        address _underlying = AnyswapV1ERC20(path[0]).underlying();\n', '        IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n', '        TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n', '        AnyswapV1ERC20(path[0]).burn(from, amountIn);\n', '        {\n', '        address[] memory _path = path;\n', '        address _from = from;\n', '        address _to = to;\n', '        uint _amountIn = amountIn;\n', '        uint _amountOutMin = amountOutMin;\n', '        uint _cID = cID();\n', '        uint _toChainID = toChainID;\n', '        emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n', '        }\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n', '        address from,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n', '        AnyswapV1ERC20(path[0]).burn(from, amountIn);\n', '        emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n', '    // Triggered by `anySwapOutExactTokensForTokens`\n', '    function anySwapInExactTokensForTokens(\n', '        bytes32 txs,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint fromChainID\n', '    ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n', '        amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n', '        _swap(amounts, path, to);\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForNative(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n', '        emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForNativeUnderlying(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n', '        AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n', '        emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n', '        address from,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        address _underlying = AnyswapV1ERC20(path[0]).underlying();\n', '        IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n', '        TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n', '        AnyswapV1ERC20(path[0]).burn(from, amountIn);\n', '        {\n', '        address[] memory _path = path;\n', '        address _from = from;\n', '        address _to = to;\n', '        uint _amountIn = amountIn;\n', '        uint _amountOutMin = amountOutMin;\n', '        uint _cID = cID();\n', '        uint _toChainID = toChainID;\n', '        emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n', '        }\n', '    }\n', '\n', '    // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n', '    function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n', '        address from,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint toChainID\n', '    ) external virtual ensure(deadline) {\n', '        IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n', '        AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n', '        AnyswapV1ERC20(path[0]).burn(from, amountIn);\n', '        emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n', '    }\n', '\n', '    // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n', '    // Triggered by `anySwapOutExactTokensForNative`\n', '    function anySwapInExactTokensForNative(\n', '        bytes32 txs,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline,\n', '        uint fromChainID\n', '    ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n', "        require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n", '        amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n", '        _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n', '        _swap(amounts, path, address(this));\n', '        IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n', '        TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n', '    }\n', '\n', '    // **** LIBRARY FUNCTIONS ****\n', '    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n', '        return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n', '    }\n', '\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n', '        public\n', '        pure\n', '        virtual\n', '        returns (uint amountOut)\n', '    {\n', '        return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n', '        public\n', '        pure\n', '        virtual\n', '        returns (uint amountIn)\n', '    {\n', '        return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n', '    }\n', '\n', '    function getAmountsOut(uint amountIn, address[] memory path)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint[] memory amounts)\n', '    {\n', '        return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n', '    }\n', '\n', '    function getAmountsIn(uint amountOut, address[] memory path)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint[] memory amounts)\n', '    {\n', '        return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n', '    }\n', '}']