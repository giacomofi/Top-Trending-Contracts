['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', 'pragma solidity 0.8.1; // optimization runs: 200, evm version: istanbul\n', '\n', 'interface ITypes {\n', '  struct Call {\n', '    address to;\n', '    uint96 value;\n', '    bytes data;\n', '  }\n', '\n', '  struct CallReturn {\n', '    bool ok;\n', '    bytes returnData;\n', '  }\n', '}\n', '\n', 'interface IActionRegistry {\n', '\n', '  // events\n', '  event AddedSelector(address account, bytes4 selector);\n', '  event RemovedSelector(address account, bytes4 selector);\n', '  event AddedSpender(address account, address spender);\n', '  event RemovedSpender(address account, address spender);\n', '\n', '  struct AccountSelectors {\n', '    address account;\n', '    bytes4[] selectors;\n', '  }\n', '\n', '  struct AccountSpenders {\n', '    address account;\n', '    address[] spenders;\n', '  }\n', '\n', '  function isValidAction(ITypes.Call[] calldata calls) external view returns (bool valid);\n', '  function addSelector(address account, bytes4 selector) external;\n', '  function removeSelector(address account, bytes4 selector) external;\n', '  function addSpender(address account, address spender) external;\n', '  function removeSpender(address account, address spender) external;\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' *\n', ' * In order to transfer ownership, a recipient must be specified, at which point\n', ' * the specified recipient can call `acceptOwnership` and take ownership.\n', ' */\n', '\n', 'contract TwoStepOwnable {\n', '  address private _owner;\n', '\n', '  address private _newPotentialOwner;\n', '\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev Initialize contract by setting transaction submitter as initial owner.\n', '   */\n', '  constructor() public {\n', '    _owner = tx.origin;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "TwoStepOwnable: caller is not the owner.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns true if the caller is the current owner.\n', '   */\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows a new account (`newOwner`) to accept ownership.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(\n', '      newOwner != address(0),\n', '      "TwoStepOwnable: new potential owner is the zero address."\n', '    );\n', '\n', '    _newPotentialOwner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Cancel a transfer of ownership to a new account.\n', '   * Can only be called by the current owner.\n', '   */\n', '  function cancelOwnershipTransfer() public onlyOwner {\n', '    delete _newPotentialOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to the caller.\n', '   * Can only be called by a new potential owner set by the current owner.\n', '   */\n', '  function acceptOwnership() public {\n', '    require(\n', '      msg.sender == _newPotentialOwner,\n', '      "TwoStepOwnable: current owner must set caller as new potential owner."\n', '    );\n', '\n', '    delete _newPotentialOwner;\n', '\n', '    emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '    _owner = msg.sender;\n', '  }\n', '}\n', '\n', 'interface DharmaTradeReserveV18Interface {\n', '  event Trade(\n', '    address account,\n', '    address suppliedAsset,\n', '    address receivedAsset,\n', '    address retainedAsset,\n', '    uint256 suppliedAmount,\n', '    uint256 recievedAmount, // note: typo\n', '    uint256 retainedAmount\n', '  );\n', '  event RoleModified(Role indexed role, address account);\n', '  event RolePaused(Role indexed role);\n', '  event RoleUnpaused(Role indexed role);\n', '  event EtherReceived(address sender, uint256 amount);\n', '  event GasReserveRefilled(uint256 etherAmount);\n', '\n', '  enum Role {            //\n', '    DEPOSIT_MANAGER,     // 0\n', '    ADJUSTER,            // 1\n', '    WITHDRAWAL_MANAGER,  // 2\n', '    RESERVE_TRADER,      // 3\n', '    PAUSER,              // 4\n', '    GAS_RESERVE_REFILLER, // 5\n', '    ACTIONER // 6\n', '  }\n', '\n', '  enum FeeType {    // #\n', '    SUPPLIED_ASSET, // 0\n', '    RECEIVED_ASSET, // 1\n', '    ETHER           // 2\n', '  }\n', '\n', '  enum TradeType {\n', '    ETH_TO_TOKEN,\n', '    TOKEN_TO_ETH,\n', '    TOKEN_TO_TOKEN,\n', '    ETH_TO_TOKEN_WITH_TRANSFER_FEE,\n', '    TOKEN_TO_ETH_WITH_TRANSFER_FEE,\n', '    TOKEN_TO_TOKEN_WITH_TRANSFER_FEE\n', '  }\n', '\n', '  struct RoleStatus {\n', '    address account;\n', '    bool paused;\n', '  }\n', '\n', '  function simulate(\n', '    ITypes.Call[] calldata calls\n', '  ) external returns (bool[] memory ok, bytes[] memory returnData, bool validCalls);\n', '\n', '  function execute(\n', '    ITypes.Call[] calldata calls\n', '  ) external returns (bool[] memory ok, bytes[] memory returnData);\n', '\n', '  event CallSuccess(\n', '    bool rolledBack,\n', '    address to,\n', '    uint256 value,\n', '    bytes data,\n', '    bytes returnData\n', '  );\n', '\n', '  event CallFailure(\n', '    address to,\n', '    uint256 value,\n', '    bytes data,\n', '    string revertReason\n', '  );\n', '\n', '  function tradeTokenForTokenSpecifyingFee(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForTokenWithFeeOnTransfer(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee,\n', '    uint256 deadline,\n', '    bool routeThroughEther\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForTokenWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface tokenProvidedFromReserves,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmountFromReserves,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForEtherWithFeeOnTransfer(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 deadline\n', '  ) external returns (uint256 totalEtherBought);\n', '\n', '  function tradeTokenForEtherWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalEtherBought);\n', '\n', '  function tradeTokenForEtherUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmountFromReserves,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalEtherBought);\n', '\n', '  function tradeTokenForEtherSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalEtherBought);\n', '\n', '  function tradeEtherForTokenWithFeeOnTransfer(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 deadline\n', '  ) external payable returns (uint256 totalTokensBought);\n', '\n', '  function tradeEtherForTokenSpecifyingFee(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external payable returns (uint256 totalTokensBought);\n', '\n', '  function tradeEtherForTokenWithFeeOnTransferSpecifyingFee(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external payable returns (uint256 totalTokensBought);\n', '\n', '  function tradeEtherForTokenWithFeeOnTransferUsingEtherizer(\n', '    address token,\n', '    uint256 etherAmount,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 deadline\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForTokenUsingReservesSpecifyingFee(\n', '    ERC20Interface tokenProvidedFromReserves,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmountFromReserves,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeEtherForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    address token,\n', '    uint256 etherAmountFromReserves,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function tradeTokenForEtherUsingReservesSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmountFromReserves,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalEtherBought);\n', '\n', '  function tradeEtherForTokenUsingReservesSpecifyingFee(\n', '    address token,\n', '    uint256 etherAmountFromReserves,\n', '    uint256 quotedTokenAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external returns (uint256 totalTokensBought);\n', '\n', '  function finalizeEtherDeposit(\n', '    address payable smartWallet,\n', '    address initialUserSigningKey,\n', '    uint256 etherAmount\n', '  ) external;\n', '\n', '  function finalizeTokenDeposit(\n', '    address smartWallet,\n', '    address initialUserSigningKey,\n', '    ERC20Interface token,\n', '    uint256 amount\n', '  ) external;\n', '\n', '  function refillGasReserve(uint256 etherAmount) external;\n', '\n', '  function withdrawUSDCToPrimaryRecipient(uint256 usdcAmount) external;\n', '\n', '  function withdrawDaiToPrimaryRecipient(uint256 usdcAmount) external;\n', '\n', '  function withdrawEther(\n', '    address payable recipient, uint256 etherAmount\n', '  ) external;\n', '\n', '  function withdraw(\n', '    ERC20Interface token, address recipient, uint256 amount\n', '  ) external returns (bool success);\n', '\n', '  function callAny(\n', '    address payable target, uint256 amount, bytes calldata data\n', '  ) external returns (bool ok, bytes memory returnData);\n', '\n', '  function setPrimaryUSDCRecipient(address recipient) external;\n', '\n', '  function setPrimaryDaiRecipient(address recipient) external;\n', '\n', '  function setRole(Role role, address account) external;\n', '\n', '  function removeRole(Role role) external;\n', '\n', '  function pause(Role role) external;\n', '\n', '  function unpause(Role role) external;\n', '\n', '  function isPaused(Role role) external view returns (bool paused);\n', '\n', '  function isRole(Role role) external view returns (bool hasRole);\n', '\n', '  function isDharmaSmartWallet(\n', '    address smartWallet, address initialUserSigningKey\n', '  ) external view returns (bool dharmaSmartWallet);\n', '\n', '  function getDepositManager() external view returns (address depositManager);\n', '\n', '  function getReserveTrader() external view returns (address reserveTrader);\n', '\n', '  function getWithdrawalManager() external view returns (\n', '    address withdrawalManager\n', '  );\n', '\n', '  function getActioner() external view returns (\n', '    address actioner\n', '  );\n', '\n', '  function getPauser() external view returns (address pauser);\n', '\n', '  function getGasReserveRefiller() external view returns (\n', '    address gasReserveRefiller\n', '  );\n', '\n', '  function getPrimaryUSDCRecipient() external view returns (\n', '    address recipient\n', '  );\n', '\n', '  function getPrimaryDaiRecipient() external view returns (\n', '    address recipient\n', '  );\n', '\n', '  function getImplementation() external view returns (address implementation);\n', '\n', '  function getInstance() external pure returns (address instance);\n', '\n', '  function getVersion() external view returns (uint256 version);\n', '}\n', '\n', 'interface ERC20Interface {\n', '  function balanceOf(address) external view returns (uint256);\n', '  function approve(address, uint256) external returns (bool);\n', '  function allowance(address, address) external view returns (uint256);\n', '  function transfer(address, uint256) external returns (bool);\n', '  function transferFrom(address, address, uint256) external returns (bool);\n', '}\n', '\n', '\n', 'interface DTokenInterface {\n', '  function balanceOf(address) external view returns (uint256);\n', '  function balanceOfUnderlying(address) external view returns (uint256);\n', '  function transfer(address, uint256) external returns (bool);\n', '  function approve(address, uint256) external returns (bool);\n', '  function exchangeRateCurrent() external view returns (uint256);\n', '}\n', '\n', '\n', 'interface UniswapV2Interface {\n', '  function swapTokensForExactTokens(\n', '    uint256 amountOut,\n', '    uint256 amountInMax,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '\n', '  function swapExactTokensForTokens(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '\n', '  function swapExactTokensForETH(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '\n', '  function swapTokensForExactETH(\n', '    uint256 amountOut,\n', '    uint256 amountInMax,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '\n', '  function swapETHForExactTokens(\n', '    uint256 amountOut,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external payable returns (uint256[] memory amounts);\n', '\n', '  function swapExactETHForTokens(\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external payable returns (uint256[] memory amounts);\n', '\n', '  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external;\n', '\n', '  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external;\n', '\n', '  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external payable;\n', '}\n', '\n', 'library SafeMath {\n', '  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title DharmaTradeReserveV18Implementation\n', ' * @author 0age\n', " * @notice This contract manages Dharma's reserves. It designates a collection of\n", ' * "roles" - these are dedicated accounts that can be modified by the owner, and\n', ' * that can trigger specific functionality on the reserve. These roles are:\n', ' *  - depositManager (0): initiates Eth / token transfers to smart wallets\n', ' *  - adjuster (1): mints / redeems Dai, and swaps USDC, for dDai\n', ' *  - withdrawalManager (2): initiates token transfers to recipients set by owner\n', ' *  - reserveTrader (3): initiates trades using funds held in reserve\n', ' *  - pauser (4): pauses any role (only the owner is then able to unpause it)\n', ' *  - gasReserveRefiller (5): transfers Ether to the Dharma Gas Reserve\n', ' *\n', ' * When finalizing deposits, the deposit manager must adhere to two constraints:\n', ' *  - it must provide "proof" that the recipient is a smart wallet by including\n', ' *    the initial user signing key used to derive the smart wallet address\n', ' *\n', ' * Note that "proofs" can be validated via `isSmartWallet`.\n', ' */\n', 'contract DharmaTradeReserveV18ImplementationStaging is DharmaTradeReserveV18Interface, TwoStepOwnable {\n', '  using SafeMath for uint256;\n', '\n', '  // Maintain a role status mapping with assigned accounts and paused states.\n', '  mapping(uint256 => RoleStatus) private _roles;\n', '\n', '  // Maintain a "primary recipient" the withdrawal manager can transfer Dai to.\n', '  address private _primaryDaiRecipient;\n', '\n', '  // Maintain a "primary recipient" the withdrawal manager can transfer USDC to.\n', '  address private _primaryUSDCRecipient;\n', '\n', '  // Maintain a maximum allowable transfer size (in Dai) for the deposit manager.\n', '  uint256 private _daiLimit; // unused\n', '\n', '  // Maintain a maximum allowable transfer size (in Ether) for the deposit manager.\n', '  uint256 private _etherLimit; // unused\n', '\n', "  bool private _originatesFromReserveTrader; // unused, don't change storage layout\n", '\n', '  bytes4 internal _selfCallContext;\n', '\n', '  uint256 private constant _VERSION = 1018;\n', '\n', '  // This contract interacts with USDC, Dai, and Dharma Dai.\n', '  ERC20Interface internal constant _USDC = ERC20Interface(\n', '    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 // mainnet\n', '  );\n', '\n', '  ERC20Interface internal constant _DAI = ERC20Interface(\n', '    0x6B175474E89094C44Da98b954EedeAC495271d0F // mainnet\n', '  );\n', '\n', '  ERC20Interface internal constant _ETHERIZER = ERC20Interface(\n', '    0x723B51b72Ae89A3d0c2a2760f0458307a1Baa191\n', '  );\n', '\n', '  DTokenInterface internal constant _DDAI = DTokenInterface(\n', '    0x00000000001876eB1444c986fD502e618c587430\n', '  );\n', '\n', '  UniswapV2Interface internal constant _UNISWAP_ROUTER = UniswapV2Interface(\n', '    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '  );\n', '\n', '  address internal constant _WETH = address(\n', '    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', '  );\n', '\n', '  address internal constant _GAS_RESERVE = address(\n', '    0x09cd826D4ABA4088E1381A1957962C946520952d\n', '  );\n', '\n', '  // The "Create2 Header" is used to compute smart wallet deployment addresses.\n', '  bytes21 internal constant _CREATE2_HEADER = bytes21(\n', '    0xff8D1e00b000e56d5BcB006F3a008Ca6003b9F0033 // control character + factory\n', '  );\n', '\n', '  // The "Wallet creation code" header & footer are also used to derive wallets.\n', '  bytes internal constant _WALLET_CREATION_CODE_HEADER = hex"60806040526040516104423803806104428339818101604052602081101561002657600080fd5b810190808051604051939291908464010000000082111561004657600080fd5b90830190602082018581111561005b57600080fd5b825164010000000081118282018810171561007557600080fd5b82525081516020918201929091019080838360005b838110156100a257818101518382015260200161008a565b50505050905090810190601f1680156100cf5780820380516001836020036101000a031916815260200191505b5060405250505060006100e661019e60201b60201c565b6001600160a01b0316826040518082805190602001908083835b6020831061011f5780518252601f199092019160209182019101610100565b6001836020036101000a038019825116818451168082178552505050505050905001915050600060405180830381855af49150503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b5050905080610197573d6000803e3d6000fd5b50506102be565b60405160009081906060906eb45d6593312ac9fde193f3d06336449083818181855afa9150503d80600081146101f0576040519150601f19603f3d011682016040523d82523d6000602084013e6101f5565b606091505b509150915081819061029f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561026457818101518382015260200161024c565b50505050905090810190601f1680156102915780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b508080602001905160208110156102b557600080fd5b50519392505050565b610175806102cd6000396000f3fe608060405261001461000f610016565b61011c565b005b60405160009081906060906eb45d6593312ac9fde193f3d06336449083818181855afa9150503d8060008114610068576040519150601f19603f3d011682016040523d82523d6000602084013e61006d565b606091505b50915091508181906100fd5760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156100c25781810151838201526020016100aa565b50505050905090810190601f1680156100ef5780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5080806020019051602081101561011357600080fd5b50519392505050565b3660008037600080366000845af43d6000803e80801561013b573d6000f35b3d6000fdfea265627a7a723158203c578cc1552f1d1b48134a72934fe12fb89a29ff396bd514b9a4cebcacc5cacc64736f6c634300050b003200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024c4d66de8000000000000000000000000";\n', '\n', '  bytes28 internal constant _WALLET_CREATION_CODE_FOOTER = bytes28(\n', '    0x00000000000000000000000000000000000000000000000000000000\n', '  );\n', '\n', '  // Flag to trigger trade for USDC and retain full trade amount\n', '  address internal constant _TRADE_FOR_USDC_AND_RETAIN_FLAG = address(type(uint160).max);\n', '\n', '  // The "action registry" keeps track of function-selectors and approved spenders\n', '  // allowed in the generic call execution flow.\n', '  IActionRegistry public immutable _ACTION_REGISTRY;\n', '\n', '  address private constant V17_STAGING = address(\n', '    0x1C2c285A9B4a5985120D5493C8Aa24C347d0B2A9\n', '  );\n', '\n', '  // Include a payable fallback so that the contract can receive Ether payments.\n', '  receive() external payable {\n', '    emit EtherReceived(msg.sender, msg.value);\n', '  }\n', '\n', '  constructor(address actionRegistryAddress) public {\n', '    _ACTION_REGISTRY = IActionRegistry(actionRegistryAddress);\n', '  }\n', '\n', '  /**\n', '  * @notice Simulate a series of generic calls to other contracts.\n', '  * Calls will be rolled back (and calls will only be\n', '  * simulated up until a failing call is encountered).\n', '  * @param calls Call[] A struct containing the target, value, and calldata to\n', '  * provide when making each call.\n', '  * return An array of structs signifying the status of each call, as well as\n', '  * any data returned from that call. Calls that are not executed will return\n', '  * empty data.\n', '  */\n', '  function simulate(\n', '    ITypes.Call[] calldata calls\n', '  ) external override returns (bool[] memory ok, bytes[] memory returnData, bool validCalls) {\n', '    // Ensure all calls are valid\n', '    validCalls = _ACTION_REGISTRY.isValidAction(calls);\n', '\n', '    // Specify length of returned values in order to work with them in memory.\n', '    ok = new bool[](calls.length);\n', '    returnData = new bytes[](calls.length);\n', '\n', '    // Make the atomic self-call - if any call fails, calls that preceded it\n', '    // will be rolled back and calls that follow it will not be made.\n', '    (, bytes memory rawCallResults) = address(this).call(\n', '      abi.encodeWithSelector(\n', '        this._simulate.selector, calls\n', '      )\n', '    );\n', '\n', '    // Parse data returned from self-call into each call result and store / log.\n', '    ITypes.CallReturn[] memory callResults = abi.decode(rawCallResults, (ITypes.CallReturn[]));\n', '    for (uint256 i = 0; i < callResults.length; i++) {\n', '      // Set the status and the return data / revert reason from the call.\n', '      ok[i] = callResults[i].ok;\n', '      returnData[i] = callResults[i].returnData;\n', '\n', '      if (!callResults[i].ok) {\n', '        // exit early - any calls after the first failed call will not execute.\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Protected function that can only be called from\n', '  * `simulateActionWithAtomicBatchCalls` on this contract. It will attempt to\n', '  * perform each specified call, populating the array of results as it goes,\n', '  * unless a failure occurs, at which point it will revert and "return" the\n', '  * array of results as revert data. Regardless, it will roll back all calls at\n', '  * the end of execution â€” in other words, this call always reverts.\n', '  * @param calls Call[] A struct containing the target, value, and calldata to\n', '  * provide when making each call.\n', '  * return An array of structs signifying the status of each call, as well as\n', '  * any data returned from that call. Calls that are not executed will return\n', '  * empty data. If any of the calls fail, the array will be returned as revert\n', '  * data.\n', '  */\n', '  function _simulate(\n', '    ITypes.Call[] memory calls\n', '  ) public returns (ITypes.CallReturn[] memory callResults) {\n', '\n', '    callResults = new ITypes.CallReturn[](calls.length);\n', '\n', '    for (uint256 i = 0; i < calls.length; i++) {\n', '      // Perform low-level call and set return values using result.\n', '      (bool ok, bytes memory returnData) = calls[i].to.call{value:\n', '        uint256(calls[i].value)\n', '      }(calls[i].data);\n', '      callResults[i] = ITypes.CallReturn({ok: ok, returnData: returnData});\n', '      if (!ok) {\n', '        // Exit early - any calls after the first failed call will not execute.\n', '        break;\n', '      }\n', '    }\n', '    // Wrap in length encoding and revert (provide bytes instead of a string).\n', '    bytes memory callResultsBytes = abi.encode(callResults);\n', '    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\n', '  }\n', '\n', '  function execute(\n', '    ITypes.Call[] memory calls\n', '  ) public onlyOwnerOr(Role.ACTIONER) override returns (bool[] memory ok, bytes[] memory returnData) {\n', '    // Ensure all calls are valid\n', '    bool validCalls = _ACTION_REGISTRY.isValidAction(calls);\n', '\n', '    require(validCalls, "Invalid call detected!");\n', '\n', '    // Note: from this point on, there are no reverts (apart from out-of-gas or\n', '    // call-depth-exceeded) originating from this contract. However, one of the\n', '    // calls may revert, in which case the function will return `false`, along\n', '    // with the revert reason encoded as bytes, and fire a CallFailure event.\n', '\n', '    // Specify length of returned values in order to work with them in memory.\n', '    ok = new bool[](calls.length);\n', '    returnData = new bytes[](calls.length);\n', '\n', '    // Set self-call context to call _execute.\n', '    _selfCallContext = this.execute.selector;\n', '\n', '    // Make the atomic self-call - if any call fails, calls that preceded it\n', '    // will be rolled back and calls that follow it will not be made.\n', '    (bool externalOk, bytes memory rawCallResults) = address(this).call(\n', '      abi.encodeWithSelector(\n', '        this._execute.selector, calls\n', '      )\n', '    );\n', '\n', '    // Ensure that self-call context has been cleared.\n', '    if (!externalOk) {\n', '      delete _selfCallContext;\n', '    }\n', '\n', '    // Parse data returned from self-call into each call result and store / log.\n', '    ITypes.CallReturn[] memory callResults = abi.decode(rawCallResults, (ITypes.CallReturn[]));\n', '    for (uint256 i = 0; i < callResults.length; i++) {\n', '      ITypes.Call memory currentCall = calls[i];\n', '\n', '      // Set the status and the return data / revert reason from the call.\n', '      ok[i] = callResults[i].ok;\n', '      returnData[i] = callResults[i].returnData;\n', '\n', '      // Emit CallSuccess or CallFailure event based on the outcome of the call.\n', '      if (callResults[i].ok) {\n', '        // Note: while the call succeeded, the action may still have "failed".\n', '        emit CallSuccess(\n', '          !externalOk, // If another call failed this will have been rolled back\n', '          currentCall.to,\n', '          uint256(currentCall.value),\n', '          currentCall.data,\n', '          callResults[i].returnData\n', '        );\n', '      } else {\n', '        // Note: while the call failed, the nonce will still be incremented,\n', '        // which will invalidate all supplied signatures.\n', '        emit CallFailure(\n', '          currentCall.to,\n', '          uint256(currentCall.value),\n', '          currentCall.data,\n', '          _decodeRevertReason(callResults[i].returnData)\n', '        );\n', '\n', '        // exit early - any calls after the first failed call will not execute.\n', '        break;\n', '      }\n', '    }\n', '  }\n', '\n', '  function _execute(\n', '    ITypes.Call[] memory calls\n', '  ) public returns (ITypes.CallReturn[] memory callResults) {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    _enforceSelfCallFrom(this.execute.selector);\n', '\n', '    bool rollBack = false;\n', '    callResults = new ITypes.CallReturn[](calls.length);\n', '\n', '    for (uint256 i = 0; i < calls.length; i++) {\n', '      // Perform low-level call and set return values using result.\n', '      (bool ok, bytes memory returnData) = calls[i].to.call{value:\n', '        uint256(calls[i].value)\n', '      }(calls[i].data);\n', '      callResults[i] = ITypes.CallReturn({ok: ok, returnData: returnData});\n', '      if (!ok) {\n', '        // Exit early - any calls after the first failed call will not execute.\n', '        rollBack = true;\n', '        break;\n', '      }\n', '    }\n', '\n', '    if (rollBack) {\n', '      // Wrap in length encoding and revert (provide bytes instead of a string).\n', '      bytes memory callResultsBytes = abi.encode(callResults);\n', '      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to ensure that protected functions can only be\n', '   * called from this contract and that they have the appropriate context set.\n', '   * The self-call context is then cleared. It is used as an additional guard\n', '   * against reentrancy, especially once generic actions are supported by the\n', '   * smart wallet in future versions.\n', '   * @param selfCallContext bytes4 The expected self-call context, equal to the\n', '   * function selector of the approved calling function.\n', '   */\n', '  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\n', '    // Ensure caller is this contract and self-call context is correctly set.\n', '    require(\n', '      msg.sender == address(this) && _selfCallContext == selfCallContext,\n', '      "External accounts or unapproved internal functions cannot call this."\n', '    );\n', '\n', '    // Clear the self-call context.\n', '    delete _selfCallContext;\n', '  }\n', '\n', '\n', '  function _decodeRevertReason(\n', '    bytes memory revertData\n', '  ) internal pure returns (string memory revertReason) {\n', '    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\n', '    if (\n', '      revertData.length > 68 && // prefix (4) + position (32) + length (32)\n', '      revertData[0] == bytes1(0x08) &&\n', '      revertData[1] == bytes1(0xc3) &&\n', '      revertData[2] == bytes1(0x79) &&\n', '      revertData[3] == bytes1(0xa0)\n', '    ) {\n', '      // Get the revert reason without the prefix from the revert data.\n', '      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\n', '      for (uint256 i = 4; i < revertData.length; i++) {\n', '        revertReasonBytes[i - 4] = revertData[i];\n', '      }\n', '\n', '      // Decode the resultant revert reason as a string.\n', '      revertReason = abi.decode(revertReasonBytes, (string));\n', '    } else {\n', '      // Simply return the default, with no revert reason.\n', '      revertReason = "(no revert reason)";\n', '    }\n', '  }\n', '\n', '  function tradeTokenForTokenSpecifyingFee(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external override returns (uint256 totalTokensBought) {\n', '    _ensureNoEtherFeeTypeWhenNotRouted(routeThroughEther, feeType);\n', '\n', '    // Transfer the token from the caller and revert on failure.\n', '    _transferInToken(tokenProvided, msg.sender, tokenProvidedAmount);\n', '\n', '    totalTokensBought = _tradeTokenForToken(\n', '      msg.sender,\n', '      tokenProvided,\n', '      tokenReceived,\n', '      tokenProvidedAmount,\n', '      quotedTokenReceivedAmount,\n', '      maximumFeeAmount,\n', '      deadline,\n', '      routeThroughEther,\n', '      feeType\n', '    );\n', '  }\n', '\n', '  function tradeTokenForTokenWithFeeOnTransfer(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee,\n', '    uint256 deadline,\n', '    bool routeThroughEther\n', '  ) external override returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeTokenForTokenWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external override returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeTokenForEtherSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external override returns (uint256 totalEtherBought) {\n', '    // Transfer the tokens from the caller and revert on failure.\n', '    _transferInToken(token, msg.sender, tokenAmount);\n', '\n', '    uint256 receivedEtherAmount;\n', '    uint256 retainedAmount;\n', '    (totalEtherBought, receivedEtherAmount, retainedAmount) = _tradeTokenForEther(\n', '      token,\n', '      tokenAmount,\n', '      tokenAmount,\n', '      quotedEtherAmount,\n', '      deadline,\n', '      feeType,\n', '      maximumFeeAmount\n', '    );\n', '\n', '    _fireTradeEvent(\n', '      false,\n', '      false,\n', '      feeType != FeeType.SUPPLIED_ASSET,\n', '      address(token),\n', '      tokenAmount,\n', '      receivedEtherAmount,\n', '      retainedAmount\n', '    );\n', '\n', '    // Transfer the Ether amount to receive to the caller.\n', '    _transferEther(msg.sender, receivedEtherAmount);\n', '  }\n', '\n', '  function tradeTokenForEtherWithFeeOnTransfer(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 deadline\n', '  ) external override returns (uint256 totalEtherBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeTokenForEtherWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external override returns (uint256 totalEtherBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeEtherForTokenSpecifyingFee(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external override payable returns (uint256 totalTokensBought) {\n', '    // Trade Ether for the specified token.\n', '    uint256 receivedTokenAmount;\n', '    uint256 retainedAmount;\n', '    (totalTokensBought, receivedTokenAmount, retainedAmount) = _tradeExactEtherForToken(\n', '      token,\n', '      msg.value,\n', '      quotedTokenAmount,\n', '      deadline,\n', '      false,\n', '      feeType,\n', '      maximumFeeAmount\n', '    );\n', '\n', '    _fireTradeEvent(\n', '      false,\n', '      true,\n', '      feeType != FeeType.RECEIVED_ASSET,\n', '      token,\n', '      msg.value,\n', '      receivedTokenAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  function tradeEtherForTokenWithFeeOnTransfer(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 deadline\n', '  ) external override payable returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeEtherForTokenWithFeeOnTransferSpecifyingFee(\n', '    address token,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external override payable returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeEtherForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    address token,\n', '    uint256 etherAmountFromReserves,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external override onlyOwnerOr(Role.RESERVE_TRADER) returns (uint256 totalTokensBought) {\n', '    totalTokensBought = _tradeEtherForTokenWithFeeOnTransfer(\n', '      token,\n', '      etherAmountFromReserves,\n', '      quotedTokenAmount,\n', '      quotedTokenAmountAfterTransferFee,\n', '      maximumFeeAmount,\n', '      deadline,\n', '      true,\n', '      feeType\n', '    );\n', '  }\n', '\n', '  function tradeEtherForTokenWithFeeOnTransferUsingEtherizer(\n', '    address token,\n', '    uint256 etherAmount,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 deadline\n', '  ) external override returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function tradeTokenForTokenUsingReservesSpecifyingFee(\n', '    ERC20Interface tokenProvidedFromReserves,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmountFromReserves,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external onlyOwnerOr(Role.RESERVE_TRADER) override returns (uint256 totalTokensBought) {\n', '    _ensureNoEtherFeeTypeWhenNotRouted(routeThroughEther, feeType);\n', '\n', '    totalTokensBought = _tradeTokenForToken(\n', '      address(this),\n', '      tokenProvidedFromReserves,\n', '      tokenReceived,\n', '      tokenProvidedAmountFromReserves,\n', '      quotedTokenReceivedAmount,\n', '      maximumFeeAmount,\n', '      deadline,\n', '      routeThroughEther,\n', '      feeType\n', '    );\n', '  }\n', '\n', '  function tradeTokenForTokenUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface tokenProvidedFromReserves,\n', '    address tokenReceived,\n', '    uint256 tokenProvidedAmountFromReserves,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) external onlyOwnerOr(Role.RESERVE_TRADER) override returns (uint256 totalTokensBought) {\n', '    _ensureNoEtherFee(feeType);\n', '\n', '    totalTokensBought = _tradeTokenForTokenWithFeeOnTransfer(\n', '      TradeTokenForTokenWithFeeOnTransferArgs({\n', '      account: address(this),\n', '      tokenProvided: tokenProvidedFromReserves,\n', '      tokenReceivedOrUSDCFlag: tokenReceived,\n', '      tokenProvidedAmount: tokenProvidedAmountFromReserves,\n', '      tokenProvidedAmountAfterTransferFee: tokenProvidedAmountFromReserves,\n', '      quotedTokenReceivedAmount: quotedTokenReceivedAmount,\n', '      quotedTokenReceivedAmountAfterTransferFee: tokenProvidedAmountFromReserves,\n', '      maximumFeeAmount: maximumFeeAmount,\n', '      deadline: deadline,\n', '      routeThroughEther: routeThroughEther,\n', '      feeType: feeType\n', '      })\n', '    );\n', '  }\n', '\n', '  function tradeTokenForEtherUsingReservesSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmountFromReserves,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external onlyOwnerOr(Role.RESERVE_TRADER) override returns (uint256 totalEtherBought) {\n', '    uint256 receivedEtherAmount;\n', '    uint256 retainedAmount;\n', '    (totalEtherBought, receivedEtherAmount, retainedAmount) = _tradeTokenForEther(\n', '      token,\n', '      tokenAmountFromReserves,\n', '      tokenAmountFromReserves,\n', '      quotedEtherAmount,\n', '      deadline,\n', '      feeType,\n', '      maximumFeeAmount\n', '    );\n', '\n', '    _fireTradeEvent(\n', '      true,\n', '      false,\n', '      feeType != FeeType.SUPPLIED_ASSET,\n', '      address(token),\n', '      tokenAmountFromReserves,\n', '      receivedEtherAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  function tradeTokenForEtherUsingReservesWithFeeOnTransferSpecifyingFee(\n', '    ERC20Interface token,\n', '    uint256 tokenAmountFromReserves,\n', '    uint256 quotedEtherAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external onlyOwnerOr(Role.RESERVE_TRADER) override returns (uint256 totalEtherBought) {\n', '    uint256 receivedEtherAmount;\n', '    uint256 retainedAmount;\n', '    (totalEtherBought, receivedEtherAmount, retainedAmount) = _tradeTokenForEther(\n', '      token,\n', '      tokenAmountFromReserves + 1,\n', '      tokenAmountFromReserves,\n', '      quotedEtherAmount,\n', '      deadline,\n', '      feeType,\n', '      maximumFeeAmount\n', '    );\n', '\n', '    _fireTradeEvent(\n', '      true,\n', '      false,\n', '      feeType != FeeType.SUPPLIED_ASSET,\n', '      address(token),\n', '      tokenAmountFromReserves,\n', '      receivedEtherAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  function tradeEtherForTokenUsingReservesSpecifyingFee(\n', '    address token,\n', '    uint256 etherAmountFromReserves,\n', '    uint256 quotedTokenAmount,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    FeeType feeType\n', '  ) external onlyOwnerOr(Role.RESERVE_TRADER) override returns (\n', '    uint256 totalTokensBought\n', '  ) {\n', '    // Trade Ether for the specified token.\n', '    uint256 receivedTokenAmount;\n', '    uint256 retainedAmount;\n', '    (totalTokensBought, receivedTokenAmount, retainedAmount) = _tradeExactEtherForToken(\n', '      token,\n', '      etherAmountFromReserves,\n', '      quotedTokenAmount,\n', '      deadline,\n', '      true,\n', '      feeType,\n', '      maximumFeeAmount\n', '    );\n', '\n', '    _fireTradeEvent(\n', '      true,\n', '      true,\n', '      feeType != FeeType.RECEIVED_ASSET,\n', '      token,\n', '      etherAmountFromReserves,\n', '      receivedTokenAmount,\n', '      maximumFeeAmount\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `amount` of token `token` to `smartWallet`, providing the\n', '   * initial user signing key `initialUserSigningKey` as proof that the\n', '   * specified smart wallet is indeed a Dharma Smart Wallet - this assumes that\n', '   * the address is derived and deployed using the Dharma Smart Wallet Factory\n', '   * V1. Only the owner or the designated deposit manager role may call this\n', '   * function.\n', '   * @param smartWallet address The smart wallet to transfer tokens to.\n', '   * @param initialUserSigningKey address The initial user signing key supplied\n', '   * when deriving the smart wallet address - this could be an EOA or a Dharma\n', '   * key ring address.\n', '   * @param token ERC20Interface The token to transfer.\n', '   * @param amount uint256 The amount of tokens to transfer.\n', '   */\n', '  function finalizeTokenDeposit(\n', '    address smartWallet,\n', '    address initialUserSigningKey,\n', '    ERC20Interface token,\n', '    uint256 amount\n', '  ) external onlyOwnerOr(Role.DEPOSIT_MANAGER) override {\n', '    // Ensure that the recipient is indeed a smart wallet.\n', '    _ensureSmartWallet(smartWallet, initialUserSigningKey);\n', '\n', '    // Transfer the token to the specified smart wallet.\n', '    _transferToken(token, smartWallet, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `etherAmount` Ether to `smartWallet`, providing the\n', '   * initial user signing key `initialUserSigningKey` as proof that the\n', '   * specified smart wallet is indeed a Dharma Smart Wallet - this assumes that\n', '   * the address is derived and deployed using the Dharma Smart Wallet Factory\n', '   * V1. In addition, the Ether amount must be less than the configured limit\n', '   * amount. Only the owner or the designated deposit manager role may call this\n', '   * function.\n', '   * @param smartWallet address The smart wallet to transfer Ether to.\n', '   * @param initialUserSigningKey address The initial user signing key supplied\n', '   * when deriving the smart wallet address - this could be an EOA or a Dharma\n', '   * key ring address.\n', '   * @param etherAmount uint256 The amount of Ether to transfer - this amount\n', '   * must be less than the current limit.\n', '   */\n', '  function finalizeEtherDeposit(\n', '    address payable smartWallet,\n', '    address initialUserSigningKey,\n', '    uint256 etherAmount\n', '  ) external onlyOwnerOr(Role.DEPOSIT_MANAGER) override {\n', '    // Ensure that the recipient is indeed a smart wallet.\n', '    _ensureSmartWallet(smartWallet, initialUserSigningKey);\n', '\n', '    // Transfer the Ether to the specified smart wallet.\n', '    _transferEther(smartWallet, etherAmount);\n', '  }\n', '\n', '  function refillGasReserve(\n', '    uint256 etherAmount\n', '  ) external onlyOwnerOr(Role.GAS_RESERVE_REFILLER) override {\n', '    // Transfer the Ether to the gas reserve.\n', '    _transferEther(_GAS_RESERVE, etherAmount);\n', '\n', '    emit GasReserveRefilled(etherAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `usdcAmount` USDC for to the current primary recipient set\n', '   * by the owner. Only the owner or the designated withdrawal manager role may\n', '   * call this function.\n', '   * @param usdcAmount uint256 The amount of USDC to transfer to the primary\n', '   * recipient.\n', '   */\n', '  function withdrawUSDCToPrimaryRecipient(\n', '    uint256 usdcAmount\n', '  ) external onlyOwnerOr(Role.WITHDRAWAL_MANAGER) override {\n', '    // Get the current primary recipient.\n', '    address primaryRecipient = _primaryUSDCRecipient;\n', '    require(\n', '      primaryRecipient != address(0), "No USDC primary recipient currently set."\n', '    );\n', '\n', '    // Transfer the supplied USDC amount to the primary recipient.\n', '    _transferToken(_USDC, primaryRecipient, usdcAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `daiAmount` Dai for to the current primary recipient set\n', '   * by the owner. Only the owner or the designated withdrawal manager role may\n', '   * call this function.\n', '   * @param daiAmount uint256 The amount of Dai to transfer to the primary\n', '   * recipient.\n', '   */\n', '  function withdrawDaiToPrimaryRecipient(\n', '    uint256 daiAmount\n', '  ) external onlyOwnerOr(Role.WITHDRAWAL_MANAGER) override {\n', '    // Get the current primary recipient.\n', '    address primaryRecipient = _primaryDaiRecipient;\n', '    require(\n', '      primaryRecipient != address(0), "No Dai primary recipient currently set."\n', '    );\n', '\n', '    // Transfer the supplied Dai amount to the primary recipient.\n', '    _transferToken(_DAI, primaryRecipient, daiAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `etherAmount` Ether to `recipient`. Only the owner may\n', '   * call this function.\n', '   * @param recipient address The account to transfer Ether to.\n', '   * @param etherAmount uint256 The amount of Ether to transfer.\n', '   */\n', '  function withdrawEther(\n', '    address payable recipient, uint256 etherAmount\n', '  ) external override onlyOwner {\n', '    // Transfer the Ether to the specified recipient.\n', '    _transferEther(recipient, etherAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfer `amount` of ERC20 token `token` to `recipient`. Only the\n', '   * owner may call this function.\n', '   * @param token ERC20Interface The ERC20 token to transfer.\n', '   * @param recipient address The account to transfer the tokens to.\n', '   * @param amount uint256 The amount of tokens to transfer.\n', '   * @return success - a boolean to indicate if the transfer was successful - note that\n', '   * unsuccessful ERC20 transfers will usually revert.\n', '   */\n', '  function withdraw(\n', '    ERC20Interface token, address recipient, uint256 amount\n', '  ) external onlyOwner override returns (bool success) {\n', '    // Transfer the token to the specified recipient.\n', '    success = token.transfer(recipient, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Call account `target`, supplying value `amount` and data `data`.\n', '   * Only the owner may call this function.\n', '   * @param target address The account to call.\n', '   * @param amount uint256 The amount of ether to include as an endowment.\n', '   * @param data bytes The data to include along with the call.\n', '   * @return ok and returnData - a boolean to indicate if the call was successful, as well as the\n', '   * returned data or revert reason.\n', '   */\n', '  function callAny(\n', '    address payable target, uint256 amount, bytes calldata data\n', '  ) external onlyOwner override returns (bool ok, bytes memory returnData) {\n', '    // Call the specified target and supply the specified data.\n', '    (ok, returnData) = target.call{value:amount}(data);\n', '  }\n', '\n', '  /**\n', '   * @notice Set `recipient` as the new primary recipient for USDC withdrawals.\n', '   * Only the owner may call this function.\n', '   * @param recipient address The new primary recipient.\n', '   */\n', '  function setPrimaryUSDCRecipient(address recipient) external override onlyOwner {\n', '    // Set the new primary recipient.\n', '    _primaryUSDCRecipient = recipient;\n', '  }\n', '\n', '  /**\n', '   * @notice Set `recipient` as the new primary recipient for Dai withdrawals.\n', '   * Only the owner may call this function.\n', '   * @param recipient address The new primary recipient.\n', '   */\n', '  function setPrimaryDaiRecipient(address recipient) external override onlyOwner {\n', '    // Set the new primary recipient.\n', '    _primaryDaiRecipient = recipient;\n', '  }\n', '\n', '  /**\n', '   * @notice Pause a currently unpaused role and emit a `RolePaused` event. Only\n', '   * the owner or the designated pauser may call this function. Also, bear in\n', '   * mind that only the owner may unpause a role once paused.\n', '   * @param role The role to pause.\n', '   */\n', '  function pause(Role role) external override onlyOwnerOr(Role.PAUSER) {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '    require(!storedRoleStatus.paused, "Role in question is already paused.");\n', '    storedRoleStatus.paused = true;\n', '    emit RolePaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice Unpause a currently paused role and emit a `RoleUnpaused` event.\n', '   * Only the owner may call this function.\n', '   * @param role The role to pause.\n', '   */\n', '  function unpause(Role role) external override onlyOwner {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '    require(storedRoleStatus.paused, "Role in question is already unpaused.");\n', '    storedRoleStatus.paused = false;\n', '    emit RoleUnpaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice Set a new account on a given role and emit a `RoleModified` event\n', '   * if the role holder has changed. Only the owner may call this function.\n', '   * @param role The role that the account will be set for.\n', '   * @param account The account to set as the designated role bearer.\n', '   */\n', '  function setRole(Role role, address account) external override onlyOwner {\n', '    require(account != address(0), "Must supply an account.");\n', '    _setRole(role, account);\n', '  }\n', '\n', '  /**\n', '   * @notice Remove any current role bearer for a given role and emit a\n', '   * `RoleModified` event if a role holder was previously set. Only the owner\n', '   * may call this function.\n', '   * @param role The role that the account will be removed from.\n', '   */\n', '  function removeRole(Role role) external override onlyOwner {\n', '    _setRole(role, address(0));\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check whether or not the functionality\n', '   * associated with a given role is currently paused or not. The owner or the\n', '   * pauser may pause any given role (including the pauser itself), but only the\n', '   * owner may unpause functionality. Additionally, the owner may call paused\n', '   * functions directly.\n', '   * @param role The role to check the pause status on.\n', '   * @return paused - a boolean to indicate if the functionality associated with the role\n', '   * in question is currently paused.\n', '   */\n', '  function isPaused(Role role) external view override returns (bool paused) {\n', '    paused = _isPaused(role);\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check whether the caller is the current\n', '   * role holder.\n', '   * @param role The role to check for.\n', '   * @return hasRole - a boolean indicating if the caller has the specified role.\n', '   */\n', '  function isRole(Role role) external view override returns (bool hasRole) {\n', '    hasRole = _isRole(role);\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check whether a "proof" that a given\n', '   * smart wallet is actually a Dharma Smart Wallet, based on the initial user\n', '   * signing key, is valid or not. This proof only works when the Dharma Smart\n', '   * Wallet in question is derived using V1 of the Dharma Smart Wallet Factory.\n', '   * @param smartWallet address The smart wallet to check.\n', '   * @param initialUserSigningKey address The initial user signing key supplied\n', '   * when deriving the smart wallet address - this could be an EOA or a Dharma\n', '   * key ring address.\n', '   * @return dharmaSmartWallet - a boolean indicating if the specified smart wallet account is\n', '   * indeed a smart wallet based on the specified initial user signing key.\n', '   */\n', '  function isDharmaSmartWallet(\n', '    address smartWallet, address initialUserSigningKey\n', '  ) external pure override returns (bool dharmaSmartWallet) {\n', '    dharmaSmartWallet = _isSmartWallet(smartWallet, initialUserSigningKey);\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * deposit manager role. The deposit manager can process standard deposit\n', '   * finalization via `finalizeDaiDeposit` and `finalizeDharmaDaiDeposit`, but\n', '   * must prove that the recipient is a Dharma Smart Wallet and adhere to the\n', '   * current deposit size limit.\n', '   * @return depositManager - the address of the current deposit manager, or the null address if\n', '   * none is set.\n', '   */\n', '  function getDepositManager() external view override returns (address depositManager) {\n', '    depositManager = _roles[uint256(Role.DEPOSIT_MANAGER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * reserve trader role. The reserve trader can trigger trades that utilize\n', '   * reserves in addition to supplied funds, if any.\n', '   * @return reserveTrader - the address of the current reserve trader, or the null address if\n', '   * none is set.\n', '   */\n', '  function getReserveTrader() external view override returns (address reserveTrader) {\n', '    reserveTrader = _roles[uint256(Role.RESERVE_TRADER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * withdrawal manager role. The withdrawal manager can transfer USDC to the\n', '   * "primary recipient" address set by the owner.\n', '   * @return withdrawalManager - the address of the current withdrawal manager, or the null address\n', '   * if none is set.\n', '   */\n', '  function getWithdrawalManager() external view override returns (\n', '    address withdrawalManager\n', '  ) {\n', '    withdrawalManager = _roles[uint256(Role.WITHDRAWAL_MANAGER)].account;\n', '  }\n', '\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * actioner role. The actioner can submit a generic calls transaction through `execute`\n', '   * @return actioner - the address of the current actioner, or the null address\n', '   * if none is set.\n', '   */\n', '  function getActioner() external view override returns (\n', '    address actioner\n', '    ) {\n', '    actioner = _roles[uint256(Role.ACTIONER)].account;\n', '  }\n', '\n', '\n', '  /**\n', '   * @notice External view function to check the account currently holding the\n', '   * pauser role. The pauser can pause any role from taking its standard action,\n', '   * though the owner will still be able to call the associated function in the\n', '   * interim and is the only entity able to unpause the given role once paused.\n', '   * @return pauser - the address of the current pauser, or the null address if none is\n', '   * set.\n', '   */\n', '  function getPauser() external view override returns (address pauser) {\n', '    pauser = _roles[uint256(Role.PAUSER)].account;\n', '  }\n', '\n', '  function getGasReserveRefiller() external view override returns (\n', '    address gasReserveRefiller\n', '  ) {\n', '    gasReserveRefiller = _roles[uint256(Role.GAS_RESERVE_REFILLER)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the address of the current\n', '   * primary recipient for USDC.\n', '   * @return recipient - the primary recipient for USDC.\n', '   */\n', '  function getPrimaryUSDCRecipient() external view override returns (\n', '    address recipient\n', '  ) {\n', '    recipient = _primaryUSDCRecipient;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the address of the current\n', '   * primary recipient for Dai.\n', '   * @return recipient - the primary recipient for Dai.\n', '   */\n', '  function getPrimaryDaiRecipient() external view override returns (\n', '    address recipient\n', '  ) {\n', '    recipient = _primaryDaiRecipient;\n', '  }\n', '\n', '  /**\n', '   * @notice External view function to check the current implementation\n', '   * of this contract (i.e. the "logic" for the contract).\n', '   * @return implementation - the current implementation for this contract.\n', '   */\n', '  function getImplementation() external view override returns (\n', '    address implementation\n', '  ) {\n', '    (bool ok, bytes memory returnData) = address(\n', '      0x481B1a16E6675D33f8BBb3a6A58F5a9678649718\n', '    ).staticcall("");\n', '    require(ok && returnData.length == 32, "Invalid implementation.");\n', '    implementation = abi.decode(returnData, (address));\n', '  }\n', '\n', '  /**\n', '   * @notice External pure function to get the address of the actual\n', '   * contract instance (i.e. the "storage" foor this contract).\n', '   * @return instance - the address of this contract instance.\n', '   */\n', '  function getInstance() external pure override returns (address instance) {\n', '    instance = address(0x2040F2f2bB228927235Dc24C33e99E3A0a7922c1);\n', '  }\n', '\n', '  function getVersion() external pure override returns (uint256 version) {\n', '    version = _VERSION;\n', '  }\n', '\n', '  function _grantUniswapRouterApprovalIfNecessary(\n', '    ERC20Interface token, uint256 amount\n', '  ) internal {\n', '    if (token.allowance(address(this), address(_UNISWAP_ROUTER)) < amount) {\n', '      // Try removing approval first as a workaround for unusual tokens.\n', '      (bool success, bytes memory data) = address(token).call(\n', '        abi.encodeWithSelector(\n', '          token.approve.selector, address(_UNISWAP_ROUTER), uint256(0)\n', '        )\n', '      );\n', '\n', '      // Grant transfer approval to Uniswap router on behalf of this contract.\n', '      (success, data) = address(token).call(\n', '        abi.encodeWithSelector(\n', '          token.approve.selector, address(_UNISWAP_ROUTER), type(uint256).max\n', '        )\n', '      );\n', '\n', '      if (!success) {\n', '        // Some janky tokens only allow setting approval up to current balance.\n', '        (success, data) = address(token).call(\n', '          abi.encodeWithSelector(\n', '            token.approve.selector, address(_UNISWAP_ROUTER), amount\n', '          )\n', '        );\n', '      }\n', '\n', '      require(\n', '        success && (data.length == 0 || abi.decode(data, (bool))),\n', '        "Token approval for Uniswap router failed."\n', '      );\n', '    }\n', '  }\n', '\n', '  function _tradeEtherForTokenWithFeeOnTransfer(\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 etherAmount,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 maximumFeeAmount,\n', '    uint256 deadline,\n', '    bool fromReserves,\n', '    FeeType feeType\n', '  ) internal returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  function _tradeEtherForTokenWithFeeOnTransferLegacy(\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 etherAmount,\n', '    uint256 quotedTokenAmount,\n', '    uint256 quotedTokenAmountAfterTransferFee,\n', '    uint256 deadline,\n', '    bool fromReserves\n', '  ) internal returns (uint256 totalTokensBought) {\n', '    _delegate(V17_STAGING);\n', '  }\n', '\n', '  /**\n', '  * @notice Internal trade function. If token is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\n', '  * trade for USDC and retain the full output amount by replacing the recipient\n', '  * ("to" input) on the swapETHForExactTokens call.\n', '  */\n', '  function _tradeExactEtherForToken(\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 etherAmount,\n', '    uint256 quotedTokenAmount,\n', '    uint256 deadline,\n', '    bool fromReserves,\n', '    FeeType feeType,\n', '    uint256 maximumFeeAmount\n', '  ) internal returns (\n', '    uint256 totalTokensBought,\n', '    uint256 receivedTokenAmount,\n', '    uint256 retainedAmount\n', '  ) {\n', '    // Set swap target destination and token.\n', '    address destination;\n', '    address[] memory path = new address[](2);\n', '    path[0] = _WETH;\n', '    if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\n', '      path[1] = address(_USDC);\n', '      destination = address(this);\n', '    } else {\n', '      path[1] = tokenReceivedOrUSDCFlag;\n', '      destination = fromReserves ? address(this) : msg.sender;\n', '    }\n', '\n', '    // Trade Ether for quoted token amount and send to appropriate recipient.\n', '    uint256[] memory amounts = new uint256[](2);\n', '    amounts = _UNISWAP_ROUTER.swapExactETHForTokens{value:\n', '      feeType != FeeType.RECEIVED_ASSET\n', '      ? etherAmount - maximumFeeAmount\n', '      : etherAmount\n', '    }(\n', '      quotedTokenAmount,\n', '      path,\n', '      destination,\n', '      deadline\n', '    );\n', '    totalTokensBought = amounts[1];\n', '\n', '    if (feeType == FeeType.RECEIVED_ASSET) {\n', '      // Retain the lesser of either max fee or bought amount less quoted amount.\n', '      retainedAmount = maximumFeeAmount.min(\n', '        totalTokensBought - quotedTokenAmount\n', '      );\n', '      receivedTokenAmount = totalTokensBought - retainedAmount;\n', '    } else {\n', '      retainedAmount = maximumFeeAmount;\n', '      receivedTokenAmount = totalTokensBought;\n', '    }\n', '  }\n', '\n', '  function _tradeTokenForEther(\n', '    ERC20Interface token,\n', '    uint256 tokenAmount,\n', '    uint256 tokenAmountAfterTransferFee,\n', '    uint256 quotedEtherAmount,\n', '    uint256 deadline,\n', '    FeeType feeType,\n', '    uint256 maximumFeeAmount\n', '  ) internal returns (\n', '    uint256 totalEtherBought,\n', '    uint256 receivedEtherAmount,\n', '    uint256 retainedAmount\n', '  ) {\n', '    // Trade tokens for Ether.\n', '    uint256 tradeAmount;\n', '    if (feeType == FeeType.SUPPLIED_ASSET) {\n', '      tradeAmount = (tokenAmount.min(tokenAmountAfterTransferFee) - maximumFeeAmount);\n', '      retainedAmount = maximumFeeAmount;\n', '    } else {\n', '      tradeAmount = tokenAmount.min(tokenAmountAfterTransferFee);\n', '    }\n', '\n', '    // Approve Uniswap router to transfer tokens on behalf of this contract.\n', '    _grantUniswapRouterApprovalIfNecessary(token, tokenAmount);\n', '\n', '    // Establish path from target token to Ether.\n', '    (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\n', '      address(token), _WETH, false\n', '    );\n', '\n', '    // Trade tokens for quoted Ether amount on Uniswap (send to this contract).\n', '    if (tokenAmount == tokenAmountAfterTransferFee) {\n', '      amounts = _UNISWAP_ROUTER.swapExactTokensForETH(\n', '        tradeAmount, quotedEtherAmount, path, address(this), deadline\n', '      );\n', '      totalEtherBought = amounts[1];\n', '    } else {\n', '      uint256 ethBalanceBeforeTrade = address(this).balance;\n', '      _UNISWAP_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        tradeAmount,\n', '        quotedEtherAmount,\n', '        path,\n', '        address(this),\n', '        deadline\n', '      );\n', '      totalEtherBought = address(this).balance - ethBalanceBeforeTrade;\n', '    }\n', '\n', '    if (feeType != FeeType.SUPPLIED_ASSET) {\n', '      // Retain the lesser of either max fee or bought amount less quoted amount.\n', '      retainedAmount = maximumFeeAmount.min(\n', '        totalEtherBought - quotedEtherAmount\n', '      );\n', '\n', '      // Receive back the total bought Ether less total retained Ether.\n', '      receivedEtherAmount = totalEtherBought - retainedAmount;\n', '    } else {\n', '      receivedEtherAmount = totalEtherBought;\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Internal trade function. If tokenReceived is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\n', '  * trade for USDC and retain the full output amount by replacing the recipient\n', '  * ("to" input) on the swapTokensForExactTokens call.\n', '  */\n', '  function _tradeTokenForToken(\n', '    address account,\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 maximumFeeAmount, // WETH if routeThroughEther, else tokenReceived\n', '    uint256 deadline,\n', '    bool routeThroughEther,\n', '    FeeType feeType\n', '  ) internal returns (uint256 totalTokensBought) {\n', '    uint256 retainedAmount;\n', '    uint256 receivedAmount;\n', '    address tokenReceived;\n', '\n', '    // Approve Uniswap router to transfer tokens on behalf of this contract.\n', '    _grantUniswapRouterApprovalIfNecessary(tokenProvided, tokenProvidedAmount);\n', '\n', '    // Set recipient, swap target token\n', '    if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\n', '      tokenReceived = address(_USDC);\n', '    } else {\n', '      tokenReceived = tokenReceivedOrUSDCFlag;\n', '    }\n', '\n', '    if (routeThroughEther == false) {\n', '      // Establish direct path between tokens.\n', '      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\n', '        address(tokenProvided), tokenReceived, false\n', '      );\n', '\n', '      // Trade for the quoted token amount on Uniswap and send to this contract.\n', '      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\n', '        feeType == FeeType.SUPPLIED_ASSET\n', '        ? tokenProvidedAmount - maximumFeeAmount\n', '        : tokenProvidedAmount,\n', '        quotedTokenReceivedAmount,\n', '        path,\n', '        address(this),\n', '        deadline\n', '      );\n', '\n', '      totalTokensBought = amounts[1];\n', '\n', '      if (feeType == FeeType.RECEIVED_ASSET) {\n', '        // Retain lesser of either max fee or bought amount less quoted amount.\n', '        retainedAmount = maximumFeeAmount.min(\n', '          totalTokensBought - quotedTokenReceivedAmount\n', '        );\n', '        receivedAmount = totalTokensBought - retainedAmount;\n', '      } else {\n', '        retainedAmount = maximumFeeAmount;\n', '        receivedAmount = totalTokensBought;\n', '      }\n', '    } else {\n', '      // Establish path between provided token and WETH.\n', '      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\n', '        address(tokenProvided), _WETH, false\n', '      );\n', '\n', '      // Trade all provided tokens for WETH on Uniswap and send to this contract.\n', '      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\n', '        feeType == FeeType.SUPPLIED_ASSET\n', '        ? tokenProvidedAmount - maximumFeeAmount\n', '        : tokenProvidedAmount,\n', '        feeType == FeeType.ETHER ? maximumFeeAmount : 1,\n', '        path,\n', '        address(this),\n', '        deadline\n', '      );\n', '      retainedAmount = amounts[1];\n', '\n', '      // Establish path between WETH and received token.\n', '      (path, amounts) = _createPathAndAmounts(\n', '        _WETH, tokenReceived, false\n', '      );\n', '\n', '      // Trade bought WETH (less fee) for received token, send to this contract.\n', '      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\n', '        feeType == FeeType.ETHER\n', '        ? retainedAmount - maximumFeeAmount\n', '        : retainedAmount,\n', '        quotedTokenReceivedAmount,\n', '        path,\n', '        address(this),\n', '        deadline\n', '      );\n', '\n', '      totalTokensBought = amounts[1];\n', '\n', '      if (feeType == FeeType.RECEIVED_ASSET) {\n', '        // Retain lesser of either max fee or bought amount less quoted amount.\n', '        retainedAmount = maximumFeeAmount.min(\n', '          totalTokensBought - quotedTokenReceivedAmount\n', '        );\n', '        receivedAmount = totalTokensBought - retainedAmount;\n', '      } else {\n', '        retainedAmount = maximumFeeAmount;\n', '        receivedAmount = totalTokensBought;\n', '      }\n', '    }\n', '\n', '    _emitTrade(\n', '      account,\n', '      address(tokenProvided),\n', '      tokenReceivedOrUSDCFlag,\n', '      feeType == FeeType.ETHER\n', '      ? _WETH\n', '      : (feeType == FeeType.RECEIVED_ASSET\n', '    ? tokenReceived\n', '    : address(tokenProvided)\n', '    ),\n', '      tokenProvidedAmount,\n', '      receivedAmount,\n', '      retainedAmount\n', '    );\n', '\n', '    if (\n', '      account != address(this) &&\n', '      tokenReceivedOrUSDCFlag != _TRADE_FOR_USDC_AND_RETAIN_FLAG\n', '    ) {\n', '      _transferToken(ERC20Interface(tokenReceived), account, receivedAmount);\n', '    }\n', '  }\n', '\n', '  /**\n', '  * @notice Internal trade function. If tokenReceived is _TRADE_FOR_USDC_AND_RETAIN_FLAG,\n', '  * trade for USDC and retain the full output amount by replacing the recipient\n', '  * ("to" input) on the swapTokensForExactTokens call.\n', '  */\n', '  function _tradeTokenForTokenLegacy(\n', '    address account,\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 deadline,\n', '    bool routeThroughEther\n', '  ) internal returns (uint256 totalTokensSold) {\n', '    uint256 retainedAmount;\n', '    address tokenReceived;\n', '    address recipient;\n', '\n', '    // Approve Uniswap router to transfer tokens on behalf of this contract.\n', '    _grantUniswapRouterApprovalIfNecessary(tokenProvided, tokenProvidedAmount);\n', '\n', '    // Set recipient, swap target token\n', '    if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\n', '      recipient = address(this);\n', '      tokenReceived = address(_USDC);\n', '    } else {\n', '      recipient = account;\n', '      tokenReceived = tokenReceivedOrUSDCFlag;\n', '    }\n', '\n', '    if (routeThroughEther == false) {\n', '      // Establish direct path between tokens.\n', '      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\n', '        address(tokenProvided), tokenReceived, false\n', '      );\n', '\n', '      // Trade for the quoted token amount on Uniswap and send to recipient.\n', '      amounts = _UNISWAP_ROUTER.swapTokensForExactTokens(\n', '        quotedTokenReceivedAmount,\n', '        tokenProvidedAmount,\n', '        path,\n', '        recipient,\n', '        deadline\n', '      );\n', '\n', '      totalTokensSold = amounts[0];\n', '      retainedAmount = tokenProvidedAmount - totalTokensSold;\n', '    } else {\n', '      // Establish path between provided token and WETH.\n', '      (address[] memory path, uint256[] memory amounts) = _createPathAndAmounts(\n', '        address(tokenProvided), _WETH, false\n', '      );\n', '\n', '      // Trade all provided tokens for WETH on Uniswap and send to this contract.\n', '      amounts = _UNISWAP_ROUTER.swapExactTokensForTokens(\n', '        tokenProvidedAmount, 0, path, address(this), deadline\n', '      );\n', '      retainedAmount = amounts[1];\n', '\n', '      // Establish path between WETH and received token.\n', '      (path, amounts) = _createPathAndAmounts(\n', '        _WETH, tokenReceived, false\n', '      );\n', '\n', '      // Trade bought WETH for received token on Uniswap and send to recipient.\n', '      amounts = _UNISWAP_ROUTER.swapTokensForExactTokens(\n', '        quotedTokenReceivedAmount, retainedAmount, path, recipient, deadline\n', '      );\n', '\n', '      totalTokensSold = amounts[0];\n', '      retainedAmount = retainedAmount - totalTokensSold;\n', '    }\n', '\n', '    _emitTrade(\n', '      account,\n', '      address(tokenProvided),\n', '      tokenReceivedOrUSDCFlag,\n', '      routeThroughEther ? _WETH : address(tokenProvided),\n', '      tokenProvidedAmount,\n', '      quotedTokenReceivedAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  struct TradeTokenForTokenWithFeeOnTransferArgs {\n', '    address account;\n', '    ERC20Interface tokenProvided;\n', '    address tokenReceivedOrUSDCFlag;\n', '    uint256 tokenProvidedAmount;\n', '    uint256 tokenProvidedAmountAfterTransferFee;\n', '    uint256 quotedTokenReceivedAmount;\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee;\n', '    uint256 maximumFeeAmount;\n', '    uint256 deadline;\n', '    bool routeThroughEther;\n', '    FeeType feeType;\n', '  }\n', '\n', '  /**\n', '  * @notice Internal trade function for cases where one of the tokens in\n', '  * question levies a transfer fee. If tokenReceived is\n', '  * _TRADE_FOR_USDC_AND_RETAIN_FLAG, trade for USDC and retain the full output\n', '  * amount by replacing the recipient ("to" input) on the\n', '  * swapTokensForExactTokens call.\n', '  */\n', '  function _tradeTokenForTokenWithFeeOnTransfer(\n', '    TradeTokenForTokenWithFeeOnTransferArgs memory args\n', '  ) internal returns (uint256 totalTokensBought) {\n', '    ERC20Interface tokenReceived = (\n', '    args.tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG\n', '    ? ERC20Interface(_USDC)\n', '    : ERC20Interface(args.tokenReceivedOrUSDCFlag)\n', '    );\n', '\n', '    // Approve Uniswap router to transfer tokens on behalf of this contract.\n', '    _grantUniswapRouterApprovalIfNecessary(\n', '      args.tokenProvided, args.tokenProvidedAmountAfterTransferFee\n', '    );\n', '\n', '    { // Scope to avoid stack too deep error.\n', '      // Establish path between tokens.\n', '      (address[] memory path, ) = _createPathAndAmounts(\n', '        address(args.tokenProvided), address(tokenReceived), args.routeThroughEther\n', '      );\n', '\n', "      // Get this contract's balance in the output token prior to the trade.\n", '      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\n', '        address(this)\n', '      );\n', '\n', '      // Trade for the quoted token amount on Uniswap and send to this contract.\n', '      _UNISWAP_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        args.feeType == FeeType.SUPPLIED_ASSET\n', '        ? args.tokenProvidedAmountAfterTransferFee - args.maximumFeeAmount\n', '        : args.tokenProvidedAmountAfterTransferFee,\n', '        args.quotedTokenReceivedAmount,\n', '        path,\n', '        address(this),\n', '        args.deadline\n', '      );\n', '\n', '      totalTokensBought = tokenReceived.balanceOf(address(this)) - priorReserveBalanceOfReceivedToken;\n', '    }\n', '    uint256 receivedAmountAfterTransferFee;\n', '    if (\n', '      args.account != address(this) &&\n', '      args.tokenReceivedOrUSDCFlag != _TRADE_FOR_USDC_AND_RETAIN_FLAG\n', '    ) {\n', '      {\n', "        // Get the receiver's balance prior to the transfer.\n", '        uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\n', '          args.account\n', '        );\n', '\n', '        // Transfer the received tokens (less the fee) to the recipient.\n', '        _transferToken(\n', '          tokenReceived,\n', '          args.account,\n', '          args.feeType == FeeType.RECEIVED_ASSET\n', '          ? totalTokensBought - args.maximumFeeAmount\n', '          : totalTokensBought\n', '        );\n', '\n', '        receivedAmountAfterTransferFee = tokenReceived.balanceOf(args.account) - priorRecipientBalanceOfReceivedToken;\n', '      }\n', '\n', '      // Ensure that sufficient tokens were returned to the user.\n', '      require(\n', '        receivedAmountAfterTransferFee >= args.quotedTokenReceivedAmountAfterTransferFee,\n', '        "Received token amount after transfer fee is less than quoted amount."\n', '      );\n', '    } else {\n', '      receivedAmountAfterTransferFee = args.feeType == FeeType.RECEIVED_ASSET\n', '      ? totalTokensBought - args.maximumFeeAmount\n', '      : totalTokensBought;\n', '    }\n', '\n', '    _emitTrade(\n', '      args.account,\n', '      address(args.tokenProvided),\n', '      args.tokenReceivedOrUSDCFlag,\n', '      args.feeType == FeeType.RECEIVED_ASSET\n', '      ? address(tokenReceived)\n', '      : address(args.tokenProvided),\n', '      args.tokenProvidedAmount,\n', '      receivedAmountAfterTransferFee,\n', '      args.maximumFeeAmount\n', '    );\n', '  }\n', '\n', '  /**\n', '  * @notice Internal trade function for cases where one of the tokens in\n', '  * question levies a transfer fee. If tokenReceived is\n', '  * _TRADE_FOR_USDC_AND_RETAIN_FLAG, trade for USDC and retain the full output\n', '  * amount by replacing the recipient ("to" input) on the\n', '  * swapTokensForExactTokens call.\n', '  */\n', '  function _tradeTokenForTokenWithFeeOnTransferLegacy(\n', '    address account,\n', '    ERC20Interface tokenProvided,\n', '    address tokenReceivedOrUSDCFlag,\n', '    uint256 tokenProvidedAmount,\n', '    uint256 tokenProvidedAmountAfterTransferFee,\n', '    uint256 quotedTokenReceivedAmount,\n', '    uint256 quotedTokenReceivedAmountAfterTransferFee,\n', '    uint256 deadline,\n', '    bool routeThroughEther\n', '  ) internal returns (uint256 totalTokensBought) {\n', '    uint256 retainedAmount;\n', '    uint256 receivedAmountAfterTransferFee;\n', '    ERC20Interface tokenReceived;\n', '\n', '    // Approve Uniswap router to transfer tokens on behalf of this contract.\n', '    _grantUniswapRouterApprovalIfNecessary(\n', '      tokenProvided, tokenProvidedAmountAfterTransferFee\n', '    );\n', '\n', '    { // Scope to avoid stack too deep error.\n', '      address recipient;\n', '      // Set recipient, swap target token\n', '      if (tokenReceivedOrUSDCFlag == _TRADE_FOR_USDC_AND_RETAIN_FLAG) {\n', '        recipient = address(this);\n', '        tokenReceived = ERC20Interface(_USDC);\n', '      } else {\n', '        recipient = account;\n', '        tokenReceived = ERC20Interface(tokenReceivedOrUSDCFlag);\n', '      }\n', '\n', '      // Establish path between tokens.\n', '      (address[] memory path, ) = _createPathAndAmounts(\n', '        address(tokenProvided), address(tokenReceived), routeThroughEther\n', '      );\n', '\n', "      // Get this contract's balance in the output token prior to the trade.\n", '      uint256 priorReserveBalanceOfReceivedToken = tokenReceived.balanceOf(\n', '        address(this)\n', '      );\n', '\n', '      // Trade for the quoted token amount on Uniswap and send to this contract.\n', '      _UNISWAP_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        tokenProvidedAmountAfterTransferFee,\n', '        quotedTokenReceivedAmount,\n', '        path,\n', '        address(this),\n', '        deadline\n', '      );\n', '\n', '      totalTokensBought = tokenReceived.balanceOf(address(this)) - priorReserveBalanceOfReceivedToken;\n', '      retainedAmount = totalTokensBought - quotedTokenReceivedAmount;\n', '\n', "      // Get the receiver's balance prior to the transfer.\n", '      uint256 priorRecipientBalanceOfReceivedToken = tokenReceived.balanceOf(\n', '        recipient\n', '      );\n', '\n', '      // Transfer the received tokens to the recipient.\n', '      _transferToken(tokenReceived, recipient, quotedTokenReceivedAmount);\n', '\n', '      receivedAmountAfterTransferFee = tokenReceived.balanceOf(recipient) - priorRecipientBalanceOfReceivedToken;\n', '\n', '      // Ensure that sufficient tokens were returned to the user.\n', '      require(\n', '        receivedAmountAfterTransferFee >= quotedTokenReceivedAmountAfterTransferFee,\n', '        "Received token amount after transfer fee is less than quoted amount."\n', '      );\n', '    }\n', '\n', '    _emitTrade(\n', '      account,\n', '      address(tokenProvided),\n', '      tokenReceivedOrUSDCFlag,\n', '      address(tokenReceived),\n', '      tokenProvidedAmount,\n', '      receivedAmountAfterTransferFee,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal function to set a new account on a given role and emit a\n', '   * `RoleModified` event if the role holder has changed.\n', '   * @param role The role that the account will be set for. Permitted roles are\n', '   * deposit manager (0), adjuster (1), and pauser (2).\n', '   * @param account The account to set as the designated role bearer.\n', '   */\n', '  function _setRole(Role role, address account) internal {\n', '    RoleStatus storage storedRoleStatus = _roles[uint256(role)];\n', '\n', '    if (account != storedRoleStatus.account) {\n', '      storedRoleStatus.account = account;\n', '      emit RoleModified(role, account);\n', '    }\n', '  }\n', '\n', '  function _emitTrade(\n', '    address account,\n', '    address suppliedAsset,\n', '    address receivedAsset,\n', '    address retainedAsset,\n', '    uint256 suppliedAmount,\n', '    uint256 receivedAmount,\n', '    uint256 retainedAmount\n', '  ) internal {\n', '    emit Trade(\n', '      account,\n', '      suppliedAsset,\n', '      receivedAsset,\n', '      retainedAsset,\n', '      suppliedAmount,\n', '      receivedAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  function _fireTradeEvent(\n', '    bool fromReserves,\n', '    bool supplyingEther,\n', '    bool feeInEther,\n', '    address token,\n', '    uint256 suppliedAmount,\n', '    uint256 receivedAmount,\n', '    uint256 retainedAmount\n', '  ) internal {\n', '    emit Trade(\n', '      fromReserves ? address(this) : msg.sender,\n', '      supplyingEther ? address(0) : token,\n', '      supplyingEther ? token : address(0),\n', '      feeInEther\n', '      ? address(0)\n', '      : (token == _TRADE_FOR_USDC_AND_RETAIN_FLAG ? address(_USDC) : token),\n', '      suppliedAmount,\n', '      receivedAmount,\n', '      retainedAmount\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function to check whether the caller is the current\n', '   * role holder.\n', '   * @param role The role to check for.\n', '   * @return hasRole - a boolean indicating if the caller has the specified role.\n', '   */\n', '  function _isRole(Role role) internal view returns (bool hasRole) {\n', '    hasRole = msg.sender == _roles[uint256(role)].account;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function to check whether the given role is paused or\n', '   * not.\n', '   * @param role The role to check for.\n', '   * @return paused - a boolean indicating if the specified role is paused or not.\n', '   */\n', '  function _isPaused(Role role) internal view returns (bool paused) {\n', '    paused = _roles[uint256(role)].paused;\n', '  }\n', '\n', '  /**\n', '   * @notice Internal view function to enforce that the given initial user signing\n', '   * key resolves to the given smart wallet when deployed through the Dharma Smart\n', '   * Wallet Factory V1. (staging version)\n', '   * @param smartWallet address The smart wallet.\n', '   * @param initialUserSigningKey address The initial user signing key.\n', '   */\n', '  function _isSmartWallet(\n', '    address smartWallet, address initialUserSigningKey\n', '  ) internal pure returns (bool) {\n', '    // Derive the keccak256 hash of the smart wallet initialization code.\n', '    bytes32 initCodeHash = keccak256(\n', '      abi.encodePacked(\n', '        _WALLET_CREATION_CODE_HEADER,\n', '        initialUserSigningKey,\n', '        _WALLET_CREATION_CODE_FOOTER\n', '      )\n', '    );\n', '\n', '    // Attempt to derive a smart wallet address that matches the one provided.\n', '    address target;\n', '    for (uint256 nonce = 0; nonce < 10; nonce++) {\n', '      target = address(          // derive the target deployment address.\n', '        uint160(                 // downcast to match the address type.\n', '          uint256(               // cast to uint to truncate upper digits.\n', '            keccak256(           // compute CREATE2 hash using all inputs.\n', '              abi.encodePacked(  // pack all inputs to the hash together.\n', '                _CREATE2_HEADER, // pass in control character + factory address.\n', '                nonce,           // pass in current nonce as the salt.\n', '                initCodeHash     // pass in hash of contract creation code.\n', '              )\n', '            )\n', '          )\n', '        )\n', '      );\n', '\n', '      // Exit early if the provided smart wallet matches derived target address.\n', '      if (target == smartWallet) {\n', '        return true;\n', '      }\n', '\n', '      // Otherwise, increment the nonce and derive a new salt.\n', '      nonce++;\n', '    }\n', '\n', '    // Explicity recognize no target was found matching provided smart wallet.\n', '    return false;\n', '  }\n', '\n', '  function _transferToken(ERC20Interface token, address to, uint256 amount) internal {\n', '    (bool success, bytes memory data) = address(token).call(\n', '      abi.encodeWithSelector(token.transfer.selector, to, amount)\n', '    );\n', '    require(\n', '      success && (data.length == 0 || abi.decode(data, (bool))),\n', '      "Transfer out failed."\n', '    );\n', '  }\n', '\n', '  function _transferEther(address recipient, uint256 etherAmount) internal {\n', '    // Send quoted Ether amount to recipient and revert with reason on failure.\n', '    (bool ok, ) = recipient.call{value:etherAmount}("");\n', '    if (!ok) {\n', '      assembly {\n', '        returndatacopy(0, 0, returndatasize())\n', '        revert(0, returndatasize())\n', '      }\n', '    }\n', '  }\n', '\n', '  function _transferInToken(ERC20Interface token, address from, uint256 amount) internal {\n', '    (bool success, bytes memory data) = address(token).call(\n', '      abi.encodeWithSelector(token.transferFrom.selector, from, address(this), amount)\n', '    );\n', '\n', '    require(\n', '      success && (data.length == 0 || abi.decode(data, (bool))),\n', '      "Transfer in failed."\n', '    );\n', '  }\n', '\n', '  function _ensureSmartWallet(\n', '    address smartWallet, address initialUserSigningKey\n', '  ) internal pure {\n', '    require(\n', '      _isSmartWallet(smartWallet, initialUserSigningKey),\n', '      "Could not resolve smart wallet using provided signing key."\n', '    );\n', '  }\n', '\n', '  function _createPathAndAmounts(\n', '    address start, address end, bool routeThroughEther\n', '  ) internal pure returns (address[] memory, uint256[] memory) {\n', '    uint256 pathLength = routeThroughEther ? 3 : 2;\n', '    address[] memory path = new address[](pathLength);\n', '    path[0] = start;\n', '\n', '    if (routeThroughEther) {\n', '      path[1] = _WETH;\n', '    }\n', '\n', '    path[pathLength - 1] = end;\n', '\n', '    return (path, new uint256[](pathLength));\n', '  }\n', '\n', '  function _ensureNoEtherFeeTypeWhenNotRouted(\n', '    bool routeThroughEther, FeeType feeType\n', '  ) internal pure {\n', '    require(\n', '      routeThroughEther || feeType != FeeType.ETHER,\n', '      "Cannot take token-for-token fee in Ether unless routed through Ether."\n', '    );\n', '  }\n', '\n', '  function _ensureNoEtherFee(FeeType feeType) internal pure {\n', '    require(\n', '      feeType != FeeType.ETHER,\n', '      "Cannot take token-for-token fee in Ether with fee on transfer."\n', '    );\n', '  }\n', '\n', '  function _delegate(address implementation) private {\n', '    assembly {\n', '      calldatacopy(0, 0, calldatasize())\n', '      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '      returndatacopy(0, 0, returndatasize())\n', '      switch result\n', '      case 0 { revert(0, returndatasize()) }\n', '      default { return(0, returndatasize()) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Modifier that throws if called by any account other than the owner\n', '   * or the supplied role, or if the caller is not the owner and the role in\n', '   * question is paused.\n', '   * @param role The role to require unless the caller is the owner.\n', '   */\n', '  modifier onlyOwnerOr(Role role) {\n', '    if (!isOwner()) {\n', '      require(_isRole(role), "Caller does not have a required role.");\n', '      require(!_isPaused(role), "Role in question is currently paused.");\n', '    }\n', '    _;\n', '  }\n', '}']