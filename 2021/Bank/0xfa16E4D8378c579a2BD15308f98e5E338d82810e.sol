['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '  function initialize() external;\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address account) external view returns (uint);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint);\n', '  function approve(address spender, uint amount) external returns (bool);\n', '  function mint(address account, uint amount) external;\n', '  function burn(address account, uint amount) external;\n', '  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'interface IUniswapRouter {\n', '\n', '  function getAmountsOut(\n', '    uint amountIn,\n', '    address[] memory path\n', '  ) external view returns (uint[] memory amounts);\n', '\n', '  function getAmountsIn(\n', '    uint amountOut,\n', '    address[] memory path\n', '  ) external view returns (uint[] memory amounts);\n', '\n', '  function swapExactTokensForTokens(\n', '    uint amountIn,\n', '    uint amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint deadline\n', '  ) external returns (uint[] memory amounts);\n', '\n', '  function addLiquidity(\n', '    address tokenA,\n', '    address tokenB,\n', '    uint amountADesired,\n', '    uint amountBDesired,\n', '    uint amountAMin,\n', '    uint amountBMin,\n', '    address to,\n', '    uint deadline\n', '  ) external returns (uint amountA, uint amountB, uint liquidity);\n', '}\n', '\n', 'interface IInterestRateModel {\n', '  function systemRate(ILendingPair _pair) external view returns(uint);\n', '  function supplyRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\n', '  function borrowRatePerBlock(ILendingPair _pair, address _token) external view returns(uint);\n', '}\n', '\n', 'interface IController {\n', '  function interestRateModel() external view returns(IInterestRateModel);\n', '  function feeRecipient() external view returns(address);\n', '  function liqMinHealth() external view returns(uint);\n', '  function liqFeePool() external view returns(uint);\n', '  function liqFeeSystem() external view returns(uint);\n', '  function liqFeeCaller() external view returns(uint);\n', '  function liqFeesTotal() external view returns(uint);\n', '  function tokenPrice(address _token) external view returns(uint);\n', '  function depositLimit(address _lendingPair, address _token) external view returns(uint);\n', '  function setFeeRecipient(address _feeRecipient) external;\n', '}\n', '\n', 'interface ILendingPair {\n', '  function checkAccountHealth(address _account) external view;\n', '  function accrueAccount(address _account) external;\n', '  function accrue() external;\n', '  function accountHealth(address _account) external view returns(uint);\n', '  function totalDebt(address _token) external view returns(uint);\n', '  function tokenA() external view returns(address);\n', '  function tokenB() external view returns(address);\n', '  function lpToken(address _token) external view returns(IERC20);\n', '  function debtOf(address _account, address _token) external view returns(uint);\n', '  function deposit(address _token, uint _amount) external;\n', '  function withdraw(address _token, uint _amount) external;\n', '  function borrow(address _token, uint _amount) external;\n', '  function repay(address _token, uint _amount) external;\n', '  function withdrawRepay(address _token, uint _amount) external;\n', '  function withdrawBorrow(address _token, uint _amount) external;\n', '  function controller() external view returns(IController);\n', '\n', '  function convertTokenValues(\n', '    address _fromToken,\n', '    address _toToken,\n', '    uint    _inputAmount\n', '  ) external view returns(uint);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() {\n', '    owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), owner);\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == owner;\n', '  }\n', '\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(owner, address(0));\n', '    owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract FeeConverter is Ownable {\n', '\n', '  uint MAX_INT = 2**256 - 1;\n', '\n', '  // Only large liquid tokens: ETH, DAI, USDC, WBTC, etc\n', '  mapping (address => bool) public permittedTokens;\n', '\n', '  IUniswapRouter public uniswapRouter;\n', '  IERC20 public wildToken;\n', '  IController public controller;\n', '  address public stakingPool;\n', '  uint public callIncentive;\n', '\n', '  event FeeDistribution(uint amount);\n', '\n', '  constructor(\n', '    IUniswapRouter _uniswapRouter,\n', '    IController _controller,\n', '    IERC20 _wildToken,\n', '    address _stakingPool,\n', '    uint _callIncentive\n', '  ) {\n', '    uniswapRouter = _uniswapRouter;\n', '    controller = _controller;\n', '    stakingPool = _stakingPool;\n', '    callIncentive = _callIncentive;\n', '    wildToken = _wildToken;\n', '  }\n', '\n', '  function convert(\n', '    address _sender,\n', '    ILendingPair _pair,\n', '    address[] memory _path,\n', '    uint _supplyTokenAmount\n', '  ) public {\n', '\n', '    _validatePath(_path);\n', '    require(_pair.controller() == controller, "FeeConverter: invalid pair");\n', '    require(_supplyTokenAmount > 0, "FeeConverter: nothing to convert");\n', '\n', '    _pair.withdraw(_path[0], _supplyTokenAmount);\n', '    IERC20(_path[0]).approve(address(uniswapRouter), MAX_INT);\n', '\n', '    uniswapRouter.swapExactTokensForTokens(\n', '      _supplyTokenAmount,\n', '      0,\n', '      _path,\n', '      address(this),\n', '      block.timestamp + 1000\n', '    );\n', '\n', '    uint wildBalance = wildToken.balanceOf(address(this));\n', '    uint callerIncentive = wildBalance * callIncentive / 100e18;\n', '    wildToken.transfer(_sender, callerIncentive);\n', '    wildToken.transfer(stakingPool, wildBalance - callerIncentive);\n', '\n', '    emit FeeDistribution(wildBalance - callerIncentive);\n', '  }\n', '\n', '  function setStakingRewards(address _value) onlyOwner public {\n', '    stakingPool = _value;\n', '  }\n', '\n', '  function setCallIncentive(uint _value) onlyOwner public {\n', '    callIncentive = _value;\n', '  }\n', '\n', '  function permitToken(address _token, bool _value) onlyOwner public {\n', '    permittedTokens[_token] = _value;\n', '  }\n', '\n', '  function _validatePath(address[] memory _path) internal view {\n', '    require(_path[_path.length - 1] == address(wildToken), "FeeConverter: must convert into WILD");\n', '\n', '    // Validate only middle tokens. Skip the first and last token.\n', '    for (uint i; i < _path.length - 1; i++) {\n', '      if (i > 0) {\n', '        require(permittedTokens[_path[i]], "FeeConverter: invalid path");\n', '      }\n', '    }\n', '  }\n', '}']