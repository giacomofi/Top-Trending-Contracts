['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-22\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Token {\n', '  function transfer(address to, uint256 value) public returns (bool success);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool success);\n', '  function balanceOf(address account) external view returns(uint256);\n', '  function allowance(address _owner, address _spender)external view returns(uint256);\n', '}\n', '\n', 'library SafeMath{\n', '      function mul(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        if (a == 0) {\n', '        return 0;}\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) \n', '    {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', 'contract SeekRewardsDex {\n', '    using SafeMath for uint;\n', '    event DepositandWithdraw(address from,address tokenAddress,uint256 amount,uint256 type_); //Type = 0-deposit 1- withdraw , Token address = address(0) - eth , address - token address;\n', '    \n', '    address payable public admin; // admin address\n', '    address payable public admin2;\n', '    address private feeAddress;\n', '    address public feeTokenAddress;\n', '    // uint256 public feeAmount;\n', '    bool public dexStatus;   // status to hold the dex transaction ;\n', '    \n', '    /*\n', '    * if status =0 no fee for fee token buyer else fee will be taken\n', '    */\n', '    \n', '    bool public feeTokenStatus;\n', '      \n', '    struct orders{ // order details\n', '        address userAddress;\n', '        address tokenAddress;\n', '        uint8 status;\n', '        uint128 type_;\n', '        uint128 price;\n', '        uint128 quantity;\n', '        uint128 tradeQuantity;\n', '    }\n', '    \n', '\n', '\n', '    struct tokens{ // token details\n', '        address tokenAddress;\n', '        string tokenSymbol;\n', '        uint128 decimals;\n', '        uint120 withdrawFee;\n', '        uint8 status;\n', '    }\n', '    \n', '   \n', '    \n', '    constructor(address payable _admin1, address payable _admin2,address feeAddress_,address feetokenaddress_,bool _status) public{ \n', '        admin = _admin1;\n', '        admin2 = _admin2;\n', '        feeAddress = feeAddress_;\n', '        dexStatus = true; // set dex status to active during contract creation\n', '        feeTokenAddress = feetokenaddress_;\n', '        feeTokenStatus = _status;\n', '    }\n', '\n', '    \n', '    mapping(uint256=>orders) public Order; //place order by passing userID and orderID as argument;\n', '    \n', '    mapping(address=>mapping(address=>uint256))public userDetails;  // trader token balance;\n', '    \n', '    mapping(address=>uint256) public withdrawfee; // admin can set fee amount to token addresses\n', '     \n', '     mapping(address=>tokens) public tokendetails; //admin can add token details\n', '     \n', '     mapping(address=>bool) public user_status; // to check user is new to dex\n', '     \n', '     mapping(uint256=>bool)public tradeOrders; // trading details;\n', '     \n', "     mapping(address=>mapping(address=>uint256))public adminProfit; //  admin profit's\n", '    \n', '    modifier dexstatuscheck(){ // check wheather dex is active or not\n', '       require(dexStatus==true);\n', '       _;\n', '    }\n', '    \n', '    modifier onlyFeeAddress(){\n', '        require(msg.sender == feeAddress);\n', '       _;\n', '    }\n', '    \n', '    modifier onlyOwner(){\n', '    require(msg.sender == admin);\n', '      _;\n', '    }\n', '    \n', '    function setDexStatus(bool status_) onlyOwner public returns(bool){ // admin can change dex to inactive if needed\n', '        dexStatus = status_; // if true dex is active & false dex is inactive\n', '        return true;\n', '    }   \n', '    \n', '    function changeFeeAddress(address changeFeeaddress) onlyOwner public returns(bool){\n', '        feeAddress = changeFeeaddress;\n', '        return true;\n', '    }\n', '    \n', '    function changeAdmin(address payable changeAdminaddress) onlyOwner public returns(bool){\n', '        admin = changeAdminaddress;\n', '        return true;\n', '    }\n', ' \n', '    function setFeeToken(address feeTokenaddress,bool _status) onlyOwner public returns(bool){\n', '        feeTokenAddress = feeTokenaddress;\n', '        feeTokenStatus = _status;\n', '        return true;\n', '    }\n', '\n', '    function addToken(address tokenAddress_,string memory tokenSymbol,uint128 decimal_,uint120 withdrawFee_) onlyFeeAddress public returns(bool){\n', '        require(tokendetails[tokenAddress_].status==0); // if status is true token already exist;\n', '        tokendetails[tokenAddress_].tokenAddress=tokenAddress_;\n', '        tokendetails[tokenAddress_].tokenSymbol=tokenSymbol; // token symbol\n', '        tokendetails[tokenAddress_].decimals=decimal_; // token decimals\n', '        tokendetails[tokenAddress_].withdrawFee = withdrawFee_;   \n', '        tokendetails[tokenAddress_].status=1; // changing token  status\n', '        return true;\n', '    }\n', '    \n', '    // verifing dex status for following functionalities.To check dex is active or not;\n', '    function deposit() dexstatuscheck public payable returns(bool) { \n', '        require((msg.sender!= admin) && (msg.sender!= admin2));\n', '        require(msg.value > 0); \n', '        userDetails[msg.sender][address(0)]=userDetails[msg.sender][address(0)].add(msg.value);\n', '        user_status[msg.sender]=true; \n', '        emit DepositandWithdraw( msg.sender, address(0),msg.value,0);\n', '        return true;\n', '    }\n', '    \n', '    function tokenDeposit(address tokenaddr,uint256 tokenAmount) dexstatuscheck public returns(bool)\n', '    {\n', '        require((msg.sender!= admin) && (msg.sender!= admin2));\n', '        require(tokenAmount > 0 && tokendetails[tokenaddr].status==1); // to deposit token , token should be added by admin\n', '        require(tokenallowance(tokenaddr,msg.sender,address(this)) > 0); // checking contract allowance by user\n', '        userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].add(tokenAmount);\n', '        Token(tokenaddr).transferFrom(msg.sender,address(this), tokenAmount);\n', '        user_status[msg.sender]=true; \n', '        emit DepositandWithdraw( msg.sender,tokenaddr,tokenAmount,0);\n', '        return true;\n', '        \n', '    }\n', '  \n', '  // user withdraw\n', '  \n', '    function withdraw(uint8 type_,address tokenaddr,uint256 amount) dexstatuscheck public returns(bool) {\n', '        require((msg.sender!= admin) && (msg.sender!= admin2));\n', '        require((type_ ==0) || (type_ == 1)); // type : 0- ether withdraw 1- token withdraw;\n', '         if(type_==0){ // withdraw ether\n', '         require(tokenaddr == address(0)); // tokenaddress should be ether (address(0))\n', '         require(amount>0 && amount <= userDetails[msg.sender][address(0)] && withdrawfee[address(0)]<amount); //check user balance\n', '         require(amount<=address(this).balance);\n', '                msg.sender.transfer(amount.sub(withdrawfee[address(0)]));   // transfer withdraw amount  \n', '                userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount); // decreasing user balance\n', '                adminProfit[admin][address(0)] = adminProfit[admin][address(0)].add(withdrawfee[address(0)]); // increasing withdraw fee\n', '                \n', '        }\n', '        else{ //withdraw token\n', '        require(tokenaddr != address(0) && tokendetails[tokenaddr].status==1);   // token address should not be ether \n', '        require(amount>0 && amount <= userDetails[msg.sender][tokenaddr] && withdrawfee[tokenaddr]<amount);\n', '              Token(tokenaddr).transfer(msg.sender, (amount.sub(withdrawfee[tokenaddr])));// transfer withdraw amount  \n', '              userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].sub(amount);  // decreasing user balance\n', '              adminProfit[admin][tokenaddr] = adminProfit[admin][tokenaddr].add(withdrawfee[tokenaddr]); // increasing withdraw fee\n', '        }\n', '        emit DepositandWithdraw( msg.sender,tokenaddr,amount,1);\n', '        return true;\n', '    }\n', '    \n', '    //admin profit withdraw\n', '     function adminProfitWithdraw(uint8 type_,address tokenAddr)public returns(bool){ //  tokenAddr = type 0 - address(0),  type 1 - token address;\n', '       require((msg.sender == admin) || (msg.sender == admin2)); // only by admin\n', '       require(type_ ==0 || type_ == 1);\n', '         if(type_==0){ // withdraw ether\n', '            msg.sender.transfer(adminProfit[msg.sender][address(0)]); // total  ether profit is transfered to admin\n', '            adminProfit[msg.sender][address(0)]=0; // set 0 to admin ether profit after transfer\n', '                \n', '        }\n', '        else{ //withdraw token\n', '            require(tokenAddr != address(0)) ;\n', '            Token(tokenAddr).transfer(msg.sender, adminProfit[msg.sender][tokenAddr]); // total  token profit is transfered to admin\n', '            adminProfit[msg.sender][tokenAddr]=0;// set 0 to admin token profit after transfer\n', '        }\n', '            return true;\n', '        }\n', '        \n', '        \n', '    function setwithdrawfee(address[] memory addr,uint120[] memory feeamount)public returns(bool)  // admin can set withdraw fee for token and ether\n', '        {\n', '          require(msg.sender==admin);\n', '          //array length should be within 10.\n', '          require(addr.length <10 && feeamount.length < 10 && addr.length==feeamount.length);\n', '          for(uint8 i=0;i<addr.length;i++){\n', '                withdrawfee[addr[i]]=feeamount[i];   \n', '                tokendetails[addr[i]].withdrawFee = feeamount[i];   //storing value of fee   \n', '          }\n', '           return true;\n', '        }\n', '\n', '    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) { // vrs signature verification\n', '        string memory header = "\\x19Ethereum Signed Message:\\n000000";\n', '        uint256 lengthOffset;\n', '        uint256 length;\n', '        assembly {\n', '            length := mload(message)\n', '            lengthOffset := add(header, 57)\n', '        }\n', '        require(length <= 999999);\n', '        uint256 lengthLength = 0;\n', '        uint256 divisor = 100000; \n', '        while (divisor != 0) {\n', '            uint256 digit = length.div(divisor);\n', '            if (digit == 0) {\n', '             \n', '                if (lengthLength == 0) {\n', '                      divisor = divisor.div(10);\n', '                      continue;\n', '                    }\n', '            }\n', '            lengthLength++;\n', '            length = length.sub(digit.mul(divisor));\n', '            divisor = divisor.div(10);\n', '            digit = digit.add(0x30);\n', '            lengthOffset++;\n', '            assembly {\n', '                mstore8(lengthOffset, digit)\n', '            }\n', '        }  \n', '        if (lengthLength == 0) {\n', '            lengthLength = 1 + 0x19 + 1;\n', '        } else {\n', '            lengthLength = lengthLength.add(1 + 0x19);\n', '        }\n', '        assembly {\n', '            mstore(header, lengthLength)\n', '        }\n', '        bytes32 check = keccak256(abi.encodePacked(header, message));\n', '        return ecrecover(check, v, r, s);\n', '    }\n', '    \n', '    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory){\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', ' \n', '    function addressToString(address _addr) internal pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '    \n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\n', '            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\n', '        }\n', '        return string(str);\n', '    }\n', ' \n', '    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = byte(uint8(48 + _i % 10));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    \n', ' \n', '    // makerOrder\n', '      // 0- orderid\n', '      // 1- quantity\n', '      // 2- price\n', '      // 3 - type  1- buy 2- sell\n', '      // 4- expiryTime\n', '      // 5 - trade amount\n', '      // 6 - buyer dex token status\n', '      // 7 - trade fee\n', '  \n', '    // takerOrder\n', '      // 0- orderid\n', '      // 1- quantity\n', '      // 2- price\n', '      // 3 - type  1- buy 2- sell\n', '      // 4- expiryTime\n', '      // 5 - trade amount\n', '      // 6 - buyer dex token status\n', '      // 7 - trade fee\n', '  \n', '    // tradeAddress\n', '    // 0- makertokenAddress\n', '    // 1- makeruserAddress\n', '    // 2 - takertokenaddress\n', '    // 3 - takeruseraddress\n', '    function makeOrder(uint128[8] memory makerOrder, uint128[8] memory takerOrder,address[4] memory tradeAddress,uint8[2] memory  v,bytes32[4] memory rs) onlyFeeAddress public returns(bool){\n', '        require(tradeOrders[makerOrder[0]]!=true && tradeOrders[takerOrder[0]] !=true);\n', '        require(makerOrder[4]>=block.timestamp && takerOrder[4]>=block.timestamp);  // expiry time less than current time\n', '        uint256 amount__m;\n', '        uint256 amount__t;\n', '        makerOrder[6]=0;\n', '        takerOrder[6]=0;\n', '        \n', '        \n', '        if(Order[makerOrder[0]].status ==0){ // if maker order is new;  && tradeAddress[0]!=feeTokenAddress\n', '            // if maker buy or sell but receiving amt is fee token \n', '            if(tradeAddress[2]==feeTokenAddress){\n', '                (feeTokenStatus) ? makerOrder[6]=1 : makerOrder[6]=0;\n', '            }\n', '            else{\n', '                require(userDetails[tradeAddress[1]][feeTokenAddress]>=makerOrder[7]);   // trade will happen event if fee amount is unset\n', '                makerOrder[6]=1;\n', '                if(tradeAddress[0] == feeTokenAddress ){\n', '                  amount__m =amount__m.add(makerOrder[7]);\n', '                }\n', '            }\n', '            // vrs verification  for maker  when order is new;\n', '            require(verify(strConcat(uint2str(makerOrder[0]),addressToString(tradeAddress[0]),uint2str(makerOrder[2]),uint2str(makerOrder[1]),uint2str(makerOrder[4])),v[0],rs[0],rs[1])==tradeAddress[1]);\n', '            makerOrder[5] = makerOrder[1];\n', '        }\n', '        else{\n', '            require(Order[makerOrder[0]].tradeQuantity > 0);\n', '           \n', '            makerOrder[2] = Order[makerOrder[0]].price;\n', '            makerOrder[3] = Order[makerOrder[0]].type_;\n', '            makerOrder[5] = Order[makerOrder[0]].tradeQuantity;\n', '            tradeAddress[0] = Order[makerOrder[0]].tokenAddress;\n', '            tradeAddress[1] = Order[makerOrder[0]].userAddress;\n', '        }\n', '\n', '        if(Order[takerOrder[0]].status ==0){  // if taker order is new;\n', '            // if taker buy or sell but receiving amt is fee token \n', '            if(tradeAddress[0]==feeTokenAddress){\n', '                (feeTokenStatus) ? takerOrder[6]=1 : takerOrder[6]=0;\n', '            }\n', '            else{\n', '                // trade will happen even if fee amount is unset\n', '                require(userDetails[tradeAddress[3]][feeTokenAddress]>=takerOrder[7]);      \n', '                takerOrder[6]=1;\n', '                \n', '                if(tradeAddress[2] == feeTokenAddress){\n', '                    amount__t =amount__t.add(takerOrder[7]);\n', '                }\n', '            }\n', '            // vrs verification  for taker  when order is new;\n', '            require(verify(strConcat(uint2str(takerOrder[0]),addressToString(tradeAddress[2]),uint2str(takerOrder[2]),uint2str(takerOrder[1]),uint2str(takerOrder[4])),v[1],rs[2],rs[3])==tradeAddress[3]);\n', '            takerOrder[5] = takerOrder[1];\n', '        }\n', '        else{\n', '            require(Order[takerOrder[0]].tradeQuantity > 0);\n', '            takerOrder[2] = Order[takerOrder[0]].price;\n', '            takerOrder[3] = Order[takerOrder[0]].type_;\n', '            takerOrder[5] = Order[takerOrder[0]].tradeQuantity;\n', '            tradeAddress[2] = Order[takerOrder[0]].tokenAddress;\n', '            tradeAddress[3] = Order[takerOrder[0]].userAddress;\n', '        }\n', '\n', '        uint128 tradeAmount;\n', '\n', '        if(takerOrder[5] > makerOrder[5]){\n', '            tradeAmount = makerOrder[5];\n', '        }\n', '        else{\n', '            tradeAmount = takerOrder[5];\n', '        }\n', '        \n', '        //if maker order is buy \n', '        if(makerOrder[3] == 1){ \n', '            amount__m =amount__m.add(((tradeAmount)*(makerOrder[2]))/tokendetails[tradeAddress[0]].decimals) ; // maker buy trade amount\n', '            amount__t =amount__t.add(tradeAmount);  // taker sell trade amount;\n', '        }\n', '        else{    //else maker order is sell \n', '            amount__m = amount__m.add(tradeAmount); // maker sell trade amount\n', '            amount__t = amount__t.add(tradeAmount*(makerOrder[2])/ tokendetails[tradeAddress[2]].decimals); // taker sell trade amount\n', '        }\n', '        \n', '        if(userDetails[tradeAddress[1]][tradeAddress[0]]<amount__m){  // trade amount <= maker balance;\n', '            return false;\n', '        }\n', '        \n', '        if(userDetails[tradeAddress[3]][tradeAddress[2]]<amount__t){ // trader amount <= taker balance\n', '            return false;\n', '        }\n', '\n', '        if(takerOrder[5] > makerOrder[5]){\n', '            if(Order[takerOrder[0]].status!=1){\n', '                Order[takerOrder[0]].userAddress = tradeAddress[3];\n', '                Order[takerOrder[0]].type_ = takerOrder[3];\n', '                Order[takerOrder[0]].price = takerOrder[2];\n', '                Order[takerOrder[0]].quantity  = takerOrder[1];\n', '                Order[takerOrder[0]].tradeQuantity  = takerOrder[5];\n', '                Order[takerOrder[0]].tokenAddress = tradeAddress[2];\n', '                Order[takerOrder[0]].status=1; // storing taker order details and updating status to 1\n', '            }\n', '            Order[takerOrder[0]].tradeQuantity -=tradeAmount; \n', '            Order[makerOrder[0]].tradeQuantity=0;\n', '            tradeOrders[makerOrder[0]] = true;\n', '        }\n', '        else if(takerOrder[5] < makerOrder[5]){\n', '            if(Order[makerOrder[0]].status!=1  ){\n', '                Order[makerOrder[0]].userAddress = tradeAddress[1];\n', '                Order[makerOrder[0]].type_ = makerOrder[3];\n', '                Order[makerOrder[0]].price = makerOrder[2];\n', '                Order[makerOrder[0]].quantity  = makerOrder[1];\n', '                Order[makerOrder[0]].tradeQuantity  =  makerOrder[5];\n', '                Order[makerOrder[0]].tokenAddress = tradeAddress[0];\n', '                Order[makerOrder[0]].status=1; // storing maker order details and updating status to 1     \n', '             }\n', '            Order[makerOrder[0]].tradeQuantity -=tradeAmount;\n', '            Order[takerOrder[0]].tradeQuantity=0;\n', '            tradeOrders[takerOrder[0]] = true;\n', '        }\n', '        else{\n', '            Order[makerOrder[0]].tradeQuantity=0;\n', '            Order[takerOrder[0]].tradeQuantity=0;\n', '            tradeOrders[makerOrder[0]] = true;\n', '            tradeOrders[takerOrder[0]] = true;\n', '        }\n', '        // maker receive amount\n', '        makerOrder[5] = uint128(amount__t); \n', '        // taker receive amount\n', '        takerOrder[5] = uint128(amount__m);\n', '                    \n', '        if(makerOrder[6]==1 ){\n', '            // If maker is seller and token sold is feetoken\n', '            // fee is deducted from the user(maker) and admin balance(feetoken) is updated\n', '            if(tradeAddress[0] == feeTokenAddress){\n', '                amount__m = amount__m.sub(makerOrder[7]);\n', '                takerOrder[5]=sub128(takerOrder[5],uint128(makerOrder[7]));\n', '                // reduce user balance\n', '                userDetails[tradeAddress[1]][feeTokenAddress] =userDetails[tradeAddress[1]][feeTokenAddress].sub(makerOrder[7]);\n', '                // update admin balance\n', '                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));\n', '                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));\n', '            }\n', '            // If maker is buyer and token buy is fee token or maker is seller and receiving token is fee token.\n', '            else if(tradeAddress[2] == feeTokenAddress){\n', '                // trade amount >= feeAmount\n', '                if(makerOrder[5]>=makerOrder[7]){\n', '                    makerOrder[5] = sub128(makerOrder[5],uint128(makerOrder[7]));\n', '                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));     \n', '                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));     \n', '                }\n', '                // trade amount < feeAmount\n', '                // admin  blance is update with trade amount\n', '                // trade amount is set to 0\n', '                else{\n', '                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(makerOrder[5]).div(2));\n', '                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[5]).div(2));\n', '                    // hence reset to 0\n', '                    makerOrder[5] = 0;\n', '                }\n', '            }\n', '            // general trade for tokens other than feetoken\n', '            else{\n', '                userDetails[tradeAddress[1]][feeTokenAddress] =userDetails[tradeAddress[1]][feeTokenAddress].sub(makerOrder[7]);\n', '                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(makerOrder[7]).div(2));\n', '                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(makerOrder[7]).div(2));\n', '            }\n', '        }\n', '            \n', '        if(takerOrder[6]==1){\n', '            // If taker is seller and token sold is feetoken\n', '            // fee is deducted from the user(taker) and admin balance(feetoken) is updated\n', '            if(tradeAddress[2] == feeTokenAddress){\n', '                amount__t = amount__t.sub(takerOrder[7]);\n', '                makerOrder[5] =sub128(makerOrder[5],uint128(takerOrder[7]));\n', '                // reduce user balance\n', '                userDetails[tradeAddress[3]][feeTokenAddress] = userDetails[tradeAddress[3]][feeTokenAddress].sub(takerOrder[7]);\n', '                // update admin balance\n', '                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));  \n', '                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));  \n', '            }\n', '            // If taker is buyer and token buy is fee token or taker is seller and receiving token is fee token.\n', '            else if(tradeAddress[0] == feeTokenAddress){\n', '                // user balance >= fee amount\n', '                // fee is deducted from the user(taker) and admin balance(feetoken) is updated\n', '              \n', '                // trade amount >= feeAmount\n', '                if(takerOrder[5]>=takerOrder[7]){\n', '                    takerOrder[5] = sub128(takerOrder[5],uint128(takerOrder[7]));\n', '                    adminProfit[admin][feeTokenAddress] = adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));\n', '                    adminProfit[admin2][feeTokenAddress] = adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));\n', '                }\n', '                // trade amount < feeAmount\n', '                // admin  blance is update with trade amount\n', '                // trade amount is set to 0\n', '                else{\n', '                    adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[5]).div(2));        \n', '                    adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[5]).div(2));   \n', '                    \n', '                    takerOrder[5]=0;\n', '                }\n', '                \n', '            }\n', '            // general trade for tokens other than feetoken\n', '            else{\n', '                userDetails[tradeAddress[3]][feeTokenAddress] = userDetails[tradeAddress[3]][feeTokenAddress].sub(takerOrder[7]);\n', '                adminProfit[admin][feeTokenAddress] =adminProfit[admin][feeTokenAddress].add(uint(takerOrder[7]).div(2));   \n', '                adminProfit[admin2][feeTokenAddress] =adminProfit[admin2][feeTokenAddress].add(uint(takerOrder[7]).div(2));   \n', '            }\n', '        }\n', '                    \n', "        // decrease taker and maker's balance with trade amount;\n", '        userDetails[tradeAddress[1]][tradeAddress[0]] = userDetails[tradeAddress[1]][tradeAddress[0]].sub(amount__m);   // freeze buyer amount   \n', '        userDetails[tradeAddress[3]][tradeAddress[2]] = userDetails[tradeAddress[3]][tradeAddress[2]].sub(amount__t);   // freeze buyer amount \n', '        \n', '        //trading\n', '        userDetails[tradeAddress[1]][tradeAddress[2]] = userDetails[tradeAddress[1]][tradeAddress[2]].add(makerOrder[5]); //marker order\n', '        userDetails[tradeAddress[3]][tradeAddress[0]] = userDetails[tradeAddress[3]][tradeAddress[0]].add(takerOrder[5]); //take order\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function sub128(uint128 a, uint128 b) internal pure  returns (uint128) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    \n', '     function viewTokenBalance(address tokenAddr,address baladdr)public view returns(uint256){ // to check token balance\n', '        return Token(tokenAddr).balanceOf(baladdr);\n', '    }\n', '    \n', '    function tokenallowance(address tokenAddr,address owner,address _spender) public view returns(uint256){ // to check token allowance to contract\n', '        return Token(tokenAddr).allowance(owner,_spender);\n', '    }\n', '    \n', '\n', '}']