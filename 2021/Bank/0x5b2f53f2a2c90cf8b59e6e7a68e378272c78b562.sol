['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-28\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2017-11-28\n', '*/\n', '\n', 'pragma solidity  ^0.4.0 ;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', '  \n', 'library SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { \n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0);\n', '    uint256 c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '//   function assert(bool assertion) internal {\n', '//     if (!assertion) {\n', '//       throw;\n', '//     }\n', '//   }\n', '}\n', '  \n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', ' \n', ' contract Ownable {\n', '    address public owner;\n', '    mapping (address =>  bool) public admins;\n', '\n', '    function owned() public {\n', '        owner = msg.sender;\n', '        admins[msg.sender]=true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner,"Caller is not the owner");\n', '        _;\n', '    }\n', '     modifier onlyAdmin   {\n', '        require(admins[msg.sender] == true,"Caller is not the admin");\n', '        _;\n', '    }\n', '\n', '    // function transferOwnership(address newOwner) onlyOwner public {\n', '    //     owner = newOwner;\n', '    // }\n', '     function makeAdmin(address newAdmin, bool isAdmin) onlyOwner public{\n', '        admins[newAdmin] = isAdmin;\n', '    }\n', '}\n', '  \n', ' \n', 'contract ERC20Basic{\n', '    uint256 public totalSupply_; \n', '    string public  name  ;\n', '    string public   symbol ;\n', '    uint8 public constant decimals = 18;\n', '    \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '     \n', '     \n', '    using SafeMath for uint256;\n', '  \n', '   /**\n', '    * @dev Fix for the ERC20 short address attack.\n', '    */\n', '    modifier onlyPayloadSize(uint size) {\n', '        require(!(msg.data.length < size + 4));\n', '        _;\n', '    }\n', '     \n', '    function totalSupply() public   view returns (uint256 ) {\n', '    return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(address owner_) public  view returns (uint256 ) {\n', '        return (balances[owner_]);\n', '    }\n', '\n', '\n', '\n', '    function approve(address delegate, uint256 amount) public   returns (bool) {\n', '        allowed[msg.sender][delegate] = amount;\n', '        emit Approval(msg.sender, delegate, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner_, address delegate) public   view returns (uint256) {\n', '        return allowed[owner_][delegate];\n', '    }\n', '\n', '   \n', '   \n', '} \n', 'contract BlackList is Ownable, ERC20Basic {\n', '    \n', '     mapping (address => bool) public isBlackListed; \n', '    /////// Getters to allow the same blacklist to be used also by other contracts (including upgraded AEDC) ///////\n', '    function getBlackListStatus(address _maker) external view returns (bool) {\n', '        return isBlackListed[_maker];\n', '    } \n', '    function getOwner() external view returns (address) {\n', '        return owner;\n', '    } \n', '    function addBlackList (address _evilUser) public onlyAdmin {\n', '        isBlackListed[_evilUser] = true;\n', '       emit AddedBlackList(_evilUser);\n', '    } \n', '    function removeBlackList (address _clearedUser) public onlyAdmin {\n', '        isBlackListed[_clearedUser] = false;\n', '       emit RemovedBlackList(_clearedUser);\n', '    } \n', '    function destroyBlackFunds (address _blackListedUser) public onlyAdmin {\n', '        require(isBlackListed[_blackListedUser]);\n', '        uint dirtyFunds = balanceOf(_blackListedUser);\n', '        balances[_blackListedUser] = 0;\n', '        totalSupply_ =totalSupply_.safeSub(dirtyFunds);\n', '       emit DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n', '    }\n', '\n', '    event DestroyedBlackFunds(address _blackListedUser, uint _balance);\n', '\n', '    event AddedBlackList(address _user);\n', '\n', '    event RemovedBlackList(address _user);\n', '\n', '}\n', '\n', '  \n', ' \n', ' /******************************************/\n', '/*       ADVANCED TOKEN STARTS HERE       */\n', '/******************************************/\n', '\n', 'contract AEDC is  BlackList {\n', '    uint256 public totalIcoSupply;\n', '    uint256  buyPrice;\n', '    uint256  buyBackPrice; \n', '    uint256  icoBuyPrice; \n', '    uint256  transactionFee;  \n', '    uint256  icoStartTime;\n', '    uint256  icoEndTime;\n', '    mapping(address => uint256) icoBalances;\n', '    event TransferICO(address indexed from, address indexed to, uint256 value); // transfer ico  \n', '    event IcoWithdrawn(address indexed owner_ , uint256 value,  uint256 time); // generates event when ico holder convert into AEDC coin \n', '    event Withdrawn(address indexed _to, uint256 value);// transfer balance to owner \n', '    event Issue(uint256 amount);// Called when new token are issued \n', '    event Redeem(uint256 amount); // Called when tokens are redeemed \n', '    event BuyPrice(uint256 value); // generates event on chenge coin buy price from ETH\n', '    event BuyBackPrice(uint256 value);// generates event on chenge coin sell price in ETH\n', '    event IcoBuyPrice(uint256 value); // generates event on chenge ico buy price from ETH\n', '    event Bought(uint256 amount);\n', '    event BoughtICO(uint256 amount);\n', '    event Sold(uint256 amount);\n', '    /* Initializes contract with initial supply tokens to the creator of the contract */ \n', '    constructor(uint256  initialSupply,uint256 icoInitialSupply,string memory tokenName, string memory tokenSymbol,uint256 icoSatrtTime_,uint256 icoEndTime_,uint256 buyPrice_,uint256 buyBackPrice_,uint256 icoBuyPrice_,uint256 transactionFee_) public {\n', '        owned() ;\n', '        totalSupply_ = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        totalIcoSupply = icoInitialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n', '        balances[this] = totalSupply_;                // Give the creator all initial tokens \n', '        icoBalances[this] = totalIcoSupply;          // Give the creator all initial ico Coins\n', '        name = tokenName;                                   // Set the name for display purposes\n', '        symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '        icoStartTime = icoSatrtTime_; // start ico   \n', '        icoEndTime = icoEndTime_;    \n', '        buyPrice = buyPrice_;\n', '        buyBackPrice = buyBackPrice_;\n', '        icoBuyPrice = icoBuyPrice_;\n', '        transactionFee = transactionFee_;\n', '      } \n', '      \n', '    using SafeMath for uint256;\n', '      \n', '    /* Internal transfer  ICO, only can be called by this contract */\n', '    function _transferICO(address _from, address _to, uint256 _value) internal {\n', '        require (_to != 0x0);      // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (icoBalances[_from] >= _value ,"Don\'t have enough ICO  balances.");               // Check if the sender has enough\n', '        require ( (icoBalances[_to] + _value) > icoBalances[_to]); // Check for overflows\n', '        require(!isBlackListed[_from],"Sender is black Listed");                     // Check if sender is isBlackListed\n', '        require(!isBlackListed[_to],"Recipient is black listed");                       // Check if recipient is isBlackListed\n', '        icoBalances[_from] = icoBalances[_from].safeSub( _value);                         // Subtract from the sender\n', '        icoBalances[_to] = icoBalances[_to].safeAdd( _value);                           // Add the same to the recipient\n', '        emit TransferICO(_from, _to, _value);\n', '    } \n', '      /* Transfer ICO Coins from other address By owner */\n', '    function transferICO( address _to, uint256 _value)  public  returns (bool success) {  \n', '        _transferICO(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '      /* Transfer ICO Coins from other address By owner */\n', '    function transferICOFrom(address _from, address _to, uint256 _value) onlyAdmin public  returns (bool success) {  \n', '        require (icoBalances[_from] >=  (_value+transactionFee),"Don\'t have enough ICO balances.");\n', '        icoBalances[_from] = icoBalances[_from].safeSub(transactionFee);// Subtract from the targeted balance \n', '        icoBalances[this] = icoBalances[this].safeAdd(transactionFee); //return tokens to owner \n', '        _transferICO(_from, _to, _value);\n', '        return true;\n', '    }\n', '     \n', '    /* Internal transfer, only can be called by this contract */\n', '    function _transfer(address _from, address _to, uint256 _value) internal {\n', '        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '        require (balances[_from] >= _value,"Don\'t have enough balances.");               // Check if the sender has enough\n', '        require ( (balances[_to] + _value) > balances[_to]); // Check for overflows\n', '        require(!isBlackListed[_from],"Sender  is black listed");                     // Check if sender is isBlackListed\n', '        require(!isBlackListed[_to],"Recipient is black listed");                       // Check if recipient is isBlackListed\n', '        balances[_from] = balances[_from].safeSub( _value);                         // Subtract from the sender\n', '        balances[_to] = balances[_to].safeAdd( _value);                           // Add the same to the recipient\n', '        emit Transfer(_from, _to, _value);\n', '    } \n', '    \n', '     function sell_(uint256 amount) internal  {\n', '        require(!isBlackListed[msg.sender],"Sender is black listed");                     // Check if sender is black listed\n', '        require(balances[msg.sender] >= amount,"You need to sell at least some AEDC");         // checks if the sender has enough to sell\n', '        uint256 revenue=amount.safeMul(buyBackPrice);\n', '        revenue=revenue.safeDiv(10 ** uint256(decimals));\n', '        require(revenue<=address(this).balance,"Not enough ether balance in the reserve to Buy AEDC");\n', "        balances[this] = balances[this].safeAdd(amount)  ;                       // adds the amount to owner's balance\n", "        balances[msg.sender] = balances[msg.sender].safeSub(amount);             // subtracts the amount from seller's balance\n", '        msg.sender.transfer(revenue); \n', '        emit Sold(amount);              // executes an event reflecting on the change\n', '                                            // ends function and returns\n', '    }\n', '    \n', '    // transfer coin \n', '     function transfer( address _to, uint256 _value)  public  returns (bool) { \n', '         \n', '         if( _to==address(this))\n', '         {\n', '            sell_(_value); \n', '            emit Transfer(msg.sender, this, _value);\n', '            \n', '         }\n', '         else \n', '         {\n', '              _transfer(msg.sender, _to, _value);\n', '         }\n', '       \n', '        return true;\n', '    } \n', '     function transferFrom(address owner_, address buyer, uint256 amount_) public   returns (bool) {\n', '        require(amount_ <= balances[owner_],"Don\'t have enough balances.");\n', '        require(amount_ <= allowed[owner_][msg.sender]);  \n', '        allowed[owner_][msg.sender] = allowed[owner_][msg.sender].safeSub(amount_); \n', '        _transfer(owner_, buyer, amount_); \n', '        return true;\n', '    }\n', '    \n', '   /** * Transfer Coins from other address By owner  */\n', '    function transferCoinFrom(address _from, address _to, uint256 _value) onlyAdmin public  returns (bool success) {  \n', '        require (balances[_from] >=  (_value+transactionFee),"Don\'t have enough balances.");\n', '        balances[_from] = balances[_from].safeSub(  transactionFee);// Subtract from the targeted balance \n', '        balances[this] =balances[this].safeAdd(transactionFee); \n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '     /* Internal ico Withdrawn, only can be called by this contract */\n', '    function _icoWithdrawn(address owner_, uint256 _value) internal {\n', '        require( block.timestamp >=icoEndTime,"ICO Withdrawn not allowed"); \n', '        require (icoBalances[owner_] >= _value,"Don\'t have enough ICO balances.");               // Check if the sender has enough\n', '        require ( (balances[owner_] + _value) > balances[owner_]); // Check for overflows\n', '        require(!isBlackListed[owner_],"Owner is black listed ");                     // Check if sender is isBlackListed  \n', '        icoBalances[owner_] =  icoBalances[owner_].safeSub( _value);                         // Subtract from the sender\n', '        totalIcoSupply=totalIcoSupply.safeSub(_value);  // subtract from total ico supply \n', '        _transfer(address(this), owner_, _value); // transer ADEC coin from contract to address \n', '        emit IcoWithdrawn(owner_, _value, block.timestamp);\n', '    } \n', '\n', '   // Ico Withdrawn by AEDC\n', '     function icoWithdrawn(  uint256 _value)  public  returns (bool) { \n', '        _icoWithdrawn(msg.sender, _value);\n', '        return true;\n', '    } \n', '    // ico Withdrawn\n', '     function icoWithdrawnFrom(address owner_, uint256 _value) onlyAdmin public   returns (bool) { \n', '        require (icoBalances[owner_] >=  (_value+transactionFee),"Don\'t have enough ICO balances.");\n', '        icoBalances[owner_] = icoBalances[owner_].safeSub(  transactionFee);// Subtract from the targeted balance \n', '        totalIcoSupply=totalIcoSupply.safeSub(transactionFee); \n', '        _icoWithdrawn(owner_, _value);\n', '        return true;\n', '    }\n', '\n', '    \n', '    /// @notice Allow users to buy tokens for `newBuyPrice`  \n', '    /// @param newBuyPrice Price users can buy from the contract denominator\n', '    function setBuyPrices( uint256 newBuyPrice) internal { \n', '        buyPrice = newBuyPrice; \n', '        emit BuyPrice(newBuyPrice);\n', '    }\n', '    /// @notice Allow users to sell tokens for `newBuyBackPrice`  \n', '    /// @param newBuyBackPrice Price users can buy from the contract denominator\n', '    function setBuyBackPrices( uint256 newBuyBackPrice) internal {\n', '        buyBackPrice = newBuyBackPrice; \n', '        emit BuyBackPrice(newBuyBackPrice);\n', '    }\n', '      /// @notice Allow owner to Set Per tokens Transfer Fee  \n', '    /// @param _transactionFee Price users pay on token transfer \n', '    function setTransactionFees( uint256 _transactionFee) internal {\n', '        transactionFee =_transactionFee ;\n', '    }\n', '     \n', '    function setPrices(uint256 newBuyPrice,uint256 newBuyBackPrice, uint256 newTransationFee) onlyAdmin public{\n', '        require(newBuyPrice>0);\n', '        require(newBuyBackPrice>0);\n', '        require(newTransationFee>0);\n', '      setBuyPrices(newBuyPrice);  \n', '      setBuyBackPrices(newBuyBackPrice);\n', '      setTransactionFees(newTransationFee);\n', '    \n', '    }\n', '     function setIcoBuyPrices( uint256 newIcoBuyPrice) onlyAdmin public {\n', '         require(newIcoBuyPrice>0);\n', '        icoBuyPrice = newIcoBuyPrice; \n', '        emit IcoBuyPrice(newIcoBuyPrice);\n', '    }\n', '   \n', '    \n', '    function setIcoTimePeriod( uint256 _icoStartTime,uint256 _icoEndTime) onlyAdmin public {\n', '        require(_icoStartTime>0);\n', '        require(_icoEndTime>0);\n', '        icoStartTime=_icoStartTime;\n', '        icoEndTime=_icoEndTime;\n', '    }\n', '    \n', '    /// @notice Buy tokens from contract by sending ether\n', '    function buy() payable public returns (uint256 amount){\n', '        require(msg.value > 0, "You need to send some Ether");\n', '        amount =  msg.value.safeMul(10 ** uint256(decimals)); \n', '        amount= amount.safeDiv(buyPrice);  // calculates the  amount\n', '        require(balanceOf(this)>=amount,"Not enough balance in the reserve to sell") ;//// checks if it has enough to sell  \n', "        balances[msg.sender] = balances[msg.sender].safeAdd(amount);    // adds the amount to buyer's balance\n", "        balances[this] = balances[this].safeSub(amount);     // subtracts amount from seller's balance\n", '        emit Transfer(this, msg.sender, amount);               // execute an event reflecting the change\n', '        return amount;                                    // ends function and returns\n', '    }\n', '     /// @notice Buy tokens from contract by sending ether\n', '    function buyICO() payable public returns (uint256 amount){\n', '        require(now <= icoEndTime,"Ico purchase not allowed");\n', '        require(msg.value > 0, "You need to send some Ether");\n', '         amount =  msg.value.safeMul(10 ** uint256(decimals)); \n', '         amount= amount.safeDiv(icoBuyPrice);  // calculates the  amount \n', '         require(icoBalances[this]>=amount,"Not enough ICO balance in the reserve to sell") ;//// checks if it has enough to sell  \n', "        icoBalances[msg.sender] = icoBalances[msg.sender].safeAdd(amount);    // adds the amount to buyer's balance\n", "        icoBalances[this] = icoBalances[this].safeSub(amount);     // subtracts amount from seller's balance\n", '        emit TransferICO(this, msg.sender, amount);               // execute an event reflecting the change\n', '        return amount;                                    // ends function and returns\n', '    }\n', '    \n', '    // Sell token on behalf of admins\n', '    // function  buyBackFrom(address _from,uint256 amount) onlyAdmin public returns (uint256 revenue){\n', '    //     require(!isBlackListed[_from],"Sender is black listed");                     // Check if sender is frozen\n', '    //     require(balances[_from] >= amount*10 ** uint256(decimals) +transactionFee,"Sender has not enough amount to sell");         // checks if the sender has enough to sell\n', "    //     balances[this] += amount*10 ** uint256(decimals) ;                       // adds the amount to owner's balance\n", "    //     balances[_from] -= amount*10 ** uint256(decimals) +transactionFee;            // subtracts the amount from seller's balance\n", '    //     revenue =  amount*buyBackPrice;\n', '    //     _from.transfer(revenue); \n', '    //     emit  Transfer(_from, this, amount*10 ** uint256(decimals));               // executes an event reflecting on the change\n', '    //     return revenue;                                   // ends function and returns\n', '    // } \n', '    \n', '     // Sell token on behalf of admins\n', '    function  buyBackFrom(uint256 amount)  onlyAdmin public returns (uint256 revenue){\n', '        require(!isBlackListed[msg.sender],"Sender is black listed");                     // Check if sender is black listed\n', '        require(balances[msg.sender] >= amount +transactionFee,"You need to sell at least some AEDC");         // checks if the sender has enough to sell\n', '        revenue=amount.safeMul(buyBackPrice);\n', '        revenue=revenue.safeDiv(10 ** uint256(decimals));\n', '        require(revenue<=address(this).balance,"Not enough ether balance in the reserve to Buy AEDC");\n', '        balances[this] = balances[this].safeAdd(amount)  ; \n', "        balances[this] = balances[this].safeAdd(transactionFee)  ; // adds the amount to owner's balance\n", "        balances[msg.sender] = balances[msg.sender].safeSub(amount);             // subtracts the amount from seller's balance\n", '        balances[msg.sender] = balances[msg.sender].safeSub(transactionFee);  \n', '        msg.sender.transfer(revenue); \n', '        emit Sold(amount);              // executes an event reflecting on the change\n', '        return revenue;                                   // ends function and returns\n', '    } \n', '    \n', '    function sell(uint256 amount) public returns (uint256 revenue){\n', '        require(!isBlackListed[msg.sender],"Sender is black listed");                     // Check if sender is black listed\n', '        require(balances[msg.sender] >= amount,"You need to sell at least some AEDC");         // checks if the sender has enough to sell\n', '        revenue=amount.safeMul(buyBackPrice);\n', '        revenue=revenue.safeDiv(10 ** uint256(decimals));\n', '        require(revenue<=address(this).balance,"Not enough ether balance in the reserve to Buy AEDC");\n', "        balances[this] = balances[this].safeAdd(amount)  ;                       // adds the amount to owner's balance\n", "        balances[msg.sender] = balances[msg.sender].safeSub(amount);             // subtracts the amount from seller's balance\n", '        msg.sender.transfer(revenue); \n', '        emit Sold(amount);              // executes an event reflecting on the change\n', '        return revenue;                                   // ends function and returns\n', '    }\n', '      \n', '      \n', '      \n', '    // transfer ether to admins\n', '\tfunction withdrawEther(uint256 amount) onlyAdmin public {\n', '\t    require(admins[msg.sender]==true,"");  \n', '\t    msg.sender.transfer(amount);\n', '\t    emit  Withdrawn(msg.sender, amount);\n', '\t\t\n', '\t} \n', '\t // transfer balance to owner\n', '\tfunction withdrawEtherToOwner(uint256 amount) onlyOwner public {\n', '\t\trequire(msg.sender == owner);\n', '\t\tmsg.sender.transfer(amount);\n', '\t}\n', '\t \t// can accept ether\n', '\tfunction() public payable { \n', '\t    require(msg.value > 0, "You need to send some Ether");\n', '        uint256 amount =  msg.value.safeMul(10 ** uint256(decimals)); \n', '        amount= amount.safeDiv(buyPrice);  // calculates the  amount\n', '        require(balanceOf(this)>=amount,"Not enough balance in the reserve to sell") ;//// checks if it has enough to sell  \n', "        balances[msg.sender] = balances[msg.sender].safeAdd(amount);    // adds the amount to buyer's balance\n", "        balances[this] = balances[this].safeSub(amount);     // subtracts amount from seller's balance\n", '        emit Transfer(this, msg.sender, amount);               // execute an event reflecting the change\n', ' \n', '    } \n', '   function TranserEtherToContract() payable public  {\n', '           \n', '    }\n', '\t  \n', '\t  // get ico balance\n', '\t  function icoBalanceOf(address owner_) public  view returns (uint256) {\n', '        return icoBalances[owner_];\n', '    }\n', '\t  \n', '\t // get buyPrice\n', '\tfunction getBuyPrice() public   view returns (uint256) {\n', '        return buyPrice;\n', '    }\n', '\t // get buyBackPrice\n', '\tfunction getBuyBackPrice() public   view returns (uint256) {\n', '        return buyBackPrice;\n', '    }\n', '\t // get transaction Fee\n', '\t   function getTransactionFee() public   view returns (uint256) {\n', '        return transactionFee;\n', '    }\n', '\t // get icoBuyPrice\n', '\tfunction getIcoBuyPrice() public   view returns (uint256) {\n', '        return icoBuyPrice;\n', '    }\n', '\t \n', '    function getTotalIcoSupply() public   view returns (uint256) {\n', '        return totalIcoSupply;\n', '    }\n', '    function getIcoStartTime() public view returns(uint256)\n', '\t{\n', '\t\treturn icoStartTime;\n', '\t} \n', '\t function getIcoEndTime() public view returns(uint256)\n', '\t{\n', '\t\treturn icoEndTime;\n', '\t} \n', '\tfunction getIcoTimePeriod() public view returns(uint256)\n', '\t{\n', '\t\treturn icoEndTime.safeSub(icoStartTime);\n', '\t} \n', '      \n', '\tfunction TimeNow() public view returns(uint256)\n', '\t{\n', '\t\treturn now;\n', '\t}\n', ' \n', '}']