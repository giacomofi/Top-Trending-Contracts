['// SPDX-License-Identifier: Unlicensed\n', '\n', 'pragma solidity ^0.8.6;\n', '\n', 'import "./ownable.sol";\n', '\n', 'interface IERC20 {\n', '\t/**\n', '\t* @dev Returns the amount of tokens in existence.\n', '\t*/\n', '\tfunction totalSupply() external view returns (uint256);\n', '\n', '\t/**\n', '\t* @dev Returns the amount of tokens owned by `account`.\n', '\t*/\n', '\tfunction balanceOf(address account) external view returns (uint256);\n', '\n', '\t/**\n', "\t* @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '\t*\n', '\t* Returns a boolean value indicating whether the operation succeeded.\n', '\t*\n', '\t* Emits a {Transfer} event.\n', '\t*/\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '\t/**\n', '\t* @dev Returns the remaining number of tokens that `spender` will be\n', '\t* allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '\t* zero by default.\n', '\t*\n', '\t* This value changes when {approve} or {transferFrom} are called.\n', '\t*/\n', '\tfunction allowance(address owner, address spender) external view returns (uint256);\n', '\n', '\t/**\n', "\t* @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '\t*\n', '\t* Returns a boolean value indicating whether the operation succeeded.\n', '\t*\n', '\t* IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '\t* that someone may use both the old and the new allowance by unfortunate\n', '\t* transaction ordering. One possible solution to mitigate this race\n', "\t* condition is to first reduce the spender's allowance to 0 and set the\n", '\t* desired value afterwards:\n', '\t* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t*\n', '\t* Emits an {Approval} event.\n', '\t*/\n', '\tfunction approve(address spender, uint256 amount) external returns (bool);\n', '\n', '\t/**\n', '\t* @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "\t* allowance mechanism. `amount` is then deducted from the caller's\n", '\t* allowance.\n', '\t*\n', '\t* Returns a boolean value indicating whether the operation succeeded.\n', '\t*\n', '\t* Emits a {Transfer} event.\n', '\t*/\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '\t/**\n', '\t* @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '\t* another (`to`).\n', '\t*\n', '\t* Note that `value` may be zero.\n', '\t*/\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '\t/**\n', '\t* @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '\t* a call to {approve}. `value` is the new allowance.\n', '\t*/\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\t/**\n', '\t* @dev Returns the addition of two unsigned integers, reverting on\n', '\t* overflow.\n', '\t*\n', "\t* Counterpart to Solidity's `+` operator.\n", '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - Addition cannot overflow.\n', '\t*/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "SafeMath: addition overflow");\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the subtraction of two unsigned integers, reverting on\n', '\t* overflow (when the result is negative).\n', '\t*\n', "\t* Counterpart to Solidity's `-` operator.\n", '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - Subtraction cannot overflow.\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn sub(a, b, "SafeMath: subtraction overflow");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '\t* overflow (when the result is negative).\n', '\t*\n', "\t* Counterpart to Solidity's `-` operator.\n", '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - Subtraction cannot overflow.\n', '\t*/\n', '\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b <= a, errorMessage);\n', '\t\tuint256 c = a - b;\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the multiplication of two unsigned integers, reverting on\n', '\t* overflow.\n', '\t*\n', "\t* Counterpart to Solidity's `*` operator.\n", '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - Multiplication cannot overflow.\n', '\t*/\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the integer division of two unsigned integers. Reverts on\n', '\t* division by zero. The result is rounded towards zero.\n', '\t*\n', "\t* Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t* uses an invalid opcode to revert (consuming all remaining gas).\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - The divisor cannot be zero.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn div(a, b, "SafeMath: division by zero");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '\t* division by zero. The result is rounded towards zero.\n', '\t*\n', "\t* Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t* uses an invalid opcode to revert (consuming all remaining gas).\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - The divisor cannot be zero.\n', '\t*/\n', '\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b > 0, errorMessage);\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t* Reverts when dividing by zero.\n', '\t*\n', "\t* Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t* opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t* invalid opcode to revert (consuming all remaining gas).\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - The divisor cannot be zero.\n', '\t*/\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn mod(a, b, "SafeMath: modulo by zero");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t* Reverts with custom message when dividing by zero.\n', '\t*\n', "\t* Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t* opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t* invalid opcode to revert (consuming all remaining gas).\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - The divisor cannot be zero.\n', '\t*/\n', '\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b != 0, errorMessage);\n', '\t\treturn a % b;\n', '\t}\n', '}\n', '\n', 'library Address {\n', '\t/**\n', '\t* @dev Returns true if `account` is a contract.\n', '\t*\n', '\t* [IMPORTANT]\n', '\t* ====\n', '\t* It is unsafe to assume that an address for which this function returns\n', '\t* false is an externally-owned account (EOA) and not a contract.\n', '\t*\n', '\t* Among others, `isContract` will return false for the following\n', '\t* types of addresses:\n', '\t*\n', '\t*  - an externally-owned account\n', '\t*  - a contract in construction\n', '\t*  - an address where a contract will be created\n', '\t*  - an address where a contract lived, but was destroyed\n', '\t* ====\n', '\t*/\n', '\tfunction isContract(address account) internal view returns (bool) {\n', '\t\tbytes32 codehash;\n', '\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\tassembly { codehash := extcodehash(account) }\n', '\t\treturn (codehash != accountHash && codehash != 0x0);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '\t* `recipient`, forwarding all available gas and reverting on errors.\n', '\t*\n', '\t* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '\t* of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '\t* imposed by `transfer`, making them unable to receive funds via\n', '\t* `transfer`. {sendValue} removes this limitation.\n', '\t*\n', '\t* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '\t*\n', '\t* IMPORTANT: because control is transferred to `recipient`, care must be\n', '\t* taken to not create reentrancy vulnerabilities. Consider using\n', '\t* {ReentrancyGuard} or the\n', '\t* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '\t*/\n', '\tfunction sendValue(address payable recipient, uint256 amount) internal {\n', '\t\trequire(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '\t\t(bool success, ) = recipient.call{ value: amount }("");\n', '\t\trequire(success, "Address: unable to send value, recipient may have reverted");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Performs a Solidity function call using a low level `call`. A\n', '\t* plain`call` is an unsafe replacement for a function call: use this\n', '\t* function instead.\n', '\t*\n', '\t* If `target` reverts with a revert reason, it is bubbled up by this\n', '\t* function (like regular Solidity function calls).\n', '\t*\n', '\t* Returns the raw returned data. To convert to the expected return value,\n', '\t* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - `target` must be a contract.\n', '\t* - calling `target` with `data` must not revert.\n', '\t*\n', '\t* _Available since v3.1._\n', '\t*/\n', '\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '\treturn functionCall(target, data, "Address: low-level call failed");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '\t* `errorMessage` as a fallback revert reason when `target` reverts.\n', '\t*\n', '\t* _Available since v3.1._\n', '\t*/\n', '\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '\t* but also transferring `value` wei to `target`.\n', '\t*\n', '\t* Requirements:\n', '\t*\n', '\t* - the calling contract must have an ETH balance of at least `value`.\n', '\t* - the called Solidity function must be `payable`.\n', '\t*\n', '\t* _Available since v3.1._\n', '\t*/\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '\t\treturn functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '\t* with `errorMessage` as a fallback revert reason when `target` reverts.\n', '\t*\n', '\t* _Available since v3.1._\n', '\t*/\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '\t\trequire(address(this).balance >= value, "Address: insufficient balance for call");\n', '\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n', '\t}\n', '\n', '\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '\t\trequire(isContract(target), "Address: call to non-contract");\n', '\n', '\t\t// solhint-disable-next-line avoid-low-level-calls\n', '\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '\t\tif (success) {\n', '\t\t\treturn returndata;\n', '\t\t} else {\n', '\t\t\t// Look for revert reason and bubble it up if present\n', '\t\t\tif (returndata.length > 0) {\n', '\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '\t\t\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\t\t\tassembly {\n', '\t\t\t\t\tlet returndata_size := mload(returndata)\n', '\t\t\t\t\trevert(add(32, returndata), returndata_size)\n', '\t\t\t\t}\n', '\t\t\t} else {\n', '\t\t\t\trevert(errorMessage);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '\tfunction feeTo() external view returns (address);\n', '\tfunction feeToSetter() external view returns (address);\n', '\n', '\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n', '\tfunction allPairs(uint) external view returns (address pair);\n', '\tfunction allPairsLength() external view returns (uint);\n', '\n', '\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '\tfunction setFeeTo(address) external;\n', '\tfunction setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '\tevent Approval(address indexed owner, address indexed spender, uint value);\n', '\tevent Transfer(address indexed from, address indexed to, uint value);\n', '\n', '\tfunction name() external pure returns (string memory);\n', '\tfunction symbol() external pure returns (string memory);\n', '\tfunction decimals() external pure returns (uint8);\n', '\tfunction totalSupply() external view returns (uint);\n', '\tfunction balanceOf(address owner) external view returns (uint);\n', '\tfunction allowance(address owner, address spender) external view returns (uint);\n', '\n', '\tfunction approve(address spender, uint value) external returns (bool);\n', '\tfunction transfer(address to, uint value) external returns (bool);\n', '\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\tfunction nonces(address owner) external view returns (uint);\n', '\n', '\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '\tevent Mint(address indexed sender, uint amount0, uint amount1);\n', '\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '\tevent Swap(\n', '\t\taddress indexed sender,\n', '\t\tuint amount0In,\n', '\t\tuint amount1In,\n', '\t\tuint amount0Out,\n', '\t\tuint amount1Out,\n', '\t\taddress indexed to\n', '\t);\n', '\tevent Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n', '\tfunction factory() external view returns (address);\n', '\tfunction token0() external view returns (address);\n', '\tfunction token1() external view returns (address);\n', '\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\tfunction price0CumulativeLast() external view returns (uint);\n', '\tfunction price1CumulativeLast() external view returns (uint);\n', '\tfunction kLast() external view returns (uint);\n', '\n', '\tfunction mint(address to) external returns (uint liquidity);\n', '\tfunction burn(address to) external returns (uint amount0, uint amount1);\n', '\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '\tfunction skim(address to) external;\n', '\tfunction sync() external;\n', '\n', '\tfunction initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '\tfunction factory() external pure returns (address);\n', '\tfunction WETH() external pure returns (address);\n', '\n', '\tfunction addLiquidity(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint amountADesired,\n', '\t\tuint amountBDesired,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountA, uint amountB, uint liquidity);\n', '\tfunction addLiquidityETH(\n', '\t\taddress token,\n', '\t\tuint amountTokenDesired,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '\tfunction removeLiquidity(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint liquidity,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountA, uint amountB);\n', '\tfunction removeLiquidityETH(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\tfunction removeLiquidityWithPermit(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint liquidity,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountA, uint amountB);\n', '\tfunction removeLiquidityETHWithPermit(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\tfunction swapExactTokensForTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\tfunction swapTokensForExactTokens(\n', '\t\tuint amountOut,\n', '\t\tuint amountInMax,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '\t\texternal\n', '\t\tpayable\n', '\t\treturns (uint[] memory amounts);\n', '\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '\t\texternal\n', '\t\treturns (uint[] memory amounts);\n', '\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '\t\texternal\n', '\t\treturns (uint[] memory amounts);\n', '\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '\t\texternal\n', '\t\tpayable\n', '\t\treturns (uint[] memory amounts);\n', '\n', '\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountETH);\n', '\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountETH);\n', '\n', '\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external;\n', '\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external payable;\n', '\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external;\n', '}\n', '\n', 'contract Leafty is Context, IERC20, Ownable {\n', '\tusing SafeMath for uint256;\n', '\tusing Address for address;\n', '\n', '\tmapping (address => uint256) private _rOwned;\n', '\tmapping (address => uint256) private _tOwned;\n', '\tmapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '\tmapping (address => bool) private _isExcludedFromFee;\n', '\n', '\tmapping (address => bool) private _isExcluded;\n', '\taddress[] private _excluded;\n', '\n', '\tuint256 private constant MAX = ~uint256(0);\n', '\tuint256 private _tTotal = 100000000000 * 10**9;\n', '\tuint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '\tuint256 private _tFeeTotal;\n', '\n', "\tstring private _name = 'Leafty';\n", "\tstring private _symbol = 'LEAFTY';\n", '\tuint8 private _decimals = 9;\n', '\n', "\t// Tax and charity fees will start at 0 so we don't have a big impact when deploying to Uniswap\n", '\t// Charity wallet address is null but the method to set the address is exposed\n', '\tuint256 private _taxFee = 1;\n', '\tuint256 private _charityFee = 7;\n', '\tuint256 private _previousTaxFee = _taxFee;\n', '\tuint256 private _previousCharityFee = _charityFee;\n', '\n', '\taddress payable public _charityWalletAddress;\n', '\n', '\tIUniswapV2Router02 public immutable uniswapV2Router;\n', '\taddress public immutable uniswapV2Pair;\n', '\n', '\tbool inSwap = false;\n', '\tbool public swapEnabled = true;\n', '\t\t\t\t\t\t\t\t   \n', '\tuint256 private _maxTxAmount = 10000000000000 * 10**9;\n', '\t// We will set a minimum amount of tokens to be swaped => 500k\n', '\tuint256 private _numOfTokensToExchangeForCharity = 5 * 10**3 * 10**9;\n', '\n', '\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n', '\tevent SwapEnabledUpdated(bool enabled);\n', '\n', '\tmodifier lockTheSwap {\n', '\t\tinSwap = true;\n', '\t\t_;\n', '\t\tinSwap = false;\n', '\t}\n', '\n', '\tconstructor (address payable charityWalletAddress) {\n', '\t\t_charityWalletAddress = charityWalletAddress;\n', '\t\t_rOwned[_msgSender()] = _rTotal;\n', '\n', '\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // UniswapV2 for Ethereum network\n', '\t\t// Create a uniswap pair for this new token\n', '\t\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n', '\t\t\t.createPair(address(this), _uniswapV2Router.WETH());\n', '\n', '\t\t// set the rest of the contract variables\n', '\t\tuniswapV2Router = _uniswapV2Router;\n', '\n', '\t\t// Exclude owner and this contract from fee\n', '\t\t_isExcludedFromFee[owner()] = true;\n', '\t\t_isExcludedFromFee[address(this)] = true;\n', '\n', '\t\temit Transfer(address(0), _msgSender(), _tTotal);\n', '\t}\n', '\n', '\tfunction name() public view returns (string memory) {\n', '\t\treturn _name;\n', '\t}\n', '\n', '\tfunction symbol() public view returns (string memory) {\n', '\t\treturn _symbol;\n', '\t}\n', '\n', '\tfunction decimals() public view returns (uint8) {\n', '\t\treturn _decimals;\n', '\t}\n', '\n', '\tfunction totalSupply() public view override returns (uint256) {\n', '\t\treturn _tTotal;\n', '\t}\n', '\n', '\tfunction balanceOf(address account) public view override returns (uint256) {\n', '\t\tif (_isExcluded[account]) return _tOwned[account];\n', '\t\treturn tokenFromReflection(_rOwned[account]);\n', '\t}\n', '\n', '\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(_msgSender(), recipient, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowance(address owner, address spender) public view override returns (uint256) {\n', '\t\treturn _allowances[owner][spender];\n', '\t}\n', '\n', '\tfunction approve(address spender, uint256 amount) public override returns (bool) {\n', '\t\t_approve(_msgSender(), spender, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(sender, recipient, amount);\n', '\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction isExcluded(address account) public view returns (bool) {\n', '\t\treturn _isExcluded[account];\n', '\t}\n', '\n', '\tfunction setExcludeFromFee(address account, bool excluded) external onlyOwner() {\n', '\t\t_isExcludedFromFee[account] = excluded;\n', '\t}\n', '\n', '\tfunction totalFees() public view returns (uint256) {\n', '\t\treturn _tFeeTotal;\n', '\t}\n', '\t\n', '\tfunction charityMin() public view returns (uint256) {\n', '\t\treturn _numOfTokensToExchangeForCharity;\n', '\t}\n', '\n', '\tfunction deliver(uint256 tAmount) public {\n', '\t\taddress sender = _msgSender();\n', '\t\trequire(!_isExcluded[sender], "Excluded addresses cannot call this function");\n', '\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rTotal = _rTotal.sub(rAmount);\n', '\t\t_tFeeTotal = _tFeeTotal.add(tAmount);\n', '\t}\n', '\n', '\tfunction reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n', '\t\trequire(tAmount <= _tTotal, "Amount must be less than supply");\n', '\t\tif (!deductTransferFee) {\n', '\t\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t\treturn rAmount;\n', '\t\t} else {\n', '\t\t\t(,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n', '\t\t\treturn rTransferAmount;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n', '\t\trequire(rAmount <= _rTotal, "Amount must be less than total reflections");\n', '\t\tuint256 currentRate =  _getRate();\n', '\t\treturn rAmount.div(currentRate);\n', '\t}\n', '\n', '\tfunction excludeAccount(address account) external onlyOwner() {\n', "\t\trequire(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n", '\t\trequire(!_isExcluded[account], "Account is already excluded");\n', '\t\tif(_rOwned[account] > 0) {\n', '\t\t\t_tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '\t\t}\n', '\t\t_isExcluded[account] = true;\n', '\t\t_excluded.push(account);\n', '\t}\n', '\n', '\tfunction includeAccount(address account) external onlyOwner() {\n', '\t\trequire(_isExcluded[account], "Account is already excluded");\n', '\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n', '\t\t\tif (_excluded[i] == account) {\n', '\t\t\t\t_excluded[i] = _excluded[_excluded.length - 1];\n', '\t\t\t\t_tOwned[account] = 0;\n', '\t\t\t\t_isExcluded[account] = false;\n', '\t\t\t\t_excluded.pop();\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction removeAllFee() private {\n', '\t\tif(_taxFee == 0 && _charityFee == 0) return;\n', '\n', '\t\t_previousTaxFee = _taxFee;\n', '\t\t_previousCharityFee = _charityFee;\n', '\n', '\t\t_taxFee = 0;\n', '\t\t_charityFee = 0;\n', '\t}\n', '\n', '\tfunction restoreAllFee() private {\n', '\t\t_taxFee = _previousTaxFee;\n', '\t\t_charityFee = _previousCharityFee;\n', '\t}\n', '\n', '\tfunction isExcludedFromFee(address account) public view returns(bool) {\n', '\t\treturn _isExcludedFromFee[account];\n', '\t}\n', '\n', '\tfunction _approve(address owner, address spender, uint256 amount) private {\n', '\t\trequire(owner != address(0), "ERC20: approve from the zero address");\n', '\t\trequire(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '\t\t_allowances[owner][spender] = amount;\n', '\t\temit Approval(owner, spender, amount);\n', '\t}\n', '\n', '\tfunction _transfer(address sender, address recipient, uint256 amount) private {\n', '\t\trequire(sender != address(0), "ERC20: transfer from the zero address");\n', '\t\trequire(recipient != address(0), "ERC20: transfer to the zero address");\n', '\t\trequire(amount > 0, "Transfer amount must be greater than zero");\n', '\n', '\t\tif(sender != owner() && recipient != owner())\n', '\t\t\trequire(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n', '\n', '\t\t// is the token balance of this contract address over the min number of\n', '\t\t// tokens that we need to initiate a swap?\n', "\t\t// also, don't get caught in a circular charity event.\n", "\t\t// also, don't swap if sender is uniswap pair.\n", '\t\tuint256 contractTokenBalance = balanceOf(address(this));\n', '\n', '\t\tif(contractTokenBalance >= _maxTxAmount)\n', '\t\t{\n', '\t\t\tcontractTokenBalance = _maxTxAmount;\n', '\t\t}\n', '\n', '\t\tbool overMinTokenBalance = contractTokenBalance >= _numOfTokensToExchangeForCharity;\n', '\t\tif (!inSwap && swapEnabled && overMinTokenBalance && sender != uniswapV2Pair) {\n', '\t\t\t// We need to swap the current tokens to ETH and send to the charity wallet\n', '\t\t\tswapTokensForEth(contractTokenBalance);\n', '\n', '\t\t\tuint256 contractETHBalance = address(this).balance;\n', '\t\t\tif(contractETHBalance > 0) {\n', '\t\t\t\tsendETHToCharity(address(this).balance);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\t//indicates if fee should be deducted from transfer\n', '\t\tbool takeFee = true;\n', '\n', '\t\t//if any account belongs to _isExcludedFromFee account then remove the fee\n', '\t\tif(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){\n', '\t\t\ttakeFee = false;\n', '\t\t}\n', '\n', '\t\t//transfer amount, it will take tax and charity fee\n', '\t\t_tokenTransfer(sender,recipient,amount,takeFee);\n', '\t}\n', '\n', '\tfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap{\n', '\t\t// generate the uniswap pair path of token -> weth\n', '\t\taddress[] memory path = new address[](2);\n', '\t\tpath[0] = address(this);\n', '\t\tpath[1] = uniswapV2Router.WETH();\n', '\n', '\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '\t\t// make the swap\n', '\t\tuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '\t\t\ttokenAmount,\n', '\t\t\t0, // accept any amount of ETH\n', '\t\t\tpath,\n', '\t\t\taddress(this),\n', '\t\t\tblock.timestamp\n', '\t\t);\n', '\t}\n', '\n', '\tfunction sendETHToCharity(uint256 amount) private {\n', '\t\t_charityWalletAddress.transfer(amount);\n', '\t}\n', '\n', '\t// We are exposing these functions to be able to manual swap and send\n', '\t// in case the token is highly valued and 500k becomes too much\n', '\tfunction manualSwap() external onlyOwner() {\n', '\t\tuint256 contractBalance = balanceOf(address(this));\n', '\t\tswapTokensForEth(contractBalance);\n', '\t}\n', '\n', '\tfunction manualSend() external onlyOwner() {\n', '\t\tuint256 contractETHBalance = address(this).balance;\n', '\t\tsendETHToCharity(contractETHBalance);\n', '\t}\n', '\n', '\tfunction setSwapEnabled(bool enabled) external onlyOwner() {\n', '\t\tswapEnabled = enabled;\n', '\t}\n', '\n', '\tfunction _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n', '\t\tif(!takeFee)\n', '\t\t\tremoveAllFee();\n', '\n', '\t\tif (_isExcluded[sender] && !_isExcluded[recipient]) {\n', '\t\t\t_transferFromExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n', '\t\t\t_transferToExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t} else if (_isExcluded[sender] && _isExcluded[recipient]) {\n', '\t\t\t_transferBothExcluded(sender, recipient, amount);\n', '\t\t} else {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t}\n', '\n', '\t\tif(!takeFee)\n', '\t\t\trestoreAllFee();\n', '\t}\n', '\n', '\tfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeCharity(tCharity);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '\tfunction _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeCharity(tCharity);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '\tfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeCharity(tCharity);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '\tfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeCharity(tCharity);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '\tfunction _takeCharity(uint256 tCharity) private {\n', '\t\tuint256 currentRate =  _getRate();\n', '\t\tuint256 rCharity = tCharity.mul(currentRate);\n', '\t\t_rOwned[address(this)] = _rOwned[address(this)].add(rCharity);\n', '\t\tif(_isExcluded[address(this)])\n', '\t\t\t_tOwned[address(this)] = _tOwned[address(this)].add(tCharity);\n', '\t}\n', '\n', '\tfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n', '\t\t_rTotal = _rTotal.sub(rFee);\n', '\t\t_tFeeTotal = _tFeeTotal.add(tFee);\n', '\t}\n', '\n', '\t\t//to recieve ETH from uniswapV2Router when swaping\n', '\treceive() external payable {}\n', '\n', '\tfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '\t\t(uint256 tTransferAmount, uint256 tFee, uint256 tCharity) = _getTValues(tAmount, _taxFee, _charityFee);\n', '\t\tuint256 currentRate =  _getRate();\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n', '\t\treturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tCharity);\n', '\t}\n', '\n', '\tfunction _getTValues(uint256 tAmount, uint256 taxFee, uint256 charityFee) private pure returns (uint256, uint256, uint256) {\n', '\t\tuint256 tFee = tAmount.mul(taxFee).div(100);\n', '\t\tuint256 tCharity = tAmount.mul(charityFee).div(100);\n', '\t\tuint256 tTransferAmount = tAmount.sub(tFee).sub(tCharity);\n', '\t\treturn (tTransferAmount, tFee, tCharity);\n', '\t}\n', '\n', '\tfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n', '\t\tuint256 rAmount = tAmount.mul(currentRate);\n', '\t\tuint256 rFee = tFee.mul(currentRate);\n', '\t\tuint256 rTransferAmount = rAmount.sub(rFee);\n', '\t\treturn (rAmount, rTransferAmount, rFee);\n', '\t}\n', '\n', '\tfunction _getRate() private view returns(uint256) {\n', '\t\t(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '\t\treturn rSupply.div(tSupply);\n', '\t}\n', '\n', '\tfunction _getCurrentSupply() private view returns(uint256, uint256) {\n', '\t\tuint256 rSupply = _rTotal;\n', '\t\tuint256 tSupply = _tTotal;\n', '\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n', '\t\t\tif (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n', '\t\t\trSupply = rSupply.sub(_rOwned[_excluded[i]]);\n', '\t\t\ttSupply = tSupply.sub(_tOwned[_excluded[i]]);\n', '\t\t}\n', '\t\tif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '\t\treturn (rSupply, tSupply);\n', '\t}\n', '\n', '\tfunction _getTaxFee() private view returns(uint256) {\n', '\t\treturn _taxFee;\n', '\t}\n', '\n', '\tfunction _getMaxTxAmount() private view returns(uint256) {\n', '\t\treturn _maxTxAmount;\n', '\t}\n', '\n', '\tfunction _getETHBalance() public view returns(uint256 balance) {\n', '\t\treturn address(this).balance;\n', '\t}\n', '\n', '\tfunction _setTaxFee(uint256 taxFee) external onlyOwner() {\n', "\t\trequire(taxFee >= 1 && taxFee <= 10, 'taxFee should be in 1 - 10');\n", '\t\t_taxFee = taxFee;\n', '\t}\n', '\n', '\tfunction _setCharityFee(uint256 charityFee) external onlyOwner() {\n', "\t\trequire(charityFee >= 1 && charityFee <= 99, 'charityFee should be in 1 - 99');\n", '\t\t_charityFee = charityFee;\n', '\t}\n', '\t\n', '\tfunction _setCharityMin(uint256 scharityMin) external onlyOwner() {\n', '\t\t_numOfTokensToExchangeForCharity = scharityMin;\n', '\t}\n', '\n', '\tfunction _setCharityWallet(address payable charityWalletAddress) external onlyOwner() {\n', '\t\t_charityWalletAddress = charityWalletAddress;\n', '\t}\n', '\n', '\tfunction _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\n', "\t\trequire(maxTxAmount >= 10000000000000e9 , 'maxTxAmount should be greater than 10000000000000e9');\n", '\t\t_maxTxAmount = maxTxAmount;\n', '\t}\n', '}']