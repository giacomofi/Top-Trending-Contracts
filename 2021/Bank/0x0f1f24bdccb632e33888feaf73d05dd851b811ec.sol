['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-02\n', '*/\n', '\n', '// Price Oracle for Reeth Token\n', '// This contract uses Uniswap v2 TWAP to obtain the token price\n', '// It initially uses 10 minute averages but can be updated on the fly by governance\n', '\n', 'pragma solidity =0.6.6;\n', '\n', 'interface UniswapV2Pair {\n', '    function price0CumulativeLast() external view returns (uint256);\n', '    function price1CumulativeLast() external view returns (uint256);\n', '    function getReserves() external view returns (uint112, uint112, uint32);\n', '}\n', '\n', 'contract ReethPriceOracle {\n', '\n', '    address public owner;\n', '    bool private _firstCapture = true;\n', '    uint256 private _reethDecimals = 18; // Same as YAM\n', '    uint256 private _reethETHPrice = 0;\n', '    uint256 private _reethPriceWindow = 0; // The time period this price was calculated over, determines its weight\n', '    uint256 private _tokenIndex = 0;\n', '    uint256 public lastREETHPriceUpdate; // The last time the price was updated\n', '    uint256 public updateFrequency = 10 minutes; // Oracle can be updated at least every 10 minutes\n', '\n', '    uint256 constant DIVISION_FACTOR = 100000;\n', '    \n', '    // TWAP details\n', '    address public mainLiquidity;\n', '    uint256 private lastTWAPCumulativePrice;\n', '    uint32 private lastTWAPBlockTime;\n', '    uint256 private lastTWAPPrice;\n', '    \n', '    // Events\n', '    event NoLiquidity();\n', '    event FirstPriceCapture(); // First time price update is called, must wait til another time to update\n', '    event FailedPriceCapture(); // Not quick enough price movement for a twap to be calculated\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyGovernance() {\n', '        require(owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    \n', '    function changeLiquidityToken(address _lp, uint256 _pos) internal {\n', '        mainLiquidity = _lp;\n', '        _tokenIndex = _pos;\n', '        _reethETHPrice = 0;\n', '        _reethPriceWindow = 0;\n', '        lastTWAPBlockTime = 0;\n', '        lastTWAPCumulativePrice = 0;\n', '        lastREETHPriceUpdate = 0;\n', '        _firstCapture = true;\n', '    }\n', '    \n', '    function getLatestREETHPrice() external view returns (uint256) {\n', '        // Returns the stored price with 18 decimals of precision\n', '        return _reethETHPrice;\n', '    }\n', '    \n', '    // This function can be called manually but will most likely be called by the monetary policy upon token transfers most often\n', '    function updateREETHPrice() external {\n', '        if(mainLiquidity == address(0)) { return; }\n', '        if(now < lastREETHPriceUpdate + updateFrequency){ return; } // Do nothing if update is called too soon\n', '        uint256 period = now - lastREETHPriceUpdate; // Get the time between the last update and now\n', '        lastREETHPriceUpdate = now;\n', '        // We will use a combination of the Twap and weighted averages to determine the current price\n', '        UniswapV2Pair pair = UniswapV2Pair(mainLiquidity);\n', '        (, uint112 reserve1, uint32 _blockTime) = pair.getReserves();\n', '        if(reserve1 == 0){\n', "            // Liquidity is gone/non-existant, can't update the price\n", '            // Reset the oracle\n', '            _reethETHPrice = 0;\n', '            _reethPriceWindow = 0;\n', '            lastTWAPBlockTime = 0;\n', '            lastTWAPCumulativePrice = 0;\n', '            _firstCapture = true;\n', '            emit NoLiquidity();\n', '            return;\n', '        }\n', '        if(lastTWAPBlockTime != _blockTime){\n', '            // Uniswap twap price has updated, update our twap price\n', '            if(_firstCapture == true){\n', '                // Never had a price before, save the price accumulators\n', '                if(_tokenIndex == 0){\n', '                    lastTWAPCumulativePrice = pair.price0CumulativeLast();\n', '                }else{\n', '                    lastTWAPCumulativePrice = pair.price1CumulativeLast();\n', '                }\n', '                lastTWAPBlockTime = _blockTime;\n', '                _firstCapture = false;\n', '                emit FirstPriceCapture();\n', '                return;\n', '            }else{\n', '                // We already have a price cumulative, capture a new price\n', '                uint256 cumuPrice = 0;\n', '                if(_tokenIndex == 0){\n', '                    cumuPrice = pair.price0CumulativeLast();\n', '                }else{\n', '                    cumuPrice = pair.price1CumulativeLast();\n', '                }\n', '                // This is price in relationship to base pair\n', '                lastTWAPPrice = ((cumuPrice - lastTWAPCumulativePrice) / (_blockTime - lastTWAPBlockTime) * (10**_reethDecimals)) >> 112;\n', '                lastTWAPCumulativePrice = cumuPrice;\n', '                lastTWAPBlockTime = _blockTime;\n', '            }\n', '        }\n', '        if(lastTWAPPrice == 0){\n', '            // Still no price calculation possible since no action on trading pair since last call\n', '            emit FailedPriceCapture();\n', '            return;\n', '        }\n', '        if(_reethPriceWindow == 0){\n', '            // First time price is calculated, set it to the twap price\n', '            _reethPriceWindow = updateFrequency;\n', '            _reethETHPrice = lastTWAPPrice;\n', '        }else{\n', '            // There is already a price window and price, use weighted averages to determine the weight\n', '            uint256 price = lastTWAPPrice;\n', '            _reethETHPrice = (_reethETHPrice * (_reethPriceWindow * DIVISION_FACTOR / (_reethPriceWindow + period)) / DIVISION_FACTOR);\n', '            _reethETHPrice += (price * (period * DIVISION_FACTOR / (_reethPriceWindow + period)) / DIVISION_FACTOR);\n', '            _reethPriceWindow = period; // Set the window to the new period\n', '        }\n', '    }\n', '    \n', '    // Governance\n', '    function governanceChangeFrequency(uint256 _freq) external onlyGovernance {\n', '        updateFrequency = _freq;\n', '    }\n', '    \n', '    // Timelock variables\n', '    \n', '    uint256 private _timelockStart; // The start of the timelock to change governance variables\n', '    uint256 private _timelockType; // The function that needs to be changed\n', '    uint256 constant TIMELOCK_DURATION = 86400; // Timelock is 24 hours\n', '    \n', '    // Reusable timelock variables\n', '    address private _timelock_address;\n', '    uint256 private _timelock_data;\n', '    \n', '    modifier timelockConditionsMet(uint256 _type) {\n', '        require(_timelockType == _type, "Timelock not acquired for this function");\n', '        _timelockType = 0; // Reset the type once the timelock is used\n', '        require(now >= _timelockStart + TIMELOCK_DURATION, "Timelock time not met");\n', '        _;\n', '    }\n', '    \n', '    // Change the owner of the token contract\n', '    // --------------------\n', '    function startGovernanceChange(address _address) external onlyGovernance {\n', '        _timelockStart = now;\n', '        _timelockType = 1;\n', '        _timelock_address = _address;       \n', '    }\n', '    \n', '    function finishGovernanceChange() external onlyGovernance timelockConditionsMet(1) {\n', '        owner = _timelock_address;\n', '    }\n', '    // --------------------\n', '    \n', '    // Update main liquidity token pair\n', '    // --------------------\n', '    function startUpdateLiquidityToken(address _address, uint256 _index) external onlyGovernance {\n', '        _timelockStart = now;\n', '        _timelockType = 2;\n', '        _timelock_address = _address;     \n', '        _timelock_data = _index;\n', '        if(mainLiquidity == address(0)){\n', '            changeLiquidityToken(_address, _index);\n', '            _timelockType = 0;\n', '        }\n', '    }\n', '    \n', '    function finishUpdateLiquidityToken() external onlyGovernance timelockConditionsMet(2) {\n', '        changeLiquidityToken(_timelock_address, _timelock_data);\n', '    }\n', '    // --------------------   \n', '\n', '}']