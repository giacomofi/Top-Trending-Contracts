['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface BPool {\n', '  function getCurrentTokens() external view returns (address[] memory tokens);\n', '\n', '  function getNormalizedWeight(address token) external view returns (uint256);\n', '\n', '  function getBalance(address token) external view returns (uint256);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '}\n', '\n', 'interface ISmartBPool {\n', '  function bPool() external view returns (BPool);\n', '\n', '  function totalSupply() external view returns (uint256);\n', '}\n', '\n', '/************\n', '@title IPriceOracle interface\n', '@notice Interface for the Aave price oracle.*/\n', 'interface IPriceOracle {\n', '  /***********\n', '    @dev returns the asset price in ETH\n', '     */\n', '  function getAssetPrice(address _asset) external view returns (uint256);\n', '}\n', '\n', 'contract BConst {\n', '  uint256 public constant BONE = 10**18;\n', '\n', '  uint256 public constant MIN_BOUND_TOKENS = 2;\n', '  uint256 public constant MAX_BOUND_TOKENS = 8;\n', '\n', '  uint256 public constant MIN_FEE = BONE / 10**6;\n', '  uint256 public constant MAX_FEE = BONE / 10;\n', '  uint256 public constant EXIT_FEE = 0;\n', '\n', '  uint256 public constant MIN_WEIGHT = BONE;\n', '  uint256 public constant MAX_WEIGHT = BONE * 50;\n', '  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n', '  uint256 public constant MIN_BALANCE = BONE / 10**12;\n', '\n', '  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n', '\n', '  uint256 public constant MIN_BPOW_BASE = 1 wei;\n', '  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n', '  uint256 public constant BPOW_PRECISION = BONE / 10**10;\n', '\n', '  uint256 public constant MAX_IN_RATIO = BONE / 2;\n', '  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n', '}\n', '\n', 'contract BNum is BConst {\n', '  function btoi(uint256 a) internal pure returns (uint256) {\n', '    return a / BONE;\n', '  }\n', '\n', '  function bfloor(uint256 a) internal pure returns (uint256) {\n', '    return btoi(a) * BONE;\n', '  }\n', '\n', '  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', "    require(c >= a, 'ERR_ADD_OVERFLOW');\n", '    return c;\n', '  }\n', '\n', '  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    (uint256 c, bool flag) = bsubSign(a, b);\n', "    require(!flag, 'ERR_SUB_UNDERFLOW');\n", '    return c;\n', '  }\n', '\n', '  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n', '    if (a >= b) {\n', '      return (a - b, false);\n', '    } else {\n', '      return (b - a, true);\n', '    }\n', '  }\n', '\n', '  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c0 = a * b;\n', "    require(a == 0 || c0 / a == b, 'ERR_MUL_OVERFLOW');\n", '    uint256 c1 = c0 + (BONE / 2);\n', "    require(c1 >= c0, 'ERR_MUL_OVERFLOW');\n", '    uint256 c2 = c1 / BONE;\n', '    return c2;\n', '  }\n', '\n', '  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    require(b != 0, 'ERR_DIV_ZERO');\n", '    uint256 c0 = a * BONE;\n', "    require(a == 0 || c0 / a == BONE, 'ERR_DIV_INTERNAL'); // bmul overflow\n", '    uint256 c1 = c0 + (b / 2);\n', "    require(c1 >= c0, 'ERR_DIV_INTERNAL'); //  badd require\n", '    uint256 c2 = c1 / b;\n', '    return c2;\n', '  }\n', '\n', '  // DSMath.wpow\n', '  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n', '    uint256 z = n % 2 != 0 ? a : BONE;\n', '\n', '    for (n /= 2; n != 0; n /= 2) {\n', '      a = bmul(a, a);\n', '\n', '      if (n % 2 != 0) {\n', '        z = bmul(z, a);\n', '      }\n', '    }\n', '    return z;\n', '  }\n', '\n', '  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '  // of approximation of b^0.w\n', '  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n', "    require(base >= MIN_BPOW_BASE, 'ERR_BPOW_BASE_TOO_LOW');\n", "    require(base <= MAX_BPOW_BASE, 'ERR_BPOW_BASE_TOO_HIGH');\n", '\n', '    uint256 whole = bfloor(exp);\n', '    uint256 remain = bsub(exp, whole);\n', '\n', '    uint256 wholePow = bpowi(base, btoi(whole));\n', '\n', '    if (remain == 0) {\n', '      return wholePow;\n', '    }\n', '\n', '    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '    return bmul(wholePow, partialResult);\n', '  }\n', '\n', '  function bpowApprox(\n', '    uint256 base,\n', '    uint256 exp,\n', '    uint256 precision\n', '  ) internal pure returns (uint256) {\n', '    // term 0:\n', '    uint256 a = exp;\n', '    (uint256 x, bool xneg) = bsubSign(base, BONE);\n', '    uint256 term = BONE;\n', '    uint256 sum = term;\n', '    bool negative = false;\n', '\n', '    // term(k) = numer / denom\n', '    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n', '    // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '    // continue until term is less than precision\n', '    for (uint256 i = 1; term >= precision; i++) {\n', '      uint256 bigK = i * BONE;\n', '      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '      term = bmul(term, bmul(c, x));\n', '      term = bdiv(term, bigK);\n', '      if (term == 0) break;\n', '\n', '      if (xneg) negative = !negative;\n', '      if (cneg) negative = !negative;\n', '      if (negative) {\n', '        sum = bsub(sum, term);\n', '      } else {\n', '        sum = badd(sum, term);\n', '      }\n', '    }\n', '\n', '    return sum;\n', '  }\n', '}\n', '\n', '/** @title NaiveBalancerSmartPoolPriceProvider\n', ' * @notice Price provider for a balancer pool token\n', ' * - NAIVE CALCULATION, USE ONLY FOR PRICE FETCHING\n', ' * This implementation assumes the underlying pool on the smart pool is a standard Balancer Shared Pool\n', " * - DON'T USE THIS ORACLE IF FUNDAMENTAL CHANGES ON THE UNDERLYING POOL ARE APPLIED\n", ' */\n', '\n', 'contract NaiveBalancerSmartPoolPriceProvider is BNum {\n', '  ISmartBPool public pool;\n', '  address[] public tokens;\n', '  uint256[] public weights;\n', '  bool[] public isPeggedToEth;\n', '  uint8[] public decimals;\n', '  IPriceOracle public priceOracle;\n', '\n', '  /**\n', '   * BalancerSmartPoolPriceProvider constructor.\n', '   * @param _pool Balancer pool address.\n', '   * @param _isPeggedToEth For each token, true if it is pegged to ETH (token order determined by pool.getPool().getFinalTokens()).\n', '   * @param _decimals Number of decimals for each token (token order determined by pool.getPool().getFinalTokens()).\n', '   * @param _priceOracle Aave price oracle.\n', '   */\n', '  constructor(\n', '    ISmartBPool _pool,\n', '    bool[] memory _isPeggedToEth,\n', '    uint8[] memory _decimals,\n', '    IPriceOracle _priceOracle\n', '  ) public {\n', '    pool = _pool;\n', '\n', '    BPool underlyingBPool = _pool.bPool();\n', '    //Get token list\n', '    tokens = underlyingBPool.getCurrentTokens();\n', '    uint256 length = tokens.length;\n', '    //Validate contructor params\n', "    require(length >= 2 && length <= 3, 'ERR_INVALID_POOL_TOKENS_NUMBER');\n", "    require(_isPeggedToEth.length == length, 'ERR_INVALID_PEGGED_LENGTH');\n", "    require(_decimals.length == length, 'ERR_INVALID_DECIMALS_LENGTH');\n", '    for (uint8 i = 0; i < length; i++) {\n', "      require(_decimals[i] <= 18, 'ERR_INVALID_DECIMALS');\n", '    }\n', "    require(address(_priceOracle) != address(0), 'ERR_INVALID_PRICE_PROVIDER');\n", '    //Get token normalized weights\n', '    for (uint8 i = 0; i < length; i++) {\n', '      weights.push(underlyingBPool.getNormalizedWeight(tokens[i]));\n', '    }\n', '    isPeggedToEth = _isPeggedToEth;\n', '    decimals = _decimals;\n', '    priceOracle = _priceOracle;\n', '  }\n', '\n', '  /**\n', '   * Returns the token balance in ethers by multiplying its balance with its price in ethers.\n', '   * @param index Token index.\n', '   */\n', '  function getEthBalanceByToken(uint256 index) internal view returns (uint256) {\n', '    uint256 pi = isPeggedToEth[index] ? BONE : uint256(priceOracle.getAssetPrice(tokens[index]));\n', "    require(pi > 0, 'ERR_NO_ORACLE_PRICE');\n", '    uint256 missingDecimals = 18 - decimals[index];\n', '    uint256 bi = bmul(pool.bPool().getBalance(tokens[index]), BONE * 10**(missingDecimals));\n', '    return bmul(bi, pi);\n', '  }\n', '\n', '  /**\n', '   * Calculates the price of the pool token using the formula of weighted arithmetic mean.\n', '   * @param ethTotals Balance of each token in ethers.\n', '   */\n', '  function getArithmeticMean(uint256[] memory ethTotals) internal view returns (uint256) {\n', '    uint256 totalEth = 0;\n', '    uint256 length = tokens.length;\n', '    for (uint8 i = 0; i < length; i++) {\n', '      totalEth = badd(totalEth, ethTotals[i]);\n', '    }\n', '    return bdiv(totalEth, pool.totalSupply());\n', '  }\n', '\n', '  /**\n', "   * Returns the pool's token price.\n", "   * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\n", '   */\n', '  function latestAnswer() external view returns (uint256) {\n', '    //Get token balances in ethers\n', '    uint256[] memory ethTotals = new uint256[](tokens.length);\n', '    uint256 length = tokens.length;\n', '    for (uint256 i = 0; i < length; i++) {\n', '      ethTotals[i] = getEthBalanceByToken(i);\n', '    }\n', '\n', '    return getArithmeticMean(ethTotals);\n', '  }\n', '\n', '  /**\n', '   * Returns Balancer pool address.\n', '   */\n', '  function getPool() external view returns (ISmartBPool) {\n', '    return pool;\n', '  }\n', '\n', '  /**\n', '   * Returns all tokens.\n', '   */\n', '  function getTokens() external view returns (address[] memory) {\n', '    return tokens;\n', '  }\n', '\n', '  /**\n', "   * Returns all tokens's weights.\n", '   */\n', '  function getWeights() external view returns (uint256[] memory) {\n', '    return weights;\n', '  }\n', '}']