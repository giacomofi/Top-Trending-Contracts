['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-03\n', '*/\n', '\n', '// File: contracts\\WUSD\\util\\IEthItemOrchestrator.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IEthItemOrchestrator {\n', '    function createNative(bytes calldata modelInitPayload, string calldata ens)\n', '        external\n', '        returns (address newNativeAddress, bytes memory modelInitCallResponse);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IERC1155.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC1155 {\n', '\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IEthItemInteroperableInterface.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface IEthItemInteroperableInterface is IERC20 {\n', '\n', '    function mainInterface() external view returns (address);\n', '\n', '    function objectId() external view returns (uint256);\n', '\n', '    function mint(address owner, uint256 amount) external;\n', '\n', '    function burn(address owner, uint256 amount) external;\n', '\n', '    function permitNonce(address sender) external view returns(uint256);\n', '\n', '    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IEthItem.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '\n', 'interface IEthItem is IERC1155 {\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function totalSupply(uint256 objectId) external view returns (uint256);\n', '\n', '    function name(uint256 objectId) external view returns (string memory);\n', '\n', '    function symbol(uint256 objectId) external view returns (string memory);\n', '\n', '    function decimals(uint256 objectId) external view returns (uint256);\n', '\n', '    function uri(uint256 objectId) external view returns (string memory);\n', '\n', '    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\n', '\n', '    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\n', '\n', '    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\n', '\n', '    function interoperableInterfaceModel() external view returns (address, uint256);\n', '\n', '    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\n', '\n', '    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\n', '\n', '    function mint(uint256 amount, string calldata partialUri)\n', '        external\n', '        returns (uint256, address);\n', '\n', '    function burn(\n', '        uint256 objectId,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function burnBatch(\n', '        uint256[] calldata objectIds,\n', '        uint256[] calldata amounts\n', '    ) external;\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\INativeV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface INativeV1 is IEthItem {\n', '\n', '    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\n', '\n', '    function extension() external view returns (address extensionAddress);\n', '\n', '    function canMint(address operator) external view returns (bool result);\n', '\n', '    function isEditable(uint256 objectId) external view returns (bool result);\n', '\n', '    function releaseExtension() external;\n', '\n', '    function uri() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint256);\n', '\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\n', '\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\n', '\n', '    function mint(uint256 objectId, uint256 amount) external;\n', '\n', '    function makeReadOnly(uint256 objectId) external;\n', '\n', '    function setUri(string calldata newUri) external;\n', '\n', '    function setUri(uint256 objectId, string calldata newUri) external;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\WUSD\\AllowedAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct AllowedAMM {\n', '    address ammAddress;\n', '    address[] liquidityPools;\n', '}\n', '\n', '// File: contracts\\WUSD\\WUSDExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract WUSDExtension {\n', '\n', '    uint256 private constant DECIMALS = 18;\n', '\n', '    address private _controller;\n', '\n', '    address private _collection;\n', '\n', '    uint256 private _mainItemObjectId;\n', '    address private _mainItemInteroperableAddress;\n', '\n', '    constructor(address orchestrator, string memory name, string memory symbol, string memory collectionUri, string memory mainItemName, string memory mainItemSymbol, string memory mainItemUri) {\n', '        _controller = msg.sender;\n', '        (_collection,) = IEthItemOrchestrator(orchestrator).createNative(abi.encodeWithSignature("init(string,string,bool,string,address,bytes)", name, symbol, true, collectionUri, address(this), ""), "");\n', '        (_mainItemObjectId, _mainItemInteroperableAddress) = _mintEmpty(mainItemName, mainItemSymbol, mainItemUri, true);\n', '    }\n', '\n', '    function collection() public view returns (address) {\n', '        return _collection;\n', '    }\n', '\n', '    function data() public view returns (address, uint256, address) {\n', '        return (_collection, _mainItemObjectId, _mainItemInteroperableAddress);\n', '    }\n', '\n', '    function controller() public view returns (address) {\n', '        return _controller;\n', '    }\n', '\n', '    modifier controllerOnly() {\n', '        require(msg.sender == _controller, "Unauthorized action");\n', '        _;\n', '    }\n', '\n', '    function mintEmpty(string memory tokenName, string memory tokenSymbol, string memory objectUri, bool editable) public controllerOnly returns(uint256 objectId, address interoperableInterfaceAddress) {\n', '        return _mintEmpty(tokenName, tokenSymbol, objectUri, editable);\n', '    }\n', '\n', '    function _mintEmpty(string memory tokenName, string memory tokenSymbol, string memory objectUri, bool editable) private returns(uint256 objectId, address interoperableInterfaceAddress) {\n', '        INativeV1 theCollection = INativeV1(_collection);\n', '        (objectId, interoperableInterfaceAddress) = theCollection.mint(10**18, tokenName, tokenSymbol, objectUri, editable);\n', '        theCollection.burn(objectId, theCollection.balanceOf(address(this), objectId));\n', '    }\n', '\n', '    function setCollectionUri(string memory uri) public controllerOnly {\n', '        INativeV1(_collection).setUri(uri);\n', '    }\n', '\n', '    function setItemUri(uint256 existingObjectId, string memory uri) public controllerOnly {\n', '        INativeV1(_collection).setUri(existingObjectId, uri);\n', '    }\n', '\n', '    function makeReadOnly(uint256 objectId) public controllerOnly {\n', '        INativeV1(_collection).makeReadOnly(objectId);\n', '    }\n', '\n', '    function mintFor(address ammPlugin, address liquidityPoolAddress, uint256 liquidityPoolAmount, address receiver) public controllerOnly {\n', '        _safeTransferFrom(liquidityPoolAddress, msg.sender, address(this), liquidityPoolAmount);\n', '        _mint(_mainItemObjectId, _normalizeAndSumAmounts(ammPlugin, liquidityPoolAddress, liquidityPoolAmount), receiver);\n', '    }\n', '\n', '    function mintForRebalanceByCredit(AllowedAMM[] memory amms) public controllerOnly returns(uint256 credit) {\n', '        uint256 totalSupply = INativeV1(_collection).totalSupply(_mainItemObjectId);\n', '        for(uint256 i = 0; i < amms.length; i++) {\n', '            for(uint256 j = 0; j < amms[i].liquidityPools.length; j++) {\n', '                credit += _normalizeAndSumAmounts(amms[i].ammAddress, amms[i].liquidityPools[j], IERC20(amms[i].liquidityPools[j]).balanceOf(address(this)));\n', '            }\n', '        }\n', '        require(credit > totalSupply, "No credit");\n', '        _mint(_mainItemObjectId, credit = (credit - totalSupply), msg.sender);\n', '    }\n', '\n', '    function burnFor(uint256 objectId, uint256 value, address receiver) public controllerOnly {\n', '        _safeTransferFrom(_mainItemInteroperableAddress, msg.sender, address(this), INativeV1(_collection).toInteroperableInterfaceAmount(_mainItemObjectId, value));\n', '        INativeV1(_collection).burn(_mainItemObjectId, value);\n', '        _mint(objectId, value, receiver);\n', '    }\n', '\n', '    function _mint(uint256 objectId, uint256 amount, address receiver) private {\n', '        INativeV1(_collection).mint(objectId, amount);\n', '        INativeV1(_collection).safeTransferFrom(address(this), receiver, objectId, INativeV1(_collection).balanceOf(address(this), objectId), "");\n', '    }\n', '\n', '    function burnFor(address from, uint256 value, address ammPlugin, address liquidityPoolAddress, uint256 liquidityPoolAmount, address liquidityPoolReceiver) public controllerOnly {\n', '        _safeTransferFrom(_mainItemInteroperableAddress, msg.sender, address(this), INativeV1(_collection).toInteroperableInterfaceAmount(_mainItemObjectId, value));\n', '        uint256 toBurn = _normalizeAndSumAmounts(ammPlugin, liquidityPoolAddress, liquidityPoolAmount);\n', '        require(value >= toBurn, "Insufficient Amount");\n', '        if(value > toBurn) {\n', '            INativeV1(_collection).safeTransferFrom(address(this), from, _mainItemObjectId, value - toBurn, "");\n', '        }\n', '        INativeV1(_collection).burn(_mainItemObjectId, toBurn);\n', '        _safeTransfer(liquidityPoolAddress, liquidityPoolReceiver, liquidityPoolAmount);\n', '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '\n', '    function _normalizeAndSumAmounts(address ammPlugin, address liquidityPoolAddress, uint256 liquidityPoolAmount)\n', '        private\n', '        view\n', '        returns(uint256 amount) {\n', '            IERC20 liquidityPool = IERC20(liquidityPoolAddress);\n', '            (uint256[] memory amounts, address[] memory tokens) = IAMM(ammPlugin).byLiquidityPoolAmount(address(liquidityPool), liquidityPoolAmount);\n', '            for(uint256 i = 0; i < amounts.length; i++) {\n', '                amount += _normalizeTokenAmountToDefaultDecimals(tokens[i], amounts[i]);\n', '            }\n', '    }\n', '\n', '    function _normalizeTokenAmountToDefaultDecimals(address tokenAddress, uint256 amount) internal virtual view returns(uint256) {\n', '        uint256 remainingDecimals = DECIMALS;\n', '        IERC20 token = IERC20(tokenAddress);\n', '        remainingDecimals -= token.decimals();\n', '\n', '        if(remainingDecimals == 0) {\n', '            return amount;\n', '        }\n', '\n', '        return amount * (remainingDecimals == 0 ? 1 : (10**remainingDecimals));\n', '    }\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\DFOHub.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IDoubleProxy {\n', '    function proxy() external view returns (address);\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns (address);\n', '    function getStateHolderAddress() external view returns(address);\n', '    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function getUint256(string calldata name) external view returns(uint256);\n', '    function getAddress(string calldata name) external view returns(address);\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\ERC1155Receiver.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'abstract contract ERC1155Receiver {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor() {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '        _registerInterface(\n', '            ERC1155Receiver(0).onERC1155Received.selector ^\n', '            ERC1155Receiver(0).onERC1155BatchReceived.selector\n', '        );\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IERC20WrapperV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface IERC20WrapperV1 is IEthItem {\n', '\n', '    function source(uint256 objectId) external view returns (address erc20TokenAddress);\n', '\n', '    function object(address erc20TokenAddress) external view returns (uint256 objectId);\n', '\n', '    function mint(address erc20TokenAddress, uint256 amount) external returns (uint256 objectId, address wrapperAddress);\n', '\n', '    function mintETH() external payable returns (uint256 objectId, address wrapperAddress);\n', '}\n', '\n', '// File: contracts\\WUSD\\IWUSDNoteController.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface IWUSDNoteController {\n', '\n', '    function wusdCollection() external view returns(address);\n', '    function wusdObjectId() external view returns(uint256);\n', '    function wusdNoteObjectId() external view returns(uint256);\n', '    function multiplier() external view returns(uint256);\n', '\n', '    function info() external view returns(address, uint256, uint256, uint256);\n', '\n', '    function init(address _wusdCollection, uint256 _wusdObjectId, uint256 _wusdNoteObjectId, uint256 _multiplier) external;\n', '}\n', '\n', '// File: contracts\\WUSD\\IWUSDExtensionController.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', 'interface IWUSDExtensionController {\n', '\n', '    function rebalanceByCreditBlockInterval() external view returns(uint256);\n', '\n', '    function lastRebalanceByCreditBlock() external view returns(uint256);\n', '\n', '    function wusdInfo() external view returns (address, uint256, address);\n', '}\n', '\n', '// File: contracts\\WUSD\\WUSDExtensionController.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract WUSDExtensionController is IWUSDExtensionController, ERC1155Receiver {\n', '\n', '    uint256 public constant ONE_HUNDRED = 1e18;\n', '\n', '    uint256 private constant DECIMALS = 18;\n', '\n', '    address private _doubleProxy;\n', '\n', '    uint256 public override rebalanceByCreditBlockInterval;\n', '\n', '    address private _extension;\n', '\n', '    address private _collection;\n', '\n', '    uint256 private _wusdObjectId;\n', '    address private _wusdInteroperableInterfaceAddress;\n', '\n', '    uint256 private _wusdNote2ObjectId;\n', '    address private _wusdNote2InteroperableInterfaceAddress;\n', '    address private _wusdNote2Controller;\n', '    uint256 private _wusdNote2Percentage;\n', '\n', '    uint256 private _wusdNote5ObjectId;\n', '    address private _wusdNote5InteroperableInterfaceAddress;\n', '    address private _wusdNote5Controller;\n', '    uint256 private _wusdNote5Percentage;\n', '\n', '    uint256 public override lastRebalanceByCreditBlock;\n', '\n', '    AllowedAMM[] private _allowedAMMs;\n', '\n', '    uint256[] private _rebalanceByCreditPercentages;\n', '\n', '    address[] private _rebalanceByCreditReceivers;\n', '\n', '    uint256 private _rebalanceByCreditPercentageForCaller;\n', '\n', '    struct WUSDInitializer {\n', '        address doubleProxyAddress;\n', '        address[] rebalanceByCreditReceivers;\n', '        uint256[] rebalanceByCreditPercentages;\n', '        uint256 rebalanceByCreditPercentageForCaller;\n', '        uint256 rebalanceByCreditBlockInterval;\n', '        bytes allowedAMMsBytes;\n', '        address wusdExtension;\n', '        uint256 wusdNote2ObjectId;\n', '        address wusdNote2Controller;\n', '        uint256 wusdNote2Percentage;\n', '        uint256 wusdNote5ObjectId;\n', '        address wusdNote5Controller;\n', '        uint256 wusdNote5Percentage;\n', '        address orchestratorAddress;\n', '        string[] names;\n', '        string[] symbols;\n', '        string[] uris;\n', '    }\n', '\n', '    constructor(bytes memory wusdInitializerBytes) {\n', '        WUSDInitializer memory wusdInitializer = abi.decode(wusdInitializerBytes, (WUSDInitializer));\n', '        _doubleProxy = wusdInitializer.doubleProxyAddress;\n', '        rebalanceByCreditBlockInterval = wusdInitializer.rebalanceByCreditBlockInterval;\n', '        WUSDExtension wusdExtension = WUSDExtension(_extension = wusdInitializer.wusdExtension != address(0) ? wusdInitializer.wusdExtension : address(new WUSDExtension(wusdInitializer.orchestratorAddress, wusdInitializer.names[0], wusdInitializer.symbols[0], wusdInitializer.uris[0], wusdInitializer.names[1], wusdInitializer.symbols[1], wusdInitializer.uris[1])));\n', '        (_collection, _wusdObjectId, _wusdInteroperableInterfaceAddress) = wusdExtension.data();\n', '        if(wusdInitializer.wusdNote2ObjectId != 0) {\n', '            _wusdNote2InteroperableInterfaceAddress = address(INativeV1(_collection).asInteroperable(_wusdNote2ObjectId = wusdInitializer.wusdNote2ObjectId));\n', '            _checkNoteController(_wusdNote2Controller = wusdInitializer.wusdNote2Controller, _wusdNote2ObjectId, 2);\n', '        }\n', '        if(wusdInitializer.wusdNote5ObjectId != 0) {\n', '            _wusdNote5InteroperableInterfaceAddress = address(INativeV1(_collection).asInteroperable(_wusdNote5ObjectId = wusdInitializer.wusdNote5ObjectId));\n', '            _checkNoteController(_wusdNote5Controller = wusdInitializer.wusdNote5Controller, _wusdNote5ObjectId, 5);\n', '        }\n', '        _wusdNote2Percentage = wusdInitializer.wusdNote2Percentage;\n', '        _wusdNote5Percentage = wusdInitializer.wusdNote5Percentage;\n', '        _setRebalanceByCreditData(wusdInitializer.rebalanceByCreditReceivers, wusdInitializer.rebalanceByCreditPercentages, wusdInitializer.rebalanceByCreditPercentageForCaller);\n', '        _setAllowedAMMs(wusdInitializer.allowedAMMsBytes);\n', '    }\n', '\n', '    function initNotes(address[] memory controllers, string[] memory names, string[] memory symbols, string[] memory uris) public {\n', '        require(_wusdNote2InteroperableInterfaceAddress == address(0), "already init");\n', '        WUSDExtension wusdExtension = WUSDExtension(_extension);\n', '        (_wusdNote2ObjectId, _wusdNote2InteroperableInterfaceAddress) = wusdExtension.mintEmpty(names[0], symbols[0], uris[0], true);\n', '        (_wusdNote5ObjectId, _wusdNote5InteroperableInterfaceAddress) = wusdExtension.mintEmpty(names[1], symbols[1], uris[1], true);\n', '        IWUSDNoteController(_wusdNote2Controller = controllers[0]).init(_collection, _wusdObjectId, _wusdNote2ObjectId, 2);\n', '        IWUSDNoteController(_wusdNote5Controller = controllers[1]).init(_collection, _wusdObjectId, _wusdNote5ObjectId, 5);\n', '    }\n', '\n', '    receive() external payable {\n', '    }\n', '\n', '    function _checkNoteController(address noteController, uint256 wusdNoteObjectIdInput, uint256 multiplierInput) private {\n', '        (address collectionAddress, uint256 wusdObjectId, uint256 wusdNoteObjectId, uint256 multiplier) = IWUSDNoteController(noteController).info();\n', '        if(collectionAddress == address(0)) {\n', '            IWUSDNoteController(noteController).init(_collection, _wusdObjectId, wusdNoteObjectIdInput, multiplierInput);\n', '            (collectionAddress, wusdObjectId, wusdNoteObjectId, multiplier) = IWUSDNoteController(noteController).info();\n', '        }\n', '        require(collectionAddress == _collection, "Wrong collection");\n', '        require(wusdObjectId == _wusdObjectId, "Wrong WUSD Object Id");\n', '        require(wusdNoteObjectId == wusdNoteObjectIdInput, "Wrong WUSD Note Object Id");\n', '        require(multiplier == multiplierInput, "Wrong WUSD Note multiplier");\n', '    }\n', '\n', '    function _setRebalanceByCreditData(address[] memory rebalanceByCreditReceivers, uint256[] memory rebalanceByCreditPercentages, uint256 rebalanceByCreditPercentageForCaller) private {\n', '        require((_rebalanceByCreditPercentages = rebalanceByCreditPercentages).length == (_rebalanceByCreditReceivers = rebalanceByCreditReceivers).length, "Invalid lengths");\n', '        uint256 percentage = _rebalanceByCreditPercentageForCaller = rebalanceByCreditPercentageForCaller + _wusdNote2Percentage + _wusdNote5Percentage;\n', '        for(uint256 i = 0; i < rebalanceByCreditReceivers.length; i++) {\n', '            require(rebalanceByCreditReceivers[i] != address(0), "Void address");\n', '            require(rebalanceByCreditPercentages[i] > 0, "Zero percentage");\n', '            percentage += rebalanceByCreditPercentages[i];\n', '        }\n', '        require(percentage <= ONE_HUNDRED, "More than one hundred");\n', '        _rebalanceByCreditPercentages = rebalanceByCreditPercentages;\n', '        _rebalanceByCreditReceivers = rebalanceByCreditReceivers;\n', '    }\n', '\n', '    function _setAllowedAMMs(bytes memory data) private {\n', '        AllowedAMM[] memory amms = abi.decode(data, (AllowedAMM[]));\n', '        delete _allowedAMMs;\n', '        for(uint256 i = 0; i < amms.length; i++) {\n', '            _allowedAMMs.push(amms[i]);\n', '        }\n', '    }\n', '\n', '    function doubleProxy() public view returns (address) {\n', '        return _doubleProxy;\n', '    }\n', '\n', '    function extension() public view returns (address) {\n', '        return _extension;\n', '    }\n', '\n', '    function collection() public view returns (address) {\n', '        return _collection;\n', '    }\n', '\n', '    function wusdInfo() public override view returns (address, uint256, address) {\n', '        return (_collection, _wusdObjectId, _wusdInteroperableInterfaceAddress);\n', '    }\n', '\n', '    function wusdNote2Info() public view returns (address, uint256, address, address, uint256) {\n', '        return (_collection, _wusdNote2ObjectId, _wusdNote2InteroperableInterfaceAddress, _wusdNote2Controller, _wusdNote2Percentage);\n', '    }\n', '\n', '    function wusdNote5Info() public view returns (address, uint256, address, address, uint256) {\n', '        return (_collection, _wusdNote5ObjectId, _wusdNote5InteroperableInterfaceAddress, _wusdNote5Controller, _wusdNote5Percentage);\n', '    }\n', '\n', '    function rebalanceByCreditReceiversInfo() public view returns (address[] memory, uint256[] memory, uint256, address) {\n', '        return (_rebalanceByCreditReceivers, _rebalanceByCreditPercentages, _rebalanceByCreditPercentageForCaller, IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDWalletAddress());\n', '    }\n', '\n', '    modifier byDFO virtual {\n', '        require(_isFromDFO(msg.sender), "Unauthorized action");\n', '        _;\n', '    }\n', '\n', '    function _isFromDFO(address sender) private view returns(bool) {\n', '        return IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(sender);\n', '    }\n', '\n', '    function setDoubleProxy(address newDoubleProxy) public byDFO {\n', '        _doubleProxy = newDoubleProxy;\n', '    }\n', '\n', '    function setRebalanceByCreditData(address[] memory rebalanceByCreditReceivers, uint256[] memory rebalanceByCreditPercentages, uint256 rebalanceByCreditPercentageForCaller) public byDFO {\n', '        _setRebalanceByCreditData(rebalanceByCreditReceivers, rebalanceByCreditPercentages, rebalanceByCreditPercentageForCaller);\n', '    }\n', '\n', '    function setCollectionUri(string memory uri) public byDFO {\n', '        WUSDExtension(_extension).setCollectionUri(uri);\n', '    }\n', '\n', '    function setItemUri(uint256 existingObjectId, string memory uri) public byDFO {\n', '        WUSDExtension(_extension).setItemUri(existingObjectId, uri);\n', '    }\n', '\n', '    function setrebalanceByCreditBlockInterval(uint256 newrebalanceByCreditBlockInterval) public byDFO {\n', '        rebalanceByCreditBlockInterval = newrebalanceByCreditBlockInterval;\n', '    }\n', '\n', '    function allowedAMMs() public view returns(AllowedAMM[] memory) {\n', '        return _allowedAMMs;\n', '    }\n', '\n', '    function setAllowedAMMs(AllowedAMM[] memory newAllowedAMMs) public byDFO {\n', '        _setAllowedAMMs(abi.encode(newAllowedAMMs));\n', '    }\n', '\n', '    function differences()\n', '        public\n', '        view\n', '        returns (uint256 credit, uint256 debt)\n', '    {\n', '        uint256 totalSupply = INativeV1(_collection).totalSupply(_wusdObjectId);\n', '        uint256 effectiveAmount = 0;\n', '        for(uint256 i = 0; i < _allowedAMMs.length; i++) {\n', '            for(uint256 j = 0; j < _allowedAMMs[i].liquidityPools.length; j++) {\n', '                effectiveAmount += _normalizeAndSumAmounts(i, j, 0);\n', '            }\n', '        }\n', '        credit = effectiveAmount > totalSupply\n', '            ? effectiveAmount - totalSupply\n', '            : 0;\n', '        debt = totalSupply > effectiveAmount\n', '            ? totalSupply - effectiveAmount\n', '            : 0;\n', '    }\n', '\n', '    function fromTokenToStable(address tokenAddress, uint256 amount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IERC20 token = IERC20(tokenAddress);\n', '        uint256 tokenDecimals = token.decimals();\n', '        uint256 remainingDecimals = DECIMALS - tokenDecimals;\n', '        uint256 result = amount == 0 ? token.balanceOf(_extension) : amount;\n', '        if (remainingDecimals == 0) {\n', '            return result;\n', '        }\n', '        return result * 10**remainingDecimals;\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        public\n', '        override\n', '        returns(bytes4) {\n', '            require(msg.sender == _collection, "Only WUSD collection allowed here");\n', '            _onSingleReceived(from, id, value, data);\n', '            return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address from,\n', '        uint256[] memory ids,\n', '        uint256[] memory values,\n', '        bytes memory data\n', '    )\n', '        public\n', '        override\n', '        returns(bytes4) {\n', '\n', '        require(msg.sender == _collection, "Only WUSD collection allowed here");\n', '        bytes[] memory payloads = abi.decode(data, (bytes[]));\n', '        require(payloads.length == ids.length, "Wrong payloads length");\n', '        for(uint256 i = 0; i < ids.length; i++) {\n', '            _onSingleReceived(from, ids[i], values[i], payloads[i]);\n', '        }\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    function _onSingleReceived(\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes memory data) private {\n', '            require(id == _wusdObjectId, "Only WUSD id allowed here");\n', '            if(from == _extension) {\n', '                return;\n', '            }\n', '            (uint256 action, bytes memory payload) = abi.decode(data, (uint256, bytes));\n', '            if(action == 1) {\n', '                _rebalanceByDebt(from, value, payload);\n', '            } else {\n', '                _burn(from, value, payload);\n', '            }\n', '    }\n', '\n', '    function _burn(address from, uint256 value, bytes memory payload) private {\n', '        (uint256 ammPosition, uint256 liquidityPoolPosition, uint256 liquidityPoolAmount, bool keepLiquidityPool) = abi.decode(payload, (uint256, uint256, uint256, bool));\n', '        _safeApprove(_wusdInteroperableInterfaceAddress, _extension, INativeV1(_collection).toInteroperableInterfaceAmount(_wusdObjectId, value));\n', '        WUSDExtension(_extension).burnFor(from, value, _allowedAMMs[ammPosition].ammAddress, _allowedAMMs[ammPosition].liquidityPools[liquidityPoolPosition], liquidityPoolAmount, keepLiquidityPool ? from : address(this));\n', '        if(!keepLiquidityPool) {\n', '            IAMM amm = IAMM(_allowedAMMs[ammPosition].ammAddress);\n', '            _checkAllowance(_allowedAMMs[ammPosition].liquidityPools[liquidityPoolPosition], liquidityPoolAmount, address(amm));\n', '            amm.removeLiquidity(LiquidityPoolData(\n', '                _allowedAMMs[ammPosition].liquidityPools[liquidityPoolPosition],\n', '                liquidityPoolAmount,\n', '                address(0),\n', '                true,\n', '                false,\n', '                from\n', '            ));\n', '        }\n', '    }\n', '\n', '    function _rebalanceByDebt(address from, uint256 value, bytes memory payload) private {\n', '        (, uint256 debt) = differences();\n', '        require(value <= debt, "Cannot Burn this amount");\n', '        uint256 note = abi.decode(payload, (uint256));\n', '        _safeApprove(_wusdInteroperableInterfaceAddress, _extension, INativeV1(_collection).toInteroperableInterfaceAmount(_wusdObjectId, value));\n', '        WUSDExtension(_extension).burnFor(note == 2 ? _wusdNote2ObjectId : _wusdNote5ObjectId, value, from);\n', '    }\n', '\n', '    function rebalanceByCredit() public {\n', '        require(block.number >= (lastRebalanceByCreditBlock + rebalanceByCreditBlockInterval), "Unauthorized action");\n', '        lastRebalanceByCreditBlock = block.number;\n', '        uint256 credit = WUSDExtension(_extension).mintForRebalanceByCredit(_allowedAMMs);\n', '        uint256 availableCredit = credit;\n', '        uint256 reward = 0;\n', '        if(_rebalanceByCreditPercentageForCaller > 0) {\n', '            IERC20(_wusdInteroperableInterfaceAddress).transfer(msg.sender, reward = _calculatePercentage(credit, _rebalanceByCreditPercentageForCaller));\n', '            availableCredit -= reward;\n', '        }\n', '        if(_wusdNote2Percentage > 0) {\n', '            IERC20(_wusdInteroperableInterfaceAddress).transfer(_wusdNote2Controller, reward = _calculatePercentage(credit, _wusdNote2Percentage));\n', '            availableCredit -= reward;\n', '        }\n', '        if(_wusdNote5Percentage > 0) {\n', '            IERC20(_wusdInteroperableInterfaceAddress).transfer(_wusdNote5Controller, reward = _calculatePercentage(credit, _wusdNote5Percentage));\n', '            availableCredit -= reward;\n', '        }\n', '        for(uint256 i = 0; i < _rebalanceByCreditReceivers.length; i++) {\n', '            IERC20(_wusdInteroperableInterfaceAddress).transfer(_rebalanceByCreditReceivers[i], reward = _calculatePercentage(credit, _rebalanceByCreditPercentages[i]));\n', '            availableCredit -= reward;\n', '        }\n', '        if(availableCredit > 0) {\n', '            IERC20(_wusdInteroperableInterfaceAddress).transfer(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDWalletAddress(), availableCredit);\n', '        }\n', '    }\n', '\n', '    function _calculatePercentage(uint256 total, uint256 percentage) private pure returns (uint256) {\n', '        return (total * ((percentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '    }\n', '\n', '    modifier _forAllowedAMMAndLiquidityPool(uint256 ammIndex, uint256 liquidityPoolIndex) {\n', '        require(\n', '            ammIndex >= 0 && ammIndex < _allowedAMMs.length,\n', '            "Unknown AMM!"\n', '        );\n', '        require(\n', '            liquidityPoolIndex >= 0 && liquidityPoolIndex < _allowedAMMs[ammIndex].liquidityPools.length,\n', '            "Unknown Liquidity Pool!"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function addLiquidity(\n', '        uint256 ammPosition,\n', '        uint256 liquidityPoolPosition,\n', '        uint256 liquidityPoolAmount,\n', '        bool byLiquidityPool\n', '    )\n', '        public\n', '        _forAllowedAMMAndLiquidityPool(ammPosition, liquidityPoolPosition)\n', '        returns(uint256 toMint)\n', '    {\n', '        address liquidityPoolAddress = _allowedAMMs[ammPosition].liquidityPools[liquidityPoolPosition];\n', '        uint256[] memory spent;\n', '        uint256[] memory amounts;\n', '        address[] memory tokens;\n', '        if(byLiquidityPool) {\n', '            _safeTransferFrom(liquidityPoolAddress, msg.sender, address(this), toMint = liquidityPoolAmount);\n', '        } else {\n', '            IAMM amm = IAMM(_allowedAMMs[ammPosition].ammAddress);\n', '            (amounts, tokens) = amm.byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount);\n', '            for(uint256 i = 0; i < tokens.length; i++) {\n', '                _safeTransferFrom(tokens[i], msg.sender, address(this), amounts[i]);\n', '                _safeApprove(tokens[i], address(amm), amounts[i]);\n', '            }\n', '            (toMint, spent,) = IAMM(_allowedAMMs[ammPosition].ammAddress).addLiquidity(LiquidityPoolData(\n', '                liquidityPoolAddress,\n', '                liquidityPoolAmount,\n', '                address(0),\n', '                true,\n', '                false,\n', '                address(this)\n', '            ));\n', '        }\n', '\n', '        _safeApprove(liquidityPoolAddress, _extension, toMint);\n', '        WUSDExtension(_extension).mintFor(_allowedAMMs[ammPosition].ammAddress, liquidityPoolAddress, toMint, msg.sender);\n', '\n', '        for(uint256 i = 0; i < spent.length; i++) {\n', '            uint256 difference = amounts[i] - spent[i];\n', '            if(difference > 0) {\n', '                _safeTransfer(tokens[i], msg.sender, difference);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _checkAllowance(address tokenAddress, uint256 value, address operator) internal virtual {\n', '        if(tokenAddress == address(0) || operator == address(0)) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if(token.allowance(address(this), operator) <= value) {\n', '            _safeApprove(tokenAddress, operator, token.totalSupply());\n', '        }\n', '    }\n', '\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '\n', '    function _flushBack(address payable sender, address[] memory tokens) internal virtual {\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            if(tokens[i] != address(0)) {\n', '                _flushBack(sender, tokens[i]);\n', '            }\n', '        }\n', '        _flushBack(sender, address(0));\n', '    }\n', '\n', '    function _flushBack(address payable sender, address tokenAddress) internal virtual {\n', '        uint256 balance = tokenAddress == address(0) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '\n', '        if(balance == 0) {\n', '            return;\n', '        }\n', '\n', '        if(tokenAddress == address(0)) {\n', '            return sender.transfer(balance);\n', '        }\n', '        _safeTransfer(tokenAddress, sender, balance);\n', '    }\n', '\n', '    function _normalizeAndSumAmounts(uint256 ammPosition, uint256 liquidityPoolPosition, uint256 liquidityPoolAmount)\n', '        private\n', '        view\n', '        returns(uint256 amount) {\n', '            IERC20 liquidityPool = IERC20(_allowedAMMs[ammPosition].liquidityPools[liquidityPoolPosition]);\n', '            (uint256[] memory amounts, address[] memory tokens) = IAMM(_allowedAMMs[ammPosition].ammAddress).byLiquidityPoolAmount(address(liquidityPool), liquidityPoolAmount != 0 ? liquidityPoolAmount : liquidityPool.balanceOf(_extension));\n', '            for(uint256 i = 0; i < amounts.length; i++) {\n', '                amount += _normalizeTokenAmountToDefaultDecimals(tokens[i], amounts[i]);\n', '            }\n', '    }\n', '\n', '    function _normalizeTokenAmountToDefaultDecimals(address tokenAddress, uint256 amount) internal virtual view returns(uint256) {\n', '        uint256 remainingDecimals = DECIMALS;\n', '        IERC20 token = IERC20(tokenAddress);\n', '        remainingDecimals -= token.decimals();\n', '\n', '        if(remainingDecimals == 0) {\n', '            return amount;\n', '        }\n', '\n', '        return amount * (remainingDecimals == 0 ? 1 : (10**remainingDecimals));\n', '    }\n', '}']