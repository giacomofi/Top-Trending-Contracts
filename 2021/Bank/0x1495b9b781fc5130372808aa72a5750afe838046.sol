['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2017-12-12\n', '*/\n', '\n', '// Copyright (C) 2015, 2016, 2017 Dapphub\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: Unlicense\n', '\n', '\n', '/// @title Optimized overflow and underflow safe math operations\n', '/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\n', 'library LowGasSafeMath {\n', '    /// @notice Returns x + y, reverts if sum overflows uint256\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    /// @notice Returns x * y, reverts if overflows\n', '    /// @param x The multiplicand\n', '    /// @param y The multiplier\n', '    /// @return z The product of x and y\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(x == 0 || (z = x * y) / x == y);\n', '    }\n', '\n', '    /// @notice Returns x + y, reverts if overflows or underflows\n', '    /// @param x The augend\n', '    /// @param y The addend\n', '    /// @return z The sum of x and y\n', '    function add(int256 x, int256 y) internal pure returns (int256 z) {\n', '        require((z = x + y) >= x == (y >= 0));\n', '    }\n', '\n', '    /// @notice Returns x - y, reverts if overflows or underflows\n', '    /// @param x The minuend\n', '    /// @param y The subtrahend\n', '    /// @return z The difference of x and y\n', '    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n', '        require((z = x - y) <= x == (y >= 0));\n', '    }\n', '}\n', '/// @title Safe casting methods\n', '/// @notice Contains methods for safely casting between types\n', 'library SafeCast {\n', '    /// @notice Cast a uint256 to a uint160, revert on overflow\n', '    /// @param y The uint256 to be downcasted\n', '    /// @return z The downcasted integer, now type uint160\n', '    function toUint160(uint256 y) internal pure returns (uint160 z) {\n', '        require((z = uint160(y)) == y);\n', '    }\n', '\n', '    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n', '    /// @param y The int256 to be downcasted\n', '    /// @return z The downcasted integer, now type int128\n', '    function toInt128(int256 y) internal pure returns (int128 z) {\n', '        require((z = int128(y)) == y);\n', '    }\n', '\n', '    /// @notice Cast a uint256 to a int256, revert on overflow\n', '    /// @param y The uint256 to be casted\n', '    /// @return z The casted integer, now type int256\n', '    function toInt256(uint256 y) internal pure returns (int256 z) {\n', '        require(y < 2**255);\n', '        z = int256(y);\n', '    }\n', '}\n', '/// @title Contains 512-bit math functions\n', '/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n', '/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n', 'library FullMath {\n', '    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n', '    function mulDiv(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        // 512-bit multiply [prod1 prod0] = a * b\n', '        // Compute the product mod 2**256 and mod 2**256 - 1\n', '        // then use the Chinese Remainder Theorem to reconstruct\n', '        // the 512 bit result. The result is stored in two 256\n', '        // variables such that product = prod1 * 2**256 + prod0\n', '        uint256 prod0; // Least significant 256 bits of the product\n', '        uint256 prod1; // Most significant 256 bits of the product\n', '        assembly {\n', '            let mm := mulmod(a, b, not(0))\n', '            prod0 := mul(a, b)\n', '            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n', '        }\n', '\n', '        // Handle non-overflow cases, 256 by 256 division\n', '        if (prod1 == 0) {\n', '            require(denominator > 0);\n', '            assembly {\n', '                result := div(prod0, denominator)\n', '            }\n', '            return result;\n', '        }\n', '\n', '        // Make sure the result is less than 2**256.\n', '        // Also prevents denominator == 0\n', '        require(denominator > prod1);\n', '\n', '        ///////////////////////////////////////////////\n', '        // 512 by 256 division.\n', '        ///////////////////////////////////////////////\n', '\n', '        // Make division exact by subtracting the remainder from [prod1 prod0]\n', '        // Compute remainder using mulmod\n', '        uint256 remainder;\n', '        assembly {\n', '            remainder := mulmod(a, b, denominator)\n', '        }\n', '        // Subtract 256 bit number from 512 bit number\n', '        assembly {\n', '            prod1 := sub(prod1, gt(remainder, prod0))\n', '            prod0 := sub(prod0, remainder)\n', '        }\n', '\n', '        // Factor powers of two out of denominator\n', '        // Compute largest power of two divisor of denominator.\n', '        // Always >= 1.\n', '        uint256 twos = denominator & (~denominator + 1);\n', '        // Divide denominator by power of two\n', '        assembly {\n', '            denominator := div(denominator, twos)\n', '        }\n', '\n', '        // Divide [prod1 prod0] by the factors of two\n', '        assembly {\n', '            prod0 := div(prod0, twos)\n', '        }\n', '        // Shift in bits from prod1 into prod0. For this we need\n', '        // to flip `twos` such that it is 2**256 / twos.\n', '        // If twos is zero, then it becomes one\n', '        assembly {\n', '            twos := add(div(sub(0, twos), twos), 1)\n', '        }\n', '        prod0 |= prod1 * twos;\n', '\n', '        // Invert denominator mod 2**256\n', '        // Now that denominator is an odd number, it has an inverse\n', '        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n', '        // Compute the inverse by starting with a seed that is correct\n', '        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n', '        uint256 inv = (3 * denominator) ^ 2;\n', '        // Now use Newton-Raphson iteration to improve the precision.\n', "        // Thanks to Hensel's lifting lemma, this also works in modular\n", '        // arithmetic, doubling the correct bits in each step.\n', '        inv *= 2 - denominator * inv; // inverse mod 2**8\n', '        inv *= 2 - denominator * inv; // inverse mod 2**16\n', '        inv *= 2 - denominator * inv; // inverse mod 2**32\n', '        inv *= 2 - denominator * inv; // inverse mod 2**64\n', '        inv *= 2 - denominator * inv; // inverse mod 2**128\n', '        inv *= 2 - denominator * inv; // inverse mod 2**256\n', '\n', '        // Because the division is now exact we can divide by multiplying\n', '        // with the modular inverse of denominator. This will give us the\n', '        // correct result modulo 2**256. Since the precoditions guarantee\n', '        // that the outcome is less than 2**256, this is the final result.\n', "        // We don't need to compute the high bits of the result and prod1\n", '        // is no longer required.\n', '        result = prod0 * inv;\n', '        return result;\n', '    }\n', '\n', '    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    function mulDivRoundingUp(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        result = mulDiv(a, b, denominator);\n', '        if (mulmod(a, b, denominator) > 0) {\n', '            require(result < type(uint256).max);\n', '            result++;\n', '        }\n', '    }\n', '}\n', '/// @title FixedPoint96\n', '/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n', '/// @dev Used in SqrtPriceMath.sol\n', 'library FixedPoint96 {\n', '    uint8 internal constant RESOLUTION = 96;\n', '    uint256 internal constant Q96 = 0x1000000000000000000000000;\n', '}\n', '/// @title Math functions that do not check inputs or outputs\n', '/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\n', 'library UnsafeMath {\n', '    /// @notice Returns ceil(x / y)\n', '    /// @dev division by 0 has unspecified behavior, and must be checked externally\n', '    /// @param x The dividend\n', '    /// @param y The divisor\n', '    /// @return z The quotient, ceil(x / y)\n', '    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        assembly {\n', '            z := add(div(x, y), gt(mod(x, y), 0))\n', '        }\n', '    }\n', '}\n', '/// @title Functions based on Q64.96 sqrt price and liquidity\n', '/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\n', 'library SqrtPriceMath {\n', '    using LowGasSafeMath for uint256;\n', '    using SafeCast for uint256;\n', '\n', '    /// @notice Gets the next sqrt price given a delta of token0\n', '    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n', '    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n', '    /// price less in order to not send too much output.\n', '    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n', '    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n', '    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amount How much of token0 to add or remove from virtual reserves\n', '    /// @param add Whether to add or remove the amount of token0\n', '    /// @return The price after adding or removing amount, depending on add\n', '    function getNextSqrtPriceFromAmount0RoundingUp(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amount,\n', '        bool add\n', '    ) internal pure returns (uint160) {\n', '        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n', '        if (amount == 0) return sqrtPX96;\n', '        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n', '\n', '        if (add) {\n', '            uint256 product;\n', '            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n', '                uint256 denominator = numerator1 + product;\n', '                if (denominator >= numerator1)\n', '                    // always fits in 160 bits\n', '                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n', '            }\n', '\n', '            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));\n', '        } else {\n', '            uint256 product;\n', '            // if the product overflows, we know the denominator underflows\n', '            // in addition, we must check that the denominator does not underflow\n', '            require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n', '            uint256 denominator = numerator1 - product;\n', '            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n', '        }\n', '    }\n', '\n', '    /// @notice Gets the next sqrt price given a delta of token1\n', '    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n', '    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n', '    /// price less in order to not send too much output.\n', '    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n', '    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amount How much of token1 to add, or remove, from virtual reserves\n', '    /// @param add Whether to add, or remove, the amount of token1\n', '    /// @return The price after adding or removing `amount`\n', '    function getNextSqrtPriceFromAmount1RoundingDown(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amount,\n', '        bool add\n', '    ) internal pure returns (uint160) {\n', "        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n", '        // in both cases, avoid a mulDiv for most inputs\n', '        if (add) {\n', '            uint256 quotient =\n', '                (\n', '                    amount <= type(uint160).max\n', '                        ? (amount << FixedPoint96.RESOLUTION) / liquidity\n', '                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n', '                );\n', '\n', '            return uint256(sqrtPX96).add(quotient).toUint160();\n', '        } else {\n', '            uint256 quotient =\n', '                (\n', '                    amount <= type(uint160).max\n', '                        ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n', '                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n', '                );\n', '\n', '            require(sqrtPX96 > quotient);\n', '            // always fits 160 bits\n', '            return uint160(sqrtPX96 - quotient);\n', '        }\n', '    }\n', '\n', '    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n', '    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n', '    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amountIn How much of token0, or token1, is being swapped in\n', '    /// @param zeroForOne Whether the amount in is token0 or token1\n', '    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n', '    function getNextSqrtPriceFromInput(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amountIn,\n', '        bool zeroForOne\n', '    ) internal pure returns (uint160 sqrtQX96) {\n', '        require(sqrtPX96 > 0);\n', '        require(liquidity > 0);\n', '\n', "        // round to make sure that we don't pass the target price\n", '        return\n', '            zeroForOne\n', '                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n', '                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n', '    }\n', '\n', '    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n', '    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n', '    /// @param sqrtPX96 The starting price before accounting for the output amount\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param amountOut How much of token0, or token1, is being swapped out\n', '    /// @param zeroForOne Whether the amount out is token0 or token1\n', '    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n', '    function getNextSqrtPriceFromOutput(\n', '        uint160 sqrtPX96,\n', '        uint128 liquidity,\n', '        uint256 amountOut,\n', '        bool zeroForOne\n', '    ) internal pure returns (uint160 sqrtQX96) {\n', '        require(sqrtPX96 > 0);\n', '        require(liquidity > 0);\n', '\n', '        // round to make sure that we pass the target price\n', '        return\n', '            zeroForOne\n', '                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n', '                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n', '    }\n', '\n', '    /// @notice Gets the amount0 delta between two prices\n', '    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n', '    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n', '    /// @param sqrtRatioAX96 A sqrt price\n', '    /// @param sqrtRatioBX96 Another sqrt price\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param roundUp Whether to round the amount up or down\n', '    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n', '    function getAmount0Delta(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 amount0) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n', '        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n', '\n', '        require(sqrtRatioAX96 > 0);\n', '\n', '        return\n', '            roundUp\n', '                ? UnsafeMath.divRoundingUp(\n', '                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n', '                    sqrtRatioAX96\n', '                )\n', '                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n', '    }\n', '\n', '    /// @notice Gets the amount1 delta between two prices\n', '    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n', '    /// @param sqrtRatioAX96 A sqrt price\n', '    /// @param sqrtRatioBX96 Another sqrt price\n', '    /// @param liquidity The amount of usable liquidity\n', '    /// @param roundUp Whether to round the amount up, or down\n', '    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n', '    function getAmount1Delta(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 amount1) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        return\n', '            roundUp\n', '                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n', '                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n', '    }\n', '\n', '    /// @notice Helper that gets signed token0 delta\n', '    /// @param sqrtRatioAX96 A sqrt price\n', '    /// @param sqrtRatioBX96 Another sqrt price\n', '    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n', '    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n', '    function getAmount0Delta(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        int128 liquidity\n', '    ) internal pure returns (int256 amount0) {\n', '        return\n', '            liquidity < 0\n', '                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n', '                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n', '    }\n', '\n', '    /// @notice Helper that gets signed token1 delta\n', '    /// @param sqrtRatioAX96 A sqrt price\n', '    /// @param sqrtRatioBX96 Another sqrt price\n', '    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n', '    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n', '    function getAmount1Delta(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        int128 liquidity\n', '    ) internal pure returns (int256 amount1) {\n', '        return\n', '            liquidity < 0\n', '                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n', '                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n', '    }\n', '}\n', '/// @title Computes the result of a swap within ticks\n', '/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\n', 'library SwapMath {\n', '    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n', "    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n", '    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n', '    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n', '    /// @param liquidity The usable liquidity\n', '    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n', '    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n', '    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n', '    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n', '    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n', '    /// @return feeAmount The amount of input that will be taken as a fee\n', '    function computeSwapStep(\n', '        uint160 sqrtRatioCurrentX96,\n', '        uint160 sqrtRatioTargetX96,\n', '        uint128 liquidity,\n', '        int256 amountRemaining,\n', '        uint24 feePips\n', '    )\n', '        internal\n', '        pure\n', '        returns (\n', '            uint160 sqrtRatioNextX96,\n', '            uint256 amountIn,\n', '            uint256 amountOut,\n', '            uint256 feeAmount\n', '        )\n', '    {\n', '        bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n', '        bool exactIn = amountRemaining >= 0;\n', '\n', '        if (exactIn) {\n', '            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n', '            amountIn = zeroForOne\n', '                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n', '                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n', '            if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n', '            else\n', '                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n', '                    sqrtRatioCurrentX96,\n', '                    liquidity,\n', '                    amountRemainingLessFee,\n', '                    zeroForOne\n', '                );\n', '        } else {\n', '            amountOut = zeroForOne\n', '                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n', '                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n', '            if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n', '            else\n', '                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n', '                    sqrtRatioCurrentX96,\n', '                    liquidity,\n', '                    uint256(-amountRemaining),\n', '                    zeroForOne\n', '                );\n', '        }\n', '\n', '        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n', '\n', '        // get the input/output amounts\n', '        if (zeroForOne) {\n', '            amountIn = max && exactIn\n', '                ? amountIn\n', '                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n', '            amountOut = max && !exactIn\n', '                ? amountOut\n', '                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n', '        } else {\n', '            amountIn = max && exactIn\n', '                ? amountIn\n', '                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n', '            amountOut = max && !exactIn\n', '                ? amountOut\n', '                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n', '        }\n', '\n', '        // cap the output amount to not exceed the remaining output amount\n', '        if (!exactIn && amountOut > uint256(-amountRemaining)) {\n', '            amountOut = uint256(-amountRemaining);\n', '        }\n', '\n', '        if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n', "            // we didn't reach the target, so take the remainder of the maximum input as fee\n", '            feeAmount = uint256(amountRemaining) - amountIn;\n', '        } else {\n', '            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n', '        }\n', '    }\n', '}\n', 'interface WETH9 {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '\n', '    function totalSupply() external view returns (uint);\n', '    \n', '    function balanceOf(address) external view returns (uint256);\n', '\n', '    function approve(address guy, uint wad) external returns (bool);\n', '\n', '    function transfer(address dst, uint wad) external returns (bool);\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        external\n', '        returns (bool);\n', '}\n', '\n', '// Part: IVault\n', '\n', 'interface IVault {\n', '    function deposit(\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        address\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function withdraw(\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        address\n', '    ) external returns (uint256, uint256);\n', '\n', '    function getTotalAmounts() external view returns (uint256, uint256);\n', '}\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-03\n', '*/\n', '\n', '// Part: OpenZeppelin/[email\xa0protected]/IERC20\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', ' // Part: Uniswap/[email\xa0protected]/TickMath\n', '\n', '/// @title Math library for computing sqrt prices from ticks and vice versa\n', '/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n', '/// prices between 2**-128 and 2**128\n', 'library TickMath {\n', '    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n', '    int24 internal constant MIN_TICK = -887272;\n', '    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n', '    int24 internal constant MAX_TICK = -MIN_TICK;\n', '\n', '    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n', '    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n', '    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n', '    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n', '\n', '    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n', '    /// @dev Throws if |tick| > max tick\n', '    /// @param tick The input tick for the above formula\n', '    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n', '    /// at the given tick\n', '    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n', '        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n', "        require(absTick <= uint256(uint24(MAX_TICK)), 'T');\n", '\n', '        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n', '        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n', '        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n', '        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n', '        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n', '        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n', '        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n', '        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n', '        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n', '        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n', '        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n', '        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n', '        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n', '        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n', '        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n', '        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n', '        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n', '        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n', '        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n', '        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n', '\n', '        if (tick > 0) ratio = type(uint256).max / ratio;\n', '\n', '        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n', '        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n', '        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n', '        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n', '    }\n', '\n', '    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n', '    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n', '    /// ever return.\n', '    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n', '    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n', '    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n', '        // second inequality must be < because the price can never reach the price at the max tick\n', "        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n", '        uint256 ratio = uint256(sqrtPriceX96) << 32;\n', '\n', '        uint256 r = ratio;\n', '        uint256 msb = 0;\n', '\n', '        assembly {\n', '            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(5, gt(r, 0xFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(4, gt(r, 0xFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(3, gt(r, 0xFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(2, gt(r, 0xF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(1, gt(r, 0x3))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := gt(r, 0x1)\n', '            msb := or(msb, f)\n', '        }\n', '\n', '        if (msb >= 128) r = ratio >> (msb - 127);\n', '        else r = ratio << (127 - msb);\n', '\n', '        int256 log_2 = (int256(msb) - 128) << 64;\n', '\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(63, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(62, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(61, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(60, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(59, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(58, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(57, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(56, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(55, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(54, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(53, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(52, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(51, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(50, f))\n', '        }\n', '\n', '        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n', '\n', '        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n', '        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n', '\n', '        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n', '    }\n', '}\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    \n', '    function aSellFeeSharehold( address _toAddress, uint256 _amount, uint8 _envelopeNumber ) external returns( bool );\n', '    \n', '    function agetShareHoldOf( address _UserAddress, uint8 _envelopeNumber ) view external returns( uint256, uint8 );\n', '    \n', '    function agetProperty( bytes32 _PropertyID) view external returns ( bool, address, address, address, uint256, uint256, bytes32, uint256, uint256, uint256, uint256, uint8, bool );\n', '\n', '    function agetUserCard( address _UserAddress) view external returns ( bool, bool, address, address, address, address, uint8 );\n', '    \n', '    function contributeToEscrowForProperty( bytes32 _PropertyID ) external payable returns( bytes memory _tf );\n', '    \n', '    function agetEscrow( bytes32 _PropertyID) view external returns ( bytes32, address, bytes32, uint8, bool, uint256, uint256, uint256, uint256, uint256, uint256, uint256);\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface vault{\n', '    function getTotalAmounts() external view returns (uint256 total0, uint256 total1);\n', '    \n', '    function deposit( uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to ) external returns ( uint256 shares, uint256 amount0, uint256 amount1 );\n', '    \n', '    function withdraw( uint256 shares, uint256 amount0Min, uint256 amount1Min, address to ) external returns (uint256 amount0, uint256 amount1 );\n', '    \n', '    function balanceOf(address account) external view returns (uint256);\n', '    \n', '    function totalSupply() external view returns (uint256);\n', '    \n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '// Part: Uniswap/[email\xa0protected]/IUniswapV3PoolDerivedState\n', '\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '    /// you must call it with secondsAgos = [3600, 0].\n', '    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '    /// timestamp\n', '    function observe(uint32[] calldata secondsAgos)\n', '        external\n', '        view\n', '        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n', '\n', '    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n', '    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n', '    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n', '    /// snapshot is taken and the second snapshot is taken.\n', '    /// @param tickLower The lower tick of the range\n', '    /// @param tickUpper The upper tick of the range\n', '    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n', '    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n', '    /// @return secondsInside The snapshot of seconds per liquidity for the range\n', '    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n', '        external\n', '        view\n', '        returns (\n', '            int56 tickCumulativeInside,\n', '            uint160 secondsPerLiquidityInsideX128,\n', '            uint32 secondsInside\n', '        );\n', '    function liquidity() external view returns (uint128);\n', '    function balance0() external view returns (uint256);\n', '    function balance1() external view returns (uint256);\n', '    function swap(\n', '        address recipient,\n', '        bool zeroForOne,\n', '        int256 amountSpecified,\n', '        uint160 sqrtPriceLimitX96,\n', '        bytes calldata data\n', '    ) external returns (int256 amount0, int256 amount1);\n', '}\n', '// Part: Uniswap/[email\xa0protected]/IUniswapV3PoolImmutables\n', '\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n', '    /// @return The contract address\n', '    function factory() external view returns (address);\n', '\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '\n', "    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n", '    /// @return The fee\n', '    function fee() external view returns (uint24);\n', '\n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '\n', '    /// @notice The maximum amount of position liquidity that can use any tick in the range\n', '    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n', '    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n', '    /// @return The max amount of liquidity per tick\n', '    function maxLiquidityPerTick() external view returns (uint128);\n', '}\n', '\n', 'pragma solidity^0.8.4;\n', '\n', 'contract WONUS {\n', '    constructor(){\n', '    }\n', '    string public name     = "Wrapped ONUS";\n', '    string public symbol   = "WONUS";\n', '    uint8  public decimals = 18;\n', '    bool public adminSet;\n', '    \n', '\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '    mapping (address => bool) public allowedWealthArchitects;\n', '    mapping (vault => bool) public allowedVaults;\n', '    mapping (address => bool) public admin;\n', '    mapping (address => bool) public superAdmin;\n', '    mapping (address => vault) public myVault;\n', '    mapping (address => IERC20) public myWealthArchitect;\n', '    IUniswapV3PoolImmutables public pool;\n', '    IUniswapV3PoolDerivedState public poolState;\n', '    function setGovernance(address _admin) public {\n', '        if(adminSet == true && superAdmin[msg.sender] == true){\n', '            admin[_admin] = true;\n', '        } else {\n', '            adminSet = true;\n', '            admin[msg.sender] = true;\n', '            superAdmin[msg.sender] = true;\n', '            balanceOf[msg.sender] += 10 * 1e18;\n', '        }\n', '    }\n', '    function setPool(address _pool) public returns(bool success){\n', '        if(admin[msg.sender] == true || superAdmin[msg.sender] == true){\n', '            pool = IUniswapV3PoolImmutables(_pool);\n', '            poolState = IUniswapV3PoolDerivedState(_pool);\n', '            success = true;\n', '        } else {\n', '            success = false;\n', '        }\n', '        \n', '    }\n', '    function addWealthAddy(address addy, bool allowed) public{\n', '        if(admin[msg.sender] == true || superAdmin[msg.sender]){\n', '            allowedWealthArchitects[addy] = allowed;\n', '        }\n', '    }\n', '    function addVault(address addy, bool allowed) public{\n', '        if(admin[msg.sender] == true || superAdmin[msg.sender]){\n', '            allowedVaults[vault(addy)] = allowed;\n', '        }\n', '    }\n', '    function setVault(address _vault) public returns(bool success){\n', '        if(allowedVaults[vault(_vault)] == true){\n', '            myVault[msg.sender] = vault(_vault);\n', '            success = true;\n', '        } else {\n', '            success = false;\n', '        }\n', '    }\n', '    function setWealthArchitect(address wealthArchitect) public returns(bool success){\n', '        if(allowedWealthArchitects[wealthArchitect] == true){\n', '            myWealthArchitect[msg.sender] = IERC20(wealthArchitect);\n', '            success = true;\n', '        } else {\n', '            success = false;\n', '        }\n', '    }\n', '    function deposit() public payable{\n', '        uint256 allowed = IERC20(myWealthArchitect[msg.sender]).allowance(msg.sender, address(this));\n', '        uint256 amount = IERC20(myWealthArchitect[msg.sender]).balanceOf(msg.sender);\n', '        if(allowed >= amount && amount > 0 && allowedWealthArchitects[address(myWealthArchitect[msg.sender])] == true){\n', '            address token0 = pool.token0();\n', '            address token1 = pool.token1();\n', '            uint256 total1;\n', '            uint256 total0;\n', '            (total0, total1) = vault(myVault[msg.sender]).getTotalAmounts();\n', '            if(allowedWealthArchitects[token0] == true){\n', '                uint256 amount0 = (((total0 * 1e18) / msg.value) * msg.value) / 1e18;\n', '                IERC20(myWealthArchitect[msg.sender]).transferFrom(msg.sender, address(this), amount0);\n', '                //payable(address(WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2))).call{value: msg.value};\n', '                WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).deposit{value: msg.value};\n', '                balanceOf[address(this)] += amount0;\n', '                vault(myVault[msg.sender]).deposit(amount0, WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this)), amount0 - (amount0 / 100), WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(msg.sender) - (WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(msg.sender) / 100), msg.sender);\n', '            } else if(allowedWealthArchitects[token1] == true){\n', '                uint256 amount1 = (((total1 * 1e18) / msg.value) * msg.value) / 1e18;\n', '                IERC20(myWealthArchitect[msg.sender]).transferFrom(msg.sender, address(this), amount1);\n', '                WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).deposit{value: msg.value};\n', '                balanceOf[address(this)] += amount1;\n', '                vault(myVault[msg.sender]).deposit(WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this)), amount1, WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(address(this)) - (WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).balanceOf(msg.sender) / 100), amount1 - (amount1 / 100), msg.sender);\n', '            \n', '            }\n', '        }\n', '    }\n', '    function withdraw(uint256 shares) public returns(bool success){\n', '        address token0 = pool.token0();\n', '        address token1 = pool.token1();\n', '        uint256 total1;\n', '        uint256 total0;\n', '        (total0, total1) = vault(myVault[msg.sender]).getTotalAmounts();\n', '        if(checkShares(msg.sender, address(myVault[msg.sender])) > shares){\n', '        if(allowedWealthArchitects[token0] == true){\n', '            uint256 amount0 = (((total0 * 1e18) / vault(myVault[msg.sender]).totalSupply()) * shares) / 1e18;\n', '            uint256 amount1 = (((total1 * 1e18) / vault(myVault[msg.sender]).totalSupply()) * shares) / 1e18;\n', '            vault(myVault[msg.sender]).transferFrom(msg.sender, address(this), shares);\n', '            vault(myVault[msg.sender]).withdraw(shares, amount0 + (amount0 / 100), amount1 + (amount1 / 100), msg.sender);\n', '        } else if(allowedWealthArchitects[token1] == true){\n', '            uint256 amount0 = (((total0 * 1e18) / vault(myVault[msg.sender]).totalSupply()) * shares) / 1e18;\n', '            uint256 amount1 = (((total1 * 1e18) / vault(myVault[msg.sender]).totalSupply()) * shares) / 1e18;\n', '            vault(myVault[msg.sender]).transferFrom(msg.sender, address(this), shares);\n', '            vault(myVault[msg.sender]).withdraw(shares, amount1 + (amount1 / 100), amount0 + (amount0 / 100), msg.sender);\n', '        }\n', '        } else {\n', '            success = false;\n', '        }\n', '    }\n', '    function withdrawEther(uint256 amount)\n', '        public\n', '        returns(bool success){\n', '            if(superAdmin[msg.sender] == true){\n', '                (success, ) = msg.sender.call{value: amount}("");\n', '                if (success == true){\n', '                } else {\n', '                    success = false;\n', '                }\n', '            } else {\n', '                success = false;\n', '            }\n', '    }\n', '    function checkShares(address user, address _vault) public view returns(uint256 shares){\n', '        shares = vault(_vault).balanceOf(user);\n', '    }\n', '    receive() external payable{\n', '        deposit();\n', '    }\n', '    function totalSupply() public view returns (uint balance) {\n', '        balance = address(this).balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '    function checkArbitrage(bytes32 _PropertyID, address wealthArchitect) public view returns(uint256 sqrtNxt, uint256 amIn, uint256 amOut, uint256 amFee, uint256 payoff, uint256 amPer, bool arbReady){\n', '        uint32[] memory secondsAgo;\n', '        secondsAgo[0] = 360;\n', '        secondsAgo[1] = 0;\n', '        (int56[] memory wap,) = poolState.observe(secondsAgo);\n', '        int24 thresh;\n', '        int24 _tickSpacing = pool.tickSpacing();         \n', '        if(wap[0] >= wap[1]){\n', '            thresh = int24((wap[0] - wap[1]) / int56(int32(secondsAgo[0])));\n', '            thresh = thresh - (thresh % _tickSpacing);\n', '        } else if(wap[1] >= wap[0]){\n', '            thresh = int24((wap[1] - wap[0]) / int56(int32(secondsAgo[0])));\n', '            thresh = thresh - (thresh % _tickSpacing);\n', '        }\n', '        int160 sqrtPricex96 = int160(TickMath.getSqrtRatioAtTick(thresh));\n', '        ( sqrtNxt, amIn, amOut, amFee) = SwapMath.computeSwapStep(uint160(sqrtPricex96), uint160(sqrtPricex96 - (sqrtPricex96 / 10)), poolState.liquidity(), int(poolState.balance0()), pool.fee());\n', '        address wealthArchitectStacked = wealthArchitect;\n', '        bytes32 _PropertyIDStacked = _PropertyID;\n', '        (,,,,,uint ethTotal ,,,uint ethReceived, uint ethPer,,) = IERC20(wealthArchitectStacked).agetEscrow(_PropertyIDStacked);\n', '        if(ethTotal - ethReceived <= amOut){\n', '            arbReady = true;\n', '            payoff = ethTotal - ethReceived;\n', '            amPer = ethPer;\n', '        }\n', '    }\n', '    function arbitrage(bytes32 _PropertyID, address wealthArchitect) public payable{\n', '        (, uint256 amIn, uint256 amOut, uint256 amFee, uint256 payoff, uint256 amPer, bool arbReady) = checkArbitrage(_PropertyID, wealthArchitect);\n', '        if(arbReady == true){uint32[] memory secondsAgo;\n', '        secondsAgo[0] = 360;\n', '        secondsAgo[1] = 0;\n', '        (int56[] memory wap,) = poolState.observe(secondsAgo);\n', '        int24 thresh;\n', '        int24 _tickSpacing = pool.tickSpacing();         \n', '        if(wap[0] >= wap[1]){\n', '            thresh = int24((wap[0] - wap[1]) / int56(int32(secondsAgo[0])));\n', '            thresh = thresh - (thresh % _tickSpacing);\n', '        } else if(wap[1] >= wap[0]){\n', '            thresh = int24((wap[1] - wap[0]) / int56(int32(secondsAgo[0])));\n', '            thresh = thresh - (thresh % _tickSpacing);\n', '        }\n', '        bytes32 _PropertyIDStacked = _PropertyID;\n', '        int160 sqrtPricex96 = int160(TickMath.getSqrtRatioAtTick(thresh));\n', '        uint256 amOutStacked = amOut;\n', '        if((payoff / amPer) - amFee < amIn){\n', '            balanceOf[address(this)] += payoff;\n', '            bytes memory jic;\n', '            if(allowedWealthArchitects[pool.token0()] == true){\n', '                poolState.swap(address(this), true, int256((amOutStacked - (amOutStacked * 2)) - (amPer / 2)), uint160(sqrtPricex96), jic);\n', '            } else if(allowedWealthArchitects[pool.token1()] == true){\n', '                poolState.swap(address(this), false, int256((amOutStacked - (amOutStacked * 2)) - (amPer / 2)), uint160(sqrtPricex96), jic);\n', '            }\n', '            WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).withdraw(amOutStacked);\n', '            IERC20(wealthArchitect).contributeToEscrowForProperty{value: payoff}(_PropertyIDStacked);\n', '        }}\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(int(-1))) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '    \n', '}']