['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '/*\n', '    WHALES ROOM CLUB\n', '    WHL Staking Contract\n', '    --------------------\n', '    10% buy fee\n', '    10% sell fee \n', '    2% referral fee \n', '    1% transfer fee \n', '*/\n', '\n', 'pragma solidity ^0.4.26;\n', '\n', 'library SafeMath {\n', '\n', ' function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '  if (a == 0) {\n', '   return 0;\n', '  }\n', '  c = a * b;\n', '  assert(c / a == b);\n', '  return c;\n', ' }\n', '\n', ' function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '  return a / b;\n', ' }\n', '\n', ' function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '  assert(b <= a);\n', '  return a - b;\n', ' }\n', '\n', ' function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '  c = a + b;\n', '  assert(c >= a);\n', '  return c;\n', ' }\n', '\n', '}\n', '\n', 'contract TOKEN {\n', ' function totalSupply() external view returns(uint256);\n', ' function balanceOf(address account) external view returns(uint256);\n', ' function transfer(address recipient, uint256 amount) external returns(bool);\n', ' function allowance(address owner, address spender) external view returns(uint256);\n', ' function approve(address spender, uint256 amount) external returns(bool);\n', ' function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n', '}\n', '\n', 'contract Ownable {\n', ' address public owner;\n', ' event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', ' constructor() public {\n', '  owner = msg.sender;\n', ' }\n', ' modifier onlyOwner() {\n', '  require(msg.sender == owner);\n', '  _;\n', ' }\n', ' function transferOwnership(address newOwner) public onlyOwner {\n', '  require(newOwner != address(0));\n', '  emit OwnershipTransferred(owner, newOwner);\n', '  owner = newOwner;\n', ' }\n', '}\n', '\n', 'contract WHLClub is Ownable {\n', '\n', ' mapping(address => bool) internal ambassadors_;\n', ' uint256 constant internal ambassadorMaxPurchase_ = 10000e18; // 10k\n', ' mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', ' bool public onlyAmbassadors = true;\n', ' uint256 ACTIVATION_TIME = 1613696400; // 2/18/2021 @ 20:00 (UTC)\n', '\n', ' modifier antiEarlyWhale(uint256 _amountOfSTAT, address _customerAddress) {\n', '  if (now >= ACTIVATION_TIME) {\n', '   onlyAmbassadors = false;\n', '  }\n', '\n', '  if (onlyAmbassadors) {\n', '   require((ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfSTAT) <= ambassadorMaxPurchase_));\n', '   ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfSTAT);\n', '   _;\n', '  } else {\n', '   onlyAmbassadors = false;\n', '   _;\n', '  }\n', ' }\n', '\n', ' modifier onlyTokenHolders {\n', '  require(myTokens() > 0);\n', '  _;\n', ' }\n', '\n', ' modifier onlyDivis {\n', '  require(myDividends(true) > 0);\n', '  _;\n', ' }\n', '\n', ' event onDistribute(\n', '  address indexed customerAddress,\n', '  uint256 price\n', ' );\n', '\n', ' event onTokenPurchase(\n', '  address indexed customerAddress,\n', '  uint256 incomingSTAT,\n', '  uint256 tokensMinted,\n', '  address indexed referredBy,\n', '  uint timestamp\n', ' );\n', '\n', ' event onTokenSell(\n', '  address indexed customerAddress,\n', '  uint256 tokensBurned,\n', '  uint256 statEarned,\n', '  uint timestamp\n', ' );\n', '\n', ' event onReinvestment(\n', '  address indexed customerAddress,\n', '  uint256 statReinvested,\n', '  uint256 tokensMinted\n', ' );\n', '\n', ' event onWithdraw(\n', '  address indexed customerAddress,\n', '  uint256 statWithdrawn\n', ' );\n', '\n', ' event Transfer(\n', '  address indexed from,\n', '  address indexed to,\n', '  uint256 tokens\n', ' );\n', '\n', ' string public name = "WHL Club";\n', ' string public symbol = "WHLC";\n', ' uint8 constant public decimals = 18;\n', ' uint256 internal entryFee_ = 10; // 10%\n', ' uint256 internal transferFee_ = 1;\n', ' uint256 internal exitFee_ = 10; // 10%\n', ' uint256 internal referralFee_ = 20; // 2% of the 10% fee \n', ' uint256 constant internal magnitude = 2 ** 64;\n', ' mapping(address => uint256) internal tokenBalanceLedger_;\n', ' mapping(address => uint256) internal referralBalance_;\n', ' mapping(address => int256) internal payoutsTo_;\n', ' mapping(address => uint256) internal invested_;\n', ' uint256 internal tokenSupply_;\n', ' uint256 internal profitPerShare_;\n', ' uint256 public stakingRequirement;\n', ' uint256 public totalHolder = 0;\n', ' uint256 public totalDonation = 0;\n', ' TOKEN erc20;\n', '\n', ' constructor() public {\n', '  erc20 = TOKEN(address(0x2aF72850c504dDD3c1876C66a914cAee7Ff8a46A));\n', ' }\n', '\n', ' function checkAndTransferSTAT(uint256 _amount) private {\n', '  require(erc20.transferFrom(msg.sender, address(this), _amount) == true, "transfer must succeed");\n', ' }\n', '\n', ' function distribute(uint256 _amount) public returns(uint256) {\n', '  require(_amount > 0, "must be a positive value");\n', '  checkAndTransferSTAT(_amount);\n', '  totalDonation += _amount;\n', '  profitPerShare_ = SafeMath.add(profitPerShare_, (_amount * magnitude) / tokenSupply_);\n', '  emit onDistribute(msg.sender, _amount);\n', ' }\n', '\n', ' function buy(uint256 _amount, address _referredBy) public returns(uint256) {\n', '  checkAndTransferSTAT(_amount);\n', '  return purchaseTokens(_referredBy, msg.sender, _amount);\n', ' }\n', '\n', ' function buyFor(uint256 _amount, address _customerAddress, address _referredBy) public returns(uint256) {\n', '  checkAndTransferSTAT(_amount);\n', '  return purchaseTokens(_referredBy, _customerAddress, _amount);\n', ' }\n', '\n', ' function() payable public {\n', '  revert();\n', ' }\n', '\n', ' function reinvest() onlyDivis public {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _dividends = myDividends(false);\n', '  payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '  _dividends += referralBalance_[_customerAddress];\n', '  referralBalance_[_customerAddress] = 0;\n', '  uint256 _tokens = purchaseTokens(0x0, _customerAddress, _dividends);\n', '  emit onReinvestment(_customerAddress, _dividends, _tokens);\n', ' }\n', '\n', ' function exit() external {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '  if (_tokens > 0) sell(_tokens);\n', '  withdraw();\n', ' }\n', '\n', ' function withdraw() onlyDivis public {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _dividends = myDividends(false);\n', '  payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '  _dividends += referralBalance_[_customerAddress];\n', '  referralBalance_[_customerAddress] = 0;\n', '  erc20.transfer(_customerAddress, _dividends);\n', '  emit onWithdraw(_customerAddress, _dividends);\n', ' }\n', '\n', ' function sell(uint256 _amountOfTokens) onlyTokenHolders public {\n', '  address _customerAddress = msg.sender;\n', '  require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_amountOfTokens, exitFee_), 100);\n', '  uint256 _taxedSTAT = SafeMath.sub(_amountOfTokens, _dividends);\n', '\n', '  tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '  int256 _updatedPayouts = (int256)(profitPerShare_ * _amountOfTokens + (_taxedSTAT * magnitude));\n', '  payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '  if (tokenSupply_ > 0) {\n', '   profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '  }\n', '\n', '  emit Transfer(_customerAddress, address(0), _amountOfTokens);\n', '  emit onTokenSell(_customerAddress, _amountOfTokens, _taxedSTAT, now);\n', ' }\n', '\n', ' function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders external returns(bool) {\n', '  address _customerAddress = msg.sender;\n', '  require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '  if (myDividends(true) > 0) {\n', '   withdraw();\n', '  }\n', '\n', '  uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '  uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '  uint256 _dividends = _tokenFee;\n', '\n', '  tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '  tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '  payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfTokens);\n', '  payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _taxedTokens);\n', '\n', '  profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '\n', '  emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '  return true;\n', ' }\n', '\n', ' function setName(string _name) onlyOwner public {\n', '  name = _name;\n', ' }\n', '\n', ' function setSymbol(string _symbol) onlyOwner public {\n', '  symbol = _symbol;\n', ' }\n', '\n', ' function totalPowerBalance() public view returns(uint256) {\n', '  return erc20.balanceOf(address(this));\n', ' }\n', '\n', ' function totalSupply() public view returns(uint256) {\n', '  return tokenSupply_;\n', ' }\n', '\n', ' function myTokens() public view returns(uint256) {\n', '  address _customerAddress = msg.sender;\n', '  return balanceOf(_customerAddress);\n', ' }\n', '\n', ' function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n', '  address _customerAddress = msg.sender;\n', '  return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', ' }\n', '\n', ' function balanceOf(address _customerAddress) public view returns(uint256) {\n', '  return tokenBalanceLedger_[_customerAddress];\n', ' }\n', '\n', ' function dividendsOf(address _customerAddress) public view returns(uint256) {\n', '  return (uint256)((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', ' }\n', '\n', ' function sellPrice() public view returns(uint256) {\n', '  uint256 _stat = 1e18;\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_stat, exitFee_), 100);\n', '  uint256 _taxedSTAT = SafeMath.sub(_stat, _dividends);\n', '\n', '  return _taxedSTAT;\n', ' }\n', '\n', ' function buyPrice() public view returns(uint256) {\n', '  uint256 _stat = 1e18;\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_stat, entryFee_), 100);\n', '  uint256 _taxedSTAT = SafeMath.add(_stat, _dividends);\n', '\n', '  return _taxedSTAT;\n', ' }\n', '\n', ' function calculateTokensReceived(uint256 _powerToSpend) public view returns(uint256) {\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_powerToSpend, entryFee_), 100);\n', '  uint256 _amountOfTokens = SafeMath.sub(_powerToSpend, _dividends);\n', '\n', '  return _amountOfTokens;\n', ' }\n', '\n', ' function calculatePowerReceived(uint256 _tokensToSell) public view returns(uint256) {\n', '  require(_tokensToSell <= tokenSupply_);\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_tokensToSell, exitFee_), 100);\n', '  uint256 _taxedSTAT = SafeMath.sub(_tokensToSell, _dividends);\n', '\n', '  return _taxedSTAT;\n', ' }\n', '\n', ' function getInvested() public view returns(uint256) {\n', '  return invested_[msg.sender];\n', ' }\n', '\n', ' function purchaseTokens(address _referredBy, address _customerAddress, uint256 _incomingSTAT) internal antiEarlyWhale(_incomingSTAT, _customerAddress) returns(uint256) {\n', '  if (getInvested() == 0) {\n', '   totalHolder++;\n', '  }\n', '\n', '  invested_[msg.sender] += _incomingSTAT;\n', '\n', '  uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingSTAT, entryFee_), 100);\n', '\n', '  uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\n', '\n', '  uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '  uint256 _amountOfTokens = SafeMath.sub(_incomingSTAT, _undividedDividends);\n', '  uint256 _fee = _dividends * magnitude;\n', '\n', '  require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '  if (_referredBy != address(0) && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement) {\n', '   referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '  } else {\n', '   _dividends = SafeMath.add(_dividends, _referralBonus);\n', '   _fee = _dividends * magnitude;\n', '  }\n', '\n', '  if (tokenSupply_ > 0) {\n', '   tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '   profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n', '   _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n', '  } else {\n', '   tokenSupply_ = _amountOfTokens;\n', '  }\n', '\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '  int256 _updatedPayouts = (int256)(profitPerShare_ * _amountOfTokens - _fee);\n', '  payoutsTo_[_customerAddress] += _updatedPayouts;\n', '\n', '  emit Transfer(address(0), msg.sender, _amountOfTokens);\n', '  emit onTokenPurchase(_customerAddress, _incomingSTAT, _amountOfTokens, _referredBy, now);\n', '\n', '  return _amountOfTokens;\n', ' }\n', '\n', ' function multiData()\n', ' public\n', ' view\n', ' returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '  return (\n', '   totalPowerBalance(),\n', '   totalSupply(),\n', '   balanceOf(msg.sender),\n', '   erc20.balanceOf(msg.sender),\n', '   dividendsOf(msg.sender),\n', '   buyPrice(),\n', '   sellPrice()\n', '\n', '  );\n', ' }\n', '}']