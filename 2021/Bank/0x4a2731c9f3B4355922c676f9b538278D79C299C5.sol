['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../interfaces/BPool.sol";\n', 'import "../interfaces/IPriceOracle.sol";\n', 'import "../misc/BNum.sol";\n', '\n', '/** @title BalancerSharedPoolPriceProvider\n', ' * @notice Price provider for a balancer pool token\n', " * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\n", " * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\n", ' */\n', '\n', 'contract BalancerSharedPoolPriceProvider is BNum {\n', '    BPool public pool;\n', '    address[] public tokens;\n', '    uint256[] public weights;\n', '    bool[] public isPeggedToEth;\n', '    uint8[] public decimals;\n', '    IPriceOracle public priceOracle;\n', '    uint256 public immutable maxPriceDeviation;\n', '    uint256 internal immutable K;\n', '    uint256 internal immutable powerPrecision;\n', '    uint256[][] internal approximationMatrix;\n', '\n', '    /**\n', '     * BalancerSharedPoolPriceProvider constructor.\n', '     * @param _pool Balancer pool address.\n', '     * @param _isPeggedToEth For each token, true if it is pegged to ETH (token order determined by pool.getFinalTokens()).\n', '     * @param _decimals Number of decimals for each token (token order determined by pool.getFinalTokens()).\n', '     * @param _priceOracle Aave price oracle.\n', '     * @param _maxPriceDeviation Threshold of spot prices deviation: 10ˆ16 represents a 1% deviation.\n', '     * @param _K //Constant K = 1 / (w1ˆw1 * .. * wn^wn)\n', '     * @param _powerPrecision //Precision for power math function.\n', '     * @param _approximationMatrix //Approximation matrix for gas optimization.\n', '     */\n', '    constructor(\n', '        BPool _pool,\n', '        bool[] memory _isPeggedToEth,\n', '        uint8[] memory _decimals,\n', '        IPriceOracle _priceOracle,\n', '        uint256 _maxPriceDeviation,\n', '        uint256 _K,\n', '        uint256 _powerPrecision,\n', '        uint256[][] memory _approximationMatrix\n', '    ) public {\n', '        pool = _pool;\n', '        //Get token list\n', '        tokens = pool.getFinalTokens(); //This already checks for pool finalized\n', '        uint256 length = tokens.length;\n', '        //Validate contructor params\n', '        require(length >= 2 && length <= 3, "ERR_INVALID_POOL_TOKENS_NUMBER");\n', '        require(_isPeggedToEth.length == length, "ERR_INVALID_PEGGED_LENGTH");\n', '        require(_decimals.length == length, "ERR_INVALID_DECIMALS_LENGTH");\n', '        for (uint8 i = 0; i < length; i++) {\n', '            require(_decimals[i] <= 18, "ERR_INVALID_DECIMALS");\n', '        }\n', '        require(\n', '            _approximationMatrix.length == 0 ||\n', '                _approximationMatrix[0].length == length + 1,\n', '            "ERR_INVALID_APPROX_MATRIX"\n', '        );\n', '        require(_maxPriceDeviation < BONE, "ERR_INVALID_PRICE_DEVIATION");\n', '        require(\n', '            _powerPrecision >= 1 && _powerPrecision <= BONE,\n', '            "ERR_INVALID_POWER_PRECISION"\n', '        );\n', '        require(\n', '            address(_priceOracle) != address(0),\n', '            "ERR_INVALID_PRICE_PROVIDER"\n', '        );\n', '        //Get token normalized weights\n', '        for (uint8 i = 0; i < length; i++) {\n', '            weights.push(pool.getNormalizedWeight(tokens[i]));\n', '        }\n', '        isPeggedToEth = _isPeggedToEth;\n', '        decimals = _decimals;\n', '        priceOracle = _priceOracle;\n', '        maxPriceDeviation = _maxPriceDeviation;\n', '        K = _K;\n', '        powerPrecision = _powerPrecision;\n', '        approximationMatrix = _approximationMatrix;\n', '    }\n', '\n', '    /**\n', '     * Returns the token balance in ethers by multiplying its balance with its price in ethers.\n', '     * @param index Token index.\n', '     */\n', '    function getEthBalanceByToken(uint256 index)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 pi = isPeggedToEth[index]\n', '            ? BONE\n', '            : uint256(priceOracle.getAssetPrice(tokens[index]));\n', '        require(pi > 0, "ERR_NO_ORACLE_PRICE");\n', '        uint256 missingDecimals = 18 - decimals[index];\n', '        uint256 bi = bmul(\n', '            pool.getBalance(tokens[index]),\n', '            BONE * 10**(missingDecimals)\n', '        );\n', '        return bmul(bi, pi);\n', '    }\n', '\n', '    /**\n', '     * Using the matrix approximation, returns a near base and exponentiation result, for num ^ weights[index]\n', '     * @param index Token index.\n', '     * @param num Base to approximate.\n', '     */\n', '    function getClosestBaseAndExponetation(uint256 index, uint256 num)\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        uint256 length = approximationMatrix.length;\n', '        uint256 k = index + 1;\n', '        for (uint8 i = 0; i < length; i++) {\n', '            if (approximationMatrix[i][0] >= num) {\n', '                return (approximationMatrix[i][0], approximationMatrix[i][k]);\n', '            }\n', '        }\n', '        return (0, 0);\n', '    }\n', '\n', '    /**\n', '     * Returns true if there is a price deviation.\n', '     * @param ethTotals Balance of each token in ethers.\n', '     */\n', '    function hasDeviation(uint256[] memory ethTotals)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        //Check for a price deviation\n', '        uint256 length = tokens.length;\n', '        for (uint8 i = 0; i < length; i++) {\n', '            for (uint8 o = 0; o < length; o++) {\n', '                if (i != o) {\n', '                    uint256 price_deviation = bdiv(\n', '                        bdiv(ethTotals[i], weights[i]),\n', '                        bdiv(ethTotals[o], weights[o])\n', '                    );\n', '                    if (\n', '                        price_deviation > (BONE + maxPriceDeviation) ||\n', '                        price_deviation < (BONE - maxPriceDeviation)\n', '                    ) {\n', '                        return true;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Calculates the price of the pool token using the formula of weighted arithmetic mean.\n', '     * @param ethTotals Balance of each token in ethers.\n', '     */\n', '    function getArithmeticMean(uint256[] memory ethTotals)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 totalEth = 0;\n', '        uint256 length = tokens.length;\n', '        for (uint8 i = 0; i < length; i++) {\n', '            totalEth = badd(totalEth, ethTotals[i]);\n', '        }\n', '        return bdiv(totalEth, pool.totalSupply());\n', '    }\n', '\n', '    /**\n', '     * Returns the weighted token balance in ethers by calculating the balance in ether of the token to the power of its weight.\n', '     * @param index Token index.\n', '     */\n', '    function getWeightedEthBalanceByToken(uint256 index, uint256 ethTotal)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 weight = weights[index];\n', '        (uint256 base, uint256 result) = getClosestBaseAndExponetation(\n', '            index,\n', '            ethTotal\n', '        );\n', '        if (base == 0 || ethTotal < MAX_BPOW_BASE) {\n', '            if (ethTotal < MAX_BPOW_BASE) {\n', '                return bpowApprox(ethTotal, weight, powerPrecision);\n', '            } else {\n', '                return\n', '                    bmul(\n', '                        ethTotal,\n', '                        bpowApprox(\n', '                            bdiv(BONE, ethTotal),\n', '                            (BONE - weight),\n', '                            powerPrecision\n', '                        )\n', '                    );\n', '            }\n', '        } else {\n', '            return\n', '                bmul(\n', '                    result,\n', '                    bpowApprox(bdiv(ethTotal, base), weight, powerPrecision)\n', '                );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculates the price of the pool token using the formula of weighted geometric mean.\n', '     * @param ethTotals Balance of each token in ethers.\n', '     */\n', '    function getWeightedGeometricMean(uint256[] memory ethTotals)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 mult = BONE;\n', '        uint256 length = tokens.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            mult = bmul(mult, getWeightedEthBalanceByToken(i, ethTotals[i]));\n', '        }\n', '        return bdiv(bmul(mult, K), pool.totalSupply());\n', '    }\n', '\n', '    /**\n', "     * Returns the pool's token price.\n", "     * It calculates the price using Chainlink as an external price source and the pool's tokens balances using the weighted arithmetic mean formula.\n", "     * If there is a price deviation, instead of the balances, it uses a weighted geometric mean with the token's weights and constant value function V.\n", '     */\n', '    function latestAnswer() external view returns (uint256) {\n', '        //Get token balances in ethers\n', '        uint256[] memory ethTotals = new uint256[](tokens.length);\n', '        uint256 length = tokens.length;\n', '        for (uint256 i = 0; i < length; i++) {\n', '            ethTotals[i] = getEthBalanceByToken(i);\n', '        }\n', '\n', '        if (hasDeviation(ethTotals)) {\n', '            //Calculate the weighted geometric mean\n', '            return getWeightedGeometricMean(ethTotals);\n', '        } else {\n', '            //Calculate the weighted arithmetic mean\n', '            return getArithmeticMean(ethTotals);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns Balancer pool address.\n', '     */\n', '    function getPool() external view returns (BPool) {\n', '        return pool;\n', '    }\n', '\n', '    /**\n', '     * Returns all tokens.\n', '     */\n', '    function getTokens() external view returns (address[] memory) {\n', '        return tokens;\n', '    }\n', '\n', '    /**\n', "     * Returns all tokens's weights.\n", '     */\n', '    function getWeights() external view returns (uint256[] memory) {\n', '        return weights;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface BPool {\n', '\n', '    function getFinalTokens() external view returns (address[] memory tokens);\n', '    function getNormalizedWeight(address token) external view returns (uint);\n', '    function getBalance(address token) external view returns (uint);\n', '    function totalSupply() external view returns (uint);\n', ' \n', '}\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', '/************\n', '@title IPriceOracle interface\n', '@notice Interface for the Aave price oracle.*/\n', 'interface IPriceOracle {\n', '    /***********\n', '    @dev returns the asset price in ETH\n', '     */\n', '    function getAssetPrice(address _asset) external view returns (uint256);\n', '\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./BConst.sol";\n', '\n', 'contract BNum is BConst {\n', '\n', '    function btoi(uint a)\n', '        internal pure \n', '        returns (uint)\n', '    {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint a)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '        internal pure\n', '        returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint a, uint n)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint z = n % 2 != 0 ? a : BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint base, uint exp)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint whole  = bfloor(exp);   \n', '        uint remain = bsub(exp, whole);\n', '\n', '        uint wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(uint base, uint exp, uint precision)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        // term 0:\n', '        uint a     = exp;\n', '        (uint x, bool xneg)  = bsubSign(base, BONE);\n', '        uint term = BONE;\n', '        uint sum   = term;\n', '        bool negative = false;\n', '\n', '\n', '        // term(k) = numer / denom \n', '        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint i = 1; term >= precision; i++) {\n', '            uint bigK = i * BONE;\n', '            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '\n', '}\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// From // From https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract BConst {\n', '    uint public constant BONE              = 10**18;\n', '\n', '    uint public constant MIN_BOUND_TOKENS  = 2;\n', '    uint public constant MAX_BOUND_TOKENS  = 8;\n', '\n', '    uint public constant MIN_FEE           = BONE / 10**6;\n', '    uint public constant MAX_FEE           = BONE / 10;\n', '    uint public constant EXIT_FEE          = 0;\n', '\n', '    uint public constant MIN_WEIGHT        = BONE;\n', '    uint public constant MAX_WEIGHT        = BONE * 50;\n', '    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\n', '    uint public constant MIN_BALANCE       = BONE / 10**12;\n', '\n', '    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\n', '\n', '    uint public constant MIN_BPOW_BASE     = 1 wei;\n', '    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\n', '    uint public constant BPOW_PRECISION    = BONE / 10**10;\n', '\n', '    uint public constant MAX_IN_RATIO      = BONE / 2;\n', '    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\n', '}']