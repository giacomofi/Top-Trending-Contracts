['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-22\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-14\n', '*/\n', '\n', '// File contracts/swappers/SushiSwapMultiSwapper.sol\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// solhint-disable avoid-low-level-calls\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'interface IERC20 {\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', 'library BoringERC20 {\n', '    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n', '\n', '    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '}\n', '\n', '// File @sushiswap/core/contracts/uniswapv2/interfaces/[email\xa0protected]\n', '// License-Identifier: GPL-3.0\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '}\n', '\n', '// File contracts/libraries/UniswapV2Library.sol\n', '// License-Identifier: GPL-3.0\n', '\n', 'library UniswapV2Library {\n', '    using BoringMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', '                pairCodeHash // init code hash\n', '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB, bytes32 pairCodeHash) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, pairCodeHash)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path, bytes32 pairCodeHash) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], pairCodeHash);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '// File @sushiswap/bentobox-sdk/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', 'interface IBentoBoxV1 {\n', '    function deposit(IERC20 token_, address from, address to, uint256 amount, uint256 share) external payable returns (uint256 amountOut, uint256 shareOut);\n', '    function toAmount(IERC20 token, uint256 share, bool roundUp) external view returns (uint256 amount);\n', '    function withdraw(IERC20 token_, address from, address to, uint256 amount, uint256 share) external returns (uint256 amountOut, uint256 shareOut);\n', '}\n', '\n', '// File contracts/swappers/SushiSwapMultiSwapper.sol\n', '// License-Identifier: GPL-3.0\n', '\n', 'contract SushiSwapMultiSwapper {\n', '    using BoringERC20 for IERC20;\n', '    using BoringMath for uint256;\n', '\n', '    address private immutable factory;\n', '    IBentoBoxV1 private immutable bentoBox;\n', '    bytes32 private immutable pairCodeHash;\n', '\n', '    constructor (address _factory, IBentoBoxV1 _bentoBox, bytes32 _pairCodeHash) public {\n', '        factory = _factory;\n', '        bentoBox = _bentoBox;\n', '        pairCodeHash = _pairCodeHash;\n', '    }\n', '\n', '    function getOutputAmount (IERC20 tokenIn, address[] calldata path, uint256 shareIn) external view returns (uint256 amountOut){\n', '        uint256 amountIn = bentoBox.toAmount(tokenIn, shareIn, false);\n', '        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n', '        amountOut = amounts[amounts.length - 1];\n', '    }\n', '\n', '    function swap (IERC20 tokenIn, IERC20 tokenOut, uint256 amountMinOut, address path1, address path2, address to, uint256 baseShare, uint256 shareIn) external returns (uint256) {\n', '        address[] memory path;\n', '        if (path2 == address(0)) {\n', '            if (path1 == address(0)) {\n', '                path = new address[](2);\n', '                path[1] = address(tokenOut);\n', '            } else {\n', '                path = new address[](3);\n', '                path[1] = path1;\n', '                path[2] = address(tokenOut);\n', '            }\n', '        } else {\n', '            path = new address[](4);\n', '            path[1] = path1;\n', '            path[2] = path2;\n', '            path[3] = address(tokenOut);\n', '        }\n', '        path[0] = address(tokenIn);\n', '        (uint256 amountIn, ) = bentoBox.withdraw(tokenIn, address(this), address(this), 0, shareIn);\n', '        uint256 amount = _swapExactTokensForTokens(amountIn, amountMinOut, path, address(bentoBox));\n', '        (, uint256 share) = bentoBox.deposit(tokenOut, address(bentoBox), to, amount, 0);\n', '        return baseShare.add(share);\n', '    }\n', '\n', '    // Swaps an exact amount of tokens for another token through the path passed as an argument\n', '    // Returns the amount of the final token\n', '    function _swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] memory path,\n', '        address to\n', '    ) internal returns (uint256 amountOut) {\n', '        uint256[] memory amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path, pairCodeHash);\n', '        amountOut = amounts[amounts.length - 1];\n', '        require(amountOut >= amountOutMin, "insufficient-amount-out");\n', '        IERC20(path[0]).safeTransfer(UniswapV2Library.pairFor(factory, path[0], path[1], pairCodeHash), amountIn);\n', '        _swap(amounts, path, to);\n', '    }\n', '\n', '    // requires the initial amount to have already been sent to the first pair\n', '    function _swap(\n', '        uint256[] memory amounts,\n', '        address[] memory path,\n', '        address _to\n', '    ) internal virtual {\n', '        for (uint256 i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0, ) = UniswapV2Library.sortTokens(input, output);\n', '            uint256 amountOut = amounts[i + 1];\n', '            (uint256 amount0Out, uint256 amount1Out) = input == token0\n', '                ? (uint256(0), amountOut)\n', '                : (amountOut, uint256(0));\n', '            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2], pairCodeHash) : _to;\n', '            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output, pairCodeHash)).swap(\n', '                amount0Out,\n', '                amount1Out,\n', '                to,\n', '                new bytes(0)\n', '            );\n', '        }\n', '    }\n', '}']