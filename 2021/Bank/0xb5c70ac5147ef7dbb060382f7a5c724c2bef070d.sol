['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    /**\n', '        * @dev Returns the amount of tokens owned by `account`.\n', '        */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '        *\n', '        * Returns a boolean value indicating whether the operation succeeded.\n', '        *\n', '        * Emits a {Transfer} event.\n', '        */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface Uni {\n', '    function swapExactTokensForTokens(\n', '        uint256,\n', '        uint256,\n', '        address[] calldata,\n', '        address,\n', '        uint256\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint amountOut, \n', '        uint amountInMax, \n', '        address[] calldata path, \n', '        address to, \n', '        uint deadline)\n', '    external\n', '    returns (uint[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint amountOutMin, \n', '        address[] calldata path, \n', '        address to, \n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '}\n', '\n', 'library UniswapV2Exchange {\n', '    address public constant DEX = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    function swapExactERC20ForERC20(\n', '        address _from,\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _fromAmount\n', '    ) external returns (uint256[] memory amounts) {\n', '        if(_fromAmount == 0) { return amounts; }\n', '        // approve tokens to the DEX \n', '        IERC20(_from).approve(DEX, _fromAmount);\n', '\n', '        address[] memory _path = new address[](3);\n', '        _path[0] = _from;\n', '        _path[1] = WETH;\n', '        _path[2] = _to;\n', '\n', '        return\n', '            Uni(DEX).swapExactTokensForTokens(\n', '                _fromAmount,\n', '                uint256(0),\n', '                _path,\n', '                _recipient,\n', '                block.timestamp + 1800\n', '            );\n', '    }\n', '\n', '    function swapERC20ForExactERC20(\n', '        address _from,\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts) {\n', '        uint256 _bal = IERC20(_from).balanceOf(address(this));\n', '        if(_bal == 0) { return amounts; }\n', '        // approve tokens to the DEX\n', '        IERC20(_from).approve(DEX, _bal);\n', '\n', '        address[] memory _path = new address[](3);\n', '        _path[0] = _from;\n', '        _path[1] = WETH;\n', '        _path[2] = _to;\n', '\n', '        return\n', '            Uni(DEX).swapTokensForExactTokens(\n', '                _amountOut,\n', '                _bal,\n', '                _path,\n', '                _recipient,\n', '                block.timestamp + 1800\n', '            );\n', '    }\n', '\n', '    function swapERC20ForExactETH(\n', '        address _from,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts) {\n', '        uint256 _bal = IERC20(_from).balanceOf(address(this));\n', '        if(_bal == 0) { return amounts; }\n', '        // approve tokens to the DEX\n', '        IERC20(_from).approve(DEX, _bal);\n', '\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = _from;\n', '        _path[1] = WETH;\n', '\n', '        return\n', '            Uni(DEX).swapTokensForExactETH(\n', '                _amountOut,\n', '                _bal,\n', '                _path,\n', '                _recipient,\n', '                block.timestamp + 1800\n', '            );\n', '    }\n', '\n', '    function swapExactERC20ForETH(\n', '        address _from,\n', '        address _recipient,\n', '        uint256 _amountIn\n', '    ) external returns (uint256[] memory amounts) {\n', '        if(_amountIn == 0) { return amounts; }\n', '        // approve tokens to the DEX\n', '        IERC20(_from).approve(DEX, _amountIn);\n', '\n', '        address[] memory _path = new address[](2);\n', '        _path[0] = _from;\n', '        _path[1] = WETH;\n', '\n', '        return\n', '            Uni(DEX).swapExactTokensForETH(\n', '                _amountIn,\n', '                0,\n', '                _path,\n', '                _recipient,\n', '                block.timestamp + 1800\n', '            );\n', '    }\n', '\n', '    function swapETHForExactERC20(\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts) {\n', '        if(address(this).balance == 0) { return amounts; }\n', '        \n', '        address[] memory _path = new address[](2);\n', '        _path[0] = WETH;\n', '        _path[1] = _to;\n', '\n', '        bytes memory _data = abi.encodeWithSelector(Uni(DEX).swapETHForExactTokens.selector, _amountOut, _path, _recipient, block.timestamp + 1800);\n', '\n', '        (bool success, bytes memory _amounts) = DEX.call{value:address(this).balance}(_data);\n', '        require(success, "swapETHForExactERC20: uniswap swap failed.");\n', '\n', '        (amounts) = abi.decode(\n', '            _amounts,\n', '            (uint256[])\n', '        );\n', '    }\n', '\n', '    function swapExactETHForERC20(\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOutMin\n', '    ) external returns (uint256[] memory amounts) {\n', '        if(address(this).balance == 0) { return amounts; }\n', '        \n', '        address[] memory _path = new address[](2);\n', '        _path[0] = WETH;\n', '        _path[1] = _to;\n', '\n', '        bytes memory _data = abi.encodeWithSelector(Uni(DEX).swapExactETHForTokens.selector, _amountOutMin, _path, _recipient, block.timestamp + 1800);\n', '\n', '        (bool success, bytes memory _amounts) = DEX.call{value:address(this).balance}(_data);\n', '        require(success, "swapExactETHForERC20: uniswap swap failed.");\n', '\n', '        (amounts) = abi.decode(\n', '            _amounts,\n', '            (uint256[])\n', '        );\n', '    }\n', '}']