['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', "import './IERC20.sol';\n", "import './ERC721.sol';\n", "import './Ownable.sol';\n", '\n', 'interface ERC20Interface is IERC20 {\n', '    function deposit() external payable;\n', '}\n', '\n', 'interface IApymonPack {\n', '    function increaseInsideTokenBalance(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address token,\n', '        uint256 amount\n', '    ) external;\n', '}\n', '\n', 'contract Apymon is ERC721, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public APYMON_PROVENANCE = "";\n', '\n', '    // Maximum amount of Eggs in existance. Ever.\n', '    uint256 public constant MAX_EGG_SUPPLY = 6400;\n', '    uint256 public constant MAX_APYMON_SUPPLY = 12800;\n', '    uint256 public CREATURE_SUPPLY;\n', '    \n', '    // Referral management\n', '    mapping(address => uint256) public _referralAmounts;\n', '    mapping(address => mapping(address => bool)) public _referralStatus;\n', '\n', '    IApymonPack public _apymonpack;\n', '\n', '    ERC20Interface private constant _weth = ERC20Interface(\n', '        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 // mainnet\n', '    );\n', '\n', '    address payable private constant _team = payable(\n', '        0x262655a65538C71454Cb60951BF1a79E19668218\n', '    );\n', '    address payable private constant _treasury = payable(\n', '        0xeD2D1254e79835bF5911Aa8946e23bf508477Da4\n', '    );\n', '    bool public hasSaleStarted = false;\n', '\n', '    constructor(\n', '        string memory baseURI\n', '    ) ERC721("Apymon", "APYMON") {\n', '        _setBaseURI(baseURI);\n', '    }\n', '\n', '    function exists(uint256 tokenId) public view returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner) external view returns(uint256[] memory) {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            for (uint256 index; index < tokenCount; index++) {\n', '                result[index] = tokenOfOwnerByIndex(_owner, index);\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Gets egg count to mint per once.\n', '    */\n', '    function getMintableCount() public view returns (uint256) {\n', '        uint256 eggSupply = totalSupply() - CREATURE_SUPPLY;\n', '\n', '        if (eggSupply >= MAX_EGG_SUPPLY) {\n', '            return 0;\n', '        } else if (eggSupply > 6395) { // 6396 ~ 6400\n', '            return 1;\n', '        } else if (eggSupply > 6000) { // 6001 ~ 6395\n', '            return 5;\n', '        } else {\n', '            return 20; // 1 ~ 6000\n', '        }\n', '    }\n', '\n', '    function getEggPrice() public view returns (uint256) {\n', '        uint256 eggSupply = totalSupply() - CREATURE_SUPPLY;\n', '\n', '        if (eggSupply >= MAX_EGG_SUPPLY) {\n', '            return 0;\n', '        } else if (eggSupply > 6395) { // 6396 ~ 6400\n', '            return 2 ether;\n', '        } else if (eggSupply > 6365) { // 6366 ~ 6395\n', '            return 1 ether;\n', '        } else if (eggSupply > 6300) { // 6301 ~ 6365\n', '            return 0.64 ether;\n', '        } else if (eggSupply > 6000) { // 6001 ~ 6300\n', '            return 0.32 ether;\n', '        } else if (eggSupply > 4000) { // 4001 ~ 6000\n', '            return 0.16 ether;\n', '        } else if (eggSupply > 500) { // 501 ~ 4000\n', '            return 0.08 ether;\n', '        } else {\n', '            return 0.04 ether; // 1 ~ 500\n', '        }\n', '    }\n', '\n', '    function getRandomNumber(uint256 a, uint256 b) public view returns (uint256) {\n', '        uint256 min = a;\n', '        uint256 max = (b.add(1)).sub(min);\n', '        return (uint256(uint256(keccak256(abi.encodePacked(blockhash(block.number))))%max)).add(min);\n', '    }\n', '\n', '    function distributeRandomBonus(\n', '        uint8 tier\n', '    ) external onlyOwner {\n', '        require(\n', '            !hasSaleStarted,\n', '            "Sale hasn\'t finised yet."\n', '        );\n', '\n', '        uint256 randomId;\n', '\n', '        if (tier == 1) {\n', '            randomId = getRandomNumber(0, 499);\n', '        } else if (tier == 2) {\n', '            randomId = getRandomNumber(500, 3999);\n', '        } else if (tier == 3) {\n', '            randomId = getRandomNumber(4000, 5999);\n', '        } else if (tier == 4) {\n', '            randomId = getRandomNumber(6000, 6299);\n', '        } else if (tier == 5) {\n', '            randomId = getRandomNumber(6300, 6364);\n', '        } else if (tier == 6) {\n', '            randomId = getRandomNumber(6365, 6394);\n', '        } else if (tier == 7) {\n', '            randomId = getRandomNumber(6395, 6399);\n', '        } else {\n', '            return;\n', '        }\n', '\n', '        uint256 bonus = getRandomNumber(0, 1E18);\n', '        \n', '        if (bonus > 0) {\n', '            _apymonpack.increaseInsideTokenBalance(\n', '                randomId,\n', '                1, // TOKEN_TYPE_ERC20\n', '                address(_weth),\n', '                bonus\n', '            );\n', '\n', '            _weth.deposit{ value: bonus }();\n', '            _weth.transfer(address(_apymonpack), bonus);\n', '        }\n', '    }\n', '\n', '    function distributeReferral(\n', '        uint256 startEggId,\n', '        uint256 endEggId\n', '    ) external onlyOwner {\n', '        require(\n', '            !hasSaleStarted,\n', '            "Sale hasn\'t finised yet."\n', '        );\n', '        uint256 totalReferralAmount;\n', '\n', '        for (uint256 i = startEggId; i <= endEggId; i++) {\n', '            address owner = ownerOf(i);\n', '            uint256 referralAmount = _referralAmounts[owner];\n', '            if (referralAmount > 0) {\n', '                _apymonpack.increaseInsideTokenBalance(\n', '                    i,\n', '                    1, // TOKEN_TYPE_ERC20\n', '                    address(_weth),\n', '                    referralAmount\n', '                );\n', '                totalReferralAmount = totalReferralAmount.add(referralAmount);\n', '                delete _referralAmounts[owner];\n', '            }\n', '        }\n', '\n', '        if (totalReferralAmount > 0) {\n', '            _weth.deposit{ value: totalReferralAmount }();\n', '            _weth.transfer(address(_apymonpack), totalReferralAmount);\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev Changes the base URI if we want to move things in the future (Callable by owner only)\n', '    */\n', '    function setBaseURI(string memory baseURI) onlyOwner external {\n', '       _setBaseURI(baseURI);\n', '    }\n', '\n', '    /**\n', '    * @dev Set apymon pack address\n', '    */\n', '    function setApymonPack(address apymonpack) onlyOwner external {\n', '       _apymonpack = IApymonPack(apymonpack);\n', '    }\n', '\n', '    function setProvenance(string memory _provenance) onlyOwner external {\n', '        APYMON_PROVENANCE = _provenance;\n', '    }\n', '\n', '    /**\n', '     * @dev Mints yourself Eggs.\n', '     */\n', '    function mintEggs(\n', '        address to,\n', '        uint256 count,\n', '        address referee\n', '    ) public payable {\n', '        uint256 eggSupply = totalSupply() - CREATURE_SUPPLY;\n', '        require(\n', '            hasSaleStarted,\n', '            "Sale hasn\'t started."\n', '        );\n', '        require(\n', '            count > 0 && count <= getMintableCount()\n', '        );\n', '        require(\n', '            SafeMath.add(eggSupply, count) <= MAX_EGG_SUPPLY\n', '        );\n', '        require(\n', '            SafeMath.mul(getEggPrice(), count) == msg.value\n', '        );\n', '\n', '        for (uint256 i; i < count; i++) {\n', '            uint256 mintIndex = totalSupply() - CREATURE_SUPPLY;\n', '            _safeMint(to, mintIndex);\n', '        }\n', '\n', '        if (referee != address(0) && referee != to) {\n', '            _addReferralAmount(referee, to, msg.value);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Mints creature to apymonpacks.\n', '     * Creatures must be distributed to owners of egg.\n', '     */\n', '    function mintCreature() external returns (uint256 creatureId) {\n', '        require(msg.sender == address(_apymonpack));\n', '        require(\n', '            !hasSaleStarted,\n', '            "Sale hasn\'t finised yet."\n', '        );\n', '        creatureId = MAX_EGG_SUPPLY + CREATURE_SUPPLY;\n', '        require(!_exists(creatureId));\n', '        _safeMint(address(_apymonpack), creatureId);\n', '        CREATURE_SUPPLY++;\n', '    }\n', '\n', '    /**\n', '     * @dev send eth to team and treasury.\n', '     */\n', '    function requestFund(\n', '        uint256 amount\n', '    ) external onlyOwner {\n', '        uint256 teamFund = amount.div(2);\n', '        _team.transfer(teamFund);\n', '        _treasury.transfer(amount.sub(teamFund));\n', '    }\n', '\n', '    function startSale() public onlyOwner {\n', '        hasSaleStarted = true;\n', '    }\n', '\n', '    function pauseSale() public onlyOwner {\n', '        hasSaleStarted = false;\n', '    }\n', '\n', '    /**\n', '     * @dev private function to record referral status.\n', '     */\n', '    function _addReferralAmount(\n', '        address referee,\n', '        address referrer,\n', '        uint256 amount\n', '    ) private {\n', '        uint256 refereeBalance = ERC721.balanceOf(referee);\n', '        bool status = _referralStatus[referrer][referee];\n', '        uint256 referralAmount = amount.div(10);\n', '\n', '        if (refereeBalance != 0 && !status) {\n', '            _referralAmounts[referee] = _referralAmounts[referee].add(referralAmount);\n', '            _referralAmounts[referrer] = _referralAmounts[referrer].add(referralAmount);\n', '            _referralStatus[referrer][referee] = true;\n', '        }\n', '    }\n', '}']