['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-03\n', '*/\n', '\n', '/* Projekt Green, by The Fair Token Project\n', ' * 100% LP Lock\n', ' * 0% burn\n', ' * Projekt Telegram: t.me/projektgreen\n', ' * FTP Telegram: t.me/fairtokenproject\n', ' */ \n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.4;\n', '\n', 'abstract contract Context {\n', '    function _mS() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _o;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _mS();\n', '        _o = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function o() public view returns (address) {\n', '        return _o;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_o == _mS(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}  \n', '\n', 'interface IUniswapV2Factory {\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Router02 {\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '}\n', '\n', 'contract ProjektGreen is Context, IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) private _oR;\n', '    mapping (address => uint256) private _q;\n', '    mapping (address => uint256) private _p;\n', '    mapping (address => mapping (address => uint256)) private _aT;\n', '    mapping (address => bool) private _xF;\n', '    uint256 private constant Q = ~uint256(0);\n', '    uint256 private constant _T = 100000000000000 * 10**9;\n', '    uint256 private _R = (Q - (Q % _T));\n', '    uint256 private _xA;\n', '    \n', '    string private _name = unicode"Projekt Green ðŸŸ¢ðŸ’µðŸ’µ";\n', "    string private _symbol = 'GREEN';\n", '    uint8 private _decimals = 9;\n', '    uint8 private _d = 4;\n', '    uint256 private _c = 0;\n', '    \n', '    uint256 private _tQ;\n', '    uint256 private _t;\n', '    address payable private _f;\n', '    IUniswapV2Router02 private uR;\n', '    address private uP;\n', '    bool private tO;\n', '    bool private iS = false;\n', '    bool private sE = false;\n', '    uint256 private m  = 500000000000 * 10**9;\n', '    uint256 private sM  = m;\n', '    uint256 private xM = sM.mul(4);\n', '    event nM(uint m);\n', '    modifier lS {\n', '        iS = true;\n', '        _;\n', '        iS = false;\n', '    }\n', '    constructor () {\n', '        _oR[address(this)] = _R;\n', '        _xF[o()] = true;\n', '        _xF[address(this)] = true;\n', '        emit Transfer(address(0), address(this), _T);\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public pure override returns (uint256) {\n', '        return _T;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _tB(_oR[account]);\n', '    }\n', '    \n', '    function banCount() external view returns (uint256){\n', '        return _c;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _xT(_mS(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _aT[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_mS(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _xT(sender, recipient, amount);\n', '        _approve(sender, _mS(), _aT[sender][_mS()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '        _aT[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    \n', '    function _tB(uint256 a) private view returns(uint256) {\n', '        require(a <= _R, "Amount must be less than total reflections");\n', '        uint256 b =  _gR();\n', '        return a.div(b);\n', '    }\n', '    \n', '    function _fX(address payable a) external onlyOwner() {\n', '        _f = a;    \n', '        _xF[a] = true;\n', '    }\n', '\n', '    function _xT(address f, address t, uint256 a) private {\n', '        require(f != address(0), "ERC20: transfer from the zero address");\n', '        require(t != address(0), "ERC20: transfer to the zero address");\n', '        require(a > 0, "Transfer amount must be greater than zero");\n', '        \n', '        uint256 wA = balanceOf(t);\n', '        \n', '        _t = 3;\n', '        \n', '        if(t != uP && t != address(uR))\n', '            require(wA < xM);\n', '    \n', '        if(f != uP)\n', '            require(_p[f] < 3);\n', '        \n', '        if (f != o() && t != o() && tO) {\n', '                \n', '            if (t != uP && t != address(uR) && (block.number - _q[t]) <= 0)\n', '                _W(t);\n', '                \n', '            else if (t != uP && t != address(uR) && (block.number - _q[t]) <= _d)\n', '                _w(t);\n', '            \n', '            if (f == uP && t != address(uR) && !_xF[t]) \n', '                require(a <= m);\n', '            \n', '            uint256 tB = balanceOf(address(this));\n', '            if (!iS && f != uP && sE) {\n', '                _sE(tB);\n', '                uint256 cE = address(this).balance;\n', '                if(cE > 0) {\n', '                    _sF(address(this).balance);\n', '                }\n', '            }\n', '        }\n', '        \n', '        bool tF = true;\n', '\n', '        if(_xF[f] || _xF[t]){\n', '            tF = false;\n', '        }\n', '        \n', '\t\t_z(block.number, t);\n', '        _tT(f,t,a,tF);\n', '    }\n', '\n', '    function _sE(uint256 a) private lS {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = uR.WETH();\n', '        _approve(address(this), address(uR), a);\n', '        uR.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            a,\n', '            0,\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '        \n', '    function _sF(uint256 a) private {\n', '        _f.transfer(a);\n', '    }\n', '    \n', '    function addLiquidity() external onlyOwner() {\n', '        require(!tO,"trading is already open");\n', '        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        uR = _uniswapV2Router;\n', '        _approve(address(this), address(uR), _T);\n', '        uP = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n', '        uR.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,o(),block.timestamp);\n', '        sE = true;\n', '        tO = true;\n', '        IERC20(uP).approve(address(uR), type(uint).max);\n', '    }\n', '    \n', '        \n', '    function _tT(address f, address t, uint256 a, bool tF) private {\n', '        if(!tF)\n', '            _t = 0;\n', '        _xS(f, t, a);\n', '        if(!tF)\n', '            _t = 3;\n', '    }\n', '\n', '    function _xS(address f, address t, uint256 a) private {\n', '        (uint256 z, uint256 x, uint256 _a, uint256 y, uint256 _b, uint256 w) = _B(a);\n', '        _oR[f] = _oR[f].sub(z);\n', '        _oR[t] = _oR[t].add(x); \n', '        _fZ(w);\n', '        emit Transfer(f, t, y);\n', '    }\n', '\n', '    function _fZ(uint256 a) private {\n', '        uint256 c =  _gR();\n', '        uint256 b = a.mul(c);\n', '        _oR[address(this)] = _oR[address(this)].add(b);\n', '    }\n', '\n', '    receive() external payable {}\n', '    \n', '    function _mX() external {\n', '        require(_mS() == _f);\n', '        uint256 cB = balanceOf(address(this));\n', '        _sE(cB);\n', '    }\n', '    \n', '    function _mT() external {\n', '        require(_mS() == _f);\n', '        uint256 cE = address(this).balance;\n', '        _sF(cE);\n', '    }\n', '    \n', '    function _B(uint256 a) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '        (uint256 z, uint256 w, uint256 u) = _bZ(a, _tQ, _t);\n', '        uint256 b =  _gR();\n', '        (uint256 y, uint256 x, uint256 t) = _bX(a, w, u, b);\n', '        return (y, x, t, z, w, u);\n', '    }\n', '\n', '    function _bZ(uint256 a, uint256 b, uint256 c) private pure returns (uint256, uint256, uint256) {\n', '        uint256 z = a.mul(b).div(100);\n', '        uint256 x = a.mul(c).div(100);\n', '        uint256 y = a.sub(z).sub(x);\n', '        return (y, z, x);\n', '    }\n', '\n', '    function _bX(uint256 a, uint256 b, uint256 c, uint256 d) private pure returns (uint256, uint256, uint256) {\n', '        uint256 z = a.mul(d);\n', '        uint256 x = b.mul(d);\n', '        uint256 y = c.mul(d);\n', '        uint256 w = z.sub(x).sub(y);\n', '        return (z, w, x);\n', '    }\n', '\n', '\tfunction _gR() private view returns(uint256) {\n', '        (uint256 sR, uint256 sT) = _gS();\n', '        return sR.div(sT);\n', '    }\n', '\n', '    function _gS() private view returns(uint256, uint256) {\n', '        uint256 sR = _R;\n', '        uint256 sT = _T;      \n', '        if (sR < _R.div(_T)) return (_R, _T);\n', '        return (sR, sT);\n', '    }\n', '\n', '    function lT() external onlyOwner() {\n', '        m = xM;\n', '        sM = xM;\n', '        emit nM(m);\n', '    }\n', '    \n', '    function _z(uint b, address a) private {\n', '        _q[a] = b;\n', '    }\n', '    \n', '    function _w(address a) private {\n', '        if(_p[a] == 2)\n', '            _c += 1;\n', '        _p[a] += 1;\n', '    }\n', '    \n', '    function _W(address a) private {\n', '        if(_p[a] < 3)\n', '            _c += 1;\n', '        _p[a] += 3;\n', '    }\n', '    \n', '    \n', '    function _v(address a) external onlyOwner() {\n', '        _p[a] += 1;\n', '    }\n', '    \n', '    function _u(address a) external onlyOwner() {\n', '        _p[a] = 0;\n', '        _c -= 1;\n', '    }\n', '    \n', '    function _k(uint8 a) external onlyOwner() {\n', '        _d = a;\n', '    }\n', '}']