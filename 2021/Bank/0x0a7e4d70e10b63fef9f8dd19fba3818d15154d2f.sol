['pragma solidity ^0.8.0;\n', '\n', "import './Address.sol';\n", "import './IUniswapV2Factory.sol';\n", "import './IUniswapV2Pair.sol';\n", "import './IUniswapV2Router02.sol';\n", "import './ERC20.sol';\n", '\n', '/**\n', ' * @notice ERC20 token with cost basis tracking and restricted loss-taking\n', ' */\n', 'contract BUFFDOGE is ERC20 {\n', '  using Address for address payable;\n', '\n', "  string public override name = 'BUFFDOGE (buffdoge.online)';\n", "  string public override symbol = 'BUFFDOGE';\n", '\n', '  address private constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '  uint private constant SUPPLY = 1e9 ether;\n', '\n', '  address private _owner;\n', '\n', '  address private _pair;\n', '\n', '  uint private _openedAt;\n', '  uint private _closedAt;\n', '\n', '  mapping (address => uint) private _basisOf;\n', '  mapping (address => uint) public cooldownOf;\n', '\n', '  uint private _initialBasis;\n', '\n', '  uint private _ath;\n', '  uint private _athTimestamp;\n', '\n', '  struct Minting {\n', '    address recipient;\n', '    uint amount;\n', '  }\n', '\n', '  /**\n', '   * @notice deploy\n', '   */\n', '  constructor () payable {\n', '    _owner = msg.sender;\n', '\n', '    // setup uniswap pair and store address\n', '\n', '    _pair = IUniswapV2Factory(\n', '      IUniswapV2Router02(UNISWAP_ROUTER).factory()\n', '    ).createPair(WETH, address(this));\n', '\n', '    // prepare to add liquidity\n', '\n', '    _approve(address(this), UNISWAP_ROUTER, SUPPLY);\n', '\n', '    // prepare to remove liquidity\n', '\n', '    IERC20(_pair).approve(UNISWAP_ROUTER, type(uint).max);\n', '  }\n', '\n', '  receive () external payable {}\n', '\n', '  /**\n', '   * @notice get cost basis for given address\n', '   * @param account address to query\n', '   * @return cost basis\n', '   */\n', '  function basisOf (\n', '    address account\n', '  ) public view returns (uint) {\n', '    uint basis = _basisOf[account];\n', '\n', '    if (basis == 0 && balanceOf(account) > 0) {\n', '      basis = _initialBasis;\n', '    }\n', '\n', '    return basis;\n', '  }\n', '\n', '  /**\n', '   * @notice mint team tokens prior to opening of trade\n', '   * @param mintings structured minting data (recipient, amount)\n', '   */\n', '  function mint (\n', '    Minting[] calldata mintings\n', '  ) external {\n', "    require(msg.sender == _owner, 'ERR: sender must be owner');\n", "    require(_openedAt == 0, 'ERR: already opened');\n", '\n', '    uint mintedSupply;\n', '\n', '    for (uint i; i < mintings.length; i++) {\n', '      Minting memory m = mintings[i];\n', '      uint amount = m.amount;\n', '      address recipient = m.recipient;\n', '\n', '      mintedSupply += amount;\n', '      _balances[recipient] += amount;\n', '      emit Transfer(address(0), recipient, amount);\n', '    }\n', '\n', '    _totalSupply += mintedSupply;\n', '  }\n', '\n', '  /**\n', '   * @notice open trading\n', '   * @dev sender must be owner\n', '   * @dev trading must not yet have been opened\n', '   */\n', '  function open () external {\n', "    require(msg.sender == _owner, 'ERR: sender must be owner');\n", "    require(_openedAt == 0, 'ERR: already opened');\n", '\n', '    _openedAt = block.timestamp;\n', '\n', '    // add liquidity, set initial cost basis\n', '\n', '    _mint(address(this), SUPPLY - totalSupply());\n', '\n', '    _initialBasis = (1 ether) * address(this).balance / balanceOf(address(this));\n', '\n', '    IUniswapV2Router02(\n', '      UNISWAP_ROUTER\n', '    ).addLiquidityETH{\n', '      value: address(this).balance\n', '    }(\n', '      address(this),\n', '      balanceOf(address(this)),\n', '      0,\n', '      0,\n', '      address(this),\n', '      block.timestamp\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice close trading\n', '   * @dev trading must not yet have been closed\n', '   * @dev minimum time since open must have elapsed\n', '   */\n', '  function close () external {\n', "    require(_openedAt != 0, 'ERR: not yet opened');\n", "    require(_closedAt == 0, 'ERR: already closed');\n", "    require(block.timestamp > _openedAt + (1 days), 'ERR: too soon');\n", '\n', '    _closedAt = block.timestamp;\n', '\n', '    require(\n', '      block.timestamp > _athTimestamp + (1 weeks),\n', "      'ERR: recent ATH'\n", '    );\n', '\n', '    (uint token, ) = IUniswapV2Router02(\n', '      UNISWAP_ROUTER\n', '    ).removeLiquidityETH(\n', '      address(this),\n', '      IERC20(_pair).balanceOf(address(this)),\n', '      0,\n', '      0,\n', '      address(this),\n', '      block.timestamp\n', '    );\n', '\n', '    _burn(address(this), token);\n', '  }\n', '\n', '  /**\n', '   * @notice exchange BUFFDOGE for proportion of ETH in contract\n', '   * @dev trading must have been closed\n', '   */\n', '  function liquidate () external {\n', "    require(_closedAt > 0, 'ERR: not yet closed');\n", '    \n', '    uint balance = balanceOf(msg.sender);\n', '\n', "    require(balance != 0, 'ERR: zero balance');\n", '\n', '    uint payout = address(this).balance * balance / totalSupply();\n', '\n', '    _burn(msg.sender, balance);\n', '    payable(msg.sender).sendValue(payout);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw remaining ETH from contract\n', '   * @dev trading must have been closed\n', '   * @dev minimum time since close must have elapsed\n', '   */\n', '  function liquidateUnclaimed () external {\n', "    require(_closedAt > 0, 'ERR: not yet closed');\n", "    require(block.timestamp > _closedAt + (12 weeks), 'ERR: too soon');\n", '    payable(_owner).sendValue(address(this).balance);\n', '  }\n', '\n', '  function _beforeTokenTransfer (\n', '    address from,\n', '    address to,\n', '    uint amount\n', '  ) override internal {\n', '    super._beforeTokenTransfer(from, to, amount);\n', '\n', '    // ignore minting and burning\n', '    if (from == address(0) || to == address(0)) return;\n', '\n', '    // ignore add/remove liquidity\n', '    if (from == address(this) || to == address(this)) return;\n', '    if (from == UNISWAP_ROUTER || to == UNISWAP_ROUTER) return;\n', '\n', '    require(_openedAt > 0);\n', '\n', '    require(\n', '      msg.sender == UNISWAP_ROUTER || msg.sender == _pair,\n', "      'ERR: sender must be uniswap'\n", '    );\n', '    require(amount <= 5e9 ether /* revert message not returned by Uniswap */);\n', '\n', '    address[] memory path = new address[](2);\n', '\n', '    if (from == _pair) {\n', '      require(cooldownOf[to] < block.timestamp /* revert message not returned by Uniswap */);\n', '      cooldownOf[to] = block.timestamp + (5 minutes);\n', '\n', '      path[0] = WETH;\n', '      path[1] = address(this);\n', '\n', '      uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsIn(\n', '        amount,\n', '        path\n', '      );\n', '\n', '      uint balance = balanceOf(to);\n', '      uint fromBasis = (1 ether) * amounts[0] / amount;\n', '      _basisOf[to] = (fromBasis * amount + basisOf(to) * balance) / (amount + balance);\n', '\n', '      if (fromBasis > _ath) {\n', '        _ath = fromBasis;\n', '        _athTimestamp = block.timestamp;\n', '      }\n', '    } else if (to == _pair) {\n', '      // blacklist Vitalik Buterin\n', '      require(from != 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B /* revert message not returned by Uniswap */);\n', '      require(cooldownOf[from] < block.timestamp /* revert message not returned by Uniswap */);\n', '      cooldownOf[from] = block.timestamp + (5 minutes);\n', '\n', '      path[0] = address(this);\n', '      path[1] = WETH;\n', '\n', '      uint[] memory amounts = IUniswapV2Router02(UNISWAP_ROUTER).getAmountsOut(\n', '        amount,\n', '        path\n', '      );\n', '\n', '      require(basisOf(from) <= (1 ether) * amounts[1] / amount /* revert message not returned by Uniswap */);\n', '    }\n', '  }\n', '}']