['// SPDX-License-Identifier: MIT\n', '\n', '// 2021-04-10 - Release Version\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '// @openzeppelin/contracts/utils/Context.sol introduces execution context to replace msg.sender with _msgSender()\n', '// implement admin role\n', 'import "./Ownable.sol";\n', '\n', '// interfaces for fetching ownership of common and wrapped Cryptopunks\n', 'interface ICryptoPunks {\n', '\tfunction punkIndexToAddress(uint) external view returns(address);\n', '}\n', 'interface IWrappedPunks {\n', '\tfunction ownerOf(uint256) external view returns (address);\n', '}\n', '\n', 'contract StitchedPunksShop is Ownable {\n', '    // access to existing CryptoPunks and WrappedPunks contracts\n', '\tICryptoPunks internal CryptoPunks = ICryptoPunks(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\n', '\tIWrappedPunks internal WrappedPunks = IWrappedPunks(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6);\n', '\n', '    // current price for submitting an order\n', '    uint256 public currentOrderPrice = 1 ether;\n', '\n', '    // order details\n', '    struct OrderDetails {\n', '        // punk ID this order refers to:\n', '        uint16 punkId;\n', '        // current status of order:\n', '        // 0 = "not created yet"\n', '        // 10 = "order created and paid"\n', '        // 20 = "crafting StitchedPunk"\n', '        // 30 = "shipped"\n', '        // 40 = "received and NFT redeemed"\n', '        uint8 status;\n', '        // owner who submitted the order:\n', '        address owner;\n', '    }\n', '\n', '    // order status for punk ID\n', '    uint16[] public orderedPunkIds;\n', '    mapping(uint16 => OrderDetails) public orderStatus;\n', '\n', '    // events\n', '    event OrderCreated(uint16 indexed punkId, address indexed owner);\n', '    event OrderUpdated(uint16 indexed punkId, uint8 indexed newStatus);\n', '\n', '    function withdraw() external onlyOwner() {\n', '        payable(owner()).transfer(address(this).balance);\n', '    }\n', '\n', '    function setOrderPrice(uint256 newPrice) external onlyOwner() {\n', '        currentOrderPrice = newPrice;\n', '    }\n', '\n', '    // returns current owner of a given CryptoPunk (if common CryptoPunk)\n', '    function getOwnerForCryptoPunk(uint16 punkIndex) public view returns (address) {\n', '        return CryptoPunks.punkIndexToAddress(punkIndex);\n', '    }\n', '\n', '    // returns current owner of a given WrappedPunk (if wrapped CryptoPunk)\n', '    function getOwnerForWrappedPunk(uint16 punkIndex) public view returns (address) {\n', '        try WrappedPunks.ownerOf(punkIndex) returns (address wrappedPunkOwner) {\n', '            return wrappedPunkOwner;\n', '        } catch Error(string memory) {\n', '            // catches failing revert() and require()\n', '            // ERC721: if token does not exist, require() fails in target contract\n', '            return address(0);\n', '        } catch (bytes memory) {\n', '            // low-level: catches a failing assertion, etc.\n', '            return address(0);\n', '        }\n', '    }\n', '\n', '    // checks if wallet owns a given CryptoPunk\n', '    function isOwnerOfPunk(address wallet, uint16 punkIndex) public view returns (bool) {\n', '        return getOwnerForCryptoPunk(punkIndex) == wallet || getOwnerForWrappedPunk(punkIndex) == wallet;\n', '    }\n', '\n', '    function submitOrder(uint16 punkIndex) external payable {\n', '        // currentOrderPrice has to be paid\n', '        require(msg.value >= currentOrderPrice, "price is too low");\n', '        // sender has to be owner of the punk (common or wrapped)\n', '        require(isOwnerOfPunk(_msgSender(), punkIndex), "you need to own this punk");\n', '        // punk must not already be ordered\n', '        require(orderStatus[punkIndex].status == 0, "punk was already ordered");\n', '\n', '        // save order details\n', '        orderStatus[punkIndex] = OrderDetails(punkIndex, 10, _msgSender());\n', '        orderedPunkIds.push(punkIndex);\n', '\n', '        emit OrderCreated(punkIndex, _msgSender());\n', '    }\n', '\n', '    function updateOrderStatus(uint16 punkIndex, uint8 newStatus) public onlyOwner() {\n', '        // punk has to be ordered already\n', '        require(orderStatus[punkIndex].status != 0, "punk was not yet ordered");\n', '\n', '        // update order status\n', '        orderStatus[punkIndex].status = newStatus;\n', '\n', '        emit OrderUpdated(punkIndex, newStatus);\n', '    }\n', '\n', '    // StitchedPunksNFT contract address\n', '    address public stitchedPunksNFTAddress = address(0);\n', '\n', '    // will be called after the StitchedPunksNFT contract was deployed\n', '    function setStitchedPunksNFTAddress(address newAddress) public onlyOwner() {\n', '        stitchedPunksNFTAddress = newAddress;\n', '    }\n', '\n', '    // update order status when the NFT is redeemed/minted (must be called from the StitchedPunksNFT contract)\n', '    function updateOrderRedeemNFT(uint16 punkIndex) external {\n', '        require(stitchedPunksNFTAddress == _msgSender(), "caller is not the StitchedPunksNFT contract");\n', '\n', '        // update order status: 40 = "received and NFT redeemed"\n', '        uint8 newStatus = 40;\n', '\n', '        // punk has to be ordered already\n', '        require(orderStatus[punkIndex].status != 0, "punk was not yet ordered");\n', '\n', '        // update order status\n', '        orderStatus[punkIndex].status = newStatus;\n', '\n', '        emit OrderUpdated(punkIndex, newStatus);\n', '    }\n', '}']