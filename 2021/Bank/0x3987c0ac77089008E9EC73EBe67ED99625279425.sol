['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.6.7;\n', 'interface IERC1155 {\n', '    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 value, bytes calldata _data) external;\n', '    function balanceOf(address _owner, uint256 _id) external view returns(uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address _who) external returns (uint256);\n', '}\n', '\n', 'library Math {\n', '    function add(uint a, uint b) internal pure returns (uint c) {require((c = a + b) >= b, "BoringMath: Add Overflow");}\n', '    function sub(uint a, uint b) internal pure returns (uint c) {require((c = a - b) <= a, "BoringMath: Underflow");}\n', '    function mul(uint a, uint b) internal pure returns (uint c) {require(a == 0 || (c = a * b)/b == a, "BoringMath: Mul Overflow");}\n', '}\n', '\n', 'contract NFTSale {\n', '    using Math for uint256;\n', '\n', '    address public controller;\n', '    address  payable public hausAddress;\n', '    \n', '    IERC1155 public nft;\n', '    uint256  public price;\n', '    uint256  public id;\n', '    uint256  public start;\n', '    uint256 public limitPerOrder;\n', '    \n', '    event Buy(address buyer, uint256 amount);\n', '    \n', '    constructor(\n', '        address payable _hausAddress,\n', '        uint256 _startTime,\n', '        address _tokenAddress,\n', '        uint256 _tokenId,\n', '        uint256 _priceWei,\n', '        uint256 _limitPerOrder\n', '    ) public {\n', '        hausAddress = _hausAddress;\n', '        start = _startTime;\n', '        nft = IERC1155(_tokenAddress);\n', '        id = _tokenId;\n', '        price = _priceWei;\n', '        limitPerOrder = _limitPerOrder;\n', '        controller = msg.sender;\n', '    }\n', '    \n', '    function buy(uint256 amount) public payable {\n', '        require(msg.sender == tx.origin, "no contracts");\n', '        require(block.timestamp >= start, "early");\n', '        require(amount <= supply(), "ordered too many");\n', '        require(amount <= limitPerOrder, "ordered too many");\n', '        require(msg.value == price.mul(amount), "wrong amount");\n', '        nft.safeTransferFrom(address(this), msg.sender, id, amount, new bytes(0x0));\n', '        hausAddress.transfer(address(this).balance);\n', '        emit Buy(msg.sender, amount);\n', '    }\n', '    \n', '    function supply() public view returns(uint256) {\n', '        return nft.balanceOf(address(this), id);\n', '    }\n', '\n', '    function setTokenAddress(address _tokenAddress) public onlyController {\n', '        nft = IERC1155(_tokenAddress);\n', '    }\n', '\n', '    function setTokenId(uint256 _tokenId) public onlyController {\n', '        id = _tokenId;\n', '    }\n', '\n', '    function pull() public onlyController {\n', '        nft.safeTransferFrom(address(this), controller, id, nft.balanceOf(address(this), id), new bytes(0x0));\n', '    }\n', '\n', '    modifier onlyController {\n', '      require(msg.sender == controller);\n', '      _;\n', '    }\n', '    \n', '    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns(bytes4) {\n', '        return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']