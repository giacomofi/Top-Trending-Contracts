['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.7.3;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', 'import "./Context.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract WStock3 is ReentrancyGuard, Context, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  constructor (address _gasToken ,address _authAddress, address payable _holdingAddress, uint256 _feeRate, uint256 _acceptableTolerance, uint256 _reserve) {\n', '    GAS_TOKEN = IERC20(_gasToken);\n', '    authAddress = _authAddress;\n', '    holdingAddress = _holdingAddress;\n', '\t  feeRate = _feeRate;\n', '    acceptableTolerance = _acceptableTolerance;\n', '    reserve = _reserve;\n', '  }\n', '\n', '  modifier onlyAuthorized() {\n', '    require(authAddress == _msgSender(), "Unauthorized usage");\n', '    _;\n', '  }\n', '\n', '  IERC20 private GAS_TOKEN;\n', '  mapping(bytes32 => IERC20) public stocks;\n', '\n', '  address private authAddress;\n', '  address payable private holdingAddress;\n', '  uint256 private feeRate;\n', '  uint256 private acceptableTolerance;\n', '  uint256 private reserve;\n', '  uint256 public totalTrades;\n', '\n', '  event Trade(uint256 indexed tradeId, address account, bytes32 ticker, bool isBuy, uint256 amount, uint256 total, uint256 fee);\n', '  event Reload(uint256 indexed amount, uint256 timestamp);\n', '\n', '  function buy(bytes32 ticker, uint256 amount, uint256 timestamp, uint8 v, bytes32 r, bytes32 s) public payable nonReentrant { // replaced total with msg.value\n', '    require(amount > 0, "Must buy an amount of tokens");\n', '    require(msg.value > 0, "total must be greater than zero");\n', '    bytes32 hash = keccak256(abi.encode(_msgSender(), ticker, amount, msg.value, timestamp));\n', '    address signer = ecrecover(hash, v, r, s);\n', '    require(signer == authAddress, "Invalid signature");\n', '    require(timestamp.add(acceptableTolerance) > block.timestamp, "Expired Order");\n', '    require(address(stocks[ticker]) != address(0), "unsupported asset");\n', '    uint256 fee = msg.value.mul(feeRate);\n', "    require(fee <= GAS_TOKEN.balanceOf(_msgSender()), 'insufficient gas token balance');\n", '\n', '    totalTrades++;\n', '    emit Trade(totalTrades, _msgSender(), ticker, true, amount, msg.value, fee);\n', '    stocks[ticker].mint(_msgSender(), amount);\n', '    GAS_TOKEN.transferFrom(_msgSender(), holdingAddress, fee);\n', '    if (address(this).balance >= reserve) {\n', '      _safeTransfer(holdingAddress, msg.value);\n', '    }\n', '    else {\n', '      emit Reload(reserve.sub(address(this).balance), block.timestamp);\n', '    }\n', '  }\n', '\n', '  function sell(bytes32 ticker, uint256 amount, uint256 total, uint256 timestamp, uint8 v, bytes32 r, bytes32 s) public nonReentrant {\n', '    require(amount > 0, "Must select an amount of tokens");\n', '    require(total > 0, "total must be greater than zero");\n', '    require(amount <= stocks[ticker].balanceOf(_msgSender()), "Cannot sell more than balance");\n', '    bytes32 hash = keccak256(abi.encode(_msgSender(), ticker, amount, total, timestamp));\n', '    address signer = ecrecover(hash, v, r, s);\n', '    require(signer == authAddress, "Invalid signature");\n', '    require(timestamp.add(acceptableTolerance) > block.timestamp, "Expired Order");\n', '    require(total <= address(this).balance, "insufficient funds, try again later");\n', '    require(address(stocks[ticker]) != address(0), "unsupported asset");\n', '    uint256 fee = total.mul(feeRate);\n', "    require(fee <= GAS_TOKEN.balanceOf(_msgSender()), 'insufficient gas token balance');\n", '\n', '    totalTrades++;\n', '    emit Trade(totalTrades, _msgSender(), ticker, false, amount, total, fee);\n', '    stocks[ticker].transferFrom(_msgSender(), address(this), amount);\n', '    stocks[ticker].burn(amount);\n', '    GAS_TOKEN.transferFrom(_msgSender(), holdingAddress, fee);\n', '    _safeTransfer(_msgSender(), total);\n', '    if (address(this).balance < reserve) {\n', '      emit Reload(reserve.sub(address(this).balance), block.timestamp);\n', '    }\n', '  }\n', '\n', '  function addStock(bytes32 _ticker, IERC20 _asset) public onlyAuthorized {\n', '    stocks[_ticker] = _asset;\n', '  }\n', '\n', '  function getReserve()  public view returns(uint256) {\n', '    return reserve;\n', '  }\n', '  function setReserve(uint256 _reserve) public payable onlyAuthorized {\n', '    reserve = _reserve;\n', '  }\n', '\n', '  function getAuthAddress() public view returns (address) {\n', '    return authAddress;\n', '  }\n', '  function setAuthAddress(address payable _authAddress) public onlyAuthorized {\n', '    authAddress = _authAddress;\n', '  }\n', '\n', '  function getFeeRate() public view returns (uint256) {\n', '    return feeRate;\n', '  }\n', '  function setFeeRate(uint256 _feeRate) public onlyAuthorized {\n', '    feeRate = _feeRate;\n', '  }\n', '\n', '  function getAcceptableTolerance()  public view returns(uint256) {\n', '    return acceptableTolerance;\n', '  }\n', '  function setAcceptableTolerance(uint256 _acceptableTolerance) public onlyAuthorized {\n', '    acceptableTolerance = _acceptableTolerance;\n', '  }\n', '\n', '  function _safeTransfer(address payable to, uint256 amount) internal {\n', '    uint256 balance;\n', '    balance = address(this).balance;\n', '    if (amount > balance) {\n', '        amount = balance;\n', '    }\n', '    Address.sendValue(to, amount);\n', '  }\n', '\n', '}']