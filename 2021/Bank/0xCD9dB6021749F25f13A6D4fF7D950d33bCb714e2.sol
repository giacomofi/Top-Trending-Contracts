['pragma solidity 0.5.17;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./ExchangeDomainV1.sol";\n', '\n', 'contract ExchangeOrdersHolderV1 {\n', '\n', '    mapping(bytes32 => OrderParams) internal orders;\n', '\n', '    struct OrderParams {\n', '        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\n', '        uint selling;\n', '        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\n', '        uint buying;\n', '\n', '        /* fee for selling */\n', '        uint sellerFee;\n', '    }\n', '\n', '    function add(ExchangeDomainV1.Order calldata order) external {\n', '        require(msg.sender == order.key.owner, "order could be added by owner only");\n', '        bytes32 key = prepareKey(order);\n', '        orders[key] = OrderParams(order.selling, order.buying, order.sellerFee);\n', '    }\n', '\n', '    function exists(ExchangeDomainV1.Order calldata order) external view returns (bool) {\n', '        bytes32 key = prepareKey(order);\n', '        OrderParams memory params = orders[key];\n', '        return params.buying == order.buying && params.selling == order.selling && params.sellerFee == order.sellerFee;\n', '    }\n', '\n', '    function prepareKey(ExchangeDomainV1.Order memory order) internal pure returns (bytes32) {\n', '        return keccak256(abi.encode(\n', '                order.key.sellAsset.token,\n', '                order.key.sellAsset.tokenId,\n', '                order.key.owner,\n', '                order.key.buyAsset.token,\n', '                order.key.buyAsset.tokenId,\n', '                order.key.salt\n', '            ));\n', '    }\n', '}']