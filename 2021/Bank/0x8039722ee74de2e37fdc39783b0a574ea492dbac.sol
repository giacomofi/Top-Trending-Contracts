['# @version ^0.2.12\n', '\n', 'struct MintParams:\n', '    token0: address\n', '    token1: address\n', '    fee: uint256\n', '    tickLower: int128\n', '    tickUpper: int128\n', '    amount0Desired: uint256\n', '    amount1Desired: uint256\n', '    amount0Min: uint256\n', '    amount1Min: uint256\n', '    recipient: address\n', '    deadline: uint256\n', '\n', 'struct ModifyParams:\n', '    fee: uint256\n', '    tickLower: int128\n', '    tickUpper: int128\n', '    recipient: address\n', '    deadline: uint256\n', '\n', 'interface ERC721:\n', '    def transferFrom(_from: address, _to: address, _tokenId: uint256): payable\n', '\n', 'interface NonfungiblePositionManager:\n', '    def burn(tokenId: uint256): payable\n', '\n', 'interface WrappedEth:\n', '    def deposit(): payable\n', '    def withdraw(amount: uint256): nonpayable\n', '\n', 'event AddedLiquidity:\n', '    tokenId: indexed(uint256)\n', '    token0: indexed(address)\n', '    token1: indexed(address)\n', '    liquidity: uint256\n', '    amount0: uint256\n', '    amount1: uint256\n', '\n', 'event NFLPModified:\n', '    oldTokenId: indexed(uint256)\n', '    newTokenId: indexed(uint256)\n', '\n', 'event Paused:\n', '    paused: bool\n', '\n', 'NONFUNGIBLEPOSITIONMANAGER: constant(address) = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88\n', 'UNISWAPV3FACTORY: constant(address) = 0x1F98431c8aD98523631AE4a59f267346ea31F984\n', '\n', 'VETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', 'WETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', '\n', 'APPROVE_MID: constant(Bytes[4]) = method_id("approve(address,uint256)")\n', 'TRANSFER_MID: constant(Bytes[4]) = method_id("transfer(address,uint256)")\n', 'TRANSFERFROM_MID: constant(Bytes[4]) = method_id("transferFrom(address,address,uint256)")\n', 'CAIPIN_MID: constant(Bytes[4]) = method_id("createAndInitializePoolIfNecessary(address,address,uint24,uint160)")\n', 'GETPOOL_MID: constant(Bytes[4]) = method_id("getPool(address,address,uint24)")\n', 'SLOT0_MID: constant(Bytes[4]) = method_id("slot0()")\n', 'MINT_MID: constant(Bytes[4]) = method_id("mint((address,address,uint24,int24,int24,uint256,uint256,uint256,uint256,address,uint256))")\n', 'POSITIONS_MID: constant(Bytes[4]) = method_id("positions(uint256)")\n', 'INCREASELIQUIDITY_MID: constant(Bytes[4]) = method_id("increaseLiquidity((uint256,uint256,uint256,uint256,uint256,uint256))")\n', 'DECREASELIQUIDITY_MID: constant(Bytes[4]) = method_id("decreaseLiquidity((uint256,uint128,uint256,uint256,uint256))")\n', 'COLLECT_MID: constant(Bytes[4]) = method_id("collect((uint256,address,uint128,uint128))")\n', '\n', 'paused: public(bool)\n', 'admin: public(address)\n', 'feeAddress: public(address)\n', '\n', '@external\n', 'def __init__():\n', '    self.paused = False\n', '    self.admin = msg.sender\n', '    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\n', '\n', '@internal\n', '@pure\n', 'def uintSqrt(x: uint256) -> uint256:\n', '    if x > 3:\n', '        z: uint256 = (x + 1) / 2\n', '        y: uint256 = x\n', '        for i in range(256):\n', '            if y == z:\n', '                return y\n', '            y = z\n', '            z = (x / z + z) / 2\n', '        raise "Did not coverage"\n', '    elif x == 0:\n', '        return 0\n', '    else:\n', '        return 1\n', '\n', '@internal\n', 'def safeApprove(_token: address, _spender: address, _value: uint256):\n', '    _response: Bytes[32] = raw_call(\n', '        _token,\n', '        concat(\n', '            APPROVE_MID,\n', '            convert(_spender, bytes32),\n', '            convert(_value, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed approve\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool), "Approve failed"  # dev: failed approve\n', '\n', '@internal\n', 'def safeTransfer(_token: address, _to: address, _value: uint256):\n', '    _response: Bytes[32] = raw_call(\n', '        _token,\n', '        concat(\n', '            TRANSFER_MID,\n', '            convert(_to, bytes32),\n', '            convert(_value, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed transfer\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool), "Transfer failed"  # dev: failed transfer\n', '\n', '@internal\n', 'def safeTransferFrom(_token: address, _from: address, _to: address, _value: uint256):\n', '    _response: Bytes[32] = raw_call(\n', '        _token,\n', '        concat(\n', '            TRANSFERFROM_MID,\n', '            convert(_from, bytes32),\n', '            convert(_to, bytes32),\n', '            convert(_value, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed transferFrom\n', '    if len(_response) > 0:\n', '        assert convert(_response, bool), "TransferFrom failed"  # dev: failed transferFrom\n', '\n', '@internal\n', 'def addLiquidity(_tokenId: uint256, sender: address, uniV3Params: MintParams) -> (uint256, uint256):\n', '    self.safeApprove(uniV3Params.token0, NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount0Desired)\n', '    self.safeApprove(uniV3Params.token1, NONFUNGIBLEPOSITIONMANAGER, uniV3Params.amount1Desired)\n', '    if _tokenId == 0:\n', '        sqrtPriceX96: uint256 = 0\n', '        _response32: Bytes[32] = raw_call(\n', '            UNISWAPV3FACTORY,\n', '            concat(\n', '                GETPOOL_MID,\n', '                convert(uniV3Params.token0, bytes32),\n', '                convert(uniV3Params.token1, bytes32),\n', '                convert(uniV3Params.fee, bytes32)\n', '            ),\n', '            max_outsize=32,\n', '            is_static_call=True\n', '        )\n', '        pool: address = convert(convert(_response32, bytes32), address)\n', '        if pool == ZERO_ADDRESS:\n', '            sqrtPriceX96 = 2 ** 96 * self.uintSqrt(uniV3Params.amount0Desired) / self.uintSqrt(uniV3Params.amount1Desired)\n', '        else:\n', '            _response224: Bytes[224] = raw_call(\n', '                pool,\n', '                SLOT0_MID,\n', '                max_outsize=224,\n', '                is_static_call=True\n', '            )\n', '            sqrtPriceX96 = convert(slice(_response224, 0, 32), uint256)\n', '            if sqrtPriceX96 == 0:\n', '                sqrtPriceX96 = 2 ** 96 * self.uintSqrt(uniV3Params.amount0Desired) / self.uintSqrt(uniV3Params.amount1Desired)\n', '\n', '        _response32 = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                CAIPIN_MID,\n', '                convert(uniV3Params.token0, bytes32),\n', '                convert(uniV3Params.token1, bytes32),\n', '                convert(uniV3Params.fee, bytes32),\n', '                convert(sqrtPriceX96, bytes32)\n', '            ),\n', '            max_outsize=32\n', '        )\n', '        assert convert(convert(_response32, bytes32), address) != ZERO_ADDRESS, "Create Or Init Pool failed"\n', '\n', '        _response128: Bytes[128] = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                MINT_MID,\n', '                convert(uniV3Params.token0, bytes32),\n', '                convert(uniV3Params.token1, bytes32),\n', '                convert(uniV3Params.fee, bytes32),\n', '                convert(uniV3Params.tickLower, bytes32),\n', '                convert(uniV3Params.tickUpper, bytes32),\n', '                convert(uniV3Params.amount0Desired, bytes32),\n', '                convert(uniV3Params.amount1Desired, bytes32),\n', '                convert(uniV3Params.amount0Min, bytes32),\n', '                convert(uniV3Params.amount1Min, bytes32),\n', '                convert(uniV3Params.recipient, bytes32),\n', '                convert(uniV3Params.deadline, bytes32)\n', '            ),\n', '            max_outsize=128\n', '        )\n', '        tokenId: uint256 = convert(slice(_response128, 0, 32), uint256)\n', '        liquidity: uint256 = convert(slice(_response128, 32, 32), uint256)\n', '        amount0: uint256 = convert(slice(_response128, 64, 32), uint256)\n', '        amount1: uint256 = convert(slice(_response128, 96, 32), uint256)\n', '        log AddedLiquidity(tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\n', '        return (amount0, amount1)\n', '    else:\n', '        liquidity: uint256 = 0\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        _response96: Bytes[96] = raw_call(\n', '            NONFUNGIBLEPOSITIONMANAGER,\n', '            concat(\n', '                INCREASELIQUIDITY_MID,\n', '                convert(_tokenId, bytes32),\n', '                convert(uniV3Params.amount0Desired, bytes32),\n', '                convert(uniV3Params.amount1Desired, bytes32),\n', '                convert(uniV3Params.amount0Min, bytes32),\n', '                convert(uniV3Params.amount1Min, bytes32),\n', '                convert(uniV3Params.deadline, bytes32)\n', '            ),\n', '            max_outsize=96\n', '        )\n', '        liquidity = convert(slice(_response96, 0, 32), uint256)\n', '        amount0 = convert(slice(_response96, 32, 32), uint256)\n', '        amount1 = convert(slice(_response96, 64, 32), uint256)\n', '        log AddedLiquidity(_tokenId, uniV3Params.token0, uniV3Params.token1, liquidity, amount0, amount1)\n', '        return (amount0, amount1)\n', '\n', '@external\n', '@payable\n', "@nonreentrant('lock')\n", 'def addLiquidityEthForUniV3(_tokenId: uint256, uniV3Params: MintParams):\n', '    assert not self.paused, "Paused"\n', '    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256), "Unsorted tokens"\n', '    if uniV3Params.token0 == WETH:\n', '        if msg.value > uniV3Params.amount0Desired:\n', '            send(msg.sender, msg.value - uniV3Params.amount0Desired)\n', '        else:\n', '            assert msg.value == uniV3Params.amount0Desired, "Eth not enough"\n', '        WrappedEth(WETH).deposit(value=uniV3Params.amount0Desired)\n', '        self.safeTransferFrom(uniV3Params.token1, msg.sender, self, uniV3Params.amount1Desired)\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        (amount0, amount1) = self.addLiquidity(_tokenId, msg.sender, uniV3Params)\n', '        amount0 = uniV3Params.amount0Desired - amount0\n', '        amount1 = uniV3Params.amount1Desired - amount1\n', '        if amount0 > 0:\n', '            WrappedEth(WETH).withdraw(amount0)\n', '            send(msg.sender, amount0)\n', '            self.safeApprove(uniV3Params.token0, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '        if amount1 > 0:\n', '            self.safeTransfer(uniV3Params.token1, msg.sender, amount1)\n', '            self.safeApprove(uniV3Params.token1, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    else:\n', '        assert uniV3Params.token1 == WETH, "Not Eth Pair"\n', '        if msg.value > uniV3Params.amount1Desired:\n', '            send(msg.sender, msg.value - uniV3Params.amount1Desired)\n', '        else:\n', '            assert msg.value == uniV3Params.amount1Desired, "Eth not enough"\n', '        WrappedEth(WETH).deposit(value=uniV3Params.amount1Desired)\n', '        self.safeTransferFrom(uniV3Params.token0, msg.sender, self, uniV3Params.amount0Desired)\n', '        amount0: uint256 = 0\n', '        amount1: uint256 = 0\n', '        (amount0, amount1) = self.addLiquidity(_tokenId, msg.sender, uniV3Params)\n', '        amount0 = uniV3Params.amount0Desired - amount0\n', '        amount1 = uniV3Params.amount1Desired - amount1\n', '        if amount0 > 0:\n', '            self.safeTransfer(uniV3Params.token0, msg.sender, amount0)\n', '            self.safeApprove(uniV3Params.token0, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '        if amount1 > 0:\n', '            WrappedEth(WETH).withdraw(amount1)\n', '            send(msg.sender, amount1)\n', '            self.safeApprove(uniV3Params.token1, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def addLiquidityForUniV3(_tokenId: uint256, uniV3Params: MintParams):\n', '    assert not self.paused, "Paused"\n', '    assert convert(uniV3Params.token0, uint256) < convert(uniV3Params.token1, uint256), "Unsorted tokens"\n', '\n', '    self.safeTransferFrom(uniV3Params.token0, msg.sender, self, uniV3Params.amount0Desired)\n', '    self.safeTransferFrom(uniV3Params.token1, msg.sender, self, uniV3Params.amount1Desired)\n', '\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    (amount0, amount1) = self.addLiquidity(_tokenId, msg.sender, uniV3Params)\n', '    amount0 = uniV3Params.amount0Desired - amount0\n', '    amount1 = uniV3Params.amount1Desired - amount1\n', '    if amount0 > 0:\n', '        self.safeTransfer(uniV3Params.token0, msg.sender, amount0)\n', '        self.safeApprove(uniV3Params.token0, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    if amount1 > 0:\n', '        self.safeTransfer(uniV3Params.token1, msg.sender, amount1)\n', '        self.safeApprove(uniV3Params.token1, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def modifyPositionForUniV3NFLP(_tokenId: uint256, modifyParams: ModifyParams):\n', '    assert _tokenId != 0, "Wrong Token ID"\n', '\n', '    ERC721(NONFUNGIBLEPOSITIONMANAGER).transferFrom(msg.sender, self, _tokenId)\n', '    \n', '    _response384: Bytes[384] = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            POSITIONS_MID,\n', '            convert(_tokenId, bytes32)\n', '        ),\n', '        max_outsize=384,\n', '        is_static_call=True\n', '    )\n', '    token0: address = convert(convert(slice(_response384, 64, 32), uint256), address)\n', '    token1: address = convert(convert(slice(_response384, 96, 32), uint256), address)\n', '    liquidity: uint256 = convert(slice(_response384, 224, 32), uint256)\n', '    \n', '    _response64: Bytes[64] = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            DECREASELIQUIDITY_MID,\n', '            convert(_tokenId, bytes32),\n', '            convert(liquidity, bytes32),\n', '            convert(0, bytes32),\n', '            convert(0, bytes32),\n', '            convert(modifyParams.deadline, bytes32)\n', '        ),\n', '        max_outsize=64\n', '    )\n', '\n', '    _response64 = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            COLLECT_MID,\n', '            convert(_tokenId, bytes32),\n', '            convert(self, bytes32),\n', '            convert(2 ** 128 - 1, bytes32),\n', '            convert(2 ** 128 - 1, bytes32)\n', '        ),\n', '        max_outsize=64\n', '    )\n', '    amount0: uint256 = convert(slice(_response64, 0, 32), uint256)\n', '    amount1: uint256 = convert(slice(_response64, 32, 32), uint256)\n', '    \n', '    NonfungiblePositionManager(NONFUNGIBLEPOSITIONMANAGER).burn(_tokenId)\n', '\n', '    sqrtPriceX96: uint256 = 0\n', '    _response32: Bytes[32] = raw_call(\n', '        UNISWAPV3FACTORY,\n', '        concat(\n', '            GETPOOL_MID,\n', '            convert(token0, bytes32),\n', '            convert(token1, bytes32),\n', '            convert(modifyParams.fee, bytes32)\n', '        ),\n', '        max_outsize=32,\n', '        is_static_call=True\n', '    )\n', '    pool: address = convert(convert(_response32, bytes32), address)\n', '    if pool == ZERO_ADDRESS:\n', '        sqrtPriceX96 = 2 ** 96 * self.uintSqrt(amount0) / self.uintSqrt(amount1)\n', '    else:\n', '        _response224: Bytes[224] = raw_call(\n', '            pool,\n', '            SLOT0_MID,\n', '            max_outsize=224,\n', '            is_static_call=True\n', '        )\n', '        sqrtPriceX96 = convert(slice(_response224, 0, 32), uint256)\n', '        if sqrtPriceX96 == 0:\n', '            sqrtPriceX96 = 2 ** 96 * self.uintSqrt(amount1) / self.uintSqrt(amount1)\n', '\n', '    _response32 = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            CAIPIN_MID,\n', '            convert(token0, bytes32),\n', '            convert(token1, bytes32),\n', '            convert(modifyParams.fee, bytes32),\n', '            convert(sqrtPriceX96, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )\n', '\n', '    assert convert(convert(_response32, bytes32), address) != ZERO_ADDRESS, "Create Or Init Pool failed"\n', '\n', '    self.safeApprove(token0, NONFUNGIBLEPOSITIONMANAGER, amount0)\n', '    self.safeApprove(token1, NONFUNGIBLEPOSITIONMANAGER, amount1)\n', '\n', '    _response128: Bytes[128] = raw_call(\n', '        NONFUNGIBLEPOSITIONMANAGER,\n', '        concat(\n', '            MINT_MID,\n', '            convert(token0, bytes32),\n', '            convert(token1, bytes32),\n', '            convert(modifyParams.fee, bytes32),\n', '            convert(modifyParams.tickLower, bytes32),\n', '            convert(modifyParams.tickUpper, bytes32),\n', '            convert(amount0, bytes32),\n', '            convert(amount1, bytes32),\n', '            convert(0, bytes32),\n', '            convert(0, bytes32),\n', '            convert(msg.sender, bytes32),\n', '            convert(modifyParams.deadline, bytes32)\n', '        ),\n', '        max_outsize=128\n', '    )\n', '    tokenId: uint256 = convert(slice(_response128, 0, 32), uint256)\n', '    liquiditynew: uint256 = convert(slice(_response128, 32, 32), uint256)\n', '    amount0new: uint256 = convert(slice(_response128, 64, 32), uint256)\n', '    amount1new: uint256 = convert(slice(_response128, 96, 32), uint256)\n', '\n', '    if amount0 > amount0new:\n', '        self.safeTransfer(token0, msg.sender, amount0 - amount0new)\n', '        self.safeApprove(token0, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    if amount1 > amount1new:\n', '        self.safeTransfer(token1, msg.sender, amount1 - amount1new)\n', '        self.safeApprove(token1, NONFUNGIBLEPOSITIONMANAGER, 0)\n', '    log NFLPModified(_tokenId, tokenId)\n', '\n', '# Admin functions\n', '@external\n', 'def pause(_paused: bool):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.paused = _paused\n', '    log Paused(_paused)\n', '\n', '@external\n', 'def newAdmin(_admin: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.admin = _admin\n', '\n', '@external\n', 'def newFeeAddress(_feeAddress: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.feeAddress = _feeAddress\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def batchWithdraw(token: address[8], amount: uint256[8], to: address[8]):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    for i in range(8):\n', '        if token[i] == VETH:\n', '            send(to[i], amount[i])\n', '        elif token[i] != ZERO_ADDRESS:\n', '            self.safeTransfer(token[i], to[i], amount[i])\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw(token: address, amount: uint256, to: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    if token == VETH:\n', '        send(to, amount)\n', '    elif token != ZERO_ADDRESS:\n', '        self.safeTransfer(token, to, amount)\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    assert msg.sender == WETH, "can\'t receive Eth"']