['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-02\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '// \n', 'interface IERC20 {\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\tfunction balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'interface ILiquidityPool {\n', '\tfunction TOKENS (uint256) external returns (address);\n', '\tfunction TOKENS_MUL (uint256) external returns (uint256);\n', '\tfunction balance (uint256 token_) external returns (uint256);\n', '\tfunction calcBorrowFee (uint256 amount_) external returns (uint256);\n', '\tfunction borrow (\n', '\t\tuint256[5] calldata amounts_,\n', '\t\tbytes calldata data_\n', '\t) external;\n', '}\n', '\n', 'contract SimpleFlashLoaner {\n', '\t\n', '\taddress public owner;\n', '\tuint256 constant public N_TOKENS = 5;\n', '\tILiquidityPool public liquidityPool;\n', '\tIERC20[N_TOKENS] public TOKENS;\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner, "caller is not the owner");\n', '\t\t_;\n', '\t}\n', '\t\n', '\tconstructor(address liquidityPool_) {\n', '\t\towner = address(0x2CadAa8DEAeb13Ee93064CCde2D6360DAB42122a);\n', '\t\tliquidityPool = ILiquidityPool(liquidityPool_);\n', '\t\tfor (uint256 i = 0; i < N_TOKENS; i++)\n', '\t\t\tTOKENS[i] = IERC20(liquidityPool.TOKENS(i));\n', '\t}\n', '\n', '\tfunction transferOwnership(address address_) \n', '\t\texternal \n', '\t\tonlyOwner \n', '\t{\n', '\t\trequire(address_ != address(0), "new owner is the zero address");\n', '\t\towner = address_;\n', '\t}\n', '\t\n', '    // Call this func initilize flashloan on []amounts of each token\n', '    function flashLoan(\n', '        uint256[N_TOKENS] calldata amounts_,\n', '        uint256[N_TOKENS] calldata payAmounts_\n', '    )\n', '    \tonlyOwner\n', '    \texternal\n', '    {\n', '        bytes memory _data = abi.encodeWithSignature("callBack(uint256[5])", payAmounts_);\n', '        liquidityPool.borrow(amounts_, _data);\n', '    }\n', '\n', '    // Callback implementing custom logic (there will be arbitrage/trades/market-making/liquidations logic). \n', '    function callBack(\n', '        uint256[N_TOKENS] calldata payAmounts_\n', '    )\n', '    \t// onlyOwner\n', '    \texternal\n', '    {\n', '    \trequire(msg.sender == address(liquidityPool), "caller is not the LiquidityPool");\n', '\n', '        // Do your logic HERE\n', '\n', '        // return flash loan \n', '        for (uint256 i = 0; i < N_TOKENS; i++) {\n', '            if (payAmounts_[i] != 0) {\n', '                TOKENS[i].transfer(address(liquidityPool), payAmounts_[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdrawERC20(address tokenAddress_)\n', '\t\texternal\n', '\t\tonlyOwner\n', '\t{\n', '\t\tIERC20 _token = IERC20(tokenAddress_);\n', '\t\tuint256 _balance = _token.balanceOf(address(this));\n', '\t\tif (_balance > 0) {\n', '\t\t\t_token.transfer(msg.sender, _balance);\n', '\t\t}\n', '\t}\n', '\n', '}']