['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// File: iface/IERC20.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IERC20 {\n', '\tfunction decimals() external view returns (uint8);\n', '\tfunction name() external view returns (string memory);\n', '\tfunction symbol() external view returns (string memory);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/SafeMath.sol\n', '\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0, "ds-math-div-zero");\n', '        z = x / y;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    }\n', '}\n', '// File: iface/INTokenController.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '///@dev This interface defines the methods for ntoken management\n', 'interface INTokenController {\n', '    /// @dev Get ntoken address from token address\n', '    /// @param tokenAddress Destination token address\n', '    /// @return ntoken address\n', '    function getNTokenAddress(address tokenAddress) external view returns (address);\n', '}\n', '// File: iface/INestPriceFacade.sol\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface INestPriceFacade {\n', '\t/// @dev Price call entry configuration structure\n', '    struct Config {\n', '\n', '        // Single query fee（0.0001 ether, DIMI_ETHER). 100\n', '        uint16 singleFee;\n', '\n', '        // Double query fee（0.0001 ether, DIMI_ETHER). 100\n', '        uint16 doubleFee;\n', '\n', '        // The normal state flag of the call address. 0\n', '        uint8 normalFlag;\n', '    }\n', '    /// @dev Get configuration\n', '    /// @return Configuration object\n', '    function getConfig() external view returns (Config memory);\n', '\n', '    /// @dev Get the full information of latest trigger price. (token and ntoken)\n', '    /// @param tokenAddress Destination token address\n', '    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447, \n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    /// @return ntokenBlockNumber The block number of ntoken price\n', '    /// @return ntokenPrice The ntoken price. (1eth equivalent to (price) ntoken)\n', '    /// @return ntokenAvgPrice Average price of ntoken\n', '    /// @return ntokenSigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that\n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo2(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ, uint ntokenBlockNumber, uint ntokenPrice, uint ntokenAvgPrice, uint ntokenSigmaSQ);\n', '\n', '    /// @dev Get the full information of latest trigger price\n', '    /// @param tokenAddress Destination token address\n', '    /// @param paybackAddress As the charging fee may change, it is suggested that the caller pay more fees, and the excess fees will be returned through this address\n', '    /// @return blockNumber The block number of price\n', '    /// @return price The token price. (1eth equivalent to (price) token)\n', '    /// @return avgPrice Average price\n', '    /// @return sigmaSQ The square of the volatility (18 decimal places). The current implementation assumes that \n', '    ///         the volatility cannot exceed 1. Correspondingly, when the return value is equal to 999999999999996447,\n', '    ///         it means that the volatility has exceeded the range that can be expressed\n', '    function triggeredPriceInfo(address tokenAddress, address paybackAddress) external payable returns (uint blockNumber, uint price, uint avgPrice, uint sigmaSQ);\n', '\n', '\n', '\n', '}\n', '// File: PriceController.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', 'contract PriceController {\n', '\tusing SafeMath for uint256;\n', '\n', '\t// Nest price contract\n', '    INestPriceFacade nestPriceFacade;\n', '    // NTokenController\n', '    INTokenController ntokenController;\n', '\n', '    /// @dev Initialization method\n', '    /// @param _nestPriceFacade Nest price contract\n', '    /// @param _ntokenController NTokenController\n', '\tconstructor (address _nestPriceFacade, address _ntokenController) public {\n', '\t\tnestPriceFacade = INestPriceFacade(_nestPriceFacade);\n', '        ntokenController = INTokenController(_ntokenController);\n', '    }\n', '\n', '    /// @dev Is it a token-ntoken price pair\n', '    /// @param tokenOne token address(USDT,HBTC...)\n', '    /// @param tokenTwo ntoken address(NEST,NHBTC...)\n', '    function checkNToken(address tokenOne, address tokenTwo) public view returns(bool) {\n', '        if (ntokenController.getNTokenAddress(tokenOne) == tokenTwo) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /// @dev Uniform accuracy\n', '    /// @param inputToken Initial token\n', '    /// @param inputTokenAmount Amount of token\n', '    /// @param outputToken Converted token\n', '    /// @return stability Amount of outputToken\n', '    function getDecimalConversion(address inputToken, \n', '    \t                          uint256 inputTokenAmount, \n', '    \t                          address outputToken) public view returns(uint256) {\n', '    \tuint256 inputTokenDec = 18;\n', '    \tuint256 outputTokenDec = 18;\n', '    \tif (inputToken != address(0x0)) {\n', '    \t\tinputTokenDec = IERC20(inputToken).decimals();\n', '    \t}\n', '    \tif (outputToken != address(0x0)) {\n', '    \t\toutputTokenDec = IERC20(outputToken).decimals();\n', '    \t}\n', '    \treturn inputTokenAmount.mul(10**outputTokenDec).div(10**inputTokenDec);\n', '    }\n', '\n', '    /// @dev Get price\n', '    /// @param token mortgage asset address\n', '    /// @param uToken underlying asset address\n', '    /// @param payback return address of excess fee\n', '    /// @return tokenPrice Mortgage asset price(1 ETH = ? token)\n', '    /// @return pTokenPrice PToken price(1 ETH = ? pToken)\n', '    function getPriceForPToken(address token, \n', '                               address uToken,\n', '                               address payback) public payable returns (uint256 tokenPrice, \n', '                                                                        uint256 pTokenPrice) {\n', '        if (token == address(0x0)) {\n', '            // The mortgage asset is ETH，get ERC20-ETH price\n', '            (,,uint256 avg,) = nestPriceFacade.triggeredPriceInfo{value:msg.value}(uToken, payback);\n', '            require(avg > 0, "Log:PriceController:!avg1");\n', '            return (1 ether, getDecimalConversion(uToken, avg, address(0x0)));\n', '        } else if (uToken == address(0x0)) {\n', '            // The underlying asset is ETH，get ERC20-ETH price\n', '            (,,uint256 avg,) = nestPriceFacade.triggeredPriceInfo{value:msg.value}(token, payback);\n', '            require(avg > 0, "Log:PriceController:!avg2");\n', '            return (getDecimalConversion(uToken, avg, address(0x0)), 1 ether);\n', '        } else {\n', '            // Get ERC20-ERC20 price\n', '            if (checkNToken(token, uToken)) {\n', '                (,,uint256 avg1,,,,uint256 avg2,) = nestPriceFacade.triggeredPriceInfo2{value:msg.value}(token, payback);\n', '                require(avg1 > 0 && avg2 > 0, "Log:PriceController:!avg3");\n', '                return (avg1, getDecimalConversion(uToken, avg2, address(0x0)));\n', '            } else if (checkNToken(uToken, token)) {\n', '                (,,uint256 avg1,,,,uint256 avg2,) = nestPriceFacade.triggeredPriceInfo2{value:msg.value}(uToken, payback);\n', '                require(avg1 > 0 && avg2 > 0, "Log:PriceController:!avg4");\n', '                return (avg2, getDecimalConversion(uToken, avg1, address(0x0)));\n', '            } else {\n', '                (,,uint256 avg1,) = nestPriceFacade.triggeredPriceInfo{value:uint256(msg.value).div(2)}(token, payback);\n', '                (,,uint256 avg2,) = nestPriceFacade.triggeredPriceInfo{value:uint256(msg.value).div(2)}(uToken, payback);\n', '                require(avg1 > 0 && avg2 > 0, "Log:PriceController:!avg5");\n', '                return (avg1, getDecimalConversion(uToken, avg2, address(0x0)));\n', '            }\n', '        }\n', '    }\n', '}']