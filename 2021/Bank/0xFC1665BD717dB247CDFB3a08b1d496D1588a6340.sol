['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\UniswapV2\\1\\IUniswapV2AMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'interface IUniswapV2AMMV1 is IAMM {\n', '\n', '    function uniswapData() external view returns(address routerAddress, address wethAddress);\n', '}\n', '\n', 'interface IUniswapV2Router {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Pair is IERC20 {\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function factory() external view returns(address);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'abstract contract AMM is IAMM {\n', '\n', '    struct ProcessedLiquidityPoolData {\n', '        address liquidityPoolAddress;\n', '        uint256 liquidityPoolAmount;\n', '        address[] liquidityPoolTokens;\n', '        uint256[] tokensAmounts;\n', '        bool involvingETH;\n', '        address liquidityPoolOperator;\n', '        address receiver;\n', '    }\n', '\n', '    struct ProcessedSwapData {\n', '        bool enterInETH;\n', '        bool exitInETH;\n', '        address[] liquidityPoolAddresses;\n', '        address[] path;\n', '        address liquidityPoolOperator;\n', '        address inputToken;\n', '        uint256 amount;\n', '        address receiver;\n', '    }\n', '\n', '    mapping(address => uint256) private _tokenIndex;\n', '    address[] private _tokensToTransfer;\n', '    address[] private _operators;\n', '    uint256[] private _tokenAmounts;\n', '\n', '    string internal _name;\n', '    uint256 internal immutable _version;\n', '    address internal immutable _ethereumAddress;\n', '    uint256 internal immutable _maxTokensPerLiquidityPool;\n', '    bool internal immutable _hasUniqueLiquidityPools;\n', '\n', '    constructor(string memory name, uint256 version, address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools) {\n', '        _name = name;\n', '        _version = version;\n', '        _ethereumAddress = ethereumAddress;\n', '        _maxTokensPerLiquidityPool = maxTokensPerLiquidityPool;\n', '        _hasUniqueLiquidityPools = hasUniqueLiquidityPools;\n', '    }\n', '\n', '    receive() external virtual payable {\n', '    }\n', '\n', '    function info() view public virtual override returns(string memory, uint256) {\n', '        return (_name, _version);\n', '    }\n', '\n', '    function data() view public virtual override returns(address, uint256, bool) {\n', '        return (_ethereumAddress, _maxTokensPerLiquidityPool, _hasUniqueLiquidityPools);\n', '    }\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount = IERC20(liquidityPoolAddress).balanceOf(owner));\n', '    }\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) view public virtual override returns(uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        uint256 numerator = liquidityPoolAmount;\n', '        uint256 denominator;\n', '\n', '        (denominator, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) view public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        uint256 numerator = tokenAmount;\n', '        uint256 denominator;\n', '\n', '        for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '            if(liquidityPoolTokens[i] == tokenAddress) {\n', '                denominator =  tokensAmounts[i];\n', '                break;\n', '            }\n', '        }\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function calculatePercentage(uint256 amount, uint256 numerator, uint256 denominator) internal virtual pure returns(uint256) {\n', '        return (amount * numerator) / denominator;\n', '    }\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address receiver) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        require(tokenAddresses.length > 1 && tokenAddresses.length == amounts.length && (_maxTokensPerLiquidityPool == 0 || tokenAddresses.length == _maxTokensPerLiquidityPool), "Invalid length");\n', '        if(_hasUniqueLiquidityPools) {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = this.byTokens(tokenAddresses);\n', '            if(liquidityPoolAddress != address(0)) {\n', '                (liquidityPoolAmount, tokensAmounts, orderedTokens) = addLiquidity(LiquidityPoolData(\n', '                    liquidityPoolAddress,\n', '                    amounts[0],\n', '                    tokenAddresses[0],\n', '                    false,\n', '                    involvingETH,\n', '                    receiver\n', '                ));\n', '                return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '            }\n', '        }\n', '        address liquidityPoolCreator = _getLiquidityPoolCreator(tokenAddresses, amounts, involvingETH);\n', '        _transferToMeAndCheckAllowance(tokenAddresses, amounts, liquidityPoolCreator, involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = _createLiquidityPoolAndAddLiquidity(tokenAddresses, amounts, involvingETH, liquidityPoolCreator, receiver);\n', '        emit NewLiquidityPoolAddress(liquidityPoolAddress);\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData memory data) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        _transferToMeAndCheckAllowance(liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens, processedLiquidityPoolData.tokensAmounts, processedLiquidityPoolData.liquidityPoolOperator, data.involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts) = _addLiquidity(processedLiquidityPoolData);\n', '        _flushBack(liquidityPoolTokens);\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] memory data) payable public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            liquidityPoolTokens[i] = (processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i])).liquidityPoolTokens;\n', '            for(uint256 z = 0; z < liquidityPoolTokens[i].length; z++) {\n', '                _collect(liquidityPoolTokens[i][z], processedLiquidityPoolDataArray[i].tokensAmounts[z], processedLiquidityPoolDataArray[i].liquidityPoolOperator, processedLiquidityPoolDataArray[i].involvingETH);\n', '            }\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        _collect(_ethereumAddress, 0, address(0), false);\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _addLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function removeLiquidity(LiquidityPoolData memory data) public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens;\n', '        _transferToMeAndCheckAllowance(processedLiquidityPoolData.liquidityPoolAddress, processedLiquidityPoolData.liquidityPoolAmount, processedLiquidityPoolData.liquidityPoolOperator);\n', '        (liquidityPoolAmount, tokensAmounts) = _removeLiquidity(processedLiquidityPoolData);\n', '        _flushBack(processedLiquidityPoolData.liquidityPoolAddress);\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] memory data) public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i]);\n', '            liquidityPoolTokens[i] = processedLiquidityPoolDataArray[i].liquidityPoolTokens;\n', '            _collect(processedLiquidityPoolDataArray[i].liquidityPoolAddress, processedLiquidityPoolDataArray[i].liquidityPoolAmount, processedLiquidityPoolDataArray[i].liquidityPoolOperator, false);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _removeLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function swapLiquidity(SwapData memory data) payable public virtual override returns(uint256 outputAmount) {\n', '        ProcessedSwapData memory processedSwapData = _processSwapData(data);\n', '        _transferToMeAndCheckAllowance(processedSwapData.inputToken == _ethereumAddress && processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken, processedSwapData.amount, processedSwapData.liquidityPoolOperator);\n', '        outputAmount = _swapLiquidity(processedSwapData);\n', '        _flushBack(processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken);\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] memory data) payable public virtual override returns(uint256[] memory outputAmounts) {\n', '        ProcessedSwapData[] memory processedSwapDatas = new ProcessedSwapData[](data.length);\n', '        outputAmounts = new uint256[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedSwapDatas[i] = _processSwapData(data[i]);\n', '            _collect(processedSwapDatas[i].inputToken, processedSwapDatas[i].amount, processedSwapDatas[i].liquidityPoolOperator, processedSwapDatas[i].enterInETH);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            outputAmounts[i] = _swapLiquidity(processedSwapDatas[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address liquidityPoolAddress, address[] memory liquidityPoolTokens) internal virtual view returns(address);\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal virtual returns(uint256 outputAmount);\n', '\n', '    function _getLiquidityPoolCreator(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH) internal virtual view returns(address);\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address operator, address receiver) internal virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens);\n', '\n', '    function _processLiquidityPoolData(LiquidityPoolData memory data) internal view returns(ProcessedLiquidityPoolData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        uint256[] memory tokensAmounts;\n', '        address[] memory liquidityPoolTokens;\n', '        uint256 liquidityPoolAmount;\n', '        if(data.amountIsLiquidityPool) {\n', '            (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(data.liquidityPoolAddress, liquidityPoolAmount = data.amount);\n', '        } else {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = byTokenAmount(data.liquidityPoolAddress, data.tokenAddress, data.amount);\n', '        }\n', '        bool involvingETH = data.involvingETH;\n', '        if(_ethereumAddress == address(0)) {\n', '            involvingETH = false;\n', '            for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '                if(liquidityPoolTokens[i] == address(0)) {\n', '                    involvingETH = true;\n', '                }\n', '            }\n', '        }\n', '        return ProcessedLiquidityPoolData(\n', '            data.liquidityPoolAddress,\n', '            liquidityPoolAmount,\n', '            liquidityPoolTokens,\n', '            tokensAmounts,\n', '            involvingETH,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddress, liquidityPoolTokens),\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _processSwapData(SwapData memory data) internal view returns(ProcessedSwapData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        require(data.path.length > 0 && data.liquidityPoolAddresses.length == data.path.length, "Invalid length");\n', '        ( , ,address[] memory liquidityPoolTokens) = this.byLiquidityPool(data.liquidityPoolAddresses[0]);\n', '        return ProcessedSwapData(\n', '            data.enterInETH && data.inputToken == _ethereumAddress,\n', '            data.exitInETH && data.path[data.path.length - 1] == _ethereumAddress,\n', '            data.liquidityPoolAddresses,\n', '            data.path,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddresses[0], liquidityPoolTokens),\n', '            data.inputToken,\n', '            data.amount,\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _collect(address tokenAddress, uint256 tokenAmount, address operator, bool involvingETH) private {\n', '        address realTokenAddress = involvingETH && tokenAddress == _ethereumAddress ? address(0) : tokenAddress;\n', '        uint256 position = _tokenIndex[realTokenAddress];\n', '        if(_tokensToTransfer.length == 0 || _tokensToTransfer[position] != realTokenAddress) {\n', '            _tokenIndex[realTokenAddress] = (position = _tokensToTransfer.length);\n', '            _tokensToTransfer.push(realTokenAddress);\n', '            _operators.push(operator);\n', '            _tokenAmounts.push(0);\n', '        }\n', '        _tokenAmounts[position] = _tokenAmounts[position] + tokenAmount;\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address[] memory tokens, uint256[] memory amounts, address operator, bool involvingETH) internal {\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            _transferToMeAndCheckAllowance(involvingETH && tokens[i] == _ethereumAddress ? address(0) : tokens[i] , amounts[i], operator);\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address tokenAddress, uint256 value, address operator) internal {\n', '        _transferToMe(tokenAddress, value);\n', '        _checkAllowance(tokenAddress, value, operator);\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            _transferToMeAndCheckAllowance(_tokensToTransfer[i], _tokenAmounts[i], _operators[i]);\n', '        }\n', '    }\n', '\n', '    function _flushBackAndClear() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            delete _tokenIndex[_tokensToTransfer[i]];\n', '            _flushBack(_tokensToTransfer[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        delete _tokensToTransfer;\n', '        delete _operators;\n', '        delete _tokenAmounts;\n', '    }\n', '\n', '    function _transferToMe(address tokenAddress, uint256 value) internal virtual {\n', '        if(tokenAddress == address(0)) {\n', '            require(msg.value == value, "Incorrect eth value");\n', '            return;\n', '        }\n', '        _safeTransferFrom(tokenAddress, msg.sender, address(this), value);\n', '    }\n', '\n', '    function _flushBack(address[] memory tokenAddresses) internal {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            _flushBack(tokenAddresses[i]);\n', '        }\n', '        _flushBack(address(0));\n', '    }\n', '\n', '    function _flushBack(address tokenAddress) internal {\n', '        uint256 amount = tokenAddress == address(0) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if(tokenAddress == address(0)) {\n', '            if(address(this).balance >= amount) {\n', '                payable(msg.sender).transfer(amount);\n', '            }\n', '            return;\n', '        }\n', '        if(IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\n', '            _safeTransfer(tokenAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function _checkAllowance(address tokenAddress, uint256 value, address operator) private {\n', '        if(tokenAddress == address(0) || operator == address(0)) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if(token.allowance(address(this), operator) <= value) {\n', '            _safeApprove(tokenAddress, operator, token.totalSupply());\n', '        }\n', '    }\n', '\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\UniswapV2\\1\\UniswapV2AMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'contract UniswapV2AMMV1 is IUniswapV2AMMV1, AMM {\n', '\n', '    address private _uniswapV2RouterAddress;\n', '\n', '    address private _wethAddress;\n', '\n', '    constructor(address uniswapV2RouterAddress) AMM("UniswapV2", 1, _wethAddress = IUniswapV2Router(_uniswapV2RouterAddress = uniswapV2RouterAddress).WETH(), 2, true) {\n', '    }\n', '\n', '    function factory() private view returns (address) {\n', '        return IUniswapV2Router(_uniswapV2RouterAddress).factory();\n', '    }\n', '\n', '    function uniswapData() public virtual override view returns(address routerAddress, address wethAddress) {\n', '        routerAddress = _uniswapV2RouterAddress;\n', '        wethAddress = _wethAddress;\n', '    }\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokenAddresses) {\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(liquidityPoolAddress);\n', '\n', '        address token0 = pair.token0();\n', '        address token1 = pair.token1();\n', '        if(IUniswapV2Factory(factory()).getPair(token0, token1) != liquidityPoolAddress) {\n', '            return(0, new uint256[](0), new address[](0));\n', '        }\n', '\n', '        liquidityPoolAmount = pair.totalSupply();\n', '\n', '        tokensAmounts = new uint256[](2);\n', '        (uint256 amountA, uint256 amountB,) = pair.getReserves();\n', '        tokensAmounts[0] = amountA;\n', '        tokensAmounts[1] = amountB;\n', '\n', '        tokenAddresses = new address[](2);\n', '        tokenAddresses[0] = token0;\n', '        tokenAddresses[1] = token1;\n', '    }\n', '\n', '    function byTokens(address[] memory tokenAddresses) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(liquidityPoolAddress = IUniswapV2Factory(factory()).getPair(tokenAddresses[0], tokenAddresses[1]));\n', '\n', '        if(address(pair) == address(0)) {\n', '            return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '        }\n', '\n', '        liquidityPoolAmount = pair.totalSupply();\n', '\n', '        tokensAmounts = new uint256[](2);\n', '        (uint256 amountA, uint256 amountB,) = pair.getReserves();\n', '        tokensAmounts[0] = amountA;\n', '        tokensAmounts[1] = amountB;\n', '\n', '        orderedTokens = new address[](2);\n', '        orderedTokens[0] = pair.token0();\n', '        orderedTokens[1] = pair.token1();\n', '    }\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view public virtual override returns(uint256[] memory) {\n', '        address[] memory realPath = new address[](path.length + 1);\n', '        realPath[0] = tokenAddress;\n', '        for(uint256 i = 0; i < path.length; i++) {\n', '            realPath[i + 1] = path[i];\n', '        }\n', '        return IUniswapV2Router(_uniswapV2RouterAddress).getAmountsOut(tokenAmount, realPath);\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address, address[] memory) internal override virtual view returns(address) {\n', '        return _uniswapV2RouterAddress;\n', '    }\n', '\n', '    function _getLiquidityPoolCreator(address[] memory, uint256[] memory, bool) internal virtual view override returns(address) {\n', '        return _uniswapV2RouterAddress;\n', '    }\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address, address receiver) internal virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        tokensAmounts = new uint256[](2);\n', '        orderedTokens = new address[](2);\n', '        if(!involvingETH) {\n', '            (tokensAmounts[0], tokensAmounts[1], liquidityPoolAmount) = IUniswapV2Router(_uniswapV2RouterAddress).addLiquidity(\n', '                tokenAddresses[0],\n', '                tokenAddresses[1],\n', '                amounts[0],\n', '                amounts[1],\n', '                1,\n', '                1,\n', '                receiver,\n', '                block.timestamp + 10000\n', '            );\n', '        } else {\n', '            address token = tokenAddresses[0] != _wethAddress ? tokenAddresses[0] : tokenAddresses[1];\n', '            uint256 amountTokenDesired = tokenAddresses[0] != _wethAddress ? amounts[0] : amounts[1];\n', '            uint256 amountETHDesired = tokenAddresses[0] == _wethAddress ? amounts[0] : amounts[1];\n', '            (tokensAmounts[0], tokensAmounts[1], liquidityPoolAmount) = IUniswapV2Router(_uniswapV2RouterAddress).addLiquidityETH {value : amountETHDesired} (\n', '                token,\n', '                amountTokenDesired,\n', '                1,\n', '                1,\n', '                receiver,\n', '                block.timestamp + 10000\n', '            );\n', '        }\n', '        IUniswapV2Pair pair = IUniswapV2Pair(liquidityPoolAddress = IUniswapV2Factory(factory()).getPair(tokenAddresses[0], tokenAddresses[1]));\n', '        orderedTokens[0] = pair.token0();\n', '        orderedTokens[1] = pair.token1();\n', '    }\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '        tokensAmounts = new uint256[](2);\n', '        if(!processedLiquidityPoolData.involvingETH) {\n', '            (tokensAmounts[0], tokensAmounts[1], liquidityPoolAmount) = IUniswapV2Router(_uniswapV2RouterAddress).addLiquidity(\n', '                processedLiquidityPoolData.liquidityPoolTokens[0],\n', '                processedLiquidityPoolData.liquidityPoolTokens[1],\n', '                processedLiquidityPoolData.tokensAmounts[0],\n', '                processedLiquidityPoolData.tokensAmounts[1],\n', '                1,\n', '                1,\n', '                processedLiquidityPoolData.receiver,\n', '                block.timestamp + 10000\n', '            );\n', '        } else {\n', '            address token = processedLiquidityPoolData.liquidityPoolTokens[0] != _wethAddress ? processedLiquidityPoolData.liquidityPoolTokens[0] : processedLiquidityPoolData.liquidityPoolTokens[1];\n', '            uint256 amountTokenDesired = processedLiquidityPoolData.liquidityPoolTokens[0] != _wethAddress ? processedLiquidityPoolData.tokensAmounts[0] : processedLiquidityPoolData.tokensAmounts[1];\n', '            uint256 amountETHDesired = processedLiquidityPoolData.liquidityPoolTokens[0] == _wethAddress ? processedLiquidityPoolData.tokensAmounts[0] : processedLiquidityPoolData.tokensAmounts[1];\n', '            (tokensAmounts[0], tokensAmounts[1], liquidityPoolAmount) = IUniswapV2Router(_uniswapV2RouterAddress).addLiquidityETH {value : amountETHDesired} (\n', '                token,\n', '                amountTokenDesired,\n', '                1,\n', '                1,\n', '                processedLiquidityPoolData.receiver,\n', '                block.timestamp + 10000\n', '            );\n', '        }\n', '    }\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '\n', '        liquidityPoolAmount = processedLiquidityPoolData.liquidityPoolAmount;\n', '\n', '        tokensAmounts = new uint256[](2);\n', '        uint256 amount0;\n', '        uint256 amount1;\n', '        if(!processedLiquidityPoolData.involvingETH) {\n', '            (amount0, amount1) = IUniswapV2Router(_uniswapV2RouterAddress).removeLiquidity(processedLiquidityPoolData.liquidityPoolTokens[0], processedLiquidityPoolData.liquidityPoolTokens[1], processedLiquidityPoolData.liquidityPoolAmount, 1, 1, processedLiquidityPoolData.receiver, block.timestamp + 1000);\n', '        } else {\n', '            (amount0, amount1) = IUniswapV2Router(_uniswapV2RouterAddress).removeLiquidityETH(processedLiquidityPoolData.liquidityPoolTokens[0] != _wethAddress ? processedLiquidityPoolData.liquidityPoolTokens[0] : processedLiquidityPoolData.liquidityPoolTokens[1], processedLiquidityPoolData.liquidityPoolAmount, 1, 1, processedLiquidityPoolData.receiver, block.timestamp + 1000);\n', '        }\n', '        tokensAmounts[0] = amount0;\n', '        tokensAmounts[1] = amount1;\n', '    }\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal override virtual returns(uint256 outputAmount) {\n', '        address[] memory path = new address[](data.path.length + 1);\n', '        path[0] = data.enterInETH ? _wethAddress : data.inputToken;\n', '        for(uint256 i = 0; i < data.path.length; i++) {\n', '            path[i + 1] = data.path[i];\n', '        }\n', '        if(data.exitInETH) {\n', '            path[path.length - 1] = _wethAddress;\n', '        }\n', '        if(!data.enterInETH && !data.exitInETH) {\n', '            return IUniswapV2Router(_uniswapV2RouterAddress).swapExactTokensForTokens(data.amount, 1, path, data.receiver, block.timestamp + 1000)[path.length - 1];\n', '        }\n', '        if(data.enterInETH) {\n', '            return IUniswapV2Router(_uniswapV2RouterAddress).swapExactETHForTokens{value : data.amount}(1, path, data.receiver, block.timestamp + 1000)[path.length - 1];\n', '        }\n', '        if(data.exitInETH) {\n', '            return IUniswapV2Router(_uniswapV2RouterAddress).swapExactTokensForETH(data.amount, 1, path, data.receiver, block.timestamp + 1000)[path.length - 1];\n', '        }\n', '        return 0;\n', '    }\n', '}']