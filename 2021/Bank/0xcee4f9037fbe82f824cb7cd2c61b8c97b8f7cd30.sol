['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-23\n', '*/\n', '\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function withdraw(uint256) external;\n', '}\n', '\n', 'interface UniswapFactory {\n', '    function getPair(address tokenA, address tokenB) external view returns(address);\n', '}\n', '\n', 'interface UniswapProxy {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '        \n', '    \n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    \n', '        function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '    \n', '}\n', '\n', 'interface UniswapPair {\n', '    function token0() external pure returns (address);\n', '\n', '    function token1() external pure returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 _reserve0,\n', '            uint112 _reserve1,\n', '            uint32 _blockTimestampLast\n', '        );\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface CurveZap {\n', '    function add_liquidity(uint256[2] calldata uamounts, uint256 min_mint_amount) external;\n', '    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_uamount) external;\n', '}\n', '\n', 'interface CurveMinter {\n', '    function mint(address gauge) external;\n', '}\n', '\n', 'interface CurveGauge {\n', '    function deposit(uint256 _amount) external;\n', '    function withdraw(uint256 _amount) external;\n', '    function balanceOf(address _owner) external view returns(uint256);\n', '    function claimable_tokens(address _owner) external view returns(uint256);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '      uint size;\n', '      assembly { size := extcodesize(account) }\n', '      return size > 0;\n', '    }\n', '\n', '    function toPayable(address account)\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address payable public owner;\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', 'contract DaiCrv is Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    \n', '    mapping(address=>bool) administrators;\n', '    \n', '    modifier onlyAdmin() {\n', '        require(owner == msg.sender || administrators[msg.sender] == true, "Admin: caller is not admin or owner");\n', '        _;\n', '    }\n', ' \n', '    UniswapProxy constant uniswapRouter = UniswapProxy(\n', '        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '    );\n', '\n', '    UniswapFactory constant uniswapFactory = UniswapFactory(\n', '        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\n', '    );\n', '\n', '    /* Direccion de WETH */\n', '    address private constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    \n', '    /* Direccion de DAI */\n', '    address private constant dai  = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    \n', '    /* Direccion de CRV */\n', '    address private constant crv  = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n', '    \n', '    address private constant crvCompound = 0xeB21209ae4C2c9FF2a86ACA31E123764A3B6Bc06;\n', '    address private constant crvMinter = 0xd061D61a4d941c39E5453435B6345Dc261C2fcE0;\n', '    address private constant crvCompoundGauge = 0x7ca5b0a2910B33e9759DC7dDB0413949071D7575;\n', '    \n', '    address private constant crvcDaicUsdc = 0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2;\n', '    \n', '    uint256 private constant deadline = 0xf000000000000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant max = uint256(-1);\n', '\n', '\n', '    uint256 public dai_invested;\n', '    uint256 public dai_divested;\n', '\n', '    function changeOwner(address payable _newowner) external onlyOwner {\n', '        owner = _newowner;\n', '    }\n', '\n', '    function addAdmin(address _admin) external onlyOwner { \n', '        administrators[_admin] = true;\n', '    }\n', '    \n', '    function removeAdmin(address _admin) external onlyOwner {\n', '        administrators[_admin] = false;\n', '    }\n', '\n', '\n', '    function approves() external onlyOwner {\n', '        require(IERC20(dai).approve(crvCompound, max), "Unable o approve dai");\n', '        require(IERC20(crvcDaicUsdc).approve(crvCompoundGauge, max), "Unable to approve cDai + cUsdc to Gauge");\n', '        require(IERC20(crvcDaicUsdc).approve(crvCompound, max), "Unable to approve cDai + cUsdc to crvCompound");\n', '    }\n', '\n', '\n', '    event CallerRespose(\n', '        bool success\n', '    );\n', '\n', '    /* \n', '       1- Hace el Claim de los CRV\n', '       2- Transforma los CRV en DAI utilizando Uniswap\n', '       3- Invierte nuevamente los DAI\n', '    */\n', '    \n', '    function loop() external onlyAdmin {\n', '        loop_internal();\n', '    }\n', '    \n', '    function loop_internal() internal {\n', '        uint256 daiToInvest = claimAndSwap();\n', '        \n', '        if (daiToInvest > 0) {\n', '            invest_balance();\n', '        }\n', '    }\n', '\n', '    \n', '    function invest_balance() internal returns(uint256) {\n', '        uint256[2] memory amounts;\n', '        uint256 lp_balance;\n', '        uint256 amount = IERC20(dai).balanceOf(address(this));\n', '        \n', '        dai_invested = dai_invested + amount;\n', '        \n', '         /* Solamente se permite invertir DAI */\n', '        amounts[0] = amount;\n', '        amounts[1] = 0;\n', '    \n', '        /* Agrega liquidez */\n', '        CurveZap(crvCompound).add_liquidity(amounts, 1);\n', '\n', '        /* Consulta los LP resultantes de proveer liquidez cDAI+cUSDC */\n', '        lp_balance = IERC20(crvcDaicUsdc).balanceOf(address(this));\n', '\n', '        /* Hace el stake */\n', '        CurveGauge(crvCompoundGauge).deposit(lp_balance);\n', '\n', '        return amount;\n', '    }\n', '\n', '    function invest(uint256 amount) external onlyAdmin {\n', '        uint256 invested;\n', '        require(IERC20(dai).transferFrom(msg.sender, address(this), amount), "Unable to transferFrom");\n', '        invested = invest_balance();\n', '    }\n', '\n', '\n', '    function divest_all() external onlyAdmin {\n', '        uint256 _balance;\n', '        claimAndSwap();\n', '        \n', '        _balance = CurveGauge(crvCompoundGauge).balanceOf(address(this));\n', '        CurveGauge(crvCompoundGauge).withdraw(_balance);\n', '        CurveZap(crvCompound).remove_liquidity_one_coin(_balance, 0, _balance);\n', '\n', '        _balance = IERC20(dai).balanceOf(address(this));\n', '        dai_divested = dai_divested + _balance;\n', '        require(IERC20(dai).transfer(msg.sender, _balance), "Unable to send founds");\n', '        \n', '    }\n', '\n', '    function divest_ratio(uint256 ratio, bool claim_and_invest) external onlyAdmin {\n', '        uint256 _balance;\n', '        \n', '        require(ratio > 0 && ratio <= 100, "Invalid ratio");\n', '        \n', '        if (claim_and_invest == true) {\n', '            loop_internal();\n', '        }\n', '        \n', '        _balance = CurveGauge(crvCompoundGauge).balanceOf(address(this));\n', '        \n', '        _balance = ratio * _balance / 100;\n', '        \n', '        CurveGauge(crvCompoundGauge).withdraw(_balance);\n', '        CurveZap(crvCompound).remove_liquidity_one_coin(_balance, 0, _balance);\n', '\n', '        _balance = IERC20(dai).balanceOf(address(this));\n', '        dai_divested = dai_divested + _balance;\n', '        require(IERC20(dai).transfer(msg.sender, _balance), "Unable to send founds");\n', '        \n', '    }\n', '\n', '\n', '    function balance() external view returns(uint256) {\n', '      return CurveGauge(crvCompoundGauge).balanceOf(address(this));\n', '    }\n', '\n', '\n', '    function claimAndSwap() internal returns(uint256) {\n', '        uint256 crvBalance;\n', '\n', '        /* Hace el claim */\n', '        CurveMinter(crvMinter).mint(crvCompoundGauge);\n', '        \n', '        /* Consultamos el balance */\n', '        crvBalance = IERC20(crv).balanceOf(address(this));\n', '\n', '        if (crvBalance > 0) {\n', '            /* Transforma el crv en dai */            \n', '            return _token2Token(crv, dai, crvBalance);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '\n', '    function _token2Token(\n', '        address _FromTokenContractAddress,\n', '        address _ToTokenContractAddress,\n', '        uint256 tokens2Trade\n', '    ) internal returns (uint256 tokenBought) {\n', '        if (_FromTokenContractAddress == _ToTokenContractAddress) {\n', '            return tokens2Trade;\n', '        }\n', '\n', '        if (_FromTokenContractAddress == address(0)) {\n', '            if (_ToTokenContractAddress == weth) {\n', '                IWETH(weth).deposit{value:tokens2Trade}();\n', '                return tokens2Trade;\n', '            }\n', '\n', '            address[] memory path = new address[](2);\n', '            path[0] = weth;\n', '            path[1] = _ToTokenContractAddress;\n', '            tokenBought = uniswapRouter.swapExactETHForTokens{value:\n', '                tokens2Trade\n', '            }(1, path, address(this), deadline)[path.length - 1];\n', '        } else if (_ToTokenContractAddress == address(0)) {\n', '            if (_FromTokenContractAddress == weth) {\n', '                IWETH(weth).withdraw(tokens2Trade);\n', '                return tokens2Trade;\n', '            }\n', '\n', '            IERC20(_FromTokenContractAddress).approve(\n', '                address(uniswapRouter),\n', '                tokens2Trade\n', '            );\n', '\n', '            address[] memory path = new address[](2);\n', '            path[0] = _FromTokenContractAddress;\n', '            path[1] = weth;\n', '            tokenBought = uniswapRouter.swapExactTokensForETH(\n', '                tokens2Trade,\n', '                1,\n', '                path,\n', '                address(this),\n', '                deadline\n', '            )[path.length - 1];\n', '        } else {\n', '            IERC20(_FromTokenContractAddress).approve(\n', '                address(uniswapRouter),\n', '                tokens2Trade\n', '            );\n', '\n', '            if (_FromTokenContractAddress != weth) {\n', '                if (_ToTokenContractAddress != weth) {\n', '                    // check output via tokenA -> tokenB\n', '                    address pairA = uniswapFactory.getPair(\n', '                        _FromTokenContractAddress,\n', '                        _ToTokenContractAddress\n', '                    );\n', '                    address[] memory pathA = new address[](2);\n', '                    pathA[0] = _FromTokenContractAddress;\n', '                    pathA[1] = _ToTokenContractAddress;\n', '                    uint256 amtA;\n', '                    if (pairA != address(0)) {\n', '                        amtA = uniswapRouter.getAmountsOut(\n', '                            tokens2Trade,\n', '                            pathA\n', '                        )[1];\n', '                    }\n', '\n', '                    // check output via tokenA -> weth -> tokenB\n', '                    address[] memory pathB = new address[](3);\n', '                    pathB[0] = _FromTokenContractAddress;\n', '                    pathB[1] = weth;\n', '                    pathB[2] = _ToTokenContractAddress;\n', '\n', '                    uint256 amtB = uniswapRouter.getAmountsOut(\n', '                        tokens2Trade,\n', '                        pathB\n', '                    )[2];\n', '\n', '                    if (amtA >= amtB) {\n', '                        tokenBought = uniswapRouter.swapExactTokensForTokens(\n', '                            tokens2Trade,\n', '                            1,\n', '                            pathA,\n', '                            address(this),\n', '                            deadline\n', '                        )[pathA.length - 1];\n', '                    } else {\n', '                        tokenBought = uniswapRouter.swapExactTokensForTokens(\n', '                            tokens2Trade,\n', '                            1,\n', '                            pathB,\n', '                            address(this),\n', '                            deadline\n', '                        )[pathB.length - 1];\n', '                    }\n', '                } else {\n', '                    address[] memory path = new address[](2);\n', '                    path[0] = _FromTokenContractAddress;\n', '                    path[1] = weth;\n', '\n', '                    tokenBought = uniswapRouter.swapExactTokensForTokens(\n', '                        tokens2Trade,\n', '                        1,\n', '                        path,\n', '                        address(this),\n', '                        deadline\n', '                    )[path.length - 1];\n', '                }\n', '            } else {\n', '                address[] memory path = new address[](2);\n', '                path[0] = weth;\n', '                path[1] = _ToTokenContractAddress;\n', '                tokenBought = uniswapRouter.swapExactTokensForTokens(\n', '                    tokens2Trade,\n', '                    1,\n', '                    path,\n', '                    address(this),\n', '                    deadline\n', '                )[path.length - 1];\n', '            }\n', '        }\n', '        require(tokenBought > 0, "Error Swapping Tokens");\n', '    }\n', '\n', '\n', '    function withdrawToken(IERC20 _TokenAddress) public onlyOwner {\n', '        uint256 qty = _TokenAddress.balanceOf(address(this));\n', '        _TokenAddress.transfer(owner, qty);\n', '    }\n', '\n', '    function withdraw() public onlyOwner {\n', '        uint256 contractBalance = address(this).balance;\n', '        address payable _to = owner;\n', '        _to.transfer(contractBalance);\n', '    }\n', '    \n', '    function caller(address _contract, bytes calldata _data) external onlyOwner {\n', '        (bool success, bytes memory data) = _contract.call(_data);\n', '        emit CallerRespose(success);\n', '    }\n', '    \n', '}']