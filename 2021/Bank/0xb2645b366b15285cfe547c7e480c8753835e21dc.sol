['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-30\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\UniswapV3\\1\\IUniswapV3AMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IUniswapV3AMMV1 is IAMM {\n', '\n', '    function uniswapData() external view returns(address factoryAddress, address swapRouterAddress, address nonFungiblePositionManagerAddress, address wethAddress);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'abstract contract AMM is IAMM {\n', '\n', '    struct ProcessedLiquidityPoolData {\n', '        address liquidityPoolAddress;\n', '        uint256 liquidityPoolAmount;\n', '        address[] liquidityPoolTokens;\n', '        uint256[] tokensAmounts;\n', '        bool involvingETH;\n', '        address liquidityPoolOperator;\n', '        address receiver;\n', '    }\n', '\n', '    struct ProcessedSwapData {\n', '        bool enterInETH;\n', '        bool exitInETH;\n', '        address[] liquidityPoolAddresses;\n', '        address[] path;\n', '        address liquidityPoolOperator;\n', '        address inputToken;\n', '        uint256 amount;\n', '        address receiver;\n', '    }\n', '\n', '    mapping(address => uint256) private _tokenIndex;\n', '    address[] private _tokensToTransfer;\n', '    address[] private _operators;\n', '    uint256[] private _tokenAmounts;\n', '\n', '    string internal _name;\n', '    uint256 internal immutable _version;\n', '    address internal immutable _ethereumAddress;\n', '    uint256 internal immutable _maxTokensPerLiquidityPool;\n', '    bool internal immutable _hasUniqueLiquidityPools;\n', '\n', '    constructor(string memory name, uint256 version, address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools) {\n', '        _name = name;\n', '        _version = version;\n', '        _ethereumAddress = ethereumAddress;\n', '        _maxTokensPerLiquidityPool = maxTokensPerLiquidityPool;\n', '        _hasUniqueLiquidityPools = hasUniqueLiquidityPools;\n', '    }\n', '\n', '    receive() external virtual payable {\n', '    }\n', '\n', '    function info() view public virtual override returns(string memory, uint256) {\n', '        return (_name, _version);\n', '    }\n', '\n', '    function data() view public virtual override returns(address, uint256, bool) {\n', '        return (_ethereumAddress, _maxTokensPerLiquidityPool, _hasUniqueLiquidityPools);\n', '    }\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount = IERC20(liquidityPoolAddress).balanceOf(owner));\n', '    }\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) view public virtual override returns(uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        uint256 numerator = liquidityPoolAmount;\n', '        uint256 denominator;\n', '\n', '        (denominator, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) view public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        uint256 numerator = tokenAmount;\n', '        uint256 denominator;\n', '\n', '        for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '            if(liquidityPoolTokens[i] == tokenAddress) {\n', '                denominator =  tokensAmounts[i];\n', '                break;\n', '            }\n', '        }\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function calculatePercentage(uint256 amount, uint256 numerator, uint256 denominator) internal virtual pure returns(uint256) {\n', '        return (amount * numerator) / denominator;\n', '    }\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address receiver) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        require(tokenAddresses.length > 1 && tokenAddresses.length == amounts.length && (_maxTokensPerLiquidityPool == 0 || tokenAddresses.length == _maxTokensPerLiquidityPool), "Invalid length");\n', '        if(_hasUniqueLiquidityPools) {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = this.byTokens(tokenAddresses);\n', '            if(liquidityPoolAddress != address(0)) {\n', '                (liquidityPoolAmount, tokensAmounts, orderedTokens) = addLiquidity(LiquidityPoolData(\n', '                    liquidityPoolAddress,\n', '                    amounts[0],\n', '                    tokenAddresses[0],\n', '                    false,\n', '                    involvingETH,\n', '                    receiver\n', '                ));\n', '                return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '            }\n', '        }\n', '        address liquidityPoolCreator = _getLiquidityPoolCreator(tokenAddresses, amounts, involvingETH);\n', '        _transferToMeAndCheckAllowance(tokenAddresses, amounts, liquidityPoolCreator, involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = _createLiquidityPoolAndAddLiquidity(tokenAddresses, amounts, involvingETH, liquidityPoolCreator, receiver);\n', '        emit NewLiquidityPoolAddress(liquidityPoolAddress);\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData memory data) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        _transferToMeAndCheckAllowance(liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens, processedLiquidityPoolData.tokensAmounts, processedLiquidityPoolData.liquidityPoolOperator, data.involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts) = _addLiquidity(processedLiquidityPoolData);\n', '        _flushBack(liquidityPoolTokens);\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] memory data) payable public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            liquidityPoolTokens[i] = (processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i])).liquidityPoolTokens;\n', '            for(uint256 z = 0; z < liquidityPoolTokens[i].length; z++) {\n', '                _collect(liquidityPoolTokens[i][z], processedLiquidityPoolDataArray[i].tokensAmounts[z], processedLiquidityPoolDataArray[i].liquidityPoolOperator, processedLiquidityPoolDataArray[i].involvingETH);\n', '            }\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        _collect(_ethereumAddress, 0, address(0), false);\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _addLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function removeLiquidity(LiquidityPoolData memory data) public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens;\n', '        _transferToMeAndCheckAllowance(processedLiquidityPoolData.liquidityPoolAddress, processedLiquidityPoolData.liquidityPoolAmount, processedLiquidityPoolData.liquidityPoolOperator);\n', '        (liquidityPoolAmount, tokensAmounts) = _removeLiquidity(processedLiquidityPoolData);\n', '        _flushBack(processedLiquidityPoolData.liquidityPoolAddress);\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] memory data) public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i]);\n', '            liquidityPoolTokens[i] = processedLiquidityPoolDataArray[i].liquidityPoolTokens;\n', '            _collect(processedLiquidityPoolDataArray[i].liquidityPoolAddress, processedLiquidityPoolDataArray[i].liquidityPoolAmount, processedLiquidityPoolDataArray[i].liquidityPoolOperator, false);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _removeLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function swapLiquidity(SwapData memory data) payable public virtual override returns(uint256 outputAmount) {\n', '        ProcessedSwapData memory processedSwapData = _processSwapData(data);\n', '        _transferToMeAndCheckAllowance(processedSwapData.inputToken == _ethereumAddress && processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken, processedSwapData.amount, processedSwapData.liquidityPoolOperator);\n', '        outputAmount = _swapLiquidity(processedSwapData);\n', '        _flushBack(processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken);\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] memory data) payable public virtual override returns(uint256[] memory outputAmounts) {\n', '        ProcessedSwapData[] memory processedSwapDatas = new ProcessedSwapData[](data.length);\n', '        outputAmounts = new uint256[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedSwapDatas[i] = _processSwapData(data[i]);\n', '            _collect(processedSwapDatas[i].inputToken, processedSwapDatas[i].amount, processedSwapDatas[i].liquidityPoolOperator, processedSwapDatas[i].enterInETH);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            outputAmounts[i] = _swapLiquidity(processedSwapDatas[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address liquidityPoolAddress, address[] memory liquidityPoolTokens) internal virtual view returns(address);\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal virtual returns(uint256 outputAmount);\n', '\n', '    function _getLiquidityPoolCreator(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH) internal virtual view returns(address);\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address operator, address receiver) internal virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens);\n', '\n', '    function _processLiquidityPoolData(LiquidityPoolData memory data) internal view returns(ProcessedLiquidityPoolData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        uint256[] memory tokensAmounts;\n', '        address[] memory liquidityPoolTokens;\n', '        uint256 liquidityPoolAmount;\n', '        if(data.amountIsLiquidityPool) {\n', '            (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(data.liquidityPoolAddress, liquidityPoolAmount = data.amount);\n', '        } else {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = byTokenAmount(data.liquidityPoolAddress, data.tokenAddress, data.amount);\n', '        }\n', '        bool involvingETH = data.involvingETH;\n', '        if(_ethereumAddress == address(0)) {\n', '            involvingETH = false;\n', '            for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '                if(liquidityPoolTokens[i] == address(0)) {\n', '                    involvingETH = true;\n', '                }\n', '            }\n', '        }\n', '        return ProcessedLiquidityPoolData(\n', '            data.liquidityPoolAddress,\n', '            liquidityPoolAmount,\n', '            liquidityPoolTokens,\n', '            tokensAmounts,\n', '            involvingETH,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddress, liquidityPoolTokens),\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _processSwapData(SwapData memory data) internal view returns(ProcessedSwapData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        require(data.path.length > 0 && data.liquidityPoolAddresses.length == data.path.length, "Invalid length");\n', '        ( , ,address[] memory liquidityPoolTokens) = this.byLiquidityPool(data.liquidityPoolAddresses[0]);\n', '        return ProcessedSwapData(\n', '            data.enterInETH && data.inputToken == _ethereumAddress,\n', '            data.exitInETH && data.path[data.path.length - 1] == _ethereumAddress,\n', '            data.liquidityPoolAddresses,\n', '            data.path,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddresses[0], liquidityPoolTokens),\n', '            data.inputToken,\n', '            data.amount,\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _collect(address tokenAddress, uint256 tokenAmount, address operator, bool involvingETH) private {\n', '        address realTokenAddress = involvingETH && tokenAddress == _ethereumAddress ? address(0) : tokenAddress;\n', '        uint256 position = _tokenIndex[realTokenAddress];\n', '        if(_tokensToTransfer.length == 0 || _tokensToTransfer[position] != realTokenAddress) {\n', '            _tokenIndex[realTokenAddress] = (position = _tokensToTransfer.length);\n', '            _tokensToTransfer.push(realTokenAddress);\n', '            _operators.push(operator);\n', '            _tokenAmounts.push(0);\n', '        }\n', '        _tokenAmounts[position] = _tokenAmounts[position] + tokenAmount;\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address[] memory tokens, uint256[] memory amounts, address operator, bool involvingETH) internal {\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            _transferToMeAndCheckAllowance(involvingETH && tokens[i] == _ethereumAddress ? address(0) : tokens[i] , amounts[i], operator);\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address tokenAddress, uint256 value, address operator) internal {\n', '        _transferToMe(tokenAddress, value);\n', '        _checkAllowance(tokenAddress, value, operator);\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            _transferToMeAndCheckAllowance(_tokensToTransfer[i], _tokenAmounts[i], _operators[i]);\n', '        }\n', '    }\n', '\n', '    function _flushBackAndClear() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            delete _tokenIndex[_tokensToTransfer[i]];\n', '            _flushBack(_tokensToTransfer[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        delete _tokensToTransfer;\n', '        delete _operators;\n', '        delete _tokenAmounts;\n', '    }\n', '\n', '    function _transferToMe(address tokenAddress, uint256 value) internal virtual {\n', '        if(tokenAddress == address(0)) {\n', '            require(msg.value == value, "Incorrect eth value");\n', '            return;\n', '        }\n', '        _safeTransferFrom(tokenAddress, msg.sender, address(this), value);\n', '    }\n', '\n', '    function _flushBack(address[] memory tokenAddresses) internal {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            _flushBack(tokenAddresses[i]);\n', '        }\n', '        _flushBack(address(0));\n', '    }\n', '\n', '    function _flushBack(address tokenAddress) internal {\n', '        uint256 amount = tokenAddress == address(0) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if(tokenAddress == address(0)) {\n', '            if(address(this).balance >= amount) {\n', '                (bool result,) = msg.sender.call{value:amount}("");\n', '                require(result, "ETH transfer failed");\n', '            }\n', '            return;\n', '        }\n', '        if(IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\n', '            _safeTransfer(tokenAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function _checkAllowance(address tokenAddress, uint256 value, address operator) private {\n', '        if(tokenAddress == address(0) || operator == address(0)) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if(token.allowance(address(this), operator) <= value) {\n', '            _safeApprove(tokenAddress, operator, token.totalSupply());\n', '        }\n', '    }\n', '\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolImmutables.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that never changes\n', '/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\n', 'interface IUniswapV3PoolImmutables {\n', '    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n', '    /// @return The contract address\n', '    function factory() external view returns (address);\n', '\n', '    /// @notice The first of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token0() external view returns (address);\n', '\n', '    /// @notice The second of the two tokens of the pool, sorted by address\n', '    /// @return The token contract address\n', '    function token1() external view returns (address);\n', '\n', "    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n", '    /// @return The fee\n', '    function fee() external view returns (uint24);\n', '\n', '    /// @notice The pool tick spacing\n', '    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n', '    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n', '    /// This value is an int24 to avoid casting even though it is always positive.\n', '    /// @return The tick spacing\n', '    function tickSpacing() external view returns (int24);\n', '\n', '    /// @notice The maximum amount of position liquidity that can use any tick in the range\n', '    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n', '    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n', '    /// @return The max amount of liquidity per tick\n', '    function maxLiquidityPerTick() external view returns (uint128);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that can change\n', "/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n", '/// per transaction\n', 'interface IUniswapV3PoolState {\n', '    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n', '    /// when accessed externally.\n', '    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n', '    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n', '    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n', '    /// boundary.\n', '    /// observationIndex The index of the last oracle observation that was written,\n', '    /// observationCardinality The current maximum number of observations stored in the pool,\n', '    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n', '    /// feeProtocol The protocol fee for both tokens of the pool.\n', '    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n', '    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n', '    /// unlocked Whether the pool is currently locked to reentrancy\n', '    function slot0()\n', '        external\n', '        view\n', '        returns (\n', '            uint160 sqrtPriceX96,\n', '            int24 tick,\n', '            uint16 observationIndex,\n', '            uint16 observationCardinality,\n', '            uint16 observationCardinalityNext,\n', '            uint8 feeProtocol,\n', '            bool unlocked\n', '        );\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal0X128() external view returns (uint256);\n', '\n', '    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n', '    /// @dev This value can overflow the uint256\n', '    function feeGrowthGlobal1X128() external view returns (uint256);\n', '\n', '    /// @notice The amounts of token0 and token1 that are owed to the protocol\n', '    /// @dev Protocol fees will never exceed uint128 max in either token\n', '    function protocolFees() external view returns (uint128 token0, uint128 token1);\n', '\n', '    /// @notice The currently in range liquidity available to the pool\n', '    /// @dev This value has no relationship to the total liquidity across all ticks\n', '    function liquidity() external view returns (uint128);\n', '\n', '    /// @notice Look up information about a specific tick in the pool\n', '    /// @param tick The tick to look up\n', '    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n', '    /// tick upper,\n', '    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n', '    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n', '    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n', '    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n', '    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n', '    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n', '    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n', '    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n', '    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n', '    /// a specific position.\n', '    function ticks(int24 tick)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 liquidityGross,\n', '            int128 liquidityNet,\n', '            uint256 feeGrowthOutside0X128,\n', '            uint256 feeGrowthOutside1X128,\n', '            int56 tickCumulativeOutside,\n', '            uint160 secondsPerLiquidityOutsideX128,\n', '            uint32 secondsOutside,\n', '            bool initialized\n', '        );\n', '\n', '    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n', '    function tickBitmap(int16 wordPosition) external view returns (uint256);\n', '\n', "    /// @notice Returns the information about a position by the position's key\n", "    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n", '    /// @return _liquidity The amount of liquidity in the position,\n', '    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n', '    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n', '    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n', '    function positions(bytes32 key)\n', '        external\n', '        view\n', '        returns (\n', '            uint128 _liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '\n', '    /// @notice Returns data about a specific observation index\n', '    /// @param index The element of the observations array to fetch\n', '    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n', '    /// ago, rather than at a specific index in the array.\n', '    /// @return blockTimestamp The timestamp of the observation,\n', '    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n', '    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n', '    /// Returns initialized whether the observation has been initialized and the values are safe to use\n', '    function observations(uint256 index)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 blockTimestamp,\n', '            int56 tickCumulative,\n', '            uint160 secondsPerLiquidityCumulativeX128,\n', '            bool initialized\n', '        );\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolDerivedState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Pool state that is not stored\n', '/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n', '/// blockchain. The functions here may have variable gas costs.\n', 'interface IUniswapV3PoolDerivedState {\n', '    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n', '    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n', '    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n', '    /// you must call it with secondsAgos = [3600, 0].\n', '    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n', '    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n', '    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n', '    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n', '    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n', '    /// timestamp\n', '    function observe(uint32[] calldata secondsAgos)\n', '        external\n', '        view\n', '        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n', '\n', '    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n', '    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n', '    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n', '    /// snapshot is taken and the second snapshot is taken.\n', '    /// @param tickLower The lower tick of the range\n', '    /// @param tickUpper The upper tick of the range\n', '    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n', '    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n', '    /// @return secondsInside The snapshot of seconds per liquidity for the range\n', '    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n', '        external\n', '        view\n', '        returns (\n', '            int56 tickCumulativeInside,\n', '            uint160 secondsPerLiquidityInsideX128,\n', '            uint32 secondsInside\n', '        );\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolActions.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissionless pool actions\n', '/// @notice Contains pool methods that can be called by anyone\n', 'interface IUniswapV3PoolActions {\n', '    /// @notice Sets the initial price for the pool\n', '    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n', '    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n', '    function initialize(uint160 sqrtPriceX96) external;\n', '\n', '    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n', '    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n', '    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n', '    /// @param recipient The address for which the liquidity will be created\n', '    /// @param tickLower The lower tick of the position in which to add liquidity\n', '    /// @param tickUpper The upper tick of the position in which to add liquidity\n', '    /// @param amount The amount of liquidity to mint\n', '    /// @param data Any data that should be passed through to the callback\n', '    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n', '    function mint(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount,\n', '        bytes calldata data\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Collects tokens owed to a position\n', '    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n', '    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n', '    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n', '    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n', '    /// @param recipient The address which should receive the fees collected\n', '    /// @param tickLower The lower tick of the position for which to collect fees\n', '    /// @param tickUpper The upper tick of the position for which to collect fees\n', '    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n', '    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(\n', '        address recipient,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '\n', '    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n', '    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n', '    /// @dev Fees must be collected separately via a call to #collect\n', '    /// @param tickLower The lower tick of the position for which to burn liquidity\n', '    /// @param tickUpper The upper tick of the position for which to burn liquidity\n', '    /// @param amount How much liquidity to burn\n', '    /// @return amount0 The amount of token0 sent to the recipient\n', '    /// @return amount1 The amount of token1 sent to the recipient\n', '    function burn(\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 amount\n', '    ) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Swap token0 for token1, or token1 for token0\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n', '    /// @param recipient The address to receive the output of the swap\n', '    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n', '    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n', '    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n', '    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n', '    /// @param data Any data to be passed through to the callback\n', '    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n', '    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n', '    function swap(\n', '        address recipient,\n', '        bool zeroForOne,\n', '        int256 amountSpecified,\n', '        uint160 sqrtPriceLimitX96,\n', '        bytes calldata data\n', '    ) external returns (int256 amount0, int256 amount1);\n', '\n', '    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n', '    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n', '    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n', '    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n', '    /// @param recipient The address which will receive the token0 and token1 amounts\n', '    /// @param amount0 The amount of token0 to send\n', '    /// @param amount1 The amount of token1 to send\n', '    /// @param data Any data to be passed through to the callback\n', '    function flash(\n', '        address recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n', '    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n', '    /// the input observationCardinalityNext.\n', '    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n', '    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolOwnerActions.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Permissioned pool actions\n', '/// @notice Contains pool methods that may only be called by the factory owner\n', 'interface IUniswapV3PoolOwnerActions {\n', "    /// @notice Set the denominator of the protocol's % share of the fees\n", '    /// @param feeProtocol0 new protocol fee for token0 of the pool\n', '    /// @param feeProtocol1 new protocol fee for token1 of the pool\n', '    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n', '\n', '    /// @notice Collect the protocol fee accrued to the pool\n', '    /// @param recipient The address to which collected protocol fees should be sent\n', '    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n', '    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n', '    /// @return amount0 The protocol fee collected in token0\n', '    /// @return amount1 The protocol fee collected in token1\n', '    function collectProtocol(\n', '        address recipient,\n', '        uint128 amount0Requested,\n', '        uint128 amount1Requested\n', '    ) external returns (uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-core\\contracts\\interfaces\\pool\\IUniswapV3PoolEvents.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Events emitted by a pool\n', '/// @notice Contains all events emitted by the pool\n', 'interface IUniswapV3PoolEvents {\n', '    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n', '    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n', '    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n', '    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n', '    event Initialize(uint160 sqrtPriceX96, int24 tick);\n', '\n', '    /// @notice Emitted when liquidity is minted for a given position\n', '    /// @param sender The address that minted the liquidity\n', '    /// @param owner The owner of the position and recipient of any minted liquidity\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity minted to the position range\n', '    /// @param amount0 How much token0 was required for the minted liquidity\n', '    /// @param amount1 How much token1 was required for the minted liquidity\n', '    event Mint(\n', '        address sender,\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted when fees are collected by the owner of a position\n', '    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n', '    /// @param owner The owner of the position for which fees are collected\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount0 The amount of token0 fees collected\n', '    /// @param amount1 The amount of token1 fees collected\n', '    event Collect(\n', '        address indexed owner,\n', '        address recipient,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount0,\n', '        uint128 amount1\n', '    );\n', '\n', "    /// @notice Emitted when a position's liquidity is removed\n", '    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n', '    /// @param owner The owner of the position for which liquidity is removed\n', '    /// @param tickLower The lower tick of the position\n', '    /// @param tickUpper The upper tick of the position\n', '    /// @param amount The amount of liquidity to remove\n', '    /// @param amount0 The amount of token0 withdrawn\n', '    /// @param amount1 The amount of token1 withdrawn\n', '    event Burn(\n', '        address indexed owner,\n', '        int24 indexed tickLower,\n', '        int24 indexed tickUpper,\n', '        uint128 amount,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any swaps between token0 and token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the output of the swap\n', '    /// @param amount0 The delta of the token0 balance of the pool\n', '    /// @param amount1 The delta of the token1 balance of the pool\n', '    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n', '    /// @param liquidity The liquidity of the pool after the swap\n', '    /// @param tick The log base 1.0001 of price of the pool after the swap\n', '    event Swap(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        int256 amount0,\n', '        int256 amount1,\n', '        uint160 sqrtPriceX96,\n', '        uint128 liquidity,\n', '        int24 tick\n', '    );\n', '\n', '    /// @notice Emitted by the pool for any flashes of token0/token1\n', '    /// @param sender The address that initiated the swap call, and that received the callback\n', '    /// @param recipient The address that received the tokens from flash\n', '    /// @param amount0 The amount of token0 that was flashed\n', '    /// @param amount1 The amount of token1 that was flashed\n', '    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n', '    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n', '    event Flash(\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        uint256 paid0,\n', '        uint256 paid1\n', '    );\n', '\n', '    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n', '    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n', '    /// just before a mint/swap/burn.\n', '    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n', '    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n', '    event IncreaseObservationCardinalityNext(\n', '        uint16 observationCardinalityNextOld,\n', '        uint16 observationCardinalityNextNew\n', '    );\n', '\n', '    /// @notice Emitted when the protocol fee is changed by the pool\n', '    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n', '    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n', '    /// @param feeProtocol0New The updated value of the token0 protocol fee\n', '    /// @param feeProtocol1New The updated value of the token1 protocol fee\n', '    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n', '\n', '    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n', '    /// @param sender The address that collects the protocol fees\n', '    /// @param recipient The address that receives the collected protocol fees\n', '    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n', '    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n', '    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n', '}\n', '\n', '// File: @uniswap\\v3-core\\contracts\\interfaces\\IUniswapV3Pool.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title The interface for a Uniswap V3 Pool\n', '/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n', '/// to the ERC20 specification\n', '/// @dev The pool interface is broken up into many smaller pieces\n', 'interface IUniswapV3Pool is\n', '    IUniswapV3PoolImmutables,\n', '    IUniswapV3PoolState,\n', '    IUniswapV3PoolDerivedState,\n', '    IUniswapV3PoolActions,\n', '    IUniswapV3PoolOwnerActions,\n', '    IUniswapV3PoolEvents\n', '{\n', '\n', '}\n', '\n', '// File: @uniswap\\v3-core\\contracts\\interfaces\\IUniswapV3Factory.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title The interface for the Uniswap V3 Factory\n', '/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\n', 'interface IUniswapV3Factory {\n', '    /// @notice Emitted when the owner of the factory is changed\n', '    /// @param oldOwner The owner before the owner was changed\n', '    /// @param newOwner The owner after the owner was changed\n', '    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n', '\n', '    /// @notice Emitted when a pool is created\n', '    /// @param token0 The first token of the pool by address sort order\n', '    /// @param token1 The second token of the pool by address sort order\n', '    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n', '    /// @param tickSpacing The minimum number of ticks between initialized ticks\n', '    /// @param pool The address of the created pool\n', '    event PoolCreated(\n', '        address indexed token0,\n', '        address indexed token1,\n', '        uint24 indexed fee,\n', '        int24 tickSpacing,\n', '        address pool\n', '    );\n', '\n', '    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n', '    /// @param fee The enabled fee, denominated in hundredths of a bip\n', '    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n', '    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n', '\n', '    /// @notice Returns the current owner of the factory\n', '    /// @dev Can be changed by the current owner via setOwner\n', '    /// @return The address of the factory owner\n', '    function owner() external view returns (address);\n', '\n', '    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n', '    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n', '    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n', '    /// @return The tick spacing\n', '    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n', '\n', '    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n', '    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n', '    /// @param tokenA The contract address of either token0 or token1\n', '    /// @param tokenB The contract address of the other token\n', '    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n', '    /// @return pool The pool address\n', '    function getPool(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) external view returns (address pool);\n', '\n', '    /// @notice Creates a pool for the given two tokens and fee\n', '    /// @param tokenA One of the two tokens in the desired pool\n', '    /// @param tokenB The other of the two tokens in the desired pool\n', '    /// @param fee The desired fee for the pool\n', '    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n', '    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n', '    /// are invalid.\n', '    /// @return pool The address of the newly created pool\n', '    function createPool(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) external returns (address pool);\n', '\n', '    /// @notice Updates the owner of the factory\n', '    /// @dev Must be called by the current owner\n', '    /// @param _owner The new owner of the factory\n', '    function setOwner(address _owner) external;\n', '\n', '    /// @notice Enables a fee amount with the given tickSpacing\n', '    /// @dev Fee amounts may never be removed once enabled\n', '    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n', '    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n', '    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n', '}\n', '\n', '// File: node_modules\\@openzeppelin\\contracts\\introspection\\IERC165.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: node_modules\\@openzeppelin\\contracts\\token\\ERC721\\IERC721.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\token\\ERC721\\IERC721Metadata.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the token collection name.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: @openzeppelin\\contracts\\token\\ERC721\\IERC721Enumerable.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable is IERC721 {\n', '\n', '    /**\n', '     * @dev Returns the total amount of tokens stored by the contract.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n', "     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n", '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n', '     * Use along with {totalSupply} to enumerate all tokens.\n', '     */\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPoolInitializer.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '/// @title Creates and initializes V3 Pools\n', '/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n', '/// require the pool to exist.\n', 'interface IPoolInitializer {\n', '    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n', '    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n', '    /// @param token0 The contract address of token0 of the pool\n', '    /// @param token1 The contract address of token1 of the pool\n', '    /// @param fee The fee amount of the v3 pool for the specified token pair\n', '    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n', '    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n', '    function createAndInitializePoolIfNecessary(\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        uint160 sqrtPriceX96\n', '    ) external payable returns (address pool);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IERC721Permit.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '\n', '\n', '/// @title ERC721 with permit\n', '/// @notice Extension to ERC721 that includes a permit function for signature based approvals\n', 'interface IERC721Permit is IERC721 {\n', '    /// @notice The permit typehash used in the permit signature\n', '    /// @return The typehash for the permit\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    /// @notice The domain separator used in the permit signature\n', '    /// @return The domain seperator used in encoding of permit signature\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    /// @notice Approve of a specific token ID for spending by spender via signature\n', '    /// @param spender The account that is being approved\n', '    /// @param tokenId The ID of the token that is being approved for spending\n', '    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n', '    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n', '    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n', '    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n', '    function permit(\n', '        address spender,\n', '        uint256 tokenId,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external payable;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPeripheryPayments.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '\n', '/// @title Periphery Payments\n', '/// @notice Functions to ease deposits and withdrawals of ETH\n', 'interface IPeripheryPayments {\n', "    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n", '    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n', '    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n', '    /// @param recipient The address receiving ETH\n', '    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n', '\n', '    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n', '    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n', '    /// that use ether for the input amount\n', '    function refundETH() external payable;\n', '\n', '    /// @notice Transfers the full amount of a token held by this contract to recipient\n', '    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n', '    /// @param token The contract address of the token which will be transferred to `recipient`\n', '    /// @param amountMinimum The minimum amount of token required for a transfer\n', '    /// @param recipient The destination address of the token\n', '    function sweepToken(\n', '        address token,\n', '        uint256 amountMinimum,\n', '        address recipient\n', '    ) external payable;\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\interfaces\\IPeripheryImmutableState.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Immutable state\n', '/// @notice Functions that return immutable state of the router\n', 'interface IPeripheryImmutableState {\n', '    /// @return Returns the address of the Uniswap V3 factory\n', '    function factory() external view returns (address);\n', '\n', '    /// @return Returns the address of WETH9\n', '    function WETH9() external view returns (address);\n', '}\n', '\n', '// File: node_modules\\@uniswap\\v3-periphery\\contracts\\libraries\\PoolAddress.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\n', 'library PoolAddress {\n', '    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n', '\n', '    /// @notice The identifying key of the pool\n', '    struct PoolKey {\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '    }\n', '\n', '    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n', '    /// @param tokenA The first token of a pool, unsorted\n', '    /// @param tokenB The second token of a pool, unsorted\n', '    /// @param fee The fee level of the pool\n', '    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n', '    function getPoolKey(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint24 fee\n', '    ) internal pure returns (PoolKey memory) {\n', '        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n', '        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n', '    }\n', '\n', '    /// @notice Deterministically computes the pool address given the factory and PoolKey\n', '    /// @param factory The Uniswap V3 factory contract address\n', '    /// @param key The PoolKey\n', '    /// @return pool The contract address of the V3 pool\n', '    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n', '        require(key.token0 < key.token1);\n', '        pool = address(\n', '            uint256(\n', '                keccak256(\n', '                    abi.encodePacked(\n', "                        hex'ff',\n", '                        factory,\n', '                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n', '                        POOL_INIT_CODE_HASH\n', '                    )\n', '                )\n', '            )\n', '        );\n', '    }\n', '}\n', '\n', '// File: @uniswap\\v3-periphery\\contracts\\interfaces\\INonfungiblePositionManager.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Non-fungible token for positions\n', '/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n', '/// and authorized.\n', 'interface INonfungiblePositionManager is\n', '    IPoolInitializer,\n', '    IPeripheryPayments,\n', '    IPeripheryImmutableState,\n', '    IERC721Metadata,\n', '    IERC721Enumerable,\n', '    IERC721Permit\n', '{\n', '    /// @notice Emitted when liquidity is increased for a position NFT\n', '    /// @dev Also emitted when a token is minted\n', '    /// @param tokenId The ID of the token for which liquidity was increased\n', '    /// @param liquidity The amount by which liquidity for the NFT position was increased\n', '    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n', '    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n', '    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n', '    /// @notice Emitted when liquidity is decreased for a position NFT\n', '    /// @param tokenId The ID of the token for which liquidity was decreased\n', '    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n', '    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n', '    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n', '    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n', '    /// @notice Emitted when tokens are collected for a position NFT\n', '    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n', '    /// @param tokenId The ID of the token for which underlying tokens were collected\n', '    /// @param recipient The address of the account that received the collected tokens\n', '    /// @param amount0 The amount of token0 owed to the position that was collected\n', '    /// @param amount1 The amount of token1 owed to the position that was collected\n', '    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Returns the position information associated with a given token ID.\n', '    /// @dev Throws if the token ID is not valid.\n', '    /// @param tokenId The ID of the token that represents the position\n', '    /// @return nonce The nonce for permits\n', '    /// @return operator The address that is approved for spending\n', '    /// @return token0 The address of the token0 for a specific pool\n', '    /// @return token1 The address of the token1 for a specific pool\n', '    /// @return fee The fee associated with the pool\n', '    /// @return tickLower The lower end of the tick range for the position\n', '    /// @return tickUpper The higher end of the tick range for the position\n', '    /// @return liquidity The liquidity of the position\n', '    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n', '    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n', '    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n', '    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n', '    function positions(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (\n', '            uint96 nonce,\n', '            address operator,\n', '            address token0,\n', '            address token1,\n', '            uint24 fee,\n', '            int24 tickLower,\n', '            int24 tickUpper,\n', '            uint128 liquidity,\n', '            uint256 feeGrowthInside0LastX128,\n', '            uint256 feeGrowthInside1LastX128,\n', '            uint128 tokensOwed0,\n', '            uint128 tokensOwed1\n', '        );\n', '\n', '    struct MintParams {\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '        int24 tickLower;\n', '        int24 tickUpper;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        address recipient;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Creates a new position wrapped in a NFT\n', '    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n', '    /// a method does not exist, i.e. the pool is assumed to be initialized.\n', '    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n', '    /// @return tokenId The ID of the token that represents the minted position\n', '    /// @return liquidity The amount of liquidity for this position\n', '    /// @return amount0 The amount of token0\n', '    /// @return amount1 The amount of token1\n', '    function mint(MintParams calldata params)\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 tokenId,\n', '            uint128 liquidity,\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        );\n', '\n', '    struct IncreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n', '    /// @param params tokenId The ID of the token for which liquidity is being increased,\n', '    /// amount0Desired The desired amount of token0 to be spent,\n', '    /// amount1Desired The desired amount of token1 to be spent,\n', '    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n', '    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n', '    /// deadline The time by which the transaction must be included to effect the change\n', '    /// @return liquidity The new liquidity amount as a result of the increase\n', '    /// @return amount0 The amount of token0 to acheive resulting liquidity\n', '    /// @return amount1 The amount of token1 to acheive resulting liquidity\n', '    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n', '        external\n', '        payable\n', '        returns (\n', '            uint128 liquidity,\n', '            uint256 amount0,\n', '            uint256 amount1\n', '        );\n', '\n', '    struct DecreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint128 liquidity;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n', '    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n', '    /// amount The amount by which liquidity will be decreased,\n', '    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n', '    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n', '    /// deadline The time by which the transaction must be included to effect the change\n', "    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n", "    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n", '    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n', '        external\n', '        payable\n', '        returns (uint256 amount0, uint256 amount1);\n', '\n', '    struct CollectParams {\n', '        uint256 tokenId;\n', '        address recipient;\n', '        uint128 amount0Max;\n', '        uint128 amount1Max;\n', '    }\n', '\n', '    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n', '    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n', '    /// recipient The account that should receive the tokens,\n', '    /// amount0Max The maximum amount of token0 to collect,\n', '    /// amount1Max The maximum amount of token1 to collect\n', '    /// @return amount0 The amount of fees collected in token0\n', '    /// @return amount1 The amount of fees collected in token1\n', '    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n', '\n', '    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n', '    /// must be collected first.\n', '    /// @param tokenId The ID of the token that is being burned\n', '    function burn(uint256 tokenId) external payable;\n', '}\n', '\n', '// File: @uniswap\\v3-core\\contracts\\interfaces\\callback\\IUniswapV3SwapCallback.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.5.0;\n', '\n', '/// @title Callback for IUniswapV3PoolActions#swap\n', '/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\n', 'interface IUniswapV3SwapCallback {\n', '    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n', '    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n', '    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n', '    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n', '    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n', '    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n', '    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n', '    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n', '    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n', '    function uniswapV3SwapCallback(\n', '        int256 amount0Delta,\n', '        int256 amount1Delta,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File: @uniswap\\v3-periphery\\contracts\\interfaces\\ISwapRouter.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '\n', '/// @title Router token swapping functionality\n', '/// @notice Functions for swapping tokens via Uniswap V3\n', 'interface ISwapRouter is IUniswapV3SwapCallback {\n', '    struct ExactInputSingleParams {\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint24 fee;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountIn;\n', '        uint256 amountOutMinimum;\n', '        uint160 sqrtPriceLimitX96;\n', '    }\n', '\n', '    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n', '    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n', '    /// @return amountOut The amount of the received token\n', '    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n', '\n', '    struct ExactInputParams {\n', '        bytes path;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountIn;\n', '        uint256 amountOutMinimum;\n', '    }\n', '\n', '    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n', '    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n', '    /// @return amountOut The amount of the received token\n', '    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n', '\n', '    struct ExactOutputSingleParams {\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint24 fee;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountOut;\n', '        uint256 amountInMaximum;\n', '        uint160 sqrtPriceLimitX96;\n', '    }\n', '\n', '    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n', '    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n', '    /// @return amountIn The amount of the input token\n', '    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n', '\n', '    struct ExactOutputParams {\n', '        bytes path;\n', '        address recipient;\n', '        uint256 deadline;\n', '        uint256 amountOut;\n', '        uint256 amountInMaximum;\n', '    }\n', '\n', '    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n', '    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n', '    /// @return amountIn The amount of the input token\n', '    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n', '}\n', '\n', '// File: @uniswap\\v3-periphery\\contracts\\interfaces\\IMulticall.sol\n', '\n', '// SPDX_License_Identifier: GPL-2.0-or-later\n', 'pragma solidity >=0.7.5;\n', '//pragma abicoder v2;\n', '\n', '/// @title Multicall interface\n', '/// @notice Enables calling multiple methods in a single call to the contract\n', 'interface IMulticall {\n', '    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n', '    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n', '    /// @param data The encoded function data for each of the calls to make to this contract\n', '    /// @return results The results from each of the calls passed in via data\n', '    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\UniswapV3\\1\\UniswapV3AMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract UniswapV3AMMV1 is IUniswapV3AMMV1, AMM {\n', '\n', '    address private _factoryAddress;\n', '    address private _swapRouterAddress;\n', '    address private _nonfungiblePositionManagerAddress;\n', '    address private _wethAddress;\n', '\n', '    constructor(address swapRouterAddress, address nonfungiblePositionManagerAddress) AMM("UniswapV3", 1, _wethAddress = INonfungiblePositionManager(_nonfungiblePositionManagerAddress = nonfungiblePositionManagerAddress).WETH9(), 2, true) {\n', '        _factoryAddress = INonfungiblePositionManager(nonfungiblePositionManagerAddress).factory();\n', '        _swapRouterAddress = swapRouterAddress;\n', '    }\n', '\n', '    function uniswapData() external virtual override view returns(address factoryAddress, address swapRouterAddress, address nonfungiblePositionManagerAddress, address wethAddress) {\n', '        factoryAddress = _factoryAddress;\n', '        swapRouterAddress = _swapRouterAddress;\n', '        nonfungiblePositionManagerAddress = _nonfungiblePositionManagerAddress;\n', '        wethAddress = _wethAddress;\n', '    }\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokenAddresses) {\n', '\n', '        IUniswapV3Pool pool = IUniswapV3Pool(liquidityPoolAddress);\n', '\n', '        address token0 = pool.token0();\n', '        address token1 = pool.token1();\n', '        if(IUniswapV3Factory(_factoryAddress).getPool(token0, token1, pool.fee()) != liquidityPoolAddress) {\n', '            return(0, new uint256[](0), new address[](0));\n', '        }\n', '\n', '        liquidityPoolAmount = pool.liquidity();\n', '\n', '        tokensAmounts = new uint256[](2);\n', '        (uint256 amountA, uint256 amountB) = (0, 0);\n', '        tokensAmounts[0] = amountA;\n', '        tokensAmounts[1] = amountB;\n', '\n', '        tokenAddresses = new address[](2);\n', '        tokenAddresses[0] = token0;\n', '        tokenAddresses[1] = token1;\n', '    }\n', '\n', '    function byTokens(address[] calldata tokenAddresses) public override view returns(uint256, uint256[] memory, address, address[] memory) {\n', '    }\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view public virtual override returns(uint256[] memory) {\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address, address[] memory) internal override virtual view returns(address) {\n', '        return _swapRouterAddress;\n', '    }\n', '\n', '    function _getLiquidityPoolCreator(address[] memory, uint256[] memory, bool) internal virtual view override returns(address) {\n', '        return _nonfungiblePositionManagerAddress;\n', '    }\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address, address receiver) internal virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '    }\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '    }\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '    }\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal override virtual returns(uint256 outputAmount) {\n', '        return data.path.length == 1 ? _swapLiquiditySingle(data) : _swapLiquidityMultiple(data);\n', '    }\n', '\n', '    function _swapLiquiditySingle(ProcessedSwapData memory data) private returns(uint256) {\n', '        ISwapRouter.ExactInputSingleParams memory exactInputSingleParams = ISwapRouter.ExactInputSingleParams({\n', '            tokenIn : data.inputToken,\n', '            tokenOut : data.path[0],\n', '            fee : IUniswapV3Pool(data.liquidityPoolAddresses[0]).fee(),\n', '            recipient : data.exitInETH ? address(0) : data.receiver,\n', '            deadline : block.timestamp + 10000,\n', '            amountIn : data.amount,\n', '            amountOutMinimum : 0,\n', '            sqrtPriceLimitX96 : 0\n', '        });\n', '        if(data.enterInETH || data.exitInETH) {\n', '            return _swapLiquidityMulticall(data.enterInETH, data.exitInETH, data.amount, data.receiver, abi.encodeWithSelector(ISwapRouter(_swapRouterAddress).exactInputSingle.selector, exactInputSingleParams));\n', '        }\n', '        return ISwapRouter(_swapRouterAddress).exactInputSingle(exactInputSingleParams);\n', '    }\n', '\n', '    function _swapLiquidityMultiple(ProcessedSwapData memory data) private returns(uint256) {\n', '        bytes memory path = abi.encodePacked(data.inputToken, IUniswapV3Pool(data.liquidityPoolAddresses[0]).fee(), data.path[0]);\n', '        for(uint256 i = 1; i < data.liquidityPoolAddresses.length; i++) {\n', '            path = abi.encodePacked(path, IUniswapV3Pool(data.liquidityPoolAddresses[i]).fee(), data.path[i]);\n', '        }\n', '\n', '        ISwapRouter.ExactInputParams memory exactInputParams = ISwapRouter.ExactInputParams({\n', '            path : path,\n', '            recipient : data.exitInETH ? address(0) : data.receiver,\n', '            deadline : block.timestamp + 10000,\n', '            amountIn : data.amount,\n', '            amountOutMinimum : 0\n', '        });\n', '\n', '        if(data.enterInETH || data.exitInETH) {\n', '            return _swapLiquidityMulticall(data.enterInETH, data.exitInETH, data.amount, data.receiver, abi.encodeWithSelector(ISwapRouter(_swapRouterAddress).exactInput.selector, exactInputParams));\n', '        }\n', '        return ISwapRouter(_swapRouterAddress).exactInput(exactInputParams);\n', '    }\n', '\n', '    function _swapLiquidityMulticall(bool enterInETH, bool exitInETH, uint256 value, address recipient, bytes memory data) private returns (uint256) {\n', '        bytes[] memory multicall = new bytes[](enterInETH && exitInETH ? 3 : 2);\n', '        multicall[0] = data;\n', '        if(enterInETH && exitInETH) {\n', '            multicall[1] = abi.encodeWithSelector(IPeripheryPayments(_swapRouterAddress).refundETH.selector);\n', '            multicall[2] = abi.encodeWithSelector(IPeripheryPayments(_swapRouterAddress).unwrapWETH9.selector, 0, recipient);\n', '        } else {\n', '            multicall[1] = enterInETH ? abi.encodeWithSelector(IPeripheryPayments(_swapRouterAddress).refundETH.selector) : abi.encodeWithSelector(IPeripheryPayments(_swapRouterAddress).unwrapWETH9.selector, 0, recipient);\n', '        }\n', '        return abi.decode(IMulticall(_swapRouterAddress).multicall{value : enterInETH ? value : 0}(multicall)[0], (uint256));\n', '    }\n', '}']