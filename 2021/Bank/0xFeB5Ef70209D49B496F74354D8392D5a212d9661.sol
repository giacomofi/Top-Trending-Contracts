['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-30\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '// SPDX-License-Identifier: Unlicensed\n', '\n', 'interface IERC20 {\n', '\tfunction totalSupply() external view returns (uint256);\n', '\tfunction balanceOf(address account) external view returns (uint256);\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\tfunction allowance(address owner, address spender) external view returns (uint256);\n', '\tfunction approve(address spender, uint256 amount) external returns (bool);\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ReentrancyGuard {\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a + b; require(c >= a, "SafeMath: addition overflow"); return c;}\t\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {return sub(a, b, "SafeMath: subtraction overflow");}\n', '\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b <= a, errorMessage);uint256 c = a - b;return c;}\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {if (a == 0) {return 0;}uint256 c = a * b;require(c / a == b, "SafeMath: multiplication overflow");return c;}\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {return div(a, b, "SafeMath: division by zero");}\n', '\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b > 0, errorMessage);uint256 c = a / b;return c;}\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {return mod(a, b, "SafeMath: modulo by zero");}\n', '\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b != 0, errorMessage);return a % b;}\n', '}\n', '\n', 'abstract contract Context {\n', '\tfunction _msgSender() internal view virtual returns (address) {return msg.sender;}\n', '\tfunction _msgData() internal view virtual returns (bytes memory) {this;return msg.data;}\n', '}\n', '\n', 'library Address {\n', '\t\n', '\tfunction isContract(address account) internal view returns (bool) {\n', '\t\tbytes32 codehash;\n', '\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\tassembly { codehash := extcodehash(account) }\n', '\t\treturn (codehash != accountHash && codehash != 0x0);\n', '\t}\n', '\n', '\tfunction sendValue(address payable recipient, uint256 amount) internal {\n', '\t\trequire(address(this).balance >= amount, "Address: insufficient balance");\n', '\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '\t\t(bool success, ) = recipient.call{ value: amount }("");\n', '\t\trequire(success, "Address: unable to send value, recipient may have reverted");\n', '\t}\n', '\n', '\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '\t  return functionCall(target, data, "Address: low-level call failed");\n', '\t}\n', '\n', '\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n', '\t}\n', '\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '\t\treturn functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '\t}\n', '\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '\t\trequire(address(this).balance >= value, "Address: insufficient balance for call");\n', '\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n', '\t}\n', '\n', '\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '\t\trequire(isContract(target), "Address: call to non-contract");\n', '\t\t// solhint-disable-next-line avoid-low-level-calls\n', '\t\t(bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '\t\tif (success) {\n', '\t\t\treturn returndata;\n', '\t\t} else {\n', '\t\t\tif (returndata.length > 0) {\n', '\t\t\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\t\t\tassembly {\n', '\t\t\t\t\tlet returndata_size := mload(returndata)\n', '\t\t\t\t\trevert(add(32, returndata), returndata_size)\n', '\t\t\t\t}\n', '\t\t\t} else {\n', '\t\t\t\trevert(errorMessage);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '}\n', '\n', 'contract Ownable is Context {\n', '\taddress private _owner;\n', '\taddress private _previousOwner;\n', '\tuint256 private _lockTime;\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\tconstructor () {\n', '\t\taddress msgSender = _msgSender();\n', '\t\t_owner = msgSender;\n', '\t\temit OwnershipTransferred(address(0), msgSender);\n', '\t}\n', '\tfunction owner() public view returns (address) {return _owner;}\n', '\tmodifier onlyOwner() {require(_owner == _msgSender(), "Ownable: caller is not the owner");_;}\n', '\tfunction renounceOwnership() public virtual onlyOwner {emit OwnershipTransferred(_owner, address(0)); _owner = address(0);}\n', '\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n', '\t\trequire(newOwner != address(0), "Ownable: new owner is the zero address");\n', '\t\temit OwnershipTransferred(_owner, newOwner);\n', '\t\t_owner = newOwner;\n', '\t}\n', '\tfunction geUnlockTime() public view returns (uint256) {return _lockTime;}\n', '\tfunction lock(uint256 time) public virtual onlyOwner {\n', '\t\t_previousOwner = _owner;\n', '\t\t_owner = address(0);\n', '\t\t_lockTime = block.timestamp + time;\n', '\t\temit OwnershipTransferred(_owner, address(0));\n', '\t}\n', '\t\n', '\tfunction unlock() public virtual {\n', '\t\trequire(_previousOwner == msg.sender, "You don\'t have permission to unlock");\n', '\t\trequire(block.timestamp > _lockTime , "Contract is locked until 7 days");\n', '\t\temit OwnershipTransferred(_owner, _previousOwner);\n', '\t\t_owner = _previousOwner;\n', '\t}\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\tfunction feeTo() external view returns (address);\n', '\tfunction feeToSetter() external view returns (address);\n', '\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n', '\tfunction allPairs(uint) external view returns (address pair);\n', '\tfunction allPairsLength() external view returns (uint);\n', '\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n', '\tfunction setFeeTo(address) external;\n', '\tfunction setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '\tevent Approval(address indexed owner, address indexed spender, uint value);\n', '\tevent Transfer(address indexed from, address indexed to, uint value);\n', '\tfunction name() external pure returns (string memory);\n', '\tfunction symbol() external pure returns (string memory);\n', '\tfunction decimals() external pure returns (uint8);\n', '\tfunction totalSupply() external view returns (uint);\n', '\tfunction balanceOf(address owner) external view returns (uint);\n', '\tfunction allowance(address owner, address spender) external view returns (uint);\n', '\tfunction approve(address spender, uint value) external returns (bool);\n', '\tfunction transfer(address to, uint value) external returns (bool);\n', '\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n', '\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\tfunction nonces(address owner) external view returns (uint);\n', '\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\tevent Mint(address indexed sender, uint amount0, uint amount1);\n', '\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '\tevent Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\n', '\tevent Sync(uint112 reserve0, uint112 reserve1);\n', '\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n', '\tfunction factory() external view returns (address);\n', '\tfunction token0() external view returns (address);\n', '\tfunction token1() external view returns (address);\n', '\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\tfunction price0CumulativeLast() external view returns (uint);\n', '\tfunction price1CumulativeLast() external view returns (uint);\n', '\tfunction kLast() external view returns (uint);\n', '\tfunction mint(address to) external returns (uint liquidity);\n', '\tfunction burn(address to) external returns (uint amount0, uint amount1);\n', '\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '\tfunction skim(address to) external;\n', '\tfunction sync() external;\n', '\tfunction initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '\tfunction factory() external pure returns (address);\n', '\tfunction WETH() external pure returns (address);\n', '\tfunction addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline\n', '\t) external returns (uint amountA, uint amountB, uint liquidity);\n', '\tfunction addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline\n', '\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '\tfunction removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline\n', '\t) external returns (uint amountA, uint amountB);\n', '\tfunction removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\tfunction removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountA, uint amountB);\n', '\tfunction removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\tfunction swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\tfunction swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n', '\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n', '\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n', '\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\n', '\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '\tfunction removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline\n', '\t) external returns (uint amountETH);\n', '\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountETH);\n', '\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\n', '\t) external;\n', '\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline\n', '\t) external payable;\n', '\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline\n', '\t) external;\n', '}\n', '\n', 'contract TokenFair is Context, IERC20, Ownable, ReentrancyGuard {\n', '\tusing SafeMath for uint256;\n', '\tusing Address for address;\n', '\n', '\tmapping (address => uint256) private _rOwned;\n', '\tmapping (address => uint256) private _tOwned;\n', '\tmapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '\tmapping (address => bool) private _isExcludedFromFee;\n', '\tmapping (address => bool) private _isExcludedFromReward;\n', '\taddress[] private _excludedFromReward;\n', '\n', '\taddress BURN_ADDRESS = 0x0000000000000000000000000000000000000001;\n', '\t\n', '\tuint256 private constant MAX = ~uint256(0);\n', '\tuint256 private _tTotal = 100 * 10**6 * 10**9;\n', '\tuint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '\tuint256 private _tHODLrRewardsTotal;\n', '\n', '\tstring private _name = "TokenFair";\n', '\tstring private _symbol = "TOF";\n', '\tuint8 private _decimals = 9;\n', '\t\n', '\tuint256 public _rewardFee = 6;\n', '\tuint256 private _previousRewardFee = _rewardFee;\n', '\t\n', '\tuint256 public _burnFee = 2;\n', '\tuint256 private _previousBurnFee = _burnFee;\n', '\n', '\tIUniswapV2Router02 public immutable uniswapV2Router;\n', '\taddress public immutable uniswapV2Pair;\n', '\tuint256 public _maxTxAmount = 5000000 * 10**6 * 10**9;\n', '\n', '\tevent TransferBurn(address indexed from, address indexed burnAddress, uint256 value);\n', '\n', '\tconstructor () {\n', '\t\t_rOwned[_msgSender()] = _rTotal;\n', '\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\t\t// eth uniswap V2 \n', '\t\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n', '\t\tuniswapV2Router = _uniswapV2Router;\n', '\t\t_isExcludedFromFee[owner()] = true;\n', '\t\t_isExcludedFromFee[address(this)] = true;\n', '\t\t_isExcludedFromReward[address(this)] = true;\n', '\t\t_isExcludedFromFee[BURN_ADDRESS] = true;\n', '\t\t_isExcludedFromReward[BURN_ADDRESS] = true;\n', '\t\temit Transfer(address(0), _msgSender(), _tTotal);\n', '\t}\n', '\n', '\tfunction name() public view returns (string memory) {return _name;}\n', '\tfunction symbol() public view returns (string memory) {return _symbol;}\n', '\tfunction decimals() public view returns (uint8) {return _decimals;}\n', '\tfunction totalSupply() public view override returns (uint256) {return _tTotal;}\n', '\n', '\tfunction balanceOf(address account) public view override returns (uint256) {\n', '\t\tif (_isExcludedFromReward[account]) return _tOwned[account];\n', '\t\treturn tokenFromReflection(_rOwned[account]);\n', '\t}\n', '\n', '\tfunction withdraw() external onlyOwner nonReentrant{\n', '\t\tuint256 balance = IERC20(address(this)).balanceOf(address(this));\n', '\t\tIERC20(address(this)).transfer(msg.sender, balance);\n', '\t\tpayable(msg.sender).transfer(address(this).balance);\n', '\t}\n', '\n', '\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(_msgSender(), recipient, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction allowance(address owner, address spender) public view override returns (uint256) {\n', '\t\treturn _allowances[owner][spender];\n', '\t}\n', '\n', '\tfunction approve(address spender, uint256 amount) public override returns (bool) {\n', '\t\t_approve(_msgSender(), spender, amount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(sender, recipient, amount);\n', '\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction totalHODLrRewards() public view returns (uint256) {\n', '\t\treturn _tHODLrRewardsTotal;\n', '\t}\n', '\n', '\tfunction totalBurned() public view returns (uint256) {\n', '\t\treturn balanceOf(BURN_ADDRESS);\n', '\t}\n', '\n', '\tfunction deliver(uint256 tAmount) public {\n', '\t\taddress sender = _msgSender();\n', '\t\trequire(!_isExcludedFromReward[sender], "Excluded addresses cannot call this function");\n', '\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rTotal = _rTotal.sub(rAmount);\n', '\t\t_tHODLrRewardsTotal = _tHODLrRewardsTotal.add(tAmount);\n', '\t}\n', '\n', '\tfunction reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n', '\t\trequire(tAmount <= _tTotal, "Amount must be less than supply");\n', '\t\tif (!deductTransferFee) {\n', '\t\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t\treturn rAmount;\n', '\t\t} else {\n', '\t\t\t(,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n', '\t\t\treturn rTransferAmount;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n', '\t\trequire(rAmount <= _rTotal, "Amount must be less than total reflections");\n', '\t\tuint256 currentRate =  _getRate();\n', '\t\treturn rAmount.div(currentRate);\n', '\t}\n', '\n', '\tfunction isExcludedFromReward(address account) public view returns (bool) {\n', '\t\treturn _isExcludedFromReward[account];\n', '\t}\n', '\n', '\tfunction excludeFromReward(address account) public onlyOwner {\n', '\t\trequire(!_isExcludedFromReward[account], "Account is already excluded");\n', '\t\tif(_rOwned[account] > 0) {\n', '\t\t\t_tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '\t\t}\n', '\t\t_isExcludedFromReward[account] = true;\n', '\t\t_excludedFromReward.push(account);\n', '\t}\n', '\n', '\tfunction includeInReward(address account) external onlyOwner {\n', '\t\trequire(_isExcludedFromReward[account], "Account is already excluded");\n', '\t\tfor (uint256 i = 0; i < _excludedFromReward.length; i++) {\n', '\t\t\tif (_excludedFromReward[i] == account) {\n', '\t\t\t\t_excludedFromReward[i] = _excludedFromReward[_excludedFromReward.length - 1];\n', '\t\t\t\t_tOwned[account] = 0;\n', '\t\t\t\t_isExcludedFromReward[account] = false;\n', '\t\t\t\t_excludedFromReward.pop();\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction excludeFromFee(address account) public onlyOwner {\n', '\t\t_isExcludedFromFee[account] = true;\n', '\t}\n', '\t\n', '\tfunction includeInFee(address account) public onlyOwner {\n', '\t\t_isExcludedFromFee[account] = false;\n', '\t}\n', '\t\n', '\tfunction setRewardFeePercent(uint256 rewardFee) external onlyOwner {\n', '\t\t_rewardFee = rewardFee;\n', '\t}\n', '\t\n', '\tfunction setBurnFeePercent(uint256 burnFee) external onlyOwner {\n', '\t\t_burnFee = burnFee;\n', '\t}\n', '\t\n', '\tfunction setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\n', '\t\t_maxTxAmount = _tTotal.mul(maxTxPercent).div(\n', '\t\t\t10**2\n', '\t\t);\n', '\t}\n', '\n', '\treceive() external payable {}\n', '\n', '\tfunction _HODLrFee(uint256 rHODLrFee, uint256 tHODLrFee) private {\n', '\t\t_rTotal = _rTotal.sub(rHODLrFee);\n', '\t\t_tHODLrRewardsTotal = _tHODLrRewardsTotal.add(tHODLrFee);\n', '\t}\n', '\n', '\tfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '\t\t(uint256 tTransferAmount, uint256 tHODLrFee, uint256 tBurn) = _getTValues(tAmount);\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rHODLrFee) = _getRValues(tAmount, tHODLrFee, tBurn, _getRate());\n', '\t\treturn (rAmount, rTransferAmount, rHODLrFee, tTransferAmount, tHODLrFee, tBurn);\n', '\t}\n', '\n', '\tfunction _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n', '\t\tuint256 tHODLrFee = calculateRewardFee(tAmount);\n', '\t\tuint256 tBurn = calculateBurnFee(tAmount);\n', '\t\tuint256 tTransferAmount = tAmount.sub(tHODLrFee).sub(tBurn);\n', '\t\treturn (tTransferAmount, tHODLrFee, tBurn);\n', '\t}\n', '\n', '\tfunction _getRValues(uint256 tAmount, uint256 tHODLrFee, uint256 tBurn, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n', '\t\tuint256 rAmount = tAmount.mul(currentRate);\n', '\t\tuint256 rHODLrFee = tHODLrFee.mul(currentRate);\n', '\t\tuint256 rBurn = tBurn.mul(currentRate);\n', '\t\tuint256 rTransferAmount = rAmount.sub(rHODLrFee).sub(rBurn);\n', '\t\treturn (rAmount, rTransferAmount, rHODLrFee);\n', '\t}\n', '\n', '\tfunction _getRate() private view returns(uint256) {\n', '\t\t(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '\t\treturn rSupply.div(tSupply);\n', '\t}\n', '\n', '\tfunction _getCurrentSupply() private view returns(uint256, uint256) {\n', '\t\tuint256 rSupply = _rTotal;\n', '\t\tuint256 tSupply = _tTotal;\n', '\t\tfor (uint256 i = 0; i < _excludedFromReward.length; i++) {\n', '\t\t\tif (_rOwned[_excludedFromReward[i]] > rSupply || _tOwned[_excludedFromReward[i]] > tSupply) return (_rTotal, _tTotal);\n', '\t\t\trSupply = rSupply.sub(_rOwned[_excludedFromReward[i]]);\n', '\t\t\ttSupply = tSupply.sub(_tOwned[_excludedFromReward[i]]);\n', '\t\t}\n', '\t\tif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '\t\treturn (rSupply, tSupply);\n', '\t}\n', '\t\n', '\n', '\t\n', '\tfunction calculateRewardFee(uint256 _amount) private view returns (uint256) {\n', '\t\treturn _amount.mul(_rewardFee).div(\n', '\t\t\t10**2\n', '\t\t);\n', '\t}\n', '\n', '\tfunction calculateBurnFee(uint256 _amount) private view returns (uint256) {\n', '\t\treturn _amount.mul(_burnFee).div(\n', '\t\t\t10**2\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction removeAllFee() private {\n', '\t\tif(_rewardFee == 0 && _burnFee == 0) return;\t\t\n', '\t\t_previousRewardFee = _rewardFee;\n', '\t\t_previousBurnFee = _burnFee;\t\t\n', '\t\t_rewardFee = 0;\n', '\t\t_burnFee = 0;\n', '\t}\n', '\t\n', '\tfunction restoreAllFee() private {\n', '\t\t_rewardFee = _previousRewardFee;\n', '\t\t_burnFee = _previousBurnFee;\n', '\t}\n', '\t\n', '\tfunction isExcludedFromFee(address account) public view returns(bool) {\n', '\t\treturn _isExcludedFromFee[account];\n', '\t}\n', '\n', '\tfunction _approve(address owner, address spender, uint256 amount) private {\n', '\t\trequire(owner != address(0), "ERC20: approve from the zero address");\n', '\t\trequire(spender != address(0), "ERC20: approve to the zero address");\n', '\t\t_allowances[owner][spender] = amount;\n', '\t\temit Approval(owner, spender, amount);\n', '\t}\n', '\n', '\tfunction _transfer(\n', '\t\taddress from,\n', '\t\taddress to,\n', '\t\tuint256 amount\n', '\t) private {\n', '\t\trequire(from != address(0), "ERC20: transfer from the zero address");\n', '\t\trequire(to != address(0), "ERC20: transfer to the zero address");\n', '\t\trequire(amount > 0, "Transfer amount must be greater than zero");\n', '\t\tif(from != owner() && to != owner())\n', '\t\t\trequire(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n', '\t\tbool takeFee = true;\n', '\t\tif(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n', '\t\t\ttakeFee = false;\n', '\t\t}\n', '\t\t_tokenTransfer(from,to,amount,takeFee);\n', '\t}\n', '\tfunction _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n', '\t\tif(!takeFee)\n', '\t\t\tremoveAllFee();\t\t\n', '\t\tif (_isExcludedFromReward[sender] && !_isExcludedFromReward[recipient]) {\n', '\t\t\t_transferFromExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcludedFromReward[sender] && _isExcludedFromReward[recipient]) {\n', '\t\t\t_transferToExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcludedFromReward[sender] && !_isExcludedFromReward[recipient]) {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t} else if (_isExcludedFromReward[sender] && _isExcludedFromReward[recipient]) {\n', '\t\t\t_transferBothExcluded(sender, recipient, amount);\n', '\t\t} else {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t}\t\t\n', '\t\tif(!takeFee)\n', '\t\t\trestoreAllFee();\n', '\t}\n', '\n', '\tfunction _transferBurn(uint256 tBurn) private {\n', '\t\tuint256 currentRate = _getRate();\n', '\t\tuint256 rBurn = tBurn.mul(currentRate);\t\t\n', '\t\t_rOwned[BURN_ADDRESS] = _rOwned[BURN_ADDRESS].add(rBurn);\n', '\t\tif(_isExcludedFromReward[BURN_ADDRESS])\n', '\t\t\t_tOwned[BURN_ADDRESS] = _tOwned[BURN_ADDRESS].add(tBurn);\n', '\t}\n', '\n', '\tfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(\n', '\t\t\tuint256 rAmount,\n', '\t\t\tuint256 rTransferAmount,\n', '\t\t\tuint256 rHODLrFee,\n', '\t\t\tuint256 tTransferAmount,\n', '\t\t\tuint256 tHODLrFee,\n', '\t\t\tuint256 tBurn\n', '\t\t) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_transferBurn(tBurn);\n', '\t\t_HODLrFee(rHODLrFee, tHODLrFee);\n', '\t\temit TransferBurn(sender, BURN_ADDRESS, tBurn);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rHODLrFee, uint256 tTransferAmount, uint256 tHODLrFee, uint256 tBurn) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_transferBurn(tBurn);\n', '\t\t_HODLrFee(rHODLrFee, tHODLrFee);\t\t\n', '\t\temit TransferBurn(sender, BURN_ADDRESS, tBurn);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rHODLrFee, uint256 tTransferAmount, uint256 tHODLrFee, uint256 tBurn) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_transferBurn(tBurn);\n', '\t\t_HODLrFee(rHODLrFee, tHODLrFee);\n', '\t\temit TransferBurn(sender, BURN_ADDRESS, tBurn);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '\tfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rHODLrFee, uint256 tTransferAmount, uint256 tHODLrFee, uint256 tBurn) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_transferBurn(tBurn);\n', '\t\t_HODLrFee(rHODLrFee, tHODLrFee);\n', '\t\temit TransferBurn(sender, BURN_ADDRESS, tBurn);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\n', '}']