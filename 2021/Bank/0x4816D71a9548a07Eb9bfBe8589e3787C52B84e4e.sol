['// Be Name KHODA\n', '// Bime Abolfazl\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.4;\n', '\n', "import '@openzeppelin/contracts/access/Ownable.sol';\n", '\n', '\n', 'interface IBPool {\n', '\tfunction exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;\n', '\tfunction exitswapPoolAmountIn(address tokenOut, uint256 poolAmountIn, uint256 minAmountOut) external returns (uint256 tokenAmountOut);\n', '\tfunction transferFrom(address src, address dst, uint256 amt) external returns (bool);\n', '}\n', '\n', 'interface IERC20 {\n', '\tfunction approve(address dst, uint256 amt) external returns (bool);\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\tfunction totalSupply() external view returns (uint);\n', '\tfunction balanceOf(address owner) external returns (uint);\n', '}\n', '\n', 'interface Vault {\n', '\tfunction lockFor(uint256 amount, address _user) external returns (uint256);\n', '}\n', '\n', 'interface SealedToken {\n', '\tfunction burn(address from, uint256 amount) external;\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\tfunction transferFrom(address src, address dst, uint256 amt) external returns (bool);\n', '\tfunction balanceOf(address owner) external returns (uint);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '\tfunction getReserves() external returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '}\n', '\n', 'interface IUniswapV2Router02 {\n', '\tfunction removeLiquidityETH(\n', '\t\taddress token,\n', '\t\tuint256 liquidity,\n', '\t\tuint256 amountTokenMin,\n', '\t\tuint256 amountETHMin,\n', '\t\taddress to,\n', '\t\tuint256 deadline\n', '\t) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '\tfunction removeLiquidity(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint256 liquidity,\n', '\t\tuint256 amountAMin,\n', '\t\tuint256 amountBMin,\n', '\t\taddress to,\n', '\t\tuint256 deadline\n', '\t) external returns (uint256 amountA, uint256 amountB);\n', '\n', '\tfunction swapExactTokensForTokens(\n', '\t\tuint256 amountIn,\n', '\t\tuint256 amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint256 deadline\n', '\t) external returns (uint256[] memory amounts);\n', '\n', '\tfunction swapExactTokensForETH(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\n', '\tfunction getAmountsOut(uint256 amountIn, address[] memory path) external  returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface AutomaticMarketMaker {\n', '\tfunction calculatePurchaseReturn(uint256 etherAmount) external returns (uint256);\n', '\tfunction buy(uint256 _tokenAmount) external payable;\n', '\tfunction sell(uint256 tokenAmount, uint256 _etherAmount) external;\n', '\tfunction withdrawPayments(address payable payee) external;\n', '}\n', '\n', 'contract SealedSwapper is Ownable {\n', '\n', '\tIBPool public bpt;\n', '\tIUniswapV2Router02 public uniswapRouter;\n', '\tAutomaticMarketMaker public AMM;\n', '\tVault public sdeaVault;\n', '\tSealedToken public sdeus;\n', '\tSealedToken public sdea;\n', '\tSealedToken public sUniDD;\n', '\tSealedToken public sUniDE;\n', '\tSealedToken public sUniDU;\n', '\taddress dea;\n', '\taddress deus;\n', '\taddress usdc;\n', '\taddress uniDD;\n', '\taddress uniDU;\n', '\taddress uniDE;\n', '\t\n', '\tuint256 MAX_INT = type(uint256).max;\n', '\n', '\tconstructor (\n', '\t\t\taddress _uniswapRouter,\n', '\t\t\taddress _bpt,\n', '\t\t\taddress _amm,\n', '\t\t\taddress _sdeaVault,\n', '\t\t\taddress _dea,\n', '\t\t\taddress _deus,\n', '\t\t\taddress _usdc,\n', '\t\t\taddress _uniDD,\n', '\t\t\taddress _uniDE,\n', '\t\t\taddress _uniDU\n', '\t\t) {\n', '\n', '\t\tuniswapRouter = IUniswapV2Router02(_uniswapRouter);\n', '\t\tbpt = IBPool(_bpt);\n', '\t\tAMM = AutomaticMarketMaker(_amm);\n', '\n', '\t\tsdeaVault = Vault(_sdeaVault);\n', '\n', '\t\tdea = _dea;\n', '\t\tdeus = _deus;\n', '\t\tusdc = _usdc;\n', '\t\tuniDD = _uniDD;\n', '\t\tuniDU = _uniDU;\n', '\t\tuniDE = _uniDE;\n', '\n', '\t}\n', '\t\n', '\tfunction init(\n', '\t\taddress _sdea,\n', '\t\taddress _sdeus,\n', '\t\taddress _sUniDD,\n', '\t\taddress _sUniDE,\n', '\t\taddress _sUniDU\n', '\t) external {\n', '\t\tsdea = SealedToken(_sdea);\n', '\t\tsdeus = SealedToken(_sdeus);\n', '\t\tsUniDD = SealedToken(_sUniDD);\n', '\t\tsUniDE = SealedToken(_sUniDE);\n', '\t\tsUniDU = SealedToken(_sUniDU);\n', '\t\tIERC20(dea).approve(address(uniswapRouter), MAX_INT);\n', '\t\tIERC20(deus).approve(address(uniswapRouter), MAX_INT);\n', '\t\tIERC20(usdc).approve(address(uniswapRouter), MAX_INT);\n', '\t\tIERC20(uniDD).approve(address(uniswapRouter), MAX_INT);\n', '\t\tIERC20(uniDE).approve(address(uniswapRouter), MAX_INT);\n', '\t\tIERC20(uniDU).approve(address(uniswapRouter), MAX_INT);\n', '\t}\n', '\n', '\tfunction approve(address token, address recipient, uint256 amount) external onlyOwner {\n', '\t\tIERC20(token).approve(recipient, amount);\n', '\t}\n', '\n', '\tfunction changeBPT(address _bpt) external onlyOwner {\n', '\t\tbpt = IBPool(_bpt);\n', '\t}\n', '\n', '\tfunction changeAMM(address _amm) external onlyOwner {\n', '\t\tAMM = AutomaticMarketMaker(_amm);\n', '\t}\n', '\n', '\tfunction bpt2eth(address tokenOut, uint256 poolAmountIn, uint256[] memory minAmountsOut, address[] memory path) public {\n', '\t\tbpt.transferFrom(msg.sender, address(this), poolAmountIn);\n', '\t\tuint256 deaAmount = bpt.exitswapPoolAmountIn(tokenOut, poolAmountIn, minAmountsOut[0]);\n', '\t\tuint256 deusAmount = uniswapRouter.swapExactTokensForTokens(deaAmount, minAmountsOut[1], path, address(this), block.timestamp + 1 days)[1];\n', '\t\tAMM.sell(deusAmount, minAmountsOut[2]);\n', '\t\tAMM.withdrawPayments(payable(msg.sender));\n', '\t}\n', '\n', '\tfunction bpt2Uni(address tokenOut, uint256 poolAmountIn, uint256[] memory minAmountsOut, address[] memory path) public {\n', '\t\tbpt.transferFrom(msg.sender, address(this), poolAmountIn);\n', '\t\tuint256 deaAmount = bpt.exitswapPoolAmountIn(tokenOut, poolAmountIn, minAmountsOut[0]);\n', '\t\tuniswapRouter.swapExactTokensForTokens(deaAmount, minAmountsOut[1], path, msg.sender, block.timestamp + 1 days);\n', '\t}\n', '\n', '\tfunction sdeus2sdea(uint256 amountIn, uint256 minAmountOut, address[] memory path) internal {\n', '\t\tsdeus.burn(msg.sender, amountIn);\n', '\n', '\t\tuint256 deaAmount = uniswapRouter.swapExactTokensForTokens(amountIn, minAmountOut, path, address(this), block.timestamp + 1 days)[1];\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(deaAmount, msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\tfunction bpt2sdea(address tokenOut, uint256 poolAmountIn, uint256 minAmountOut) public {\n', '\t\tbpt.transferFrom(msg.sender, address(this), poolAmountIn);\n', '\n', '\t\tuint256 deaAmount = bpt.exitswapPoolAmountIn(tokenOut, poolAmountIn, minAmountOut);\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(deaAmount, msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\tfunction bpt2sdea(\n', '\t\tuint256 poolAmountIn,\n', '\t\tuint256[] memory balancerMinAmountsOut,\n', '\t\tuint256 DDMinAmountsOut,\n', '\t\tuint256 sUniDDMinAmountsOut,\n', '\t\tuint256 sUniDEMinAmountsOut,\n', '\t\tuint256[] memory sUniDUMinAmountsOut,\n', '\t\taddress[] memory DDPath,\n', '\t\taddress[] memory sUniDDPath,\n', '\t\taddress[] memory sUniDEPath,\n', '\t\taddress[] memory sUniDUPath1,\n', '\t\taddress[] memory sUniDUPath2\n', '\t) public {\n', '\t\tbpt.transferFrom(msg.sender, address(this), poolAmountIn);\n', '\t\tbpt.exitPool(poolAmountIn, balancerMinAmountsOut);\n', '\n', '\t\tsdeus2sdea(sdeus.balanceOf(address(this)), DDMinAmountsOut, DDPath);\n', '\t\tsUniDD2sdea(sUniDD.balanceOf(address(this)), sUniDDMinAmountsOut, sUniDDPath);\n', '\t\tsUniDE2sdea(sUniDE.balanceOf(address(this)), sUniDEMinAmountsOut, sUniDEPath);\n', '\t\tsUniDU2sdea(sUniDU.balanceOf(address(this)), sUniDUMinAmountsOut, sUniDUPath1, sUniDUPath2);\n', '\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(IERC20(dea).balanceOf(address(this)), msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\tfunction minAmountsCalculator(uint256 univ2Amount, uint256 totalSupply, uint256 reserve1, uint256 reserve2) pure internal returns(uint256, uint256) {\n', '\t\treturn (((univ2Amount/1e5) /  totalSupply * reserve1) * 95 / 100, ((univ2Amount/1e5) / totalSupply * reserve2) * 95 / 100);\n', '\t}\n', '\t\n', '\tfunction sUniDD2sdea(uint256 sUniDDAmount, uint256 minAmountOut, address[] memory path) public {\n', '\t\tsUniDD.burn(msg.sender, sUniDDAmount);\n', '\n', '\t\tuint256 totalSupply = IERC20(uniDD).totalSupply();\n', '\t\t(uint256 deusReserve, uint256 deaReserve, ) = IUniswapV2Pair(uniDD).getReserves();\n', '\n', '\t\t(uint256 deusMinAmountOut, uint256 deaMinAmountOut) = minAmountsCalculator(sUniDDAmount, totalSupply, deusReserve, deaReserve);\n', '\t\t(uint256 deusAmount, uint256 deaAmount) = uniswapRouter.removeLiquidity(deus, dea, sUniDDAmount, deusMinAmountOut, deaMinAmountOut, address(this), block.timestamp + 1 days);\n', '\n', '\t\tuint256 deaAmount2 = uniswapRouter.swapExactTokensForTokens(deusAmount, minAmountOut, path, address(this), block.timestamp + 1 days)[1];\n', '\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(deaAmount + deaAmount2, msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\t// function sUniDU2sdea() public {\n', '\t\t\n', '\t// }\n', '\t\n', '\n', '\tfunction sUniDU2sdea(uint256 sUniDUAmount, uint256[] memory minAmountsOut, address[] memory path1, address[] memory path2) public {\n', '\t\tsUniDU.burn(msg.sender, sUniDUAmount);\n', '\n', '\t\tuint256 totalSupply = IERC20(uniDU).totalSupply();\n', '\t\t(uint256 deaReserve, uint256 usdcReserve, ) = IUniswapV2Pair(uniDU).getReserves();\n', '\t\t\n', '\t\t(uint256 deaMinAmountOut, uint256 usdcMinAmountOut) = minAmountsCalculator(sUniDUAmount/1e5, totalSupply, deaReserve, usdcReserve);\n', '\t\t(uint256 deaAmount, uint256 usdcAmount) = uniswapRouter.removeLiquidity(dea, usdc, (sUniDUAmount/1e5), deaMinAmountOut, usdcMinAmountOut, address(this), block.timestamp + 1 days);\n', '\n', '\n', '\t\tuint256 ethAmount = uniswapRouter.swapExactTokensForETH(usdcAmount, minAmountsOut[0], path1, address(this), block.timestamp + 1 days)[1];\n', '\n', '\t\tuint256 deusAmount = AMM.calculatePurchaseReturn(ethAmount);\n', '\t\tAMM.buy{value: ethAmount}(deusAmount);\n', '\t\t\n', '\t\tuint256 deaAmount2 = uniswapRouter.swapExactTokensForTokens(deusAmount, minAmountsOut[1], path2, address(this), block.timestamp + 1 days)[1];\n', '\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(deaAmount + deaAmount2, msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\t// function sUniDE2sdea() public {\n', '\t\t\n', '\t// }\n', '\n', '\tfunction sUniDE2sdea(uint256 sUniDEAmount, uint256 minAmountOut, address[] memory path) public {\n', '\t\tsUniDE.burn(msg.sender, sUniDEAmount);\n', '\n', '\t\tuint256 totalSupply = IERC20(uniDE).totalSupply();\n', '\t\t(uint256 deusReserve, uint256 wethReserve, ) = IUniswapV2Pair(uniDE).getReserves();\n', '\t\t(uint256 deusMinAmountOut, uint256 ethMinAmountOut) = minAmountsCalculator(sUniDEAmount, totalSupply, deusReserve, wethReserve);\n', '\t\t(uint256 deusAmount, uint256 ethAmount) = uniswapRouter.removeLiquidityETH(deus, sUniDEAmount, deusMinAmountOut, ethMinAmountOut, address(this), block.timestamp + 1 days);\n', '\t\tuint256 deusAmount2 = AMM.calculatePurchaseReturn(ethAmount);\n', '\t\tAMM.buy{value: ethAmount}(deusAmount2);\n', '\t\tuint256 deaAmount = uniswapRouter.swapExactTokensForTokens(deusAmount + deusAmount2, minAmountOut, path, address(this), block.timestamp + 1 days)[1];\n', '\n', '\t\tuint256 sdeaAmount = sdeaVault.lockFor(deaAmount, msg.sender);\n', '\n', '\t\tsdea.transfer(msg.sender, sdeaAmount);\n', '\t}\n', '\n', '\tfunction withdraw(address token, uint256 amount, address to) public onlyOwner {\n', '\t\tIERC20(token).transfer(to, amount);\n', '\t}\n', '\n', '\treceive() external payable {}\n', '}\n', '\n', '// Dar panahe Khoda\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../utils/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']