['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-23\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface PriceRouter {\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function WETH() external view returns (address);\n', '}\n', '\n', 'interface Pair {\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112,\n', '            uint112,\n', '            uint32\n', '        );\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'contract CalculationsSushiswap {\n', '    address public primaryRouterAddress;\n', '    address public primaryFactoryAddress;\n', '    address public secondaryRouterAddress;\n', '    address public secondaryFactoryAddress;\n', '    address public wethAddress;\n', '    address public usdcAddress;\n', '    PriceRouter primaryRouter;\n', '    PriceRouter secondaryRouter;\n', '\n', '    address ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address zeroAddress = 0x0000000000000000000000000000000000000000;\n', '\n', '    constructor(\n', '        address _primaryRouterAddress,\n', '        address _primaryFactoryAddress,\n', '        address _secondaryRouterAddress,\n', '        address _secondaryFactoryAddress,\n', '        address _usdcAddress\n', '    ) {\n', '        primaryRouterAddress = _primaryRouterAddress;\n', '        primaryFactoryAddress = _primaryFactoryAddress;\n', '        secondaryRouterAddress = _secondaryRouterAddress;\n', '        secondaryFactoryAddress = _secondaryFactoryAddress;\n', '        usdcAddress = _usdcAddress;\n', '        primaryRouter = PriceRouter(primaryRouterAddress);\n', '        secondaryRouter = PriceRouter(secondaryRouterAddress);\n', '        wethAddress = primaryRouter.WETH();\n', '    }\n', '\n', '    // Uniswap/Sushiswap\n', '    function getPriceUsdc(address tokenAddress) public view returns (uint256) {\n', '        if (isLpToken(tokenAddress)) {\n', '            return getLpTokenPriceUsdc(tokenAddress);\n', '        }\n', '        return getPriceFromRouterUsdc(tokenAddress);\n', '    }\n', '\n', '    function getPriceFromRouter(address token0Address, address token1Address)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // Convert ETH address (0xEeee...) to WETH\n', '        if (token0Address == ethAddress) {\n', '            token0Address = wethAddress;\n', '        }\n', '        if (token1Address == ethAddress) {\n', '            token1Address = wethAddress;\n', '        }\n', '\n', '        address[] memory path;\n', '        uint8 numberOfJumps;\n', '        bool inputTokenIsWeth =\n', '            token0Address == wethAddress || token1Address == wethAddress;\n', '        if (inputTokenIsWeth) {\n', '            // path = [token0, weth] or [weth, token1]\n', '            numberOfJumps = 1;\n', '            path = new address[](numberOfJumps + 1);\n', '            path[0] = token0Address;\n', '            path[1] = token1Address;\n', '        } else {\n', '            // path = [token0, weth, token1]\n', '            numberOfJumps = 2;\n', '            path = new address[](numberOfJumps + 1);\n', '            path[0] = token0Address;\n', '            path[1] = wethAddress;\n', '            path[2] = token1Address;\n', '        }\n', '\n', '        IERC20 token0 = IERC20(token0Address);\n', '        uint256 amountIn = 10**uint256(token0.decimals());\n', '        uint256[] memory amountsOut;\n', '\n', '        bool fallbackRouterExists = secondaryRouterAddress != zeroAddress;\n', '        if (fallbackRouterExists) {\n', '            try primaryRouter.getAmountsOut(amountIn, path) returns (\n', '                uint256[] memory _amountsOut\n', '            ) {\n', '                amountsOut = _amountsOut;\n', '            } catch {\n', '                amountsOut = secondaryRouter.getAmountsOut(amountIn, path);\n', '            }\n', '        } else {\n', '            amountsOut = primaryRouter.getAmountsOut(amountIn, path);\n', '        }\n', '\n', '        // Return raw price (without fees)\n', '        uint256 amountOut = amountsOut[amountsOut.length - 1];\n', '        uint256 feeBips = 30; // .3% per swap\n', '        amountOut = (amountOut * 10000) / (10000 - (feeBips * numberOfJumps));\n', '        return amountOut;\n', '    }\n', '\n', '    function getPriceFromRouterUsdc(address tokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return getPriceFromRouter(tokenAddress, usdcAddress);\n', '    }\n', '\n', '    function isLpToken(address tokenAddress) public view returns (bool) {\n', '        if (tokenAddress == ethAddress) {\n', '            return false;\n', '        }\n', '        Pair lpToken = Pair(tokenAddress);\n', '        try lpToken.factory() {\n', '            return true;\n', '        } catch {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function getRouterForLpToken(address tokenAddress)\n', '        public\n', '        view\n', '        returns (PriceRouter)\n', '    {\n', '        Pair lpToken = Pair(tokenAddress);\n', '        address factoryAddress = lpToken.factory();\n', '        if (factoryAddress == primaryFactoryAddress) {\n', '            return primaryRouter;\n', '        } else if (factoryAddress == secondaryFactoryAddress) {\n', '            return secondaryRouter;\n', '        }\n', '        revert();\n', '    }\n', '\n', '    function getLpTokenTotalLiquidityUsdc(address tokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Pair pair = Pair(tokenAddress);\n', '        address token0Address = pair.token0();\n', '        address token1Address = pair.token1();\n', '        IERC20 token0 = IERC20(token0Address);\n', '        IERC20 token1 = IERC20(token1Address);\n', '        uint8 token0Decimals = token0.decimals();\n', '        uint8 token1Decimals = token1.decimals();\n', '        uint256 token0Price = getPriceUsdc(token0Address);\n', '        uint256 token1Price = getPriceUsdc(token1Address);\n', '        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n', '        uint256 totalLiquidity =\n', '            ((reserve0 / 10**token0Decimals) * token0Price) +\n', '                ((reserve1 / 10**token1Decimals) * token1Price);\n', '        return totalLiquidity;\n', '    }\n', '\n', '    function getLpTokenPriceUsdc(address tokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        Pair pair = Pair(tokenAddress);\n', '        uint256 totalLiquidity = getLpTokenTotalLiquidityUsdc(tokenAddress);\n', '        uint256 totalSupply = pair.totalSupply();\n', '        uint8 pairDecimals = pair.decimals();\n', '        uint256 pricePerLpTokenUsdc =\n', '            (totalLiquidity * 10**pairDecimals) / totalSupply;\n', '        return pricePerLpTokenUsdc;\n', '    }\n', '}']