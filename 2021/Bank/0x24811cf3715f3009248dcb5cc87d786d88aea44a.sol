['/**\n', '* SPDX-License-Identifier: LicenseRef-Aktionariat\n', '*\n', '* MIT License with Automated License Fee Payments\n', '*\n', '* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n', '*\n', '* Permission is hereby granted to any person obtaining a copy of this software\n', '* and associated documentation files (the "Software"), to deal in the Software\n', '* without restriction, including without limitation the rights to use, copy,\n', '* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n', '* Software, and to permit persons to whom the Software is furnished to do so,\n', '* subject to the following conditions:\n', '*\n', '* - The above copyright notice and this permission notice shall be included in\n', '*   all copies or substantial portions of the Software.\n', '* - All automated license fee payments integrated into this and related Software\n', '*   are preserved.\n', '*\n', '* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '* SOFTWARE.\n', '*/\n', 'pragma solidity >=0.8;\n', '\n', 'import "./Ownable.sol";\n', 'import "./IERC20.sol";\n', 'import "./IUniswapV2.sol";\n', '\n', 'contract Market is Ownable {\n', '\n', '    address public base;  // ERC-20 currency\n', '    address public token; // ERC-20 share token\n', '\n', '    address public copyright;\n', '    uint8 public licenseFeeBps; // only charged on sales, max 1% i.e. 100\n', '\n', '    uint256 private price; // current offer price, without drift\n', '    uint256 public increment; // increment\n', '\n', '    uint256 public driftStart;\n', '    uint256 public timeToDrift; // seconds until drift pushes price by one drift increment\n', '    int256 public driftIncrement;\n', '\n', '    bool public buyingEnabled = true;\n', '    bool public sellingEnabled = true;\n', '\n', '    IUniswapV2 constant uniswap = IUniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    address public weth;\n', '\n', '    event Trade(address indexed token, address who, bytes ref, int amount, address base, uint totPrice, uint fee, uint newprice);\n', '\n', '    constructor(address shareToken, uint256 price_, address baseCurrency, address owner) {\n', '        base = baseCurrency;\n', '        token = shareToken;\n', '        price = price_;\n', '        weth = uniswap.WETH();\n', '        copyright = 0x29Fe8914e76da5cE2d90De98a64d0055f199d06D; // Aktionariat AG\n', '        driftStart = block.timestamp;\n', '        transferOwnership(owner);\n', '    }\n', '\n', '    function setPrice(uint256 newPrice, uint256 newIncrement) public onlyOwner {\n', '        anchorPrice(newPrice);\n', '        increment = newIncrement;\n', '    }\n', '\n', '    function hasDrift() public view returns (bool) {\n', '        return timeToDrift != 0;\n', '    }\n', '\n', '    // secondsPerStep should be negative for downwards drift\n', '    function setDrift(uint256 secondsPerStep, int256 newDriftIncrement) public onlyOwner {\n', '        anchorPrice(getPrice());\n', '        timeToDrift = secondsPerStep;\n', '        driftIncrement = newDriftIncrement;\n', '    }\n', '\n', '    function anchorPrice(uint256 currentPrice) private {\n', '        price = currentPrice;\n', '        driftStart = block.timestamp;\n', '    }\n', '\n', '    function getPrice() public view returns (uint256) {\n', '        return getPriceAtTime(block.timestamp);\n', '    }\n', '\n', '    function getPriceAtTime(uint256 timestamp) public view returns (uint256) {\n', '        if (hasDrift()){\n', '            uint256 passed = timestamp - driftStart;\n', '            int256 drifted = int256(passed / timeToDrift) * driftIncrement;\n', '            int256 driftedPrice = int256(price) + drifted;\n', '            if (driftedPrice < 0){\n', '                return 0;\n', '            } else {\n', '                return uint256(driftedPrice);\n', '            }\n', '        } else {\n', '            return price;\n', '        }\n', '    }\n', '\n', '    function getPriceInEther(uint256 shares) public view returns (uint256) {\n', '        uint256 totPrice = getBuyPrice(shares);\n', '        address[] memory path = new address[](2);\n', '        path[0] = weth;\n', '        path[1] = base;\n', '        return uniswap.getAmountsIn(totPrice, path)[0];\n', '    }\n', '\n', '    function buyWithEther(uint256 shares, bytes calldata ref) public payable returns (uint256) {\n', '        require(buyingEnabled);\n', '        uint256 totPrice = getBuyPrice(shares);\n', '        uint256 totPriceEth = getPriceInEther(shares);\n', '        address[] memory path = new address[](2);\n', '        path[0] = weth;\n', '        path[1] = base;\n', '        uint256[] memory amounts = uniswap.swapETHForExactTokens{value: totPriceEth}(totPrice, path, address(this), block.timestamp);\n', '        assert(totPrice == amounts[1]);\n', '        _buy(msg.sender, msg.sender, shares, amounts[1], ref);\n', '        if (address(this).balance > 0){\n', '            payable(msg.sender).transfer(address(this).balance);\n', '        }\n', '        return amounts[0];\n', '    }\n', '\n', '    function buy(uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\n', '        require(buyingEnabled);\n', '        return buy(msg.sender, numberOfSharesToBuy, ref);\n', '    }\n', '\n', '    function buy(address recipient, uint256 numberOfSharesToBuy, bytes calldata ref) public returns (uint256) {\n', '        require(buyingEnabled);\n', '        return _buy(msg.sender, recipient, numberOfSharesToBuy, 0, ref);\n', '    }\n', '\n', '    function _buy(address paying, address recipient, uint256 shares, uint256 alreadyPaid, bytes calldata ref) internal returns (uint256) {\n', '        uint256 totPrice = getBuyPrice(shares);\n', '        IERC20 baseToken = IERC20(base);\n', '        if (totPrice > alreadyPaid){\n', '            require(baseToken.transferFrom(paying, address(this), totPrice - alreadyPaid));\n', '        } else if (totPrice < alreadyPaid){\n', '            // caller paid to much, return excess amount\n', '            require(baseToken.transfer(paying, alreadyPaid - totPrice));\n', '        }\n', '        IERC20 shareToken = IERC20(token);\n', '        require(shareToken.transfer(recipient, shares));\n', '        price = price + (shares * increment);\n', '        emit Trade(token, paying, ref, int256(shares), base, totPrice, 0, getPrice());\n', '        return totPrice;\n', '    }\n', '\n', '    function _notifyMoneyReceived(address from, uint256 amount, bytes calldata ref) internal {\n', '        uint shares = getShares(amount);\n', '        _buy(from, from, shares, amount, ref);\n', '    }\n', '\n', '    function sell(uint256 tokens, bytes calldata ref) public returns (uint256){\n', '        require(sellingEnabled);\n', '        return sell(msg.sender, tokens, ref);\n', '    }\n', '\n', '    function sell(address recipient, uint256 tokens, bytes calldata ref) public returns (uint256){\n', '        require(sellingEnabled);\n', '        return _sell(msg.sender, recipient, tokens, ref);\n', '    }\n', '\n', '    function _sell(address seller, address recipient, uint256 shares, bytes calldata ref) internal returns (uint256) {\n', '        IERC20 shareToken = IERC20(token);\n', '        require(shareToken.transferFrom(seller, address(this), shares));\n', '        return _notifyTokensReceived(recipient, shares, ref);\n', '    }\n', '\n', '    // ERC-677 recipient\n', '    function onTokenTransfer(address from, uint256 amount, bytes calldata ref) public returns (bool success) {\n', '        require(msg.sender == token || msg.sender == base);\n', '        if (msg.sender == token){\n', '            require(sellingEnabled);\n', '            _notifyTokensReceived(from, amount, ref);\n', '        } else if (msg.sender == base){\n', '            require(buyingEnabled);\n', '            _notifyMoneyReceived(from, amount, ref);\n', '        } else {\n', '            require(false);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _notifyTokensReceived(address recipient, uint256 amount, bytes calldata ref) internal returns (uint256) {\n', '        uint256 totPrice = getSellPrice(amount);\n', '        IERC20 baseToken = IERC20(base);\n', '        uint256 fee = getSaleFee(totPrice);\n', '        if (fee > 0){\n', '            require(baseToken.transfer(copyright, fee));\n', '        }\n', '        require(baseToken.transfer(recipient, totPrice - fee));\n', '        price -= amount * increment;\n', '        emit Trade(token, recipient, ref, -int256(amount), base, totPrice, fee, getPrice());\n', '        return totPrice;\n', '    }\n', '\n', '    function getSaleFee(uint256 totalPrice) public view returns (uint256) {\n', '        return totalPrice * licenseFeeBps / 10000;\n', '    }\n', '\n', '    function getSaleProceeds(uint256 shares) public view returns (uint256) {\n', '        uint256 total = getSellPrice(shares);\n', '        return total - getSaleFee(total);\n', '    }\n', '\n', '    function getSellPrice(uint256 shares) public view returns (uint256) {\n', '        return getPrice(getPrice() - (shares * increment), shares);\n', '    }\n', '\n', '    function getBuyPrice(uint256 shares) public view returns (uint256) {\n', '        return getPrice(getPrice(), shares);\n', '    }\n', '\n', '    function getPrice(uint256 lowest, uint256 shares) internal view returns (uint256){\n', '        if (shares == 0){\n', '            return 0;\n', '        } else {\n', '            uint256 highest = lowest + (shares - 1) * increment;\n', '            return ((lowest + highest) / 2) * shares;\n', '        }\n', '    }\n', '\n', '    function getShares(uint256 money) public view returns (uint256) {\n', '        uint256 currentPrice = getPrice();\n', '        uint256 min = 0;\n', '        uint256 max = money / currentPrice;\n', '        while (min + 1 < max){\n', '            uint256 middle = (min + max)/2;\n', '            uint256 totalPrice = getPrice(currentPrice, middle);\n', '            if (totalPrice > money){\n', '                max = middle;\n', '            } else {\n', '                min = middle;\n', '            }\n', '        }\n', '        return min;\n', '    }\n', '\n', '    function setCopyright(address newOwner) public {\n', '        require(msg.sender == copyright);\n', '        copyright = newOwner;\n', '    }\n', '\n', '    function setLicenseFee(uint8 bps) public {\n', '        require(msg.sender == copyright);\n', '        require(bps <= 100);\n', '        licenseFeeBps = bps;\n', '    }\n', '\n', '    function withdraw(address ercAddress, address to, uint256 amount) public onlyOwner() {\n', '        IERC20 erc20 = IERC20(ercAddress);\n', '        require(erc20.transfer(to, amount), "Transfer failed");\n', '    }\n', '\n', '    function setEnabled(bool newBuyingEnabled, bool newSellingEnabled) public onlyOwner() {\n', '        buyingEnabled = newBuyingEnabled;\n', '        sellingEnabled = newSellingEnabled;\n', '    }\n', '}']