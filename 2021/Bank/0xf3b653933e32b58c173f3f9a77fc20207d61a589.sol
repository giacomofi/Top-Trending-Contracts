['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-05\n', '*/\n', '\n', 'pragma solidity ^0.5.15;\n', '\n', '/*\n', ":'######::'########:'########::'#######::\n", "'##... ##: ##.....::... ##..::'##.... ##:\n", ' ##:::..:: ##:::::::::: ##:::: ##:::: ##:\n', ' ##::::::: ######:::::: ##:::: ##:::: ##:\n', ' ##::::::: ##...::::::: ##:::: ##:::: ##:\n', ' ##::: ##: ##:::::::::: ##:::: ##:::: ##:\n', '. ######:: ########:::: ##::::. #######::\n', ':......:::........:::::..::::::.......:::\n', '\n', 'Creator: 773d62b24a9d49e1f990b22e3ef1a9903f44ee809a12d73e660c66c1772c47dd\n', '*/\n', '\n', 'contract Hourglass {\n', '    /*=================================\n', '    =            MODIFIERS            =\n', '    =================================*/\n', '    // only people with tokens\n', '    modifier onlyBagholders() {\n', '        require(myTokens() > 0);\n', '        _;\n', '    }\n', '\n', '    // administrators can:\n', '    // -> change the name of the contract\n', '    // -> change the name of the token\n', '    // -> change the PoS difficulty (How many tokens it costs to hold a masternode, in case it gets crazy high later)\n', '    // they CANNOT:\n', '    // -> take funds\n', '    // -> disable withdrawals\n', '    // -> kill the contract\n', '    // -> change the price of tokens\n', '    modifier onlyAdministrator() {\n', '        address _customerAddress = msg.sender;\n', '        require(administrators[_customerAddress], "This address is not an admin");\n', '        _;\n', '    }\n', '\n', '    // ensures that the first tokens in the contract will be equally distributed\n', '    // meaning, no divine dump will be ever possible\n', '    // result: healthy longevity.\n', '    modifier antiEarlyWhale(uint256 _amountOfEthereum) {\n', '        // are we still in the vulnerable phase?\n', '        // if so, enact anti early whale protocol\n', '        if (onlyAmbassadors) {\n', '            address _customerAddress = msg.sender;\n', '\n', '            if (\n', '                (totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_\n', '            ) {\n', '                require(\n', '                    // is the customer in the ambassador list?\n', '                    ambassadors_[_customerAddress] == true &&\n', '                        // does the customer purchase exceed the max ambassador quota?\n', '                        (ambassadorAccumulatedQuota_[_customerAddress] +\n', '                            _amountOfEthereum) <=\n', '                        ambassadorMaxPurchase_\n', '                );\n', '\n', '                // updated the accumulated quota\n', '                ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(\n', '                    ambassadorAccumulatedQuota_[_customerAddress],\n', '                    _amountOfEthereum\n', '                );\n', '\n', '                // execute\n', '                _;\n', '            } else {\n', "                // in case the trx count drops low, the ambassador phase won't reinitiate\n", '                onlyAmbassadors = false;\n', '                _;\n', '            }\n', '        }\n', '\n', '        // execute\n', '        _;\n', '    }\n', '\n', '    /*==============================\n', '    =            EVENTS            =\n', '    ==============================*/\n', '    event onTokenPurchase(\n', '        address indexed customerAddress,\n', '        uint256 incomingEthereum,\n', '        uint256 tokensMinted,\n', '        address indexed referredBy\n', '    );\n', '\n', '    event onTokenSell(\n', '        address indexed customerAddress,\n', '        uint256 tokensBurned,\n', '        uint256 ethereumEarned\n', '    );\n', '\n', '    event onReinvestment(\n', '        address indexed customerAddress,\n', '        uint256 ethereumReinvested,\n', '        uint256 tokensMinted\n', '    );\n', '\n', '    event onWithdraw(\n', '        address indexed customerAddress,\n', '        uint256 ethereumWithdrawn\n', '    );\n', '\n', '    // ERC20\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 tokens\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    // When a customer sets up AutoReinvestment\n', '    event onAutoReinvestmentEntry(\n', '        address indexed customerAddress,\n', '        uint256 nextExecutionTime,\n', '        uint256 rewardPerInvocation,\n', '        uint24 period,\n', '        uint256 minimumDividendValue\n', '    );\n', '\n', '    // When a customer stops AutoReinvestment\n', '    event onAutoReinvestmentStop(address indexed customerAddress);\n', '\n', '    /*=====================================\n', '    =            CONFIGURABLES            =\n', '    =====================================*/\n', '    string public name = "Crystal Elephant Token";\n', '    string public symbol = "ECETO";\n', '    uint8 public constant decimals = 18;\n', '    uint8 internal constant dividendFee_ = 10;\n', '    uint256 internal constant tokenPriceInitial_ = 100e9; // unit: wei\n', '    uint256 internal constant tokenPriceIncremental_ = 10e9; // unit: wei\n', '    uint256 internal constant magnitude = 2**64;\n', '\n', '    // requirement for earning a referral bonus (defaults at 360 tokens)\n', '    uint256 public stakingRequirement = 30e18;\n', '\n', '    // ambassador program\n', '    mapping(address => bool) public ambassadors_;\n', '    uint256 internal constant ambassadorMaxPurchase_ = 4e18; // 4 ETH\n', '    uint256 internal constant ambassadorQuota_ = 100e18; // 100 ETH\n', '\n', '    /*================================\n', '    =            DATASETS            =\n', '    ================================*/\n', '    // amount of tokens for each address (scaled number)\n', '    mapping(address => uint256) internal tokenBalanceLedger_;\n', '\n', '    // TODO: \n', '    // amount of tokens bought with their buy timestamp for each address\n', '    struct TimestampedBalance {\n', '        uint256 value;\n', '        uint256 timestamp;\n', '        uint256 valueSold;\n', '    }\n', '\n', '    mapping(address => TimestampedBalance[])\n', '        internal tokenTimestampedBalanceLedger_;\n', '\n', '    // The start and end index of the unsold timestamped transactions list\n', '    struct Cursor {\n', '        uint256 start;\n', '        uint256 end;\n', '    }\n', '\n', '    mapping(address => Cursor) internal tokenTimestampedBalanceCursor;\n', '\n', '    // mappings to and from referral address\n', '    mapping(address => bytes32) public referralMapping;\n', '    mapping(bytes32 => address) public referralReverseMapping;\n', '\n', '    // The current referral balance\n', '    mapping(address => uint256) public referralBalance_;\n', '    // All time referrals earnings\n', '    mapping(address => uint256) public referralIncome_;\n', '\n', '    mapping(address => int256) internal payoutsTo_;\n', '    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n', '    uint256 internal tokenSupply_ = 0;\n', '    uint256 internal profitPerShare_;\n', '\n', '    // administrator list (see above on what they can do)\n', '    mapping(address => bool) public administrators;\n', '\n', '    // when this is set to true, only ambassadors can purchase tokens (this prevents a whale premine, it ensures a fairly distributed upper pyramid)\n', '    bool public onlyAmbassadors = true;\n', '\n', '    /*=======================================\n', '    =            PUBLIC FUNCTIONS            =\n', '    =======================================*/\n', '    /*\n', '     * -- APPLICATION ENTRY POINTS --\n', '     */\n', '    constructor() public {\n', '        address owner = msg.sender;\n', '        administrators[owner] = true;\n', '\n', '        ambassadors_[0x8c67C528a78c3142eEbA7A9FB9966c3141ABFc07] = true;\n', '        ambassadors_[0xA3085Dc923e5de6E1919CFaE73a4D4557CF31734] = true;\n', '        ambassadors_[0x62544c00f6458011796605E8E6E7F799E17b1348] = true;\n', '        ambassadors_[0x5357777ddD555a192E1E87b96a93aAdcC463D0f8] = true;\n', '        ambassadors_[0x8713c7d84dA4edC2795EbaBfFdeEF4bB2Ef654Df] = true;\n', '        ambassadors_[0xC8b17a71fE39dB3AdD2438B89C1522d03767ebDA] = true;\n', '        ambassadors_[0x6B6dDbb85000EFCbff006BEa12CeD803Fd0a0B96] = true;\n', '        ambassadors_[0x2F09612675A16E9D97e8A0c27D2285A5d8FB6EBa] = true;\n', '        ambassadors_[0xD82f5174e03E3352a35a933a11100e6c2607Ba1E] = true;\n', '        ambassadors_[0x28eb45DB2c42b56A1C5BC915F4cc47DD79239632] = true;\n', '        ambassadors_[0x12B2398405f49dEc00D7ceEF9C0925e6fc96c51F] = true;\n', '        ambassadors_[0x32c0aE75EF5BEB409a17fcf26fDDb8561EEF8394] = true;\n', '        ambassadors_[0x2FC1DbA620e749E86E51C2d9c42993174E1986ce] = true;\n', '        ambassadors_[0xDBfc64ff6C4d85f42D8411680ebe90aD06bF3E81] = true;\n', '        ambassadors_[0xBD54eb8AD245450e225A77Af5956F2b41301c845] = true;\n', '        ambassadors_[0x58d1a5e3ca23F46E16BcA17849CE327a415A2ee5] = true;\n', '        ambassadors_[0x33a2e739b428508643Ee49d874775e1196178A1c] = true;\n', '        ambassadors_[0x45ADFF324Eb1ac03a6A115dc539052232D4bA980] = true;\n', '        ambassadors_[0x3e666E4B6091263F3A70C004E47a1e172f31Ff42] = true;\n', '        ambassadors_[0x766917c3Ee4AA5164b3A6F01363865efA8CE6fFd] = true;\n', '        ambassadors_[0x3Ee362b5DB70c2935e718f7711B1CCAC7dbAd081] = true;\n', '        ambassadors_[0xcb1A0F26c89fbC1BCb14fE1Ee9a2785BAE419e81] = true;\n', '    }\n', '\n', '    /**\n', '     * Fallback function to handle ethereum that was send straight to the contract\n', '     * Unfortunately we cannot use a referral address this way.\n', '     */\n', '    function() external payable {\n', '        purchaseTokens(msg.sender, msg.value, address(0));\n', '    }\n', '\n', '    /**\n', '     * Converts all incoming ethereum to tokens for the caller, and passes down the referral addy (if any)\n', '     */\n', '    function buy(address _referredBy) public payable {\n', '        purchaseTokens(msg.sender, msg.value, _referredBy);\n', '    }\n', '\n', '    /**\n', "     * Converts all of caller's dividends to tokens.\n", '     */\n', '    function reinvest(\n', '        bool isAutoReinvestChecked,\n', '        uint24 period,\n', '        uint256 rewardPerInvocation,\n', '        uint256 minimumDividendValue\n', '    ) public {\n', '        _reinvest(msg.sender);\n', '\n', '        // Setup Auto Reinvestment\n', '        if (isAutoReinvestChecked) {\n', '            _setupAutoReinvest(\n', '                period,\n', '                rewardPerInvocation,\n', '                msg.sender,\n', '                minimumDividendValue\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Alias of sell() and withdraw().\n', '     */\n', '    function exit() public {\n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '        if (_tokens > 0) sell(_tokens);\n', '        withdraw();\n', '    }\n', '\n', '    /**\n', '     * Withdraws all of the callers earnings.\n', '     */\n', '    function withdraw() public {\n', '        _withdraw(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * Liquifies tokens to ethereum.\n', '     */\n', '    function sell(uint256 _amountOfTokens) public onlyBagholders() {\n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '        uint256 _tokens = _amountOfTokens;\n', '        uint256 _ethereum = tokensToEthereum_(_tokens);\n', '\n', '        uint256 penalty =\n', '            mulDiv(\n', '                calculateAveragePenaltyAndUpdateLedger(\n', '                    _amountOfTokens,\n', '                    _customerAddress\n', '                ),\n', '                _ethereum,\n', '                100\n', '            );\n', '\n', '        uint256 _dividends =\n', '            SafeMath.add(\n', '                penalty,\n', '                SafeMath.div(SafeMath.sub(_ethereum, penalty), dividendFee_)\n', '            );\n', '\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '\n', '        // burn the sold tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(\n', '            tokenBalanceLedger_[_customerAddress],\n', '            _tokens\n', '        );\n', '\n', '        // update dividends tracker\n', '        int256 _updatedPayouts =\n', '            (int256)(profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n', '        payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '        if (tokenSupply_ > 0) {\n', '            // update the amount of dividends per token\n', '            profitPerShare_ = SafeMath.add(\n', '                profitPerShare_,\n', '                mulDiv(_dividends, magnitude, tokenSupply_)\n', '            );\n', '        }\n', '\n', '        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n', '    }\n', '\n', '    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\n', '    /**\n', '     * In case the amassador quota is not met, the administrator can manually disable the ambassador phase.\n', '     */\n', '    function disableInitialStage() public onlyAdministrator() {\n', '        onlyAmbassadors = false;\n', '    }\n', '\n', '    function setAdministrator(address _identifier, bool _status)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        administrators[_identifier] = _status;\n', '    }\n', '\n', '    /**\n', '     * Precautionary measures in case we need to adjust the masternode rate.\n', '     */\n', '    function setStakingRequirement(uint256 _amountOfTokens)\n', '        public\n', '        onlyAdministrator()\n', '    {\n', '        stakingRequirement = _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setName(string memory _name) public onlyAdministrator() {\n', '        name = _name;\n', '    }\n', '\n', '    /**\n', '     * If we want to rebrand, we can.\n', '     */\n', '    function setSymbol(string memory _symbol) public onlyAdministrator() {\n', '        symbol = _symbol;\n', '    }\n', '\n', '    /*----------  REFERRAL FUNCTIONS  ----------*/\n', '\n', '    function setReferralName(bytes32 ref_name) public returns (bool) {\n', '        referralMapping[msg.sender] = ref_name;\n', '        referralReverseMapping[ref_name] = msg.sender;\n', '        return true;\n', '    }\n', '\n', '    function getReferralAddressForName(bytes32 ref_name)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        return referralReverseMapping[ref_name];\n', '    }\n', '\n', '    function getReferralNameForAddress(address ref_address)\n', '        public\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return referralMapping[ref_address];\n', '    }\n', '\n', '    function getReferralBalance() public view returns (uint256, uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return (\n', '            referralBalance_[_customerAddress],\n', '            referralIncome_[_customerAddress]\n', '        );\n', '    }\n', '\n', '    /*------READ FUNCTIONS FOR TIMESTAMPED BALANCE LEDGER-------*/\n', '\n', '    function getCursor() public view returns (uint256, uint256) {\n', '        address _customerAddress = msg.sender;\n', '        Cursor storage cursor = tokenTimestampedBalanceCursor[_customerAddress];\n', '\n', '        return (cursor.start, cursor.end);\n', '    }\n', '\n', '    function getTimestampedBalanceLedger(uint256 counter)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        TimestampedBalance storage transaction =\n', '            tokenTimestampedBalanceLedger_[_customerAddress][counter];\n', '        return (\n', '            transaction.value,\n', '            transaction.timestamp,\n', '            transaction.valueSold\n', '        );\n', '    }\n', '\n', '    /*----------  HELPERS AND CALCULATORS  ----------*/\n', '    /**\n', '     * Method to view the current Ethereum stored in the contract\n', '     * Example: totalEthereumBalance()\n', '     */\n', '    function totalEthereumBalance() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the total token supply.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokenSupply_;\n', '    }\n', '\n', '    /**\n', '     * Retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens() public view returns (uint256) {\n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividends owned by the caller.\n', '     * If `_includeReferralBonus` is true, the referral bonus will be included in the calculations.\n', '     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\n', '     * But in the internal calculations, we want them separate.\n', '     */\n', '    function myDividends(bool _includeReferralBonus)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        return\n', '            _includeReferralBonus\n', '                ? dividendsOf(_customerAddress) +\n', '                    referralBalance_[_customerAddress]\n', '                : dividendsOf(_customerAddress);\n', '    }\n', '\n', '    /**\n', '     * Retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address _customerAddress) public view returns (uint256) {\n', '        return tokenBalanceLedger_[_customerAddress];\n', '    }\n', '\n', '    /**\n', '     * Retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            (uint256)(\n', '                (int256)(\n', '                    profitPerShare_ * tokenBalanceLedger_[_customerAddress]\n', '                ) - payoutsTo_[_customerAddress]\n', '            ) / magnitude;\n', '    }\n', '\n', '    /**\n', '     * Return the ethereum received on selling 1 individual token.\n', "     * We are not deducting the penalty over here as it's a general sell price\n", '     * the user can use the `calculateEthereumReceived` to get the sell price specific to them\n', '     */\n', '    function sellPrice() public view returns (uint256) {\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ - tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n', '            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Return the ethereum required for buying 1 individual token.\n', '     */\n', '    function buyPrice() public view returns (uint256) {\n', '        if (tokenSupply_ == 0) {\n', '            return tokenPriceInitial_ + tokenPriceIncremental_;\n', '        } else {\n', '            uint256 _ethereum = tokensToEthereum_(1e18);\n', '            uint256 _taxedEthereum =\n', '                mulDiv(_ethereum, dividendFee_, (dividendFee_ - 1));\n', '            return _taxedEthereum;\n', '        }\n', '    }\n', '\n', '    /*\n', '     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\n', '     */\n', '    function calculateTokensReceived(uint256 _ethereumToSpend)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    function calculateTokensReinvested() public view returns (uint256) {\n', '        uint256 _ethereumToSpend = myDividends(true);\n', '        uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    /**\n', '     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\n', '     */\n', '    function calculateEthereumReceived(uint256 _tokensToSell)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(_tokensToSell <= tokenSupply_);\n', '        require(_tokensToSell <= myTokens());\n', '        uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n', '        address _customerAddress = msg.sender;\n', '\n', '        uint256 penalty =\n', '            mulDiv(\n', '                calculateAveragePenalty(_tokensToSell, _customerAddress),\n', '                _ethereum,\n', '                100\n', '            );\n', '\n', '        uint256 _dividends =\n', '            SafeMath.add(\n', '                penalty,\n', '                SafeMath.div(SafeMath.sub(_ethereum, penalty), dividendFee_)\n', '            );\n', '\n', '        uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n', '        return _taxedEthereum;\n', '    }\n', '\n', '    function calculateEthereumTransferred(uint256 _amountOfTokens)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        require(_amountOfTokens <= tokenSupply_);\n', '        require(_amountOfTokens <= myTokens());\n', '        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        return _taxedTokens;\n', '    }\n', '\n', '    /**\n', '     * Calculate the early exit penalty for selling x tokens\n', '     */\n', '    function calculateAveragePenalty(\n', '        uint256 _amountOfTokens,\n', '        address _customerAddress\n', '    ) public view onlyBagholders() returns (uint256) {\n', '        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '        uint256 tokensFound = 0;\n', '        Cursor storage _customerCursor =\n', '            tokenTimestampedBalanceCursor[_customerAddress];\n', '        uint256 counter = _customerCursor.start;\n', '        uint256 averagePenalty = 0;\n', '\n', '        while (counter <= _customerCursor.end) {\n', '            TimestampedBalance storage transaction =\n', '                tokenTimestampedBalanceLedger_[_customerAddress][counter];\n', '            uint256 tokensAvailable =\n', '                SafeMath.sub(transaction.value, transaction.valueSold);\n', '\n', '            uint256 tokensRequired = SafeMath.sub(_amountOfTokens, tokensFound);\n', '\n', '            if (tokensAvailable < tokensRequired) {\n', '                tokensFound += tokensAvailable;\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensAvailable\n', '                    )\n', '                );\n', '            } else if (tokensAvailable <= tokensRequired) {\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensRequired\n', '                    )\n', '                );\n', '                break;\n', '            } else {\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensRequired\n', '                    )\n', '                );\n', '                break;\n', '            }\n', '\n', '            counter = SafeMath.add(counter, 1);\n', '        }\n', '        return SafeMath.div(averagePenalty, _amountOfTokens);\n', '    }\n', '\n', '    /**\n', '     * Calculate the early exit penalty for selling after x days\n', '     */\n', '    function _calculatePenalty(uint256 timestamp)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 gap = block.timestamp - timestamp;\n', '\n', '        if (gap > 30 days) {\n', '            return 0;\n', '        } else if (gap > 20 days) {\n', '            return 25;\n', '        } else if (gap > 10 days) {\n', '            return 50;\n', '        }\n', '        return 75;\n', '    }\n', '\n', '    /**\n', '     * Calculate Token price based on an amount of incoming ethereum\n', '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function ethereumToTokens_(uint256 _ethereum)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n', '        uint256 _tokensReceived =\n', '            ((\n', '                SafeMath.sub(\n', '                    (\n', '                        sqrt(\n', '                            (_tokenPriceInitial**2) +\n', '                                (2 *\n', '                                    (tokenPriceIncremental_ * 1e18) *\n', '                                    (_ethereum * 1e18)) +\n', '                                (((tokenPriceIncremental_)**2) *\n', '                                    (tokenSupply_**2)) +\n', '                                (2 *\n', '                                    (tokenPriceIncremental_) *\n', '                                    _tokenPriceInitial *\n', '                                    tokenSupply_)\n', '                        )\n', '                    ),\n', '                    _tokenPriceInitial\n', '                )\n', '            ) / (tokenPriceIncremental_)) - (tokenSupply_);\n', '\n', '        return _tokensReceived;\n', '    }\n', '\n', '    /**\n', '     * Calculate token sell value.\n', '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokensToEthereum_(uint256 _tokens) public view returns (uint256) {\n', '        uint256 tokens_ = (_tokens + 1e18);\n', '        uint256 _tokenSupply = (tokenSupply_ + 1e18);\n', '        uint256 _ethereumReceived =\n', '            (SafeMath.sub(\n', '                (((tokenPriceInitial_ +\n', '                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\n', '                    tokenPriceIncremental_) * (tokens_ - 1e18)),\n', '                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\n', '            ) / 1e18);\n', '\n', '        return _ethereumReceived;\n', '    }\n', '\n', '    /*==========================================\n', '    =            INTERNAL FUNCTIONS            =\n', '    ==========================================*/\n', '    function purchaseTokens(\n', '        address _customerAddress,\n', '        uint256 _incomingEthereum,\n', '        address _referredBy\n', '    ) internal antiEarlyWhale(_incomingEthereum) returns (uint256) {\n', '        // data setup\n', '        uint256 _undividedDividends =\n', '            SafeMath.div(_incomingEthereum, dividendFee_);\n', '        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedEthereum =\n', '            SafeMath.sub(_incomingEthereum, _undividedDividends);\n', '        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n', '        uint256 _fee = _dividends * magnitude;\n', '\n', '        require(\n', '            _amountOfTokens > 0 &&\n', '                SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_\n', '        );\n', '\n', '        // is the user referred by a masternode?\n', '        if (\n', '            _referredBy != address(0) &&\n', '            _referredBy != _customerAddress &&\n', '            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n', '        ) {\n', '            // wealth redistribution\n', '            referralBalance_[_referredBy] = SafeMath.add(\n', '                referralBalance_[_referredBy],\n', '                _referralBonus\n', '            );\n', '            referralIncome_[_referredBy] = SafeMath.add(\n', '                referralIncome_[_referredBy],\n', '                _referralBonus\n', '            );\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '            _fee = _dividends * magnitude;\n', '        }\n', '\n', '        if (tokenSupply_ > 0) {\n', '            // add tokens to the pool\n', '            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '\n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            profitPerShare_ += ((_dividends * magnitude) / (tokenSupply_));\n', '\n', '            // calculate the amount of tokens the customer receives over his purchase\n', '            _fee =\n', '                _fee -\n', '                (_fee -\n', '                    (_amountOfTokens *\n', '                        ((_dividends * magnitude) / (tokenSupply_))));\n', '        } else {\n', '            // add tokens to the pool\n', '            tokenSupply_ = _amountOfTokens;\n', '        }\n', '\n', '        // update circulating supply & the ledger address for the customer\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.add(\n', '            tokenBalanceLedger_[_customerAddress],\n', '            _amountOfTokens\n', '        );\n', '        tokenTimestampedBalanceLedger_[_customerAddress].push(\n', '            TimestampedBalance(_amountOfTokens, block.timestamp, 0)\n', '        );\n', '        tokenTimestampedBalanceCursor[_customerAddress].end += 1;\n', '\n', "        // You don't get dividends for the tokens before they owned them\n", '        int256 _updatedPayouts =\n', '            (int256)(profitPerShare_ * _amountOfTokens - _fee);\n', '        payoutsTo_[_customerAddress] += _updatedPayouts;\n', '\n', '        // fire event\n', '        emit onTokenPurchase(\n', '            _customerAddress,\n', '            _incomingEthereum,\n', '            _amountOfTokens,\n', '            _referredBy\n', '        );\n', '\n', '        emit Transfer(\n', '            address(0),\n', '            _customerAddress,\n', '            _amountOfTokens\n', '        );\n', '\n', '        return _amountOfTokens;\n', '    }\n', '\n', '    function _reinvest(address _customerAddress) internal {\n', '        uint256 _dividends = dividendsOf(_customerAddress);\n', '\n', '        // onlyStronghands\n', '        require(_dividends + referralBalance_[_customerAddress] > 0);\n', '\n', '        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '        // retrieve ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _tokens =\n', '            purchaseTokens(_customerAddress, _dividends, address(0));\n', '\n', '        // fire event\n', '        emit onReinvestment(_customerAddress, _dividends, _tokens);\n', '    }\n', '\n', '    function _withdraw(address _customerAddress) internal {\n', '        uint256 _dividends = dividendsOf(_customerAddress); // get ref. bonus later in the code\n', '\n', '        // onlyStronghands\n', '        require(_dividends + referralBalance_[_customerAddress] > 0);\n', '\n', '        // update dividend tracker\n', '        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '\n', '        // add ref. bonus\n', '        _dividends += referralBalance_[_customerAddress];\n', '        referralBalance_[_customerAddress] = 0;\n', '\n', '        address payable _payableCustomerAddress =\n', '            address(uint160(_customerAddress));\n', '        _payableCustomerAddress.transfer(_dividends);\n', '\n', '        // fire event\n', '        emit onWithdraw(_customerAddress, _dividends);\n', '    }\n', '\n', '    /**\n', '     * Update ledger after transferring x tokens\n', '     */\n', '    function _updateLedgerForTransfer(\n', '        uint256 _amountOfTokens,\n', '        address _customerAddress\n', '    ) internal {\n', '        // Parse through the list of transactions\n', '        uint256 tokensFound = 0;\n', '        Cursor storage _customerCursor =\n', '            tokenTimestampedBalanceCursor[_customerAddress];\n', '        uint256 counter = _customerCursor.start;\n', '\n', '        while (counter <= _customerCursor.end) {\n', '            TimestampedBalance storage transaction =\n', '                tokenTimestampedBalanceLedger_[_customerAddress][counter];\n', '            uint256 tokensAvailable =\n', '                SafeMath.sub(transaction.value, transaction.valueSold);\n', '\n', '            uint256 tokensRequired = SafeMath.sub(_amountOfTokens, tokensFound);\n', '\n', '            if (tokensAvailable < tokensRequired) {\n', '                tokensFound += tokensAvailable;\n', '\n', '                delete tokenTimestampedBalanceLedger_[_customerAddress][\n', '                    counter\n', '                ];\n', '            } else if (tokensAvailable <= tokensRequired) {\n', '                delete tokenTimestampedBalanceLedger_[_customerAddress][\n', '                    counter\n', '                ];\n', '                _customerCursor.start = counter + 1;\n', '                break;\n', '            } else {\n', '                transaction.valueSold += tokensRequired;\n', '                _customerCursor.start = counter;\n', '                break;\n', '            }\n', '            counter += 1;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Calculate the early exit penalty for selling x tokens and edit the timestamped ledger\n', '     */\n', '    function calculateAveragePenaltyAndUpdateLedger(\n', '        uint256 _amountOfTokens,\n', '        address _customerAddress\n', '    ) internal onlyBagholders() returns (uint256) {\n', '        // Parse through the list of transactions\n', '        uint256 tokensFound = 0;\n', '        Cursor storage _customerCursor =\n', '            tokenTimestampedBalanceCursor[_customerAddress];\n', '        uint256 counter = _customerCursor.start;\n', '        uint256 averagePenalty = 0;\n', '\n', '        while (counter <= _customerCursor.end) {\n', '            TimestampedBalance storage transaction =\n', '                tokenTimestampedBalanceLedger_[_customerAddress][counter];\n', '            uint256 tokensAvailable =\n', '                SafeMath.sub(transaction.value, transaction.valueSold);\n', '\n', '            uint256 tokensRequired = SafeMath.sub(_amountOfTokens, tokensFound);\n', '\n', '            if (tokensAvailable < tokensRequired) {\n', '                tokensFound += tokensAvailable;\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensAvailable\n', '                    )\n', '                );\n', '                delete tokenTimestampedBalanceLedger_[_customerAddress][\n', '                    counter\n', '                ];\n', '            } else if (tokensAvailable <= tokensRequired) {\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensRequired\n', '                    )\n', '                );\n', '                delete tokenTimestampedBalanceLedger_[_customerAddress][\n', '                    counter\n', '                ];\n', '                _customerCursor.start = counter + 1;\n', '                break;\n', '            } else {\n', '                averagePenalty = SafeMath.add(\n', '                    averagePenalty,\n', '                    SafeMath.mul(\n', '                        _calculatePenalty(transaction.timestamp),\n', '                        tokensRequired\n', '                    )\n', '                );\n', '                transaction.valueSold += tokensRequired;\n', '                _customerCursor.start = counter;\n', '                break;\n', '            }\n', '\n', '            counter += 1;\n', '        }\n', '\n', '        return SafeMath.div(averagePenalty, _amountOfTokens);\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev calculates x*y and outputs a emulated 512bit number as l being the lower 256bit half and h the upper 256bit half.\n', '     */\n', '    function fullMul(uint256 x, uint256 y)\n', '        public\n', '        pure\n', '        returns (uint256 l, uint256 h)\n', '    {\n', '        uint256 mm = mulmod(x, y, uint256(-1));\n', '        l = x * y;\n', '        h = mm - l;\n', '        if (mm < l) h -= 1;\n', '    }\n', '\n', '    /**\n', '     * @dev calculates x*y/z taking care of phantom overflows.\n', '     */\n', '    function mulDiv(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 z\n', '    ) public pure returns (uint256) {\n', '        (uint256 l, uint256 h) = fullMul(x, y);\n', '        require(h < z);\n', '        uint256 mm = mulmod(x, y, z);\n', '        if (mm > l) h -= 1;\n', '        l -= mm;\n', '        uint256 pow2 = z & -z;\n', '        z /= pow2;\n', '        l /= pow2;\n', '        l += h * ((-pow2) / pow2 + 1);\n', '        uint256 r = 1;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        r *= 2 - z * r;\n', '        return l * r;\n', '    }\n', '\n', '    /*\n', '     * =========================\n', '     * Auto Reinvestment Feature\n', '     * =========================\n', '     */\n', '\n', '    // uint256 recommendedRewardPerInvocation = 5000000; // 5 TRX\n', '\n', '    struct AutoReinvestEntry {\n', '        uint256 nextExecutionTime;\n', '        uint256 rewardPerInvocation;\n', '        uint256 minimumDividendValue;\n', '        uint24 period;\n', '    }\n', '\n', '    mapping(address => AutoReinvestEntry) internal autoReinvestment;\n', '\n', '    function setupAutoReinvest(\n', '        uint24 period,\n', '        uint256 rewardPerInvocation,\n', '        uint256 minimumDividendValue\n', '    ) public {\n', '        _setupAutoReinvest(\n', '            period,\n', '            rewardPerInvocation,\n', '            msg.sender,\n', '            minimumDividendValue\n', '        );\n', '    }\n', '\n', '    function _setupAutoReinvest(\n', '        uint24 period,\n', '        uint256 rewardPerInvocation,\n', '        address customerAddress,\n', '        uint256 minimumDividendValue\n', '    ) internal {\n', '        autoReinvestment[customerAddress] = AutoReinvestEntry(\n', '            block.timestamp + period,\n', '            rewardPerInvocation,\n', '            minimumDividendValue,\n', '            period\n', '        );\n', '\n', '        // Launch an event that this entry has been created\n', '        emit onAutoReinvestmentEntry(\n', '            customerAddress,\n', '            autoReinvestment[customerAddress].nextExecutionTime,\n', '            rewardPerInvocation,\n', '            period,\n', '            minimumDividendValue\n', '        );\n', '    }\n', '\n', '    // Anyone can call this function and claim the reward\n', '    function invokeAutoReinvest(address _customerAddress)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        AutoReinvestEntry storage entry = autoReinvestment[_customerAddress];\n', '\n', '        if (\n', '            entry.nextExecutionTime > 0 &&\n', '            block.timestamp >= entry.nextExecutionTime\n', '        ) {\n', '            // fetch dividends\n', '            uint256 _dividends = dividendsOf(_customerAddress);\n', '\n', "            // Only execute if the user's dividends are more that the\n", '            // rewardPerInvocation and the minimumDividendValue\n', '            if (\n', '                _dividends > entry.minimumDividendValue &&\n', '                _dividends > entry.rewardPerInvocation\n', '            ) {\n', '                // Deduct the reward from the users dividends\n', '                payoutsTo_[_customerAddress] += (int256)(\n', '                    entry.rewardPerInvocation * magnitude\n', '                );\n', '\n', '                // Update the Auto Reinvestment entry\n', '                entry.nextExecutionTime +=\n', '                    (((block.timestamp - entry.nextExecutionTime) /\n', '                        uint256(entry.period)) + 1) *\n', '                    uint256(entry.period);\n', '\n', '                /*\n', '                 * Do the reinvestment\n', '                 */\n', '                _reinvest(_customerAddress);\n', '\n', '                // Send the caller their reward\n', '                msg.sender.transfer(entry.rewardPerInvocation);\n', '            }\n', '        }\n', '\n', '        return entry.nextExecutionTime;\n', '    }\n', '\n', '    // Read function for the frontend to determine if the user has setup Auto Reinvestment or not\n', '    function getAutoReinvestEntry()\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint24,\n', '            uint256\n', '        )\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        AutoReinvestEntry storage _autoReinvestEntry =\n', '            autoReinvestment[_customerAddress];\n', '        return (\n', '            _autoReinvestEntry.nextExecutionTime,\n', '            _autoReinvestEntry.rewardPerInvocation,\n', '            _autoReinvestEntry.period,\n', '            _autoReinvestEntry.minimumDividendValue\n', '        );\n', '    }\n', '\n', '    // Read function for the scheduling workers determine if the user has setup Auto Reinvestment or not\n', '    function getAutoReinvestEntryOf(address _customerAddress)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint24,\n', '            uint256\n', '        )\n', '    {\n', '        AutoReinvestEntry storage _autoReinvestEntry =\n', '            autoReinvestment[_customerAddress];\n', '        return (\n', '            _autoReinvestEntry.nextExecutionTime,\n', '            _autoReinvestEntry.rewardPerInvocation,\n', '            _autoReinvestEntry.period,\n', '            _autoReinvestEntry.minimumDividendValue\n', '        );\n', '    }\n', '\n', '    // The user can stop the autoReinvestment whenever they want\n', '    function stopAutoReinvest() external {\n', '        address customerAddress = msg.sender;\n', '        if (autoReinvestment[customerAddress].nextExecutionTime > 0) {\n', '            delete autoReinvestment[customerAddress];\n', '\n', '            // Launch an event that this entry has been deleted\n', '            emit onAutoReinvestmentStop(customerAddress);\n', '        }\n', '    }\n', '\n', '    // Allowance, Approval and Transfer From\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    function allowance(address owner, address spender)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        uint256 final_amount =\n', '            SafeMath.sub(_allowances[sender][msg.sender], amount);\n', '\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, final_amount);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _toAddress, uint256 _amountOfTokens)\n', '        public\n', '        onlyBagholders\n', '        returns (bool)\n', '    {\n', '        _transfer(msg.sender, _toAddress, _amountOfTokens);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient` after liquifying 10% of the tokens `amount` as dividens.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `_customerAddress` cannot be the zero address.\n', '     * - `_toAddress` cannot be the zero address.\n', '     * - `_customerAddress` must have a balance of at least `_amountOfTokens`.\n', '     */\n', '    function _transfer(\n', '        address _customerAddress,\n', '        address _toAddress,\n', '        uint256 _amountOfTokens\n', '    ) internal {\n', '        require(\n', '            _customerAddress != address(0),\n', '            "ERC20: transfer from the zero address"\n', '        );\n', '        require(\n', '            _toAddress != address(0),\n', '            "ERC20: transfer to the zero address"\n', '        );\n', '\n', '        // also disables transfers until ambassador phase is over\n', '        // ( we dont want whale premines )\n', '        // make sure we have the requested tokens\n', '        require(\n', '            !onlyAmbassadors &&\n', '                _amountOfTokens <= tokenBalanceLedger_[_customerAddress]\n', '        );\n', '\n', '        // withdraw all outstanding dividends first\n', '        if (\n', '            dividendsOf(_customerAddress) + referralBalance_[_customerAddress] >\n', '            0\n', '        ) {\n', '            _withdraw(_customerAddress);\n', '        }\n', '\n', '        // updating tokenTimestampedBalanceLedger_ for _customerAddress\n', '        _updateLedgerForTransfer(_amountOfTokens, _customerAddress);\n', '\n', '        // liquify 10% of the remaining tokens that are transfered\n', '        // these are dispersed to shareholders\n', '        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n', '\n', '        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '        uint256 _dividends = tokensToEthereum_(_tokenFee);\n', '\n', '        // burn the fee tokens\n', '        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '        // exchange tokens\n', '        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(\n', '            tokenBalanceLedger_[_customerAddress],\n', '            _amountOfTokens\n', '        );\n', '        tokenBalanceLedger_[_toAddress] = SafeMath.add(\n', '            tokenBalanceLedger_[_toAddress],\n', '            _taxedTokens\n', '        );\n', '\n', '        // updating tokenTimestampedBalanceLedger_ for _toAddress\n', '        tokenTimestampedBalanceLedger_[_toAddress].push(\n', '            TimestampedBalance(_taxedTokens, block.timestamp, 0)\n', '        );\n', '        tokenTimestampedBalanceCursor[_toAddress].end += 1;\n', '\n', '        // update dividend trackers\n', '        payoutsTo_[_customerAddress] -= (int256)(\n', '            profitPerShare_ * _amountOfTokens\n', '        );\n', '        payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _taxedTokens);\n', '\n', '        // disperse dividends among holders\n', '        profitPerShare_ = SafeMath.add(\n', '            profitPerShare_,\n', '            mulDiv(_dividends, magnitude, tokenSupply_)\n', '        );\n', '\n', '        // fire event\n', '        emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '    }\n', '\n', '    // Atomically increases the allowance granted to `spender` by the caller.\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 final_allowance =\n', '            SafeMath.add(_allowances[msg.sender][spender], addedValue);\n', '\n', '        _approve(msg.sender, spender, final_allowance);\n', '        return true;\n', '    }\n', '\n', '    //Atomically decreases the allowance granted to `spender` by the caller.\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 final_allowance =\n', '            SafeMath.sub(_allowances[msg.sender][spender], subtractedValue);\n', '\n', '        _approve(msg.sender, spender, final_allowance);\n', '        return true;\n', '    }\n', '\n', '    // Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '        _allowances[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two numbers, throws on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, throws on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']