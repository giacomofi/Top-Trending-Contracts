['pragma solidity 0.5.16;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./MorpherState.sol";\n', 'import "./IMorpherStaking.sol";\n', 'import "./MorpherMintingLimiter.sol";\n', '\n', '// ----------------------------------------------------------------------------------\n', '// Tradeengine of the Morpher platform\n', '// Creates and processes orders, and computes the state change of portfolio.\n', '// Needs writing/reading access to/from Morpher State. Order objects are stored locally,\n', '// portfolios are stored in state.\n', '// ----------------------------------------------------------------------------------\n', '\n', 'contract MorpherTradeEngine is Ownable {\n', '    MorpherState state;\n', '    IMorpherStaking staking;\n', '    MorpherMintingLimiter mintingLimiter;\n', '    using SafeMath for uint256;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Precision of prices and leverage\n', '// ----------------------------------------------------------------------------\n', '    uint256 constant PRECISION = 10**8;\n', '    uint256 public orderNonce;\n', '    bytes32 public lastOrderId;\n', '    uint256 public deployedTimeStamp;\n', '\n', '    address public escrowOpenOrderAddress = 0x1111111111111111111111111111111111111111;\n', '    bool public escrowOpenOrderEnabled;\n', '\n', '\n', "    //we're locking positions in for this price at a market marketId;\n", '    address public closedMarketPriceLock = 0x0000000000000000000000000000000000000001;\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Order struct contains all order specific varibles. Variables are completed\n', '// during processing of trade. State changes are saved in the order struct as\n', '// well, since local variables would lead to stack to deep errors *sigh*.\n', '// ----------------------------------------------------------------------------\n', '    struct order {\n', '        address userId;\n', '        bytes32 marketId;\n', '        uint256 closeSharesAmount;\n', '        uint256 openMPHTokenAmount;\n', '        bool tradeDirection; // true = long, false = short\n', '        uint256 liquidationTimestamp;\n', '        uint256 marketPrice;\n', '        uint256 marketSpread;\n', '        uint256 orderLeverage;\n', '        uint256 timeStamp;\n', '        uint256 longSharesOrder;\n', '        uint256 shortSharesOrder;\n', '        uint256 balanceDown;\n', '        uint256 balanceUp;\n', '        uint256 newLongShares;\n', '        uint256 newShortShares;\n', '        uint256 newMeanEntryPrice;\n', '        uint256 newMeanEntrySpread;\n', '        uint256 newMeanEntryLeverage;\n', '        uint256 newLiquidationPrice;\n', '        uint256 orderEscrowAmount;\n', '    }\n', '\n', '    mapping(bytes32 => order) private orders;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Events\n', '// Order created/processed events are fired by MorpherOracle.\n', '// ----------------------------------------------------------------------------\n', '\n', '    event PositionLiquidated(\n', '        address indexed _address,\n', '        bytes32 indexed _marketId,\n', '        bool _longPosition,\n', '        uint256 _timeStamp,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread\n', '    );\n', '\n', '    event OrderCancelled(\n', '        bytes32 indexed _orderId,\n', '        address indexed _address\n', '    );\n', '\n', '    event OrderIdRequested(\n', '        bytes32 _orderId,\n', '        address indexed _address,\n', '        bytes32 indexed _marketId,\n', '        uint256 _closeSharesAmount,\n', '        uint256 _openMPHTokenAmount,\n', '        bool _tradeDirection,\n', '        uint256 _orderLeverage\n', '    );\n', '\n', '    event OrderProcessed(\n', '        bytes32 _orderId,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread,\n', '        uint256 _liquidationTimestamp,\n', '        uint256 _timeStamp,\n', '        uint256 _newLongShares,\n', '        uint256 _newShortShares,\n', '        uint256 _newAverageEntry,\n', '        uint256 _newAverageSpread,\n', '        uint256 _newAverageLeverage,\n', '        uint256 _liquidationPrice\n', '    );\n', '\n', '    event PositionUpdated(\n', '        address _userId,\n', '        bytes32 _marketId,\n', '        uint256 _timeStamp,\n', '        uint256 _newLongShares,\n', '        uint256 _newShortShares,\n', '        uint256 _newMeanEntryPrice,\n', '        uint256 _newMeanEntrySpread,\n', '        uint256 _newMeanEntryLeverage,\n', '        uint256 _newLiquidationPrice,\n', '        uint256 _mint,\n', '        uint256 _burn\n', '    );\n', '\n', '    event LinkState(address _address);\n', '    event LinkStaking(address _stakingAddress);\n', '    event LinkMintingLimiter(address _mintingLimiterAddress);\n', '\n', '    \n', '    event LockedPriceForClosingPositions(bytes32 _marketId, uint256 _price);\n', '\n', '\n', '    constructor(address _stateAddress, address _coldStorageOwnerAddress, address _stakingContractAddress, bool _escrowOpenOrderEnabled, uint256 _deployedTimestampOverride, address _mintingLimiterAddress) public {\n', '        setMorpherState(_stateAddress);\n', '        setMorpherStaking(_stakingContractAddress);\n', '        setMorpherMintingLimiter(_mintingLimiterAddress);\n', '        transferOwnership(_coldStorageOwnerAddress);\n', '        escrowOpenOrderEnabled = _escrowOpenOrderEnabled;\n', '        deployedTimeStamp = _deployedTimestampOverride > 0 ? _deployedTimestampOverride : block.timestamp;\n', '    }\n', '\n', '    modifier onlyOracle {\n', '        require(msg.sender == state.getOracleContract(), "MorpherTradeEngine: function can only be called by Oracle Contract.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdministrator {\n', '        require(msg.sender == getAdministrator(), "MorpherTradeEngine: function can only be called by the Administrator.");\n', '        _;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Administrative functions\n', '// Set state address, get administrator address\n', '// ----------------------------------------------------------------------------\n', '\n', '    function setMorpherState(address _stateAddress) public onlyOwner {\n', '        state = MorpherState(_stateAddress);\n', '        emit LinkState(_stateAddress);\n', '    }\n', '\n', '    function setMorpherStaking(address _stakingAddress) public onlyOwner {\n', '        staking = IMorpherStaking(_stakingAddress);\n', '        emit LinkStaking(_stakingAddress);\n', '    }\n', '\n', '    function setMorpherMintingLimiter(address _mintingLimiterAddress) public onlyOwner {\n', '        mintingLimiter = MorpherMintingLimiter(_mintingLimiterAddress);\n', '        emit LinkMintingLimiter(_mintingLimiterAddress);\n', '    }\n', '\n', '    function getAdministrator() public view returns(address _administrator) {\n', '        return state.getAdministrator();\n', '    }\n', '\n', '    function setEscrowOpenOrderEnabled(bool _isEnabled) public onlyOwner {\n', '        escrowOpenOrderEnabled = _isEnabled;\n', '    }\n', '    \n', '    function paybackEscrow(bytes32 _orderId) private {\n', '        //pay back the escrow to the user so he has it back on his balance/**\n', '        if(orders[_orderId].orderEscrowAmount > 0) {\n', '            //checks effects interaction\n', '            uint256 paybackAmount = orders[_orderId].orderEscrowAmount;\n', '            orders[_orderId].orderEscrowAmount = 0;\n', '            state.transfer(escrowOpenOrderAddress, orders[_orderId].userId, paybackAmount);\n', '        }\n', '    }\n', '\n', '    function buildupEscrow(bytes32 _orderId, uint256 _amountInMPH) private {\n', '        if(escrowOpenOrderEnabled && _amountInMPH > 0) {\n', '            state.transfer(orders[_orderId].userId, escrowOpenOrderAddress, _amountInMPH);\n', '            orders[_orderId].orderEscrowAmount = _amountInMPH;\n', '        }\n', '    }\n', '\n', '\n', '    function validateClosedMarketOrderConditions(address _address, bytes32 _marketId, uint256 _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection ) internal view {\n', '        //markets active? Still tradeable?\n', '        if(_openMPHTokenAmount > 0) {\n', '            require(state.getMarketActive(_marketId) == true, "MorpherTradeEngine: market unknown or currently not enabled for trading.");\n', '        } else {\n', "            //we're just closing a position, but it needs a forever price locked in if market is not active\n", '            //the user needs to close his complete position\n', '            if(state.getMarketActive(_marketId) == false) {\n', '                require(getDeactivatedMarketPrice(_marketId) > 0, "MorpherTradeEngine: Can\'t close a position, market not active and closing price not locked");\n', '                if(_tradeDirection) {\n', '                    //long\n', '                    require(_closeSharesAmount == state.getShortShares(_address, _marketId), "MorpherTradeEngine: Deactivated market order needs all shares to be closed");\n', '                } else {\n', '                    //short\n', '                    require(_closeSharesAmount == state.getLongShares(_address, _marketId), "MorpherTradeEngine: Deactivated market order needs all shares to be closed");\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    //wrapper for stack too deep errors\n', '    function validateClosedMarketOrder(bytes32 _orderId) internal view {\n', '         validateClosedMarketOrderConditions(orders[_orderId].userId, orders[_orderId].marketId, orders[_orderId].closeSharesAmount, orders[_orderId].openMPHTokenAmount, orders[_orderId].tradeDirection);\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// requestOrderId(address _address, bytes32 _marketId, bool _closeSharesAmount, uint256 _openMPHTokenAmount, bool _tradeDirection, uint256 _orderLeverage)\n', '// Creates a new order object with unique orderId and assigns order information.\n', '// Must be called by MorpherOracle contract.\n', '// ----------------------------------------------------------------------------\n', '\n', '    function requestOrderId(\n', '        address _address,\n', '        bytes32 _marketId,\n', '        uint256 _closeSharesAmount,\n', '        uint256 _openMPHTokenAmount,\n', '        bool _tradeDirection,\n', '        uint256 _orderLeverage\n', '        ) public onlyOracle returns (bytes32 _orderId) {\n', '            \n', '        require(_orderLeverage >= PRECISION, "MorpherTradeEngine: leverage too small. Leverage precision is 1e8");\n', '        require(_orderLeverage <= state.getMaximumLeverage(), "MorpherTradeEngine: leverage exceeds maximum allowed leverage.");\n', '\n', '        validateClosedMarketOrderConditions(_address, _marketId, _closeSharesAmount, _openMPHTokenAmount, _tradeDirection);\n', '\n', '        //request limits\n', '        require(state.getNumberOfRequests(_address) <= state.getNumberOfRequestsLimit() ||\n', '            state.getLastRequestBlock(_address) < block.number,\n', '            "MorpherTradeEngine: request exceeded maximum permitted requests per block."\n', '        );\n', '\n', '        /**\n', "         * The user can't partially close a position and open another one with MPH\n", '         */\n', '        if(_openMPHTokenAmount > 0) {\n', '            if(_tradeDirection) {\n', '                //long\n', '                require(_closeSharesAmount == state.getShortShares(_address, _marketId), "MorpherTradeEngine: Can\'t partially close a position and open another one in opposite direction");\n', '            } else {\n', '                //short\n', '                require(_closeSharesAmount == state.getLongShares(_address, _marketId), "MorpherTradeEngine: Can\'t partially close a position and open another one in opposite direction");\n', '            }\n', '        }\n', '\n', '        state.setLastRequestBlock(_address);\n', '        state.increaseNumberOfRequests(_address);\n', '        orderNonce++;\n', '        _orderId = keccak256(\n', '            abi.encodePacked(\n', '                _address,\n', '                block.number,\n', '                _marketId,\n', '                _closeSharesAmount,\n', '                _openMPHTokenAmount,\n', '                _tradeDirection,\n', '                _orderLeverage,\n', '                orderNonce\n', '                )\n', '            );\n', '        lastOrderId = _orderId;\n', '        orders[_orderId].userId = _address;\n', '        orders[_orderId].marketId = _marketId;\n', '        orders[_orderId].closeSharesAmount = _closeSharesAmount;\n', '        orders[_orderId].openMPHTokenAmount = _openMPHTokenAmount;\n', '        orders[_orderId].tradeDirection = _tradeDirection;\n', '        orders[_orderId].orderLeverage = _orderLeverage;\n', '        emit OrderIdRequested(\n', '            _orderId,\n', '            _address,\n', '            _marketId,\n', '            _closeSharesAmount,\n', '            _openMPHTokenAmount,\n', '            _tradeDirection,\n', '            _orderLeverage\n', '        );\n', '\n', '        /**\n', '         * put the money in escrow here if given MPH to open an order\n', '         * - also, can only close positions if in shares, so it will\n', '         * definitely trigger a mint there.\n', '         * The money must be put in escrow even though we have an existing position\n', '         */\n', '        buildupEscrow(_orderId, _openMPHTokenAmount);\n', '\n', '        return _orderId;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// Getter functions for orders, shares, and positions\n', '// ----------------------------------------------------------------------------\n', '\n', '    function getOrder(bytes32 _orderId) public view returns (\n', '        address _userId,\n', '        bytes32 _marketId,\n', '        uint256 _closeSharesAmount,\n', '        uint256 _openMPHTokenAmount,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread,\n', '        uint256 _orderLeverage\n', '        ) {\n', '        return(\n', '            orders[_orderId].userId,\n', '            orders[_orderId].marketId,\n', '            orders[_orderId].closeSharesAmount,\n', '            orders[_orderId].openMPHTokenAmount,\n', '            orders[_orderId].marketPrice,\n', '            orders[_orderId].marketSpread,\n', '            orders[_orderId].orderLeverage\n', '            );\n', '    }\n', '\n', '    function getPosition(address _address, bytes32 _marketId) public view returns (\n', '        uint256 _positionLongShares,\n', '        uint256 _positionShortShares,\n', '        uint256 _positionAveragePrice,\n', '        uint256 _positionAverageSpread,\n', '        uint256 _positionAverageLeverage,\n', '        uint256 _liquidationPrice\n', '        ) {\n', '        return(\n', '            state.getLongShares(_address, _marketId),\n', '            state.getShortShares(_address, _marketId),\n', '            state.getMeanEntryPrice(_address,_marketId),\n', '            state.getMeanEntrySpread(_address,_marketId),\n', '            state.getMeanEntryLeverage(_address,_marketId),\n', '            state.getLiquidationPrice(_address,_marketId)\n', '        );\n', '    }\n', '\n', '    function setDeactivatedMarketPrice(bytes32 _marketId, uint256 _price) public onlyOracle {\n', '         state.setPosition(\n', '            closedMarketPriceLock,\n', '            _marketId,\n', '            now.mul(1000),\n', '            0,\n', '            0,\n', '            _price,\n', '            0,\n', '            0,\n', '            0\n', '        );\n', '\n', '        emit LockedPriceForClosingPositions(_marketId, _price);\n', '\n', '    }\n', '\n', '    function getDeactivatedMarketPrice(bytes32 _marketId) public view returns(uint256) {\n', '        ( , , uint positionForeverClosingPrice, , ,) = state.getPosition(closedMarketPriceLock, _marketId);\n', '        return positionForeverClosingPrice;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// liquidate(bytes32 _orderId)\n', '// Checks for bankruptcy of position between its last update and now\n', '// Time check is necessary to avoid two consecutive / unorderded liquidations\n', '// ----------------------------------------------------------------------------\n', '\n', '    function liquidate(bytes32 _orderId) private {\n', '        address _address = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '        uint256 _liquidationTimestamp = orders[_orderId].liquidationTimestamp;\n', '        if (_liquidationTimestamp > state.getLastUpdated(_address, _marketId)) {\n', '            if (state.getLongShares(_address,_marketId) > 0) {\n', '                state.setPosition(\n', '                    _address,\n', '                    _marketId,\n', '                    orders[_orderId].timeStamp,\n', '                    0,\n', '                    state.getShortShares(_address, _marketId),\n', '                    0,\n', '                    0,\n', '                    PRECISION,\n', '                    0);\n', '                emit PositionLiquidated(\n', '                    _address,\n', '                    _marketId,\n', '                    true,\n', '                    orders[_orderId].timeStamp,\n', '                    orders[_orderId].marketPrice,\n', '                    orders[_orderId].marketSpread\n', '                );\n', '            }\n', '            if (state.getShortShares(_address,_marketId) > 0) {\n', '                state.setPosition(\n', '                    _address,\n', '                    _marketId,\n', '                    orders[_orderId].timeStamp,\n', '                    state.getLongShares(_address, _marketId),\n', '                    0,\n', '                    0,\n', '                    0,\n', '                    PRECISION,\n', '                    0\n', '                );\n', '                emit PositionLiquidated(\n', '                    _address,\n', '                    _marketId,\n', '                    false,\n', '                    orders[_orderId].timeStamp,\n', '                    orders[_orderId].marketPrice,\n', '                    orders[_orderId].marketSpread\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// processOrder(bytes32 _orderId, uint256 _marketPrice, uint256 _marketSpread, uint256 _liquidationTimestamp, uint256 _timeStamp)\n', '// ProcessOrder receives the price/spread/liqidation information from the Oracle and\n', '// triggers the processing of the order. If successful, processOrder updates the portfolio state.\n', '// Liquidation time check is necessary to avoid two consecutive / unorderded liquidations\n', '// ----------------------------------------------------------------------------\n', '\n', '    function processOrder(\n', '        bytes32 _orderId,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread,\n', '        uint256 _liquidationTimestamp,\n', '        uint256 _timeStampInMS\n', '        ) public onlyOracle returns (\n', '            uint256 _newLongShares,\n', '            uint256 _newShortShares,\n', '            uint256 _newAverageEntry,\n', '            uint256 _newAverageSpread,\n', '            uint256 _newAverageLeverage,\n', '            uint256 _liquidationPrice\n', '        ) {\n', '        require(orders[_orderId].userId != address(0), "MorpherTradeEngine: unable to process, order has been deleted.");\n', '        require(_marketPrice > 0, "MorpherTradeEngine: market priced at zero. Buy order cannot be processed.");\n', '        require(_marketPrice >= _marketSpread, "MorpherTradeEngine: market price lower then market spread. Order cannot be processed.");\n', '        \n', '        orders[_orderId].marketPrice = _marketPrice;\n', '        orders[_orderId].marketSpread = _marketSpread;\n', '        orders[_orderId].timeStamp = _timeStampInMS;\n', '        orders[_orderId].liquidationTimestamp = _liquidationTimestamp;\n', '        \n', '        /**\n', '        * If the market is deactivated, then override the price with the locked in market price\n', "        * if the price wasn't locked in: error out.\n", '        */\n', '        if(state.getMarketActive(orders[_orderId].marketId) == false) {\n', '            validateClosedMarketOrder(_orderId);\n', '            orders[_orderId].marketPrice = getDeactivatedMarketPrice(orders[_orderId].marketId);\n', '        }\n', '        \n', '        // Check if previous position on that market was liquidated\n', '        if (_liquidationTimestamp > state.getLastUpdated(orders[_orderId].userId, orders[_orderId].marketId)) {\n', '            liquidate(_orderId);\n', '        }\n', '    \n', '\n', '        paybackEscrow(_orderId);\n', '\n', '        if (orders[_orderId].tradeDirection) {\n', '            processBuyOrder(_orderId);\n', '        } else {\n', '            processSellOrder(_orderId);\n', '        }\n', '\n', '        address _address = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '        delete orders[_orderId];\n', '        emit OrderProcessed(\n', '            _orderId,\n', '            _marketPrice,\n', '            _marketSpread,\n', '            _liquidationTimestamp,\n', '            _timeStampInMS,\n', '            _newLongShares,\n', '            _newShortShares,\n', '            _newAverageEntry,\n', '            _newAverageSpread,\n', '            _newAverageLeverage,\n', '            _liquidationPrice\n', '        );\n', '\n', '        return (\n', '            state.getLongShares(_address, _marketId),\n', '            state.getShortShares(_address, _marketId),\n', '            state.getMeanEntryPrice(_address,_marketId),\n', '            state.getMeanEntrySpread(_address,_marketId),\n', '            state.getMeanEntryLeverage(_address,_marketId),\n', '            state.getLiquidationPrice(_address,_marketId)\n', '        );\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// function cancelOrder(bytes32 _orderId, address _address)\n', '// Users or Administrator can delete pending orders before the callback went through\n', '// ----------------------------------------------------------------------------\n', '    function cancelOrder(bytes32 _orderId, address _address) public onlyOracle {\n', '        require(_address == orders[_orderId].userId || _address == getAdministrator(), "MorpherTradeEngine: only Administrator or user can cancel an order.");\n', '        require(orders[_orderId].userId != address(0), "MorpherTradeEngine: unable to process, order does not exist.");\n', '\n', '        /**\n', '         * Pay back any escrow there\n', '         */\n', '        paybackEscrow(_orderId);\n', '\n', '        delete orders[_orderId];\n', '        emit OrderCancelled(_orderId, _address);\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// shortShareValue / longShareValue compute the value of a virtual future\n', '// given current price/spread/leverage of the market and mean price/spread/leverage\n', '// at the beginning of the trade\n', '// ----------------------------------------------------------------------------\n', '    function shortShareValue(\n', '        uint256 _positionAveragePrice,\n', '        uint256 _positionAverageLeverage,\n', '        uint256 _positionTimeStampInMs,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread,\n', '        uint256 _orderLeverage,\n', '        bool _sell\n', '        ) public view returns (uint256 _shareValue) {\n', '\n', '        uint256 _averagePrice = _positionAveragePrice;\n', '        uint256 _averageLeverage = _positionAverageLeverage;\n', '\n', '        if (_positionAverageLeverage < PRECISION) {\n', '            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\n', '            _averageLeverage = PRECISION;\n', '        }\n', '        if (_sell == false) {\n', '            // New short position\n', '            // It costs marketPrice + marketSpread to build up a new short position\n', '            _averagePrice = _marketPrice;\n', '\t        // This is the average Leverage\n', '\t        _averageLeverage = _orderLeverage;\n', '        }\n', '        if (\n', '            getLiquidationPrice(_averagePrice, _averageLeverage, false, _positionTimeStampInMs) <= _marketPrice\n', '            ) {\n', '\t        // Position is worthless\n', '            _shareValue = 0;\n', '        } else {\n', '            // The regular share value is 2x the entry price minus the current price for short positions.\n', '            _shareValue = _averagePrice.mul((PRECISION.add(_averageLeverage))).div(PRECISION);\n', '            _shareValue = _shareValue.sub(_marketPrice.mul(_averageLeverage).div(PRECISION));\n', '            if (_sell == true) {\n', '                // We have to reduce the share value by the average spread (i.e. the average expense to build up the position)\n', '                // and reduce the value further by the spread for selling.\n', '                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\n', '                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\n', '                if (_marginInterest <= _shareValue) {\n', '                    _shareValue = _shareValue.sub(_marginInterest);\n', '                } else {\n', '                    _shareValue = 0;\n', '                }\n', '            } else {\n', '                // If a new short position is built up each share costs value + spread\n', '                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\n', '            }\n', '        }\n', '      \n', '        return _shareValue;\n', '    }\n', '\n', '    function longShareValue(\n', '        uint256 _positionAveragePrice,\n', '        uint256 _positionAverageLeverage,\n', '        uint256 _positionTimeStampInMs,\n', '        uint256 _marketPrice,\n', '        uint256 _marketSpread,\n', '        uint256 _orderLeverage,\n', '        bool _sell\n', '        ) public view returns (uint256 _shareValue) {\n', '\n', '        uint256 _averagePrice = _positionAveragePrice;\n', '        uint256 _averageLeverage = _positionAverageLeverage;\n', '\n', '        if (_positionAverageLeverage < PRECISION) {\n', '            // Leverage can never be less than 1. Fail safe for empty positions, i.e. undefined _positionAverageLeverage\n', '            _averageLeverage = PRECISION;\n', '        }\n', '        if (_sell == false) {\n', '            // New long position\n', '            // It costs marketPrice + marketSpread to build up a new long position\n', '            _averagePrice = _marketPrice;\n', '\t        // This is the average Leverage\n', '\t        _averageLeverage = _orderLeverage;\n', '        }\n', '        if (\n', '            _marketPrice <= getLiquidationPrice(_averagePrice, _averageLeverage, true, _positionTimeStampInMs)\n', '            ) {\n', '\t        // Position is worthless\n', '            _shareValue = 0;\n', '        } else {\n', '            _shareValue = _averagePrice.mul(_averageLeverage.sub(PRECISION)).div(PRECISION);\n', '            // The regular share value is market price times leverage minus entry price times entry leverage minus one.\n', '            _shareValue = (_marketPrice.mul(_averageLeverage).div(PRECISION)).sub(_shareValue);\n', '            if (_sell == true) {\n', '                // We sell a long and have to correct the shareValue with the averageSpread and the currentSpread for selling.\n', '                _shareValue = _shareValue.sub(_marketSpread.mul(_averageLeverage).div(PRECISION));\n', '                \n', '                uint256 _marginInterest = calculateMarginInterest(_averagePrice, _averageLeverage, _positionTimeStampInMs);\n', '                if (_marginInterest <= _shareValue) {\n', '                    _shareValue = _shareValue.sub(_marginInterest);\n', '                } else {\n', '                    _shareValue = 0;\n', '                }\n', '            } else {\n', '                // We buy a new long position and have to pay the spread\n', '                _shareValue = _shareValue.add(_marketSpread.mul(_orderLeverage).div(PRECISION));\n', '            }\n', '        }\n', '        return _shareValue;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStamp)\n', '// Calculates the interest for leveraged positions\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '    function calculateMarginInterest(uint256 _averagePrice, uint256 _averageLeverage, uint256 _positionTimeStampInMs) public view returns (uint256 _marginInterest) {\n', '        if (_positionTimeStampInMs.div(1000) < deployedTimeStamp) {\n', '            _positionTimeStampInMs = deployedTimeStamp.mul(1000);\n', '        }\n', '        _marginInterest = _averagePrice.mul(_averageLeverage.sub(PRECISION));\n', '        _marginInterest = _marginInterest.mul((now.sub(_positionTimeStampInMs.div(1000)).div(86400)).add(1));\n', '        _marginInterest = _marginInterest.mul(staking.interestRate()).div(PRECISION).div(PRECISION);\n', '        return _marginInterest;\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// processBuyOrder(bytes32 _orderId)\n', '// Converts orders specified in virtual shares to orders specified in Morpher token\n', '// and computes the number of short shares that are sold and long shares that are bought.\n', '// long shares are bought only if the order amount exceeds all open short positions\n', '// ----------------------------------------------------------------------------\n', '\n', '    function processBuyOrder(bytes32 _orderId) private {\n', '        if (orders[_orderId].closeSharesAmount > 0) {\n', '            //calcualte the balanceUp/down first\n', '            //then reopen the position with MPH amount\n', '\n', '             // Investment was specified in shares\n', '            if (orders[_orderId].closeSharesAmount <= state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId)) {\n', '                // Partial closing of short position\n', '                orders[_orderId].shortSharesOrder = orders[_orderId].closeSharesAmount;\n', '            } else {\n', '                // Closing of entire short position\n', '                orders[_orderId].shortSharesOrder = state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId);\n', '            }\n', '        }\n', '\n', '        //calculate the long shares, but only if the old position is completely closed out (if none exist shortSharesOrder = 0)\n', '        if(\n', '            orders[_orderId].shortSharesOrder == state.getShortShares(orders[_orderId].userId, orders[_orderId].marketId) && \n', '            orders[_orderId].openMPHTokenAmount > 0\n', '        ) {\n', '            orders[_orderId].longSharesOrder = orders[_orderId].openMPHTokenAmount.div(\n', '                longShareValue(\n', '                    orders[_orderId].marketPrice,\n', '                    orders[_orderId].orderLeverage,\n', '                    now,\n', '                    orders[_orderId].marketPrice,\n', '                    orders[_orderId].marketSpread,\n', '                    orders[_orderId].orderLeverage,\n', '                    false\n', '            ));\n', '        }\n', '\n', '        // Investment equals number of shares now.\n', '        if (orders[_orderId].shortSharesOrder > 0) {\n', '            closeShort(_orderId);\n', '        }\n', '        if (orders[_orderId].longSharesOrder > 0) {\n', '            openLong(_orderId);\n', '        }\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// processSellOrder(bytes32 _orderId)\n', '// Converts orders specified in virtual shares to orders specified in Morpher token\n', '// and computes the number of long shares that are sold and short shares that are bought.\n', '// short shares are bought only if the order amount exceeds all open long positions\n', '// ----------------------------------------------------------------------------\n', '\n', '    function processSellOrder(bytes32 _orderId) private {\n', '        if (orders[_orderId].closeSharesAmount > 0) {\n', '            //calcualte the balanceUp/down first\n', '            //then reopen the position with MPH amount\n', '\n', '            // Investment was specified in shares\n', '            if (orders[_orderId].closeSharesAmount <= state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId)) {\n', '                // Partial closing of long position\n', '                orders[_orderId].longSharesOrder = orders[_orderId].closeSharesAmount;\n', '            } else {\n', '                // Closing of entire long position\n', '                orders[_orderId].longSharesOrder = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\n', '            }\n', '        }\n', '\n', '        if(\n', '            orders[_orderId].longSharesOrder == state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId) && \n', '            orders[_orderId].openMPHTokenAmount > 0\n', '        ) {\n', '        orders[_orderId].shortSharesOrder = orders[_orderId].openMPHTokenAmount.div(\n', '                    shortShareValue(\n', '                        orders[_orderId].marketPrice,\n', '                        orders[_orderId].orderLeverage,\n', '                        now,\n', '                        orders[_orderId].marketPrice,\n', '                        orders[_orderId].marketSpread,\n', '                        orders[_orderId].orderLeverage,\n', '                        false\n', '                ));\n', '        }\n', '        // Investment equals number of shares now.\n', '        if (orders[_orderId].longSharesOrder > 0) {\n', '            closeLong(_orderId);\n', '        }\n', '        if (orders[_orderId].shortSharesOrder > 0) {\n', '            openShort(_orderId);\n', '        }\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// openLong(bytes32 _orderId)\n', '// Opens a new long position and computes the new resulting average entry price/spread/leverage.\n', '// Computation is broken down to several instructions for readability.\n', '// ----------------------------------------------------------------------------\n', '    function openLong(bytes32 _orderId) private {\n', '        address _userId = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '\n', '        uint256 _newMeanSpread;\n', '        uint256 _newMeanLeverage;\n', '\n', '        // Existing position is virtually liquidated and reopened with current marketPrice\n', '        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n', '        // _factorLongShares is a factor to adjust the existing longShares via virtual liqudiation and reopening at current market price\n', '\n', '        uint256 _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId);\n', '        if (_factorLongShares < PRECISION) {\n', '            _factorLongShares = PRECISION;\n', '        }\n', '        _factorLongShares = _factorLongShares.sub(PRECISION);\n', '        _factorLongShares = _factorLongShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\n', '        if (state.getMeanEntryLeverage(_userId, _marketId) > _factorLongShares) {\n', '            _factorLongShares = state.getMeanEntryLeverage(_userId, _marketId).sub(_factorLongShares);\n', '        } else {\n', '            _factorLongShares = 0;\n', '        }\n', '\n', '        uint256 _adjustedLongShares = _factorLongShares.mul(state.getLongShares(_userId, _marketId)).div(PRECISION);\n', '\n', '        // _newMeanLeverage is the weighted leverage of the existing position and the new position\n', '        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedLongShares);\n', '        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].longSharesOrder));\n', '        _newMeanLeverage = _newMeanLeverage.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\n', '\n', '        // _newMeanSpread is the weighted spread of the existing position and the new position\n', '        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getLongShares(_userId, _marketId));\n', '        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].longSharesOrder));\n', '        _newMeanSpread = _newMeanSpread.div(_adjustedLongShares.add(orders[_orderId].longSharesOrder));\n', '\n', '        orders[_orderId].balanceDown = orders[_orderId].longSharesOrder.mul(orders[_orderId].marketPrice).add(\n', '            orders[_orderId].longSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\n', '        );\n', '        orders[_orderId].balanceUp = 0;\n', '        orders[_orderId].newLongShares = _adjustedLongShares.add(orders[_orderId].longSharesOrder);\n', '        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\n', '        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n', '        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n', '        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n', '\n', '        setPositionInState(_orderId);\n', '    }\n', '// ----------------------------------------------------------------------------\n', '// closeLong(bytes32 _orderId)\n', '// Closes an existing long position. Average entry price/spread/leverage do not change.\n', '// ----------------------------------------------------------------------------\n', '     function closeLong(bytes32 _orderId) private {\n', '        address _userId = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '        uint256 _newLongShares  = state.getLongShares(_userId, _marketId).sub(orders[_orderId].longSharesOrder);\n', '        uint256 _balanceUp = calculateBalanceUp(_orderId);\n', '        uint256 _newMeanEntry;\n', '        uint256 _newMeanSpread;\n', '        uint256 _newMeanLeverage;\n', '\n', '        if (orders[_orderId].longSharesOrder == state.getLongShares(_userId, _marketId)) {\n', '            _newMeanEntry = 0;\n', '            _newMeanSpread = 0;\n', '            _newMeanLeverage = PRECISION;\n', '        } else {\n', '            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\n', '\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\n', '\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\n', '            resetTimestampInOrderToLastUpdated(_orderId);\n', '        }\n', '\n', '        orders[_orderId].balanceDown = 0;\n', '        orders[_orderId].balanceUp = _balanceUp;\n', '        orders[_orderId].newLongShares = _newLongShares;\n', '        orders[_orderId].newShortShares = state.getShortShares(_userId, _marketId);\n', '        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\n', '        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n', '        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n', '\n', '        setPositionInState(_orderId);\n', '    }\n', '\n', 'event ResetTimestampInOrder(bytes32 _orderId, uint oldTimestamp, uint newTimestamp);\n', 'function resetTimestampInOrderToLastUpdated(bytes32 _orderId) internal {\n', '    address userId = orders[_orderId].userId;\n', '    bytes32 marketId = orders[_orderId].marketId;\n', '    uint lastUpdated = state.getLastUpdated(userId, marketId);\n', '    emit ResetTimestampInOrder(_orderId, orders[_orderId].timeStamp, lastUpdated);\n', '    orders[_orderId].timeStamp = lastUpdated;\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// closeShort(bytes32 _orderId)\n', '// Closes an existing short position. Average entry price/spread/leverage do not change.\n', '// ----------------------------------------------------------------------------\n', 'function calculateBalanceUp(bytes32 _orderId) private view returns (uint256 _balanceUp) {\n', '        address _userId = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '        uint256 _shareValue;\n', '\n', '        if (orders[_orderId].tradeDirection == false) { //we are selling our long shares\n', '            _balanceUp = orders[_orderId].longSharesOrder;\n', '            _shareValue = longShareValue(\n', '                state.getMeanEntryPrice(_userId, _marketId),\n', '                state.getMeanEntryLeverage(_userId, _marketId),\n', '                state.getLastUpdated(_userId, _marketId),\n', '                orders[_orderId].marketPrice,\n', '                orders[_orderId].marketSpread,\n', '                state.getMeanEntryLeverage(_userId, _marketId),\n', '                true\n', '            );\n', '        } else { //we are going long, we are selling our short shares\n', '            _balanceUp = orders[_orderId].shortSharesOrder;\n', '            _shareValue = shortShareValue(\n', '                state.getMeanEntryPrice(_userId, _marketId),\n', '                state.getMeanEntryLeverage(_userId, _marketId),\n', '                state.getLastUpdated(_userId, _marketId),\n', '                orders[_orderId].marketPrice,\n', '                orders[_orderId].marketSpread,\n', '                state.getMeanEntryLeverage(_userId, _marketId),\n', '                true\n', '            );\n', '        }\n', '        return _balanceUp.mul(_shareValue); \n', '    }\n', '\n', '    function closeShort(bytes32 _orderId) private {\n', '        address _userId = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '        uint256 _newMeanEntry;\n', '        uint256 _newMeanSpread;\n', '        uint256 _newMeanLeverage;\n', '        uint256 _newShortShares = state.getShortShares(_userId, _marketId).sub(orders[_orderId].shortSharesOrder);\n', '        uint256 _balanceUp = calculateBalanceUp(_orderId);\n', '        \n', '        if (orders[_orderId].shortSharesOrder == state.getShortShares(_userId, _marketId)) {\n', '            _newMeanEntry = 0;\n', '            _newMeanSpread = 0;\n', '\t        _newMeanLeverage = PRECISION;\n', '        } else {\n', '            _newMeanEntry = state.getMeanEntryPrice(_userId, _marketId);\n', '\t        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId);\n', '\t        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId);\n', '\n', '            /**\n', '             * we need the timestamp of the old order for partial closes, not the new one\n', '             */\n', '            resetTimestampInOrderToLastUpdated(_orderId);\n', '        }\n', '\n', '        orders[_orderId].balanceDown = 0;\n', '        orders[_orderId].balanceUp = _balanceUp;\n', '        orders[_orderId].newLongShares = state.getLongShares(orders[_orderId].userId, orders[_orderId].marketId);\n', '        orders[_orderId].newShortShares = _newShortShares;\n', '        orders[_orderId].newMeanEntryPrice = _newMeanEntry;\n', '        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n', '        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n', '\n', '        setPositionInState(_orderId);\n', '    }\n', '\n', '// ----------------------------------------------------------------------------\n', '// openShort(bytes32 _orderId)\n', '// Opens a new short position and computes the new resulting average entry price/spread/leverage.\n', '// Computation is broken down to several instructions for readability.\n', '// ----------------------------------------------------------------------------\n', '    function openShort(bytes32 _orderId) private {\n', '        address _userId = orders[_orderId].userId;\n', '        bytes32 _marketId = orders[_orderId].marketId;\n', '\n', '        uint256 _newMeanSpread;\n', '        uint256 _newMeanLeverage;\n', '        //\n', '        // Existing position is virtually liquidated and reopened with current marketPrice\n', '        // orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n', '        // _factorShortShares is a factor to adjust the existing shortShares via virtual liqudiation and reopening at current market price\n', '\n', '        uint256 _factorShortShares = state.getMeanEntryLeverage(_userId, _marketId);\n', '        if (_factorShortShares < PRECISION) {\n', '            _factorShortShares = PRECISION;\n', '        }\n', '        _factorShortShares = _factorShortShares.add(PRECISION);\n', '        _factorShortShares = _factorShortShares.mul(state.getMeanEntryPrice(_userId, _marketId)).div(orders[_orderId].marketPrice);\n', '        if (state.getMeanEntryLeverage(_userId, _marketId) < _factorShortShares) {\n', '            _factorShortShares = _factorShortShares.sub(state.getMeanEntryLeverage(_userId, _marketId));\n', '        } else {\n', '            _factorShortShares = 0;\n', '        }\n', '\n', '        uint256 _adjustedShortShares = _factorShortShares.mul(state.getShortShares(_userId, _marketId)).div(PRECISION);\n', '\n', '        // _newMeanLeverage is the weighted leverage of the existing position and the new position\n', '        _newMeanLeverage = state.getMeanEntryLeverage(_userId, _marketId).mul(_adjustedShortShares);\n', '        _newMeanLeverage = _newMeanLeverage.add(orders[_orderId].orderLeverage.mul(orders[_orderId].shortSharesOrder));\n', '        _newMeanLeverage = _newMeanLeverage.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\n', '\n', '        // _newMeanSpread is the weighted spread of the existing position and the new position\n', '        _newMeanSpread = state.getMeanEntrySpread(_userId, _marketId).mul(state.getShortShares(_userId, _marketId));\n', '        _newMeanSpread = _newMeanSpread.add(orders[_orderId].marketSpread.mul(orders[_orderId].shortSharesOrder));\n', '        _newMeanSpread = _newMeanSpread.div(_adjustedShortShares.add(orders[_orderId].shortSharesOrder));\n', '\n', '        orders[_orderId].balanceDown = orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketPrice).add(\n', '            orders[_orderId].shortSharesOrder.mul(orders[_orderId].marketSpread).mul(orders[_orderId].orderLeverage).div(PRECISION)\n', '        );\n', '        orders[_orderId].balanceUp = 0;\n', '        orders[_orderId].newLongShares = state.getLongShares(_userId, _marketId);\n', '        orders[_orderId].newShortShares = _adjustedShortShares.add(orders[_orderId].shortSharesOrder);\n', '        orders[_orderId].newMeanEntryPrice = orders[_orderId].marketPrice;\n', '        orders[_orderId].newMeanEntrySpread = _newMeanSpread;\n', '        orders[_orderId].newMeanEntryLeverage = _newMeanLeverage;\n', '\n', '        setPositionInState(_orderId);\n', '    }\n', '\n', '    function computeLiquidationPrice(bytes32 _orderId) public returns(uint256 _liquidationPrice) {\n', '        orders[_orderId].newLiquidationPrice = 0;\n', '        if (orders[_orderId].newLongShares > 0) {\n', '            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, true, orders[_orderId].timeStamp);\n', '        }\n', '        if (orders[_orderId].newShortShares > 0) {\n', '            orders[_orderId].newLiquidationPrice = getLiquidationPrice(orders[_orderId].newMeanEntryPrice, orders[_orderId].newMeanEntryLeverage, false, orders[_orderId].timeStamp);\n', '        }\n', '        return orders[_orderId].newLiquidationPrice;\n', '    }\n', '\n', '    function getLiquidationPrice(uint256 _newMeanEntryPrice, uint256 _newMeanEntryLeverage, bool _long, uint _positionTimestampInMs) public view returns (uint256 _liquidationPrice) {\n', '        if (_long == true) {\n', '            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.sub(PRECISION)).div(_newMeanEntryLeverage);\n', '            _liquidationPrice = _liquidationPrice.add(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\n', '        } else {\n', '            _liquidationPrice = _newMeanEntryPrice.mul(_newMeanEntryLeverage.add(PRECISION)).div(_newMeanEntryLeverage);\n', '            _liquidationPrice = _liquidationPrice.sub(calculateMarginInterest(_newMeanEntryPrice, _newMeanEntryLeverage, _positionTimestampInMs));\n', '        }\n', '        return _liquidationPrice;\n', '    }\n', '\n', '    \n', '// ----------------------------------------------------------------------------\n', '// setPositionInState(bytes32 _orderId)\n', '// Updates the portfolio in Morpher State. Called by closeLong/closeShort/openLong/openShort\n', '// ----------------------------------------------------------------------------\n', '    function setPositionInState(bytes32 _orderId) private {\n', '        require(state.balanceOf(orders[_orderId].userId).add(orders[_orderId].balanceUp) >= orders[_orderId].balanceDown, "MorpherTradeEngine: insufficient funds.");\n', '        computeLiquidationPrice(_orderId);\n', '        // Net balanceUp and balanceDown\n', '        if (orders[_orderId].balanceUp > orders[_orderId].balanceDown) {\n', '            orders[_orderId].balanceUp.sub(orders[_orderId].balanceDown);\n', '            orders[_orderId].balanceDown = 0;\n', '        } else {\n', '            orders[_orderId].balanceDown.sub(orders[_orderId].balanceUp);\n', '            orders[_orderId].balanceUp = 0;\n', '        }\n', '        if (orders[_orderId].balanceUp > 0) {\n', '            mintingLimiter.mint(orders[_orderId].userId, orders[_orderId].balanceUp);\n', '        }\n', '        if (orders[_orderId].balanceDown > 0) {\n', '            state.burn(orders[_orderId].userId, orders[_orderId].balanceDown);\n', '        }\n', '        state.setPosition(\n', '            orders[_orderId].userId,\n', '            orders[_orderId].marketId,\n', '            orders[_orderId].timeStamp,\n', '            orders[_orderId].newLongShares,\n', '            orders[_orderId].newShortShares,\n', '            orders[_orderId].newMeanEntryPrice,\n', '            orders[_orderId].newMeanEntrySpread,\n', '            orders[_orderId].newMeanEntryLeverage,\n', '            orders[_orderId].newLiquidationPrice\n', '        );\n', '        emit PositionUpdated(\n', '            orders[_orderId].userId,\n', '            orders[_orderId].marketId,\n', '            orders[_orderId].timeStamp,\n', '            orders[_orderId].newLongShares,\n', '            orders[_orderId].newShortShares,\n', '            orders[_orderId].newMeanEntryPrice,\n', '            orders[_orderId].newMeanEntrySpread,\n', '            orders[_orderId].newMeanEntryLeverage,\n', '            orders[_orderId].newLiquidationPrice,\n', '            orders[_orderId].balanceUp,\n', '            orders[_orderId].balanceDown\n', '        );\n', '    }\n', '}']