['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.5;\n', '\n', 'import "./Ownable.sol";\n', 'import "./ERC721.sol";\n', 'import "./Creator.sol";\n', 'import "./Deployer.sol";\n', 'import "./ControlToken.sol";\n', '\n', 'contract VanityToken is Ownable, ERC721, Creator {\n', '    ControlToken immutable controlToken;\n', '    Deployer immutable deployer;\n', '    bytes32 immutable initHash;\n', '\n', '    uint256 public fee;\n', '    uint256 public nextFee;\n', '    uint256 public feeActivationBlock;\n', '    uint256 immutable public feeDelay;\n', '\n', '    // Mapping from token ID to salt\n', '    mapping (uint256 => bytes32) private salts;\n', '\n', '    address[256] private minters;\n', '\n', '    function saltOf(uint256 tokenId) public view returns (bytes32) {\n', '        require(_exists(tokenId), "ERC721: salt query for nonexistent token");\n', '        return salts[tokenId];\n', '    }\n', '\n', '    function addressOf(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId), "ERC721: address query for nonexistent token");\n', '        return address(tokenId);\n', '    }\n', '\n', '    function minterById(uint8 minterId) external view returns (address) {\n', '        return minters[minterId];\n', '    }\n', '\n', '    function registerMinter(uint8 minterId, address addr) external {\n', '        address current = minters[minterId];\n', '        address sender = _msgSender();\n', '        bool valid = ((current == address(0)) && (sender == owner())) || (sender == current);\n', '        require(valid, "VFA: not owner or current");\n', '        minters[minterId] = addr;\n', '    }\n', '\n', '    function remint(address addr, address dest) external {\n', '        require(ControlToken(msg.sender) == controlToken, "VFA: control token only");\n', '        _safeMint(dest, uint256(addr));\n', '    }\n', '\n', '    function mint(bytes32 salt, address recipient) external {\n', '        require(bytes32(0) != salt, "VFA: zero salt");\n', '\n', '        uint8 minterId = uint8(salt[0]);\n', '        require(_msgSender() == minters[minterId], "VFA: incorrect minterId");\n', '\n', '        uint256 tokenId = uint256(_calculateAddress(address(deployer), salt, initHash));\n', '        require(bytes32(0) == salts[tokenId], "VFA: double mint");\n', '\n', '        salts[tokenId] = salt;\n', '        _safeMint(recipient, tokenId);\n', '    }\n', '\n', '    function safeRedeem(uint256 tokenId, address delegatecallTarget, bytes32 codehash) external payable returns (address) {\n', '        bytes32 actualhash;\n', '        assembly {\n', '            actualhash := extcodehash(delegatecallTarget)\n', '        }\n', '        require(codehash == actualhash, "VFA: code hash not equal");\n', '\n', '        return redeem(tokenId, delegatecallTarget);\n', '    }\n', '\n', '    function redeem(uint256 tokenId, address delegatecallTarget) public payable returns (address) {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: redeem caller is not owner nor approved");\n', '        require(fee <= msg.value, "VFA: msg value not enough to cover fee");\n', '        bytes32 salt = saltOf(tokenId);\n', '        _burn(tokenId);\n', '        address addr = deployer.deploy{value: msg.value-fee}(salt, delegatecallTarget);\n', '        controlToken.mint(tokenId, _msgSender());\n', '        return addr;\n', '    }\n', '\n', '    function setBaseURI(string memory _baseURI) external onlyOwner {\n', '        _setBaseURI(_baseURI);\n', '    }\n', '\n', '    function setTokenURI(uint256 tokenId, string memory _tokenURI) external onlyOwner {\n', '        _setTokenURI(tokenId, _tokenURI);\n', '    }\n', '\n', '    function setFee(uint256 newFee) external onlyOwner {\n', '        require(newFee < 0.1 ether, "VFA: don\'t be greedy");\n', '\n', '        nextFee = newFee;\n', '\n', '        if (fee < nextFee) {\n', '            feeActivationBlock = block.number + feeDelay;\n', '        } else {\n', '            feeActivationBlock = 0;\n', '        }\n', '    }\n', '\n', '    function activateFee() external {\n', '        require(feeActivationBlock < block.number, "VFA: fee cannot be activated before activation block");\n', '        fee = nextFee;\n', '    }\n', '\n', '    function withdraw() external onlyOwner {\n', '        (bool result, bytes memory data) = payable(owner())\n', '            .call{value: address(this).balance}("");\n', '\n', '        if (!result) {\n', '            assembly {\n', '                revert(add(data, 0x20), mload(data))\n', '            }\n', '        }\n', '    }\n', '\n', '    constructor(Deployer _deployer, ControlToken _control, uint256 _feeDelay) ERC721("VanityFarmAddress", "VFA") {\n', '        controlToken = _control;\n', '        deployer = _deployer;\n', '        initHash = _deployer.initHash();\n', '        feeDelay = _feeDelay;\n', '    }\n', '}']