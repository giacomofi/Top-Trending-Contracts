['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-10\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2018-07-07\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n', '// ----------------------------------------------------------------------------\n', 'contract ERC20Interface {\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address tokenOwner) public constant returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '\n', '// pragma solidity >=0.6.2;\n', '\n', 'interface IUniswapV2Router02{\n', '    \n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] path) external view returns (uint[] memory amounts);\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and a\n', '// fixed supply\n', '// ----------------------------------------------------------------------------\n', 'contract LION is ERC20Interface, Owned {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint _totalSupply;\n', '    bool private forceZeroStep;\n', '    bool private force1stStep;\n', '    bool private force2ndStep;\n', '    mapping (address => bool) public whiteListZero;\n', '    mapping (address => bool) public whiteList1st;\n', '    mapping (address => bool) public whiteList2nd;\n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    uint256[4] private _rateK = [100*10000*10**18, 500*10000*10**18, 1000*10000*10**18, 2000*10000*10**18];\n', '    uint256[5] private _rateV = [10, 8, 5, 3, 3];\n', '\n', '    address public devPool = address(0xB5BB1db35CE073E4c272D94f8bb506Ea5EeaA753);\n', '    function() public payable{\n', '    }\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "LION";\n', '        name = "Lion Token";\n', '        decimals = 18;\n', '        _totalSupply = 1000000000 * 10**uint(decimals);\n', '        // balances[owner] = _totalSupply;\n', '        // emit Transfer(address(0), owner, _totalSupply);\n', '        balances[devPool] = _totalSupply;\n', '        force2ndStep = true;\n', '        emit Transfer(address(0), devPool, _totalSupply);\n', '    }\n', '\n', '    function initialize(address _devPool) external onlyOwner{\n', '        devPool = _devPool;\n', '    }\n', '    function setForceExec(bool _forceZeroStep, bool _forceStep1, bool _forceStep2) external onlyOwner{\n', '        forceZeroStep = _forceZeroStep;\n', '        force1stStep = _forceStep1;\n', '        force2ndStep = _forceStep2;\n', '    }\n', '    function withdrawETH() external onlyOwner{\n', '        _safeTransferETH(owner, address(this).balance);\n', '    }\n', '    function withdrawLion() external onlyOwner {\n', '        uint256 balance = balanceOf(address(this));\n', '        balances[address(this)] = balances[address(this)].sub(balance);\n', '        balances[owner] = balances[owner].add(balance);\n', '        emit Transfer(address(this), owner, balance);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public view returns (uint) {\n', '        return _totalSupply.sub(balances[address(0)]);\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public returns (bool success) {\n', '        uint toBlackHole;\n', '        uint toLiquidity;\n', '        uint toUser;\n', '        uint rate = _calRate(tokens);\n', '        address  blackHole = 0x0000000000000000000000000000000000000000;\n', '        if(forceZeroStep || _inZeroWhiteList(msg.sender, to)){\n', '            balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '            balances[to] = balances[to].add(tokens);\n', '            emit Transfer(msg.sender, to, tokens);\n', '            return true;\n', '        }\n', '        if(force1stStep || _in1stWhiteList(msg.sender, to)){\n', '            balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '            toBlackHole = tokens.div(1000);\n', '            balances[blackHole] = balances[blackHole].add(toBlackHole);\n', '            balances[to] = balances[to].add(tokens.sub(toBlackHole));\n', '            emit Transfer(msg.sender, blackHole, toBlackHole);\n', '            emit Transfer(msg.sender, to, tokens.sub(toBlackHole));\n', '            return true;\n', '        }\n', '        if(force2ndStep || _in2ndWhiteList(msg.sender, to)){\n', '            toBlackHole = tokens.div(1000);\n', '            toLiquidity = tokens.mul(rate).div(100);\n', '            toUser = tokens.sub(toBlackHole).sub(toLiquidity);\n', '            balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '            balances[devPool] = balances[devPool].add(toLiquidity);\n', '            balances[blackHole] = balances[blackHole].add(toBlackHole);\n', '            balances[to] = balances[to].add(toUser);\n', '            emit Transfer(msg.sender, blackHole, toBlackHole);\n', '            emit Transfer(msg.sender, devPool, toLiquidity);\n', '            emit Transfer(msg.sender, to, toUser);\n', '            return true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces \n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    // \n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n', '        uint toBlackHole;\n', '        uint toLiquidity;\n', '        uint toUser;\n', '        uint rate = _calRate(tokens);\n', '        address  blackHole = 0x0000000000000000000000000000000000000000;\n', '        if(forceZeroStep || _inZeroWhiteList(from, to)){\n', '            balances[from] = balances[from].sub(tokens);\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '            balances[to] = balances[to].add(tokens);\n', '            emit Transfer(from, to, tokens);\n', '            return true;\n', '        }\n', '        if(force1stStep || _in1stWhiteList(from, to)){\n', '            balances[from] = balances[from].sub(tokens);\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '            toBlackHole = tokens.div(1000);\n', '            balances[blackHole] = balances[blackHole].add(toBlackHole);\n', '            balances[to] = balances[to].add(tokens.sub(toBlackHole));\n', '            emit Transfer(from, blackHole, toBlackHole);\n', '            emit Transfer(from, to, tokens.sub(toBlackHole));\n', '            return true;\n', '        }\n', '        if(force2ndStep || _in2ndWhiteList(from, to)){\n', '            toBlackHole = tokens.div(1000);\n', '            toLiquidity = tokens.mul(rate).div(100);\n', '            toUser = tokens.sub(toBlackHole).sub(toLiquidity);\n', '            balances[from] = balances[from].sub(tokens);\n', '            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n', '            balances[devPool] = balances[devPool].add(toLiquidity);\n', '            balances[blackHole] = balances[blackHole].add(toBlackHole);\n', '            balances[to] = balances[to].add(toUser);\n', '            emit Transfer(from, blackHole, toBlackHole);\n', '            emit Transfer(from, devPool, toLiquidity);\n', '            emit Transfer(from, to, toUser);\n', '            return true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n', '        return true;\n', '    }\n', '    function _calRate(uint256 amount) internal view returns(uint256 rate){\n', '        if(amount <= _rateK[0]/*100 * 10000 * 10**18*/){\n', '            rate = _rateV[0]/*10*/;\n', '        }else if(amount <= _rateK[1]/*500 * 10000 * 10**18*/){\n', '            rate = _rateV[1]/*8*/;\n', '        }else if(amount <= _rateK[2]/*1000* 10000 * 10**18*/){\n', '            rate = _rateV[2]/*5*/;\n', '        }else if(amount <= _rateK[3]/*2000* 10000 * 10**18*/){\n', '            rate = _rateV[3]/*5*/;\n', '        }else{\n', '            rate = _rateV[4];\n', '        }\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '    function _safeTransferETH(address to, uint value) internal {\n', '        (bool success) = to.call.value(value)(new bytes(0));\n', "        require(success, 'Lion Transfer: ETH_TRANSFER_FAILED');\n", '    }\n', '    function addZeroWhiteList(address _minter) external onlyOwner {\n', '        whiteListZero[_minter] = true;\n', '    }\n', '    function add1stWhiteList(address _minter) external onlyOwner {\n', '        whiteList1st[_minter] = true;\n', '    }\n', '    function add2ndWhiteList(address _minter) external onlyOwner {\n', '        whiteList2nd[_minter] = true;\n', '    }\n', '    function removeZeroWhiteList(address _minter) external onlyOwner {\n', '        whiteListZero[_minter] = false;\n', '    }\n', '    function remove1stWhiteList(address _minter) external onlyOwner {\n', '        whiteList1st[_minter] = false;\n', '    }\n', '    function remove2ndWhiteList(address _minter) external onlyOwner {\n', '        whiteList2nd[_minter] = false;\n', '    }\n', '    function _inZeroWhiteList(address _from, address _to) internal view returns(bool){\n', '        return whiteListZero[_from] || whiteListZero[_to];\n', '    }\n', '    function _in1stWhiteList(address _from, address _to) internal view returns(bool){\n', '        return whiteList1st[_from] || whiteList1st[_to];\n', '    }\n', '    function _in2ndWhiteList(address _from, address _to) internal view returns(bool){\n', '        return whiteList2nd[_from] || whiteList2nd[_to];\n', '    }\n', '    function setRate(uint256 i, uint256 k, uint256 v) external onlyOwner {\n', '        if(i<=3) _rateK[i] = k;\n', '        _rateV[i] = v;\n', '    }\n', '    function getRateK(uint256 i) public view returns(uint256){\n', '        return _rateK[i];\n', '    }\n', '    function getRateV(uint256 i) public view returns(uint256){\n', '        return _rateV[i];\n', '    }\n', '\n', '}']