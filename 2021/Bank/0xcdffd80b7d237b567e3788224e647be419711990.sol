['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-17\n', '*/\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        uint160 a = uint160(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '        pair = address(a);\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = reserveIn.mul(amountOut).mul(1000);\n', '        uint denominator = reserveOut.sub(amountOut).mul(997);\n', '        amountIn = (numerator / denominator).add(1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library VeloxTransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: TOKEN_ZERO_ADDRESS');\n", "        require(from != address(0), 'VeloxTransferHelper: FROM_ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '        \n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '/**\n', ' * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n', ' * See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', ' */\n', 'abstract contract IERC20NONStandard {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '\n', '    uint256 public totalSupply;\n', '    function balanceOf(address owner) virtual public view returns (uint256 balance);\n', '\n', '    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC20 specification\n', '    /// will return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 value) virtual public;\n', '\n', '    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC20 specification\n', '    /// will return Whether the transfer was successful or not\n', '    function transferFrom(address from, address to, uint256 value) virtual public;\n', '\n', '\n', '    function approve(address spender, uint256 value) virtual public returns (bool success);\n', '    function allowance(address owner, address spender) virtual public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'contract SwapExceptions {\n', '\n', '    event SwapException(uint exception, uint info, uint detail);\n', '\n', '    enum Exception {\n', '        NO_ERROR,\n', '        GENERIC_ERROR,\n', '        UNAUTHORIZED,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW,\n', '        DIVISION_BY_ZERO,\n', '        BAD_INPUT,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_TRANSFER_FAILED,\n', '        MARKET_NOT_SUPPORTED,\n', '        SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_RATE_CALCULATION_FAILED,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_OUT_FAILED,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INSUFFICIENT_BALANCE,\n', '        INVALID_COLLATERAL_RATIO,\n', '        MISSING_ASSET_PRICE,\n', '        EQUITY_INSUFFICIENT_BALANCE,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        ASSET_NOT_PRICED,\n', '        INVALID_LIQUIDATION_DISCOUNT,\n', '        INVALID_COMBINED_RISK_PARAMETERS,\n', '        ZERO_ORACLE_ADDRESS,\n', '        CONTRACT_PAUSED\n', '    }\n', '\n', '    /*\n', '     * Note: Reason (but not Exception) is kept in alphabetical order\n', '     *       This is because Reason grows significantly faster, and\n', '     *       the order of Exception has some meaning, while the order of Reason\n', '     *       is arbitrary.\n', '     */\n', '    enum Reason {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        BORROW_CONTRACT_PAUSED,\n', '        BORROW_MARKET_NOT_SUPPORTED,\n', '        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n', '        BORROW_TRANSFER_OUT_FAILED,\n', '        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n', '        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n', '        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n', '        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n', '        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n', '        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n', '        LIQUIDATE_CONTRACT_PAUSED,\n', '        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_CONTRACT_PAUSED,\n', '        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_ASSET_PRICE_CHECK_ORACLE,\n', '        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_ORACLE_OWNER_CHECK,\n', '        SET_ORIGINATION_FEE_OWNER_CHECK,\n', '        SET_PAUSED_OWNER_CHECK,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_VALIDATION,\n', '        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_CONTRACT_PAUSED,\n', '        SUPPLY_MARKET_NOT_SUPPORTED,\n', '        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        SUPPLY_TRANSFER_IN_FAILED,\n', '        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n', '        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SUPPORT_MARKET_PRICE_CHECK,\n', '        SUSPEND_MARKET_OWNER_CHECK,\n', '        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n', '        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n', '        WITHDRAW_CONTRACT_PAUSED,\n', '        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n', '    }\n', '\n', '    /**\n', '      * @dev report a known exception\n', '      */\n', '    function raiseException(Exception exception, Reason reason) internal returns (uint) {\n', '        emit SwapException(uint(exception), uint(reason), 0);\n', '        return uint(exception);\n', '    }\n', '\n', '    /**\n', '      * @dev report an opaque error from an upgradeable collaborator contract\n', '      */\n', '    function raiseGenericException(Reason reason, uint genericException) internal returns (uint) {\n', '        emit SwapException(uint(Exception.GENERIC_ERROR), uint(reason), genericException);\n', '        return uint(Exception.GENERIC_ERROR);\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '/**\n', '  * @title Swappable Interface\n', '  */\n', 'contract Swappable is SwapExceptions {\n', '    /**\n', '      * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\n', '      *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\n', '      */\n', '    function checkTransferIn(address asset, address from, uint amount) internal view returns (Exception) {\n', '\n', '        IERC20 token = IERC20(asset);\n', '\n', '        if (token.allowance(from, address(this)) < amount) {\n', '            return Exception.TOKEN_INSUFFICIENT_ALLOWANCE;\n', '        }\n', '\n', '        if (token.balanceOf(from) < amount) {\n', '            return Exception.TOKEN_INSUFFICIENT_BALANCE;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '\n', '    /**\n', '      *  @dev This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n', '      *  See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', '      */\n', '    function doTransferIn(address asset, address from, uint amount) internal returns (Exception) {\n', '        IERC20NONStandard token = IERC20NONStandard(asset);\n', '        bool result;\n', '        // Should we use Helper.safeTransferFrom?\n', "        require(token.allowance(from, address(this)) >= amount, 'Not enough allowance from client');\n", '        token.transferFrom(from, address(this), amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {                      // This is a non-standard ERC-20\n', '                    result := not(0)          // set result to true\n', '                }\n', '                case 32 {                     // This is a complaint ERC-20\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)        // Set `result = returndata` of external call\n', '                }\n', '                default {                     // This is an excessively non-compliant ERC-20, revert.\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '\n', '        if (!result) {\n', '            return Exception.TOKEN_TRANSFER_FAILED;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '\n', '    /**\n', '      * @dev Checks balance of this contract in asset\n', '      */\n', '    function getCash(address asset) internal view returns (uint) {\n', '        IERC20 token = IERC20(asset);\n', '        return token.balanceOf(address(this));\n', '    }\n', '\n', '    /**\n', '      * @dev Checks balance of `from` in `asset`\n', '      */\n', '    function getBalanceOf(address asset, address from) internal view returns (uint) {\n', '        IERC20 token = IERC20(asset);\n', '        return token.balanceOf(from);\n', '    }\n', '\n', '    /**\n', '      * @dev Similar to EIP20 transfer, except it handles a False result from `transfer` and returns an explanatory\n', "      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n", "      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n", '      *      it is >= amount, this should not revert in normal conditions.\n', '      *\n', '      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n', '      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', '      */\n', '    function doTransferOut(address asset, address to, uint amount) internal returns (Exception) {\n', '        IERC20NONStandard token = IERC20NONStandard(asset);\n', '        bool result;\n', '        token.transfer(to, amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {                      // This is a non-standard ERC-20\n', '                    result := not(0)          // set result to true\n', '                }\n', '                case 32 {                     // This is a complaint ERC-20\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)        // Set `result = returndata` of external call\n', '                }\n', '                default {                     // This is an excessively non-compliant ERC-20, revert.\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '\n', '        if (!result) {\n', '            return Exception.TOKEN_TRANSFER_OUT_FAILED;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return payable(msg.sender);\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IVeloxSwap {\n', '\n', '    function withdrawToken(address token, uint256 amount) external;\n', '    \n', '    function withdrawETH(uint256 amount) external;\n', '\n', '    function sellExactTokensForTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) external returns (uint256 amountOut);\n', '\n', '    function sellExactTokensForTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) external returns (uint256 amountOut);\n', '\n', '    function sellTokensForExactTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) external;\n', '\n', '    function sellTokensForExactTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) external;\n', '\n', '    function fundGasCost(address seller, uint256 wethAmount) external;\n', '\n', '}\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'abstract contract BackingStore {\n', '    address public MAIN_CONTRACT;\n', '    address public UNISWAP_FACTORY_ADDRESS = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '    address public UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    address public ADMIN_ADDRESS;\n', '}\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title VeloxSwap based on algorithmic conditional trading exeuctions\n', '*/\n', 'contract VeloxSwapV2 is BackingStore, Ownable, Swappable, IVeloxSwap {\n', '\n', '    /**\n', '        * @dev Throws if called by any account other than the admin.\n', '        */\n', '    modifier onlyAdmin() {\n', '        require(ADMIN_ADDRESS == msg.sender, "VELOXSWAP: NOT_ADMIN");\n', '        _;\n', '    }\n', '\n', '    struct SwapInput {\n', '        address seller;\n', '        address tokenInAddress;\n', '        address tokenOutAddress;\n', '        uint256 tokenInAmount;\n', '        uint256 tokenOutAmount;\n', '        uint16 feeFactor;\n', '        bool takeFeeFromInput;\n', '        uint256 deadline;\n', '    }\n', '\n', '    uint constant FEE_SCALE = 10000;\n', '    uint constant GAS_FUNDING_ESTIMATED_GAS = 26233;\n', '\n', '    IUniswapV2Router02 public immutable router;\n', '\n', '    constructor() {\n', '        router = IUniswapV2Router02(UNISWAP_ROUTER_ADDRESS);\n', '    }\n', '\n', '    event ValueSwapped(address indexed seller, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n', '    event GasFunded(address indexed seller, uint256 gasCost);\n', '\n', '    function withdrawToken(address token, uint256 amount) onlyOwner override external {\n', '        VeloxTransferHelper.safeTransfer(token, msg.sender, amount);\n', '    }\n', '\n', '    function withdrawETH(uint256 amount) onlyOwner override external {\n', '        VeloxTransferHelper.safeTransferETH(msg.sender, amount);\n', '    }\n', '\n', '    function fundGasCost(address seller, uint256 wethAmount) onlyAdmin override public {\n', '        VeloxTransferHelper.safeTransferFrom(router.WETH(), seller, ADMIN_ADDRESS, wethAmount);\n', '        \n', '        emit GasFunded(seller, wethAmount);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellExactTokensForTokens\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param tokenInAmount        uint256\n', '    *   @param minTokenOutAmount    uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    *   @param estimatedGasFundingCost uint - estimated gas for gas funding transaction\n', '    */\n', '    function sellExactTokensForTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost\n', '    ) override onlyAdmin public returns (uint256 amountOut) {\n', '        uint256 initialGas = gasleft();\n', '\n', '        SwapInput memory input = SwapInput({ \n', '            seller: seller, tokenInAddress: tokenInAddress,\n', '            tokenOutAddress: tokenOutAddress,\n', '            tokenInAmount: tokenInAmount,\n', '            tokenOutAmount: minTokenOutAmount,\n', '            feeFactor: feeFactor,\n', '            takeFeeFromInput: takeFeeFromInput,\n', '            deadline: deadline });\n', '        \n', '        amountOut = swapTokens(input, true);\n', '        \n', '        uint256 gasCost = (initialGas - gasleft() + estimatedGasFundingCost) * tx.gasprice;\n', '\n', '        fundGasCost(seller, gasCost);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellExactTokensForTokens\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param tokenInAmount        uint256\n', '    *   @param minTokenOutAmount    uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    */\n', '    function sellExactTokensForTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline\n', '    ) override onlyAdmin public returns (uint256 amountOut) {\n', '        amountOut = sellExactTokensForTokens(seller, tokenInAddress, tokenOutAddress, tokenInAmount, minTokenOutAmount, feeFactor, takeFeeFromInput, deadline, GAS_FUNDING_ESTIMATED_GAS);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellTokensForExactTokens\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param maxTokenInAmount     uint256\n', '    *   @param tokenOutAmount       uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    *   @param estimatedGasFundingCost uint - estimated gas for gas funding transaction\n', '    */\n', '    function sellTokensForExactTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) override onlyAdmin public {\n', '\n', '        uint256 initialGas = gasleft();\n', '\n', '        SwapInput memory input = SwapInput({ \n', '            seller: seller, tokenInAddress: tokenInAddress,\n', '            tokenOutAddress: tokenOutAddress,\n', '            tokenInAmount: maxTokenInAmount,\n', '            tokenOutAmount: tokenOutAmount,\n', '            feeFactor: feeFactor,\n', '            takeFeeFromInput: takeFeeFromInput,\n', '            deadline: deadline });\n', '        \n', '        swapTokens(input, false);\n', '        \n', '        uint256 gasCost = (initialGas - gasleft() + estimatedGasFundingCost) * tx.gasprice;\n', '\n', '        fundGasCost(seller, gasCost);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellTokensForExactTokens\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param maxTokenInAmount     uint256\n', '    *   @param tokenOutAmount       uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    */\n', '    function sellTokensForExactTokens(\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) override onlyAdmin public {\n', '        sellTokensForExactTokens(seller, tokenInAddress, tokenOutAddress, maxTokenInAmount, tokenOutAmount, feeFactor, takeFeeFromInput, deadline, GAS_FUNDING_ESTIMATED_GAS);\n', '    }\n', '    \n', '    function swapTokens(SwapInput memory input, bool exactIn) public returns (uint256 amountOut) {\n', '        uint256 amountInForSwap;\n', '        uint256 amountOutForSwap;\n', '        address swapTargetAddress;\n', '\n', '        (amountInForSwap, amountOutForSwap, swapTargetAddress) \n', '            = prepareSwap(input);\n', '\n', '        // Execute the swap\n', '        doSwap(input.tokenInAddress, input.tokenOutAddress, amountInForSwap, amountOutForSwap, swapTargetAddress, input.deadline, exactIn);\n', '\n', '        amountOut = amountOutForSwap;\n', '\n', '        // Take the fee from the output if not taken from the input\n', '        if (!input.takeFeeFromInput) {\n', '            amountOut = takeOutputFee(amountOutForSwap, input.feeFactor, input.tokenOutAddress, input.seller);\n', '        }\n', '\n', '        emit ValueSwapped(input.seller, input.tokenInAddress, input.tokenOutAddress, input.tokenInAmount, amountOut);\n', '    }\n', '\n', '    function prepareSwap(SwapInput memory input) private returns (uint256 amountInForSwap, uint256 amountOurForSwap, address targetAddress) {\n', '\n', '        // Sanity checks\n', '        validateInput(input.seller, input.tokenInAddress, input.tokenOutAddress, input.tokenInAmount, input.tokenOutAmount, input.feeFactor, input.deadline);\n', '\n', "        // Be 100% sure there's available allowance in this token contract\n", '        Exception exception = doTransferIn(input.tokenInAddress, input.seller, input.tokenInAmount);\n', "        require(exception == Exception.NO_ERROR, 'VELOXSWAP: ALLOWANCE_TOO_LOW');\n", '\n', '        // Checking In/Out reserves\n', '        checkLiquidity(input.tokenInAddress, input.tokenOutAddress, input.tokenOutAmount);\n', '\n', '        // Fee\n', '        (amountInForSwap, amountOurForSwap, targetAddress) = adjustInputBasedOnFee(input.takeFeeFromInput, input.feeFactor, input.tokenInAmount, input.tokenOutAmount, input.seller);\n', '    }\n', '\n', '    function validateInput(address seller, address tokenInAddress, address tokenOutAddress, uint256 tokenInAmount, uint256 tokenOutAmount, uint16 feeFactor, uint256 deadline) private view {\n', "        require(deadline >= block.timestamp, 'VELOXSWAP: EXPIRED');\n", "        require(feeFactor <= 30, 'VELOXSWAP: FEE_OVER_03_PERCENT');\n", "        require(address(router) != address(0), 'VELOXSWAP: ROUTER_NOT_INSTANTIATED');\n", '\n', '        address tokenWETH = router.WETH();\n', "        require(tokenWETH != address(0), 'VELOXSWAP: WETH_ADDRESS_NOT_FOUND');\n", '\n', '        require (seller != address(0) &&\n', '                tokenInAddress != address(0) &&\n', '                tokenOutAddress != address(0) &&\n', '                tokenInAmount > 0 &&\n', '                tokenOutAmount > 0,\n', "        'VELOXSWAP: ZERO_DETECTED');\n", '\n', '        // For now we only work with WETH/TOKEN pairs\n', "        require(tokenInAddress == tokenWETH || tokenOutAddress == tokenWETH, 'VELOXSWAP: INVALID_PATH');\n", '    }\n', '\n', '    /**\n', '    *   @dev Adjust input values based on the fee strategy\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param amountIn             uint256\n', '    *   @param amountOut            uint256\n', '    *   @param sellerAddress        address\n', '    */\n', '    function adjustInputBasedOnFee(bool takeFeeFromInput, uint16 feeFactor, uint256 amountIn, uint256 amountOut, address sellerAddress) private view\n', '        returns (uint256 amountInForSwap, uint256 amountOurForSwap, address targetAddress) {\n', '        // Take fee from input\n', '        if (takeFeeFromInput) {\n', '            // Use less tokens for swap so we can keep the difference and make one less transfer\n', '            amountInForSwap = deductFee(amountIn, feeFactor);\n', '            amountOurForSwap = deductFee(amountOut, feeFactor);\n', '\n', '        // If we took fee from the input, transfer the result directly to client,\n', '        // otherwise, transfer to contract address so we can take fee from output\n', '            targetAddress = sellerAddress;\n', '        } else {\n', '            amountInForSwap = amountIn;\n', '            amountOurForSwap = amountOut;\n', '            targetAddress = address(this);\n', '        }\n', '    }\n', '\n', '    function doSwap(address  tokenInAddress, address tokenOutAddress, uint256 tokenInAmount, uint256 minTokenOutAmount, address targetAddress, uint256 deadline, bool exactIn) private {\n', '        // Safely Approve UNISWAP V2 Router for token amount\n', '        VeloxTransferHelper.safeApprove(tokenInAddress, address(router), tokenInAmount);\n', '\n', '        // Path\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenInAddress;\n', '        path[1] = tokenOutAddress;\n', '\n', '        if (exactIn) {\n', '            router.swapExactTokensForTokens(\n', '                tokenInAmount,\n', '                minTokenOutAmount,\n', '                path,\n', '                targetAddress,\n', '                deadline\n', '            );\n', '        } else {\n', '            router.swapTokensForExactTokens(\n', '                tokenInAmount,\n', '                minTokenOutAmount,\n', '                path,\n', '                targetAddress,\n', '                deadline\n', '            );\n', '        }\n', '    }\n', '\n', '    function checkLiquidity(address  tokenInAddress, address tokenOutAddress, uint256 minTokenOutAmount) private view {\n', '        (uint256 reserveIn, uint256 reserveOut) = UniswapV2Library.getReserves(UNISWAP_FACTORY_ADDRESS, tokenInAddress, tokenOutAddress);\n', "        require(reserveIn > 0 && reserveOut > 0, 'VELOXSWAP: ZERO_RESERVE_DETECTED');\n", "        require(reserveOut > minTokenOutAmount, 'VELOXSWAP: NOT_ENOUGH_LIQUIDITY');\n", '    }\n', '\n', '    function takeOutputFee(uint256 amountOut, uint16 feeFactor, address tokenOutAddress,\n', '                           address from) private returns (uint256 transferredAmount) {\n', '\n', '        // Transfer to client address the value of amountOut - fee and keep difference in contract address\n', '        transferredAmount = deductFee(amountOut, feeFactor);\n', '        Exception exception = doTransferOut(tokenOutAddress, from, transferredAmount);\n', "        require (exception == Exception.NO_ERROR, 'VELOXSWAP: ERROR_GETTING_OUTPUT_FEE');\n", '    }\n', '\n', '    function deductFee(uint256 amount, uint16 feeFactor) private pure returns (uint256 deductedAmount) {\n', '        deductedAmount = (amount * (FEE_SCALE - feeFactor)) / FEE_SCALE;\n', '    }\n', '}']