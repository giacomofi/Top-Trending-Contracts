['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '/**\n', ' *  Program Name    : DappIncubator\n', ' *  Website         : https://www.dappincubator.com\n', ' *  Telegram        : https://t.me/dappincubatorofficial\n', ' *  Concept         : High Return On Investment\n', ' *  Category        : Passive Income\n', ' *  Risk Category   : High Risk\n', ' **/\n', '\n', 'pragma solidity >=0.6.0 <0.8.1;\n', '\n', 'abstract contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '     /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract DappIncubator is Ownable {\n', '    \n', '    /**\n', '     * @dev Structure to hold tokens supplu and dividend per share against collateral.\n', '     */\n', '    struct TokenLedger {\n', '        uint supply;\n', '        uint dividend;\n', '        uint initialPrice;\n', '        uint incrementPrice;\n', '    }\n', '    \n', '    /**\n', '     * @dev Structure to hold collateral balalnce of wallet.\n', '     */\n', '    struct BalanceLedger {\n', '        uint tokenBalance;\n', '        uint referralBalance;\n', '        int payOut;\n', '    }\n', '    \n', '    /**\n', '     * @dev mapping to store all active contract addresses and wallet addresses. This will be used to check if contract address and wallet address already part of system.\n', '     */\n', '    mapping(address => bool) contractAddressRecord;\n', '    mapping(address => bool) walletAddressRecord;\n', '    \n', '    uint constant magnitude = 1e18 ;\n', '    uint constant dividendFee = 10;\n', '    \n', '    /**\n', '     * @dev structure mapping created for storing balance and token information.\n', '     */\n', '    mapping (address => mapping(address => BalanceLedger)) balanceLedger;\n', '    mapping(address => TokenLedger) tokenLedger;\n', '    \n', '    /**\n', '     * @dev events to register information about collateral buy, sell, reinvest and token withdraw.\n', '     */\n', '     \n', '    event onTokenOnboard(address indexed contractAddress, uint initialPrice, uint incrementPrice);\n', '    event onPurchase(address indexed walletAddress, address indexed contractAddress, uint incomingTokenAmount, uint collateralMinted, address indexed referredBy);\n', '    event onSell(address indexed walletAddress, address indexed contractAddress, uint tokenAmountToReceiver, uint collateralBurned);\n', '    event onReinvest(address indexed walletAddress, address indexed contractAddress, uint reInvestTokenAmount, uint collateralMinted);\n', '    event onWithdraw(address indexed walletAddress, address indexed contractAddress, uint amountToWithdraw);\n', '    event onTransfer(address indexed contractAddress, address indexed from,address indexed to,uint256 tokens);\n', '    \n', '    /**\n', '     * @dev function to add ERC-20 Token to ecosystem.\n', '     */\n', '     function tokenOnboard(address contractAddress, uint initialPrice, uint incrementPrice) public onlyOwner\n', '     {\n', '         if(contractAddressRecord[contractAddress] == false)\n', '         {\n', '            contractAddressRecord[contractAddress] = true;\n', '            tokenLedger[contractAddress].initialPrice = initialPrice;\n', '            tokenLedger[contractAddress].incrementPrice = incrementPrice;\n', '            tokenLedger[contractAddress].supply = 0;\n', '            tokenLedger[contractAddress].dividend = 0;\n', '            \n', '            emit onTokenOnboard(contractAddress, initialPrice, incrementPrice);\n', '         }\n', '         \n', '     }\n', '    \n', '    \n', '    /**\n', '     * @dev function to purchase collateral by sending Ethereum.\n', '     */\n', '    function buy(address _referredBy) public payable returns(uint256)\n', '    {\n', '        require(msg.value>0);\n', '        require(contractAddressRecord[address(0)] == true);\n', '        \n', '        // if first investment from user then activate wallet address in system.\n', '        if(walletAddressRecord[msg.sender] == false){\n', '            walletAddressRecord[msg.sender] = true;\n', '        }\n', '        \n', '        uint256 collateAmount = purchaseCollate(address(0), msg.value, _referredBy);\n', '        return collateAmount;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to purchase collateral by sending any ERC-20 Tokens except Ethereum.\n', '     */\n', '    function buy(address contractAddress, uint256 tokenAmount, address _referredBy) public returns(uint256)\n', '    {\n', '        \n', '        // transfer token to system from user wallet\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(tokenAmount > 0);\n', '        require(ERC20(contractAddress).allowance(msg.sender, address(this)) >= tokenAmount);\n', '        require(ERC20(contractAddress).transferFrom(msg.sender, address(this), tokenAmount));\n', '        \n', '        \n', '        \n', '        // if first investment from user then activate wallet address in system.\n', '        if(walletAddressRecord[msg.sender] == false){\n', '            walletAddressRecord[msg.sender] = true;\n', '        }\n', '        \n', '        uint256 collateAmount = purchaseCollate(contractAddress,tokenAmount, _referredBy);\n', '        return collateAmount;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to purchase collateral by sending Ethereum directly to smart contract address.\n', '     */\n', '    fallback() payable external\n', '    {\n', '        require(msg.value > 0);\n', '        require(contractAddressRecord[address(0)] == true);\n', '        \n', '        // if first investment from user then activate wallet address in system.\n', '        if(walletAddressRecord[msg.sender] == false){\n', '            walletAddressRecord[msg.sender] = true;\n', '        }\n', '        purchaseCollate(address(0), msg.value, address(0));\n', '    }\n', '    \n', '    /**\n', '     * @dev function to convert all dividend to collateral.\n', '     */\n', '    function reinvest(address contractAddress) public\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(walletAddressRecord[msg.sender] == true);\n', '        \n', '        // fetch dividends\n', '        uint256 _dividends = myDividends(contractAddress, false); // retrieve ref. bonus later in the code\n', '        \n', '        // pay out the dividends virtually\n', '        address _customerAddress = msg.sender;\n', '        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n', '        \n', '        // retrieve ref. bonus\n', '        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\n', '        \n', '        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\n', '        \n', '        // dispatch a buy order with the virtualized "withdrawn dividends"\n', '        uint256 _collate = purchaseCollate(contractAddress, _dividends, address(0));\n', '        \n', '        // fire event\n', '        emit onReinvest(_customerAddress, contractAddress, _dividends, _collate);\n', '    }\n', '    \n', '    /**\n', '     * @dev function to sell collateral and withdraw tokens.\n', '     */\n', '    function exit(address contractAddress) public\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(walletAddressRecord[msg.sender] == true);\n', '        \n', '        // get token count for caller & sell them all\n', '        address _customerAddress = msg.sender;\n', '        uint256 _tokens = balanceLedger[_customerAddress][contractAddress].tokenBalance;\n', '        if(_tokens > 0) sell(contractAddress, _tokens);\n', '    \n', '        withdraw(contractAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev function to withdraw tokens, dividend and referralBalance.\n', '     */\n', '    function withdraw(address contractAddress) public\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(walletAddressRecord[msg.sender] == true);\n', '        \n', '        // setup data\n', '        address _customerAddress = msg.sender;\n', '        uint256 _dividends = myDividends(contractAddress, false); // get ref. bonus later in the code\n', '        \n', '        // update dividend tracker\n', '        balanceLedger[_customerAddress][contractAddress].payOut +=  (int256) (_dividends * magnitude);\n', '        \n', '        // add ref. bonus\n', '        _dividends += balanceLedger[_customerAddress][contractAddress].referralBalance;\n', '        balanceLedger[_customerAddress][contractAddress].referralBalance = 0;\n', '        \n', '        // delivery service\n', '        if (contractAddress == address(0)){\n', '            payable(address(_customerAddress)).transfer(_dividends);\n', '        }\n', '        else{\n', '            ERC20(contractAddress).transfer(_customerAddress,_dividends);\n', '        }\n', '        \n', '        \n', '        // fire event\n', '        emit onWithdraw(_customerAddress, contractAddress, _dividends);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Transfer collateral from the caller to a new holder.\n', "     * Remember, there's a 10% fee here as well.\n", '     */\n', '    function transfer(address contractAddress, address toAddress, uint256 amountOfCollate) public returns(bool)\n', '    {\n', '        address _customerAddress = msg.sender;\n', '        \n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(walletAddressRecord[_customerAddress] == true);\n', '        require(amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\n', '        \n', '        if(walletAddressRecord[toAddress] == false){\n', '            walletAddressRecord[toAddress] = true;\n', '        }\n', '        \n', '        // withdraw all outstanding dividends first\n', '        if(myDividends(contractAddress, true) > 0) withdraw(contractAddress);\n', '        \n', '        // calculate divident fees, tokens to transfer\n', '        uint256 _tokenFee = SafeMath.div(amountOfCollate, dividendFee);\n', '        uint256 _taxedTokens = SafeMath.sub(amountOfCollate, _tokenFee);\n', '        uint256 _dividends = collateralToToken_(contractAddress, _tokenFee);\n', '  \n', '        // burn the fee tokens\n', '        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _tokenFee);\n', '\n', '        // exchange tokens\n', '        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, amountOfCollate);\n', '        balanceLedger[toAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[toAddress][contractAddress].tokenBalance, _taxedTokens);\n', '        \n', '        // update dividend trackers\n', '        balanceLedger[_customerAddress][contractAddress].payOut -= (int256) (tokenLedger[contractAddress].dividend * amountOfCollate);\n', '        balanceLedger[toAddress][contractAddress].payOut += (int256) (tokenLedger[contractAddress].dividend * _taxedTokens);\n', '        \n', '        // disperse dividends among holders\n', '        tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\n', '        \n', '        // emit transfer events\n', '        emit onTransfer(contractAddress, _customerAddress, toAddress, _taxedTokens);\n', '        \n', '        return true;\n', '\n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev function to sell collatral.\n', '     */\n', '    function sell(address contractAddress, uint256 _amountOfCollate) public\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(walletAddressRecord[msg.sender] == true);\n', '      \n', '        address _customerAddress = msg.sender;\n', '       \n', '        require(_amountOfCollate <= balanceLedger[_customerAddress][contractAddress].tokenBalance);\n', '        \n', '        uint256 _collates = _amountOfCollate;\n', '        uint256 _tokens = collateralToToken_(contractAddress, _collates);\n', '        uint256 _dividends = SafeMath.div(_tokens, dividendFee);\n', '        uint256 _taxedToken = SafeMath.sub(_tokens, _dividends);\n', '        \n', '        // burn the sold tokens\n', '        tokenLedger[contractAddress].supply = SafeMath.sub(tokenLedger[contractAddress].supply, _collates);\n', '        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.sub(balanceLedger[_customerAddress][contractAddress].tokenBalance, _collates);\n', '        \n', '        // update dividends tracker\n', '        int256 _updatedPayouts = (int256) (tokenLedger[contractAddress].dividend * _collates + (_taxedToken * magnitude));\n', '        balanceLedger[_customerAddress][contractAddress].payOut -= _updatedPayouts;       \n', '        \n', '        // dividing by zero is a bad idea\n', '        if (tokenLedger[contractAddress].supply > 0) {\n', '            // update the amount of dividends per token\n', '            tokenLedger[contractAddress].dividend = SafeMath.add(tokenLedger[contractAddress].dividend, (_dividends * magnitude) / tokenLedger[contractAddress].supply);\n', '        }\n', '        \n', '        // fire event\n', '        emit onSell(_customerAddress, contractAddress, _taxedToken, _collates);\n', '    }\n', '        \n', '    /**\n', '     * @dev function to get current purchase price of single collateral.\n', '     */\n', '    function buyPrice(address contractAddress) public view returns(uint currentBuyPrice) {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        if(tokenLedger[contractAddress].supply == 0){\n', '            return tokenLedger[contractAddress].initialPrice + tokenLedger[contractAddress].incrementPrice;\n', '        } else {\n', '            uint256 _token = collateralToToken_(contractAddress, 1e18);\n', '            uint256 _dividends = SafeMath.div(_token, dividendFee);\n', '            uint256 _taxedToken = SafeMath.add(_token, _dividends);\n', '            return _taxedToken;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev function to get current sell price of single collateral.\n', '     */\n', '    function sellPrice(address contractAddress) public view returns(uint) {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        if(tokenLedger[contractAddress].supply == 0){\n', '            return tokenLedger[contractAddress].initialPrice - tokenLedger[contractAddress].incrementPrice;\n', '        } else {\n', '            uint256 _token = collateralToToken_(contractAddress, 1e18);\n', '            uint256 _dividends = SafeMath.div(_token, dividendFee);\n', '            uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n', '            return _taxedToken;\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '     * @dev function to calculate collateral price based on an amount of incoming token\n', "     * It's an scientific algorithm;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function tokentoCollateral_(address contractAddress, uint amount) internal view returns(uint)\n', '    {\n', '        uint256 _tokenPriceInitial = tokenLedger[contractAddress].initialPrice * 1e18;\n', '        uint256 tokenSupply_ = tokenLedger[contractAddress].supply;\n', '        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\n', '        \n', '        uint256 _tokensReceived = \n', '         (\n', '            (\n', '                // underflow attempts BTFO\n', '                SafeMath.sub(\n', '                    (sqrt\n', '                        (\n', '                            (_tokenPriceInitial**2)\n', '                            +\n', '                            (2*(tokenPriceIncremental_ * 1e18)*(amount * 1e18))\n', '                            +\n', '                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n', '                            +\n', '                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n', '                        )\n', '                    ), _tokenPriceInitial\n', '                )\n', '            )/(tokenPriceIncremental_)\n', '        )-(tokenSupply_)\n', '        ;\n', '  \n', '        return _tokensReceived;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to calculate token price based on an amount of incoming collateral\n', "     * It's an scientific algorithm;\n", '     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\n', '     */\n', '    function collateralToToken_(address contractAddress, uint256 _tokens) internal view returns(uint256)\n', '    {\n', '\n', '        uint256 tokens_ = _tokens + 1e18 ;\n', '        uint256 _tokenSupply = tokenLedger[contractAddress].supply + 1e18;\n', '        uint256 tokenPriceInitial_ = tokenLedger[contractAddress].initialPrice;\n', '        uint tokenPriceIncremental_ = tokenLedger[contractAddress].incrementPrice;\n', '        \n', '        uint256 _etherReceived =\n', '        (\n', '            // underflow attempts BTFO\n', '            SafeMath.sub(\n', '                (\n', '                    (\n', '                        (\n', '                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n', '                        )-tokenPriceIncremental_\n', '                    )*(tokens_ - 1e18)\n', '                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n', '            )\n', '        /1e18);\n', '        \n', '        return _etherReceived;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to calculate amount of collateral received after sending tokens\n', '     */\n', '    function calculateCollateReceived(address contractAddress, uint256 _tokenAmount) public view returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        uint256 _dividends = SafeMath.div(_tokenAmount, dividendFee);\n', '        uint256 _taxedToken = SafeMath.sub(_tokenAmount, _dividends);\n', '        uint256 _amountOfCollatral = tokentoCollateral_(contractAddress, _taxedToken);\n', '        \n', '        return _amountOfCollatral;\n', '    }\n', '     \n', '    /**\n', '     * @dev function to calculate amount of tokens received after sending collateral\n', '     */\n', '    function calculateTokenReceived(address contractAddress, uint256 _collateToSell) public view returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        require(_collateToSell <= tokenLedger[contractAddress].supply);\n', '        \n', '        uint256 _token = collateralToToken_(contractAddress, _collateToSell);\n', '        uint256 _dividends = SafeMath.div(_token, dividendFee);\n', '        uint256 _taxedToken = SafeMath.sub(_token, _dividends);\n', '        return _taxedToken;\n', '    }  \n', '    \n', '    /**\n', '     * @dev function to process purchase of collateral and update user balance, dividend\n', '     */\n', '    function purchaseCollate(address contractAddress, uint256 _incomingToken, address _referredBy) internal returns(uint256)\n', '    {\n', '        // data setup\n', '        address _customerAddress = msg.sender;\n', '        uint256 _undividedDividends = SafeMath.div(_incomingToken, dividendFee);\n', '        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n', '        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '        uint256 _taxedToken = SafeMath.sub(_incomingToken, _undividedDividends);\n', '        uint256 _amountOfCollate = tokentoCollateral_(contractAddress,_taxedToken);\n', '        uint256 _fee = _dividends * magnitude;\n', ' \n', '      \n', '        require(_amountOfCollate > 0 && (SafeMath.add(_amountOfCollate,tokenLedger[contractAddress].supply) > tokenLedger[contractAddress].supply));\n', '        \n', '        // is the user referred by a karmalink?\n', '        if(\n', '            // is this a referred purchase?\n', '            _referredBy != address(0) &&\n', '            \n', '            // no cheating!\n', '            _referredBy != _customerAddress &&\n', '            \n', '            walletAddressRecord[_referredBy] == true\n', '        ){\n', '            // wealth redistribution\n', '            balanceLedger[_referredBy][contractAddress].referralBalance = SafeMath.add(balanceLedger[_referredBy][contractAddress].referralBalance, _referralBonus);\n', '        } else {\n', '            // no ref purchase\n', '            // add the referral bonus back to the global dividends cake\n', '            _dividends = SafeMath.add(_dividends, _referralBonus);\n', '            _fee = _dividends * magnitude;\n', '        }\n', '        \n', "        // we can't give people infinite ethereum\n", '        if(tokenLedger[contractAddress].supply > 0){\n', '            \n', '            // add tokens to the pool\n', '            tokenLedger[contractAddress].supply = SafeMath.add(tokenLedger[contractAddress].supply, _amountOfCollate);\n', ' \n', '            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\n', '            tokenLedger[contractAddress].dividend += (_dividends * magnitude / (tokenLedger[contractAddress].supply));\n', '            \n', '            // calculate the amount of tokens the customer receives over his purchase \n', '            _fee = _fee - (_fee-(_amountOfCollate * (_dividends * magnitude / (tokenLedger[contractAddress].supply))));\n', '        \n', '        } else {\n', '            // add tokens to the pool\n', '            tokenLedger[contractAddress].supply = _amountOfCollate;\n', '        }\n', '        \n', '        // update circulating supply & the ledger address for the customer\n', '        balanceLedger[_customerAddress][contractAddress].tokenBalance = SafeMath.add(balanceLedger[_customerAddress][contractAddress].tokenBalance, _amountOfCollate);\n', '        \n', '        int256 _updatedPayouts = (int256) ((tokenLedger[contractAddress].dividend * _amountOfCollate) - _fee);\n', '        balanceLedger[_customerAddress][contractAddress].payOut += _updatedPayouts;\n', '        \n', '        // fire event\n', '        emit onPurchase(_customerAddress, contractAddress, _incomingToken, _amountOfCollate, _referredBy);\n', '        \n', '        return _amountOfCollate;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to get tokens contract hold\n', '     */\n', '    function totalTokenBalance(address contractAddress) public view returns(uint)\n', '    {   \n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        if (contractAddress== address(0)){\n', '            return address(this).balance;\n', '        }\n', '        else{\n', '            return ERC20(contractAddress).balanceOf(address(this));\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev function to retrieve the total token supply.\n', '     */\n', '    function totalSupply(address contractAddress) public view returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        return tokenLedger[contractAddress].supply;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to retrieve the tokens owned by the caller.\n', '     */\n', '    function myTokens(address contractAddress) public view returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        address _customerAddress = msg.sender;\n', '        return balanceOf(contractAddress, _customerAddress);\n', '    }\n', '    \n', '    /**\n', '     * @dev function to retrieve the dividends owned by the caller.\n', '      */ \n', '    function myDividends(address contractAddress, bool _includeReferralBonus) public view returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        address _customerAddress = msg.sender;\n', '        return _includeReferralBonus ? dividendsOf(contractAddress,_customerAddress) + balanceLedger[_customerAddress][contractAddress].referralBalance : dividendsOf(contractAddress, _customerAddress) ;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to retrieve the token balance of any single address.\n', '     */\n', '    function balanceOf(address contractAddress, address _customerAddress) view public returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        return balanceLedger[_customerAddress][contractAddress].tokenBalance;\n', '    }\n', '    \n', '    /**\n', '     * @dev function to retrieve the dividend balance of any single address.\n', '     */\n', '    function dividendsOf(address contractAddress, address _customerAddress) view public returns(uint256)\n', '    {\n', '        require(contractAddressRecord[contractAddress] == true);\n', '        \n', '        return (uint256) ((int256)(tokenLedger[contractAddress].dividend * balanceLedger[_customerAddress][contractAddress].tokenBalance) - balanceLedger[_customerAddress][contractAddress].payOut) / magnitude;\n', '    }\n', '    \n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev interface to process transfer of ERC20 tokens\n', ' */ \n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint supply);\n', '    function allowance(address _owner, address _spender) external view returns (uint remaining);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '    function transfer(address _to, uint _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender,    uint _value);\n', '    event Transfer(address indexed _from, address indexed _to, uint    _value);\n', '}\n', '\n', '/**\n', ' * @dev safemath library to avoid mathematical overflow error\n', ' */ \n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '   \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '   \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}']