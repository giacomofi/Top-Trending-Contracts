['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-22\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'library Address {\n', '       function isContract(address account) internal view returns (bool) {\n', '           bytes32 codehash;\n', '           bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '           assembly { codehash := extcodehash(account) }\n', '           return (codehash != accountHash && codehash != 0x0);\n', '       }\n', '       function sendValue(address payable recipient, uint256 amount) internal {\n', '          require(address(this).balance >= amount, "Address: insufficient balance");\n', '          (bool success, ) = recipient.call.value(amount)("");\n', '          require(success, "Address: unable to send value, recipient may have reverted");\n', '      }\n', '      function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '      }\n', '      function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '          return _functionCallWithValue(target, data, 0, errorMessage);\n', '      }\n', '      function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '          return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '      }\n', '      function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '          require(address(this).balance >= value, "Address: insufficient balance for call");\n', '          return _functionCallWithValue(target, data, value, errorMessage);\n', '      }\n', '      function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '          require(isContract(target), "Address: call to non-contract");\n', '          (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\n', '          if (success) {\n', '              return returndata;\n', '          } else {\n', '              if (returndata.length > 0) {\n', '                  assembly {\n', '                      let returndata_size := mload(returndata)\n', '                      revert(add(32, returndata), returndata_size)\n', '                  }\n', '              } else {\n', '                  revert(errorMessage);\n', '              }\n', '          }\n', '      }\n', '  }\n', '  abstract contract Context {\n', '      function _msgSender() internal view virtual returns (address payable) {\n', '          return msg.sender;\n', '      }\n', '      function _msgData() internal view virtual returns (bytes memory) {\n', '          this; \n', '          return msg.data;\n', '      }\n', '  }\n', '  interface IERC20 {\n', '      function totalSupply() external view returns (uint256);\n', '      function balanceOf(address account) external view returns (uint256);\n', '      function transfer(address recipient, uint256 amount) external returns (bool);\n', '      function allowance(address owner, address spender) external view returns (uint256);\n', '      function approve(address spender, uint256 amount) external returns (bool);\n', '      function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '      event Transfer(address indexed from, address indexed to, uint256 value);\n', '      event Approval(address indexed owner, address indexed spender, uint256 value);\n', '  }\n', '  contract Ownable is Context {\n', '      address private _owner;\n', '      address private _previousOwner;\n', '      uint256 private _lockTime;\n', '      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '      constructor () internal {\n', '          address msgSender = _msgSender();\n', '          _owner = msgSender;\n', '          emit OwnershipTransferred(address(0), msgSender);\n', '      }\n', '      function owner() public view returns (address) {\n', '          return _owner;\n', '      }\n', '      modifier onlyOwner() {\n', '          require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '          _;\n', '      }\n', '      function renounceOwnership() public virtual onlyOwner {\n', '          emit OwnershipTransferred(_owner, address(0));\n', '          _owner = address(0);\n', '      }\n', '      function transferOwnership(address newOwner) public virtual onlyOwner {\n', '          require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '          emit OwnershipTransferred(_owner, newOwner);\n', '          _owner = newOwner;\n', '      }\n', '      function geUnlockTime() public view returns (uint256) {\n', '          return _lockTime;\n', '      }\n', '      function lock(uint256 time) public virtual onlyOwner {\n', '          _previousOwner = _owner;\n', '          _owner = address(0);\n', '          _lockTime = now + time;\n', '          emit OwnershipTransferred(_owner, address(0));\n', '      }\n', '      function unlock() public virtual {\n', '          require(_previousOwner == msg.sender, "You don\'t have permission to unlock");\n', '          require(now > _lockTime , "Contract is locked until 7 days");\n', '         emit OwnershipTransferred(_owner, _previousOwner);\n', '         _owner = _previousOwner;\n', '     }\n', ' }\n', ' contract DOGELASEREYES is Context, IERC20, Ownable {\n', '     using SafeMath for uint256;\n', '     using Address for address;\n', '     mapping (address => uint256) private _rOwned;\n', '     mapping (address => uint256) private _tOwned;\n', '     mapping (address => mapping (address => uint256)) private _allowances;\n', '     mapping (address => bool) private _isExcluded;\n', '     address[] private _excluded;\n', '     uint256 private constant MAX = ~uint256(0);\n', '     uint256 private _tTotal = 100000000000 * 10**6 * 10**9;\n', '     uint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '     uint256 private _tFeeTotal;\n', '     uint256 private _tBurnTotal;\n', "     string private _name = 'DOGELASEREYES';\n", "     string private _symbol = 'Dogelasereyes';\n", '     uint8 private _decimals = 9;\n', '     uint256 private _taxFee = 1;\n', '     uint256 private _burnFee = numBurn();\n', '     uint256 private _maxTxAmount = 100000000000 * 10**6 * 10**9;\n', '     constructor () public {\n', '         _rOwned[_msgSender()] = _rTotal;\n', '         emit Transfer(address(0), _msgSender(), _tTotal);\n', '     }\n', '\t \n', '\t //try to convert decimal to uint256\n', '\t function numBurn() public pure returns (uint) {\n', '\t\t uint tmp = 0.1 * 10**1;\n', '\t\t return tmp;\n', '\t }\n', '\t \n', '     function name() public view returns (string memory) {\n', '         return _name;\n', '     }\n', '     function symbol() public view returns (string memory) {\n', '         return _symbol;\n', '     }\n', '     function decimals() public view returns (uint8) {\n', '         return _decimals;\n', '     }\n', '     function totalSupply() public view override returns (uint256) {\n', '         return _tTotal;\n', '     }\n', '     function balanceOf(address account) public view override returns (uint256) {\n', '         if (_isExcluded[account]) return _tOwned[account];\n', '         return tokenFromReflection(_rOwned[account]);\n', '     }\n', '     function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '         _transfer(_msgSender(), recipient, amount);\n', '         return true;\n', '     }\n', '     function allowance(address owner, address spender) public view override returns (uint256) {\n', '         return _allowances[owner][spender];\n', '     }\n', '     function approve(address spender, uint256 amount) public override returns (bool) {\n', '         _approve(_msgSender(), spender, amount);\n', '         return true;\n', '     }\n', '     function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '         _transfer(sender, recipient, amount);\n', '         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '         return true;\n', '     }\n', '     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '         return true;\n', '     }\n', '     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '         return true;\n', '     }\n', '     function isExcluded(address account) public view returns (bool) {\n', '         return _isExcluded[account];\n', '     }\n', '     function totalFees() public view returns (uint256) {\n', '         return _tFeeTotal;\n', '     }\n', '     function totalBurn() public view returns (uint256) {\n', '         return _tBurnTotal;\n', '     }\n', '     function deliver(uint256 tAmount) public {\n', '         address sender = _msgSender();\n', '         require(!_isExcluded[sender], "Excluded addresses cannot call this function");\n', '         (uint256 rAmount,,,,,) = _getValues(tAmount);\n', '         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '         _rTotal = _rTotal.sub(rAmount);\n', '         _tFeeTotal = _tFeeTotal.add(tAmount);\n', '     }\n', '     function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n', '         require(tAmount <= _tTotal, "Amount must be less than supply");\n', '         if (!deductTransferFee) {\n', '             (uint256 rAmount,,,,,) = _getValues(tAmount);\n', '             return rAmount;\n', '         } else {\n', '             (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n', '             return rTransferAmount;\n', '         }\n', '     }\n', '     function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n', '         require(rAmount <= _rTotal, "Amount must be less than total reflections");\n', '         uint256 currentRate =  _getRate();\n', '         return rAmount.div(currentRate);\n', '     }\n', '     function excludeAccount(address account) external onlyOwner() {\n', "         require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\n", '         require(!_isExcluded[account], "Account is already excluded");\n', '         if(_rOwned[account] > 0) {\n', '             _tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '         }\n', '         _isExcluded[account] = true;\n', '         _excluded.push(account);\n', '     }\n', '     function includeAccount(address account) external onlyOwner() {\n', '         require(_isExcluded[account], "Account is already excluded");\n', '         for (uint256 i = 0; i < _excluded.length; i++) {\n', '             if (_excluded[i] == account) {\n', '                 _excluded[i] = _excluded[_excluded.length - 1];\n', '                 _tOwned[account] = 0;\n', '                 _isExcluded[account] = false;\n', '                 _excluded.pop();\n', '                 break;\n', '             }\n', '         }\n', '     }\n', '     function _approve(address owner, address spender, uint256 amount) private {\n', '         require(owner != address(0), "ERC20: approve from the zero address");\n', '         require(spender != address(0), "ERC20: approve to the zero address");\n', '         _allowances[owner][spender] = amount;\n', '         emit Approval(owner, spender, amount);\n', '     }\n', '     function _transfer(address sender, address recipient, uint256 amount) private {\n', '         require(sender != address(0), "ERC20: transfer from the zero address");\n', '         require(recipient != address(0), "ERC20: transfer to the zero address");\n', '         require(amount > 0, "Transfer amount must be greater than zero");\n', '         if(sender != owner() && recipient != owner())\n', '             require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");\n', '         if (_isExcluded[sender] && !_isExcluded[recipient]) {\n', '             _transferFromExcluded(sender, recipient, amount);\n', '         } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n', '             _transferToExcluded(sender, recipient, amount);\n', '         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n', '             _transferStandard(sender, recipient, amount);\n', '         } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n', '             _transferBothExcluded(sender, recipient, amount);\n', '         } else {\n', '             _transferStandard(sender, recipient, amount);\n', '         }\n', '     }\n', '     function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n', '         uint256 currentRate =  _getRate();\n', '         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn) = _getValues(tAmount);\n', '         uint256 rBurn =  tBurn.mul(currentRate);\n', '         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n', '         _reflectFee(rFee, rBurn, tFee, tBurn);\n', '         emit Transfer(sender, recipient, tTransferAmount);\n', '     }\n', '     function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n', '         uint256 currentRate =  _getRate();\n', '         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn) = _getValues(tAmount);\n', '         uint256 rBurn =  tBurn.mul(currentRate);\n', '         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n', '         _reflectFee(rFee, rBurn, tFee, tBurn);\n', '         emit Transfer(sender, recipient, tTransferAmount);\n', '     }\n', '     function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n', '         uint256 currentRate =  _getRate();\n', '         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn) = _getValues(tAmount);\n', '         uint256 rBurn =  tBurn.mul(currentRate);\n', '         _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n', '         _reflectFee(rFee, rBurn, tFee, tBurn);\n', '         emit Transfer(sender, recipient, tTransferAmount);\n', '     }\n', '     function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n', '         uint256 currentRate =  _getRate();\n', '         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tBurn) = _getValues(tAmount);\n', '         uint256 rBurn =  tBurn.mul(currentRate);\n', '         _tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '         _rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '         _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '         _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n', '         _reflectFee(rFee, rBurn, tFee, tBurn);\n', '         emit Transfer(sender, recipient, tTransferAmount);\n', '     }\n', '     function _reflectFee(uint256 rFee, uint256 rBurn, uint256 tFee, uint256 tBurn) private {\n', '         _rTotal = _rTotal.sub(rFee).sub(rBurn);\n', '         _tFeeTotal = _tFeeTotal.add(tFee);\n', '         _tBurnTotal = _tBurnTotal.add(tBurn);\n', '         _tTotal = _tTotal.sub(tBurn);\n', '     }\n', '     function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '         (uint256 tTransferAmount, uint256 tFee, uint256 tBurn) = _getTValues(tAmount, _taxFee, _burnFee);\n', '         uint256 currentRate =  _getRate();\n', '         (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tBurn, currentRate);\n', '         return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tBurn);\n', '     }\n', '     function _getTValues(uint256 tAmount, uint256 taxFee, uint256 burnFee) private pure returns (uint256, uint256, uint256) {\n', '         uint256 tFee = tAmount.mul(taxFee).div(100);\n', '         uint256 tBurn = tAmount.mul(burnFee).div(100);\n', '         uint256 tTransferAmount = tAmount.sub(tFee).sub(tBurn);\n', '         return (tTransferAmount, tFee, tBurn);\n', '     }\n', '     function _getRValues(uint256 tAmount, uint256 tFee, uint256 tBurn, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n', '         uint256 rAmount = tAmount.mul(currentRate);\n', '         uint256 rFee = tFee.mul(currentRate);\n', '         uint256 rBurn = tBurn.mul(currentRate);\n', '         uint256 rTransferAmount = rAmount.sub(rFee).sub(rBurn);\n', '         return (rAmount, rTransferAmount, rFee);\n', '     }\n', '     function _getRate() private view returns(uint256) {\n', '         (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '         return rSupply.div(tSupply);\n', '     }\n', '     function _getCurrentSupply() private view returns(uint256, uint256) {\n', '         uint256 rSupply = _rTotal;\n', '         uint256 tSupply = _tTotal;      \n', '         for (uint256 i = 0; i < _excluded.length; i++) {\n', '             if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n', '             rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n', '             tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n', '         }\n', '         if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '         return (rSupply, tSupply);\n', '     }\n', '     function _getTaxFee() private view returns(uint256) {\n', '         return _taxFee;\n', '     }\n', '     function _getMaxTxAmount() private view returns(uint256) {\n', '         return _maxTxAmount;\n', '     }\n', '    function _setTaxFee(uint256 taxFee) external onlyOwner() {\n', "         require(taxFee >= 1 && taxFee <= 10, 'taxFee should be in 1 - 10');\n", '         _taxFee = taxFee;\n', '     }\n', '     function _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\n', "         require(maxTxAmount >= 100000000000000e9 , 'maxTxAmount should be greater than 100000000000000e9');\n", '         _maxTxAmount = maxTxAmount;\n', '     }\n', ' }\n', ' library SafeMath {\n', '     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         uint256 c = a + b;\n', '         require(c >= a, "SafeMath: addition overflow");\n', '         return c;\n', '     }\n', '     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         return sub(a, b, "SafeMath: subtraction overflow");\n', '     }\n', '     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '         require(b <= a, errorMessage);\n', '         uint256 c = a - b;\n', '         return c;\n', '     }\n', '     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         if (a == 0) {\n', '            return 0;\n', '         }\n', '         uint256 c = a * b;\n', '         require(c / a == b, "SafeMath: multiplication overflow");\n', '         return c;\n', '     }\n', '     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         return div(a, b, "SafeMath: division by zero");\n', '     }\n', '     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '         uint256 c = a / b;\n', '         return c;\n', '     }\n', '     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         return mod(a, b, "SafeMath: modulo by zero");\n', '     }\n', '     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '         require(b != 0, errorMessage);\n', '         return a % b;\n', '     }\n', '}']