['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC721Receiver.sol";\n', "import './IERC1155Receiver.sol';\n", 'import "./ERC165.sol";\n', "import './Events.sol';\n", "import './Ownable.sol';\n", '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IERC721 {\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function totalSupply() external view returns (uint256);\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '    function approve(address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function mintCreature() external returns (uint256 creatureId);\n', '}\n', '\n', 'interface IERC1155 {\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', 'interface ISwap {\n', '    function swapErc20(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inAmount,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external;\n', '    function swapErc721(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external;\n', '    function swapErc1155(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        uint256 inAmount,\n', '        address outToken,\n', '        uint256 outId,\n', '        uint8 router,\n', '        address to\n', '    ) external;\n', '}\n', '\n', 'contract ApymonPack is ERC165, IERC1155Receiver, IERC721Receiver, Context, Events, Ownable {\n', '\n', '    struct Token {\n', '        uint8 tokenType; // 1: ERC20, 2: ERC721, 3: ERC1155\n', '        address tokenAddress;\n', '    }\n', '\n', '    // Token types\n', '    uint8 private constant TOKEN_TYPE_ERC20 = 1;\n', '    uint8 private constant TOKEN_TYPE_ERC721 = 2;\n', '    uint8 private constant TOKEN_TYPE_ERC1155 = 3;\n', '\n', '    uint256 private constant MAX_EGG_SUPPLY = 6400;\n', '\n', '    // Mapping from egg ID -> token(erc20) -> balance\n', '    mapping(uint256 => mapping(address => uint256)) private _insideERC20TokenBalances;\n', '\n', '    // Mapping from egg ID -> token(erc1155) -> tokenId -> balance\n', '    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) private _insideERC1155TokenBalances;\n', '\n', '    // Mapping from egg ID -> tokens\n', '    mapping(uint256 => Token[]) private _insideTokens;\n', '\n', '    // Mapping from egg ID -> token(erc721 or erc1155) -> ids\n', '    mapping(uint256 => mapping(address => uint256[])) private _insideTokenIds;\n', '\n', '    // Mapping from egg ID -> locked time\n', '    mapping(uint256 => uint256) private _lockedTimestamp;\n', '\n', '    // Mapping from egg ID -> opened\n', '    mapping(uint256 => bool) private _opened;\n', '\n', '    IERC721 public _apymon;\n', '\n', '    bool public _enableClose;\n', '    ISwap public _swap;\n', '\n', '    modifier onlyEggOwner(uint256 eggId) {\n', '        require(_apymon.exists(eggId));\n', '        require(_apymon.ownerOf(eggId) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier unlocked(uint256 eggId) {\n', '        require(\n', '            _lockedTimestamp[eggId] == 0 ||\n', '            _lockedTimestamp[eggId] < block.timestamp\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier opened(uint256 eggId) {\n', '        require(isOpened(eggId));\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address apymon\n', '    ) {\n', '        _apymon = IERC721(apymon);\n', '        _enableClose = false;\n', '    }\n', '\n', '    // View functions\n', '\n', '    /**\n', '     * @dev check if egg has been locked.\n', '     */\n', '    function existsId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 id\n', '    ) public view returns (bool) {\n', '        uint256[] memory ids = _insideTokenIds[eggId][token];\n', '\n', '        for (uint256 i; i < ids.length; i++) {\n', '            if (ids[i] == id) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if egg has been locked.\n', '     */\n', '    function isLocked(\n', '        uint256 eggId\n', '    ) external view returns (bool locked, uint256 endTime) {\n', '        if (\n', '            _lockedTimestamp[eggId] == 0 ||\n', '            _lockedTimestamp[eggId] < block.timestamp\n', '        ) {\n', '            locked = false;\n', '        } else {\n', '            locked = true;\n', '            endTime = _lockedTimestamp[eggId];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev check if egg opened or not.\n', '     */\n', '    function isOpened(\n', '        uint256 eggId\n', '    ) public view returns (bool) {\n', '        return _opened[eggId];\n', '    }\n', '\n', '    /**\n', '     * @dev check if claimed creature for certain egg.\n', '     */\n', '    function isClaimedCreature(\n', '        uint256 eggId\n', '    ) public view returns (bool) {\n', '        return _apymon.exists(eggId + MAX_EGG_SUPPLY);\n', '    }\n', '\n', '    /**\n', '     * @dev check if tokenId exists in egg\n', '     */\n', '    function getInsideTokensCount(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (\n', '        uint256 erc20Len,\n', '        uint256 erc721Len,\n', '        uint256 erc1155Len\n', '    ) {\n', '        Token[] memory tokens = _insideTokens[eggId];\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            Token memory token = tokens[i];\n', '            if (token.tokenType == TOKEN_TYPE_ERC20) {\n', '                erc20Len += 1;\n', '            }\n', '            if (token.tokenType == TOKEN_TYPE_ERC721) {\n', '                erc721Len += 1;\n', '            }\n', '            if (token.tokenType == TOKEN_TYPE_ERC1155) {\n', '                erc1155Len += 1;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev get tokens by eggId\n', '     */\n', '    function getTokens(\n', '        uint256 eggId\n', '    ) external view opened(eggId) returns (\n', '        uint8[] memory tokenTypes,\n', '        address[] memory tokenAddresses\n', '    ) {\n', '        Token[] memory tokens = _insideTokens[eggId];\n', '        \n', '        tokenTypes = new uint8[](tokens.length);\n', '        tokenAddresses = new address[](tokens.length);\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            tokenTypes[i] = tokens[i].tokenType;\n', '            tokenAddresses[i] = tokens[i].tokenAddress;\n', '        }        \n', '    }\n', '\n', '    /**\n', '     * @dev get ERC20 token info\n', '     */\n', '    function getERC20Tokens(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (\n', '        address[] memory addresses,\n', '        uint256[] memory tokenBalances\n', '    ) {\n', '        Token[] memory tokens = _insideTokens[eggId];\n', '        (\n', '            uint256 erc20Len,\n', '            ,\n', '        ) = getInsideTokensCount(eggId);\n', '        \n', '        tokenBalances = new uint256[](erc20Len);\n', '        addresses = new address[](erc20Len);\n', '        uint256 j;\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            Token memory token = tokens[i];\n', '            if (token.tokenType == TOKEN_TYPE_ERC20) {\n', '                addresses[j] = token.tokenAddress;\n', '                tokenBalances[j] = _insideERC20TokenBalances[eggId][token.tokenAddress];\n', '                j++;\n', '            }\n', '        }        \n', '    }\n', '\n', '    /**\n', '     * @dev get ERC721 token info\n', '     */\n', '    function getERC721Tokens(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (\n', '        address[] memory addresses,\n', '        uint256[] memory tokenBalances\n', '    ) {\n', '        Token[] memory tokens = _insideTokens[eggId];\n', '        (\n', '            ,\n', '            uint256 erc721Len\n', '            ,\n', '        ) = getInsideTokensCount(eggId);\n', '        \n', '        tokenBalances = new uint256[](erc721Len);\n', '        addresses = new address[](erc721Len);\n', '        uint256 j;\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            Token memory token = tokens[i];\n', '            if (token.tokenType == TOKEN_TYPE_ERC721) {\n', '                addresses[j] = token.tokenAddress;\n', '                tokenBalances[j] = _insideTokenIds[eggId][token.tokenAddress].length;\n', '                j++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev get ERC721 or ERC1155 ids\n', '     */\n', '    function getERC721OrERC1155Ids(\n', '        uint256 eggId,\n', '        address insideToken\n', '    ) public view opened(eggId) returns (uint256[] memory) {\n', '        return _insideTokenIds[eggId][insideToken];\n', '    }\n', '\n', '    /**\n', '     * @dev get ERC1155 token addresses info\n', '     */\n', '    function getERC1155Tokens(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (address[] memory addresses) {\n', '        Token[] memory tokens = _insideTokens[eggId];\n', '        (\n', '            ,\n', '            ,\n', '            uint256 erc1155Len\n', '        ) = getInsideTokensCount(eggId);\n', '        \n', '        addresses = new address[](erc1155Len);\n', '        uint256 j;\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            Token memory token = tokens[i];\n', '            if (token.tokenType == TOKEN_TYPE_ERC1155) {\n', '                addresses[j] = token.tokenAddress;\n', '                j++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev get ERC1155 token balances by ids\n', '     */\n', '    function getERC1155TokenBalances(\n', '        uint256 eggId,\n', '        address insideToken,\n', '        uint256[] memory tokenIds\n', '    ) public view opened(eggId) returns (uint256[] memory tokenBalances) {\n', '        tokenBalances = new uint256[](tokenIds.length);\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            tokenBalances[i] = _insideERC1155TokenBalances[eggId][insideToken][tokenIds[i]];\n', '        }\n', '    }\n', '\n', '    // Write functions\n', '\n', '    /**\n', '     * @dev lock egg.\n', '     */\n', '    function lockEgg(\n', '        uint256 eggId,\n', '        uint256 timeInSeconds\n', '    ) external onlyEggOwner(eggId) opened(eggId) unlocked(eggId) {\n', '        _lockedTimestamp[eggId] = block.timestamp + timeInSeconds;\n', '        emit LockedEgg(\n', '            eggId,\n', '            msg.sender,\n', '            block.timestamp,\n', '            block.timestamp + timeInSeconds\n', '        );\n', '    }\n', '\n', '    function setEnableClose(bool enabled) external onlyOwner {\n', '        _enableClose = enabled;\n', '    }\n', '\n', '    function setSwap(address swap) external onlyOwner {\n', '        _swap = ISwap(swap);\n', '    }\n', '\n', '    /**\n', '     * @dev open egg.\n', '     */\n', '    function openEgg(\n', '        uint256 eggId,\n', '        bool isClaimCreature\n', '    ) external onlyEggOwner(eggId) {\n', '        _opened[eggId] = true;\n', '        emit OpenedEgg(\n', '            eggId,\n', '            msg.sender\n', '        );\n', '\n', '        if (isClaimCreature && !isClaimedCreature(eggId)) {\n', '            claimCreature(eggId);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev open egg.\n', '     */\n', '    function closeEgg(\n', '        uint256 eggId\n', '    ) external onlyEggOwner(eggId) {\n', '        require(_enableClose == true);\n', '        _opened[eggId] = false;\n', '        emit ClosedEgg(\n', '            eggId,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev deposit erc20 tokens into egg.\n', '     */\n', '    function depositErc20IntoEgg(\n', '        uint256 eggId,\n', '        address[] memory tokens,\n', '        uint256[] memory amounts\n', '    ) external {\n', '        require(\n', '            tokens.length > 0 &&\n', '            tokens.length == amounts.length\n', '        );\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            require(tokens[i] != address(0));\n', '            IERC20 iToken = IERC20(tokens[i]);\n', '\n', '            uint256 prevBalance = iToken.balanceOf(address(this));\n', '            iToken.transferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                amounts[i]\n', '            );\n', '            uint256 receivedAmount = iToken.balanceOf(address(this)) - prevBalance;\n', '\n', '            _increaseInsideTokenBalance(\n', '                eggId,\n', '                TOKEN_TYPE_ERC20,\n', '                tokens[i],\n', '                receivedAmount\n', '            );\n', '\n', '            if (isOpened(eggId)) {\n', '                emit DepositedErc20IntoEgg(\n', '                    eggId,\n', '                    msg.sender,\n', '                    tokens[i],\n', '                    receivedAmount\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw erc20 tokens from egg.\n', '     */\n', '    function withdrawErc20FromEgg(\n', '        uint256 eggId,\n', '        address[] memory tokens,\n', '        uint256[] memory amounts,\n', '        address to\n', '    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(\n', '            tokens.length > 0 &&\n', '            tokens.length == amounts.length\n', '        );\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            require(tokens[i] != address(0));\n', '            IERC20 iToken = IERC20(tokens[i]);\n', '\n', '            iToken.transfer(to, amounts[i]);\n', '\n', '            _decreaseInsideTokenBalance(\n', '                eggId,\n', '                TOKEN_TYPE_ERC20,\n', '                tokens[i],\n', '                amounts[i]\n', '            );\n', '            emit WithdrewErc20FromEgg(\n', '                eggId,\n', '                msg.sender,\n', '                tokens[i],\n', '                amounts[i],\n', '                to\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send erc20 tokens from my egg to another egg.\n', '     */\n', '    function sendErc20(\n', '        uint256 fromEggId,\n', '        address[] memory tokens,\n', '        uint256[] memory amounts,\n', '        uint256 toEggId\n', '    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n', '        require(fromEggId != toEggId);\n', '        require(\n', '            tokens.length > 0 &&\n', '            tokens.length == amounts.length\n', '        );\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            require(tokens[i] != address(0));\n', '            require(_apymon.exists(toEggId));\n', '\n', '            _decreaseInsideTokenBalance(\n', '                fromEggId,\n', '                TOKEN_TYPE_ERC20,\n', '                tokens[i],\n', '                amounts[i]\n', '            );\n', '\n', '            _increaseInsideTokenBalance(\n', '                toEggId,\n', '                TOKEN_TYPE_ERC20,\n', '                tokens[i],\n', '                amounts[i]\n', '            );\n', '\n', '            emit SentErc20(\n', '                fromEggId,\n', '                msg.sender,\n', '                tokens[i],\n', '                amounts[i],\n', '                toEggId\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev deposit erc721 tokens into egg.\n', '     */\n', '    function depositErc721IntoEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds\n', '    ) external {\n', '        require(token != address(0));\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            require(\n', '                token != address(this) ||\n', '                (token == address(this) && eggId != tokenIds[i])\n', '            );\n', '            IERC721 iToken = IERC721(token);\n', '            \n', '            iToken.safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                tokenIds[i]\n', '            );\n', '\n', '            _putInsideTokenId(\n', '                eggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            if (isOpened(eggId)) {\n', '                emit DepositedErc721IntoEgg(\n', '                    eggId,\n', '                    msg.sender,\n', '                    token,\n', '                    tokenIds[i]\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw erc721 token from egg.\n', '     */\n', '    function withdrawErc721FromEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        address to\n', '    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(token != address(0));\n', '        IERC721 iToken = IERC721(token);\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            address tokenOwner = iToken.ownerOf(tokenIds[i]);\n', '\n', '            require(tokenOwner == address(this));\n', '\n', '            iToken.safeTransferFrom(\n', '                tokenOwner,\n', '                to,\n', '                tokenIds[i]\n', '            );\n', '\n', '            _popInsideTokenId(\n', '                eggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            emit WithdrewErc721FromEgg(\n', '                eggId,\n', '                msg.sender,\n', '                token,\n', '                tokenIds[i],\n', '                to\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send erc721 tokens from my egg to another egg.\n', '     */\n', '    function sendErc721(\n', '        uint256 fromEggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        uint256 toEggId\n', '    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n', '        require(fromEggId != toEggId);\n', '        require(token != address(0));\n', '        require(_apymon.exists(toEggId));\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            _popInsideTokenId(\n', '                fromEggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            _putInsideTokenId(\n', '                toEggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            emit SentErc721(\n', '                fromEggId,\n', '                msg.sender,\n', '                token,\n', '                tokenIds[i],\n', '                toEggId\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev deposit erc1155 token into egg.\n', '     */\n', '    function depositErc1155IntoEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        uint256[] memory amounts\n', '    ) external {\n', '        require(token != address(0));\n', '        IERC1155 iToken = IERC1155(token);\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            iToken.safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                tokenIds[i],\n', '                amounts[i],\n', '                bytes("")\n', '            );\n', '\n', '            _putInsideTokenIdForERC1155(\n', '                eggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            _increaseInsideERC1155TokenBalance(\n', '                eggId,\n', '                TOKEN_TYPE_ERC1155,\n', '                token,\n', '                tokenIds[i],\n', '                amounts[i]\n', '            );\n', '\n', '            if (isOpened(eggId)) {\n', '                emit DepositedErc1155IntoEgg(\n', '                    eggId,\n', '                    msg.sender,\n', '                    token,\n', '                    tokenIds[i],\n', '                    amounts[i]\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw erc1155 token from egg.\n', '     */\n', '    function withdrawErc1155FromEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        uint256[] memory amounts,\n', '        address to\n', '    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(token != address(0));\n', '        IERC1155 iToken = IERC1155(token);\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            uint256 tokenId = tokenIds[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            iToken.safeTransferFrom(\n', '                address(this),\n', '                to,\n', '                tokenId,\n', '                amount,\n', '                bytes("")\n', '            );\n', '\n', '            _decreaseInsideERC1155TokenBalance(\n', '                eggId,\n', '                token,\n', '                tokenId,\n', '                amount\n', '            );\n', '\n', '            _popInsideTokenIdForERC1155(\n', '                eggId,\n', '                token,\n', '                tokenId\n', '            );\n', '\n', '            _popERC1155FromEgg(\n', '                eggId,\n', '                token,\n', '                tokenId\n', '            );\n', '            emit WithdrewErc1155FromEgg(\n', '                eggId,\n', '                msg.sender,\n', '                token,\n', '                tokenId,\n', '                amount,\n', '                to\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send erc1155 token from my egg to another egg.\n', '     */\n', '    function sendErc1155(\n', '        uint256 fromEggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        uint256[] memory amounts,\n', '        uint256 toEggId\n', '    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n', '        require(fromEggId != toEggId);\n', '        require(token != address(0));\n', '        require(_apymon.exists(toEggId));\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            uint256 tokenId = tokenIds[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            _decreaseInsideERC1155TokenBalance(\n', '                fromEggId,\n', '                token,\n', '                tokenId,\n', '                amount\n', '            );\n', '\n', '            _increaseInsideERC1155TokenBalance(\n', '                toEggId,\n', '                TOKEN_TYPE_ERC1155,\n', '                token,\n', '                tokenId,\n', '                amount\n', '            );\n', '\n', '            _popInsideTokenIdForERC1155(\n', '                fromEggId,\n', '                token,\n', '                tokenId\n', '            );\n', '\n', '            _putInsideTokenIdForERC1155(\n', '                toEggId,\n', '                token,\n', '                tokenId\n', '            );\n', '\n', '            _popERC1155FromEgg(\n', '                fromEggId,\n', '                token,\n', '                tokenId\n', '            );\n', '            emit SentErc1155(\n', '                fromEggId,\n', '                msg.sender,\n', '                token,\n', '                tokenId,\n', '                amount,\n', '                toEggId\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw all of inside tokens into specific address.\n', '     */\n', '    function withdrawAll(\n', '        uint256 eggId,\n', '        address to\n', '    ) external {\n', '        require(to != address(0));\n', '        (address[] memory erc20Addresses, uint256[] memory erc20Balances) = getERC20Tokens(eggId);\n', '        withdrawErc20FromEgg(\n', '            eggId,\n', '            erc20Addresses,\n', '            erc20Balances,\n', '            to\n', '        );\n', '\n', '        (address[] memory erc721Addresses, ) = getERC721Tokens(eggId);\n', '        for (uint256 a; a < erc721Addresses.length; a++) {\n', '            uint256[] memory ids = getERC721OrERC1155Ids(\n', '                eggId,\n', '                erc721Addresses[a]\n', '            );\n', '            withdrawErc721FromEgg(\n', '                eggId,\n', '                erc721Addresses[a],\n', '                ids,\n', '                to\n', '            );\n', '        }\n', '\n', '        address[] memory erc1155Addresses = getERC1155Tokens(eggId);\n', '        for (uint256 a; a < erc1155Addresses.length; a++) {\n', '            uint256[] memory ids = getERC721OrERC1155Ids(\n', '                eggId,\n', '                erc1155Addresses[a]\n', '            );\n', '            uint256[] memory tokenBalances = getERC1155TokenBalances(\n', '                eggId,\n', '                erc1155Addresses[a],\n', '                ids\n', '            );\n', '            withdrawErc1155FromEgg(\n', '                eggId,\n', '                erc1155Addresses[a],\n', '                ids,\n', '                tokenBalances,\n', '                to\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send all of inside tokens to specific egg.\n', '     */\n', '    function sendAll(\n', '        uint256 fromEggId,\n', '        uint256 toEggId\n', '    ) external {\n', '        (\n', '            address[] memory erc20Addresses,\n', '            uint256[] memory erc20Balances\n', '        ) = getERC20Tokens(fromEggId);\n', '        sendErc20(\n', '            fromEggId,\n', '            erc20Addresses,\n', '            erc20Balances,\n', '            toEggId\n', '        );\n', '\n', '        (\n', '            address[] memory erc721Addresses\n', '            ,\n', '        ) = getERC721Tokens(fromEggId);\n', '        for (uint256 a; a < erc721Addresses.length; a++) {\n', '            uint256[] memory ids = getERC721OrERC1155Ids(\n', '                fromEggId,\n', '                erc721Addresses[a]\n', '            );\n', '            sendErc721(\n', '                fromEggId,\n', '                erc721Addresses[a],\n', '                ids,\n', '                toEggId\n', '            );\n', '        }\n', '\n', '        address[] memory erc1155Addresses = getERC1155Tokens(fromEggId);\n', '        for (uint256 a; a < erc1155Addresses.length; a++) {\n', '            uint256[] memory ids = getERC721OrERC1155Ids(\n', '                fromEggId,\n', '                erc1155Addresses[a]\n', '            );\n', '            uint256[] memory tokenBalances = getERC1155TokenBalances(\n', '                fromEggId,\n', '                erc1155Addresses[a],\n', '                ids\n', '            );\n', '            sendErc1155(\n', '                fromEggId,\n', '                erc1155Addresses[a],\n', '                ids,\n', '                tokenBalances,\n', '                toEggId\n', '            );\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev external function to increase token balance of egg\n', '     */\n', '    function increaseInsideTokenBalance(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address token,\n', '        uint256 amount\n', '    ) external {\n', '        require(msg.sender != address(0));\n', '        require(msg.sender == address(_apymon));\n', '\n', '        _increaseInsideTokenBalance(\n', '            eggId,\n', '            tokenType,\n', '            token,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev external function to put creature into egg\n', '     * Must be called by egg owner\n', '     */\n', '    function claimCreature(\n', '        uint256 eggId\n', '    ) public onlyEggOwner(eggId) {\n', '        uint256 creatureId = _apymon.mintCreature();\n', '\n', '        _putInsideTokenId(\n', '            eggId,\n', '            address(_apymon),\n', '            creatureId\n', '        );\n', '\n', '        emit DepositedErc721IntoEgg(\n', '            eggId,\n', '            address(this),\n', '            address(_apymon),\n', '            creatureId\n', '        );\n', '    }\n', '\n', '    function swapErc20(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inAmount,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(address(_swap) != address(0));\n', '        require(_insideERC20TokenBalances[eggId][inToken] >= inAmount);\n', '\n', '        IERC20(inToken).approve(address(_swap), inAmount);\n', '\n', '        _swap.swapErc20(\n', '            eggId,\n', '            inToken,\n', '            inAmount,\n', '            outToken,\n', '            router,\n', '            to\n', '        );\n', '        emit SwapedErc20(\n', '            msg.sender,\n', '            eggId,\n', '            inToken,\n', '            inAmount,\n', '            outToken,\n', '            to\n', '        );\n', '\n', '        _decreaseInsideTokenBalance(\n', '            eggId,\n', '            TOKEN_TYPE_ERC20,\n', '            inToken,\n', '            inAmount\n', '        );\n', '    }\n', '\n', '    function swapErc721(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(address(_swap) != address(0));\n', '        require(existsId(eggId, inToken, inId));\n', '        \n', '        IERC721(inToken).approve(address(_swap), inId);\n', '\n', '        _swap.swapErc721(\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            outToken,\n', '            router,\n', '            to\n', '        );\n', '        emit SwapedErc721(\n', '            msg.sender,\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            outToken,\n', '            to\n', '        );\n', '\n', '        _popInsideTokenId(\n', '            eggId,\n', '            inToken,\n', '            inId\n', '        );\n', '    }\n', '\n', '    function swapErc1155(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        uint256 inAmount,\n', '        address outToken,\n', '        uint256 outId,\n', '        uint8 router,\n', '        address to\n', '    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(address(_swap) != address(0));\n', '        require(existsId(eggId, inToken, inId));\n', '        require(\n', '            _insideERC1155TokenBalances[eggId][inToken][inId] >= inAmount\n', '        );\n', '\n', '        IERC1155(inToken).setApprovalForAll(address(_swap), true);\n', '\n', '        _swap.swapErc1155(\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            inAmount,\n', '            outToken,\n', '            outId,\n', '            router,\n', '            to\n', '        );\n', '        emit SwapedErc1155(\n', '            msg.sender,\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            inAmount,\n', '            outToken,\n', '            outId,\n', '            to\n', '        );\n', '\n', '        _decreaseInsideERC1155TokenBalance(\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            inAmount\n', '        );\n', '\n', '        _popInsideTokenIdForERC1155(\n', '            eggId,\n', '            inToken,\n', '            inId\n', '        );\n', '\n', '        _popERC1155FromEgg(\n', '            eggId,\n', '            inToken,\n', '            inId\n', '        );\n', '    }\n', '\n', '    function _popERC1155FromEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] memory ids = _insideTokenIds[eggId][token];\n', '        if (\n', '            _insideERC1155TokenBalances[eggId][token][tokenId] == 0 && \n', '            ids.length == 0\n', '        ) {\n', '            delete _insideERC1155TokenBalances[eggId][token][tokenId];\n', '            delete _insideTokenIds[eggId][token];\n', '            _popTokenFromEgg(\n', '                eggId,\n', '                TOKEN_TYPE_ERC1155,\n', '                token\n', '            );\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev private function to increase token balance of egg\n', '     */\n', '    function _increaseInsideTokenBalance(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address token,\n', '        uint256 amount\n', '    ) private {\n', '        _insideERC20TokenBalances[eggId][token] += amount;\n', '        _putTokenIntoEgg(\n', '            eggId,\n', '            tokenType,\n', '            token\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev private function to increase erc1155 token balance of egg\n', '     */\n', '    function _increaseInsideERC1155TokenBalance(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address token,\n', '        uint256 tokenId,\n', '        uint256 amount\n', '    ) private {\n', '        _insideERC1155TokenBalances[eggId][token][tokenId] += amount;\n', '        _putTokenIntoEgg(\n', '            eggId,\n', '            tokenType,\n', '            token\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev private function to decrease token balance of egg\n', '     */\n', '    function _decreaseInsideTokenBalance(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address token,\n', '        uint256 amount\n', '    ) private {\n', '        require(_insideERC20TokenBalances[eggId][token] >= amount);\n', '        _insideERC20TokenBalances[eggId][token] -= amount;\n', '        if (_insideERC20TokenBalances[eggId][token] == 0) {\n', '            delete _insideERC20TokenBalances[eggId][token];\n', '            _popTokenFromEgg(\n', '                eggId,\n', '                tokenType,\n', '                token\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev private function to decrease erc1155 token balance of egg\n', '     */\n', '    function _decreaseInsideERC1155TokenBalance(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId,\n', '        uint256 amount\n', '    ) private {\n', '        require(_insideERC1155TokenBalances[eggId][token][tokenId] >= amount);\n', '        _insideERC1155TokenBalances[eggId][token][tokenId] -= amount;\n', '    }\n', '\n', '    /**\n', '     * @dev private function to put a token id to egg\n', '     */\n', '    function _putInsideTokenId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] storage ids = _insideTokenIds[eggId][token];\n', '        ids.push(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev private function to put a token id to egg in ERC1155\n', '     */\n', '    function _putInsideTokenIdForERC1155(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] storage ids = _insideTokenIds[eggId][token];\n', '        bool isExist;\n', '        for (uint256 i; i < ids.length; i++) {\n', '            if (ids[i] == tokenId) {\n', '                isExist = true;\n', '            }\n', '        }\n', '        if (!isExist) {\n', '            ids.push(tokenId);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev private function to pop a token id from egg\n', '     */\n', '    function _popInsideTokenId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] storage ids = _insideTokenIds[eggId][token];\n', '        for (uint256 i; i < ids.length; i++) {\n', '            if (ids[i] == tokenId) {\n', '                ids[i] = ids[ids.length - 1];\n', '                ids.pop();\n', '            }\n', '        }\n', '\n', '        if (ids.length == 0) {\n', '            delete _insideTokenIds[eggId][token];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev private function to pop a token id from egg in ERC1155\n', '     */\n', '    function _popInsideTokenIdForERC1155(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256 tokenBalance = _insideERC1155TokenBalances[eggId][token][tokenId];\n', '        if (tokenBalance <= 0) {\n', '            delete _insideERC1155TokenBalances[eggId][token][tokenId];\n', '            _popInsideTokenId(\n', '                eggId,\n', '                token,\n', '                tokenId\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev put token(type, address) to egg\n', '     */\n', '    function _putTokenIntoEgg(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address tokenAddress\n', '    ) private {\n', '        Token[] storage tokens = _insideTokens[eggId];\n', '        bool exists = false;\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            if (\n', '                tokens[i].tokenType == tokenType &&\n', '                tokens[i].tokenAddress == tokenAddress\n', '            ) {\n', '                exists = true;\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (!exists) {\n', '            tokens.push(Token({\n', '                tokenType: tokenType,\n', '                tokenAddress: tokenAddress\n', '            }));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev pop token(type, address) from egg\n', '     */\n', '    function _popTokenFromEgg(\n', '        uint256 eggId,\n', '        uint8 tokenType,\n', '        address tokenAddress\n', '    ) private {\n', '        Token[] storage tokens = _insideTokens[eggId];\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            if (\n', '                tokens[i].tokenType == tokenType &&\n', '                tokens[i].tokenAddress == tokenAddress\n', '            ) {\n', '                tokens[i] = tokens[tokens.length - 1];\n', '                tokens.pop();\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (tokens.length == 0) {\n', '            delete _insideTokens[eggId];\n', '        }\n', '    }\n', '   \n', '    function onERC721Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        bytes calldata\n', '    ) external pure override returns (bytes4) {\n', '        return this.onERC721Received.selector;\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        bytes calldata\n', '    ) external pure override returns(bytes4) {\n', '        return 0xf23a6e61;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        bytes calldata\n', '    ) external pure override returns(bytes4) {\n', '        return 0xbc197c81;\n', '    }\n', '}']