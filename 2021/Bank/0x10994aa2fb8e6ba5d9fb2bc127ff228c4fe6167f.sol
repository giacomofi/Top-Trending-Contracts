['/* \n', '   SPDX-License-Identifier: MIT\n', '*/\n', '\n', 'interface IUniswapV2Factory {\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function sync() external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '      address token,\n', '      uint liquidity,\n', '      uint amountTokenMin,\n', '      uint amountETHMin,\n', '      address to,\n', '      uint deadline\n', '    ) external returns (uint amountETH);\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '}\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "../SafeMath.sol";\n', 'import "../Ownable.sol";\n', '\n', 'contract SEPA_Token is Ownable\n', '{\n', '    using SafeMath for *;\n', '\n', '\tIUniswapV2Router02 public _uniswapV2Router;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    address public reserve_repay_addr;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    mapping(address => bool) public uniswapPairAddress;\n', '\taddress public currentPoolAddress;\n', '\taddress public currentPairTokenAddress;\n', '\taddress public uniswapETHPool;\n', '\n', '    uint16 public LP_FEE = 3;\n', '    uint16 public RR_FEE = 1;\n', '    \n', '    bool public transferable = false;\n', '    mapping (address => bool) public transferWhitelist;\n', '\n', '\tuint256 public _minTokensBeforeSwap = 100;\n', '\tuint256 constant _autoSwapCallerFee = 0;\n', '\tuint256 constant liquidityRewardRate = 2;\n', '\t\n', '\tbool private inSwapAndLiquify;\n', '    bool public swapAndLiquifyEnabled;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event Approval(address indexed owner, address indexed spender, uint amount);\n', '    event UniswapPairAddress(address _addr, bool _whitelisted);\n', '\t\n', '\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n', '    event SwapAndLiquifyEnabledUpdated(bool enabled);\n', '    event SwapAndLiquify(\n', '        address indexed pairTokenAddress,\n', '        uint256 tokensSwapped,\n', '        uint256 pairTokenReceived,\n', '        uint256 tokensIntoLiqudity\n', '    );\n', '    \n', '\tmodifier lockTheSwap {\n', '        inSwapAndLiquify = true;\n', '        _;\n', '        inSwapAndLiquify = false;\n', '    }\n', '\n', '    constructor (IUniswapV2Router02 uniswapV2Router) {\n', '        _name = "Secure Pad";\n', '        _symbol = "SEPA";\n', '        _decimals = 18;\n', '        _mint(msg.sender, 3.5e5 * 10**_decimals); \n', '        _minTokensBeforeSwap = 100 * 10**_decimals;\n', '        \n', '\t\t_uniswapV2Router = uniswapV2Router;\n', '\n', '        currentPoolAddress = IUniswapV2Factory(uniswapV2Router.factory())\n', '            .createPair(address(this), uniswapV2Router.WETH());\n', '            \n', '        uniswapETHPool = currentPoolAddress;\n', '        \n', '        transferWhitelist[msg.sender] = true;\n', '\n', '    }\n', '    \n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view  returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view  returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual  returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual  returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual  returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual  returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '    \n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\t\n', '\tfunction _transfer(address sender, address recipient, uint256 amount) private {\n', '\t\trequire(sender != address(0), "cannot transfer from the zero address");\n', '        require(recipient != address(0), "cannot transfer to the zero address");\n', '\n', '        if (!transferable) {\n', '            require(transferWhitelist[sender], "sender not in transfer whitelist");\n', '        }\n', '\n', '        if(!inSwapAndLiquify) {\n', '            uint256 lockedBalanceForPool = balanceOf(address(this));\n', '            bool overMinTokenBalance = lockedBalanceForPool >= _minTokensBeforeSwap;\n', '\t\t\tcurrentPairTokenAddress == _uniswapV2Router.WETH();\n', '            if (\n', '                overMinTokenBalance &&\n', '                msg.sender != currentPoolAddress &&\n', '                swapAndLiquifyEnabled &&\n', '                _isUniswapPairAddress(recipient)\n', '            ) {\n', '                swapAndLiquifyForEth(lockedBalanceForPool);\n', '            }\n', '        }\n', '            _transferStandard(sender, recipient, amount);\n', '    }\n', '    \n', '\tfunction _transferStandard(address sender, address recipient, uint256 amount) private {\n', '\t\t_balances[sender] = _balances[sender].sub(amount);\n', '\t\t\n', '\t\tif (inSwapAndLiquify) {\n', '            _balances[recipient] = _balances[recipient].add(amount);\n', '            emit Transfer(sender, recipient, amount);\n', '\t\t}\n', '\t\t\n', '\t    else if (_isUniswapPairAddress(recipient))\n', '        {\n', '        uint256 LP_amount = LP_FEE.mul(amount).div(100);\n', '        uint256 RR_amount = RR_FEE.mul(amount).div(100);\n', '        uint256 transfer_amount = amount.sub(LP_amount.add(RR_amount));\n', '\n', '\t\t_transferStandardSell(sender, recipient, transfer_amount, LP_amount, RR_amount);\n', '        }\n', '        \n', '        else {\n', '            _balances[recipient] = _balances[recipient].add(amount);\n', '            emit Transfer(sender, recipient, amount);\n', '\n', '        }\n', '    }\n', '    \n', '    function _transferStandardSell(address sender, address recipient, uint256 transfer_amount, uint256 LP_amount, uint256 RR_amount) private {\n', '            _balances[recipient] = _balances[recipient].add(transfer_amount);\n', '            _balances[address(this)] = _balances[address(this)].add(LP_amount);\n', '            _balances[reserve_repay_addr] = _balances[reserve_repay_addr].add(RR_amount);        \n', '\t\t\n', '            emit Transfer(sender, recipient, transfer_amount);\n', '            emit Transfer(sender, address(this), LP_amount);\n', '            emit Transfer(sender, reserve_repay_addr, RR_amount);\n', '    }\n', '    \n', '    function swapAndLiquifyForEth(uint256 lockedBalanceForPool) internal lockTheSwap {\n', '        uint256 lockedForSwap = lockedBalanceForPool.sub(_autoSwapCallerFee);\n', '\t\tuint256 forLiquidity = lockedForSwap.div(liquidityRewardRate);\n', '\t\tuint256 forLiquidityReward = lockedForSwap.sub(forLiquidity);\n', '        uint256 half = forLiquidity.div(2);\n', '        uint256 otherHalf = forLiquidity.sub(half);\n', '\n', '        uint256 initialBalance = address(this).balance;\n', '\n', '        swapTokensForEth(half);\n', '        \n', '        uint256 newBalance = address(this).balance.sub(initialBalance);\n', '\n', '        addLiquidityForEth(otherHalf, newBalance);\n', '        \n', '        emit SwapAndLiquify(_uniswapV2Router.WETH(), half, newBalance, otherHalf);\n', '        \n', '\t\t_transfer(address(this), uniswapETHPool, forLiquidityReward);\n', '        _transfer(address(this), tx.origin, _autoSwapCallerFee);\n', '    }\n', '    \n', '    function swapTokensForEth(uint256 tokenAmount) internal {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = _uniswapV2Router.WETH();\n', '\n', '        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n', '\n', '        _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0, // accept any amount of ETH\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function addLiquidityForEth(uint256 tokenAmount, uint256 ethAmount) internal {\n', '        _approve(address(this), address(_uniswapV2Router), tokenAmount);\n', '\n', '        _uniswapV2Router.addLiquidityETH{value: ethAmount}(\n', '            address(this),\n', '            tokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '\treceive() external payable {}\n', '\n', ' \tfunction _setMinTokensBeforeSwap(uint256 minTokensBeforeSwap) external onlyOwner() {\n', "        require(minTokensBeforeSwap >= 1 * _decimals, 'minTokenBeforeSwap should be greater than 1 SEPA');\n", '        _minTokensBeforeSwap = minTokensBeforeSwap;\n', '        emit MinTokensBeforeSwapUpdated(minTokensBeforeSwap);\n', '    }\n', '    \n', '    function _enableTransfers() external onlyOwner() {\n', '        transferable = true;\n', '    }\n', '    \n', '    function _isUniswapPairAddress(address _addr) internal view returns (bool) {\n', '        return uniswapPairAddress[_addr];\n', '    }\n', '    \n', '    function _setUniswapPairAddress(address _addr, bool _whitelisted) external onlyOwner {\n', '        emit UniswapPairAddress(_addr, _whitelisted);\n', '        uniswapPairAddress[_addr] = _whitelisted;\n', '    }\n', '    \n', '    function _setReserveRepayAddr(address _addr) external onlyOwner {\n', '        reserve_repay_addr = _addr;\n', '    }\n', '    \n', '    function _setRouterContract(IUniswapV2Router02 _addr) external onlyOwner {\n', '        _uniswapV2Router = _addr;\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(uint256 amount) public {\n', '        require(msg.sender != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(msg.sender, address(0), amount);\n', '    }\n', '\t\n', '\tfunction getCurrentPoolAddress() public view returns(address) {\n', '        return currentPoolAddress;\n', '    }\n', '    \n', '    function getCurrentPairTokenAddress() public view returns(address) {\n', '        return currentPairTokenAddress;\n', '    }\n', '\n', '\tfunction updateSwapAndLiquifyEnabled(bool _enabled) external onlyOwner {\n', '        swapAndLiquifyEnabled = _enabled;\n', '        emit SwapAndLiquifyEnabledUpdated(_enabled);\n', '    }\n', '    \n', '    function setAddrTransferWhitelist(address _addr, bool _bool) external onlyOwner {\n', '        transferWhitelist[_addr] = _bool;\n', '    }\n', '    \n', '    function setFees(uint16 lp, uint16 rr) external onlyOwner {\n', '        LP_FEE = lp;\n', '        RR_FEE = rr;\n', '    }\n', '\t\n', '}']