['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-12\n', '*/\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface PriceRouter {\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface CurveRegistry {\n', '    function get_pool_from_lp_token(address arg0)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function get_underlying_coins(address arg0)\n', '        external\n', '        view\n', '        returns (address[8] memory);\n', '\n', '    function get_virtual_price_from_lp_token(address arg0)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'contract Oracle {\n', '    // Routers\n', '    address sushiswapRouterAddress = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n', '    address uniswapRouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    PriceRouter sushiswapRouter = PriceRouter(sushiswapRouterAddress);\n', '    PriceRouter uniswapRouter = PriceRouter(uniswapRouterAddress);\n', '\n', '    // Constants\n', '    address usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '    address wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '    // Uniswap/Sushiswap\n', '    function getPriceFromRouter(address token0Address, address token1Address)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = token0Address;\n', '        path[1] = token1Address;\n', '        IERC20 token0 = IERC20(token0Address);\n', '        uint256 amountIn = 10**uint256(token0.decimals());\n', '        uint256[] memory amountsOut;\n', '        try uniswapRouter.getAmountsOut(amountIn, path) returns (\n', '            uint256[] memory _amountsOut\n', '        ) {\n', '            amountsOut = _amountsOut;\n', '        } catch {\n', '            amountsOut = sushiswapRouter.getAmountsOut(amountIn, path);\n', '        }\n', '\n', '        uint256 amountOut = amountsOut[amountsOut.length - 1];\n', '        return amountOut;\n', '    }\n', '\n', '    function getPriceFromRouterUsdc(address tokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return getPriceFromRouter(tokenAddress, usdcAddress);\n', '    }\n', '\n', '    function getPriceUsdc(address tokenAddress) public view returns (uint256) {\n', '        bool useCurveCalculation = isCurveLpToken(tokenAddress);\n', '        if (useCurveCalculation) {\n', '            return getCurvePriceUsdc(tokenAddress);\n', '        }\n', '        return getPriceFromRouterUsdc(tokenAddress);\n', '    }\n', '\n', '    // Curve\n', '    address curveRegistryAddress = 0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c;\n', '    address zeroAddress = 0x0000000000000000000000000000000000000000;\n', '    CurveRegistry curveRegistry = CurveRegistry(curveRegistryAddress);\n', '\n', '    function getCurvePriceUsdc(address curveLpTokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 basePrice = getBasePrice(curveLpTokenAddress);\n', '        uint256 virtualPrice = getVirtualPrice(curveLpTokenAddress);\n', '        IERC20 usdc = IERC20(usdcAddress);\n', '        uint256 decimals = usdc.decimals();\n', '        uint256 decimalsAdjustment = 18 - decimals;\n', '        uint256 price =\n', '            (virtualPrice * basePrice * (10**decimalsAdjustment)) /\n', '                10**(decimalsAdjustment + 18);\n', '        return price;\n', '    }\n', '\n', '    function getBasePrice(address curveLpTokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address poolAddress =\n', '            curveRegistry.get_pool_from_lp_token(curveLpTokenAddress);\n', '        address firstUnderlyingCoin =\n', '            getFirstUnderlyingCoinFromPool(poolAddress);\n', '        uint256 basePrice = getPriceFromRouterUsdc(firstUnderlyingCoin);\n', '        return basePrice;\n', '    }\n', '\n', '    function getVirtualPrice(address curveLpTokenAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            curveRegistry.get_virtual_price_from_lp_token(curveLpTokenAddress);\n', '    }\n', '\n', '    function isCurveLpToken(address tokenAddress) public view returns (bool) {\n', '        address poolAddress =\n', '            curveRegistry.get_pool_from_lp_token(tokenAddress);\n', '        bool tokenHasCurvePool = poolAddress != zeroAddress;\n', '        return tokenHasCurvePool;\n', '    }\n', '\n', '    function getFirstUnderlyingCoinFromPool(address poolAddress)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        address[8] memory coins =\n', '            curveRegistry.get_underlying_coins(poolAddress);\n', '        address firstCoin = coins[0];\n', '        return firstCoin;\n', '    }\n', '}']