['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-14\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    \n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    \n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '   \n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '   \n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Interface for the optional metadata functions from the ERC20 standard.\n', ' */\n', 'interface IERC20Metadata is IERC20 {\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the decimals places of the token.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '  \n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '  function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '  function allPairs(uint) external view returns (address pair);\n', '  function allPairsLength() external view returns (uint);\n', '\n', '  function feeTo() external view returns (address);\n', '  function feeToSetter() external view returns (address);\n', '\n', '  function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'contract EthanolX is Ownable, IERC20Metadata {\n', '    IUniswapV2Factory public uniswapV2Factory;\n', '    IUniswapV2Router02 public uniswapV2Router;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint256 private _totalSupply;\n', '\n', '    uint256 public startTime;\n', '    uint256 private _cashbackInterval;\n', '    uint256 private _initialDitributionAmount;\n', '    uint256 public ditributionRewardsPool;\n', '    uint256 public liquidityRewardsPool;\n', '    uint256 public taxPercentage;\n', '    uint8 public activateFeatures;\n', '\n', '    uint256 public stabilizingRewardsPool;\n', '    uint8 public lastStabilizeAction;\n', '    uint256 private _stabilizeTokenAmount;\n', '    \n', '    address public referralWallet;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '    mapping(address => Cashback) public cashbacks;\n', '    mapping(address => bool) public excluded;\n', '    mapping(address => address) public referrers;\n', '    mapping(address => uint256) public weeklyPayouts;\n', '\n', '    struct Cashback {\n', '        address user;\n', '        uint256 timestamp;\n', '        uint256 totalClaimedRewards;\n', '    }\n', '    \n', '    event CashBackClaimed(address indexed user, uint256 amount, uint256 timestamp);\n', '    event Refund(address indexed user, uint256 amount, uint256 timestamp);\n', '    event SwapAndAddLiquidity(address indexed sender, uint256 tokensSwapped, uint256 ethReceived);\n', '    event Referral(address indexed user, address indexed referrer, uint256 timestamp);\n', '    event Stablize(string action, uint256 tokenAmount, uint256 ethAmount, uint256 timestamp);\n', '\n', '    constructor(address _referralWallet) {\n', '        _name = "EthanolX";\n', '        _symbol = "ENOX";\n', '        \n', '        uint256 _initialSupply = 10000000 ether;\n', '        uint256 _minterAmount = (_initialSupply * 70) / 100;\n', '        uint256 _ditributionAmount = (_initialSupply * 30) / 100;\n', '        \n', '        startTime = block.timestamp;\n', '        _cashbackInterval = 24 hours;\n', '        taxPercentage =  8;\n', '        activateFeatures = 0;\n', '        lastStabilizeAction = 0;\n', '        _stabilizeTokenAmount = 1000 ether;\n', '\n', '        _initialDitributionAmount = _ditributionAmount;\n', '        ditributionRewardsPool = _ditributionAmount;\n', '\n', '        _mint(_msgSender(), _minterAmount);\n', '        _mint(address(this), _ditributionAmount);\n', '        \n', '        referralWallet = _referralWallet;\n', '\n', '        /* \n', '            instantiate uniswapV2Router & uniswapV2Factory\n', '            uniswapV2Router address: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '            pancakeswapV2Router address: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\n', '        */\n', '        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        uniswapV2Factory = IUniswapV2Factory(uniswapV2Router.factory());\n', '\n', '        // create ENOX -> WETH pair\n', '        uniswapV2Factory.createPair(address(this), uniswapV2Router.WETH());\n', '\n', '        excluded[address(this)] = true;\n', '        excluded[address(uniswapV2Router)] = true;\n', '        excluded[address(uniswapV2Factory)] = true;\n', '        excluded[getPair()] = true;\n', '    }\n', '\n', '    receive() external payable {  }\n', '\n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view virtual override returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns(uint256) {\n', '        uint256 _initialBalance = _balances[account];\n', '        uint256 _finalBalance = _initialBalance + calculateRewards(account);\n', '        return _finalBalance;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        // claim accumulated cashbacks\n', '        _claimCashback(recipient);\n', '        // transfer token from caller to recipient\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        // claim accumulated cashbacks for sender and the recipient\n', '        _claimCashback(sender);\n', '        _claimCashback(recipient);\n', '\n', '        // transfer token from sender to recipient\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        // calculate tax from transferred amount\n', '        (uint256 _finalAmount, uint256 _tax) = _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += _finalAmount;\n', '        _balances[address(this)] += _tax;\n', '        _distributeTax(_tax);\n', '\n', '        /*\n', '            Note:: A static "startTime" might lead to an unforseen _cashback bug in the future.\n', '            A way of mitigating this is to automaticaly update the startTime every 24 hours on deployment\n', '        */\n', '        if((block.timestamp - startTime) >= _cashbackInterval) startTime = block.timestamp;\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function burn(uint256 _amount) external {\n', '        _burn(_msgSender(), _amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _beforeTokenTransfer(address, address, uint256 amount) internal virtual returns(uint256 _finalAmount, uint256 _tax) {\n', '        if(taxPercentage == 0 || activateFeatures == 0 || excluded[_msgSender()]) return(amount, 0);\n', '\n', '        _tax = (amount * 8) / 100;\n', '        _finalAmount = amount - _tax;\n', '        return(_finalAmount, _tax);\n', '    }\n', ' \n', '\n', '\n', '    function setActivateFeatures() external onlyOwner {\n', '        if(activateFeatures == 0) activateFeatures = 1;\n', '        else activateFeatures = 0;\n', '    }\n', '\n', '    function setExcluded(address _account, bool _status) external onlyOwner {\n', '        excluded[_account] = _status;\n', '    }\n', '\n', '    function setTransferFee(uint256 _amount) public onlyOwner {\n', '        taxPercentage = _amount;\n', '    }\n', '\n', '    function _distributeTax(uint256 _amount) internal returns(uint8) {\n', '        if(getPair() == address(0) || activateFeatures == 0 || _amount == 0) return 0;\n', '        uint256 _splitedAmount = _amount / 4; \n', '\n', '        /* \n', '            Add twice of the _splitedAmount to ditributionRewardsPool, \n', "            this will later be deducted as referrer's rewards\n", '        */\n', '        ditributionRewardsPool += (_splitedAmount * 2);\n', '        stabilizingRewardsPool += _splitedAmount;\n', '        liquidityRewardsPool += _splitedAmount;\n', '        _balances[referralWallet] += _splitedAmount;\n', '        return 1;\n', '    }\n', '\n', '    function injectLpToken() public onlyOwner returns(uint8) {\n', '        if(liquidityRewardsPool == 0) return 0;\n', '        _addLiquidity(liquidityRewardsPool);\n', '        return 1;\n', '    }\n', '    \n', '    function withdrawLpToken() external onlyOwner {\n', '        _transfer(address(this), _msgSender(), liquidityRewardsPool);\n', '        liquidityRewardsPool = 0;\n', '    }\n', '\n', '    // Start CashBack Logics\n', '    function setCashbackInterval(uint256 _value) external onlyOwner {\n', '        _cashbackInterval = _value;\n', '    }\n', '\n', '    function _claimCashback(address _account) internal returns(uint8) {\n', '        if(calculateRewards(_account) == 0) return 0;\n', '        uint256 _totalClaimedRewards = cashbacks[_account].totalClaimedRewards;\n', '\n', '        uint256 _rewards = _transferRewards(_account);\n', '        cashbacks[_account] = Cashback(_account, block.timestamp, _totalClaimedRewards + _rewards);\n', '        emit CashBackClaimed(_account, _rewards, block.timestamp);\n', '        return 1;\n', '    }\n', '\n', '    function calculateRewards(address _account) public view returns(uint256) {\n', '        // should return zero is _account has zero balance || _account => contract address\n', '        if(_balances[_account] == 0 || _isContract(_account) || _cashbackInterval == 0) return 0;\n', '\n', '        uint256 _lastClaimedTime = 0;\n', '\n', '        /* \n', '            This logic sets the initial claimedTime to the timestamp the contract was deployed.\n', '            Since the cashbacks[_account].timestamp will always be zero for all users when the contract is being deployed\n', '        */\n', '        cashbacks[_account].timestamp == 0 \n', '            ? _lastClaimedTime = startTime \n', '            : _lastClaimedTime = cashbacks[_account].timestamp;\n', '\n', '        // calculates for the unclaimed days using (current time - last claimed time) / cashbackInterval (24 hours on deployment)\n', '        uint256 _unclaimedDays = (block.timestamp - _lastClaimedTime) / _cashbackInterval;\n', '        uint256 _rewards = _unclaimedDays * calculateDailyCashback(_account);\n', '        return _rewards;\n', '    }\n', '\n', '    function calculateDailyCashback(address _account) public view returns(uint256 _rewardsPerDay) {\n', '        uint256 _accountBalance = _balances[_account];\n', '        _rewardsPerDay = (_accountBalance * 2) / 100;\n', '        return _rewardsPerDay;\n', '    }\n', '\n', '    function _transferRewards(address _account) private returns(uint256) {\n', '        uint256 _rewards = calculateRewards(_account);\n', '        uint256 _seventyPercent = (ditributionRewardsPool * 70) / 100;\n', '        uint256 _diff = ditributionRewardsPool - _initialDitributionAmount;\n', '\n', '        if(ditributionRewardsPool <= _seventyPercent) {\n', '            _mint(address(this), _diff);\n', '            ditributionRewardsPool += _diff;\n', '        } if(_rewards > ditributionRewardsPool) {\n', '            _mint(address(this), _rewards);\n', '            ditributionRewardsPool += _rewards;\n', '        }\n', '\n', '        ditributionRewardsPool -= _rewards;\n', '        _transfer(address(this), _account, _rewards);\n', '        return _rewards;\n', '    }\n', '    // End CashBack Logics\n', '\n', '    // Referral Logics\n', '    function registerReferrer(address _referrer) external {\n', '        require(referrers[_msgSender()] == address(0), "EthanolX: Referrer has already been registered");\n', '        require(_msgSender() != _referrer, "EthanolX: Can not register self as referrer");\n', '        require(balanceOf(_msgSender()) != 0, "EthanolX: Balance must be greater than zero to register a referrer");\n', '        require(!_isContract(_referrer), "EthanolX: Referrer can not be contract address");\n', '\n', '        referrers[_msgSender()] = _referrer;\n', '        emit Referral(_msgSender(), _referrer, block.timestamp);\n', '    }\n', '\n', '    // End Referral Logics\n', '\n', '    // Stabilizing mechanism\n', '    function stabilize() public onlyOwner {\n', '        _stab();\n', '    }\n', '    \n', '    function _stab() internal returns(uint8 _res) {\n', '        address[] memory path = new address[](2);\n', '        uint256[] memory amounts;\n', '        /* \n', '            lastStabilizeAction == 0 => Swap ENOX -> ETH\n', '            lastStabilizeAction == 1 => Swap ETH -> ENOX\n', '        */\n', '        if(lastStabilizeAction == 0) {\n', '            if(stabilizingRewardsPool < _stabilizeTokenAmount) return 0;\n', '            path[0] = address(this);\n', '            path[1] = uniswapV2Router.WETH();\n', '            amounts = getAmountsOut(address(this), uniswapV2Router.WETH(), _stabilizeTokenAmount);\n', '\n', '            // approve _stabilizeTokenAmount to be swapped for ETH\n', '            _approve(address(this), address(uniswapV2Router), _stabilizeTokenAmount);\n', '\n', '            // swap ENOX => ETH\n', '            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(_stabilizeTokenAmount, 0, path, address(this), block.timestamp);\n', '\n', '            // re-set global state variable\n', '            stabilizingRewardsPool -= _stabilizeTokenAmount;\n', '            lastStabilizeAction = 1;\n', '            emit Stablize("SELL", _stabilizeTokenAmount, amounts[1], block.timestamp);\n', '\n', '        } else {\n', '            path[0] = uniswapV2Router.WETH();\n', '            path[1] = address(this);\n', '            amounts = getAmountsOut(address(this), uniswapV2Router.WETH(), _stabilizeTokenAmount);\n', '            // swap ETH => ENOX\n', '            uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amounts[1]}(\n', '                0,\n', '                path,\n', '                owner(),\n', '                block.timestamp\n', '            );\n', '            _transfer(owner(), address(this), amounts[0]);\n', '            // re-set global state variable\n', '            stabilizingRewardsPool += _stabilizeTokenAmount;\n', '            lastStabilizeAction = 0;\n', '            emit Stablize("BUY", amounts[0], amounts[1], block.timestamp);\n', '            return 1;\n', '        }\n', '    }\n', '    \n', '    function withdrawStabilizeRewards() public onlyOwner {\n', '        _transfer(address(this), _msgSender(), stabilizingRewardsPool);\n', '        stabilizingRewardsPool = 0;\n', '    }\n', '\n', '    function setStabilizeTokenAmount(uint256 _amount) external onlyOwner {\n', '        _stabilizeTokenAmount = _amount;\n', '    }\n', '\n', '    function getStabilizeTokenAmount() external view returns(uint256) {\n', '        return _stabilizeTokenAmount;\n', '    }\n', '    // End stabilizing mechanism\n', '\n', '    // Uniswap Trade Logics\n', '    function getPair() public view returns(address pair) {\n', '        pair = uniswapV2Factory.getPair(address(this), uniswapV2Router.WETH());\n', '        return pair;\n', '    }\n', '\n', '    function getAmountsOut(address token1, address token2, uint256 _amount) public view returns(uint256[] memory amounts) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = token1;\n', '        path[1] = token2;\n', '        amounts = uniswapV2Router.getAmountsOut(_amount, path);\n', '        return amounts;\n', '    }\n', '\n', '    function _addLiquidity(uint256 tokenAmount) private {\n', '        uint256 _half = tokenAmount / 2;\n', '\n', '        address[] memory path = new address[](2);\n', '        uint256[] memory amounts = getAmountsOut(address(this), uniswapV2Router.WETH(), _half);\n', '\n', '        path[0] = address(this);\n', '        path[1] = uniswapV2Router.WETH();\n', '\n', '        // approve transferred amount to uniswapV2Router\n', '        _approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            _half, \n', '            0, \n', '            path, \n', '            address(this), \n', '            block.timestamp\n', '        );\n', '\n', '        uniswapV2Router.addLiquidityETH{value: amounts[1]}(\n', '            address(this),\n', '            _half,\n', '            0,\n', '            0,\n', '            owner(),\n', '            block.timestamp\n', '        );\n', '        emit SwapAndAddLiquidity(owner(), _half, amounts[1]);\n', '    }\n', '\n', '    function withdrawETH() external onlyOwner {\n', '        (bool _success, ) = payable(_msgSender()).call{ value: address(this).balance }(bytes(""));\n', '        require(_success, "EthanolX: ETH withdrawal failed");\n', '    }\n', '\n', '    function _isContract(address account) internal view returns(bool) {\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}']