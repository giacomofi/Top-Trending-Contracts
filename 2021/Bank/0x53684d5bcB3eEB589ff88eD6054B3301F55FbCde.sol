['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-06\n', '*/\n', '\n', 'pragma solidity ^ 0.4.26;\n', '\n', '/*\n', '   _____  .__.__  .__  .__                ____   ____            .__   __   \n', '  /     \\ |__|  | |  | |__| ____   ____   \\   \\ /   /____   __ __|  |_/  |_ \n', ' /  \\ /  \\|  |  | |  | |  |/  _ \\ /    \\   \\   Y   /\\__  \\ |  |  \\  |\\   __\\\n', '/    Y    \\  |  |_|  |_|  (  <_> )   |  \\   \\     /  / __ \\|  |  /  |_|  |  \n', '\\____|__  /__|____/____/__|\\____/|___|  /    \\___/  (____  /____/|____/__|  \n', '        \\/                            \\/                 \\/                 \n', '\n', 'Mechanics:\n', '---------\n', '\n', 'This is a stable hourglass without a bonding curve, long term staking \n', 'is highly recommended. \n', '\n', '10% entry fee, 10% exit fee \n', '1% transfer fee \n', '2% referral fee (no deposit required to earn ref bonus)\n', '\n', "First time deposit mints a free NFT in Team3D's InventoryV2 \n", '\n', '*/\n', '\n', 'contract InventoryV2 {\n', ' function createFromTemplate(uint256 _templateId, uint8 _feature1, uint8 _feature2, uint8 _feature3, uint8 _feature4, uint8 _equipmentPosition) public returns(uint256);\n', '}\n', '\n', 'contract TOKEN {\n', ' function totalSupply() external view returns(uint256);\n', ' function balanceOf(address account) external view returns(uint256);\n', ' function transfer(address recipient, uint256 amount) external returns(bool);\n', ' function allowance(address owner, address spender) external view returns(uint256);\n', ' function approve(address spender, uint256 amount) external returns(bool);\n', ' function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n', '}\n', '\n', 'contract Ownable {\n', ' address public owner;\n', ' event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', ' constructor() public {\n', '  owner = msg.sender;\n', ' }\n', ' modifier onlyOwner() {\n', '  require(msg.sender == owner);\n', '  _;\n', ' }\n', ' function transferOwnership(address newOwner) public onlyOwner {\n', '  require(newOwner != address(0));\n', '  emit OwnershipTransferred(owner, newOwner);\n', '  owner = newOwner;\n', ' }\n', '}\n', '\n', 'contract MillionVault is Ownable {\n', '\n', ' modifier onlyTokenHolders {\n', '  require(myTokens() > 0);\n', '  _;\n', ' }\n', '\n', ' modifier onlyDivis {\n', '  require(myDividends(true) > 0);\n', '  _;\n', ' }\n', '\n', ' event onDistribute(\n', '  address indexed customerAddress,\n', '  uint256 price\n', ' );\n', '\n', ' event onTokenPurchase(\n', '  address indexed customerAddress,\n', '  uint256 incomingMM,\n', '  uint256 tokensMinted,\n', '  address indexed referredBy,\n', '  uint timestamp\n', ' );\n', '\n', ' event onTokenSell(\n', '  address indexed customerAddress,\n', '  uint256 tokensBurned,\n', '  uint256 mmEarned,\n', '  uint timestamp\n', ' );\n', '\n', ' event onReinvestment(\n', '  address indexed customerAddress,\n', '  uint256 mmReinvested,\n', '  uint256 tokensMinted\n', ' );\n', '\n', ' event onWithdraw(\n', '  address indexed customerAddress,\n', '  uint256 mmWithdrawn\n', ' );\n', '\n', ' event Transfer(\n', '  address indexed from,\n', '  address indexed to,\n', '  uint256 tokens\n', ' );\n', '\n', ' string public name = "Million Vault";\n', ' string public symbol = "MV";\n', ' uint8 constant public decimals = 18;\n', ' uint256 internal entryFee_ = 10;\n', ' uint256 internal transferFee_ = 1;\n', ' uint256 internal exitFee_ = 10;\n', ' uint256 internal referralFee_ = 20;\n', ' uint256 constant internal magnitude = 2 ** 64;\n', ' mapping(address => uint256) internal tokenBalanceLedger_;\n', ' mapping(address => uint256) internal referralBalance_;\n', ' mapping(address => int256) internal payoutsTo_;\n', ' mapping(address => uint256) internal invested_;\n', ' mapping(address => bool) internal minted;\n', ' uint256 internal tokenSupply_;\n', ' uint256 internal profitPerShare_;\n', ' uint256 public stakingRequirement = 0;\n', ' uint256 public totalHolder = 0;\n', ' uint256 public totalDonation = 0;\n', ' TOKEN erc20;\n', ' InventoryV2 item;\n', '\n', ' constructor() public {\n', '  erc20 = TOKEN(address(0x6B4c7A5e3f0B99FCD83e9c089BDDD6c7FCe5c611));\n', '  item = InventoryV2(address(0x9680223F7069203E361f55fEFC89B7c1A952CDcc));\n', ' }\n', '\n', ' function checkAndTransferMM(uint256 _amount) private {\n', '  require(erc20.transferFrom(msg.sender, address(this), _amount) == true, "transfer must succeed");\n', ' }\n', '\n', ' function distribute(uint256 _amount) public returns(uint256) {\n', '  require(_amount > 0, "must be a positive value");\n', '  checkAndTransferMM(_amount);\n', '  totalDonation += _amount;\n', '  profitPerShare_ = SafeMath.add(profitPerShare_, (_amount * magnitude) / tokenSupply_);\n', '  emit onDistribute(msg.sender, _amount);\n', ' }\n', '\n', ' function buy(uint256 _amount, address _referredBy) public returns(uint256) {\n', '  checkAndTransferMM(_amount);\n', '  return purchaseTokens(_referredBy, msg.sender, _amount);\n', ' }\n', '\n', ' function buyFor(uint256 _amount, address _customerAddress, address _referredBy) public returns(uint256) {\n', '  checkAndTransferMM(_amount);\n', '  return purchaseTokens(_referredBy, _customerAddress, _amount);\n', ' }\n', '\n', ' function() payable public {\n', '  revert();\n', ' }\n', '\n', ' function reinvest() onlyDivis public {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _dividends = myDividends(false);\n', '  payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '  _dividends += referralBalance_[_customerAddress];\n', '  referralBalance_[_customerAddress] = 0;\n', '  uint256 _tokens = purchaseTokens(0x0, _customerAddress, _dividends);\n', '  emit onReinvestment(_customerAddress, _dividends, _tokens);\n', ' }\n', '\n', ' function exit() external {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n', '  if (_tokens > 0) sell(_tokens);\n', '  withdraw();\n', ' }\n', '\n', ' function withdraw() onlyDivis public {\n', '  address _customerAddress = msg.sender;\n', '  uint256 _dividends = myDividends(false);\n', '  payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\n', '  _dividends += referralBalance_[_customerAddress];\n', '  referralBalance_[_customerAddress] = 0;\n', '  erc20.transfer(_customerAddress, _dividends);\n', '  emit onWithdraw(_customerAddress, _dividends);\n', ' }\n', '\n', ' function sell(uint256 _amountOfTokens) onlyTokenHolders public {\n', '  address _customerAddress = msg.sender;\n', '  require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_amountOfTokens, exitFee_), 100);\n', '  uint256 _taxedMM = SafeMath.sub(_amountOfTokens, _dividends);\n', '\n', '  tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '  int256 _updatedPayouts = (int256)(profitPerShare_ * _amountOfTokens + (_taxedMM * magnitude));\n', '  payoutsTo_[_customerAddress] -= _updatedPayouts;\n', '\n', '  if (tokenSupply_ > 0) {\n', '   profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '  }\n', '\n', '  emit Transfer(_customerAddress, address(0), _amountOfTokens);\n', '  emit onTokenSell(_customerAddress, _amountOfTokens, _taxedMM, now);\n', ' }\n', '\n', ' function transfer(address _toAddress, uint256 _amountOfTokens) onlyTokenHolders external returns(bool) {\n', '  address _customerAddress = msg.sender;\n', '  require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n', '\n', '  if (myDividends(true) > 0) {\n', '   withdraw();\n', '  }\n', '\n', '  uint256 _tokenFee = SafeMath.div(SafeMath.mul(_amountOfTokens, transferFee_), 100);\n', '  uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n', '  uint256 _dividends = _tokenFee;\n', '\n', '  tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n', '\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '  tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n', '\n', '  payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfTokens);\n', '  payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _taxedTokens);\n', '\n', '  profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n', '\n', '  emit Transfer(_customerAddress, _toAddress, _taxedTokens);\n', '\n', '  return true;\n', ' }\n', '\n', ' function setName(string _name) onlyOwner public {\n', '  name = _name;\n', ' }\n', '\n', ' function setSymbol(string _symbol) onlyOwner public {\n', '  symbol = _symbol;\n', ' }\n', '\n', ' function totalMMBalance() public view returns(uint256) {\n', '  return erc20.balanceOf(address(this));\n', ' }\n', '\n', ' function totalSupply() public view returns(uint256) {\n', '  return tokenSupply_;\n', ' }\n', '\n', ' function myTokens() public view returns(uint256) {\n', '  address _customerAddress = msg.sender;\n', '  return balanceOf(_customerAddress);\n', ' }\n', '\n', ' function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n', '  address _customerAddress = msg.sender;\n', '  return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\n', ' }\n', '\n', ' function balanceOf(address _customerAddress) public view returns(uint256) {\n', '  return tokenBalanceLedger_[_customerAddress];\n', ' }\n', '\n', ' function dividendsOf(address _customerAddress) public view returns(uint256) {\n', '  return (uint256)((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n', ' }\n', '\n', ' function sellPrice() public view returns(uint256) {\n', '  uint256 _mm = 1e18;\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_mm, exitFee_), 100);\n', '  uint256 _taxedMM = SafeMath.sub(_mm, _dividends);\n', '\n', '  return _taxedMM;\n', ' }\n', '\n', ' function buyPrice() public view returns(uint256) {\n', '  uint256 _mm = 1e18;\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_mm, entryFee_), 100);\n', '  uint256 _taxedMM = SafeMath.add(_mm, _dividends);\n', '\n', '  return _taxedMM;\n', ' }\n', '\n', ' function calculateTokensReceived(uint256 _mmToSpend) public view returns(uint256) {\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_mmToSpend, entryFee_), 100);\n', '  uint256 _amountOfTokens = SafeMath.sub(_mmToSpend, _dividends);\n', '\n', '  return _amountOfTokens;\n', ' }\n', '\n', ' function calculateMMReceived(uint256 _tokensToSell) public view returns(uint256) {\n', '  require(_tokensToSell <= tokenSupply_);\n', '  uint256 _dividends = SafeMath.div(SafeMath.mul(_tokensToSell, exitFee_), 100);\n', '  uint256 _taxedMM = SafeMath.sub(_tokensToSell, _dividends);\n', '\n', '  return _taxedMM;\n', ' }\n', '\n', ' function getInvested() public view returns(uint256) {\n', '  return invested_[msg.sender];\n', ' }\n', '\n', ' function purchaseTokens(address _referredBy, address _customerAddress, uint256 _incomingMM) internal returns(uint256) {\n', '  if (getInvested() == 0) {\n', '   totalHolder++;\n', '  }\n', '\n', '  invested_[msg.sender] += _incomingMM;\n', '\n', '  uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingMM, entryFee_), 100);\n', '\n', '  uint256 _referralBonus = SafeMath.div(SafeMath.mul(_undividedDividends, referralFee_), 100);\n', '\n', '  uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n', '  uint256 _amountOfTokens = SafeMath.sub(_incomingMM, _undividedDividends);\n', '  uint256 _fee = _dividends * magnitude;\n', '\n', '  require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\n', '\n', '  if (_referredBy != address(0) && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement) {\n', '   referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n', '  } else {\n', '   _dividends = SafeMath.add(_dividends, _referralBonus);\n', '   _fee = _dividends * magnitude;\n', '  }\n', '\n', '  if (tokenSupply_ > 0) {\n', '   tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n', '   profitPerShare_ += (_dividends * magnitude / tokenSupply_);\n', '   _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / tokenSupply_)));\n', '  } else {\n', '   tokenSupply_ = _amountOfTokens;\n', '  }\n', '\n', '  tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n', '\n', '  int256 _updatedPayouts = (int256)(profitPerShare_ * _amountOfTokens - _fee);\n', '  payoutsTo_[_customerAddress] += _updatedPayouts;\n', '  \n', '  if(!minted[msg.sender]) {\n', '      minted[msg.sender] = true;\n', '      item.createFromTemplate(39,0,0,0,0,0);\n', '  }\n', '\n', '  emit Transfer(address(0), msg.sender, _amountOfTokens);\n', '  emit onTokenPurchase(_customerAddress, _incomingMM, _amountOfTokens, _referredBy, now);\n', '\n', '  return _amountOfTokens;\n', ' }\n', '\n', ' function multiData()\n', ' public\n', ' view\n', ' returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\n', '  return (\n', '\n', '   // [0] Total MM in contract \n', '   totalMMBalance(),\n', '\n', '   // [1] Total MV supply\n', '   totalSupply(),\n', '\n', '   // [2] User MV balance \n', '   balanceOf(msg.sender),\n', '\n', '   // [3] User MM balance\n', '   erc20.balanceOf(msg.sender),\n', '\n', '   // [4] User divs \n', '   dividendsOf(msg.sender),\n', '\n', '   // [5] Buy price \n', '   buyPrice(),\n', '\n', '   // [6] Sell price \n', '   sellPrice()\n', '\n', '  );\n', ' }\n', '}\n', '\n', 'library SafeMath {\n', '\n', ' function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '  if (a == 0) {\n', '   return 0;\n', '  }\n', '  c = a * b;\n', '  assert(c / a == b);\n', '  return c;\n', ' }\n', '\n', ' function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '  return a / b;\n', ' }\n', '\n', ' function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '  assert(b <= a);\n', '  return a - b;\n', ' }\n', '\n', ' function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '  c = a + b;\n', '  assert(c >= a);\n', '  return c;\n', ' }\n', '\n', '}']