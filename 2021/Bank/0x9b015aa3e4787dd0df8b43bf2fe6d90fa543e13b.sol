['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-04\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '/// UNIV2LPOracle.sol\n', '\n', '// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', '///////////////////////////////////////////////////////\n', '//                                                   //\n', '//    Methodology for Calculating LP Token Price     //\n', '//                                                   //\n', '///////////////////////////////////////////////////////\n', '\n', '// INVARIANT k = reserve0 [num token0] * reserve1 [num token1]\n', '//\n', '// k = r_x * r_y\n', '// r_y = k / r_x\n', '//\n', '// 50-50 pools try to stay balanced in dollar terms\n', '// r_x * p_x = r_y * p_y    // Proportion of r_x and r_y can be manipulated so need to normalize them\n', '//\n', '// r_x * p_x = p_y * (k / r_x)\n', '// r_x^2 = k * p_y / p_x\n', '// r_x = sqrt(k * p_y / p_x) & r_y = sqrt(k * p_x / p_y)\n', '//\n', "// Now that we've calculated normalized values of r_x and r_y that are not prone to manipulation by an attacker,\n", '// we can calculate the price of an lp token using the following formula.\n', '//\n', '// p_lp = (r_x * p_x + r_y * p_y) / supply_lp\n', '//\n', 'pragma solidity ^0.6.11;\n', '\n', 'interface ERC20Like {\n', '    function decimals()         external view returns (uint8);\n', '    function balanceOf(address) external view returns (uint256);\n', '    function totalSupply()      external view returns (uint256);\n', '}\n', '\n', 'interface UniswapV2PairLike {\n', '    function sync()        external;\n', '    function token0()      external view returns (address);\n', '    function token1()      external view returns (address);\n', '    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\n', '}\n', '\n', 'interface OracleLike {\n', '    function read() external view returns (uint256);\n', '    function peek() external view returns (uint256,bool);\n', '}\n', '\n', '// Factory for creating Uniswap V2 LP Token Oracle instances\n', 'contract UNIV2LPOracleFactory {\n', '\n', '    mapping(address => bool) public isOracle;\n', '\n', '    event Created(address sender, address orcl, bytes32 wat, address tok0, address tok1, address orb0, address orb1);\n', '\n', '    // Create new Uniswap V2 LP Token Oracle instance\n', '    function build(address _src, bytes32 _wat, address _orb0, address _orb1) public returns (address orcl) {\n', '        address tok0 = UniswapV2PairLike(_src).token0();\n', '        address tok1 = UniswapV2PairLike(_src).token1();\n', '        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\n', '        UNIV2LPOracle(orcl).rely(msg.sender);\n', '        isOracle[orcl] = true;\n', '        emit Created(msg.sender, orcl, _wat, tok0, tok1, _orb0, _orb1);\n', '    }\n', '}\n', '\n', 'contract UNIV2LPOracle {\n', '\n', '    // --- Auth ---\n', '    mapping (address => uint) public wards;                                       // Addresses with admin authority\n', '    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }  // Add admin\n', '    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }  // Remove admin\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "UNIV2LPOracle/not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Stop ---\n', '    uint256 public stopped;  // Stop/start ability to read\n', '    modifier stoppable { require(stopped == 0, "UNIV2LPOracle/is-stopped"); _; }\n', '\n', '    // --- Whitelisting ---\n', '    mapping (address => uint256) public bud;\n', '    modifier toll { require(bud[msg.sender] == 1, "UNIV2LPOracle/contract-not-whitelisted"); _; }\n', '\n', '    // --- Data ---\n', '    uint8   public immutable dec0;  // Decimals of token0\n', '    uint8   public immutable dec1;  // Decimals of token1\n', '    address public           orb0;  // Oracle for token0, ideally a Medianizer\n', '    address public           orb1;  // Oracle for token1, ideally a Medianizer\n', '    bytes32 public immutable wat;   // Token whose price is being tracked\n', '\n', '    uint32  public hop = 1 hours;   // Minimum time inbetween price updates\n', '    address public src;             // Price source\n', '    uint32  public zzz;             // Time of last price update\n', '\n', '    struct Feed {\n', '        uint128 val;  // Price\n', '        uint128 has;  // Is price valid\n', '    }\n', '\n', '    Feed    public cur;  // Current price\n', '    Feed    public nxt;  // Queued price\n', '\n', '    // --- Math ---\n', '    uint256 constant WAD = 10 ** 18;\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0 && (z = x / y) * y == x, "ds-math-divide-by-zero");\n', '    }\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    // Compute the square root using the Babylonian method.\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '\n', '    // --- Events ---\n', '    event Rely(address indexed usr);\n', '    event Deny(address indexed usr);\n', '    event Change(address indexed src);\n', '    event Step(uint256 hop);\n', '    event Stop();\n', '    event Start();\n', '    event Value(uint128 curVal, uint128 nxtVal);\n', '    event Link(uint256 id, address orb);\n', '\n', '    // --- Init ---\n', '    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\n', '        require(_src  != address(0),                        "UNIV2LPOracle/invalid-src-address");\n', '        require(_orb0 != address(0) && _orb1 != address(0), "UNIV2LPOracle/invalid-oracle-address");\n', '        wards[msg.sender] = 1;\n', '        src  = _src;\n', '        zzz  = 0;\n', '        wat  = _wat;\n', '        dec0 = uint8(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());  // Get decimals of token0\n', '        dec1 = uint8(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());  // Get decimals of token1\n', '        orb0 = _orb0;\n', '        orb1 = _orb1;\n', '    }\n', '\n', '    function stop() external auth {\n', '        stopped = 1;\n', '        emit Stop();\n', '    }\n', '\n', '    function start() external auth {\n', '        stopped = 0;\n', '        emit Start();\n', '    }\n', '\n', '    function change(address _src) external auth {\n', '        src = _src;\n', '        emit Change(src);\n', '    }\n', '\n', '    function step(uint256 _hop) external auth {\n', '        require(_hop <= uint32(-1), "UNIV2LPOracle/invalid-hop");\n', '        hop = uint32(_hop);\n', '        emit Step(hop);\n', '    }\n', '\n', '    function link(uint256 id, address orb) external auth {\n', '        require(orb != address(0), "UNIV2LPOracle/no-contract-0");\n', '        if(id == 0) {\n', '            orb0 = orb;\n', '        } else if (id == 1) {\n', '            orb1 = orb;\n', '        }\n', '        emit Link(id, orb);\n', '    }\n', '\n', '    function pass() public view returns (bool ok) {\n', '        return block.timestamp >= add(zzz, hop);\n', '    }\n', '\n', '    function seek() internal returns (uint128 quote, uint32 ts) {\n', '        // Sync up reserves of uniswap liquidity pool\n', '        UniswapV2PairLike(src).sync();\n', '\n', '        // Get reserves of uniswap liquidity pool\n', '        (uint112 res0, uint112 res1, uint32 _ts) = UniswapV2PairLike(src).getReserves();\n', '        require(res0 > 0 && res1 > 0, "UNIV2LPOracle/invalid-reserves");\n', '        ts = _ts;\n', '        require(ts == block.timestamp);\n', '\n', '        // Adjust reserves w/ respect to decimals\n', '        if (dec0 != uint8(18)) res0 = uint112(res0 * 10 ** sub(18, dec0));\n', '        if (dec1 != uint8(18)) res1 = uint112(res1 * 10 ** sub(18, dec1));\n', '\n', '        // Calculate constant product invariant k (WAD * WAD)\n', '        uint256 k = mul(res0, res1);\n', '\n', '        // All Oracle prices are priced with 18 decimals against USD\n', '        uint256 val0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\n', '        uint256 val1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\n', '        require(val0 != 0, "UNIV2LPOracle/invalid-oracle-0-price");\n', '        require(val1 != 0, "UNIV2LPOracle/invalid-oracle-1-price");\n', '\n', '        // Calculate normalized balances of token0 and token1\n', '        uint256 bal0 =\n', '            sqrt(\n', '                wmul(\n', '                    k,\n', '                    wdiv(\n', '                        val1,\n', '                        val0\n', '                    )\n', '                )\n', '            );\n', '        uint256 bal1 = wdiv(k, bal0) / WAD;\n', '\n', '        // Get LP token supply\n', '        uint256 supply = ERC20Like(src).totalSupply();\n', '        require(supply > 0, "UNIV2LPOracle/invalid-lp-token-supply");\n', '\n', '        // Calculate price quote of LP token\n', '        quote = uint128(\n', '            wdiv(\n', '                add(\n', '                    wmul(bal0, val0),  // (WAD)\n', '                    wmul(bal1, val1)   // (WAD)\n', '                ),\n', '                supply  // (WAD)\n', '            )\n', '        );\n', '    }\n', '\n', '    function poke() external stoppable {\n', '        require(pass(), "UNIV2LPOracle/not-passed");\n', '        (uint val, uint32 ts) = seek();\n', '        require(val != 0, "UNIV2LPOracle/invalid-price");\n', '        cur = nxt;\n', '        nxt = Feed(uint128(val), 1);\n', '        zzz = ts;\n', '        emit Value(cur.val, nxt.val);\n', '    }\n', '\n', '    function peek() external view toll returns (bytes32,bool) {\n', '        return (bytes32(uint(cur.val)), cur.has == 1);\n', '    }\n', '\n', '    function peep() external view toll returns (bytes32,bool) {\n', '        return (bytes32(uint(nxt.val)), nxt.has == 1);\n', '    }\n', '\n', '    function read() external view toll returns (bytes32) {\n', '        require(cur.has == 1, "UNIV2LPOracle/no-current-value");\n', '        return (bytes32(uint(cur.val)));\n', '    }\n', '\n', '    function kiss(address a) external auth {\n', '        require(a != address(0), "UNIV2LPOracle/no-contract-0");\n', '        bud[a] = 1;\n', '    }\n', '\n', '    function kiss(address[] calldata a) external auth {\n', '        for(uint i = 0; i < a.length; i++) {\n', '            require(a[i] != address(0), "UNIV2LPOracle/no-contract-0");\n', '            bud[a[i]] = 1;\n', '        }\n', '    }\n', '\n', '    function diss(address a) external auth {\n', '        bud[a] = 0;\n', '    }\n', '\n', '    function diss(address[] calldata a) external auth {\n', '        for(uint i = 0; i < a.length; i++) {\n', '            bud[a[i]] = 0;\n', '        }\n', '    }\n', '}']