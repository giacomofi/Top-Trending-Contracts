['//SPDX-License-Identifier: GPL-3.0 License\n', 'pragma solidity >=0.7.0 <0.8.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./ReentrancyGuard.sol";\n', '\n', 'interface IERC721 {\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '}\n', '\n', 'interface IERC1155 {\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '}\n', '\n', 'contract Popswap is ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    event TradeOpened(\n', '        uint256 indexed tradeId,\n', '        address indexed tradeOpener\n', '    );\n', '\n', '    event TradeCancelled(\n', '        uint256 indexed tradeId,\n', '        address indexed tradeCloser\n', '    );\n', '\n', '    event TradeExecuted(\n', '        uint256 indexed tradeId,\n', '        address indexed tradeOpener,\n', '        address indexed tradeCloser\n', '    );\n', '\n', '    struct Trade {\n', '        uint256 tradeId;\n', '        address openingTokenAddress;\n', '        uint256 openingTokenId;\n', '        address closingTokenAddress;\n', '        uint256 closingTokenId;\n', '        uint256 expiryDate;\n', '        uint256 successDate;\n', '        address tradeOpener;\n', '        address tradeCloser;\n', '        bool active;\n', '    }\n', '\n', '    Trade[] public trades;\n', '\n', '    mapping (uint256 => address) private _tradeIdToTradeCloser;\n', '  \n', '    address private _devFund;\n', '\n', '    constructor(address devFund_) {\n', '        _devFund = devFund_;\n', '    }\n', '\n', '    function devFund() public view virtual returns (address) {\n', '        return _devFund;\n', '    }\n', '\n', '    function openNewTrade(\n', '        address _openingTokenAddress,\n', '        uint256 _openingTokenId,\n', '        address _closingTokenAddress,\n', '        uint256 _closingTokenId,\n', '        uint256 _expiryDate\n', '    ) public nonReentrant returns (uint256) {\n', '        require(\n', '            _expiryDate > block.timestamp,\n', '            "Popswap::openNewTrade: _expiryDate must be after current block.timestamp"\n', '        );\n', '        uint256 tradeId = trades.length;\n', '        trades.push(Trade(\n', '            tradeId,\n', '            _openingTokenAddress,\n', '            _openingTokenId,\n', '            _closingTokenAddress,\n', '            _closingTokenId,\n', '            _expiryDate,\n', '            0,\n', '            msg.sender,\n', '            0x0000000000000000000000000000000000000000,\n', '            true\n', '        ));\n', '        emit TradeOpened(tradeId, msg.sender);\n', '        return tradeId;\n', '    }\n', '\n', '    function getTradeByTradeId(uint256 _tradeId) public view returns(\n', '        uint256,\n', '        address,\n', '        uint256,\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        address,\n', '        address,\n', '        bool\n', '    ) {\n', '        Trade memory trade = trades[_tradeId];\n', '        return(\n', '            trade.tradeId,\n', '            trade.openingTokenAddress,\n', '            trade.openingTokenId,\n', '            trade.closingTokenAddress,\n', '            trade.closingTokenId,\n', '            trade.expiryDate,\n', '            trade.successDate,\n', '            trade.tradeOpener,\n', '            trade.tradeCloser,\n', '            trade.active\n', '        );\n', '    }\n', '\n', '    function getTradeCount() public view returns(uint256) {\n', '        return trades.length;\n', '    }\n', '\n', '    function cancelTrade(\n', '        uint256 _tradeId\n', '    ) public {\n', '        Trade memory trade = trades[_tradeId];\n', '        require(\n', '            trade.tradeOpener == msg.sender,\n', '            "Popswap::cancelTrade: _tradeId must be trade created by msg.sender"\n', '        );\n', '        require(\n', '            trade.tradeCloser == 0x0000000000000000000000000000000000000000,\n', '            "Popswap::cancelTrade: _tradeCloser can\'t already be non-zero address"\n', '        );\n', '        require(\n', '            trade.expiryDate > block.timestamp,\n', '            "Popswap::cancelTrade: trade.expiryDate must be after current block.timestamp"\n', '        );\n', '        trades[_tradeId] = Trade(\n', '            trade.tradeId,\n', '            trade.openingTokenAddress,\n', '            trade.openingTokenId,\n', '            trade.closingTokenAddress,\n', '            trade.closingTokenId,\n', '            trade.expiryDate,\n', '            trade.successDate,\n', '            trade.tradeOpener,\n', '            msg.sender,\n', '            false\n', '        );\n', '        _tradeIdToTradeCloser[_tradeId] = msg.sender;\n', '        emit TradeCancelled(trade.tradeId, msg.sender);\n', '    }\n', '\n', '    function isTradeExecutable(uint256 _tradeId, uint8 _openingTokenType, uint8 _closingTokenType) public view returns (bool) {\n', '        require(\n', '            _openingTokenType <= 1,\n', '            "Popswap::isTradeExecutable: _openingTokenType must be either 0 or 1"\n', '        );\n', '        require(\n', '            _closingTokenType <= 1,\n', '            "Popswap::isTradeExecutable: _closingTokenType must be either 0 or 1"\n', '        );\n', '        Trade memory trade = trades[_tradeId];\n', '        if(trade.expiryDate < block.timestamp) {\n', '            return false;\n', '        }\n', '        if(trade.active != true) {\n', '            return false;\n', '        }\n', '        if(_openingTokenType == 0) {\n', '            IERC721 openingToken = IERC721(trade.openingTokenAddress);\n', '            if(openingToken.isApprovedForAll(trade.tradeOpener, address(this)) != true) {\n', '                return false;\n', '            }\n', '            if(openingToken.ownerOf(trade.openingTokenId) != trade.tradeOpener) {\n', '                return false;\n', '            }\n', '        }else if(_openingTokenType == 1) {\n', '            IERC1155 openingToken = IERC1155(trade.openingTokenAddress);\n', '            if(openingToken.isApprovedForAll(trade.tradeOpener, address(this)) != true) {\n', '                return false;\n', '            }\n', '            if(openingToken.balanceOf(trade.tradeOpener, trade.openingTokenId) < 1) {\n', '                return false;\n', '            }\n', '        }\n', '        if(_closingTokenType == 0) {\n', '            IERC721 closingToken = IERC721(trade.closingTokenAddress);\n', '            if(closingToken.isApprovedForAll(msg.sender, address(this)) != true) {\n', '                return false;\n', '            }\n', '            if(closingToken.ownerOf(trade.closingTokenId) != msg.sender) {\n', '                return false;\n', '            }\n', '        }else if(_closingTokenType == 1) {\n', '            IERC1155 closingToken = IERC1155(trade.closingTokenAddress);\n', '            if(closingToken.isApprovedForAll(msg.sender, address(this)) != true) {\n', '                return false;\n', '            }\n', '            if(closingToken.balanceOf(msg.sender, trade.closingTokenId) < 1) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function executeTrade(uint256 _tradeId, uint8 _openingTokenType, uint8 _closingTokenType) public nonReentrant returns (uint256) {\n', '        require(\n', '            _openingTokenType <= 1,\n', '            "Popswap::executeTrade: _openingTokenType must be either 0 or 1"\n', '        );\n', '        require(\n', '            _closingTokenType <= 1,\n', '            "Popswap::executeTrade: _closingTokenType must be either 0 or 1"\n', '        );\n', '        Trade memory trade = trades[_tradeId];\n', '        require(\n', '            trade.active == true,\n', '            "Popswap::executeTrade: trade is no longer active"\n', '        );\n', '        require(\n', '            trade.expiryDate > block.timestamp,\n', '            "Popswap::executeTrade: trade has expired"\n', '        );\n', '        if(_openingTokenType == 0) {\n', '            IERC721 openingToken = IERC721(trade.openingTokenAddress);\n', '            openingToken.safeTransferFrom(trade.tradeOpener, msg.sender, trade.openingTokenId);\n', '        }else if(_openingTokenType == 1) {\n', '            IERC1155 openingToken = IERC1155(trade.openingTokenAddress);\n', '            openingToken.safeTransferFrom(trade.tradeOpener, msg.sender, trade.openingTokenId, 1, "0000000000000000000000000000000000000000000000000000000000000000");\n', '        }\n', '        if(_closingTokenType == 0) {\n', '            IERC721 closingToken = IERC721(trade.closingTokenAddress);\n', '            closingToken.safeTransferFrom(msg.sender, trade.tradeOpener, trade.closingTokenId);\n', '        }else if(_closingTokenType == 1) {\n', '            IERC1155 closingToken = IERC1155(trade.closingTokenAddress);\n', '            closingToken.safeTransferFrom(msg.sender, trade.tradeOpener, trade.closingTokenId, 1, "0000000000000000000000000000000000000000000000000000000000000000");\n', '        }\n', '        trades[_tradeId] = Trade(\n', '            trade.tradeId,\n', '            trade.openingTokenAddress,\n', '            trade.openingTokenId,\n', '            trade.closingTokenAddress,\n', '            trade.closingTokenId,\n', '            trade.expiryDate,\n', '            block.timestamp,\n', '            trade.tradeOpener,\n', '            msg.sender,\n', '            false\n', '        );\n', '        _tradeIdToTradeCloser[_tradeId] = msg.sender;\n', '        emit TradeExecuted(trade.tradeId, trade.tradeOpener, msg.sender);\n', '        return trade.tradeId;\n', '    }\n', '}']