['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-02\n', '*/\n', '\n', '// File: USAToken-imports.sol\n', '\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'interface IERC20Metadata is IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '}\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {return msg.sender;}\n', '    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\n', '}\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked { require(b <= a, errorMessage); return a - b; }\n', '    }\n', '}\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0;}\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");(bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, "Address: low-level call failed");}\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, "Address: low-level call with value failed");}\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) { return returndata; } else {\n', '            if (returndata.length > 0) {\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {revert(errorMessage);}\n', '        }\n', '    }\n', '}\n', 'abstract contract Manageable is Context {\n', '    address private _manager;\n', '    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n', '    constructor(){\n', '        address msgSender = _msgSender();\n', '        _manager = msgSender;\n', '        emit ManagementTransferred(address(0), msgSender);\n', '    }\n', '    function manager() public view returns(address){ return _manager; }\n', '    modifier onlyManager(){\n', '        require(_manager == _msgSender(), "Manageable: caller is not the manager");\n', '        _;\n', '    }\n', '    function transferManagement(address newManager) external virtual onlyManager {\n', '        emit ManagementTransferred(_manager, newManager);\n', '        _manager = newManager;\n', '    }\n', '}\n', 'contract Initializable {\n', '  bool private initialized;\n', '  bool private initializing;\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '    _;\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '  function isConstructor() private view returns (bool) {\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '  uint256[50] private ______gap;\n', '}\n', 'abstract contract ProxyOwnable is Context, Initializable {\n', '    address private _owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    function ownerInitialize() public initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '// File: USAToken.sol\n', '\n', '/**\n', ' * SPDX-License-Identifier: MIT\n', ' */\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * Tokenomics:\n', ' * \n', ' * Redistribution   1.776%%\n', ' * Burn             0 or 1.776%\n', ' * Charity          to be voted on\n', '\n', ' */\n', '\n', '\n', 'abstract contract Tokenomics {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    // --------------------- Token Settings ------------------- //\n', '\n', '    string internal constant NAME = "USA Coin";\n', '    string internal constant SYMBOL = "USA";\n', '    \n', '    uint32 internal constant FEES_DIVISOR = 10**5; //100000\n', '    uint8 internal constant DECIMALS = 13; //USA\n', '    \n', '    uint256 internal constant MAX = ~uint256(0);\n', '    uint256 internal constant TOTAL_SUPPLY = 1776 * 10**DECIMALS * 10**9;\n', '    uint256 internal _reflectedSupply; \n', '\n', '   \n', '    // --------------------- Fees Settings ------------------- //\n', '\n', '    address internal charityAddress;\n', '\n', '    address internal burnAddress;\n', '\n', '    enum FeeType { Burn, Rfi, External }\n', '    struct Fee {\n', '        FeeType name;\n', '        uint256 value;\n', '        address recipient;\n', '        uint256 total;\n', '    }\n', '\n', '    Fee[] internal fees;\n', '    uint256 internal sumOfFees;\n', '\n', '\n', '    function _addFee(FeeType name, uint256 value, address recipient) private {\n', '        fees.push( Fee(name, value, recipient, 0 ) );\n', '        sumOfFees += value;\n', '    }\n', '\n', '    function _addFees() internal {\n', '\n', '        /**\n', '         * The value of fees is given in part per 100000 (based on the value of FEES_DIVISOR),\n', '         * e.g. for 5% use 5000, for 3.5% use 3500, etc. \n', '         */ \n', '        _addFee(FeeType.Rfi, 1776, address(this) ); \n', '\n', '        //_addFee(FeeType.Burn, 1776, burnAddress );\n', '        //_addFee(FeeType.External, 1776, charityAddress );\n', '        //_addFee(FeeType.External, 30, marketingAddress );\n', '    }\n', '\n', '    function _getFeesCount() internal view returns (uint256){ return fees.length; }\n', '\n', '    function _getFeeStruct(uint256 index) private view returns(Fee storage){\n', '        require( index >= 0 && index < fees.length, "FeesSettings._getFeeStruct: Fee index out of bounds");\n', '        return fees[index];\n', '    }\n', '    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\n', '        Fee memory fee = _getFeeStruct(index);\n', '        return ( fee.name, fee.value, fee.recipient, fee.total );\n', '    }\n', '    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\n', '        Fee storage fee = _getFeeStruct(index);\n', '        fee.total = fee.total.add(amount);\n', '    }\n', '\n', '    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\n', '        Fee memory fee = _getFeeStruct(index);\n', '        return fee.total;\n', '    }\n', '}\n', '\n', 'abstract contract BaseRfiToken is IERC20, IERC20Metadata, ProxyOwnable, Tokenomics { \n', '\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) internal _reflectedBalances;\n', '    mapping (address => uint256) internal _balances;\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '    \n', '    mapping (address => bool) internal _isExcludedFromFee;\n', '    mapping (address => bool) internal _isExcludedFromRewards;\n', '    address[] private _excluded;\n', ' \n', '    /** Functions required by IERC20Metadat **/\n', '        function name() external pure override returns (string memory) { return NAME; }\n', '        function symbol() external pure override returns (string memory) { return SYMBOL; }\n', '        function decimals() external pure override returns (uint8) { return DECIMALS; }\n', '        \n', '    /** Functions required by IERC20Metadat - END **/\n', '    /** Functions required by IERC20 **/\n', '        function totalSupply() external pure override returns (uint256) {\n', '            return TOTAL_SUPPLY;\n', '        }\n', '        \n', '        function balanceOf(address account) public view override returns (uint256){\n', '            if (_isExcludedFromRewards[account]) return _balances[account];\n', '            return tokenFromReflection(_reflectedBalances[account]);\n', '        }\n', '        \n', '        function transfer(address recipient, uint256 amount) external override returns (bool){\n', '            _transfer(_msgSender(), recipient, amount);\n', '            return true;\n', '        }\n', '        \n', '        function allowance(address owner, address spender) external view override returns (uint256){\n', '            return _allowances[owner][spender];\n', '        }\n', '    \n', '        function approve(address spender, uint256 amount) external override returns (bool) {\n', '            _approve(_msgSender(), spender, amount);\n', '            return true;\n', '        }\n', '        \n', '        function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\n', '            _transfer(sender, recipient, amount);\n', '            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '            return true;\n', '        }\n', '    /** Functions required by IERC20 - END **/\n', '\n', '    /**\n', '     * @dev this is really a "soft" burn (total supply is not reduced). RFI holders\n', '     * get two benefits from burning tokens:\n', '     *\n', '     * 1) Tokens in the burn address increase the % of tokens held by holders not\n', '     *    excluded from rewards (assuming the burn address is excluded)\n', '     * 2) Tokens in the burn address cannot be sold \n', '     */\n', '    function burn(uint256 amount) external {\n', '\n', '        address sender = _msgSender();\n', '        require(sender != address(0), "BaseRfiToken: burn from the zero address");\n', '        require(sender != address(burnAddress), "BaseRfiToken: burn from the burn address");\n', '\n', '        uint256 balance = balanceOf(sender);\n', '        require(balance >= amount, "BaseRfiToken: burn amount exceeds balance");\n', '\n', '        uint256 reflectedAmount = amount.mul(_getCurrentRate());\n', '\n', "        // remove the amount from the sender's balance first\n", '        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\n', '        if (_isExcludedFromRewards[sender])\n', '            _balances[sender] = _balances[sender].sub(amount);\n', '\n', '        _burnTokens( sender, amount, reflectedAmount );\n', '    }\n', '    \n', '    /**\n', '         Burn.\n', '     */\n', '    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\n', '\n', '        /**\n', '         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\n', '         * tokens to the burn address (which should be excluded from rewards) is sufficient\n', '         * in RFI\n', '         */ \n', '        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\n', '        if (_isExcludedFromRewards[burnAddress])\n', '            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\n', '\n', '        /**\n', '         * @dev Emit the event so that the burn address balance is updated (on ethscan)\n', '         */\n', '        emit Transfer(sender, burnAddress, tBurn);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '    \n', '    function isExcludedFromReward(address account) external view returns (bool) {\n', '        return _isExcludedFromRewards[account];\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates and returns the reflected amount for the given amount with or without \n', '     * the transfer fees (deductTransferFee true/false)\n', '     */\n', '    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\n', '        require(tAmount <= TOTAL_SUPPLY, "Amount must be less than supply");\n', '        if (!deductTransferFee) {\n', '            (uint256 rAmount,,,,) = _getValues(tAmount,0);\n', '            return rAmount;\n', '        } else {\n', '            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees());\n', '            return rTransferAmount;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\n', '     */\n', '    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\n', '        require(rAmount <= _reflectedSupply, "Amount must be less than total reflections");\n', '        uint256 currentRate = _getCurrentRate();\n', '        return rAmount.div(currentRate);\n', '    }\n', '    \n', '    function excludeFromReward(address account) external onlyOwner() {\n', '        require(!_isExcludedFromRewards[account], "Account is not included");\n', '        _exclude(account);\n', '    }\n', '    \n', '    function _exclude(address account) internal {\n', '        if(_reflectedBalances[account] > 0) {\n', '            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\n', '        }\n', '        _isExcludedFromRewards[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '\n', '    function includeInReward(address account) external onlyOwner() {\n', '        require(_isExcludedFromRewards[account], "Account is not excluded");\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _balances[account] = 0;\n', '                _isExcludedFromRewards[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\n', '    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\n', '    \n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "BaseRfiToken: approve from the zero address");\n', '        require(spender != address(0), "BaseRfiToken: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    \n', '    function _transfer(address sender, address recipient, uint256 amount) private {\n', '        require(sender != address(0), "BaseRfiToken: transfer from the zero address");\n', '        require(recipient != address(0), "BaseRfiToken: transfer to the zero address");\n', '        require(sender != address(burnAddress), "BaseRfiToken: transfer from the burn address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        \n', '        // indicates whether or not feee should be deducted from the transfer\n', '        bool takeFee = true;\n', '\n', '        // if any account belongs to _isExcludedFromFee account then remove the fee\n', '        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\n', '\n', '        _transferTokens(sender, recipient, amount, takeFee);\n', '        \n', '    }\n', '\n', '    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\n', '    \n', '        /**\n', "         * We don't need to know anything about the individual fees here \n", '         * All that is required \n', '         * for the transfer is the sum of all fees to calculate the % of the total \n', '         * transaction amount which should be transferred to the recipient. \n', '         *\n', '         * The `_takeFees` call will/should take care of the individual fees\n', '         */\n', '        uint256 sumOfFees = _getSumOfFees();\n', '        if ( !takeFee ){ sumOfFees = 0; }\n', '        \n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\n', '        \n', '        /** \n', "         * Sender's and Recipient's reflected balances must be always updated regardless of\n", '         * whether they are excluded from rewards or not.\n', '         */ \n', '        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\n', '        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\n', '\n', '        /**\n', '         * Update the true/nominal balances for excluded accounts\n', '         */        \n', '        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\n', '        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }\n', '        \n', '        _takeFees( amount, currentRate, sumOfFees );\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    \n', '    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees ) private {\n', '        if ( sumOfFees > 0){\n', '            _takeTransactionFees(amount, currentRate);\n', '        }\n', '    }\n', '    \n', '    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n', '        \n', '        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\n', '        uint256 tTransferAmount = tAmount.sub(tTotalFees);\n', '        uint256 currentRate = _getCurrentRate();\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '        uint256 rTotalFees = tTotalFees.mul(currentRate);\n', '        uint256 rTransferAmount = rAmount.sub(rTotalFees);\n', '        \n', '        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\n', '    }\n', '    \n', '    function _getCurrentRate() internal view returns(uint256) {\n', '        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '        return rSupply.div(tSupply);\n', '    }\n', '    \n', '    function _getCurrentSupply() internal view returns(uint256, uint256) {\n', '        uint256 rSupply = _reflectedSupply;\n', '        uint256 tSupply = TOTAL_SUPPLY;  \n', '\n', '        /**\n', '         * The code below removes balances of addresses excluded from rewards from\n', '         * rSupply and tSupply, which effectively increases the % of transaction fees\n', '         * delivered to non-excluded holders\n', '         */    \n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_reflectedBalances[_excluded[i]] > rSupply || _balances[_excluded[i]] > tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\n', '            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\n', '            tSupply = tSupply.sub(_balances[_excluded[i]]);\n', '        }\n', '        if (tSupply == 0 || rSupply < _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\n', '        return (rSupply, tSupply);\n', '    }\n', '    \n', '    /**\n', '     * @dev Returns the total sum of fees to be processed in each transaction. \n', '     * \n', '     * To separate concerns this contract (class) will take care of ONLY handling RFI, i.e. \n', "     * changing the rates and updating the holder's balance (via `_redistribute`). \n", '     * It is the responsibility of the dev/user to handle all other fees and taxes \n', '     * in the appropriate contracts (classes).\n', '     */ \n', '    function _getSumOfFees() internal view virtual returns (uint256);\n', '\n', ' \n', '    /**\n', '     * @dev Redistributes the specified amount among the current holders via the reflect.finance\n', '     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\n', '     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`. \n', '     * This is the bit of clever math which allows rfi to redistribute the fee without \n', '     * having to iterate through all holders. \n', '     * \n', '     */\n', '    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\n', '        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rFee = tFee.mul(currentRate);\n', '\n', '        _reflectedSupply = _reflectedSupply.sub(rFee);\n', '        _addFeeCollectedAmount(index, tFee);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\n', '     */\n', '    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal virtual;\n', '}\n', '\n', '\n', 'contract USAToken is BaseRfiToken {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '\n', '    function initialize() public initializer {\n', '        ownerInitialize();\n', '\n', '        _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\n', '\n', '        burnAddress = 0x000000000000000000000000000000000000dEaD;\n', '        charityAddress = 0x000000000000000000000000000000000000dEaD;\n', '\n', '        _exclude(burnAddress);\n', '        _addFees();\n', '\n', '        _reflectedBalances[owner()] = _reflectedSupply;\n', '        \n', '        // exclude owner and this contract from fee\n', '        _isExcludedFromFee[owner()] = true;\n', '        _isExcludedFromFee[address(this)] = true;\n', '        \n', '        // exclude the owner and this contract from rewards\n', '        _exclude(owner());\n', '        _exclude(address(this));\n', '\n', '        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\n', '        \n', '    }\n', '\n', '    function _getSumOfFees() internal view override returns (uint256){ \n', '        return sumOfFees;\n', '    }\n', '    \n', '    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal override {\n', '        \n', '        uint256 feesCount = _getFeesCount();\n', '        for (uint256 index = 0; index < feesCount; index++ ){\n', '            (FeeType name, uint256 value, address recipient,) = _getFee(index);\n', '            // no need to check value < 0 as the value is uint (i.e. from 0 to 2^256-1)\n', '            if ( value == 0 ) continue;\n', '\n', '            if ( name == FeeType.Rfi ){\n', '                _redistribute( amount, currentRate, value, index );\n', '            }\n', '            else if ( name == FeeType.Burn ){\n', '                _burn( amount, currentRate, value, index );\n', '            }\n', "            else { //it's FeeType.External\n", '                _takeFee( amount, currentRate, value, recipient, index );\n', '            }\n', '        }\n', '    }\n', '\n', '    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\n', '        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rBurn = tBurn.mul(currentRate);\n', '\n', '        _burnTokens(address(this), tBurn, rBurn);\n', '        _addFeeCollectedAmount(index, tBurn);\n', '    }\n', '\n', '    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\n', '\n', '        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '\n', '        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\n', '        if(_isExcludedFromRewards[recipient])\n', '            _balances[recipient] = _balances[recipient].add(tAmount);\n', '\n', '        _addFeeCollectedAmount(index, tAmount);\n', '    }\n', '    \n', '}']