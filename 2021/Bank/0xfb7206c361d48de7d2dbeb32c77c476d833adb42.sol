['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-25\n', '*/\n', '\n', 'pragma solidity 0.7.3;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract MultiOwnable {\n', '\n', '    mapping (address => bool) public isOwner;\n', '    address[] public ownerHistory;\n', '\n', '    event OwnerAddedEvent(address indexed _newOwner);\n', '    event OwnerRemovedEvent(address indexed _oldOwner);\n', '\n', '    constructor() {\n', '        // Add default owner\n', '        address owner = msg.sender;\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner[msg.sender], "Only owners allowed");\n', '        _;\n', '    }\n', '\n', '    function ownerHistoryCount() public view returns (uint) {\n', '        return ownerHistory.length;\n', '    }\n', '\n', '    /** Add extra owner. */\n', '    function addOwner(address owner) onlyOwner public {\n', '        require(owner != address(0), "Only valid addresses allowed");\n', '        require(!isOwner[owner], "Owner is already added");\n', '        ownerHistory.push(owner);\n', '        isOwner[owner] = true;\n', '        emit OwnerAddedEvent(owner);\n', '    }\n', '\n', '    /** Remove extra owner. */\n', '    function removeOwner(address owner) onlyOwner public {\n', '        require(isOwner[owner], "Owner is not defined");\n', '        isOwner[owner] = false;\n', '        emit OwnerRemovedEvent(owner);\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'abstract contract StandardToken is ERC20 {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint256 public totalSupply;\n', '\n', '    mapping(address => uint256) balances;\n', '\n', '    mapping(address => mapping(address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) public override virtual view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transferInternal(address _from, address _to, uint256 _value) internal {\n', '        require(_to != address(0), "Forbidden to transfer to zero address");\n', '\n', '        trackBalance(_from);\n', '        trackBalance(_to);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '    }\n', '\n', '    function approveInternal(address _owner, address _spender, uint256 _value) internal returns (bool) {\n', '        require(_spender != address(0), "Forbidden to approve zero address");\n', '\n', '        allowed[_owner][_spender] = _value;\n', '        emit Approval(_owner, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public override virtual returns (bool) {\n', '        transferInternal(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Allows allowed third party to transfer tokens from one address to another. Returns success.\n', '    /// @param _from Address from where tokens are withdrawn.\n', '    /// @param _to Address to where tokens are sent.\n', '    /// @param _value Number of tokens to transfer.\n', '    function transferFrom(address _from, address _to, uint256 _value) public override virtual returns (bool) {\n', '        require(_from != address(0), "Forbidden to transfer from zero address");\n', '        require(_to != address(0), "Forbidden to transfer to zero address");\n', '\n', '        trackBalance(_from);\n', '        trackBalance(_to);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '\n', '        emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Sets approved amount of tokens for spender. Returns success.\n', '    /// @param _spender Address of allowed account.\n', '    /// @param _value Number of approved tokens.\n', '    function approve(address _spender, uint256 _value) public override virtual returns (bool) {\n', '        return approveInternal(msg.sender, _spender, _value);\n', '    }\n', '\n', '    /// @dev Returns number of allowed tokens for given address.\n', '    /// @param _owner Address of token owner.\n', '    /// @param _spender Address of token spender.\n', '    function allowance(address _owner, address _spender) public override virtual view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function trackBalance(address account) public virtual;\n', '}\n', '\n', 'contract CommonToken is StandardToken, MultiOwnable {\n', '    using SafeMath for uint;\n', '\n', '    struct Dividend {\n', '        uint256 amount;\n', '        uint256 block;\n', '    }\n', '\n', '    struct UserDividend {\n', '        uint256 lastClaimedDividend;\n', '        uint256 balanceTillDividend;\n', '    }\n', '\n', "    string public constant name   = 'BRKROFX';\n", "    string public constant symbol = 'BRKROFX';\n", '    uint8 public constant decimals = 18;\n', '\n', '    uint256 public saleLimit;   // 30% of tokens for sale (10% presale & 20% public sale).\n', '\n', '    // The main account that holds all tokens at the beginning and during tokensale.\n', '    address public seller; // Seller address (main holder of tokens)\n', '\n', '    address public distributor; // Distributor address\n', '\n', '    uint256 public tokensSold; // (e18) Number of tokens sold through all tiers or tokensales.\n', '    uint256 public totalSales; // Total number of sales (including external sales) made through all tiers or tokensales.\n', '\n', '    // Lock the transfer functions during tokensales to prevent price speculations.\n', '    bool public locked = true;\n', '\n', '    mapping (address => uint256) public nonces;\n', '    bytes32 public immutable PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public immutable DOMAIN_SEPARATOR;\n', '\n', '    mapping (address => bool) public dividendDistributors;\n', '\n', '    Dividend [] public dividends;\n', '    mapping(address => UserDividend) public userDividends;\n', '    mapping(address => mapping(uint256 => uint256)) public balanceByDividends;\n', '\n', '    event SellEvent(address indexed _seller, address indexed _buyer, uint256 _value);\n', '    event ChangeSellerEvent(address indexed _oldSeller, address indexed _newSeller);\n', '    event Burn(address indexed _burner, uint256 _value);\n', '    event Unlock();\n', '    event DividendAdded(uint256 _dividendId, uint256 _value, uint256 _block);\n', '    event DividendClaimed(address _account, uint256 _dividendId, uint256 _value);\n', '\n', '    constructor(\n', '        address _seller\n', '    ) MultiOwnable() {\n', '\n', '        totalSupply = 1_000_000_000 ether;\n', '        saleLimit   = 300_000_000 ether;\n', '\n', '        seller = _seller;\n', '        distributor = msg.sender;\n', '\n', '        uint sellerTokens = totalSupply;\n', '        balances[seller] = sellerTokens;\n', '        emit Transfer(address(0x0), seller, sellerTokens);\n', '\n', '        uint256 chainId;\n', '        assembly {chainId := chainid()}\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '                keccak256(bytes(name)),\n', "                keccak256(bytes('1')),\n", '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    modifier ifUnlocked(address _from) {\n', '        require(!locked, "Allowed only if unlocked");\n', '        _;\n', '    }\n', '\n', '    modifier onlyDistributor() {\n', '        require(msg.sender == distributor, "Allowed only for distributor");\n', '        _;\n', '    }\n', '\n', '    modifier onlyDividendDistributor() {\n', '        require(dividendDistributors[msg.sender], "Allowed only for dividend distributor");\n', '        _;\n', '    }\n', '\n', '    /** Can be called once by super owner. */\n', '    function unlock() onlyOwner public {\n', '        require(locked, "I am locked");\n', '        locked = false;\n', '        emit Unlock();\n', '    }\n', '\n', '    /**\n', '     * An address can become a new seller only in case it has no tokens.\n', '     * This is required to prevent stealing of tokens  from newSeller via\n', '     * 2 calls of this function.\n', '     */\n', '    function changeSeller(address newSeller) onlyOwner public returns (bool) {\n', '        require(newSeller != address(0), "Invalid seller address");\n', '        require(seller != newSeller, "New seller is same");\n', '\n', '        // To prevent stealing of tokens from newSeller via 2 calls of changeSeller:\n', '        require(balances[newSeller] == 0, "New seller balance is not empty");\n', '\n', '        address oldSeller = seller;\n', '        uint256 unsoldTokens = balances[oldSeller];\n', '        balances[oldSeller] = 0;\n', '        balances[newSeller] = unsoldTokens;\n', '        emit Transfer(oldSeller, newSeller, unsoldTokens);\n', '\n', '        seller = newSeller;\n', '        emit ChangeSellerEvent(oldSeller, newSeller);\n', '        return true;\n', '    }\n', '\n', '    function changeDistributor(address newDistributor) onlyOwner public returns (bool) {\n', '        distributor = newDistributor;\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * User-friendly alternative to sell() function.\n', '     */\n', '    function sellNoDecimals(address _to, uint256 _value) public returns (bool) {\n', '        return sell(_to, _value * 1e18);\n', '    }\n', '\n', '    function sell(address _to, uint256 _value) onlyDistributor public returns (bool) {\n', '\n', '        // Check that we are not out of limit and still can sell tokens:\n', '        require(tokensSold.add(_value) <= saleLimit, "Sell exceeds allowed limit");\n', '\n', '        require(_to != address(0), "Can\'t sell to zero address");\n', '        require(_value > 0, "_value is 0");\n', '        require(_value <= balances[seller], "Can\'t sell more tokens then available");\n', '\n', '        balances[seller] = balances[seller].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(seller, _to, _value);\n', '\n', '        totalSales++;\n', '        tokensSold = tokensSold.add(_value);\n', '        emit SellEvent(seller, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\n", '     */\n', '    function transfer(address _to, uint256 _value) ifUnlocked(msg.sender) public override returns (bool) {\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /**\n', "     * Until all tokens are sold, tokens can be transfered to/from owner's accounts.\n", '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) ifUnlocked(_from) public override returns (bool) {\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '\n', '    function burn(uint256 _value) public returns (bool) {\n', '        require(_value > 0, "_value is 0");\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Transfer(msg.sender, address(0x0), _value);\n', '        emit Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n', "        require(deadline >= block.timestamp, 'CommonToken: expired deadline');\n", '\n', '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR,\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n', '            )\n', '        );\n', '\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CommonToken: invalid permit');\n", '\n', '        approveInternal(owner, spender, value);\n', '    }\n', '\n', '    function transferByPermit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n', '        permit(owner, spender, value, deadline, v, r, s);\n', '\n', '        require(msg.sender == spender, "CommonToken: spender should be method caller");\n', '\n', '        transferFrom(owner, spender, value);\n', '    }\n', '\n', '    function dividendsCount() public view returns (uint256 count) {\n', '        return dividends.length;\n', '    }\n', '\n', '    function setDividendsDistributor(address _dividendDistributor, bool _allowed) public onlyOwner {\n', '        dividendDistributors[_dividendDistributor] = _allowed;\n', '    }\n', '\n', '    function addDividend(uint256 _dividendTokens) public onlyDividendDistributor {\n', '        require(_dividendTokens > 0, "CommonToken: not enough dividend tokens shared");\n', '        require(balanceOf(msg.sender) >= _dividendTokens, "CommonToken: not enough balance to create dividend");\n', '\n', '        dividends.push(Dividend(_dividendTokens, block.number));\n', '\n', '        transferInternal(msg.sender, address(this), _dividendTokens);\n', '\n', '        emit DividendAdded(dividends.length - 1, _dividendTokens, block.number);\n', '    }\n', '\n', '    function claimDividend() public {\n', '        claimDividendsFor(msg.sender, 1);\n', '    }\n', '\n', '    function claimDividends(uint256 _dividendsCount) public {\n', '        claimDividendsFor(msg.sender, _dividendsCount);\n', '    }\n', '\n', '    function claimAllDividends() public {\n', '        claimAllDividendsFor(msg.sender);\n', '    }\n', '\n', '    function claimDividendFor(address _account) public {\n', '        claimDividendsFor(_account, 1);\n', '    }\n', '\n', '    function claimDividendsFor(address _account, uint256 _dividendsCount) public {\n', '        require(_dividendsCount > 0, "CommonToken: Dividends count to claim should be greater than 0");\n', '        require(dividends.length > 0, "CommonToken: No dividends present");\n', '\n', '        trackBalance(_account);\n', '\n', '        uint256 _fromDividend = userDividends[_account].lastClaimedDividend;\n', '        uint256 _toDividend = _fromDividend.add(_dividendsCount);\n', '\n', '        require(_toDividend <= dividends.length, "CommonToken: no dividends available for claim");\n', '\n', '        uint256 totalDividends = 0;\n', '\n', '        for (uint256 i = _fromDividend; i < _toDividend; i++) {\n', '            uint256 dividendsFraction = dividends[i].amount.mul(balanceByDividends[_account][i]).div(totalSupply);\n', '            totalDividends = totalDividends.add(dividendsFraction);\n', '\n', '            emit DividendClaimed(_account, i, dividendsFraction);\n', '        }\n', '\n', '        userDividends[_account].lastClaimedDividend = _toDividend;\n', '\n', '        transferInternal(address(this), _account, totalDividends);\n', '\n', '        emit Transfer(address(this), _account, totalDividends);\n', '    }\n', '\n', '    function claimAllDividendsFor(address _account) public {\n', '        claimDividendsFor(_account, dividends.length.sub(userDividends[_account].lastClaimedDividend));\n', '    }\n', '\n', '    function trackBalance(address account) public override {\n', '        if (dividends.length == 0) {\n', '            return;\n', '        }\n', '\n', '        if (balanceOf(account) == 0 && userDividends[account].lastClaimedDividend == 0) {\n', '            userDividends[account].lastClaimedDividend = dividends.length;\n', '\n', '            return;\n', '        }\n', '\n', '        if (userDividends[account].balanceTillDividend < dividends.length) {\n', '            for (uint256 i = userDividends[account].balanceTillDividend; i < dividends.length; i++) {\n', '                balanceByDividends[account][i] = balanceOf(account);\n', '            }\n', '\n', '            userDividends[account].balanceTillDividend = dividends.length;\n', '        }\n', '    }\n', '}\n', '\n', 'contract ProdToken is CommonToken {\n', '    constructor() CommonToken(\n', '        0xF774c190CDAD67578f7181F74323F996041cAcfd\n', '    ) {}\n', '}']