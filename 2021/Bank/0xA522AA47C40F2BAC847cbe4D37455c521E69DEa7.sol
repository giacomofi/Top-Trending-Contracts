['# Copyright (C) 2021 VolumeFi Software, Inc.\n', '\n', '#  This program is free software: you can redistribute it and/or modify\n', '#  it under the terms of the Apache 2.0 License. \n', '#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\n', '#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n', '#  @author VolumeFi, Software inc.\n', '#  @notice This Vyper contract adds liquidity to any Uniswap V2 pool using ETH or any ERC20 Token.\n', '#  SPDX-License-Identifier: Apache-2.0\n', '\n', '# @version ^0.2.0\n', '\n', 'interface ERC20:\n', '    def approve(spender: address, amount: uint256): nonpayable\n', '    def transfer(recipient: address, amount: uint256): nonpayable\n', '    def transferFrom(sender: address, recipient: address, amount: uint256): nonpayable\n', '\n', 'interface UniswapV2Pair:\n', '    def token0() -> address: view\n', '    def token1() -> address: view\n', '    def getReserves() -> (uint256, uint256, uint256): view\n', '    def mint(to: address) -> uint256: nonpayable\n', '\n', 'interface UniswapV2Router02:\n', '    def addLiquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256) -> (uint256, uint256, uint256): nonpayable\n', '\n', 'interface UniswapV2Factory:\n', '    def getPair(tokenA: address, tokenB: address) -> address: view\n', '    def createPair(tokenA: address, tokenB: address) -> address: nonpayable\n', '\n', 'interface WrappedEth:\n', '    def deposit(): payable\n', '\n', 'event LPTokenMint:\n', '    msg_sender: address\n', '    liquidity: uint256\n', '\n', 'UNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', 'UNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\n', '\n', 'VETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', 'WETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', 'DEADLINE: constant(uint256) = MAX_UINT256 # change\n', '\n', 'paused: public(bool)\n', 'admin: public(address)\n', 'feeAmount: public(uint256)\n', 'feeAddress: public(address)\n', '\n', '@external\n', 'def __init__():\n', '    self.paused = False\n', '    self.admin = msg.sender\n', '    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\n', '    self.feeAmount = 5 * 10 ** 15\n', '\n', '@internal\n', '@pure\n', 'def _getPairTokens(pair: address) -> (address, address):\n', '    token0: address = UniswapV2Pair(pair).token0()\n', '    token1: address = UniswapV2Pair(pair).token1()\n', '    return (token0, token1)\n', '\n', '@internal\n', '@pure\n', 'def uintSqrt(y: uint256) -> uint256:\n', '    z: uint256 = 0\n', '    x: uint256 = 0\n', '    if y > 3:\n', '        z = y\n', '        x = y / 2 + 1\n', '        for i in range(256):\n', '            if x >= z:\n', '                break\n', '            z = x\n', '            x = (y / x + x) / 2\n', '    elif y != 0:\n', '        z = 1\n', '    else:\n', '        z = 0\n', '    return z\n', '\n', '@internal\n', 'def _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\n', '    if fromToken == toToken:\n', '        return tokens2Trade\n', '    ERC20(fromToken).approve(UNISWAPV2ROUTER02, 0)\n', '    ERC20(fromToken).approve(UNISWAPV2ROUTER02, tokens2Trade)\n', '    \n', '    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(self, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\n', '    funcsig: Bytes[4] = method_id("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")\n', '    full_data: Bytes[292] = concat(funcsig, addrBytes)\n', '    \n', '    _response: Bytes[128] = raw_call(\n', '        UNISWAPV2ROUTER02,\n', '        full_data,\n', '        max_outsize=128\n', '    )\n', '    tokenBought: uint256 = convert(slice(_response, 96, 32), uint256)\n', '    assert tokenBought > 0, "Error Swapping Token 2"\n', '    return tokenBought\n', '\n', '@internal\n', '@view\n', 'def _calculateSwapInAmount(reserveIn: uint256, userIn: uint256) -> uint256:\n', '    return ((self.uintSqrt(reserveIn * (userIn * 3988000 + reserveIn * 3988009))) - reserveIn * 1997) / 1994\n', '\n', '@internal\n', 'def _swap(fromToken: address, pair: address, toUnipoolToken0: address, toUnipoolToken1: address, amount: uint256, deadline: uint256) -> (uint256, uint256):\n', '    res0: uint256 = 0\n', '    res1: uint256 = 0\n', '    blockTimestampLast: uint256 = 0\n', '    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '    token1Bought: uint256 = 0\n', '    token0Bought: uint256 = 0\n', '    if (fromToken == toUnipoolToken0):\n', '        amountToSwap: uint256 = self._calculateSwapInAmount(res0, amount)\n', '        if amountToSwap == 0:\n', '            amountToSwap = amount / 2\n', '        token1Bought = self._token2Token(fromToken, toUnipoolToken1, amountToSwap, deadline)\n', '        token0Bought = amount - amountToSwap\n', '    else:\n', '        amountToSwap: uint256 = self._calculateSwapInAmount(res1, amount)\n', '        if amountToSwap == 0:\n', '            amountToSwap = amount / 2\n', '        token0Bought = self._token2Token(fromToken, toUnipoolToken0, amountToSwap, deadline)\n', '        token1Bought = amount - amountToSwap\n', '    return (token0Bought, token1Bought)\n', '\n', '@internal\n', 'def _uniDeposit(token0: address, token1: address, amount0: uint256, amount1: uint256, sender: address, deadline: uint256) -> uint256:\n', '    ERC20(token0).approve(UNISWAPV2ROUTER02, 0)\n', '    ERC20(token1).approve(UNISWAPV2ROUTER02, 0)\n', '    ERC20(token0).approve(UNISWAPV2ROUTER02, amount0)\n', '    ERC20(token1).approve(UNISWAPV2ROUTER02, amount1)\n', '    amountA: uint256 = 0\n', '    amountB: uint256 = 0\n', '    LP: uint256 = 0\n', '    (amountA, amountB, LP) = UniswapV2Router02(UNISWAPV2ROUTER02).addLiquidity(token0, token1, amount0, amount1, 1, 1, sender, deadline)\n', '    if amount0 - amountA > 0:\n', '        ERC20(token0).transfer(sender, amount0 - amountA)\n', '    if amount1 - amountB > 0:\n', '        ERC20(token1).transfer(sender, amount1 - amountB)\n', '    return LP\n', '\n', '@internal\n', 'def _performInvest(fromToken:address, pair:address, amount:uint256, sender: address, deadline: uint256) -> uint256:\n', '    toUniswapToken0: address = ZERO_ADDRESS\n', '    toUniswapToken1: address = ZERO_ADDRESS\n', '    (toUniswapToken0, toUniswapToken1) = self._getPairTokens(pair)\n', '    if fromToken != toUniswapToken0 and fromToken != toUniswapToken1:\n', '        raise "Token Error"\n', '    token0Bought: uint256 = 0\n', '    token1Bought: uint256 = 0\n', '    (token0Bought, token1Bought) = self._swap(fromToken, pair, toUniswapToken0, toUniswapToken1, amount, deadline)\n', '    return self._uniDeposit(toUniswapToken0, toUniswapToken1, token0Bought, token1Bought, sender, deadline)\n', '\n', '@internal\n', '@view\n', 'def _getLiquidityInPool(midToken: address, pair: address) -> uint256:\n', '    res0: uint256 = 0\n', '    res1: uint256 = 0\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    blockTimestampLast: uint256 = 0\n', '    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '    (token0, token1) = self._getPairTokens(pair)\n', '    if token0 == midToken:\n', '        return res0\n', '    else:\n', '        return res1\n', '\n', '@internal\n', '@view\n', 'def _getMidToken(midToken: address, token0: address, token1: address) -> address:\n', '    pair0: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token0)\n', '    pair1: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, token1)\n', '    eth0: uint256 = self._getLiquidityInPool(midToken, pair0)\n', '    eth1: uint256 = self._getLiquidityInPool(midToken, pair1)\n', '    if eth0 > eth1:\n', '        return token0\n', '    else:\n', '        return token1\n', '\n', '@external\n', '@payable\n', "@nonreentrant('lock')\n", 'def investTokenForUniPair(token: address, pair: address, amount: uint256, minPoolTokens: uint256, deadline: uint256=DEADLINE) -> uint256:\n', '    assert not self.paused, "Paused"\n', '    fee: uint256 = self.feeAmount\n', '    msg_value: uint256 = msg.value\n', '    assert msg.value >= fee, "Insufficient fee"\n', '    send(self.feeAddress, fee)\n', '    msg_value -= fee\n', '    assert amount > 0, "Invalid input amount"\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    (token0, token1) = self._getPairTokens(pair)\n', '    LPBought: uint256 = 0\n', '    midToken: address = WETH\n', '    toInvest: uint256 = 0\n', '    # invest ETH\n', '    if token == VETH or token == ZERO_ADDRESS:\n', '        assert msg_value >= amount, "ETH not enough"\n', '        # return remaining ETH\n', '        if msg_value > amount:\n', '            send(msg.sender, msg_value - amount)\n', '        toInvest = amount\n', '        WrappedEth(WETH).deposit(value=toInvest)\n', '    # invest Token\n', '    else:\n', '        ERC20(token).transferFrom(msg.sender, self, amount)\n', '        if msg_value > 0:\n', '            send(msg.sender, msg_value)\n', '        if token == WETH:\n', '            toInvest = amount\n', '        elif token != token0 and token != token1:\n', '            toInvest = self._token2Token(token, WETH, amount, deadline)\n', '        else:\n', '            midToken = token\n', '            toInvest = amount\n', '    if token0 == WETH or token1 == WETH or token == token0 or token == token1:\n', '        LPBought = self._performInvest(midToken, pair, toInvest, msg.sender, deadline)\n', '    else:\n', '        midToken = self._getMidToken(WETH, token0, token1)\n', '        toInvest = self._token2Token(WETH, midToken, toInvest, deadline)\n', '        LPBought = self._performInvest(midToken, pair, toInvest, msg.sender, deadline)\n', '    assert LPBought >= minPoolTokens, "High Slippage"\n', '    return LPBought\n', '\n', '@internal\n', 'def _add_liquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256) -> (uint256, uint256, address):\n', '    pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(tokenA, tokenB)\n', '    if pair == ZERO_ADDRESS:\n', '        pair = UniswapV2Factory(UNISWAPV2FACTORY).createPair(tokenA, tokenB)\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    amount0Min: uint256 = 0\n', '    amount1Min: uint256 = 0\n', '    amount0Desired: uint256 = 0\n', '    amount1Desired: uint256 = 0\n', '    amount0: uint256 = 0\n', '    amount1: uint256 = 0\n', '    ab_swapped: bool = False\n', '    if convert(tokenA, uint256) < convert(tokenB, uint256):\n', '        amount0Min = amountAMin\n', '        amount1Min = amountBMin\n', '        amount0Desired = amountADesired\n', '        amount1Desired = amountBDesired\n', '    else:\n', '        amount0Min = amountBMin\n', '        amount1Min = amountAMin\n', '        amount0Desired = amountBDesired\n', '        amount1Desired = amountADesired\n', '        ab_swapped = True\n', '    reserve0: uint256 = 0\n', '    reserve1: uint256 = 0\n', '    blockTimestampLast: uint256 = 0\n', '    (reserve0, reserve1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '    if reserve0 == 0 and reserve1 == 0:\n', '        return (amountADesired, amountBDesired, pair)\n', '    amount1Optimal: uint256 = amount0Desired * reserve1 / reserve0\n', '    if amount1Optimal <= amount1Desired:\n', '        if ab_swapped:\n', '            assert amount1Optimal >= amount1Min, "INSUFFICIENT_A_AMOUNT"\n', '            return (amount1Optimal, amount0Desired, pair)\n', '        else:\n', '            assert amount1Optimal >= amount1Min, "INSUFFICIENT_B_AMOUNT"\n', '            return (amount0Desired, amount1Optimal, pair)\n', '        \n', '    else:\n', '        amount0Optimal: uint256 = amount1Desired * reserve0 / reserve1\n', '        assert amount0Optimal <= amount0Desired, "DESIRED AMOUNT ERROR"\n', '        if ab_swapped:\n', '            assert amount0Optimal >= amount0Min, "INSUFFICIENT_B_AMOUNT"\n', '            return (amount1Desired, amount0Optimal, pair)\n', '        else:\n', '            assert amount0Optimal >= amount0Min, "INSUFFICIENT_A_AMOUNT"\n', '            return (amount0Optimal, amount1Desired, pair)\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def addLiquidity(tokenA: address, tokenB: address, amountADesired: uint256, amountBDesired: uint256, amountAMin: uint256, amountBMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256, uint256):\n', '    assert deadline >= block.timestamp, "EXPIRED"\n', '    amountA: uint256 = 0\n', '    amountB: uint256 = 0\n', '    liquidity: uint256 = 0\n', '    pair: address = ZERO_ADDRESS\n', '    (amountA, amountB, pair) = self._add_liquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin)\n', '    ERC20(tokenA).transferFrom(msg.sender, pair, amountA)\n', '    ERC20(tokenB).transferFrom(msg.sender, pair, amountB)\n', '    liquidity = UniswapV2Pair(pair).mint(to)\n', '    log LPTokenMint(msg.sender, liquidity)\n', '    return (amountA, amountB, liquidity)\n', '\n', '@external\n', '@payable\n', "@nonreentrant('lock')\n", 'def addLiquidityETH(token: address, amountTokenDesired: uint256, amountTokenMin: uint256, amountETHMin: uint256, to: address, deadline: uint256=DEADLINE) -> (uint256, uint256, uint256):\n', '    assert deadline >= block.timestamp, "EXPIRED"\n', '    amountToken: uint256 = 0\n', '    amountETH: uint256 = 0\n', '    liquidity: uint256 = 0\n', '    pair: address = ZERO_ADDRESS\n', '    (amountToken, amountETH, pair) = self._add_liquidity(token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin)\n', '    ERC20(token).transferFrom(msg.sender, pair, amountToken)\n', '    WrappedEth(WETH).deposit(value=amountETH)\n', '    if msg.value > amountETH:\n', '        send(msg.sender, msg.value - amountETH)\n', '    ERC20(WETH).transfer(pair, amountETH)\n', '    liquidity = UniswapV2Pair(pair).mint(to)\n', '    log LPTokenMint(msg.sender, liquidity)\n', '    return (amountToken, amountETH, liquidity)\n', '\n', '# Admin functions\n', '@external\n', 'def pause(_paused: bool):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.paused = _paused\n', '\n', '@external\n', 'def newAdmin(_admin: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.admin = _admin\n', '\n', '@external\n', 'def newFeeAmount(_feeAmount: uint256):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.feeAmount = _feeAmount\n', '\n', '@external\n', 'def newFeeAddress(_feeAddress: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.feeAddress = _feeAddress\n', '\n', '@external\n', '@payable\n', 'def __default__(): pass']