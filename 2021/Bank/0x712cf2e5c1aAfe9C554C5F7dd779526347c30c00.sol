['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-08\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma abicoder v2;\n', 'pragma solidity ^0.7.0;\n', '\n', 'contract UniswapV3Analysor {\n', '    struct Pool {\n', '        address pool_address;\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '        uint128 liquidity;\n', '        uint256 amount0;\n', '        uint256 amount1;\n', '    }\n', '\n', '    address factory_address = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n', '    address nfp_manager_address = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n', '    \n', '    IUniswapV3Factory factory;\n', '    INonfungiblePositionManager nfp_manager;\n', '    \n', '    constructor() {\n', '        factory = IUniswapV3Factory(factory_address);\n', '        nfp_manager = INonfungiblePositionManager(nfp_manager_address);\n', '    }\n', '\n', '    function nftBalanceOf(address account) public view returns (uint) {\n', '        return nfp_manager.balanceOf(account);\n', '    }\n', '\n', '    function nftIDsOf(address account) public view returns (uint[] memory nftIDs) {\n', '        uint nftBalance = nftBalanceOf(account);\n', '        nftIDs = new uint[](nftBalance);\n', '        for (uint i = 0; i < nftBalance; i++) {\n', '            nftIDs[i] = nfp_manager.tokenOfOwnerByIndex(account, i);\n', '        }\n', '    }\n', '    \n', '    function positionOf(uint id) internal view returns (\n', '        address token0,\n', '        address token1,\n', '        uint24 fee,\n', '        int24 tickLower,\n', '        int24 tickUpper,\n', '        uint128 liquidity\n', '    ) {\n', '        (\n', '            ,,\n', '            token0,\n', '            token1,\n', '            fee,\n', '            tickLower,\n', '            tickUpper,\n', '            liquidity,\n', '            ,,,\n', '        ) = nfp_manager.positions(id);\n', '    }\n', '    \n', '    function getPools(\n', '        address[] memory token0s,\n', '        address[] memory token1s,\n', '        uint24[] memory fees,\n', '        int24[] memory tickLowers,\n', '        int24[] memory tickUppers,\n', '        uint128[] memory liquidity\n', '    ) public view returns (Pool[] memory pools) {\n', '        require(token0s.length == token1s.length, "Length of token0s and token1s are different");\n', '        require(token1s.length == fees.length, "Length of token1s and fees are different");\n', '        for (uint i = 0; i < token0s.length; i++) {\n', '            pools[i].pool_address = factory.getPool(token0s[i], token1s[i], fees[i]);\n', '            pools[i].token0 = token0s[i];\n', '            pools[i].token1 = token1s[i];\n', '            pools[i].fee = fees[i];\n', '            pools[i].liquidity = IUniswapV3Pool(pools[i].pool_address).liquidity();\n', '            \n', '            (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pools[i].pool_address).slot0();\n', '            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLowers[i]);\n', '            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUppers[i]);\n', '            \n', '            (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidity[i]);\n', '            \n', '            pools[i].amount0 = amount0;\n', '            pools[i].amount1 = amount1;\n', '        }\n', '    }\n', '}\n', '\n', 'library LiquidityAmounts {\n', '    function toUint128(uint256 x) private pure returns (uint128 y) {\n', '        require((y = uint128(x)) == x);\n', '    }\n', '\n', '    function getLiquidityForAmount0(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount0\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n', '        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n', '    }\n', '\n', '    function getLiquidityForAmount1(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount1\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n', '    }\n', '\n', '    function getLiquidityForAmounts(\n', '        uint160 sqrtRatioX96,\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint256 amount0,\n', '        uint256 amount1\n', '    ) internal pure returns (uint128 liquidity) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        if (sqrtRatioX96 <= sqrtRatioAX96) {\n', '            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n', '        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n', '            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n', '            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n', '\n', '            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n', '        } else {\n', '            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n', '        }\n', '    }\n', '\n', '    function getAmount0ForLiquidity(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount0) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        return\n', '            FullMath.mulDiv(\n', '                uint256(liquidity) << FixedPoint96.RESOLUTION,\n', '                sqrtRatioBX96 - sqrtRatioAX96,\n', '                sqrtRatioBX96\n', '            ) / sqrtRatioAX96;\n', '    }\n', '\n', '    function getAmount1ForLiquidity(\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount1) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n', '    }\n', '\n', '    function getAmountsForLiquidity(\n', '        uint160 sqrtRatioX96,\n', '        uint160 sqrtRatioAX96,\n', '        uint160 sqrtRatioBX96,\n', '        uint128 liquidity\n', '    ) internal pure returns (uint256 amount0, uint256 amount1) {\n', '        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n', '\n', '        if (sqrtRatioX96 <= sqrtRatioAX96) {\n', '            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n', '        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n', '            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n', '            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n', '        } else {\n', '            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n', '        }\n', '    }\n', '}\n', '\n', 'library FixedPoint96 {\n', '    uint8 internal constant RESOLUTION = 96;\n', '    uint256 internal constant Q96 = 0x1000000000000000000000000;\n', '}\n', '\n', 'library FullMath {\n', '    function mulDiv(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        uint256 prod0;\n', '        uint256 prod1;\n', '        assembly {\n', '            let mm := mulmod(a, b, not(0))\n', '            prod0 := mul(a, b)\n', '            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n', '        }\n', '\n', '        if (prod1 == 0) {\n', '            require(denominator > 0);\n', '            assembly {\n', '                result := div(prod0, denominator)\n', '            }\n', '            return result;\n', '        }\n', '        \n', '        require(denominator > prod1);\n', '\n', '        uint256 remainder;\n', '        assembly {\n', '            remainder := mulmod(a, b, denominator)\n', '        }\n', '\n', '        assembly {\n', '            prod1 := sub(prod1, gt(remainder, prod0))\n', '            prod0 := sub(prod0, remainder)\n', '        }\n', '\n', '        uint256 twos = -denominator & denominator;\n', '\n', '        assembly {\n', '            denominator := div(denominator, twos)\n', '        }\n', '\n', '        assembly {\n', '            prod0 := div(prod0, twos)\n', '        }\n', '\n', '        assembly {\n', '            twos := add(div(sub(0, twos), twos), 1)\n', '        }\n', '        prod0 |= prod1 * twos;\n', '\n', '        uint256 inv = (3 * denominator) ^ 2;\n', '\n', '        inv *= 2 - denominator * inv; // inverse mod 2**8\n', '        inv *= 2 - denominator * inv; // inverse mod 2**16\n', '        inv *= 2 - denominator * inv; // inverse mod 2**32\n', '        inv *= 2 - denominator * inv; // inverse mod 2**64\n', '        inv *= 2 - denominator * inv; // inverse mod 2**128\n', '        inv *= 2 - denominator * inv; // inverse mod 2**256\n', '\n', '        result = prod0 * inv;\n', '        return result;\n', '    }\n', '\n', '    function mulDivRoundingUp(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        result = mulDiv(a, b, denominator);\n', '        if (mulmod(a, b, denominator) > 0) {\n', '            require(result < type(uint256).max);\n', '            result++;\n', '        }\n', '    }\n', '}\n', '\n', 'library TickMath {\n', '    int24 internal constant MIN_TICK = -887272;\n', '    int24 internal constant MAX_TICK = -MIN_TICK;\n', '\n', '    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n', '    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n', '\n', '    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n', '        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n', "        require(absTick <= uint256(MAX_TICK), 'T');\n", '\n', '        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n', '        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n', '        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n', '        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n', '        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n', '        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n', '        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n', '        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n', '        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n', '        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n', '        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n', '        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n', '        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n', '        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n', '        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n', '        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n', '        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n', '        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n', '        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n', '        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n', '\n', '        if (tick > 0) ratio = type(uint256).max / ratio;\n', '\n', '        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n', '    }\n', '    \n', '    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n', "        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n", '        uint256 ratio = uint256(sqrtPriceX96) << 32;\n', '\n', '        uint256 r = ratio;\n', '        uint256 msb = 0;\n', '\n', '        assembly {\n', '            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(5, gt(r, 0xFFFFFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(4, gt(r, 0xFFFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(3, gt(r, 0xFF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(2, gt(r, 0xF))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := shl(1, gt(r, 0x3))\n', '            msb := or(msb, f)\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            let f := gt(r, 0x1)\n', '            msb := or(msb, f)\n', '        }\n', '\n', '        if (msb >= 128) r = ratio >> (msb - 127);\n', '        else r = ratio << (127 - msb);\n', '\n', '        int256 log_2 = (int256(msb) - 128) << 64;\n', '\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(63, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(62, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(61, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(60, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(59, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(58, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(57, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(56, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(55, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(54, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(53, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(52, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(51, f))\n', '            r := shr(f, r)\n', '        }\n', '        assembly {\n', '            r := shr(127, mul(r, r))\n', '            let f := shr(128, r)\n', '            log_2 := or(log_2, shl(50, f))\n', '        }\n', '\n', '        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n', '\n', '        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n', '        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n', '\n', '        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n', '    }\n', '}\n', '\n', 'interface IUniswapV3Factory {\n', '    function owner() external view returns (address);\n', '    function feeAmountTickSpacing(uint24) external view returns (int24);\n', '    function getPool(address, address, uint24) external view returns (address);\n', '    function createPool(address, address, uint24) external returns (address);\n', '    function setOwner(address) external;\n', '    function enableFeeAmount(uint24, int24) external;\n', '}\n', '\n', 'interface IUniswapV3Pool\n', '{\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function fee() external view returns (uint24);\n', '    function tickSpacing() external view returns (int24);\n', '    function maxLiquidityPerTick() external view returns (uint128);\n', '    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\n', '    function feeGrowthGlobal0X128() external view returns (uint256);\n', '    function feeGrowthGlobal1X128() external view returns (uint256);\n', '    function protocolFees() external view returns (uint128, uint128);\n', '    function liquidity() external view returns (uint128);\n', '    function ticks(int24) external view returns (uint128, int128, uint256, uint256, int56, uint160, uint32, bool);\n', '    function tickBitmap(int16) external view returns (uint256);\n', '    function positions(bytes32) external view returns (uint128, uint256, uint256, uint128, uint128);\n', '    function observations(uint256) external view returns (uint32, int56, uint160, bool);\n', '    function observe(uint32[] calldata) external view returns (int56[] memory, uint160[] memory);\n', '    function snapshotCumulativesInside(int24, int24) external view returns (int56, uint160, uint32);\n', '    function initialize(uint160) external;\n', '    function mint(address, int24, int24, uint128, bytes calldata) external returns (uint256, uint256);\n', '    function collect(address, int24, int24, uint128, uint128) external returns (uint128, uint128);\n', '    function burn(int24, int24, uint128) external returns (uint256, uint256);\n', '    function swap(address, bool, int256, uint160, bytes calldata) external returns (int256, int256);\n', '    function flash( address, uint256, uint256, bytes calldata) external;\n', '    function increaseObservationCardinalityNext(uint16) external;\n', '    function setFeeProtocol(uint8, uint8) external;\n', '    function collectProtocol( address, uint128, uint128) external returns (uint128, uint128);\n', '}\n', '\n', 'interface INonfungiblePositionManager {\n', '    function positions(uint256) external view returns (uint96, address, address, address, uint24, int24, int24, uint128, uint256, uint256, uint128, uint128);\n', '\n', '    struct MintParams {\n', '        address token0;\n', '        address token1;\n', '        uint24 fee;\n', '        int24 tickLower;\n', '        int24 tickUpper;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        address recipient;\n', '        uint256 deadline;\n', '    }\n', '\n', '    function mint(MintParams calldata) external payable returns (uint256, uint128, uint256, uint256);\n', '\n', '    struct IncreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint256 amount0Desired;\n', '        uint256 amount1Desired;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    function increaseLiquidity(IncreaseLiquidityParams calldata) external payable returns (uint128, uint256, uint256);\n', '\n', '    struct DecreaseLiquidityParams {\n', '        uint256 tokenId;\n', '        uint128 liquidity;\n', '        uint256 amount0Min;\n', '        uint256 amount1Min;\n', '        uint256 deadline;\n', '    }\n', '\n', '    function decreaseLiquidity(DecreaseLiquidityParams calldata) external payable returns (uint256, uint256);\n', '\n', '    struct CollectParams {\n', '        uint256 tokenId;\n', '        address recipient;\n', '        uint128 amount0Max;\n', '        uint128 amount1Max;\n', '    }\n', '\n', '    function collect(CollectParams calldata) external payable returns (uint256, uint256);\n', '    function burn(uint256) external payable;\n', '    function createAndInitializePoolIfNecessary(address, address, uint24, uint160) external payable returns (address);\n', '    function unwrapWETH9(uint256, address) external payable;\n', '    function refundETH() external payable;\n', '    function sweepToken( address, uint256, address) external payable;\n', '    function factory() external view returns (address);\n', '    function WETH9() external view returns (address);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256) external view returns (string memory);\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address, uint256) external view returns (uint256);\n', '    function tokenByIndex(uint256) external view returns (uint256);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function permit(address, uint256, uint256, uint8, bytes32, bytes32) external payable;\n', '    function balanceOf(address) external view returns (uint256);\n', '    function ownerOf(uint256) external view returns (address);\n', '    function safeTransferFrom(address, address, uint256) external;\n', '    function transferFrom(address, address, uint256) external;\n', '    function approve(address, uint256) external;\n', '    function getApproved(uint256) external view returns (address);\n', '    function setApprovalForAll(address, bool) external;\n', '    function isApprovedForAll(address, address) external view returns (bool);\n', '    function safeTransferFrom(address, address, uint256, bytes calldata) external;\n', '}\n', '\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address) external view returns (uint);\n', '    function allowance(address, address) external view returns (uint);\n', '    function decimals() external view returns(uint);\n', '}']