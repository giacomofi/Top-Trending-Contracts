['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', 'import "./GODLDividendTracker.sol";\n', 'import "./FTPAntiBot.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IUniswapV2Router.sol";\n', '\n', 'contract GODL is ERC20, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    FTPAntiBot private antiBot;\n', '    bool public useAntiBot = true;\n', '\n', '    IUniswapV2Router02 public uniswapV2Router;\n', '    address public immutable uniswapV2Pair;\n', '\n', '    bool private liquidating;\n', '\n', '    GODLDividendTracker public dividendTracker;\n', '\n', '    address public liquidityWallet;\n', '\n', '    uint256 public constant MAX_SELL_TRANSACTION_AMOUNT = 1000000 * (10**18);\n', '\n', '    uint256 public constant ETH_REWARDS_FEE = 5;\n', '    uint256 public constant LIQUIDITY_FEE = 3;\n', '    uint256 public constant TOTAL_FEES = ETH_REWARDS_FEE + LIQUIDITY_FEE;\n', '\n', '    // use by default 150,000 gas to process auto-claiming dividends\n', '    uint256 public gasForProcessing = 150000;\n', '\n', '    // liquidate tokens for ETH when the contract reaches 100k tokens by default\n', '    uint256 public liquidateTokensAtAmount = 100000 * (10**18);\n', '\n', '    // whether the token can already be traded\n', '    bool public tradingEnabled;\n', '\n', '    function activate() public onlyOwner {\n', '        require(!tradingEnabled, "GODL: Trading is already enabled");\n', '        tradingEnabled = true;\n', '    }\n', '\n', '    // exclude from fees and max transaction amount\n', '    mapping (address => bool) private _isExcludedFromFees;\n', '\n', '    // addresses that can make transfers before presale is over\n', '    mapping (address => bool) public canTransferBeforeTradingIsEnabled;\n', '\n', '    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n', '    // could be subject to a maximum transfer amount\n', '    mapping (address => bool) public automatedMarketMakerPairs;\n', '\n', '    event UpdatedAntiBot(address indexed newAddress, address indexed oldAddress);\n', '\n', '    event ToggledAntiBot(bool newValue, bool oldValue);\n', '\n', '    event UpdatedDividendTracker(address indexed newAddress, address indexed oldAddress);\n', '\n', '    event UpdatedUniswapV2Router(address indexed newAddress, address indexed oldAddress);\n', '\n', '    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n', '\n', '    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\n', '\n', '    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n', '\n', '    event LiquidationThresholdUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n', '\n', '    event Liquified(\n', '        uint256 tokensSwapped,\n', '        uint256 ethReceived,\n', '        uint256 tokensIntoLiqudity\n', '    );\n', '\n', '    event SentDividends(\n', '        uint256 tokensSwapped,\n', '        uint256 amount\n', '    );\n', '\n', '    event ProcessedDividendTracker(\n', '        uint256 iterations,\n', '        uint256 claims,\n', '        uint256 lastProcessedIndex,\n', '        bool indexed automatic,\n', '        uint256 gas,\n', '        address indexed processor\n', '    );\n', '\n', '    constructor() ERC20("GODL", "GODL") {\n', '        assert(TOTAL_FEES == 8);\n', '\n', '        dividendTracker = new GODLDividendTracker();\n', '        liquidityWallet = owner();\n', '\n', '        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        // Create a uniswap pair for this new token\n', '        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n', '\n', '        FTPAntiBot _antiBot = FTPAntiBot(0xCD5312d086f078D1554e8813C27Cf6C9D1C3D9b3);\n', '        antiBot = _antiBot;\n', '\n', '        uniswapV2Router = _uniswapV2Router;\n', '        uniswapV2Pair = _uniswapV2Pair;\n', '\n', '        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n', '\n', '        // exclude from receiving dividends\n', '        dividendTracker.excludeFromDividends(address(dividendTracker));\n', '        dividendTracker.excludeFromDividends(address(this));\n', '        dividendTracker.excludeFromDividends(owner());\n', '        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\n', '\n', '        // exclude from paying fees or having max transaction amount\n', '        excludeFromFees(liquidityWallet);\n', '        excludeFromFees(address(this));\n', '\n', '        // enable owner wallet to send tokens before presales are over.\n', '        canTransferBeforeTradingIsEnabled[owner()] = true;\n', '\n', '        /*\n', '            _mint is an internal function in ERC20.sol that is only called here,\n', '            and CANNOT be called ever again\n', '        */\n', '        _mint(owner(), 1000000000 * (10**18));\n', '    }\n', '\n', '    receive() external payable {\n', '\n', '    }\n', '\n', '    function updateDividendTracker(address newAddress) public onlyOwner {\n', '        require(newAddress != address(dividendTracker), "GODL: The dividend tracker already has that address");\n', '\n', '        GODLDividendTracker newDividendTracker = GODLDividendTracker(payable(newAddress));\n', '\n', '        require(newDividendTracker.owner() == address(this), "GODL: The new dividend tracker must be owned by the GODL token contract");\n', '\n', '        newDividendTracker.excludeFromDividends(address(newDividendTracker));\n', '        newDividendTracker.excludeFromDividends(address(this));\n', '        newDividendTracker.excludeFromDividends(owner());\n', '        newDividendTracker.excludeFromDividends(address(uniswapV2Router));\n', '\n', '        emit UpdatedDividendTracker(newAddress, address(dividendTracker));\n', '\n', '        dividendTracker = newDividendTracker;\n', '    }\n', '\n', '    function updateUniswapV2Router(address newAddress) public onlyOwner {\n', '        require(newAddress != address(uniswapV2Router), "GODL: The router already has that address");\n', '        emit UpdatedUniswapV2Router(newAddress, address(uniswapV2Router));\n', '        uniswapV2Router = IUniswapV2Router02(newAddress);\n', '    }\n', '\n', '    function excludeFromFees(address account) public onlyOwner {\n', '        require(!_isExcludedFromFees[account], "GODL: Account is already excluded from fees");\n', '        _isExcludedFromFees[account] = true;\n', '    }\n', '\n', '    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n', '        require(pair != uniswapV2Pair, "GODL: The Uniswap pair cannot be removed from automatedMarketMakerPairs");\n', '\n', '        _setAutomatedMarketMakerPair(pair, value);\n', '    }\n', '\n', '    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n', '        require(automatedMarketMakerPairs[pair] != value, "GODL: Automated market maker pair is already set to that value");\n', '        automatedMarketMakerPairs[pair] = value;\n', '\n', '        if (value) {\n', '            dividendTracker.excludeFromDividends(pair);\n', '        }\n', '\n', '        emit SetAutomatedMarketMakerPair(pair, value);\n', '    }\n', '\n', '    function allowTransferBeforeTradingIsEnabled(address account) public onlyOwner {\n', '        require(!canTransferBeforeTradingIsEnabled[account], "GODL: Account is already allowed to transfer before trading is enabled");\n', '        canTransferBeforeTradingIsEnabled[account] = true;\n', '    }\n', '\n', '    function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner {\n', '        require(newLiquidityWallet != liquidityWallet, "GODL: The liquidity wallet is already this address");\n', '        excludeFromFees(newLiquidityWallet);\n', '        emit LiquidityWalletUpdated(newLiquidityWallet, liquidityWallet);\n', '        liquidityWallet = newLiquidityWallet;\n', '    }\n', '\n', '    function updateGasForProcessing(uint256 newValue) public onlyOwner {\n', '        // Need to make gas fee customizable to future-proof against Ethereum network upgrades.\n', '        require(newValue != gasForProcessing, "GODL: Cannot update gasForProcessing to same value");\n', '        emit GasForProcessingUpdated(newValue, gasForProcessing);\n', '        gasForProcessing = newValue;\n', '    }\n', '\n', '    function updateLiquidationThreshold(uint256 newValue) external onlyOwner {\n', '        require(newValue <= 200000 * (10 ** 18), "GODL: liquidateTokensAtAmount must be less than 200,000");\n', '        require(newValue != liquidateTokensAtAmount, "GODL: Cannot update gasForProcessing to same value");\n', '        emit LiquidationThresholdUpdated(newValue, liquidateTokensAtAmount);\n', '        liquidateTokensAtAmount = newValue;\n', '    }\n', '\n', '    function updateGasForTransfer(uint256 gasForTransfer) external onlyOwner {\n', '        dividendTracker.updateGasForTransfer(gasForTransfer);\n', '    }\n', '\n', '    function updateClaimWait(uint256 claimWait) external onlyOwner {\n', '        dividendTracker.updateClaimWait(claimWait);\n', '    }\n', '\n', '    function getGasForTransfer() external view returns(uint256) {\n', '        return dividendTracker.gasForTransfer();\n', '    }\n', '\n', '    function getClaimWait() external view returns(uint256) {\n', '        return dividendTracker.claimWait();\n', '    }\n', '\n', '    function getTotalDividendsDistributed() external view returns (uint256) {\n', '        return dividendTracker.totalDividendsDistributed();\n', '    }\n', '\n', '    function isExcludedFromFees(address account) public view returns(bool) {\n', '        return _isExcludedFromFees[account];\n', '    }\n', '\n', '    function withdrawableDividendOf(address account) public view returns(uint256) {\n', '        return dividendTracker.withdrawableDividendOf(account);\n', '    }\n', '\n', '    function dividendTokenBalanceOf(address account) public view returns (uint256) {\n', '        return dividendTracker.balanceOf(account);\n', '    }\n', '\n', '    function getAccountDividendsInfo(address account)\n', '    external view returns (\n', '        address,\n', '        int256,\n', '        int256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256) {\n', '        return dividendTracker.getAccount(account);\n', '    }\n', '\n', '    function getAccountDividendsInfoAtIndex(uint256 index)\n', '    external view returns (\n', '        address,\n', '        int256,\n', '        int256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256) {\n', '        return dividendTracker.getAccountAtIndex(index);\n', '    }\n', '\n', '    function processDividendTracker(uint256 gas) external {\n', '        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\n', '        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\n', '    }\n', '\n', '    function claim() external {\n', '        dividendTracker.processAccount(payable(msg.sender), false);\n', '    }\n', '\n', '    function getLastProcessedIndex() external view returns(uint256) {\n', '        return dividendTracker.getLastProcessedIndex();\n', '    }\n', '\n', '    function getNumberOfDividendTokenHolders() external view returns(uint256) {\n', '        return dividendTracker.getNumberOfTokenHolders();\n', '    }\n', '\n', '    function updateAntiBot(address newAddress) external onlyOwner {\n', '        FTPAntiBot _antiBot = FTPAntiBot(newAddress);\n', '        emit UpdatedAntiBot(newAddress, address(antiBot));\n', '        antiBot = _antiBot;\n', '    }\n', '\n', '    function toggleAntiBot() external onlyOwner {\n', '        bool newValue = !useAntiBot;\n', '        emit ToggledAntiBot(newValue, useAntiBot);\n', '        useAntiBot = newValue;\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal override {\n', '        require(from != address(0), "ERC20: transfer from the zero address");\n', '        require(to != address(0), "ERC20: transfer to the zero address");\n', '\n', '        bool tradingIsEnabled = tradingEnabled;\n', '\n', '        // only whitelisted addresses can make transfers before the public presale is over.\n', '        if (!tradingIsEnabled) {\n', '            require(canTransferBeforeTradingIsEnabled[from], "GODL: This account cannot send tokens until trading is enabled");\n', '        }\n', '\n', '        if (useAntiBot) {\n', '            if ((from == uniswapV2Pair || to == uniswapV2Pair) && tradingIsEnabled) {\n', '                require(!antiBot.scanAddress(from, uniswapV2Pair, tx.origin),  "Beep Beep Boop, You\'re a piece of poop");\n', '                require(!antiBot.scanAddress(to, uniswapV2Pair, tx.origin), "Beep Beep Boop, You\'re a piece of poop");\n', '            }\n', '        }\n', '\n', '        if (amount == 0) {\n', '            super._transfer(from, to, 0);\n', '            return;\n', '        }\n', '\n', '        if (!liquidating &&\n', '            tradingIsEnabled &&\n', '            automatedMarketMakerPairs[to] && // sells only by detecting transfer to automated market maker pair\n', "            from != address(uniswapV2Router) && //router -> pair is removing liquidity which shouldn't have max\n", '            !_isExcludedFromFees[to] //no max for those excluded from fees\n', '        ) {\n', '            require(amount <= MAX_SELL_TRANSACTION_AMOUNT, "Sell transfer amount exceeds the MAX_SELL_TRANSACTION_AMOUNT.");\n', '        }\n', '\n', '        uint256 contractTokenBalance = balanceOf(address(this));\n', '\n', '        bool canSwap = contractTokenBalance >= liquidateTokensAtAmount;\n', '\n', '        if (tradingIsEnabled &&\n', '            canSwap &&\n', '            !liquidating &&\n', '            !automatedMarketMakerPairs[from] &&\n', '            from != liquidityWallet &&\n', '            to != liquidityWallet\n', '        ) {\n', '            liquidating = true;\n', '\n', '            uint256 swapTokens = contractTokenBalance.mul(LIQUIDITY_FEE).div(TOTAL_FEES);\n', '            swapAndLiquify(swapTokens);\n', '\n', '            uint256 sellTokens = balanceOf(address(this));\n', '            swapAndSendDividends(sellTokens);\n', '\n', '            liquidating = false;\n', '        }\n', '\n', '        bool takeFee = tradingIsEnabled && !liquidating;\n', '\n', '        // if any account belongs to _isExcludedFromFee account then remove the fee\n', '        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n', '            takeFee = false;\n', '        }\n', '\n', '        if (takeFee) {\n', '            uint256 fees = amount.mul(TOTAL_FEES).div(100);\n', '            amount = amount.sub(fees);\n', '\n', '            super._transfer(from, address(this), fees);\n', '        }\n', '\n', '        super._transfer(from, to, amount);\n', '\n', '        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\n', '        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n', '\n', '        if (useAntiBot) {\n', '            // Tells AntiBot to start watching.\n', '            antiBot.registerBlock(from, to, tx.origin);\n', '        }\n', '\n', '        if (!liquidating) {\n', '            uint256 gas = gasForProcessing;\n', '\n', '            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\n', '                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\n', '            } catch {\n', '\n', '            }\n', '        }\n', '    }\n', '\n', '    function swapAndLiquify(uint256 tokens) private {\n', '        // split the contract balance into halves\n', '        uint256 half = tokens.div(2);\n', '        uint256 otherHalf = tokens.sub(half);\n', '\n', "        // capture the contract's current ETH balance.\n", '        // this is so that we can capture exactly the amount of ETH that the\n', '        // swap creates, and not make the liquidity event include any ETH that\n', '        // has been manually sent to the contract\n', '        uint256 initialBalance = address(this).balance;\n', '\n', '        // swap tokens for ETH\n', '        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n', '\n', '        // how much ETH did we just swap into?\n', '        uint256 newBalance = address(this).balance.sub(initialBalance);\n', '\n', '        // add liquidity to uniswap\n', '        addLiquidity(otherHalf, newBalance);\n', '\n', '        emit Liquified(half, newBalance, otherHalf);\n', '    }\n', '\n', '    function swapTokensForEth(uint256 tokenAmount) private {\n', '        // generate the uniswap pair path of token -> weth\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = uniswapV2Router.WETH();\n', '\n', '        _approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '        // make the swap\n', '        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0, // accept any amount of ETH\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n', '        // approve token transfer to cover all possible scenarios\n', '        _approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\n', '        // add the liquidity\n', '        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n', '            address(this),\n', '            tokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            liquidityWallet,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function swapAndSendDividends(uint256 tokens) private {\n', '        swapTokensForEth(tokens);\n', '        uint256 dividends = address(this).balance;\n', '\n', '        (bool success,) = address(dividendTracker).call{value: dividends}("");\n', '        if (success) {\n', '            emit SentDividends(tokens, dividends);\n', '        }\n', '    }\n', '}']