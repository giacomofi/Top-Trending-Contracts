['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity =0.7.6;\n', '\n', "import './provableAPI_0.6.sol';\n", '\n', '// Interfaces\n', 'interface ISwappToken {\n', '    function currentSwappDay() external view returns (uint64);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '    function mintSupply(address _investorAddress, uint256 _amount) external;\n', '    function giveStatus(address _referrer) external;\n', '}\n', '\n', 'interface UniswapRouterV2 {\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenMax,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (\n', '        uint256 amountToken,\n', '        uint256 amountETH,\n', '        uint256 liquidity\n', '    );\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (\n', '        uint256[] memory amounts\n', '    );\n', '}\n', '\n', 'interface IERC20Token {\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '}\n', '\n', 'library SafeMathLT {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', "        require(c >= a, 'SWAPP: addition overflow');\n", '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b <= a, 'SWAPP: subtraction overflow');\n", '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', "        require(c / a == b, 'SWAPP: multiplication overflow');\n", '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b > 0, 'SWAPP: division by zero');\n", '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b != 0, 'SWAPP: modulo by zero');\n", '        return a % b;\n', '    }\n', '}\n', '\n', 'contract LiquidityTransformer is usingProvable {\n', '    using SafeMathLT for uint256;\n', '    using SafeMathLT for uint128;\n', '\n', '    ISwappToken public SWAPP_CONTRACT;\n', '\n', '    UniswapRouterV2 private constant UNISWAP_ROUTER = UniswapRouterV2(\n', '        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '    );\n', '\n', '    address payable constant TEAM_ADDRESS = 0xde121Cc755c1D1786Dd46FfF7e373e9372FD79D8;\n', '    address public TOKEN_DEFINER = 0xF1b9ad5D49d5829A0BdC698483CcBbF2179043C2;\n', '\n', '    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n', '    uint8 constant INVESTMENT_DAYS = 30;\n', '\n', '    uint128 constant THRESHOLD_LIMIT_MIN = 1 ether;\n', '    uint128 constant THRESHOLD_LIMIT_INFLUENCER = 50 ether;\n', '    uint128 constant THRESHOLD_LIMIT_SUPPER = 150 ether;\n', '\n', '    uint128 constant TEAM_ETHER_MAX = 2000 ether;\n', '    uint128 constant MIN_INVEST = 0.05 ether;\n', '    uint128 constant DAILY_MAX_SUPPLY = 10000000;\n', '\n', '    uint256 constant TESLAS_PER_SWAPP = 10 ** uint256(18);\n', '    uint256 constant NUM_RANDOM_BYTES_REQUESTED = 7;\n', '\n', '    struct Globals {\n', '        uint64 generatedDays;\n', '        uint64 generationDayBuffer;\n', '        uint64 generationTimeout;\n', '        uint64 preparedReferrals;\n', '        uint256 totalTransferTokens;\n', '        uint256 totalWeiContributed;\n', '        uint256 totalReferralTokens;\n', '    }\n', '\n', '    Globals public g;\n', '\n', '    mapping(uint256 => uint256) dailyMinSupply;\n', '    mapping(uint256 => uint256) public dailyTotalSupply;\n', '    mapping(uint256 => uint256) public dailyTotalInvestment;\n', '\n', '    mapping(uint256 => uint256) public investorAccountCount;\n', '    mapping(uint256 => mapping(uint256 => address)) public investorAccounts;\n', '    mapping(address => mapping(uint256 => uint256)) public investorBalances;\n', '\n', '    mapping(address => uint256) public referralAmount;\n', '    mapping(address => uint256) public referralTokens;\n', '    mapping(address => uint256) public investorTotalBalance;\n', '    mapping(address => uint256) originalInvestment;\n', '\n', '    uint32 public totalInvestorCount;\n', '\n', '    uint256 public referralAccountCount;\n', '    \n', '    mapping (uint256 => address) public referralAccounts;\n', '\n', '    event GeneratedSupply(\n', '        uint256 indexed investmentDay,\n', '        uint256 supply\n', '    );\n', '\n', '    event GenerationStatus(\n', '        uint64 indexed investmentDay,\n', '        bool result\n', '    );\n', '\n', '    event LogNewProvableQuery(\n', '        string description\n', '    );\n', '\n', '    event ReferralAdded(\n', '        address indexed referral,\n', '        address indexed referee,\n', '        uint256 amount\n', '    );\n', '\n', '    event UniSwapResult(\n', '        uint256 amountToken,\n', '        uint256 amountETH,\n', '        uint256 liquidity\n', '    );\n', '\n', '    event SwappReservation(\n', '        address indexed sender,\n', '        uint256 indexed investmentDay,\n', '        uint256 amount\n', '    );\n', '\n', '    modifier afterInvestmentPhase() {\n', '        require(\n', '            _currentSwappDay() > INVESTMENT_DAYS,\n', "            'SWAPP: ongoing investment phase'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier afterUniswapTransfer() {\n', '        require (\n', '            g.generatedDays > 0 &&\n', '            g.totalWeiContributed == 0,\n', "            'SWAPP: forward liquidity first'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier investmentDaysRange(uint256 _investmentDay) {\n', '        require(\n', '            _investmentDay > 0 &&\n', '            _investmentDay <= INVESTMENT_DAYS,\n', "            'SWAPP: not in initial investment days range'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier investmentEntryAmount(uint256 _days) {\n', '        require(\n', '            msg.value >= MIN_INVEST * _days,\n', "            'SWAPP: investment below minimum'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyFundedDays(uint256 _investmentDay) {\n', '        require(\n', '            dailyTotalInvestment[_investmentDay] > 0,\n', "            'SWAPP: no investments on that day'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyTokenDefiner() {\n', '        require(\n', '            msg.sender == TOKEN_DEFINER,\n', "            'SWAPP: wrong sender'\n", '        );\n', '        _;\n', '    }\n', '\n', '    receive() external payable {\n', '        require (\n', '            msg.sender == address(UNISWAP_ROUTER) ||\n', '            msg.sender == TEAM_ADDRESS ||\n', '            msg.sender == TOKEN_DEFINER,\n', "            'SWAPP: direct deposits disabled'\n", '        );\n', '    }\n', '\n', '    function defineToken(\n', '        address _swappToken\n', '    ) external onlyTokenDefiner {\n', '        SWAPP_CONTRACT = ISwappToken(_swappToken);\n', '    }\n', '\n', '    function revokeAccess() external onlyTokenDefiner {\n', '        TOKEN_DEFINER = address(0x0);\n', '    }\n', '\n', '    constructor() {\n', '        provable_setProof(proofType_Ledger);\n', '        provable_setCustomGasPrice(10000000000);\n', '\n', '        dailyMinSupply[1] = 5000000;\n', '        dailyMinSupply[2] = 5000000;\n', '        dailyMinSupply[3] = 3300000;\n', '        dailyMinSupply[4] = 4500000;\n', '        dailyMinSupply[5] = 5000000;\n', '        dailyMinSupply[6] = 4500000;\n', '        dailyMinSupply[7] = 5000000;\n', '        dailyMinSupply[8] = 2500000;\n', '        dailyMinSupply[9] = 5000000;\n', '        dailyMinSupply[10] = 5000000;\n', '\n', '        dailyMinSupply[11] = 3500000;\n', '        dailyMinSupply[12] = 5000000;\n', '        dailyMinSupply[13] = 3500000;\n', '        dailyMinSupply[14] = 3400000;\n', '        dailyMinSupply[15] = 5000000;\n', '        dailyMinSupply[16] = 5000000;\n', '        dailyMinSupply[17] = 3000000;\n', '        dailyMinSupply[18] = 5000000;\n', '        dailyMinSupply[19] = 3000000;\n', '        dailyMinSupply[20] = 5000000;\n', '\n', '        dailyMinSupply[21] = 3000000;\n', '        dailyMinSupply[22] = 5000000;\n', '        dailyMinSupply[23] = 2500000;\n', '        dailyMinSupply[24] = 5000000;\n', '        dailyMinSupply[25] = 2200000;\n', '        dailyMinSupply[26] = 5000000;\n', '        dailyMinSupply[27] = 3200000;\n', '        dailyMinSupply[28] = 5000000;\n', '        dailyMinSupply[29] = 7900000;\n', '        dailyMinSupply[30] = 5000000;\n', '    }\n', '\n', '    //  SWAPP RESERVATION (EXTERNAL FUNCTIONS)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @dev Performs reservation of SWAPP tokens with ETH\n', '      * @param _investmentDays array of reservation days.\n', '      * @param _referralAddress referral address for bonus.\n', '      */\n', '    function reserveSwapp(\n', '        uint8[] calldata _investmentDays,\n', '        address _referralAddress\n', '    ) external payable investmentEntryAmount(_investmentDays.length) {\n', '        checkInvestmentDays(\n', '            _investmentDays,\n', '            _currentSwappDay()\n', '        );\n', '\n', '        _reserveSwapp(\n', '            _investmentDays,\n', '            _referralAddress,\n', '            msg.sender,\n', '            msg.value\n', '        );\n', '    }\n', '\n', '    //  SWAPP RESERVATION (INTERNAL FUNCTIONS)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Distributes ETH equaly between selected reservation days\n', '      * @dev this will require LT contract to be approved as a spender\n', '      * @param _investmentDays array of selected reservation days\n', '      * @param _referralAddress referral address for bonus\n', '      * @param _senderAddress address of the investor\n', '      * @param _senderValue amount of ETH contributed\n', '      */\n', '    function _reserveSwapp(\n', '        uint8[] memory _investmentDays,\n', '        address _referralAddress,\n', '        address _senderAddress,\n', '        uint256 _senderValue\n', '    ) internal {\n', '        require(\n', '            _senderAddress != _referralAddress,\n', "            'SWAPP: must be a different address'\n", '        );\n', '\n', '        require(\n', '            notContract(_referralAddress),\n', "            'SWAPP: invalid referral address'\n", '        );\n', '\n', '        uint256 _investmentBalance = _referralAddress == address(0x0)\n', '            ? _senderValue // no referral bonus\n', '            : _senderValue.mul(1100).div(1000); // 10% referral bonus\n', '\n', '        uint256 _totalDays = _investmentDays.length;\n', '        uint256 _dailyAmount = _investmentBalance.div(_totalDays);\n', '        uint256 _leftOver = _investmentBalance.mod(_totalDays);\n', '\n', '        _addBalance(\n', '            _senderAddress,\n', '            _investmentDays[0],\n', '            _dailyAmount.add(_leftOver)\n', '        );\n', '\n', '        for (uint8 _i = 1; _i < _totalDays; _i++) {\n', '            _addBalance(\n', '                _senderAddress,\n', '                _investmentDays[_i],\n', '                _dailyAmount\n', '            );\n', '        }\n', '\n', '        _trackInvestors(\n', '            _senderAddress,\n', '            _investmentBalance\n', '        );\n', '\n', '        if (_referralAddress != address(0x0)) {\n', '\n', '            _trackReferrals(_referralAddress, _senderValue);\n', '\n', '            emit ReferralAdded(\n', '                _referralAddress,\n', '                _senderAddress,\n', '                _senderValue\n', '            );\n', '        }\n', '\n', '        originalInvestment[_senderAddress] += _senderValue;\n', '        g.totalWeiContributed += _senderValue;\n', '    }\n', '\n', '    /** @notice Allocates investors balance to specific day\n', '      * @param _senderAddress investors wallet address\n', '      * @param _investmentDay selected investment day\n', '      * @param _investmentBalance amount invested (with bonus)\n', '      */\n', '    function _addBalance(\n', '        address _senderAddress,\n', '        uint256 _investmentDay,\n', '        uint256 _investmentBalance\n', '    ) internal {\n', '        if (investorBalances[_senderAddress][_investmentDay] == 0) {\n', '            investorAccounts[_investmentDay][investorAccountCount[_investmentDay]] = _senderAddress;\n', '            investorAccountCount[_investmentDay]++;\n', '        }\n', '\n', '        investorBalances[_senderAddress][_investmentDay] += _investmentBalance;\n', '        dailyTotalInvestment[_investmentDay] += _investmentBalance;\n', '\n', '        emit SwappReservation(\n', '            _senderAddress,\n', '            _investmentDay,\n', '            _investmentBalance\n', '        );\n', '    }\n', '\n', '    //  SWAPP RESERVATION (PRIVATE FUNCTIONS)  //\n', '    //  ------------------------------------  //\n', '\n', '    /** @notice Tracks investorTotalBalance\n', '      * @dev used in _reserveSwapp() internal function\n', '      * @param _investorAddress address of the investor\n', '      * @param _value ETH amount invested (with bonus)\n', '      */\n', '    function _trackInvestors(address _investorAddress, uint256 _value) private {\n', '        if (investorTotalBalance[_investorAddress] == 0) {\n', '            totalInvestorCount++;\n', '        }\n', '        investorTotalBalance[_investorAddress] += _value;\n', '    }\n', '\n', '    /** @notice Tracks referralAmount and referralAccounts\n', '      * @dev used in _reserveSwapp() internal function\n', '      * @param _referralAddress address of the referrer\n', '      * @param _value ETH amount referred during reservation\n', '      */\n', '    function _trackReferrals(address _referralAddress, uint256 _value) private {\n', '        if (referralAmount[_referralAddress] == 0) {\n', '            referralAccounts[referralAccountCount] = _referralAddress;\n', '            referralAccountCount++;\n', '        }\n', '        referralAmount[_referralAddress] += _value;\n', '    }\n', '\n', '    //  SUPPLY GENERATION (EXTERNAL FUNCTION)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Allows to generate supply for past funded days\n', '      * @param _investmentDay investemnt day index (1-30)\n', '      */\n', '    function generateSupply(\n', '        uint64 _investmentDay\n', '    ) external investmentDaysRange(_investmentDay) onlyFundedDays(_investmentDay) {\n', '        require(\n', '            _investmentDay < _currentSwappDay(),\n', "            'SWAPP: investment day must be in past'\n", '        );\n', '\n', '        require(\n', '            g.generationDayBuffer == 0,\n', "            'SWAPP: supply generation in progress'\n", '        );\n', '\n', '        require(\n', '            dailyTotalSupply[_investmentDay] == 0,\n', "            'SWAPP: supply already generated'\n", '        );\n', '\n', '        g.generationDayBuffer = _investmentDay;\n', '        g.generationTimeout = uint64(block.timestamp.add(2 hours));\n', '\n', '        dailyMinSupply[_investmentDay] == 1\n', '            ? _generateRandomSupply(_investmentDay)\n', '            : _generateStaticSupply(_investmentDay);\n', '    }\n', '\n', '    //  SUPPLY GENERATION (INTERNAL FUNCTIONS)  //\n', '    //  --------------------------------------  //\n', '\n', '    /** @notice Generates supply for days with static supply\n', '      * @param _investmentDay investemnt day index (1-30)\n', '      */\n', '    function _generateStaticSupply(\n', '        uint256 _investmentDay\n', '    ) internal {\n', '        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay] * TESLAS_PER_SWAPP;\n', '        g.totalTransferTokens += dailyTotalSupply[_investmentDay];\n', '\n', '        g.generatedDays++;\n', '        g.generationDayBuffer = 0;\n', '        g.generationTimeout = 0;\n', '\n', '        emit GeneratedSupply(\n', '            _investmentDay,\n', '            dailyTotalSupply[_investmentDay]\n', '        );\n', '    }\n', '\n', '    /** @notice Generates supply for days with random supply\n', '      * @dev uses provable api to request provable_newRandomDSQuery\n', '      * @param _investmentDay investemnt day index (1-30)\n', '      */\n', '    function _generateRandomSupply(\n', '        uint256 _investmentDay\n', '    ) internal {\n', '        uint256 QUERY_EXECUTION_DELAY = 0;\n', '        uint256 GAS_FOR_CALLBACK = 200000;\n', '        provable_newRandomDSQuery(\n', '            QUERY_EXECUTION_DELAY,\n', '            NUM_RANDOM_BYTES_REQUESTED,\n', '            GAS_FOR_CALLBACK\n', '        );\n', '\n', '        emit LogNewProvableQuery("Provable query was sent, standing by for the answer...");\n', '    }\n', '\n', '    //  SUPPLY GENERATION (ORACLE FUNCTIONS)  //\n', '    //  ------------------------------------  //\n', '\n', '    /** @notice Function that generates random supply\n', '      * @dev expected to be called by oracle within 2 hours\n', '      * time-frame, otherwise __timeout() can be performed\n', '      */\n', '    function __callback(\n', '        bytes32 _queryId,\n', '        string memory _result,\n', '        bytes memory _proof\n', '    ) public override {\n', '        require(\n', '            msg.sender == provable_cbAddress(),\n', "            'SWAPP: can only be called by Oracle'\n", '        );\n', '\n', '        require(\n', '            g.generationDayBuffer > 0 &&\n', '            g.generationDayBuffer <= INVESTMENT_DAYS,\n', "            'SWAPP: incorrect generation day'\n", '        );\n', '\n', '        if (\n', '            provable_randomDS_proofVerify__returnCode(\n', '                _queryId,\n', '                _result,\n', '                _proof\n', '            ) != 0\n', '        ) {\n', '            g.generationDayBuffer = 0;\n', '            g.generationTimeout = 0;\n', '\n', '            emit GenerationStatus(\n', '                g.generationDayBuffer, false\n', '            );\n', '        } else {\n', '            g.generatedDays = g.generatedDays + 1;\n', '            uint256 _investmentDay = g.generationDayBuffer;\n', '\n', '            uint256 currentDayMaxSupply = DAILY_MAX_SUPPLY.sub(dailyMinSupply[_investmentDay]);\n', '            uint256 ceilingDayMaxSupply = currentDayMaxSupply.sub(dailyMinSupply[_investmentDay]);\n', '\n', '            uint256 randomSupply = uint256(\n', '                keccak256(\n', '                    abi.encodePacked(_result)\n', '                )\n', '            ) % ceilingDayMaxSupply;\n', '\n', '            require(\n', '                dailyTotalSupply[_investmentDay] == 0,\n', "                'SWAPP: supply already generated!'\n", '            );\n', '\n', '            dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay]\n', '                .add(randomSupply)\n', '                .mul(TESLAS_PER_SWAPP);\n', '\n', '            g.totalTransferTokens = g.totalTransferTokens\n', '                .add(dailyTotalSupply[_investmentDay]);\n', '\n', '            emit GeneratedSupply(\n', '                _investmentDay,\n', '                dailyTotalSupply[_investmentDay]\n', '            );\n', '\n', '            emit GenerationStatus(\n', '                g.generationDayBuffer, true\n', '            );\n', '\n', '            g.generationDayBuffer = 0;\n', '            g.generationTimeout = 0;\n', '        }\n', '    }\n', '\n', '    /** @notice Allows to reset expected oracle callback\n', '      * @dev resets generationDayBuffer to retry callback\n', '      * assigns static supply if no callback within a day\n', '      */\n', '    function __timeout() external {\n', '        require(\n', '            g.generationTimeout > 0 &&\n', '            g.generationTimeout < block.timestamp,\n', "            'SWAPP: still awaiting!'\n", '        );\n', '\n', '        uint64 _investmentDay = g.generationDayBuffer;\n', '\n', '        require(\n', '            _investmentDay > 0 &&\n', '            _investmentDay <= INVESTMENT_DAYS,\n', "            'SWAPP: incorrect generation day'\n", '        );\n', '\n', '        require(\n', '            dailyTotalSupply[_investmentDay] == 0,\n', "            'SWAPP: supply already generated!'\n", '        );\n', '\n', '        if (_currentSwappDay() - _investmentDay > 1) {\n', '\n', '            dailyTotalSupply[_investmentDay] = dailyMinSupply[1]\n', '                .mul(TESLAS_PER_SWAPP);\n', '\n', '            g.totalTransferTokens = g.totalTransferTokens\n', '                .add(dailyTotalSupply[_investmentDay]);\n', '\n', '            g.generatedDays = g.generatedDays + 1;\n', '\n', '            emit GeneratedSupply(\n', '                _investmentDay,\n', '                dailyTotalSupply[_investmentDay]\n', '            );\n', '\n', '            emit GenerationStatus(\n', '                _investmentDay, true\n', '            );\n', '\n', '        } else {\n', '            emit GenerationStatus(\n', '                _investmentDay, false\n', '            );\n', '        }\n', '        g.generationDayBuffer = 0;\n', '        g.generationTimeout = 0;\n', '    }\n', '\n', '    //  PRE-LIQUIDITY GENERATION FUNCTION  //\n', '    //  ---------------------------------  //\n', '\n', '    /** @notice Pre-calculates amount of tokens each referrer will get\n', '      * @dev must run this for all referrer addresses in batches\n', '      * converts _referralAmount to _referralTokens based on dailyRatio\n', '      */\n', '    function prepareReferralBonuses(\n', '        uint256 _referralBatchFrom,\n', '        uint256 _referralBatchTo\n', '    ) external afterInvestmentPhase {\n', '        require(\n', '            _referralBatchFrom < _referralBatchTo,\n', "            'SWAPP: incorrect referral batch'\n", '        );\n', '\n', '        require (\n', '            g.preparedReferrals < referralAccountCount,\n', "            'SWAPP: all referrals already prepared'\n", '        );\n', '\n', '        uint256 _totalRatio = g.totalTransferTokens.div(g.totalWeiContributed);\n', '\n', '        for (uint256 i = _referralBatchFrom; i < _referralBatchTo; i++) {\n', '            address _referralAddress = referralAccounts[i];\n', '            uint256 _referralAmount = referralAmount[_referralAddress];\n', '            if (referralAmount[_referralAddress] > 0) {\n', '                referralAmount[_referralAddress] = 0;\n', '                if (_referralAmount >= THRESHOLD_LIMIT_MIN) {\n', '                    if (_referralAmount >= THRESHOLD_LIMIT_INFLUENCER) {\n', '                        _referralAmount >= THRESHOLD_LIMIT_SUPPER\n', '                            ? _supperReferralBonus(_referralAddress, _referralAmount, _totalRatio)\n', '                            : _influencerReferralBonus(_referralAddress, _referralAmount, _totalRatio);\n', '                    } else {\n', '                        _familyReferralBonus(_referralAddress, _totalRatio);\n', '                    }\n', '                    g.totalReferralTokens = g.totalReferralTokens.add(\n', '                        referralTokens[_referralAddress]\n', '                    );\n', '                }\n', '                g.preparedReferrals++;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /** @notice performs token allocation for 12.5% of referral amount\n', '      * @dev after liquidity is formed referrer can withdraw this amount\n', '      * additionally this will give CM status to the referrer address\n', '      */\n', '    function _supperReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\n', '        referralTokens[_referralAddress] = _referralAmount.mul(_ratio).mul(1250).div(10000);\n', '        SWAPP_CONTRACT.giveStatus(_referralAddress);\n', '    }\n', '\n', '    /** @notice performs token allocation for 10% of referral amount\n', '      * @dev after liquidity is formed referrer can withdraw this amount\n', '      * additionally this will give CM status to the referrer address\n', '      */\n', '    function _influencerReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\n', '        referralTokens[_referralAddress] = _referralAmount.div(10).mul(_ratio);\n', '        SWAPP_CONTRACT.giveStatus(_referralAddress);\n', '    }\n', '\n', '    /** @notice performs token allocation for family bonus referrals\n', '      * @dev after liquidity is formed referrer can withdraw this amount\n', '      */\n', '    function _familyReferralBonus(address _referralAddress, uint256 _ratio) internal {\n', '        referralTokens[_referralAddress] = MIN_INVEST.mul(_ratio);\n', '    }\n', '\n', '    //  LIQUIDITY GENERATION FUNCTION  //\n', '    //  -----------------------------  //\n', '\n', '    /** @notice Creates initial liquidity on Uniswap by forwarding\n', '      * reserved tokens equivalent to ETH contributed to the contract\n', '      * @dev check addLiquidityETH documentation\n', '      */\n', '    function forwardLiquidity() external afterInvestmentPhase {\n', '        require(\n', '            g.generatedDays == fundedDays(),\n', "            'SWAPP: must generate supply for all days'\n", '        );\n', '\n', '        uint256 _balance = g.totalWeiContributed;\n', '        uint256 _buffer = g.totalTransferTokens + g.totalReferralTokens;\n', '\n', '        _balance = _balance.sub(\n', '            _teamContribution(\n', '                _balance.div(10)\n', '            )\n', '        );\n', '\n', '        _buffer = _buffer.mul(_balance).div(\n', '            g.totalWeiContributed\n', '        );\n', '\n', '        SWAPP_CONTRACT.mintSupply(\n', '            address(this), _buffer\n', '        );\n', '\n', '        SWAPP_CONTRACT.approve(\n', '            address(UNISWAP_ROUTER), _buffer\n', '        );\n', '\n', '        (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        ) = UNISWAP_ROUTER.addLiquidityETH{value: _balance}(\n', '            address(SWAPP_CONTRACT),\n', '            _buffer,\n', '            0,\n', '            0,\n', '            address(0x0),\n', '            block.timestamp.add(2 hours)\n', '        );\n', '\n', '        g.totalTransferTokens = 0;\n', '        g.totalReferralTokens = 0;\n', '        g.totalWeiContributed = 0;\n', '\n', '        emit UniSwapResult(\n', '            amountToken, amountETH, liquidity\n', '        );\n', '    }\n', '\n', '    //  SWAPP TOKEN PAYOUT FUNCTIONS (INDIVIDUAL)  //\n', '    //  ----------------------------------------  //\n', '\n', '    /** @notice Allows to mint all the tokens\n', '      * from investor and referrer perspectives\n', '      * @dev can be called after forwardLiquidity()\n', '      */\n', '    function getMyTokens() external afterUniswapTransfer {\n', '        payoutInvestorAddress(msg.sender);\n', '        payoutReferralAddress(msg.sender);\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for specific investor address\n', '      * @dev aggregades investors tokens across all investment days\n', '      * and uses SWAPP_CONTRACT instance to mint all the SWAPP tokens\n', '      * @param _investorAddress requested investor calculation address\n', '      * @return _payout amount minted to the investors address\n', '      */\n', '    function payoutInvestorAddress(\n', '        address _investorAddress\n', '    ) public afterUniswapTransfer returns (uint256 _payout) {\n', '        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            if (investorBalances[_investorAddress][i] > 0) {\n', '                _payout += investorBalances[_investorAddress][i].mul(\n', '                    _calculateDailyRatio(i)\n', '                ).div(100E18);\n', '                investorBalances[_investorAddress][i] = 0;\n', '            }\n', '        }\n', '        if (_payout > 0) {\n', '            SWAPP_CONTRACT.mintSupply(\n', '                _investorAddress,\n', '                _payout\n', '            );\n', '        }\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for specific referrer address\n', '      * @dev must be pre-calculated in prepareReferralBonuses()\n', '      * @param _referralAddress referrer payout address\n', '      * @return _referralTokens amount minted to the referrer address\n', '      */\n', '    function payoutReferralAddress(\n', '        address _referralAddress\n', '    ) public afterUniswapTransfer returns (uint256 _referralTokens) {\n', '        _referralTokens = referralTokens[_referralAddress];\n', '        if (referralTokens[_referralAddress] > 0) {\n', '            referralTokens[_referralAddress] = 0;\n', '            SWAPP_CONTRACT.mintSupply(\n', '                _referralAddress,\n', '                _referralTokens\n', '            );\n', '        }\n', '    }\n', '\n', '    //  SWAPP TOKEN PAYOUT FUNCTIONS (BATCHES)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Allows to mint tokens for specific investment day\n', '      * recommended batch size is up to 50 addresses per call\n', '      * @param _investmentDay processing investment day\n', '      * @param _investorBatchFrom batch starting index\n', '      * @param _investorBatchTo bach finishing index\n', '      */\n', '    function payoutInvestmentDayBatch(\n', '        uint256 _investmentDay,\n', '        uint256 _investorBatchFrom,\n', '        uint256 _investorBatchTo\n', '    ) external afterUniswapTransfer onlyFundedDays(_investmentDay) {\n', '        require(\n', '            _investorBatchFrom < _investorBatchTo,\n', "            'SWAPP: incorrect investment batch'\n", '        );\n', '\n', '        uint256 _dailyRatio = _calculateDailyRatio(_investmentDay);\n', '\n', '        for (uint256 i = _investorBatchFrom; i < _investorBatchTo; i++) {\n', '            address _investor = investorAccounts[_investmentDay][i];\n', '            uint256 _balance = investorBalances[_investor][_investmentDay];\n', '            uint256 _payout = _balance.mul(_dailyRatio).div(100E18);\n', '\n', '            if (investorBalances[_investor][_investmentDay] > 0) {\n', '                investorBalances[_investor][_investmentDay] = 0;\n', '                SWAPP_CONTRACT.mintSupply(\n', '                    _investor,\n', '                    _payout\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for referrers in batches\n', '      * @dev can be called right after forwardLiquidity()\n', '      * recommended batch size is up to 50 addresses per call\n', '      * @param _referralBatchFrom batch starting index\n', '      * @param _referralBatchTo bach finishing index\n', '      */\n', '    function payoutReferralBatch(\n', '        uint256 _referralBatchFrom,\n', '        uint256 _referralBatchTo\n', '    ) external afterUniswapTransfer {\n', '        require(\n', '            _referralBatchFrom < _referralBatchTo,\n', "            'SWAPP: incorrect referral batch'\n", '        );\n', '\n', '        for (uint256 i = _referralBatchFrom; i < _referralBatchTo; i++) {\n', '            address _referralAddress = referralAccounts[i];\n', '            uint256 _referralTokens = referralTokens[_referralAddress];\n', '            if (referralTokens[_referralAddress] > 0) {\n', '                referralTokens[_referralAddress] = 0;\n', '                SWAPP_CONTRACT.mintSupply(\n', '                    _referralAddress,\n', '                    _referralTokens\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    //  INFO VIEW FUNCTIONS (PERSONAL)  //\n', '    //  ------------------------------  //\n', '\n', '    /** @notice checks for callers investment amount on each day (with bonus)\n', '      * @return _userAllDays total amount invested across all days (with bonus)\n', '      */\n', '    function userInvestmentAmountAllDays(address _investor) external view returns (uint256[31] memory _userAllDays) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _userAllDays[i] = investorBalances[_investor][i];\n', '        }\n', '    }\n', '\n', '    /** @notice checks for callers total investment amount (with bonus)\n', '      * @return total amount invested across all investment days (with bonus)\n', '      */\n', '    function userTotalInvestmentAmount(address _investor) external view returns (uint256) {\n', '        return investorTotalBalance[_investor];\n', '    }\n', '\n', '    //  INFO VIEW FUNCTIONS (GLOBAL)  //\n', '    //  ----------------------------  //\n', '\n', '    /** @notice checks for investors count on specific day\n', '      * @return investors count for specific day\n', '      */\n', '    function investorsOnDay(uint256 _investmentDay) public view returns (uint256) {\n', '        return dailyTotalInvestment[_investmentDay] > 0 ? investorAccountCount[_investmentDay] : 0;\n', '    }\n', '\n', '    /** @notice checks for investors count on each day\n', '      * @return _allInvestors array with investors count for each day\n', '      */\n', '    function investorsOnAllDays() external view returns (uint256[31] memory _allInvestors) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allInvestors[i] = investorsOnDay(i);\n', '        }\n', '    }\n', '\n', '    /** @notice checks for investment amount on each day\n', '      * @return _allInvestments array with investment amount for each day\n', '      */\n', '    function investmentsOnAllDays() external view returns (uint256[31] memory _allInvestments) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allInvestments[i] = dailyTotalInvestment[i];\n', '        }\n', '    }\n', '\n', '    /** @notice checks for supply amount on each day\n', '      * @return _allSupply array with supply amount for each day\n', '      */\n', '    function supplyOnAllDays() external view returns (uint256[31] memory _allSupply) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allSupply[i] = dailyTotalSupply[i];\n', '        }\n', '    }\n', '\n', '    //  HELPER FUNCTIONS (PURE)  //\n', '    //  -----------------------  //\n', '\n', '    /** @notice checks that provided days are valid for investemnt\n', '      * @dev used in reserveSwapp() and reserveSwappWithToken()\n', '      */\n', '    function checkInvestmentDays(\n', '        uint8[] memory _investmentDays,\n', '        uint64 _swappDay\n', '    ) internal pure {\n', '        for (uint8 _i = 0; _i < _investmentDays.length; _i++) {\n', '            require(\n', '                _investmentDays[_i] >= _swappDay,\n', "                'SWAPP: investment day already passed'\n", '            );\n', '            require(\n', '                _investmentDays[_i] > 0 &&\n', '                _investmentDays[_i] <= INVESTMENT_DAYS,\n', "                'SWAPP: incorrect investment day'\n", '            );\n', '        }\n', '    }\n', '\n', '    /** @notice prepares path variable for uniswap to exchange tokens\n', '      * @dev used in reserveSwappWithToken() swapExactTokensForETH call\n', '      * @param _tokenAddress ERC20 token address to be swapped for ETH\n', '      * @return _path that is used to swap tokens for ETH on uniswap\n', '      */\n', '    function preparePath(\n', '        address _tokenAddress\n', '    ) internal pure returns (address[] memory _path) {\n', '        _path = new address[](2);\n', '        _path[0] = _tokenAddress;\n', '        _path[1] = WETH;\n', '    }\n', '\n', '    /** @notice keeps team contribution at caped level\n', '      * @dev subtracts amount during forwardLiquidity()\n', '      * @return ETH amount the team is allowed to withdraw\n', '      */\n', '    function _teamContribution(\n', '        uint256 _teamAmount\n', '    ) internal pure returns (uint256) {\n', '        return _teamAmount > TEAM_ETHER_MAX ? TEAM_ETHER_MAX : _teamAmount;\n', '    }\n', '\n', '    /** @notice checks for invesments on all days\n', '      * @dev used in forwardLiquidity() requirements\n', '      * @return $fundedDays - amount of funded days 0-30\n', '      */\n', '    function fundedDays() public view returns (uint8 $fundedDays) {\n', '        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            if (dailyTotalInvestment[i] > 0) $fundedDays++;\n', '        }\n', '    }\n', '\n', '    /** @notice SWAPP equivalent in ETH price calculation\n', '      * @dev returned value has 100E18 precision - divided later on\n', '      * @return token price for specific day based on total investement\n', '      */\n', '    function _calculateDailyRatio(\n', '        uint256 _investmentDay\n', '    ) internal view returns (uint256) {\n', '\n', '        uint256 dailyRatio = dailyTotalSupply[_investmentDay].mul(100E18)\n', '            .div(dailyTotalInvestment[_investmentDay]);\n', '\n', '        uint256 remainderCheck = dailyTotalSupply[_investmentDay].mul(100E18)\n', '            .mod(dailyTotalInvestment[_investmentDay]);\n', '\n', '        return remainderCheck == 0 ? dailyRatio : dailyRatio.add(1);\n', '    }\n', '\n', '    //  TIMING FUNCTIONS  //\n', '    //  ----------------  //\n', '\n', '    /** @notice shows current day of SwappToken\n', '      * @dev value is fetched from SWAPP_CONTRACT\n', '      * @return iteration day since SWAPP inception\n', '      */\n', '    function _currentSwappDay() public view returns (uint64) {\n', '        return SWAPP_CONTRACT.currentSwappDay();\n', '    }\n', '\n', '    //  EMERGENCY REFUND FUNCTIONS  //\n', '    //  --------------------------  //\n', '\n', '    /** @notice allows refunds if funds are stuck\n', '      * @param _investor address to be refunded\n', '      * @return _amount refunded to the investor\n', '      */\n', '    function requestRefund(\n', '        address payable _investor,\n', '        address payable _succesor\n', '    ) external returns (uint256 _amount) {\n', '        require(\n', '            g.totalWeiContributed > 0  &&\n', '            originalInvestment[_investor] > 0 &&\n', '            _currentSwappDay() > INVESTMENT_DAYS + 10,\n', "           unicode'SWAPP: liquidity successfully forwarded to uniswap'\n", '        );\n', '\n', '        // refunds the investor\n', '        _amount = originalInvestment[_investor];\n', '        originalInvestment[_investor] = 0;\n', '        _succesor.transfer(_amount);\n', '\n', '        // deny possible comeback\n', '        g.totalTransferTokens = 0;\n', '    }\n', '\n', '    /** @notice allows to withdraw team funds for the work\n', '      * strictly only after the uniswap liquidity is formed\n', '      * @param _amount value to withdraw from the contract\n', '      */\n', '    function requestTeamFunds(\n', '        uint256 _amount\n', '    ) external {\n', '        TEAM_ADDRESS.transfer(_amount);\n', '    }\n', '\n', '    function notContract(address _addr) internal view returns (bool) {\n', '        uint32 size;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return (size == 0);\n', '    }\n', '\n', '}']