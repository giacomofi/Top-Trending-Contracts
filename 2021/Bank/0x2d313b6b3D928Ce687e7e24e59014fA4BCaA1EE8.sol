['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-13\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'interface INBU_WETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', 'interface IERC20Permit {\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'contract NimbusERC20P2P_V1 {    \n', '    struct Trade {\n', '        address initiator;\n', '        address counterparty;\n', '        address proposedAsset;\n', '        uint proposedAmount;\n', '        address askedAsset;\n', '        uint askedAmount;\n', '        uint deadline;\n', '        uint status; //0: Active, 1: success, 2: canceled, 3: withdrawn\n', '    }\n', '\n', '    enum TradeState {\n', '        Active,\n', '        Succeeded,\n', '        Canceled,\n', '        Withdrawn,\n', '        Overdue\n', '    }\n', '\n', '    INBU_WETH public immutable NBU_WETH;\n', '\n', '    uint public tradeCount;\n', '    mapping(uint => Trade) public trades;\n', '    mapping(address => uint[]) private _userTrades;\n', '\n', '    event NewTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline, uint tradeId);\n', '    event SupportTrade(uint tradeId, address counterparty);\n', '    event CancelTrade(uint tradeId);\n', '    event WithdrawOverdueAsset(uint tradeId);\n', '    \n', '    constructor(address nbuWeth) {\n', '        require(Address.isContract(nbuWeth), "NimbusERC20P2P_V1: Not contract");\n', '        NBU_WETH = INBU_WETH(nbuWeth);\n', '    }\n', '\n', '    receive() external payable {\n', '        assert(msg.sender == address(NBU_WETH)); // only accept ETH via fallback from the NBU_WETH contract\n', '    }\n', '\n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'NimbusERC20P2P_V1: locked');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    function createTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline) external returns (uint tradeId) {\n', '        require(Address.isContract(proposedAsset) && Address.isContract(askedAsset), "NimbusERC20P2P_V1: Not contracts");\n', '        TransferHelper.safeTransferFrom(proposedAsset, msg.sender, address(this), proposedAmount);\n', '        tradeId = _createTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline);   \n', '    }\n', '\n', '    function createTradeETH(address askedAsset, uint askedAmount, uint deadline) payable external returns (uint tradeId) {\n', '        require(Address.isContract(askedAsset), "NimbusERC20P2P_V1: Not contract");\n', '        NBU_WETH.deposit{value: msg.value}();\n', '        tradeId = _createTrade(address(NBU_WETH), msg.value, askedAsset, askedAmount, deadline);   \n', '    }\n', '\n', '    function createTradeWithPermit(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline, uint permitDeadline, uint8 v, bytes32 r, bytes32 s) external returns (uint tradeId) {\n', '        require(Address.isContract(proposedAsset) && Address.isContract(askedAsset), "NimbusERC20P2P_V1: Not contracts");\n', '        IERC20Permit(proposedAsset).permit(msg.sender, address(this), proposedAmount, permitDeadline, v, r, s);\n', '        TransferHelper.safeTransferFrom(proposedAsset, msg.sender, address(this), proposedAmount);\n', '        tradeId = _createTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline);   \n', '    }\n', '\n', '\n', '    function supportTrade(uint tradeId) external lock {\n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        require(trade.status == 0 && trade.deadline > block.timestamp, "NimbusERC20P2P_V1: not active trade");\n', '\n', '        TransferHelper.safeTransferFrom(trade.askedAsset, msg.sender, trade.initiator, trade.askedAmount);\n', '        _supportTrade(tradeId);\n', '    }\n', '\n', '    function supportTradeETH(uint tradeId) payable external lock {\n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        require(trade.status == 0 && trade.deadline > block.timestamp, "NimbusERC20P2P_V1: not active trade");\n', '        require(msg.value >= trade.askedAmount, "NimbusERC20P2P_V1: Not enough ETH sent");\n', '        require(trade.askedAsset == address(NBU_WETH), "NimbusERC20P2P_V1: ERC20 trade");\n', '\n', '        TransferHelper.safeTransferETH(trade.initiator, trade.askedAmount);\n', '        if (msg.value > trade.askedAmount) TransferHelper.safeTransferETH(msg.sender, msg.value - trade.askedAmount);\n', '        _supportTrade(tradeId);\n', '    }\n', '\n', '    function supportTradeWithPermit(uint tradeId, uint permitDeadline, uint8 v, bytes32 r, bytes32 s) external lock {\n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        require(trade.status == 0 && trade.deadline > block.timestamp, "NimbusERC20P2P_V1: not active trade");\n', '\n', '        IERC20Permit(trade.askedAsset).permit(msg.sender, address(this), trade.askedAmount, permitDeadline, v, r, s);\n', '        TransferHelper.safeTransferFrom(trade.askedAsset, msg.sender, trade.initiator, trade.askedAmount);\n', '        _supportTrade(tradeId);\n', '    }\n', '\n', '    function cancelTrade(uint tradeId) external lock { \n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        require(trade.initiator == msg.sender, "NimbusERC20P2P_V1: not allowed");\n', '        require(trade.status == 0 && trade.deadline > block.timestamp, "NimbusERC20P2P_V1: not active trade");\n', '        trade.status = 2;\n', '\n', '        if (trade.proposedAsset != address(NBU_WETH)) {\n', '            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\n', '        } else {\n', '            NBU_WETH.withdraw(trade.proposedAmount);\n', '            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\n', '        }\n', '\n', '        emit CancelTrade(tradeId);\n', '    }\n', '\n', '    function withdrawOverdueAsset(uint tradeId) external lock { \n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        require(trade.initiator == msg.sender, "NimbusERC20P2P_V1: not allowed");\n', '        require(trade.status == 0 && trade.deadline < block.timestamp, "NimbusERC20P2P_V1: not available for withdrawal");\n', '\n', '        if (trade.proposedAsset != address(NBU_WETH)) {\n', '            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\n', '        } else {\n', '            NBU_WETH.withdraw(trade.proposedAmount);\n', '            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\n', '        }\n', '\n', '        trade.status = 3;\n', '\n', '        emit WithdrawOverdueAsset(tradeId);\n', '    }\n', '\n', '    function state(uint tradeId) public view returns (TradeState) {\n', '        require(tradeCount >= tradeId && tradeId > 0, "NimbusERC20P2P_V1: invalid trade id");\n', '        Trade storage trade = trades[tradeId];\n', '        if (trade.status == 1) {\n', '            return TradeState.Succeeded;\n', '        } else if (trade.status == 2 || trade.status == 3) {\n', '            return TradeState(trade.status);\n', '        } else if (trade.deadline < block.timestamp) {\n', '            return TradeState.Overdue;\n', '        } else {\n', '            return TradeState.Active;\n', '        }\n', '    }\n', '\n', '    function userTrades(address user) public view returns (uint[] memory) {\n', '        return _userTrades[user];\n', '    }\n', '\n', '\n', '\n', '    function _createTrade(address proposedAsset, uint proposedAmount, address askedAsset, uint askedAmount, uint deadline) private returns (uint tradeId) { \n', '        require(askedAsset != proposedAsset, "NimbusERC20P2P_V1: asked asset can\'t be equal to proposed asset");\n', '        require(proposedAmount > 0, "NimbusERC20P2P_V1: zero proposed amount");\n', '        require(askedAmount > 0, "NimbusERC20P2P_V1: zero asked amount");\n', '        require(deadline > block.timestamp, "NimbusERC20P2P_V1: incorrect deadline");\n', '        tradeId = ++tradeCount;\n', '        Trade storage trade = trades[tradeId];\n', '        trade.initiator = msg.sender;\n', '        trade.proposedAsset = proposedAsset;\n', '        trade.proposedAmount = proposedAmount;\n', '        trade.askedAsset = askedAsset;\n', '        trade.askedAmount = askedAmount;\n', '        trade.deadline = deadline;\n', '        \n', '        _userTrades[msg.sender].push(tradeId);\n', '        \n', '        emit NewTrade(proposedAsset, proposedAmount, askedAsset, askedAmount, deadline, tradeId);\n', '    }\n', '\n', '    function _supportTrade(uint tradeId) private { \n', '        Trade storage trade = trades[tradeId];\n', '\n', '        if (trade.proposedAsset != address(NBU_WETH)) {\n', '            TransferHelper.safeTransfer(trade.proposedAsset, msg.sender, trade.proposedAmount);\n', '        } else {\n', '            NBU_WETH.withdraw(trade.proposedAmount);\n', '            TransferHelper.safeTransferETH(msg.sender, trade.proposedAmount);\n', '        }\n', '        trade.counterparty = msg.sender;\n', '        trade.status = 1;\n', '        emit SupportTrade(tradeId, msg.sender);\n', '    }\n', ' }']