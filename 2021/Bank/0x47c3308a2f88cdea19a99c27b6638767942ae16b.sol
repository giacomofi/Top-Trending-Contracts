['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-05\n', '*/\n', '\n', '// File: contracts/XVersion.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract XVersion {\n', '    function getVersion() external view returns (bytes32);\n', '}\n', '\n', 'contract XApollo is XVersion {\n', '    function getVersion() external view returns (bytes32) {\n', '        return bytes32("APOLLO");\n', '    }\n', '}\n', '\n', '// File: contracts/XConst.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract XConst {\n', '    uint256 public constant BONE = 10**18;\n', '\n', '    uint256 public constant MIN_BOUND_TOKENS = 2;\n', '    uint256 public constant MAX_BOUND_TOKENS = 8;\n', '\n', '    uint256 public constant EXIT_ZERO_FEE = 0;\n', '\n', '    uint256 public constant MIN_WEIGHT = BONE;\n', '    uint256 public constant MAX_WEIGHT = BONE * 50;\n', '    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n', '\n', '    // min effective value: 0.000001 TOKEN\n', '    uint256 public constant MIN_BALANCE = 10**6;\n', '\n', '    // BONE/(10**10) XPT\n', '    uint256 public constant MIN_POOL_AMOUNT = 10**8;\n', '\n', '    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n', '\n', '    uint256 public constant MAX_IN_RATIO = BONE / 2;\n', '    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n', '}\n', '\n', '// File: contracts/lib/XNum.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'library XNum {\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant MIN_BPOW_BASE = 1 wei;\n', '    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n', '    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n', '\n', '    function btoi(uint256 a) internal pure returns (uint256) {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint256 a) internal pure returns (uint256) {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        (uint256 c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint256 c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint256 c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint256 c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint256 c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint256 c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n', '        uint256 z = n % 2 != 0 ? a : BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint256 whole = bfloor(exp);\n', '        uint256 remain = bsub(exp, whole);\n', '\n', '        uint256 wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(\n', '        uint256 base,\n', '        uint256 exp,\n', '        uint256 precision\n', '    ) internal pure returns (uint256) {\n', '        // term 0:\n', '        uint256 a = exp;\n', '        (uint256 x, bool xneg) = bsubSign(base, BONE);\n', '        uint256 term = BONE;\n', '        uint256 sum = term;\n', '        bool negative = false;\n', '\n', '        // term(k) = numer / denom\n', '        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint256 i = 1; term >= precision; i++) {\n', '            uint256 bigK = i * BONE;\n', '            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '}\n', '\n', '// File: contracts/interface/IERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    ) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        external\n', '        view\n', '        returns (uint256 remaining);\n', '}\n', '\n', '// File: contracts/XPToken.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '// Highly opinionated token implementation\n', 'contract XTokenBase {\n', '    using XNum for uint256;\n', '\n', '    mapping(address => uint256) internal _balance;\n', '    mapping(address => mapping(address => uint256)) internal _allowance;\n', '    uint256 internal _totalSupply;\n', '\n', '    event Approval(address indexed src, address indexed dst, uint256 amt);\n', '    event Transfer(address indexed src, address indexed dst, uint256 amt);\n', '\n', '    function _mint(uint256 amt) internal {\n', '        _balance[address(this)] = (_balance[address(this)]).badd(amt);\n', '        _totalSupply = _totalSupply.badd(amt);\n', '        emit Transfer(address(0), address(this), amt);\n', '    }\n', '\n', '    function _burn(uint256 amt) internal {\n', '        require(_balance[address(this)] >= amt, "ERR_INSUFFICIENT_BAL");\n', '        _balance[address(this)] = (_balance[address(this)]).bsub(amt);\n', '        _totalSupply = _totalSupply.bsub(amt);\n', '        emit Transfer(address(this), address(0), amt);\n', '    }\n', '\n', '    function _move(\n', '        address src,\n', '        address dst,\n', '        uint256 amt\n', '    ) internal {\n', '        require(_balance[src] >= amt, "ERR_INSUFFICIENT_BAL");\n', '        _balance[src] = (_balance[src]).bsub(amt);\n', '        _balance[dst] = (_balance[dst]).badd(amt);\n', '        emit Transfer(src, dst, amt);\n', '    }\n', '}\n', '\n', 'contract XPToken is XTokenBase, IERC20, XApollo {\n', '    using XNum for uint256;\n', '\n', '    string private constant _name = "XDeFi Pool Token";\n', '    string private constant _symbol = "XPT";\n', '    uint8 private constant _decimals = 18;\n', '\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() external view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function allowance(address src, address dst)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowance[src][dst];\n', '    }\n', '\n', '    function balanceOf(address whom) external view returns (uint256) {\n', '        return _balance[whom];\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function approve(address dst, uint256 amt) external returns (bool) {\n', '        _allowance[msg.sender][dst] = amt;\n', '        emit Approval(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint256 amt) external returns (bool) {\n', '        _move(msg.sender, dst, amt);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address src,\n', '        address dst,\n', '        uint256 amt\n', '    ) external returns (bool) {\n', '        require(\n', '            msg.sender == src || amt <= _allowance[src][msg.sender],\n', '            "ERR_BTOKEN_BAD_CALLER"\n', '        );\n', '        _move(src, dst, amt);\n', '        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\n', '            _allowance[src][msg.sender] = (_allowance[src][msg.sender]).bsub(\n', '                amt\n', '            );\n', '            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/XMath.sol\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'library XMath {\n', '    using XNum for uint256;\n', '\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant EXIT_ZERO_FEE = 0;\n', '\n', '    /**********************************************************************************************\n', '    // calcSpotPrice                                                                             //\n', '    // sP = spotPrice                                                                            //\n', '    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\n', '    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\n', '    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee                                                                              //\n', '    **********************************************************************************************/\n', '    function calcSpotPrice(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 swapFee\n', '    ) public pure returns (uint256 spotPrice) {\n', '        uint256 numer = tokenBalanceIn.bdiv(tokenWeightIn);\n', '        uint256 denom = tokenBalanceOut.bdiv(tokenWeightOut);\n', '        uint256 ratio = numer.bdiv(denom);\n', '        uint256 scale = BONE.bdiv(BONE.bsub(swapFee));\n', '        return (spotPrice = ratio.bmul(scale));\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcOutGivenIn                                                                            //\n', '    // aO = tokenAmountOut                                                                       //\n', '    // bO = tokenBalanceOut                                                                      //\n', '    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\n', '    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\n', '    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\n', '    // wO = tokenWeightOut                                                                       //\n', '    // sF = swapFee                                                                              //\n', '    **********************************************************************************************/\n', '    function calcOutGivenIn(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 swapFee\n', '    ) public pure returns (uint256 tokenAmountOut) {\n', '        uint256 weightRatio;\n', '        if (tokenWeightIn == tokenWeightOut) {\n', '            weightRatio = 1 * BONE;\n', '        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\n', '            weightRatio = 2 * BONE;\n', '        } else {\n', '            weightRatio = tokenWeightIn.bdiv(tokenWeightOut);\n', '        }\n', '        uint256 adjustedIn = BONE.bsub(swapFee);\n', '        adjustedIn = tokenAmountIn.bmul(adjustedIn);\n', '        uint256 y = tokenBalanceIn.bdiv(tokenBalanceIn.badd(adjustedIn));\n', '        uint256 foo;\n', '        if (tokenWeightIn == tokenWeightOut) {\n', '            foo = y;\n', '        } else if (tokenWeightIn >> 1 == tokenWeightOut) {\n', '            foo = y.bmul(y);\n', '        } else {\n', '            foo = y.bpow(weightRatio);\n', '        }\n', '        uint256 bar = BONE.bsub(foo);\n', '        tokenAmountOut = tokenBalanceOut.bmul(bar);\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcInGivenOut                                                                            //\n', '    // aI = tokenAmountIn                                                                        //\n', '    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\n', '    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\n', '    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\n', '    // wI = tokenWeightIn           --------------------------------------------                 //\n', '    // wO = tokenWeightOut                          ( 1 - sF )                                   //\n', '    // sF = swapFee                                                                              //\n', '    **********************************************************************************************/\n', '    function calcInGivenOut(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 swapFee\n', '    ) public pure returns (uint256 tokenAmountIn) {\n', '        uint256 weightRatio;\n', '        if (tokenWeightOut == tokenWeightIn) {\n', '            weightRatio = 1 * BONE;\n', '        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\n', '            weightRatio = 2 * BONE;\n', '        } else {\n', '            weightRatio = tokenWeightOut.bdiv(tokenWeightIn);\n', '        }\n', '        uint256 diff = tokenBalanceOut.bsub(tokenAmountOut);\n', '        uint256 y = tokenBalanceOut.bdiv(diff);\n', '        uint256 foo;\n', '        if (tokenWeightOut == tokenWeightIn) {\n', '            foo = y;\n', '        } else if (tokenWeightOut >> 1 == tokenWeightIn) {\n', '            foo = y.bmul(y);\n', '        } else {\n', '            foo = y.bpow(weightRatio);\n', '        }\n', '        foo = foo.bsub(BONE);\n', '        tokenAmountIn = BONE.bsub(swapFee);\n', '        tokenAmountIn = tokenBalanceIn.bmul(foo).bdiv(tokenAmountIn);\n', '        return tokenAmountIn;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcPoolOutGivenSingleIn                                                                  //\n', '    // pAo = poolAmountOut         /                                              \\              //\n', '    // tAi = tokenAmountIn        ///      /     //    wI \\      \\\\       \\     wI \\             //\n', '    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\    --  \\            //\n', '    // tW = totalWeight     pAo=||  \\      \\     \\\\    tW /      //         | ^ tW   | * pS - pS //\n', '    // tBi = tokenBalanceIn      \\\\  ------------------------------------- /        /            //\n', '    // pS = poolSupply            \\\\                    tBi               /        /             //\n', '    // sF = swapFee                \\                                              /              //\n', '    **********************************************************************************************/\n', '    function calcPoolOutGivenSingleIn(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 poolSupply,\n', '        uint256 totalWeight,\n', '        uint256 tokenAmountIn,\n', '        uint256 swapFee\n', '    ) public pure returns (uint256 poolAmountOut) {\n', '        // Charge the trading fee for the proportion of tokenAi\n', '        ///  which is implicitly traded to the other pool tokens.\n', '        // That proportion is (1- weightTokenIn)\n', '        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\n', '        uint256 normalizedWeight = tokenWeightIn.bdiv(totalWeight);\n', '        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\n', '        uint256 tokenAmountInAfterFee = tokenAmountIn.bmul(BONE.bsub(zaz));\n', '\n', '        uint256 newTokenBalanceIn = tokenBalanceIn.badd(tokenAmountInAfterFee);\n', '        uint256 tokenInRatio = newTokenBalanceIn.bdiv(tokenBalanceIn);\n', '\n', '        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\n', '        uint256 poolRatio = tokenInRatio.bpow(normalizedWeight);\n', '        uint256 newPoolSupply = poolRatio.bmul(poolSupply);\n', '        poolAmountOut = newPoolSupply.bsub(poolSupply);\n', '        return poolAmountOut;\n', '    }\n', '\n', '    /**********************************************************************************************\n', '    // calcSingleOutGivenPoolIn                                                                  //\n', '    // tAo = tokenAmountOut            /      /                                             \\\\   //\n', '    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /    1    \\      \\\\  //\n', '    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\n', '    // ps = poolSupply                \\      \\\\          pS           /     \\(wO / tW)/      //  //\n', '    // wI = tokenWeightIn      tAo =   \\      \\                                             //   //\n', '    // tW = totalWeight                    /     /      wO \\       \\                             //\n', '    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\n', '    // eF = exitFee                        \\     \\      tW /       /                             //\n', '    **********************************************************************************************/\n', '    function calcSingleOutGivenPoolIn(\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 poolSupply,\n', '        uint256 totalWeight,\n', '        uint256 poolAmountIn,\n', '        uint256 swapFee\n', '    ) public pure returns (uint256 tokenAmountOut) {\n', '        uint256 normalizedWeight = tokenWeightOut.bdiv(totalWeight);\n', '        // charge exit fee on the pool token side\n', '        // pAiAfterExitFee = pAi*(1-exitFee)\n', '        uint256 poolAmountInAfterExitFee =\n', '            poolAmountIn.bmul(BONE.bsub(EXIT_ZERO_FEE));\n', '        uint256 newPoolSupply = poolSupply.bsub(poolAmountInAfterExitFee);\n', '        uint256 poolRatio = newPoolSupply.bdiv(poolSupply);\n', '\n', '        // newBalTo = poolRatio^(1/weightTo) * balTo;\n', '        uint256 tokenOutRatio = poolRatio.bpow(BONE.bdiv(normalizedWeight));\n', '        uint256 newTokenBalanceOut = tokenOutRatio.bmul(tokenBalanceOut);\n', '\n', '        uint256 tokenAmountOutBeforeSwapFee =\n', '            tokenBalanceOut.bsub(newTokenBalanceOut);\n', '\n', '        // charge swap fee on the output token side\n', '        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\n', '        uint256 zaz = BONE.bsub(normalizedWeight).bmul(swapFee);\n', '        tokenAmountOut = tokenAmountOutBeforeSwapFee.bmul(BONE.bsub(zaz));\n', '        return tokenAmountOut;\n', '    }\n', '}\n', '\n', '// File: contracts/interface/IXConfig.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IXConfig {\n', '    function getCore() external view returns (address);\n', '\n', '    function getSAFU() external view returns (address);\n', '\n', '    function isFarmPool(address pool) external view returns (bool);\n', '\n', '    function getMaxExitFee() external view returns (uint256);\n', '\n', '    function getSafuFee() external view returns (uint256);\n', '\n', '    function getSwapProxy() external view returns (address);\n', '\n', '    function ethAddress() external pure returns (address);\n', '\n', '    function hasPool(address[] calldata tokens, uint256[] calldata denorms)\n', '        external\n', '        view\n', '        returns (bool exist, bytes32 sig);\n', '\n', '    // add by XSwapProxy\n', '    function addPoolSig(bytes32 sig) external;\n', '\n', '    // remove by XSwapProxy\n', '    function removePoolSig(bytes32 sig) external;\n', '}\n', '\n', '// File: contracts/XPool.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract XPool is XApollo, XPToken, XConst {\n', '    using XNum for uint256;\n', '\n', '    //Swap Fees: 0.1%, 0.25%, 1%, 2.5%, 10%\n', '    uint256[5] public SWAP_FEES = [\n', '        BONE / 1000,\n', '        (25 * BONE) / 10000,\n', '        BONE / 100,\n', '        (25 * BONE) / 1000,\n', '        BONE / 10\n', '    ];\n', '\n', '    struct Record {\n', '        bool bound; // is token bound to pool\n', '        uint256 index; // private\n', '        uint256 denorm; // denormalized weight\n', '        uint256 balance;\n', '    }\n', '\n', '    event LOG_SWAP(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_REFER(\n', '        address indexed caller,\n', '        address indexed ref,\n', '        address indexed tokenIn,\n', '        uint256 fee\n', '    );\n', '\n', '    event LOG_JOIN(\n', '        address indexed caller,\n', '        address indexed tokenIn,\n', '        uint256 tokenAmountIn\n', '    );\n', '\n', '    event LOG_EXIT(\n', '        address indexed caller,\n', '        address indexed tokenOut,\n', '        uint256 tokenAmountOut\n', '    );\n', '\n', '    event LOG_BIND(\n', '        address indexed caller,\n', '        address indexed token,\n', '        uint256 denorm,\n', '        uint256 balance\n', '    );\n', '\n', '    event LOG_UPDATE_SAFU(address indexed safu, uint256 fee);\n', '\n', '    event LOG_EXIT_FEE(uint256 fee);\n', '\n', '    event LOG_FINAL(uint256 swapFee);\n', '\n', '    // anonymous event\n', '    event LOG_CALL(\n', '        bytes4 indexed sig,\n', '        address indexed caller,\n', '        bytes data\n', '    ) anonymous;\n', '\n', '    modifier _logs_() {\n', '        emit LOG_CALL(msg.sig, msg.sender, msg.data);\n', '        _;\n', '    }\n', '\n', '    modifier _lock_() {\n', '        require(!_mutex, "ERR_REENTRY");\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    }\n', '\n', '    modifier _viewlock_() {\n', '        require(!_mutex, "ERR_REENTRY");\n', '        _;\n', '    }\n', '\n', '    bool private _mutex;\n', '\n', '    address public controller; // has CONTROL role\n', '\n', '    // `finalize` require CONTROL, `finalize` sets `can SWAP and can JOIN`\n', '    bool public finalized;\n', '\n', '    uint256 public swapFee;\n', '    uint256 public exitFee;\n', '\n', '    // Pool Governance\n', '    address public SAFU;\n', '    uint256 public safuFee;\n', '    bool public isFarmPool;\n', '\n', '    address[] internal _tokens;\n', '    mapping(address => Record) internal _records;\n', '    uint256 private _totalWeight;\n', '\n', '    IXConfig public xconfig;\n', '    address public origin;\n', '\n', '    constructor(address _xconfig, address _controller) public {\n', '        controller = _controller;\n', '        origin = tx.origin;\n', '        swapFee = SWAP_FEES[1];\n', '        exitFee = EXIT_ZERO_FEE;\n', '        finalized = false;\n', '        xconfig = IXConfig(_xconfig);\n', '        SAFU = xconfig.getSAFU();\n', '        safuFee = xconfig.getSafuFee();\n', '    }\n', '\n', '    function isBound(address t) external view returns (bool) {\n', '        return _records[t].bound;\n', '    }\n', '\n', '    function getNumTokens() external view returns (uint256) {\n', '        return _tokens.length;\n', '    }\n', '\n', '    function getFinalTokens()\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (address[] memory tokens)\n', '    {\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '        return _tokens;\n', '    }\n', '\n', '    function getDenormalizedWeight(address token)\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256)\n', '    {\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        return _records[token].denorm;\n', '    }\n', '\n', '    function getTotalDenormalizedWeight()\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256)\n', '    {\n', '        return _totalWeight;\n', '    }\n', '\n', '    function getNormalizedWeight(address token)\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256)\n', '    {\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        uint256 denorm = _records[token].denorm;\n', '        return denorm.bdiv(_totalWeight);\n', '    }\n', '\n', '    function getBalance(address token)\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256)\n', '    {\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        return _records[token].balance;\n', '    }\n', '\n', '    function setController(address manager) external _logs_ {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        controller = manager;\n', '    }\n', '\n', '    function setExitFee(uint256 fee) external {\n', '        require(!finalized, "ERR_IS_FINALIZED");\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(fee <= xconfig.getMaxExitFee(), "INVALID_EXIT_FEE");\n', '        exitFee = fee;\n', '        emit LOG_EXIT_FEE(fee);\n', '    }\n', '\n', '    // allow SAFU address and SAFE FEE be updated by xconfig\n', '    function updateSafu(address safu, uint256 fee) external {\n', '        require(msg.sender == address(xconfig), "ERR_NOT_CONFIG");\n', '        require(safu != address(0), "ERR_ZERO_ADDR");\n', '        SAFU = safu;\n', '        safuFee = fee;\n', '\n', '        emit LOG_UPDATE_SAFU(safu, fee);\n', '    }\n', '\n', '    // allow isFarmPool be updated by xconfig\n', '    function updateFarm(bool isFarm) external {\n', '        require(msg.sender == address(xconfig), "ERR_NOT_CONFIG");\n', '        isFarmPool = isFarm;\n', '    }\n', '\n', '    function bind(address token, uint256 denorm) external _lock_ {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(!_records[token].bound, "ERR_IS_BOUND");\n', '        require(!finalized, "ERR_IS_FINALIZED");\n', '\n', '        require(_tokens.length < MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");\n', '\n', '        require(denorm >= MIN_WEIGHT, "ERR_MIN_WEIGHT");\n', '        require(denorm <= MAX_WEIGHT, "ERR_MAX_WEIGHT");\n', '\n', '        uint256 balance = IERC20(token).balanceOf(address(this));\n', '\n', '        uint256 decimal = 10**uint256(IERC20(token).decimals());\n', '        require(decimal >= 10**6, "ERR_TOO_SMALL");\n', '\n', '        // 0.000001 TOKEN\n', '        require(balance >= decimal / MIN_BALANCE, "ERR_MIN_BALANCE");\n', '\n', '        _totalWeight = _totalWeight.badd(denorm);\n', '        require(_totalWeight <= MAX_TOTAL_WEIGHT, "ERR_MAX_TOTAL_WEIGHT");\n', '\n', '        _records[token] = Record({\n', '            bound: true,\n', '            index: _tokens.length,\n', '            denorm: denorm,\n', '            balance: balance\n', '        });\n', '        _tokens.push(token);\n', '\n', '        emit LOG_BIND(msg.sender, token, denorm, balance);\n', '    }\n', '\n', '    // _swapFee must be one of SWAP_FEES\n', '    function finalize(uint256 _swapFee) external _lock_ {\n', '        require(msg.sender == controller, "ERR_NOT_CONTROLLER");\n', '        require(!finalized, "ERR_IS_FINALIZED");\n', '        require(_tokens.length >= MIN_BOUND_TOKENS, "ERR_MIN_TOKENS");\n', '        require(_tokens.length <= MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");\n', '\n', '        require(_swapFee >= SWAP_FEES[0], "ERR_MIN_FEE");\n', '        require(_swapFee <= SWAP_FEES[SWAP_FEES.length - 1], "ERR_MAX_FEE");\n', '\n', '        bool found = false;\n', '        for (uint256 i = 0; i < SWAP_FEES.length; i++) {\n', '            if (_swapFee == SWAP_FEES[i]) {\n', '                found = true;\n', '                break;\n', '            }\n', '        }\n', '        require(found, "ERR_INVALID_SWAP_FEE");\n', '        swapFee = _swapFee;\n', '\n', '        finalized = true;\n', '\n', '        _mintPoolShare(INIT_POOL_SUPPLY);\n', '        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\n', '\n', '        emit LOG_FINAL(swapFee);\n', '    }\n', '\n', '    // Absorb any tokens that have been sent to this contract into the pool\n', '    function gulp(address token) external _logs_ _lock_ {\n', '        require(_records[token].bound, "ERR_NOT_BOUND");\n', '        _records[token].balance = IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256 spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return\n', '            XMath.calcSpotPrice(\n', '                inRecord.balance,\n', '                inRecord.denorm,\n', '                outRecord.balance,\n', '                outRecord.denorm,\n', '                swapFee\n', '            );\n', '    }\n', '\n', '    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n', '        external\n', '        view\n', '        _viewlock_\n', '        returns (uint256 spotPrice)\n', '    {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        Record storage inRecord = _records[tokenIn];\n', '        Record storage outRecord = _records[tokenOut];\n', '        return\n', '            XMath.calcSpotPrice(\n', '                inRecord.balance,\n', '                inRecord.denorm,\n', '                outRecord.balance,\n', '                outRecord.denorm,\n', '                0\n', '            );\n', '    }\n', '\n', '    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n', '        external\n', '        _lock_\n', '    {\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '        require(maxAmountsIn.length == _tokens.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        uint256 poolTotal = totalSupply();\n', '        uint256 ratio = poolAmountOut.bdiv(poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint256 bal = _records[t].balance;\n', '            uint256 tokenAmountIn = ratio.bmul(bal);\n', '            require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "ERR_LIMIT_IN");\n', '            _records[t].balance = (_records[t].balance).badd(tokenAmountIn);\n', '            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\n', '            _pullUnderlying(t, msg.sender, tokenAmountIn);\n', '        }\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '    }\n', '\n', '    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n', '        external\n', '        _lock_\n', '    {\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '        require(minAmountsOut.length == _tokens.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        // min pool amount\n', '        require(poolAmountIn >= MIN_POOL_AMOUNT, "ERR_MIN_AMOUNT");\n', '\n', '        uint256 poolTotal = totalSupply();\n', '        uint256 _exitFee = poolAmountIn.bmul(exitFee);\n', '        uint256 pAiAfterExitFee = poolAmountIn.bsub(_exitFee);\n', '        uint256 ratio = pAiAfterExitFee.bdiv(poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '\n', '        // to origin\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '        if (_exitFee > 0) {\n', '            _pushPoolShare(origin, _exitFee);\n', '        }\n', '        _burnPoolShare(pAiAfterExitFee);\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            address t = _tokens[i];\n', '            uint256 bal = _records[t].balance;\n', '            uint256 tokenAmountOut = ratio.bmul(bal);\n', '            require(tokenAmountOut != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountOut >= minAmountsOut[i], "ERR_LIMIT_OUT");\n', '            _records[t].balance = (_records[t].balance).bsub(tokenAmountOut);\n', '            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\n', '            _pushUnderlying(t, msg.sender, tokenAmountOut);\n', '        }\n', '    }\n', '\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n', '        return\n', '            swapExactAmountInRefer(\n', '                tokenIn,\n', '                tokenAmountIn,\n', '                tokenOut,\n', '                minAmountOut,\n', '                maxPrice,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function swapExactAmountInRefer(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) public _lock_ returns (uint256 tokenAmountOut, uint256 spotPriceAfter) {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(\n', '            tokenAmountIn <= (inRecord.balance).bmul(MAX_IN_RATIO),\n', '            "ERR_MAX_IN_RATIO"\n', '        );\n', '\n', '        uint256 spotPriceBefore =\n', '            XMath.calcSpotPrice(\n', '                inRecord.balance,\n', '                inRecord.denorm,\n', '                outRecord.balance,\n', '                outRecord.denorm,\n', '                swapFee\n', '            );\n', '        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");\n', '\n', '        tokenAmountOut = calcOutGivenIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(\n', '            spotPriceBefore <= tokenAmountIn.bdiv(tokenAmountOut),\n', '            "ERR_MATH_APPROX"\n', '        );\n', '\n', '        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\n', '        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\n', '\n', '        spotPriceAfter = XMath.calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");\n', '\n', '        emit LOG_SWAP(\n', '            msg.sender,\n', '            tokenIn,\n', '            tokenOut,\n', '            tokenAmountIn,\n', '            tokenAmountOut\n', '        );\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '\n', '        uint256 _swapFee = tokenAmountIn.bmul(swapFee);\n', '\n', '        // to referral\n', '        uint256 _referFee = 0;\n', '        if (\n', '            referrer != address(0) &&\n', '            referrer != msg.sender &&\n', '            referrer != tx.origin\n', '        ) {\n', '            _referFee = _swapFee / 5; // 20% to referrer\n', '            _pushUnderlying(tokenIn, referrer, _referFee);\n', '            inRecord.balance = (inRecord.balance).bsub(_referFee);\n', '            emit LOG_REFER(msg.sender, referrer, tokenIn, _referFee);\n', '        }\n', '\n', '        // to SAFU\n', '        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\n', '        if (isFarmPool) {\n', '            _safuFee = _swapFee.bsub(_referFee);\n', '        }\n', '        require(_safuFee.badd(_referFee) <= _swapFee, "ERR_FEE_LIMIT");\n', '        _pushUnderlying(tokenIn, SAFU, _safuFee);\n', '        inRecord.balance = (inRecord.balance).bsub(_safuFee);\n', '\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '        return (tokenAmountOut, spotPriceAfter);\n', '    }\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n', '        return\n', '            swapExactAmountOutRefer(\n', '                tokenIn,\n', '                maxAmountIn,\n', '                tokenOut,\n', '                tokenAmountOut,\n', '                maxPrice,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function swapExactAmountOutRefer(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) public _lock_ returns (uint256 tokenAmountIn, uint256 spotPriceAfter) {\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '\n', '        Record storage inRecord = _records[address(tokenIn)];\n', '        Record storage outRecord = _records[address(tokenOut)];\n', '\n', '        require(\n', '            tokenAmountOut <= (outRecord.balance).bmul(MAX_OUT_RATIO),\n', '            "ERR_MAX_OUT_RATIO"\n', '        );\n', '\n', '        uint256 spotPriceBefore =\n', '            XMath.calcSpotPrice(\n', '                inRecord.balance,\n', '                inRecord.denorm,\n', '                outRecord.balance,\n', '                outRecord.denorm,\n', '                swapFee\n', '            );\n', '        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");\n', '\n', '        tokenAmountIn = calcInGivenOut(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            tokenAmountOut,\n', '            swapFee\n', '        );\n', '        require(tokenAmountIn <= maxAmountIn, "ERR_LIMIT_IN");\n', '        require(\n', '            spotPriceBefore <= tokenAmountIn.bdiv(tokenAmountOut),\n', '            "ERR_MATH_APPROX"\n', '        );\n', '\n', '        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\n', '        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\n', '\n', '        spotPriceAfter = XMath.calcSpotPrice(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            swapFee\n', '        );\n', '        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");\n', '        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");\n', '\n', '        emit LOG_SWAP(\n', '            msg.sender,\n', '            tokenIn,\n', '            tokenOut,\n', '            tokenAmountIn,\n', '            tokenAmountOut\n', '        );\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '\n', '        uint256 _swapFee = tokenAmountIn.bmul(swapFee);\n', '        // to referral\n', '        uint256 _referFee = 0;\n', '        if (\n', '            referrer != address(0) &&\n', '            referrer != msg.sender &&\n', '            referrer != tx.origin\n', '        ) {\n', '            _referFee = _swapFee / 5; // 20% to referrer\n', '            _pushUnderlying(tokenIn, referrer, _referFee);\n', '            inRecord.balance = (inRecord.balance).bsub(_referFee);\n', '            emit LOG_REFER(msg.sender, referrer, tokenIn, _referFee);\n', '        }\n', '\n', '        // to SAFU\n', '        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\n', '        if (isFarmPool) {\n', '            _safuFee = _swapFee.bsub(_referFee);\n', '        }\n', '        require(_safuFee.badd(_referFee) <= _swapFee, "ERR_FEE_LIMIT");\n', '        _pushUnderlying(tokenIn, SAFU, _safuFee);\n', '        inRecord.balance = (inRecord.balance).bsub(_safuFee);\n', '\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\n', '        return (tokenAmountIn, spotPriceAfter);\n', '    }\n', '\n', '    function joinswapExternAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        uint256 minPoolAmountOut\n', '    ) external _lock_ returns (uint256 poolAmountOut) {\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '        require(_records[tokenIn].bound, "ERR_NOT_BOUND");\n', '        require(\n', '            tokenAmountIn <= (_records[tokenIn].balance).bmul(MAX_IN_RATIO),\n', '            "ERR_MAX_IN_RATIO"\n', '        );\n', '\n', '        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\n', '\n', '        // to SAFU\n', '        uint256 _safuFee = tokenAmountIn.bmul(safuFee);\n', '        if (isFarmPool) {\n', '            _safuFee = tokenAmountIn.bmul(swapFee);\n', '        }\n', '        tokenAmountIn = tokenAmountIn.bsub(_safuFee);\n', '\n', '        Record storage inRecord = _records[tokenIn];\n', '        poolAmountOut = XMath.calcPoolOutGivenSingleIn(\n', '            inRecord.balance,\n', '            inRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            tokenAmountIn,\n', '            swapFee\n', '        );\n', '        require(poolAmountOut >= minPoolAmountOut, "ERR_LIMIT_OUT");\n', '\n', '        inRecord.balance = (inRecord.balance).badd(tokenAmountIn);\n', '\n', '        _pushUnderlying(tokenIn, SAFU, _safuFee);\n', '        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\n', '        _mintPoolShare(poolAmountOut);\n', '        _pushPoolShare(msg.sender, poolAmountOut);\n', '        return poolAmountOut;\n', '    }\n', '\n', '    function exitswapPoolAmountIn(\n', '        address tokenOut,\n', '        uint256 poolAmountIn,\n', '        uint256 minAmountOut\n', '    ) external _logs_ _lock_ returns (uint256 tokenAmountOut) {\n', '        require(finalized, "ERR_NOT_FINALIZED");\n', '        require(_records[tokenOut].bound, "ERR_NOT_BOUND");\n', '        require(poolAmountIn >= MIN_POOL_AMOUNT, "ERR_MIN_AMOUNT");\n', '\n', '        _pullPoolShare(msg.sender, poolAmountIn);\n', '\n', '        // exit fee to origin\n', '        if (exitFee > 0) {\n', '            uint256 _exitFee = poolAmountIn.bmul(exitFee);\n', '            _pushPoolShare(origin, _exitFee);\n', '            poolAmountIn = poolAmountIn.bsub(_exitFee);\n', '        }\n', '\n', '        _burnPoolShare(poolAmountIn);\n', '\n', '        Record storage outRecord = _records[tokenOut];\n', '        tokenAmountOut = XMath.calcSingleOutGivenPoolIn(\n', '            outRecord.balance,\n', '            outRecord.denorm,\n', '            _totalSupply,\n', '            _totalWeight,\n', '            poolAmountIn,\n', '            swapFee\n', '        );\n', '\n', '        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");\n', '        require(\n', '            tokenAmountOut <= (_records[tokenOut].balance).bmul(MAX_OUT_RATIO),\n', '            "ERR_MAX_OUT_RATIO"\n', '        );\n', '\n', '        outRecord.balance = (outRecord.balance).bsub(tokenAmountOut);\n', '\n', '        // to SAFU\n', '        uint256 _safuFee = tokenAmountOut.bmul(safuFee);\n', '        if (isFarmPool) {\n', '            _safuFee = tokenAmountOut.bmul(swapFee);\n', '        }\n', '\n', '        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\n', '        _pushUnderlying(tokenOut, SAFU, _safuFee);\n', '        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut.bsub(_safuFee));\n', '        return tokenAmountOut;\n', '    }\n', '\n', '    function calcOutGivenIn(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 _swapFee\n', '    ) public pure returns (uint256) {\n', '        return\n', '            XMath.calcOutGivenIn(\n', '                tokenBalanceIn,\n', '                tokenWeightIn,\n', '                tokenBalanceOut,\n', '                tokenWeightOut,\n', '                tokenAmountIn,\n', '                _swapFee\n', '            );\n', '    }\n', '\n', '    function calcInGivenOut(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 _swapFee\n', '    ) public pure returns (uint256) {\n', '        return\n', '            XMath.calcInGivenOut(\n', '                tokenBalanceIn,\n', '                tokenWeightIn,\n', '                tokenBalanceOut,\n', '                tokenWeightOut,\n', '                tokenAmountOut,\n', '                _swapFee\n', '            );\n', '    }\n', '\n', '    // ==\n', "    // 'Underlying' token-manipulation functions make external calls but are NOT locked\n", '    // You must `_lock_` or otherwise ensure reentry-safety\n', '    // Fixed ERC-20 transfer revert for some special token such as USDT\n', '    function _pullUnderlying(\n', '        address erc20,\n', '        address from,\n', '        uint256 amount\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) =\n', '            erc20.call(\n', '                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n', '            );\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "ERC20_TRANSFER_FROM_FAILED"\n', '        );\n', '    }\n', '\n', '    function _pushUnderlying(\n', '        address erc20,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) =\n', '            erc20.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "ERC20_TRANSFER_FAILED"\n', '        );\n', '    }\n', '\n', '    function _pullPoolShare(address from, uint256 amount) internal {\n', '        _move(from, address(this), amount);\n', '    }\n', '\n', '    function _pushPoolShare(address to, uint256 amount) internal {\n', '        _move(address(this), to, amount);\n', '    }\n', '\n', '    function _mintPoolShare(uint256 amount) internal {\n', '        _mint(amount);\n', '    }\n', '\n', '    function _burnPoolShare(uint256 amount) internal {\n', '        _burn(amount);\n', '    }\n', '}\n', '\n', '// File: contracts/XPoolCreator.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', 'contract XPoolCreator is XApollo {\n', '    function newXPool(address config, address controller)\n', '        external\n', '        returns (XPool)\n', '    {\n', '        return new XPool(config, controller);\n', '    }\n', '}']