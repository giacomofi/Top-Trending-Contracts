['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.4;\n', '\n', '/*\n', 'https://t.me/moondogofficial\n', 'Moon Dog\n', '$MDOG\n', '\n', 'Completely dynamic fees - able to be changed when the community chooses.\n', 'Join us and join a community that will have more power and control over their\n', 'ecosystem than any other community in meme coin history.\n', '\n', '***Original source code - separate voting contract deployed soon***\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdhhhyhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdddyohhoohNMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMddhy-.-smy/osyhdmNMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMdym/+yhso+:::::/oyyyydmNMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMmhmhs/::::``.::::::://oyyyyyyyyhmNMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNho+/::/yys///+//::-..:::/shyyyydhdMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmhyydNNdo/:::::://ymmNNmmy/-..::::/hh---dhdMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNmy/````:sh+::.``````.mNNNNNmhyyys+:::/hy-odhmMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMys`       -ho`  -/.   +mNNmh:.y//+o::::/dsdydNMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNyy+`       .d:  hNd:-:+dd+.`  `..-::::::omhdmMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNmdmmddddddhhhhhhhdo-`     `h+  dNNmmNNNNdo.``.::``-:::::+hmMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMNmmmddhhhhhyyyyyyyyyyyyyyyyy:--..om:` +NNmhydmhdmmddmNm-  .:::::ydMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMNNmmdhhyyyyyyssssooooooooosssssyyyyyyhhhyshsosyhs+oymNNNNm+    -::::sdMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMNmddhhhyo+++oo+++///////////////+++oossyyyyyms+yys++ymNNNmds-      .::/dmMMMMMM\n', 'MMMMMMMMMMMMMMMMMMNmddhhyyyss+/////////////////////////////++osyyyhhyyyhy/-::--`         .:ydMMMMMMM\n', 'MMMMMMMMMMMMMMMMNmdhhhyyyso+///////////////////////////////////+osyyyyyhho-`             `odNMMMMMMM\n', 'MMMMMMMMMMMMMMNmdhhyyyso+/////////////////////////////////////////+osyyyyhhy+.   `.--.``.ymMMMMMMMMM\n', 'MMMMMMMMMMMMNmdhhyyyso+/////////////////////////////////////////////+ossoooshhs/os++++osddNMMMMMMMMM\n', 'MMMMMMMMMMMmddhyyyyo+/////////////////////////////////////////////////+/////+yhd:`     `-ohNMMMMMMMM\n', 'MMMMMMMMMNddhhyyys+//////////////////////////////////////////////////////////oyd/         /mNMMMMMMM\n', 'MMMMMMMMNddhyyyyo////////////////////////////////////////////////////////////oyyd-`       -dNMMMMMMM\n', 'MMMMMMMmdhhyyyyo//////////////////////////////////++++++++//////////////////oyyyyhys-..` -hdMMMMMMMM\n', 'MMMMMMNmhhyyyy+//////////////////////////////++osssyyyyyyssoo+//////////////oyyyyyyhdddyydmMMMMMMMMM\n', 'MMMMMmdhhyyyyo/////////////////////////////+osyyyyyyyyyyyyyyyyso+////////////oyyyyyyhhhhmmmMMMMMMMMM\n', 'MMMMNmhhyyyys/////////////////////////////oyyyyyyyyyyyyyyyyyyyyys+//////////++ssyyyyhhhhdNmmMMMMMMMM\n', 'MMMNddhhyyyy+///////////////////////////+syyyyyyyyyyyyyyyyyyyyyyyyo+sss+/+ossyyssssyyhhhhmNmNMMMMMMM\n', 'MMMmmhhysooo+++/////////////////////////syyyyyyyyyyyyyyyyyyyyyyyyyyyyyyooyyyyyyyyysoyyhhhhmNmMMMMMMM\n', 'MMNmdhhs+syyyyys+//////////////////////+yyyyyyyyyyyyyyyyyyyyyyyyyyyyooo+yyyyyyyyyyysoyhhhhdNmmMMMMMM\n', 'MMmmhhy+syyyyyyyy+/////////////////////oyyyyyyyyyyyyyyyyyyyyyyyyyyyy+//+yyyyyyyyyyyyoyyhhhhmNmMMMMMM\n', 'MNddhhy+syyyyyyyy+/////////////////////+yyyyyyyyyyyyyyyyyyyyyyyyyyyy+//+syyyyyyyyyyssyyhhhhmNmmMMMMM\n', 'Mmmdhhyyosyyyyys+//////////////////////+syyyyyyyyyyyyyyyyyyyyyyyyyys////+syyyyyyyyooyyyhhhhdNNdMMMMM\n', 'MNmhhhyyyys++++/////////////////////////+yyyyyyyyyyyyyyyyyyyyyyyyys+//////+oossooosyyyyhhhhdNNdMMMMM\n', 'MNmhhhyyyyy+/////////////////////////////+syyyyyyyyyyyyyyyyyyyyyys+////////////oyyyyyyyhhhhdNNhMMMMM\n', 'MNmhhhyyyyyo///////////////////////////////osyyyyyyyyyyyyyyyyyys+//////////////syyyyyyyhhhhdNNhMMMMM\n', 'MNNhhhyyyyyy+////////////////////////////////+osyyyyyyyyyyyyso+///////////////+yyyyyyyyhhhhdNNhMMMMM\n', 'MNNdhhyyyyyyo///////////////////////////////////+++oooooo+++//////////////////syyyyyyyhhhhhmNNdMMMMM\n', 'Mmmmhhhysssyyo////////////////////////////////////////+ossso+////////////////oyyyyyyyyhhhhhmNNdMMMMM\n', 'MNdmhhhyoyyyyyo//////////////////////////////////////oyyyyyys+//////////////oyyyyyyyyhhhhhdNNmNMMMMM\n', 'MMdNdhhhosyyyys+/////////////////////////////////////syyyyyyy+/////////////oyyyyyyyyyhhhhhmNNmMMMMMM\n', 'MMNmmdhhhsssssyyo////////////////++oosssssoo++///////+osyyss+/////////////oyyyyyyyyyhhhhhdNNmmMMMMMM\n', 'MMMmmmhhhhyyyyyyyo+///////////+ossyyyyyyyyyyyyso+//////++++///////++////+syyyyyyyyyhhhhhdmNNmMMMMMMM\n', 'MMMMdNmhhhhyyyyyyyso/////////+syyyyyyyyyyyyyyyyyso//////////////+sssso+osyyyyyyyyyhhhhhhmNNdNMMMMMMM\n', 'MMMMNdNdhhhhyyyyyyyys+//////+yyyyyyyyyyyyyyyyyyyyyo////////////+yyyyyyssyyyyyyyyyhhhhhhmNNmmMMMMMMMM\n', 'MMMMMmmNdhhhhyyyyyyyyys++///syyyyyyyyyyyyyyyyyyyyyy+///////////+yyyyyysoyyyyyyyyhhhhhhmNNmmMMMMMMMMM\n', 'MMMMMMNmNmhhhhyyyyyyyyyyso++yyyyyyyyyyyyyyyyyyyyyyyo///////////+osyyysosyyyyyyhhhhhhdmNNmNMMMMMMMMMM\n', 'MMMMMMMmmNmdhhhhyyyyyyyyyyyssyyyyyyyyyyyyyyyyyyyyys+///////++osssoosssyyyyyyyhhhhhhdmNNmmMMMMMMMMMMM\n', 'MMMMMMMMNmmmdhhhhhyyyyyyyyyyssyyyyyyyyyyyyyyyyyyys+///+++ossyyyyyyyyyyyyyyyhhhhhhdmNNmmNMMMMMMMMMMMM\n', 'MMMMMMMMMMmmNmdhhhhhyyyyyyyyyyssyyyyyyyyyyyyyyyso++osssyyyyyyyyyyyyyyyyyyhhhhhhhdmNNmmNMMMMMMMMMMMMM\n', 'MMMMMMMMMMMNmmNmdhhhhhhyyyyyyyysssssyyyyyyyysso++oyyyyyyyyyyyyyyyyyyyyhhhhhhhhdmNNmmNMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMNmmmNmdhhhhhhhyyyyyyyyssoooooooooossyyyyyyyyyyyyyyyyyyyhhhhhhhhhdmNNNmmNMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMmmmNmmdhhhhhhhyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyhhhhhhhhhhdmmNNmmmMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMmmmNNmddhhhhhhhhhhyyyyyyyyyyyyyyyyyyyyyyyhhhhhhhhhhhhdmmNNNmmmNMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMNmmmNNmmdhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhddmmNNNNmmmMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMNNdmNNNmmddhhhhhhhhhhhhhhhhhhhhhhhhhhhhdddmmNNNNNmmNNMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMNNmmNNNNNmmmdddddhhhhhhhhhhhddddmmmmNNNNNNmmNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMNNmmdmmNNNNNNNNNNNmmmNNNNNNNNNNmNmmmdNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNmmddmmmmmmmmmmmmmmdmNmNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', 'MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n', '*/\n', '\n', "//Note: Moon Dog isn't relying on SafeMath as recent versions of solidity \n", '//      have implicit under/over-flow checking.\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '    address private _previousOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '}  \n', '\n', 'interface IUniswapV2Router02 {\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amount_in,\n', '        uint amount_out_min,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amount_token_desired,\n', '        uint amount_token_min,\n', '        uint amount_eth_min,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amount_token, uint amount_eth, uint liquidity);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract MoonDog is IERC20, Ownable {\n', '    string public constant name = "Moon Dog";\n', '    string public constant symbol = "MDOG";\n', '    uint8 public constant decimals = 9;\n', '    uint256 uint256_max = ~uint256(0);\n', '    uint256 private token_total = 1 * 10**9 * 10**9; //max-supply: 1 billion tokens\n', '    uint256 private reserve_total = (uint256_max - (uint256_max % token_total)); //max divisor\n', '    address public burn_address = address(0);\n', '    mapping(address => uint256) private reserves_owned;\n', '    mapping(address => uint256) private tokens_owned;\n', '    mapping(address => bool) private excluded_from_fees;\n', '    mapping(address => mapping (address => uint256)) private allowances;\n', '    mapping(address => bool) private bots;\n', '    mapping(address => uint) private cooldowns;\n', '    uint256 public liquidity_fee = 5;\n', '    uint256 public reflection_fee = 3;\n', '    uint256 public burn_fee = 0;\n', '    uint256 private team_fee = 8;\n', '    uint256 private max_tx_amount = token_total;\n', '    uint256 private liquify_threshold = 1*10**5 * 10**9;\n', '    uint256 private liquidity_tokens = 0;\n', '    uint256 private fee_tokens = 0;\n', '    bool private swap_locked = false;\n', '    bool private trading_open = false;\n', '    bool private cooldown_enabled = false;\n', '    bool private exclude_burn_address = false;\n', '    address private fee_tweaker;\n', '    address payable private fee_addr;\n', '    address public uniswapV2_pair;\n', '    IUniswapV2Router02 private uniswapv2_router;\n', '\n', '    event FeesTweaked(\n', '        uint256 liquidity_fee, \n', '        uint256 reflection_fee, \n', '        uint256 burn_fee\n', '    );\n', '\n', '    constructor(address fee_tweaker_, address payable fee_addr_) {\n', '        fee_addr = fee_addr_;\n', '        reserves_owned[msg.sender] = reserve_total;\n', '        fee_tweaker = fee_tweaker_;\n', '        IUniswapV2Router02 uniswap_router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        uniswapv2_router = uniswap_router;\n', '        uniswapV2_pair = IUniswapV2Factory(uniswapv2_router.factory()).createPair(\n', '            address(this), uniswapv2_router.WETH()\n', '        );\n', '        excluded_from_fees[msg.sender] = true;\n', '        excluded_from_fees[address(this)] = true;\n', '        excluded_from_fees[fee_addr] = true;\n', '        emit Transfer(address(0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B), _msgSender(), token_total);\n', '    }\n', '    \n', '    function openSwap() external onlyOwner {\n', '        require(!trading_open, "Trading has already been opened");\n', '        max_tx_amount = 5 * 10**6 * 10**9; // 0.5%\n', '        trading_open = true;\n', '        cooldown_enabled = true;\n', '    }\n', '\n', '    modifier onlyFeeTweaker() {\n', '        require(fee_tweaker == _msgSender(), "You are not the fee tweaker");\n', '        _;\n', '    }\n', '\n', '    function tweakFees(uint256 new_liquidity_fee, \n', '                       uint256 new_reflection_fee, \n', '                       uint256 new_burn_fee) public onlyFeeTweaker() {\n', '        //The max fee (15%) cannot be changed\n', "        //This is so the community doesn't have to trust the fee tweaker that much\n", '        //Malicious behaviour is thus limited\n', '        require((new_liquidity_fee + new_reflection_fee + new_burn_fee) <= 15);\n', '        liquidity_fee = new_liquidity_fee;\n', '        reflection_fee = new_reflection_fee;\n', '        burn_fee = new_burn_fee;\n', '        emit FeesTweaked(new_liquidity_fee, new_reflection_fee, new_burn_fee);\n', '    }\n', '\n', '    function banBots(address[] memory bots_to_ban) public onlyOwner {\n', '        for (uint i = 0; i < bots_to_ban.length; ++i) {\n', '            bots[bots_to_ban[i]] = true;\n', '        }\n', '    }\n', '\n', '    function unbanBot(address unban_me) public onlyOwner {\n', '        bots[unban_me] = false;\n', '    }\n', '\n', '    function totalSupply() public override view returns (uint256) {\n', '        return token_total;\n', '    }\n', '\n', '    function balanceOf(address token_owner) public override view returns (uint256) {\n', '        if (token_owner == burn_address && exclude_burn_address) \n', '            return tokens_owned[burn_address];\n', '        return tokenFromReflection(reserves_owned[token_owner]);\n', '    }\n', '\n', '    function transfer(address receiver, uint256 num_tokens) public override returns (bool) {\n', '        require(\n', '            excluded_from_fees[msg.sender] || \n', '            excluded_from_fees[receiver] || \n', '            trading_open\n', '        );\n', '        transferStageInitialChecks(msg.sender, receiver, num_tokens);\n', '        return true;\n', '    }\n', '\n', '    function approve(address delegate, uint256 num_tokens) public override returns (bool) {\n', '        approveOthers(msg.sender, delegate, num_tokens);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address delegate) public override view returns (uint) {\n', '        return allowances[owner][delegate];\n', '    }\n', '\n', '    function transferFrom(address owner, address buyer, uint256 num_tokens) public override returns (bool) {\n', '        require(num_tokens <= allowances[owner][msg.sender], "Cannot spend more tokens than the allowance");\n', '        transferStageInitialChecks(owner, buyer, num_tokens);\n', '        approve(owner, allowances[owner][msg.sender] - num_tokens);\n', '        return true;\n', '    }\n', '\n', '    function approveOthers(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '        allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function editFeesOnAddress(address addr, bool true_or_false) external onlyOwner {\n', '        excluded_from_fees[addr] = true_or_false;\n', '    }\n', '\n', '    modifier swapLock {\n', '        swap_locked = true;\n', '        _;\n', '        swap_locked = false;\n', '    }\n', '\n', '    function setMaxTXPercentage(uint256 new_max_tx) public onlyOwner {\n', '        require(new_max_tx > 0);\n', '        max_tx_amount = ((token_total * new_max_tx) / 100);\n', '\n', '    }\n', '\n', '    function transferStageInitialChecks(address from, address to, uint256 amount) private {\n', '        require(from != address(0), "Can\'t transfer from 0 address");\n', '        require(to != address(0), "Can\'t transfer to 0 address");\n', '        require(amount > 0, "Must transfer more than 0 tokens");\n', '        require(!bots[from] && !bots[to], "Not on my watch");\n', '        if (from != owner() && to != owner()) {\n', '            if (!swap_locked) {\n', '                if (from == uniswapV2_pair && to != address(uniswapv2_router) && cooldown_enabled && !excluded_from_fees[to]) {\n', '                    require(amount <= max_tx_amount, "Transfer amount exceeds maximum amount");\n', '                    require(cooldowns[to] < block.timestamp);\n', '                    cooldowns[to] = block.timestamp + (30 seconds);\n', '                }\n', '                if (from != uniswapV2_pair && trading_open) {\n', '                    swapAndLiquify();\n', '                }\n', '            }\n', '        }\n', '        transferStageToken(from, to, amount);\n', '    }\n', '    \n', '    function swapAndLiquify() private swapLock {\n', '        uint256 fee_balance = balanceOf(address(this)) - liquidity_tokens;\n', '        bool over_liquify_threshold = (liquidity_tokens >= liquify_threshold);\n', '        if (liquidity_fee != 0 && over_liquify_threshold) {\n', '            uint256 half = liquidity_tokens / 2;\n', '            uint256 other_half = liquidity_tokens - half;\n', '            uint256 swap_this = half + fee_balance;\n', '            swapTokensForETH(swap_this);\n', '            uint256 eth_balance = address(this).balance;\n', '            uint256 fee_total = (((liquidity_fee*10)/2) + team_fee*10);\n', '            uint256 liq_share = (eth_balance / fee_total) * (liquidity_fee*10);\n', '            addLiquidity(other_half, liq_share);\n', '            liquidity_tokens = 0;\n', '        }\n', '        if (fee_tokens > 0) { \n', '            if (!over_liquify_threshold) {\n', '                swapTokensForETH(fee_balance);\n', '            }\n', '            fee_tokens = 0;\n', '            uint256 balance = address(this).balance;\n', '            if (balance > 0)\n', '                fee_addr.transfer(balance);\n', '        }\n', '    }\n', '\n', '    //This function is to circumvent uniswap maximum slippage values\n', '    //just incase tokens back up and the swap gets jammed\n', "    //this shouldn't happen, but if it does, this fixes it\n", '    function manualLiquify() public onlyFeeTweaker {\n', '        swapAndLiquify();\n', '    }\n', '\n', '    function transferStageToken(address from, address to, uint256 amount) private {\n', '        bool cancel_fees = false;\n', '        if (excluded_from_fees[from] || excluded_from_fees[to]) {\n', '            cancel_fees = true;\n', '        }\n', '        transferStageStandard(from, to, amount, cancel_fees);\n', '    }\n', '\n', '    function transferStageStandard(address from, address to, uint256 t_initial, bool cancel_fees) private {\n', '        uint256 current_rate = getRate();\n', '        uint256 r_amount = t_initial * current_rate;\n', '        uint256 r_xfer_amount = r_amount;\n', '        if (!cancel_fees) {\n', '            uint256 one_percent = t_initial / 100;\n', '            if (team_fee != 0) {\n', '                uint256 rteam_fee;\n', '                uint256 tteam_fee;\n', '                (tteam_fee, rteam_fee) = calcRTValue(current_rate, team_fee, one_percent);\n', '                fee_tokens += tteam_fee;\n', '                r_xfer_amount -= rteam_fee;\n', '            }\n', '            if (liquidity_fee != 0) {\n', '                uint256 rliq_fee;\n', '                uint256 tliq_fee;\n', '                (tliq_fee, rliq_fee) = calcRTValue(current_rate, liquidity_fee, one_percent);\n', '                liquidity_tokens += tliq_fee;\n', '                r_xfer_amount -= rliq_fee;\n', '            }\n', '            if (burn_fee != 0) {\n', '                uint256 tburn_fee = one_percent * burn_fee;\n', '                uint256 rburn_fee = tburn_fee * current_rate;\n', '                r_xfer_amount -= rburn_fee;\n', '                reserves_owned[burn_address] = reserves_owned[burn_address] + rburn_fee;\n', '                if (exclude_burn_address)\n', '                    tokens_owned[burn_address] = tokens_owned[burn_address] + tburn_fee;\n', '                emit Transfer(from, burn_address, tburn_fee);\n', '            }\n', '            if (reflection_fee != 0) {\n', '                uint256 rrefl_fee;\n', '                rrefl_fee = (one_percent * reflection_fee) * current_rate;\n', '                reserve_total = reserve_total - rrefl_fee;\n', '                r_xfer_amount -= rrefl_fee;\n', '            }\n', '        }\n', '        reserves_owned[from] = reserves_owned[from] - r_amount;\n', '        reserves_owned[to] = reserves_owned[to] + r_xfer_amount;\n', '        emit Transfer(from, to, (r_xfer_amount / current_rate));\n', '    }\n', '\n', '    function calcRTValue(uint256 current_rate, uint256 fee, uint256 one_percent) private returns (uint256, uint256) {\n', '        uint256 tfee = one_percent * fee;\n', '        uint256 rfee = tfee * current_rate;\n', '        reserves_owned[address(this)] += rfee;\n', '        return (tfee, rfee);\n', '    }\n', '    \n', '    function enableCooldown(bool torf) external onlyOwner {\n', '        cooldown_enabled = torf;\n', '    }\n', '\n', '    function swapTokensForETH(uint256 token_amount) private {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(this);\n', '        path[1] = uniswapv2_router.WETH();\n', '        approveOthers(address(this), address(uniswapv2_router), token_amount);\n', '        uniswapv2_router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '            token_amount, \n', '            0, \n', '            path, \n', '            address(this), \n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function addLiquidity(uint256 token_amount, uint256 eth_amount) private {\n', '        approveOthers(address(this), address(uniswapv2_router), token_amount);\n', '        uniswapv2_router.addLiquidityETH{value: eth_amount}(\n', '            address(this), \n', '            token_amount, \n', '            0, \n', '            0, \n', '            owner(), \n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function tokenFromReflection(uint256 reserve_amount) private view returns (uint256) {\n', '        require (reserve_amount <= reserve_total, "Amount must be less than reserve total");\n', '        uint256 current_rate = getRate();\n', '        return reserve_amount / current_rate;\n', '    }\n', '\n', '    function getRate() private view returns (uint256) {\n', '        (uint256 reserve_supply, uint256 token_supply) = getSupply();\n', '        return reserve_supply / token_supply;\n', '    }\n', '\n', '    function getSupply() private view returns(uint256, uint256) {\n', '        uint256 r_supply = reserve_total;\n', '        uint256 t_supply = token_total;\n', '        if (exclude_burn_address) {\n', '            if (reserves_owned[burn_address] > r_supply || tokens_owned[burn_address] > t_supply)\n', '                return (reserve_total, token_total);\n', '            r_supply = r_supply - reserves_owned[burn_address];\n', '            t_supply = t_supply - tokens_owned[burn_address];\n', '        }\n', '        if (r_supply < (reserve_total / token_total))\n', '            return (reserve_total, token_total);\n', '        return (r_supply, t_supply);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function excludeBurnAddress() public onlyFeeTweaker {\n', '        require(!exclude_burn_address, "Already excluded");\n', '        if (reserves_owned[burn_address] > 0)\n', '            tokens_owned[burn_address] = tokenFromReflection(reserves_owned[burn_address]);\n', '        exclude_burn_address = true;\n', '    }\n', '\n', '    function includeBurnAddress() public onlyFeeTweaker {\n', '        require(exclude_burn_address, "Already included");\n', '        tokens_owned[burn_address] = 0;\n', '        exclude_burn_address = false;\n', '    }\n', '}']