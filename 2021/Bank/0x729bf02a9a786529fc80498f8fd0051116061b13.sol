['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-16\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function decimals() external view returns (uint256);\n', '}\n', '\n', 'interface IUniswapV3Pool {\n', '\n', '    function slot0()\n', '        external\n', '        view\n', '        returns (\n', '            uint160 sqrtPriceX96,\n', '            int24 tick,\n', '            uint16 observationIndex,\n', '            uint16 observationCardinality,\n', '            uint16 observationCardinalityNext,\n', '            uint8 feeProtocol,\n', '            bool unlocked\n', '        );\n', '\n', '}\n', '\n', 'interface IGUniPool {\n', '    function token0() external view returns (IERC20);\n', '\n', '    function token1() external view returns (IERC20);\n', '\n', '    function pool() external view returns (IUniswapV3Pool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function getMintAmounts(uint256 amount0Max, uint256 amount1Max)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 amount0,\n', '            uint256 amount1,\n', '            uint256 mintAmount\n', '        );\n', '\n', '    function getPositionID() external view returns (bytes32 positionID);\n', '\n', '    function lowerTick() external view returns (int24);\n', '\n', '    function upperTick() external view returns (int24);\n', '\n', '\n', '}\n', '\n', 'interface GUniResolver {\n', '\n', '    function getPoolUnderlyingBalances(IGUniPool pool)\n', '        external\n', '        view\n', '        returns (uint256 amount0, uint256 amount1);\n', '\n', '    function getUnderlyingBalances(\n', '        IGUniPool pool,\n', '        uint256 balance\n', '    ) external view returns (uint256 amount0, uint256 amount1);\n', '\n', '    function getRebalanceParams(\n', '        IGUniPool pool,\n', '        uint256 amount0In,\n', '        uint256 amount1In,\n', '        uint16 slippageBPS\n', '    ) external view returns (\n', '        bool zeroForOne,\n', '        uint256 swapAmount,\n', '        uint160 swapThreshold\n', '    );\n', '\n', '}\n', '\n', 'struct StakingRewardsInfo {\n', '    address stakingRewards;\n', '    uint rewardAmount;\n', '}\n', 'interface StakingFactoryInterface {\n', '\n', '    function stakingRewardsInfoByStakingToken(address) external view returns(StakingRewardsInfo memory);\n', '\n', '}\n', '\n', 'interface StakingInterface {\n', '    function totalSupply() external view returns (uint256);\n', '    function rewardRate() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function earned(address account) external view returns (uint256);\n', '    function rewardPerToken() external view returns (uint256);\n', '}\n', '\n', 'interface IndexInterface {\n', '    function master() external view returns (address);\n', '}\n', '\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "math-not-safe");\n', '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "math-not-safe");\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '}\n', '\n', 'contract Helpers is DSMath {\n', '\n', '    GUniResolver public constant gelatoRouter = GUniResolver(0x3B01f3534c9505fE8e7cf42794a545A0d2ede976);\n', '    StakingFactoryInterface public getStakingFactory;\n', '\n', '    function updateFactory(address _stakingFactory) public {\n', '        require(msg.sender == IndexInterface(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723).master(), "not-master");\n', '        require(address(getStakingFactory) != _stakingFactory, "already-enabled");\n', '        getStakingFactory = StakingFactoryInterface(_stakingFactory);\n', '    }\n', '\n', '    struct UserData {\n', '        address pool; // address of pool contract\n', '        address staking; // address of staking contract\n', '        address token0Addr; // address of token 0\n', '        address token1Addr; // address of token 1\n', '        uint poolTokenSupply; // Total supply of Pool token\n', '        uint poolToken0Bal; // balance of total pool for token0\n', '        uint poolToken1Bal; // balance of total pool for token1\n', '        uint poolTokenSupplyStaked; // total pool token locked in staking contract\n', '        uint stakingToken0Bal; // total balance of token0 in Staking\n', '        uint stakingToken1Bal; // total balance of token1 in Staking\n', '        uint rewardRate; // INST distributing per second\n', '        uint token0Bal; // balance of token 0 of user\n', '        uint token1Bal; // balance of token 1 of user\n', '        uint earned; // INST earned from staking\n', "        uint stakedBal; // user's pool token bal in staking contract\n", "        uint poolBal; // ideal pool token in user's DSA\n", '        uint totalBal; // stakedBal + poolTknBal\n', '        uint token0Decimals; // token0 decimals\n', '        uint token1Decimals; // token1 decimals\n', '        int24 currentTick; // Current price of 1 token w.r.t to other\n', '        int24 lowerTick; // Price of 1 token w.r.t to other at lower tick\n', '        int24 upperTick; // Price of 1 token w.r.t to other at upper tick\n', '    }\n', '\n', '}\n', '\n', 'contract Resolver is Helpers {\n', '\n', '    function getSinglePosition(address user, address pool) public view returns(UserData memory _data) {\n', '        _data.pool = pool;\n', '        StakingInterface stakingContract = StakingInterface(getStakingFactory.stakingRewardsInfoByStakingToken(pool).stakingRewards);\n', '        _data.staking = address(stakingContract);\n', '        IGUniPool poolContract = IGUniPool(pool);\n', '        _data.token0Addr = address(poolContract.token0());\n', '        _data.token1Addr = address(poolContract.token1());\n', '        if (_data.staking == address(0)) {\n', '            _data.earned = 0;\n', '            _data.stakedBal = 0;\n', '        } else {\n', '            _data.earned = stakingContract.earned(user);\n', '            _data.stakedBal = stakingContract.balanceOf(user);\n', '        }\n', '        _data.poolBal = poolContract.balanceOf(user);\n', '        _data.totalBal = add(_data.stakedBal, _data.poolBal);\n', '        (_data.token0Bal, _data.token1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, _data.totalBal);\n', '        _data.poolTokenSupply = poolContract.balanceOf(user);\n', '        (_data.poolToken0Bal, _data.poolToken1Bal) = gelatoRouter.getPoolUnderlyingBalances(poolContract);\n', '        _data.poolTokenSupplyStaked = stakingContract.totalSupply();\n', '        (_data.stakingToken0Bal, _data.stakingToken1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, _data.poolTokenSupplyStaked);\n', '        _data.rewardRate = stakingContract.rewardRate();\n', '\n', '        _data.token0Decimals = poolContract.token0().decimals();\n', '        _data.token1Decimals = poolContract.token1().decimals();\n', '\n', '        IUniswapV3Pool uniNft = poolContract.pool();\n', '        (, _data.currentTick, , , , , ) = uniNft.slot0();\n', '        _data.lowerTick = poolContract.lowerTick();\n', '        _data.upperTick = poolContract.upperTick();\n', '    }\n', '\n', '    function getPosition(address user, address[] memory pools) public view returns(UserData[] memory _data) {\n', '        _data = new UserData[](pools.length);\n', '        for (uint i = 0; i < pools.length; i++) {\n', '            _data[i] = getSinglePosition(user, pools[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @param pool - gelato pool address.\n', '    * @param amount0In - amount of token0 user wants to deposit.\n', '    * @param amount1In - amount of token1 user wants to deposit.\n', '    * @param slippage in 18 decimal where 100% = 1e18.\n', '    * @return zeroForOne - if true swap token0 for token1 else vice versa\n', '    * @return swapAmount - Amount of tokens to swap.\n', '    * @return swapThreshold - Max slippage that the swap can take.\n', '    */\n', '    function getSwapAndDepositParams(\n', '        address pool, \n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint slippage\n', '    ) public view returns (\n', '        bool zeroForOne,\n', '        uint256 swapAmount,\n', '        uint160 swapThreshold\n', '    ) {\n', '        uint slippageBPS = slippage / 1e16;\n', '        (zeroForOne, swapAmount, swapThreshold) = gelatoRouter.getRebalanceParams(IGUniPool(pool), amount0In, amount1In, uint16(slippageBPS));\n', '    }\n', '\n', '    /**\n', '     * @param user - address of user.\n', '     * @param pool - address of Gelato Pool.\n', '     * @param burnPercent - in 18 decimal where 100% = 1e18.\n', '     * @param slippage in 18 decimal where 100% = 1e18.\n', '     * @return burnAmt - Amount of pool tokens to burn.\n', '     * @return amount0 - Amount of token0 user will get.\n', '     * @return amount1 - Amount of token1 user will get.\n', '     * @return amount0Min - Min amount of token0 user should get.\n', '     * @return amount1Min - Min amount of token1 user should get.\n', '    */\n', '    function getWithdrawParams(address user, address pool, uint burnPercent, uint slippage) public view returns (uint burnAmt, uint amount0, uint amount1, uint amount0Min, uint amount1Min) {\n', '        UserData memory _data = getSinglePosition(user, pool);\n', '        burnPercent = burnPercent > 1e18 ? 1e18 : burnPercent;\n', '        burnAmt = wmul(_data.totalBal, burnPercent);\n', '        amount0 = wmul(_data.token0Bal, burnPercent);\n', '        amount1 = wmul(_data.token1Bal, burnPercent);\n', '        amount0Min = wmul(amount0, sub(1e18, slippage));\n', '        amount1Min = wmul(amount1, sub(1e18, slippage));\n', '    }\n', '\n', '}\n', '\n', 'contract InstaGUNIV3PoolResolver is Resolver {\n', '\n', '    constructor (address _stakingFactory) public {\n', '        getStakingFactory = StakingFactoryInterface(_stakingFactory);\n', '    }\n', '\n', '\n', '    string public constant name = "G-UNI-V3-Resolver-v1.0";\n', '\n', '}']