['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\Mooniswap\\1\\IMooniswapAMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'interface IMooniswapAMMV1 is IAMM {\n', '\n', '    function factory() external view returns(address);\n', '}\n', '\n', 'contract IMooniFactory {\n', '\n', '    mapping(address => mapping(address => Mooniswap)) public pools;\n', '\n', '    function deploy(address tokenA, address tokenB) external returns(Mooniswap pool) {}\n', '    function sortTokens(address tokenA, address tokenB) external pure returns(address, address) {}\n', '}\n', '\n', 'interface Mooniswap {\n', '\n', '    function fee() external view returns(uint256);\n', '\n', '    function getTokens() external view returns(address[] memory);\n', '\n', '    function decayPeriod() external pure returns(uint256);\n', '\n', '    function getBalanceForAddition(address token) external view returns(uint256);\n', '\n', '    function getBalanceForRemoval(address token) external view returns(uint256);\n', '\n', '    function getReturn(address src, address dst, uint256 amount) external view returns(uint256);\n', '\n', '    function deposit(uint256[] calldata amounts, uint256[] calldata minAmounts) external payable returns(uint256 fairSupply);\n', '\n', '    function withdraw(uint256 amount, uint256[] memory minReturns) external;\n', '\n', '    function swap(address src, address dst, uint256 amount, uint256 minReturn, address referral) external payable returns(uint256 result);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'abstract contract AMM is IAMM {\n', '\n', '    struct ProcessedLiquidityPoolData {\n', '        address liquidityPoolAddress;\n', '        uint256 liquidityPoolAmount;\n', '        address[] liquidityPoolTokens;\n', '        uint256[] tokensAmounts;\n', '        bool involvingETH;\n', '        address liquidityPoolOperator;\n', '        address receiver;\n', '    }\n', '\n', '    struct ProcessedSwapData {\n', '        bool enterInETH;\n', '        bool exitInETH;\n', '        address[] liquidityPoolAddresses;\n', '        address[] path;\n', '        address liquidityPoolOperator;\n', '        address inputToken;\n', '        uint256 amount;\n', '        address receiver;\n', '    }\n', '\n', '    mapping(address => uint256) private _tokenIndex;\n', '    address[] private _tokensToTransfer;\n', '    address[] private _operators;\n', '    uint256[] private _tokenAmounts;\n', '\n', '    string internal _name;\n', '    uint256 internal immutable _version;\n', '    address internal immutable _ethereumAddress;\n', '    uint256 internal immutable _maxTokensPerLiquidityPool;\n', '    bool internal immutable _hasUniqueLiquidityPools;\n', '\n', '    constructor(string memory name, uint256 version, address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools) {\n', '        _name = name;\n', '        _version = version;\n', '        _ethereumAddress = ethereumAddress;\n', '        _maxTokensPerLiquidityPool = maxTokensPerLiquidityPool;\n', '        _hasUniqueLiquidityPools = hasUniqueLiquidityPools;\n', '    }\n', '\n', '    receive() external virtual payable {\n', '    }\n', '\n', '    function info() view public virtual override returns(string memory, uint256) {\n', '        return (_name, _version);\n', '    }\n', '\n', '    function data() view public virtual override returns(address, uint256, bool) {\n', '        return (_ethereumAddress, _maxTokensPerLiquidityPool, _hasUniqueLiquidityPools);\n', '    }\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount = IERC20(liquidityPoolAddress).balanceOf(owner));\n', '    }\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) view public virtual override returns(uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        uint256 numerator = liquidityPoolAmount;\n', '        uint256 denominator;\n', '\n', '        (denominator, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) view public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        uint256 numerator = tokenAmount;\n', '        uint256 denominator;\n', '\n', '        for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '            if(liquidityPoolTokens[i] == tokenAddress) {\n', '                denominator =  tokensAmounts[i];\n', '                break;\n', '            }\n', '        }\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function calculatePercentage(uint256 amount, uint256 numerator, uint256 denominator) internal virtual pure returns(uint256) {\n', '        return (amount * numerator) / denominator;\n', '    }\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address receiver) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        require(tokenAddresses.length > 1 && tokenAddresses.length == amounts.length && (_maxTokensPerLiquidityPool == 0 || tokenAddresses.length == _maxTokensPerLiquidityPool), "Invalid length");\n', '        if(_hasUniqueLiquidityPools) {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = this.byTokens(tokenAddresses);\n', '            if(liquidityPoolAddress != address(0)) {\n', '                (liquidityPoolAmount, tokensAmounts, orderedTokens) = addLiquidity(LiquidityPoolData(\n', '                    liquidityPoolAddress,\n', '                    amounts[0],\n', '                    tokenAddresses[0],\n', '                    false,\n', '                    involvingETH,\n', '                    receiver\n', '                ));\n', '                return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '            }\n', '        }\n', '        address liquidityPoolCreator = _getLiquidityPoolCreator(tokenAddresses, amounts, involvingETH);\n', '        _transferToMeAndCheckAllowance(tokenAddresses, amounts, liquidityPoolCreator, involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = _createLiquidityPoolAndAddLiquidity(tokenAddresses, amounts, involvingETH, liquidityPoolCreator, receiver);\n', '        emit NewLiquidityPoolAddress(liquidityPoolAddress);\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData memory data) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        _transferToMeAndCheckAllowance(liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens, processedLiquidityPoolData.tokensAmounts, processedLiquidityPoolData.liquidityPoolOperator, data.involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts) = _addLiquidity(processedLiquidityPoolData);\n', '        _flushBack(liquidityPoolTokens);\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] memory data) payable public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            liquidityPoolTokens[i] = (processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i])).liquidityPoolTokens;\n', '            for(uint256 z = 0; z < liquidityPoolTokens[i].length; z++) {\n', '                _collect(liquidityPoolTokens[i][z], processedLiquidityPoolDataArray[i].tokensAmounts[z], processedLiquidityPoolDataArray[i].liquidityPoolOperator, processedLiquidityPoolDataArray[i].involvingETH);\n', '            }\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        _collect(_ethereumAddress, 0, address(0), false);\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _addLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function removeLiquidity(LiquidityPoolData memory data) public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens;\n', '        _transferToMeAndCheckAllowance(processedLiquidityPoolData.liquidityPoolAddress, processedLiquidityPoolData.liquidityPoolAmount, processedLiquidityPoolData.liquidityPoolOperator);\n', '        (liquidityPoolAmount, tokensAmounts) = _removeLiquidity(processedLiquidityPoolData);\n', '        _flushBack(processedLiquidityPoolData.liquidityPoolAddress);\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] memory data) public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i]);\n', '            liquidityPoolTokens[i] = processedLiquidityPoolDataArray[i].liquidityPoolTokens;\n', '            _collect(processedLiquidityPoolDataArray[i].liquidityPoolAddress, processedLiquidityPoolDataArray[i].liquidityPoolAmount, processedLiquidityPoolDataArray[i].liquidityPoolOperator, false);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _removeLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function swapLiquidity(SwapData memory data) payable public virtual override returns(uint256 outputAmount) {\n', '        ProcessedSwapData memory processedSwapData = _processSwapData(data);\n', '        _transferToMeAndCheckAllowance(processedSwapData.inputToken == _ethereumAddress && processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken, processedSwapData.amount, processedSwapData.liquidityPoolOperator);\n', '        outputAmount = _swapLiquidity(processedSwapData);\n', '        _flushBack(processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken);\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] memory data) payable public virtual override returns(uint256[] memory outputAmounts) {\n', '        ProcessedSwapData[] memory processedSwapDatas = new ProcessedSwapData[](data.length);\n', '        outputAmounts = new uint256[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedSwapDatas[i] = _processSwapData(data[i]);\n', '            _collect(processedSwapDatas[i].inputToken, processedSwapDatas[i].amount, processedSwapDatas[i].liquidityPoolOperator, processedSwapDatas[i].enterInETH);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            outputAmounts[i] = _swapLiquidity(processedSwapDatas[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address liquidityPoolAddress, address[] memory liquidityPoolTokens) internal virtual view returns(address);\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal virtual returns(uint256 outputAmount);\n', '\n', '    function _getLiquidityPoolCreator(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH) internal virtual view returns(address);\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address operator, address receiver) internal virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens);\n', '\n', '    function _processLiquidityPoolData(LiquidityPoolData memory data) internal view returns(ProcessedLiquidityPoolData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        uint256[] memory tokensAmounts;\n', '        address[] memory liquidityPoolTokens;\n', '        uint256 liquidityPoolAmount;\n', '        if(data.amountIsLiquidityPool) {\n', '            (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(data.liquidityPoolAddress, liquidityPoolAmount = data.amount);\n', '        } else {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = byTokenAmount(data.liquidityPoolAddress, data.tokenAddress, data.amount);\n', '        }\n', '        bool involvingETH = data.involvingETH;\n', '        if(_ethereumAddress == address(0)) {\n', '            involvingETH = false;\n', '            for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '                if(liquidityPoolTokens[i] == address(0)) {\n', '                    involvingETH = true;\n', '                }\n', '            }\n', '        }\n', '        return ProcessedLiquidityPoolData(\n', '            data.liquidityPoolAddress,\n', '            liquidityPoolAmount,\n', '            liquidityPoolTokens,\n', '            tokensAmounts,\n', '            involvingETH,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddress, liquidityPoolTokens),\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _processSwapData(SwapData memory data) internal view returns(ProcessedSwapData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        require(data.path.length > 0 && data.liquidityPoolAddresses.length == data.path.length, "Invalid length");\n', '        ( , ,address[] memory liquidityPoolTokens) = this.byLiquidityPool(data.liquidityPoolAddresses[0]);\n', '        return ProcessedSwapData(\n', '            data.enterInETH && data.inputToken == _ethereumAddress,\n', '            data.exitInETH && data.path[data.path.length - 1] == _ethereumAddress,\n', '            data.liquidityPoolAddresses,\n', '            data.path,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddresses[0], liquidityPoolTokens),\n', '            data.inputToken,\n', '            data.amount,\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _collect(address tokenAddress, uint256 tokenAmount, address operator, bool involvingETH) private {\n', '        address realTokenAddress = involvingETH && tokenAddress == _ethereumAddress ? address(0) : tokenAddress;\n', '        uint256 position = _tokenIndex[realTokenAddress];\n', '        if(_tokensToTransfer.length == 0 || _tokensToTransfer[position] != realTokenAddress) {\n', '            _tokenIndex[realTokenAddress] = (position = _tokensToTransfer.length);\n', '            _tokensToTransfer.push(realTokenAddress);\n', '            _operators.push(operator);\n', '            _tokenAmounts.push(0);\n', '        }\n', '        _tokenAmounts[position] = _tokenAmounts[position] + tokenAmount;\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address[] memory tokens, uint256[] memory amounts, address operator, bool involvingETH) internal {\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            _transferToMeAndCheckAllowance(involvingETH && tokens[i] == _ethereumAddress ? address(0) : tokens[i] , amounts[i], operator);\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address tokenAddress, uint256 value, address operator) internal {\n', '        _transferToMe(tokenAddress, value);\n', '        _checkAllowance(tokenAddress, value, operator);\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            _transferToMeAndCheckAllowance(_tokensToTransfer[i], _tokenAmounts[i], _operators[i]);\n', '        }\n', '    }\n', '\n', '    function _flushBackAndClear() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            delete _tokenIndex[_tokensToTransfer[i]];\n', '            _flushBack(_tokensToTransfer[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        delete _tokensToTransfer;\n', '        delete _operators;\n', '        delete _tokenAmounts;\n', '    }\n', '\n', '    function _transferToMe(address tokenAddress, uint256 value) internal virtual {\n', '        if(tokenAddress == address(0)) {\n', '            require(msg.value == value, "Incorrect eth value");\n', '            return;\n', '        }\n', '        _safeTransferFrom(tokenAddress, msg.sender, address(this), value);\n', '    }\n', '\n', '    function _flushBack(address[] memory tokenAddresses) internal {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            _flushBack(tokenAddresses[i]);\n', '        }\n', '        _flushBack(address(0));\n', '    }\n', '\n', '    function _flushBack(address tokenAddress) internal {\n', '        uint256 amount = tokenAddress == address(0) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if(tokenAddress == address(0)) {\n', '            if(address(this).balance >= amount) {\n', '                payable(msg.sender).transfer(amount);\n', '            }\n', '            return;\n', '        }\n', '        if(IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\n', '            _safeTransfer(tokenAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function _checkAllowance(address tokenAddress, uint256 value, address operator) private {\n', '        if(tokenAddress == address(0) || operator == address(0)) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if(token.allowance(address(this), operator) <= value) {\n', '            _safeApprove(tokenAddress, operator, token.totalSupply());\n', '        }\n', '    }\n', '\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\Mooniswap\\1\\MooniswapAMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'contract MooniswapAMMV1 is IMooniswapAMMV1, AMM {\n', '\n', '    address public override immutable factory;\n', '\n', '    constructor(address factoryAddress) AMM("Mooniswap", 1, address(0), 2, true) {\n', '        factory = factoryAddress;\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address, address[] memory) internal override virtual view returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokenAddresses) {\n', '\n', '        Mooniswap mooniswap = Mooniswap(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = IERC20(liquidityPoolAddress).totalSupply();\n', '\n', '        tokensAmounts = new uint256[]((tokenAddresses = mooniswap.getTokens()).length);\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = mooniswap.getBalanceForRemoval(tokenAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function byTokens(address[] memory tokens) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '\n', '        Mooniswap mooniswap = IMooniFactory(factory).pools(tokens[0], tokens[1]);\n', '\n', '        if(address(mooniswap) == address(0)) {\n', '            return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '        }\n', '\n', '        orderedTokens = mooniswap.getTokens();\n', '\n', '        liquidityPoolAmount = IERC20(liquidityPoolAddress = address(mooniswap)).totalSupply();\n', '\n', '        tokensAmounts = new uint256[](orderedTokens.length);\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = mooniswap.getBalanceForRemoval(orderedTokens[i]);\n', '        }\n', '    }\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata liquidityPoolAddresses, address[] calldata path) view public virtual override returns(uint256[] memory realAmounts) {\n', '        realAmounts = new uint256[](path.length + 1);\n', '        realAmounts[0] = tokenAmount;\n', '        for(uint256 i = 0 ; i < path.length; i++) {\n', '            realAmounts[i + 1] = Mooniswap(liquidityPoolAddresses[i]).getReturn(i == 0 ? tokenAddress : path[i - 1], path[i], realAmounts[i]);\n', '        }\n', '    }\n', '\n', '    function _getLiquidityPoolCreator(address[] memory, uint256[] memory, bool) internal virtual view override returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool, address, address receiver) internal virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '\n', '        Mooniswap mooniswap = IMooniFactory(factory).deploy(tokenAddresses[0], tokenAddresses[1]);\n', '        liquidityPoolAddress = address(mooniswap);\n', '        orderedTokens = mooniswap.getTokens();\n', '\n', '        tokensAmounts = new uint256[](orderedTokens.length);\n', '        tokensAmounts[0] = amounts[orderedTokens[0] == tokenAddresses[0] ? 0 : 1];\n', '        tokensAmounts[1] = amounts[orderedTokens[1] == tokenAddresses[1] ? 1 : 0];\n', '\n', '        for(uint256 i = 0; i < orderedTokens.length; i++) {\n', '            if(orderedTokens[i] != _ethereumAddress) {\n', '                _safeApprove(orderedTokens[i], liquidityPoolAddress, tokensAmounts[i]);\n', '            }\n', '        }\n', '\n', '        if(orderedTokens[0] != _ethereumAddress && orderedTokens[1] != _ethereumAddress) {\n', '            mooniswap.deposit(tokensAmounts, tokensAmounts);\n', '        } else {\n', '            mooniswap.deposit{value : orderedTokens[0] == _ethereumAddress ? tokensAmounts[0] : tokensAmounts[1]}(tokensAmounts, tokensAmounts);\n', '        }\n', '\n', '        _safeTransfer(liquidityPoolAddress, receiver, liquidityPoolAmount = IERC20(liquidityPoolAddress).balanceOf(address(this)));\n', '    }\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory data) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '\n', '        Mooniswap mooniswap = Mooniswap(data.liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = data.liquidityPoolAmount;\n', '        tokensAmounts = data.tokensAmounts;\n', '\n', '        for(uint256 i = 0; i < data.liquidityPoolTokens.length; i++) {\n', '            if(data.liquidityPoolTokens[i] != _ethereumAddress) {\n', '                _safeApprove(data.liquidityPoolTokens[i], data.liquidityPoolAddress, data.tokensAmounts[i]);\n', '            }\n', '        }\n', '\n', '        if(data.liquidityPoolTokens[0] != _ethereumAddress && data.liquidityPoolTokens[1] != _ethereumAddress) {\n', '            mooniswap.deposit(data.tokensAmounts, new uint256[](data.tokensAmounts.length));\n', '        } else {\n', '            mooniswap.deposit{value : data.liquidityPoolTokens[0] == _ethereumAddress ? data.tokensAmounts[0] : data.tokensAmounts[1]}(data.tokensAmounts, new uint256[](data.tokensAmounts.length));\n', '        }\n', '        _safeTransfer(data.liquidityPoolAddress, data.receiver, liquidityPoolAmount = IERC20(data.liquidityPoolAddress).balanceOf(address(this)));\n', '    }\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory data) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '\n', '        Mooniswap(data.liquidityPoolAddress).withdraw(liquidityPoolAmount = data.liquidityPoolAmount, new uint256[](2));\n', '\n', '        tokensAmounts = new uint256[](data.tokensAmounts.length);\n', '        for(uint256 i = 0; i < data.tokensAmounts.length; i++) {\n', '            if(data.liquidityPoolTokens[i] != _ethereumAddress) {\n', '                _safeTransfer(data.liquidityPoolTokens[i], data.receiver, data.tokensAmounts[i] = IERC20(data.liquidityPoolTokens[i]).balanceOf(address(this)));\n', '            } else {\n', '                payable(data.receiver).transfer(tokensAmounts[i] = address(this).balance);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal override virtual returns(uint256 outputAmount) {\n', '        outputAmount = data.amount;\n', '        for(uint256 i = 0; i < data.liquidityPoolAddresses.length; i++) {\n', '            address inputToken = i == 0 ? data.inputToken : data.path[i - 1];\n', '            if(inputToken != _ethereumAddress) {\n', '                _safeApprove(inputToken, data.liquidityPoolAddresses[i], outputAmount);\n', '            }\n', '            if(inputToken == _ethereumAddress) {\n', '                outputAmount = Mooniswap(data.liquidityPoolAddresses[i]).swap{value : outputAmount}(inputToken, data.path[i], outputAmount, 0, address(0));\n', '            } else {\n', '                outputAmount = Mooniswap(data.liquidityPoolAddresses[i]).swap(inputToken, data.path[i], outputAmount, 0, address(0));\n', '            }\n', '        }\n', '        if(data.path[data.path.length - 1] == _ethereumAddress) {\n', '            payable(data.receiver).transfer(outputAmount);\n', '        } else {\n', '            _safeTransfer(data.path[data.path.length - 1], data.receiver, outputAmount);\n', '        }\n', '    }\n', '}']