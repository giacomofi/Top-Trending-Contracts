['// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity 0.8.0;\n', '\n', "import './MateriaOperator.sol';\n", "import './IMateriaOrchestrator.sol';\n", "import './IMateriaFactory.sol';\n", "import './IMateriaPair.sol';\n", "import './IERC20.sol';\n", "import './IERC20WrapperV1.sol';\n", "import './IEthItemMainInterface.sol';\n", "import './MateriaLibrary.sol';\n", "import './TransferHelper.sol';\n", '\n', '\n', 'contract MateriaSwapper is MateriaOperator {\n', '\n', '    function _swap(address factory, uint[] memory amounts, address[] memory path, address _to) internal virtual {\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (address input, address output) = (path[i], path[i + 1]);\n', '            (address token0,) = MateriaLibrary.sortTokens(input, output);\n', '            uint amountOut = amounts[i + 1];\n', '            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n', '            address to = i < path.length - 2 ? MateriaLibrary.pairFor(factory, output, path[i + 2]) : _to;\n', '            IMateriaPair(MateriaLibrary.pairFor(factory, input, output)).swap(\n', '                amount0Out, amount1Out, to, new bytes(0)\n', '            );\n', '        }\n', '    }\n', '    \n', ' \n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public ensure(deadline) returns (uint[] memory amounts) {\n', '        \n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '\n', '        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amountIn);\n', '        \n', '        (path[0], amountIn) = _wrapErc20(path[0], amountIn, erc20Wrapper);\n', '        \n', '        bool ethItemOut;\n', '        uint itemId;\n', '        address tokenOut;\n', '        \n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        \n', '        if (!ethItemOut && bridgeToken != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '        \n', '        amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'INSUFFICIENT_OUTPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public ensure(deadline) returns (uint[] memory amounts) {\n', '        \n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        \n', '        address tokenIn = path[0];\n', '        path[0] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(IERC20WrapperV1(erc20Wrapper).object(path[0])));\n', '        \n', '        bool ethItemOut;\n', '        uint itemId;\n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        address tokenOut;\n', '        \n', '        if (!ethItemOut && address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOut =  _adjustAmount(tokenOut, amountOut);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '\n', '        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\n', '        amounts[0] = amounts[0] / (10**(18 - IERC20Data(tokenIn).decimals())) + 1;\n', '\n', "        require(amounts[0] <= amountInMax, 'EXCESSIVE_INPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransferFrom(tokenIn, msg.sender, address(this), amounts[0]);\n', '        \n', '        (, amounts[0]) = _wrapErc20(tokenIn, amounts[0], erc20Wrapper);\n', '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '    }\n', '    \n', '     function swapExactETHForTokens(\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public ensure(deadline) payable returns (uint[] memory amounts) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '\n', '        path[0] = _wrapEth(msg.value, erc20Wrapper);\n', '        \n', '        bool ethItemOut;\n', '        uint itemId;\n', '        address tokenOut;\n', '        \n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        \n', '        if (!ethItemOut && bridgeToken != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '        \n', '        amounts = MateriaLibrary.getAmountsOut(factory, msg.value, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'INSUFFICIENT_OUTPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '    }\n', '   \n', '    function swapTokensForExactETH(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public ensure(deadline) returns (uint[] memory amounts) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\n', '        \n', '        address token = path[0];\n', '        path[0] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(IERC20WrapperV1(erc20Wrapper).object(path[0])));\n', '        amountOut = amountOut * (10 ** (18 - IERC20Data(path[path.length - 1]).decimals()));\n', '\n', '        amountInMax = _adjustAmount(token, amountInMax);\n', '        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'INSUFFICIENT_INPUT_AMOUNT');\n", '\n', '        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amounts[0]);\n', '        \n', '        (path[0], amounts[0]) = _wrapErc20(token, amounts[0], erc20Wrapper);\n', '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        _swap(factory, amounts, path, address(this));\n', '        _unwrapEth(ethId, amounts[amounts.length - 1], erc20Wrapper, to);\n', '    }\n', '    \n', '    function swapExactTokensForETH(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public ensure(deadline) returns (uint[] memory amounts) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\n', '\n', '        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amountIn);\n', '        \n', '        (path[0], amountIn) = _wrapErc20(path[0], amountIn, erc20Wrapper);\n', '        \n', '        amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'INSUFFICIENT_OUTPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        _swap(factory, amounts, path, address(this));\n', '        _unwrapEth(ethId, amounts[amounts.length - 1], erc20Wrapper, to);\n', '    }\n', '    \n', '    function swapETHForExactTokens(\n', '        uint amountOut,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) public payable ensure(deadline) returns (uint[] memory amounts) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\n', '        \n', '        bool ethItemOut;\n', '        uint itemId;\n', '        address tokenOut;\n', '        \n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        \n', '        if (!ethItemOut && bridgeToken != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOut = _adjustAmount(tokenOut, amountOut);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '        \n', '        amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= msg.value, 'INSUFFICIENT_INPUT_AMOUNT');\n", '        \n', '        path[0] = _wrapEth(amounts[0], erc20Wrapper);\n', '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '        \n', '        if (msg.value > amounts[0])\n', '            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n', '    }\n', '    \n', '    function swapExactItemsForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) private ensure(deadline) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '\n', '        bool ethItemOut;\n', '        uint itemId;\n', '        address tokenOut;\n', '        \n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        \n', '        if (!ethItemOut && address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOutMin = _adjustAmount(tokenOut, amountOutMin);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '        \n', '        uint[] memory amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'INSUFFICIENT_OUTPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '    }\n', '    \n', '    function swapItemsForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        address from,\n', '        uint deadline\n', '    ) private ensure(deadline) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '\n', '        bool ethItemOut;\n', '        uint itemId;\n', '        address tokenOut;\n', '        \n', '        (ethItemOut, itemId) = _isEthItem(path[path.length - 1], erc20Wrapper);\n', '        \n', '        if (!ethItemOut && address(IMateriaOrchestrator(address(this)).bridgeToken()) != path[path.length - 1]) {\n', '            tokenOut = path[path.length - 1];\n', '            amountOut = _adjustAmount(tokenOut, amountOut);\n', '            path[path.length - 1] = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId));\n', '        }\n', '        \n', '        uint[] memory amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'INSUFFICIENT_INPUT_AMOUNT');\n", '        \n', '        {\n', '        uint amountBack;\n', '        if ((amountBack = amountInMax - amounts[0]) > 0)\n', '            TransferHelper.safeTransfer(path[0], from, amountBack);\n', '        }\n', '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        if (ethItemOut) {\n', '            _swap(factory, amounts, path, to);\n', '        } else {\n', '            _swap(factory, amounts, path, address(this));\n', '            _unwrapErc20(itemId, tokenOut, amounts[amounts.length - 1], erc20Wrapper, to);\n', '        }\n', '    }\n', '    \n', '    function swapExactItemsForEth(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) private ensure(deadline) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\n', '\n', '        uint[] memory amounts = MateriaLibrary.getAmountsOut(factory, amountIn, path);\n', "        require(amounts[amounts.length - 1] >= amountOutMin, 'INSUFFICIENT_OUTPUT_AMOUNT');\n", '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        _swap(factory, amounts, path, address(this));\n', '        \n', '        IERC20WrapperV1(erc20Wrapper).burn(\n', '            ethId,\n', '            amounts[amounts.length - 1]\n', '        );\n', '        \n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '    \n', '    function swapItemsForExactEth(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] memory path,\n', '        address to,\n', '        address from,\n', '        uint deadline\n', '    ) private ensure(deadline) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        uint ethId = uint(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID());\n', '\n', '        uint[] memory amounts = MateriaLibrary.getAmountsIn(factory, amountOut, path);\n', "        require(amounts[0] <= amountInMax, 'INSUFFICIENT_INPUT_AMOUNT');\n", '        \n', '        {\n', '        uint amountBack;\n', '        if ((amountBack = amountInMax - amounts[0]) > 0)\n', '            TransferHelper.safeTransfer(path[0], from, amountBack);\n', '        }\n', '        \n', '        TransferHelper.safeTransfer(\n', '            path[0], MateriaLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n', '        );\n', '        \n', '        _swap(factory, amounts, path, address(this));\n', '        \n', '        IERC20WrapperV1(erc20Wrapper).burn(\n', '            ethId,\n', '            amounts[amounts.length - 1]\n', '        );\n', '        \n', '        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address from,\n', '        uint,\n', '        uint value,\n', '        bytes calldata data\n', '    ) public override returns(bytes4) {\n', '        uint operation;\n', '        uint amount;\n', '        address[] memory path;\n', '        address to;\n', '        uint deadline;\n', '        \n', '        { //to avoid "stack too deep"\n', '            bytes memory payload;\n', '            (operation, payload) = abi.decode(data, (uint, bytes));\n', '            (amount, path, to, deadline) = abi.decode(payload, (uint, address[], address, uint));\n', '        }\n', '        \n', '        if (operation == 2) swapExactItemsForTokens(value, amount, path, to, deadline);\n', '        else if (operation == 3) swapItemsForExactTokens(amount, value, path, to, from, deadline);\n', '        else if (operation == 4) swapExactItemsForEth(value, amount, path, to, deadline);\n', '        else if (operation == 5) swapItemsForExactEth(amount, value, path, to, from, deadline);\n', '        else revert();\n', '        \n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        bytes calldata\n', '    ) public override pure returns(bytes4) {\n', '        revert();\n', '    }\n', '    \n', '    function supportsInterface(\n', '        bytes4\n', '    ) public override pure returns (bool) {\n', '        return false;\n', '    }\n', '}']