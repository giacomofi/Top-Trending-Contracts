['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\Balancer\\1\\IBalancerAMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'interface IBalancerAMMV1 is IAMM {\n', '}\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '\n', '    function withdraw(uint wad) external;\n', '\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function approve(address guy, uint wad) external returns (bool);\n', '\n', '    function transfer(address dst, uint wad) external returns (bool);\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        external\n', '        returns (bool);\n', '}\n', '\n', 'interface BPool {\n', '\n', '    function isPublicSwap()\n', '        external view\n', '        returns (bool);\n', '\n', '    function isFinalized()\n', '        external view\n', '        returns (bool);\n', '\n', '    function isBound(address t)\n', '        external view\n', '        returns (bool);\n', '\n', '    function getNumTokens()\n', '        external view\n', '        returns (uint);\n', '\n', '    function getCurrentTokens()\n', '        external view\n', '        returns (address[] memory tokens);\n', '\n', '    function getFinalTokens()\n', '        external view\n', '        returns (address[] memory tokens);\n', '\n', '    function getDenormalizedWeight(address token)\n', '        external view\n', '        returns (uint);\n', '\n', '    function getTotalDenormalizedWeight()\n', '        external view\n', '        returns (uint);\n', '\n', '    function getNormalizedWeight(address token)\n', '        external view\n', '        returns (uint);\n', '\n', '    function getBalance(address token)\n', '        external view\n', '        returns (uint);\n', '\n', '    function getSwapFee()\n', '        external view\n', '        returns (uint);\n', '\n', '    function getController()\n', '        external view\n', '        returns (address);\n', '\n', '    function calcOutGivenIn(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountIn,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint tokenAmountOut);\n', '\n', '    function calcInGivenOut(\n', '        uint tokenBalanceIn,\n', '        uint tokenWeightIn,\n', '        uint tokenBalanceOut,\n', '        uint tokenWeightOut,\n', '        uint tokenAmountOut,\n', '        uint swapFee\n', '    )\n', '        external pure\n', '        returns (uint tokenAmountIn);\n', '\n', '    function setSwapFee(uint swapFee)\n', '        external;\n', '\n', '    function setController(address manager)\n', '        external;\n', '\n', '    function setPublicSwap(bool public_)\n', '        external;\n', '\n', '    function finalize()\n', '        external;\n', '\n', '    function bind(address token, uint balance, uint denorm)\n', '        external;\n', '\n', '    function rebind(address token, uint balance, uint denorm)\n', '        external;\n', '\n', '    function unbind(address token)\n', '        external;\n', '\n', '    function gulp(address token)\n', '        external;\n', '\n', '    function getSpotPrice(address tokenIn, address tokenOut)\n', '        external view\n', '        returns (uint spotPrice);\n', '\n', '    function getSpotPriceSansFee(address tokenIn, address tokenOut)\n', '        external view\n', '        returns (uint spotPrice);\n', '\n', '    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\n', '        external;\n', '\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n', '        external;\n', '\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint tokenAmountIn,\n', '        address tokenOut,\n', '        uint minAmountOut,\n', '        uint maxPrice\n', '    )\n', '        external\n', '        returns (uint tokenAmountOut, uint spotPriceAfter);\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint maxAmountIn,\n', '        address tokenOut,\n', '        uint tokenAmountOut,\n', '        uint maxPrice\n', '    )\n', '        external\n', '        returns (uint tokenAmountIn, uint spotPriceAfter);\n', '\n', '    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\n', '        external\n', '        returns (uint poolAmountOut);\n', '\n', '    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\n', '        external\n', '        returns (uint tokenAmountIn);\n', '\n', '    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\n', '        external\n', '        returns (uint tokenAmountOut);\n', '\n', '    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\n', '        external\n', '        returns (uint poolAmountIn);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'abstract contract AMM is IAMM {\n', '\n', '    struct ProcessedLiquidityPoolData {\n', '        address liquidityPoolAddress;\n', '        uint256 liquidityPoolAmount;\n', '        address[] liquidityPoolTokens;\n', '        uint256[] tokensAmounts;\n', '        bool involvingETH;\n', '        address liquidityPoolOperator;\n', '        address receiver;\n', '    }\n', '\n', '    struct ProcessedSwapData {\n', '        bool enterInETH;\n', '        bool exitInETH;\n', '        address[] liquidityPoolAddresses;\n', '        address[] path;\n', '        address liquidityPoolOperator;\n', '        address inputToken;\n', '        uint256 amount;\n', '        address receiver;\n', '    }\n', '\n', '    mapping(address => uint256) private _tokenIndex;\n', '    address[] private _tokensToTransfer;\n', '    address[] private _operators;\n', '    uint256[] private _tokenAmounts;\n', '\n', '    string internal _name;\n', '    uint256 internal immutable _version;\n', '    address internal immutable _ethereumAddress;\n', '    uint256 internal immutable _maxTokensPerLiquidityPool;\n', '    bool internal immutable _hasUniqueLiquidityPools;\n', '\n', '    constructor(string memory name, uint256 version, address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools) {\n', '        _name = name;\n', '        _version = version;\n', '        _ethereumAddress = ethereumAddress;\n', '        _maxTokensPerLiquidityPool = maxTokensPerLiquidityPool;\n', '        _hasUniqueLiquidityPools = hasUniqueLiquidityPools;\n', '    }\n', '\n', '    receive() external virtual payable {\n', '    }\n', '\n', '    function info() view public virtual override returns(string memory, uint256) {\n', '        return (_name, _version);\n', '    }\n', '\n', '    function data() view public virtual override returns(address, uint256, bool) {\n', '        return (_ethereumAddress, _maxTokensPerLiquidityPool, _hasUniqueLiquidityPools);\n', '    }\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount = IERC20(liquidityPoolAddress).balanceOf(owner));\n', '    }\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) view public virtual override returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) view public virtual override returns(uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        uint256 numerator = liquidityPoolAmount;\n', '        uint256 denominator;\n', '\n', '        (denominator, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) view public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = this.byLiquidityPool(liquidityPoolAddress);\n', '\n', '        uint256 numerator = tokenAmount;\n', '        uint256 denominator;\n', '\n', '        for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '            if(liquidityPoolTokens[i] == tokenAddress) {\n', '                denominator =  tokensAmounts[i];\n', '                break;\n', '            }\n', '        }\n', '\n', '        liquidityPoolAmount = calculatePercentage(liquidityPoolAmount, numerator, denominator);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = calculatePercentage(tokensAmounts[i], numerator, denominator);\n', '        }\n', '    }\n', '\n', '    function calculatePercentage(uint256 amount, uint256 numerator, uint256 denominator) internal virtual pure returns(uint256) {\n', '        return (amount * numerator) / denominator;\n', '    }\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address receiver) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        require(tokenAddresses.length > 1 && tokenAddresses.length == amounts.length && (_maxTokensPerLiquidityPool == 0 || tokenAddresses.length == _maxTokensPerLiquidityPool), "Invalid length");\n', '        if(_hasUniqueLiquidityPools) {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = this.byTokens(tokenAddresses);\n', '            if(liquidityPoolAddress != address(0)) {\n', '                (liquidityPoolAmount, tokensAmounts, orderedTokens) = addLiquidity(LiquidityPoolData(\n', '                    liquidityPoolAddress,\n', '                    amounts[0],\n', '                    tokenAddresses[0],\n', '                    false,\n', '                    involvingETH,\n', '                    receiver\n', '                ));\n', '                return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '            }\n', '        }\n', '        address liquidityPoolCreator = _getLiquidityPoolCreator(tokenAddresses, amounts, involvingETH);\n', '        _transferToMeAndCheckAllowance(tokenAddresses, amounts, liquidityPoolCreator, involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens) = _createLiquidityPoolAndAddLiquidity(tokenAddresses, amounts, involvingETH, liquidityPoolCreator, receiver);\n', '        emit NewLiquidityPoolAddress(liquidityPoolAddress);\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData memory data) payable public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        _transferToMeAndCheckAllowance(liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens, processedLiquidityPoolData.tokensAmounts, processedLiquidityPoolData.liquidityPoolOperator, data.involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts) = _addLiquidity(processedLiquidityPoolData);\n', '        _flushBack(liquidityPoolTokens);\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] memory data) payable public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            liquidityPoolTokens[i] = (processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i])).liquidityPoolTokens;\n', '            for(uint256 z = 0; z < liquidityPoolTokens[i].length; z++) {\n', '                _collect(liquidityPoolTokens[i][z], processedLiquidityPoolDataArray[i].tokensAmounts[z], processedLiquidityPoolDataArray[i].liquidityPoolOperator, processedLiquidityPoolDataArray[i].involvingETH);\n', '            }\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        _collect(_ethereumAddress, 0, address(0), false);\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _addLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function removeLiquidity(LiquidityPoolData memory data) public virtual override returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens;\n', '        _transferToMeAndCheckAllowance(processedLiquidityPoolData.liquidityPoolAddress, processedLiquidityPoolData.liquidityPoolAmount, processedLiquidityPoolData.liquidityPoolOperator);\n', '        (liquidityPoolAmount, tokensAmounts) = _removeLiquidity(processedLiquidityPoolData);\n', '        _flushBack(processedLiquidityPoolData.liquidityPoolAddress);\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] memory data) public virtual override returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        ProcessedLiquidityPoolData[] memory processedLiquidityPoolDataArray = new ProcessedLiquidityPoolData[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedLiquidityPoolDataArray[i] = _processLiquidityPoolData(data[i]);\n', '            liquidityPoolTokens[i] = processedLiquidityPoolDataArray[i].liquidityPoolTokens;\n', '            _collect(processedLiquidityPoolDataArray[i].liquidityPoolAddress, processedLiquidityPoolDataArray[i].liquidityPoolAmount, processedLiquidityPoolDataArray[i].liquidityPoolOperator, false);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < processedLiquidityPoolDataArray.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i]) = _removeLiquidity(processedLiquidityPoolDataArray[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function swapLiquidity(SwapData memory data) payable public virtual override returns(uint256 outputAmount) {\n', '        ProcessedSwapData memory processedSwapData = _processSwapData(data);\n', '        _transferToMeAndCheckAllowance(processedSwapData.inputToken == _ethereumAddress && processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken, processedSwapData.amount, processedSwapData.liquidityPoolOperator);\n', '        outputAmount = _swapLiquidity(processedSwapData);\n', '        _flushBack(processedSwapData.enterInETH ? address(0) : processedSwapData.inputToken);\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] memory data) payable public virtual override returns(uint256[] memory outputAmounts) {\n', '        ProcessedSwapData[] memory processedSwapDatas = new ProcessedSwapData[](data.length);\n', '        outputAmounts = new uint256[](data.length);\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            processedSwapDatas[i] = _processSwapData(data[i]);\n', '            _collect(processedSwapDatas[i].inputToken, processedSwapDatas[i].amount, processedSwapDatas[i].liquidityPoolOperator, processedSwapDatas[i].enterInETH);\n', '        }\n', '        _transferToMeAndCheckAllowance();\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            outputAmounts[i] = _swapLiquidity(processedSwapDatas[i]);\n', '        }\n', '        _flushBackAndClear();\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address liquidityPoolAddress, address[] memory liquidityPoolTokens) internal virtual view returns(address);\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory processedLiquidityPoolData) internal virtual returns(uint256, uint256[] memory);\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal virtual returns(uint256 outputAmount);\n', '\n', '    function _getLiquidityPoolCreator(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH) internal virtual view returns(address);\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory tokenAddresses, uint256[] memory amounts, bool involvingETH, address operator, address receiver) internal virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens);\n', '\n', '    function _processLiquidityPoolData(LiquidityPoolData memory data) internal view returns(ProcessedLiquidityPoolData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        uint256[] memory tokensAmounts;\n', '        address[] memory liquidityPoolTokens;\n', '        uint256 liquidityPoolAmount;\n', '        if(data.amountIsLiquidityPool) {\n', '            (tokensAmounts, liquidityPoolTokens) = byLiquidityPoolAmount(data.liquidityPoolAddress, liquidityPoolAmount = data.amount);\n', '        } else {\n', '            (liquidityPoolAmount, tokensAmounts, liquidityPoolTokens) = byTokenAmount(data.liquidityPoolAddress, data.tokenAddress, data.amount);\n', '        }\n', '        bool involvingETH = data.involvingETH;\n', '        if(_ethereumAddress == address(0)) {\n', '            involvingETH = false;\n', '            for(uint256 i = 0; i < liquidityPoolTokens.length; i++) {\n', '                if(liquidityPoolTokens[i] == address(0)) {\n', '                    involvingETH = true;\n', '                }\n', '            }\n', '        }\n', '        return ProcessedLiquidityPoolData(\n', '            data.liquidityPoolAddress,\n', '            liquidityPoolAmount,\n', '            liquidityPoolTokens,\n', '            tokensAmounts,\n', '            involvingETH,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddress, liquidityPoolTokens),\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _processSwapData(SwapData memory data) internal view returns(ProcessedSwapData memory) {\n', '        require(data.amount > 0, "Zero amount");\n', '        require(data.path.length > 0 && data.liquidityPoolAddresses.length == data.path.length, "Invalid length");\n', '        ( , ,address[] memory liquidityPoolTokens) = this.byLiquidityPool(data.liquidityPoolAddresses[0]);\n', '        return ProcessedSwapData(\n', '            data.enterInETH && data.inputToken == _ethereumAddress,\n', '            data.exitInETH && data.path[data.path.length - 1] == _ethereumAddress,\n', '            data.liquidityPoolAddresses,\n', '            data.path,\n', '            _getLiquidityPoolOperator(data.liquidityPoolAddresses[0], liquidityPoolTokens),\n', '            data.inputToken,\n', '            data.amount,\n', '            data.receiver == address(0) ? msg.sender : data.receiver\n', '        );\n', '    }\n', '\n', '    function _collect(address tokenAddress, uint256 tokenAmount, address operator, bool involvingETH) private {\n', '        address realTokenAddress = involvingETH && tokenAddress == _ethereumAddress ? address(0) : tokenAddress;\n', '        uint256 position = _tokenIndex[realTokenAddress];\n', '        if(_tokensToTransfer.length == 0 || _tokensToTransfer[position] != realTokenAddress) {\n', '            _tokenIndex[realTokenAddress] = (position = _tokensToTransfer.length);\n', '            _tokensToTransfer.push(realTokenAddress);\n', '            _operators.push(operator);\n', '            _tokenAmounts.push(0);\n', '        }\n', '        _tokenAmounts[position] = _tokenAmounts[position] + tokenAmount;\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address[] memory tokens, uint256[] memory amounts, address operator, bool involvingETH) internal {\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            _transferToMeAndCheckAllowance(involvingETH && tokens[i] == _ethereumAddress ? address(0) : tokens[i] , amounts[i], operator);\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(address tokenAddress, uint256 value, address operator) internal {\n', '        _transferToMe(tokenAddress, value);\n', '        _checkAllowance(tokenAddress, value, operator);\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            _transferToMeAndCheckAllowance(_tokensToTransfer[i], _tokenAmounts[i], _operators[i]);\n', '        }\n', '    }\n', '\n', '    function _flushBackAndClear() private {\n', '        for(uint256 i = 0; i < _tokensToTransfer.length; i++) {\n', '            delete _tokenIndex[_tokensToTransfer[i]];\n', '            _flushBack(_tokensToTransfer[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        delete _tokensToTransfer;\n', '        delete _operators;\n', '        delete _tokenAmounts;\n', '    }\n', '\n', '    function _transferToMe(address tokenAddress, uint256 value) internal virtual {\n', '        if(tokenAddress == address(0)) {\n', '            require(msg.value == value, "Incorrect eth value");\n', '            return;\n', '        }\n', '        _safeTransferFrom(tokenAddress, msg.sender, address(this), value);\n', '    }\n', '\n', '    function _flushBack(address[] memory tokenAddresses) internal {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            _flushBack(tokenAddresses[i]);\n', '        }\n', '        _flushBack(address(0));\n', '    }\n', '\n', '    function _flushBack(address tokenAddress) internal {\n', '        uint256 amount = tokenAddress == address(0) ? address(this).balance : IERC20(tokenAddress).balanceOf(address(this));\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if(tokenAddress == address(0)) {\n', '            if(address(this).balance >= amount) {\n', '                payable(msg.sender).transfer(amount);\n', '            }\n', '            return;\n', '        }\n', '        if(IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\n', '            _safeTransfer(tokenAddress, msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function _checkAllowance(address tokenAddress, uint256 value, address operator) private {\n', '        if(tokenAddress == address(0) || operator == address(0)) {\n', '            return;\n', '        }\n', '        IERC20 token = IERC20(tokenAddress);\n', '        if(token.allowance(address(this), operator) <= value) {\n', '            _safeApprove(tokenAddress, operator, token.totalSupply());\n', '        }\n', '    }\n', '\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\models\\Balancer\\1\\BalancerAMMV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', 'contract BalancerAMMV1 is IBalancerAMMV1, AMM {\n', '\n', '    uint public constant BONE = 10**18;\n', '\n', '    bool private _multi;\n', '\n', '    constructor(address wethAddressInput) AMM("Balancer", 1, wethAddressInput, 0, false) {\n', '    }\n', '\n', '    function _getLiquidityPoolOperator(address, address[] memory) internal override virtual view returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokenAddresses) {\n', '\n', '        BPool pool = BPool(liquidityPoolAddress);\n', '\n', '        liquidityPoolAmount = IERC20(liquidityPoolAddress).totalSupply();\n', '\n', '        tokenAddresses = pool.getFinalTokens();\n', '\n', '        tokensAmounts = new uint256[](tokenAddresses.length);\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = pool.getBalance(tokenAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function calculatePercentage(uint256 amount, uint256 numerator, uint256 denominator) internal virtual pure override returns(uint256) {\n', '        return bmul(bdiv(numerator, denominator), amount);\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) view public virtual override(IAMM, AMM) returns(uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '\n', '        uint256 numerator = liquidityPoolAmount;\n', '        uint256 denominator;\n', '\n', '        (denominator, tokensAmounts, liquidityPoolTokens) = byLiquidityPool(liquidityPoolAddress);\n', '\n', '        for(uint256 i = 0; i < tokensAmounts.length; i++) {\n', '            tokensAmounts[i] = bmul(bdiv(numerator, denominator), tokensAmounts[i]);\n', '        }\n', '    }\n', '\n', '    function byTokens(address[] memory) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address liquidityPoolAddress, address[] memory orderedTokens) {\n', '        return (liquidityPoolAmount, tokensAmounts, liquidityPoolAddress, orderedTokens);\n', '    }\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata liquidityPoolAddresses, address[] calldata path) view public virtual override returns(uint256[] memory realAmounts) {\n', '        realAmounts = new uint256[](path.length + 1);\n', '        realAmounts[0] = tokenAmount;\n', '        for(uint256 i = 0 ; i < path.length; i++) {\n', '            BPool bPool = BPool(liquidityPoolAddresses[i]);\n', '            address tokenIn = i == 0 ? tokenAddress : path[i - 1];\n', '            tokenIn = tokenIn == address(0) ? _ethereumAddress : tokenIn;\n', '            address tokenOut = path[i] == address(0) ? _ethereumAddress : path[i];\n', '            realAmounts[i + 1] = bPool.calcOutGivenIn(\n', '                IERC20(tokenIn).balanceOf(liquidityPoolAddresses[i]),\n', '                bPool.getNormalizedWeight(tokenIn),\n', '                IERC20(tokenOut).balanceOf(liquidityPoolAddresses[i]),\n', '                bPool.getNormalizedWeight(tokenOut),\n', '                realAmounts[i],\n', '                bPool.getSwapFee()\n', '            );\n', '        }\n', '    }\n', '\n', '    function _getLiquidityPoolCreator(address[] memory, uint256[] memory, bool) internal virtual view override returns(address) {\n', '        return address(0);\n', '    }\n', '\n', '    function _createLiquidityPoolAndAddLiquidity(address[] memory, uint256[] memory, bool, address, address) internal virtual override returns(uint256, uint256[] memory, address, address[] memory) {\n', '        revert("Balancer");\n', '    }\n', '\n', '    function _addLiquidity(ProcessedLiquidityPoolData memory data) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '        for(uint256 i = 0; i < data.liquidityPoolTokens.length; i++) {\n', '            if(data.involvingETH && data.liquidityPoolTokens[i] == _ethereumAddress) {\n', '                IWETH(_ethereumAddress).deposit{value : data.tokensAmounts[i]}();\n', '            }\n', '            _safeApprove(data.liquidityPoolTokens[i], data.liquidityPoolAddress, data.tokensAmounts[i]);\n', '        }\n', '        BPool(data.liquidityPoolAddress).joinPool(liquidityPoolAmount = data.liquidityPoolAmount, tokensAmounts = data.tokensAmounts);\n', '        _safeTransfer(data.liquidityPoolAddress, data.receiver, liquidityPoolAmount);\n', '    }\n', '\n', '    function _removeLiquidity(ProcessedLiquidityPoolData memory data) internal override virtual returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts) {\n', '        BPool(data.liquidityPoolAddress).exitPool(liquidityPoolAmount = data.liquidityPoolAmount, data.tokensAmounts);\n', '        tokensAmounts = new uint256[](data.tokensAmounts.length);\n', '        for(uint256 i = 0; i < data.tokensAmounts.length; i++) {\n', '            bool eth = data.involvingETH && data.liquidityPoolTokens[i] == _ethereumAddress;\n', '            if(!eth) {\n', '                _safeTransfer(data.liquidityPoolTokens[i], data.receiver, data.tokensAmounts[i] = IERC20(data.liquidityPoolTokens[i]).balanceOf(address(this)));\n', '            } else {\n', '                if(!_multi) {\n', '                    IWETH(_ethereumAddress).withdraw(tokensAmounts[i] = IERC20(_ethereumAddress).balanceOf(address(this)));\n', '                    payable(data.receiver).transfer(tokensAmounts[i]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function _swapLiquidity(ProcessedSwapData memory data) internal override virtual returns(uint256 outputAmount) {\n', '        if(data.enterInETH) {\n', '            IWETH(_ethereumAddress).deposit{value : data.amount}();\n', '        }\n', '        outputAmount = data.amount;\n', '        for(uint256 i = 0; i < data.liquidityPoolAddresses.length; i++) {\n', '            address inputToken = i == 0 ? data.enterInETH ? _ethereumAddress : data.inputToken : data.path[i - 1];\n', '            _safeApprove(inputToken, data.liquidityPoolAddresses[i], outputAmount);\n', '            address outputToken = i != data.liquidityPoolAddresses.length - 1 || !data.exitInETH ? data.path[i] : _ethereumAddress;\n', '            (outputAmount, ) = BPool(data.liquidityPoolAddresses[i]).swapExactAmountIn(inputToken, outputAmount, outputToken, 1, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n', '        }\n', '        if(data.exitInETH) {\n', '            IWETH(_ethereumAddress).withdraw(outputAmount);\n', '            payable(data.receiver).transfer(outputAmount);\n', '        } else {\n', '            _safeTransfer(data.path[data.path.length - 1], data.receiver, outputAmount);\n', '        }\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData memory data) payable public virtual override(IAMM, AMM) returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory liquidityPoolTokens) {\n', '        ProcessedLiquidityPoolData memory processedLiquidityPoolData = _processLiquidityPoolData(data);\n', '        _transferToMeAndCheckAllowance(liquidityPoolTokens = processedLiquidityPoolData.liquidityPoolTokens, processedLiquidityPoolData.tokensAmounts, processedLiquidityPoolData.liquidityPoolOperator, data.involvingETH);\n', '        (liquidityPoolAmount, tokensAmounts) = _addLiquidity(processedLiquidityPoolData);\n', '        if(!_multi) {\n', '            _flushBack(liquidityPoolTokens);\n', '        }\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] memory data) payable public virtual override(IAMM, AMM) returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        _multi = true;\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i], liquidityPoolTokens[i]) = addLiquidity(data[i]);\n', '        }\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            _flushBack(liquidityPoolTokens[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        _multi = false;\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] memory data) public virtual override(IAMM, AMM) returns(uint256[] memory liquidityPoolAmounts, uint256[][] memory tokensAmounts, address[][] memory liquidityPoolTokens) {\n', '        liquidityPoolAmounts = new uint256[](data.length);\n', '        tokensAmounts = new uint256[][](data.length);\n', '        liquidityPoolTokens = new address[][](data.length);\n', '        _multi = true;\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            (liquidityPoolAmounts[i], tokensAmounts[i], liquidityPoolTokens[i]) = removeLiquidity(data[i]);\n', '        }\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            _flushBack(liquidityPoolTokens[i]);\n', '        }\n', '        _flushBack(address(0));\n', '        _multi = false;\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] memory data) payable public virtual override(IAMM, AMM) returns(uint256[] memory outputAmounts) {\n', '        outputAmounts = new uint256[](data.length);\n', '        _multi = true;\n', '        for(uint256 i = 0; i < data.length; i++) {\n', '            outputAmounts[i] = swapLiquidity(data[i]);\n', '        }\n', '        _multi = false;\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint a, uint b)\n', '        internal pure\n', '        returns (uint)\n', '    {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '}']