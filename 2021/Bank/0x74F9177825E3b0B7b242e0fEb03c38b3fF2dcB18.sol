['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC721Receiver.sol";\n', 'import "./ERC165.sol";\n', "import './Events721.sol';\n", "import './Ownable.sol';\n", '\n', 'interface IERC721 {\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '    function approve(address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '}\n', '\n', 'interface IAPYMONPACK {\n', '    function isLocked(uint256 eggId) external view returns (bool locked, uint256 endTime);\n', '    function isOpened(uint256 eggId) external view returns (bool);\n', '}\n', '\n', 'interface ISwap {\n', '    function swapErc721(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external;\n', '}\n', '\n', 'contract ApymonPack721 is ERC165, IERC721Receiver, Context, Events721, Ownable {\n', '\n', '    // Mapping from egg ID -> tokens\n', '    mapping(uint256 => address[]) private _insideTokens;\n', '\n', '    // Mapping from egg ID -> token(erc721) -> ids\n', '    mapping(uint256 => mapping(address => uint256[])) private _insideTokenIds;\n', '\n', '    IERC721 public _apymon;\n', '    IAPYMONPACK public _apymonPack;\n', '\n', '    ISwap public _swap;\n', '\n', '    modifier onlyEggOwner(uint256 eggId) {\n', '        require(_apymon.exists(eggId));\n', '        require(_apymon.ownerOf(eggId) == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier unlocked(uint256 eggId) {\n', '        (bool locked, ) = _apymonPack.isLocked(eggId);\n', '        require(!locked, "Egg has been locked.");\n', '        _;\n', '    }\n', '\n', '    modifier opened(uint256 eggId) {\n', '        require(_apymonPack.isOpened(eggId), "Egg has been closed");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', '        _apymon = IERC721(0x9C008A22D71B6182029b694B0311486e4C0e53DB);\n', '        _apymonPack = IAPYMONPACK(0x3dFCB488F6e96654e827Ab2aB10a463B9927d4f9);\n', '    }\n', '\n', '    // View functions\n', '\n', '    /**\n', '     * @dev check if egg token id exists in egg.\n', '     */\n', '    function existsId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 id\n', '    ) public view returns (bool) {\n', '        uint256[] memory ids = _insideTokenIds[eggId][token];\n', '\n', '        for (uint256 i; i < ids.length; i++) {\n', '            if (ids[i] == id) {\n', '                return true;\n', '            }\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if tokenId exists in egg\n', '     */\n', '    function getInsideTokensCount(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (\n', '        uint256 erc721Len\n', '    ) {\n', '        return _insideTokens[eggId].length;\n', '    }\n', '\n', '    /**\n', '     * @dev get ERC721 token info\n', '     */\n', '    function getERC721Tokens(\n', '        uint256 eggId\n', '    ) public view opened(eggId) returns (\n', '        address[] memory addresses,\n', '        uint256[] memory tokenBalances\n', '    ) {\n', '        address[] memory tokens = _insideTokens[eggId];\n', '        uint256 erc721Len = tokens.length;\n', '        \n', '        tokenBalances = new uint256[](erc721Len);\n', '        addresses = new address[](erc721Len);\n', '        uint256 j;\n', '\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            addresses[j] = tokens[i];\n', '            tokenBalances[j] = _insideTokenIds[eggId][tokens[i]].length;\n', '            j++;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev get ERC721 ids\n', '     */\n', '    function getTokenIds(\n', '        uint256 eggId,\n', '        address insideToken\n', '    ) public view opened(eggId) returns (uint256[] memory) {\n', '        return _insideTokenIds[eggId][insideToken];\n', '    }\n', '\n', '    // Write functions\n', '\n', '    function setSwap(address swap) external onlyOwner {\n', '        _swap = ISwap(swap);\n', '    }\n', '\n', '    function setApymonPack(address _pack) external onlyOwner {\n', '        _apymonPack = IAPYMONPACK(_pack);\n', '    }\n', '\n', '    /**\n', '     * @dev deposit erc721 tokens into egg.\n', '     */\n', '    function depositErc721IntoEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds\n', '    ) external {\n', '        require(token != address(0));\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            require(\n', '                token != address(_apymon) ||\n', '                (token == address(_apymon) && eggId != tokenIds[i])\n', '            );\n', '            IERC721 iToken = IERC721(token);\n', '            \n', '            iToken.safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                tokenIds[i]\n', '            );\n', '\n', '            _putInsideTokenId(\n', '                eggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            if (_apymonPack.isOpened(eggId)) {\n', '                emit DepositedErc721IntoEgg(\n', '                    eggId,\n', '                    msg.sender,\n', '                    token,\n', '                    tokenIds[i]\n', '                );\n', '            }\n', '        }\n', '\n', '        _putTokenIntoEgg(\n', '            eggId,\n', '            token\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw erc721 token from egg.\n', '     */\n', '    function withdrawErc721FromEgg(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        address to\n', '    ) public onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(token != address(0));\n', '        IERC721 iToken = IERC721(token);\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            address tokenOwner = iToken.ownerOf(tokenIds[i]);\n', '\n', '            require(tokenOwner == address(this));\n', '\n', '            iToken.safeTransferFrom(\n', '                tokenOwner,\n', '                to,\n', '                tokenIds[i]\n', '            );\n', '\n', '            _popInsideTokenId(\n', '                eggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            emit WithdrewErc721FromEgg(\n', '                eggId,\n', '                msg.sender,\n', '                token,\n', '                tokenIds[i],\n', '                to\n', '            );\n', '        }\n', '\n', '        uint256[] memory ids = _insideTokenIds[eggId][token];\n', '\n', '        if (ids.length == 0) {\n', '            _popTokenFromEgg(\n', '                eggId,\n', '                token\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send erc721 tokens from my egg to another egg.\n', '     */\n', '    function sendErc721(\n', '        uint256 fromEggId,\n', '        address token,\n', '        uint256[] memory tokenIds,\n', '        uint256 toEggId\n', '    ) public onlyEggOwner(fromEggId) unlocked(fromEggId) opened(fromEggId) {\n', '        require(fromEggId != toEggId);\n', '        require(token != address(0));\n', '        require(_apymon.exists(toEggId));\n', '\n', '        for (uint256 i; i < tokenIds.length; i++) {\n', '            _popInsideTokenId(\n', '                fromEggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            _putInsideTokenId(\n', '                toEggId,\n', '                token,\n', '                tokenIds[i]\n', '            );\n', '\n', '            emit SentErc721(\n', '                fromEggId,\n', '                msg.sender,\n', '                token,\n', '                tokenIds[i],\n', '                toEggId\n', '            );\n', '        }\n', '\n', '        uint256[] memory ids = _insideTokenIds[fromEggId][token];\n', '\n', '        if (ids.length == 0) {\n', '            _popTokenFromEgg(\n', '                fromEggId,\n', '                token\n', '            );\n', '        }\n', '\n', '        _putTokenIntoEgg(\n', '            toEggId,\n', '            token\n', '        );\n', '    }\n', '\n', '    function swapErc721(\n', '        uint256 eggId,\n', '        address inToken,\n', '        uint256 inId,\n', '        address outToken,\n', '        uint8 router,\n', '        address to\n', '    ) external onlyEggOwner(eggId) unlocked(eggId) opened(eggId) {\n', '        require(address(_swap) != address(0));\n', '        require(existsId(eggId, inToken, inId));\n', '        \n', '        IERC721(inToken).approve(address(_swap), inId);\n', '\n', '        _swap.swapErc721(\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            outToken,\n', '            router,\n', '            to\n', '        );\n', '        emit SwapedErc721(\n', '            msg.sender,\n', '            eggId,\n', '            inToken,\n', '            inId,\n', '            outToken,\n', '            to\n', '        );\n', '\n', '        _popInsideTokenId(\n', '            eggId,\n', '            inToken,\n', '            inId\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev private function to put a token id to egg\n', '     */\n', '    function _putInsideTokenId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] storage ids = _insideTokenIds[eggId][token];\n', '        ids.push(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev private function to pop a token id from egg\n', '     */\n', '    function _popInsideTokenId(\n', '        uint256 eggId,\n', '        address token,\n', '        uint256 tokenId\n', '    ) private {\n', '        uint256[] storage ids = _insideTokenIds[eggId][token];\n', '        for (uint256 i; i < ids.length; i++) {\n', '            if (ids[i] == tokenId) {\n', '                ids[i] = ids[ids.length - 1];\n', '                ids.pop();\n', '            }\n', '        }\n', '\n', '        if (ids.length == 0) {\n', '            delete _insideTokenIds[eggId][token];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev put token(type, address) to egg\n', '     */\n', '    function _putTokenIntoEgg(\n', '        uint256 eggId,\n', '        address tokenAddress\n', '    ) private {\n', '        address[] storage tokens = _insideTokens[eggId];\n', '        bool exists = false;\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            if (tokens[i] == tokenAddress) {\n', '                exists = true;\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (!exists) {\n', '            tokens.push(tokenAddress);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev pop token(type, address) from egg\n', '     */\n', '    function _popTokenFromEgg(\n', '        uint256 eggId,\n', '        address tokenAddress\n', '    ) private {\n', '        address[] storage tokens = _insideTokens[eggId];\n', '        for (uint256 i; i < tokens.length; i++) {\n', '            if (tokens[i] == tokenAddress) {\n', '                tokens[i] = tokens[tokens.length - 1];\n', '                tokens.pop();\n', '                break;\n', '            }\n', '        }\n', '\n', '        if (tokens.length == 0) {\n', '            delete _insideTokens[eggId];\n', '        }\n', '    }\n', '   \n', '    function onERC721Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        bytes calldata\n', '    ) external pure override returns (bytes4) {\n', '        return this.onERC721Received.selector;\n', '    }\n', '}']