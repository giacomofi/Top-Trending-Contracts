['/**\n', ' *Submitted for verification at Etherscan.io on 2021-01-31\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; \n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', 'contract DIAMONDHANDS is Context, IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _diamondHandsValueOwned;\n', '    mapping (address => uint256) private _tokenValueOwned;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    mapping (address => bool) private _isExcluded;\n', '    address[] private _excluded;\n', '\n', "    string private _name = 'DiamondHands';\n", "    string private _symbol = 'HODL';\n", '    uint8 private constant _decimals = 8;   \n', '    uint256 private constant MAX = ~uint256(0);\n', '    uint256 private  _totalSupply = 4200000000 * 10**uint256(_decimals);\n', '    uint256 private _maxSupplyGen = (MAX - (MAX % _totalSupply));\n', '    uint256 private _CurTotalFee;\n', '    uint256 private feePercent = 5;\n', '    bool private Buylimitactive = true;\n', '    uint256 private BuyLimit = 63000000 * 10**uint256(_decimals);\n', '\n', ' \n', '\n', '    constructor () public {\n', '        _diamondHandsValueOwned[_msgSender()] = _maxSupplyGen;\n', '        emit Transfer(address(0), _msgSender(), _totalSupply);\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        if (_isExcluded[account]) return _tokenValueOwned[account];\n', '        return tokenFromBeingStrongHodler(_diamondHandsValueOwned[account]);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowed[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowed[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowed[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '   function setBuylimitactive (bool limitactivechanger) external onlyOwner() {\n', '\n', '    Buylimitactive = limitactivechanger;\n', '    \n', '    \n', '  }\n', '\n', '    function isExcluded(address account) public view returns (bool) {\n', '        return _isExcluded[account];\n', '    }\n', '\n', '    function totalFees() public view returns (uint256) {\n', '        return _CurTotalFee;\n', '    }\n', '\n', '\n', '    //Update actual values of accounts and distribute on transfer, automatic getter and exec\n', '    function diamondHandReward(uint256 valueToken) public {\n', '        address sender = _msgSender();\n', '        require(!_isExcluded[sender], "Excluded addresses cannot call this function");\n', '        (uint256 valueDiamondHands,,,,) = _getValues(valueToken);\n', '        _diamondHandsValueOwned[sender] = _diamondHandsValueOwned[sender].sub(valueDiamondHands);\n', '        _maxSupplyGen = _maxSupplyGen.sub(valueDiamondHands);\n', '        _CurTotalFee = _CurTotalFee.add(valueToken);\n', '    }\n', '\n', '\n', '\n', '    function tokenFromBeingStrongHodler(uint256 valueDiamondHands) public view returns(uint256) {\n', '        require(valueDiamondHands <= _maxSupplyGen, "Amount must be less than max Supply generated");\n', '        uint256 currentRate =  _getRate();\n', '        return valueDiamondHands.div(currentRate);\n', '    }\n', '\n', '    function getActualBuyLimit() public view returns (uint256){\n', '    return BuyLimit;\n', '  }\n', '\n', '    function excludeAccount(address account) external onlyOwner() {\n', '        _excludeAccount(account);\n', '\n', '    }\n', '\n', '    function _excludeAccount(address account) internal{\n', '        require(!_isExcluded[account], "Account is already excluded");\n', '        if(_diamondHandsValueOwned[account] > 0) {\n', '            _tokenValueOwned[account] = tokenFromBeingStrongHodler(_diamondHandsValueOwned[account]);\n', '        }\n', '        _isExcluded[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '\n', '\n', '\n', '\n', '    function includeAccount(address account) external onlyOwner() {\n', '        require(_isExcluded[account], "Account is not excluded");\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _tokenValueOwned[account] = 0;\n', '                _isExcluded[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    function _approve(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '       _allowed[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) private {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        // No limit on Dev wallet and UniSwap Contract so liquidity can be added\n', '        if(Buylimitactive && msg.sender != owner() && msg.sender != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D){\n', '        require(amount <= BuyLimit);           // Buylimit not allowed to be over actualBuylimit\n', '      }\n', '\n', '        if(_isExcluded[sender]){\n', '            if(_isExcluded[recipient]){\n', '                _transferBothExcluded(sender, recipient, amount); \n', '            }else{\n', '                _transferFromExcluded(sender, recipient, amount);\n', '            }\n', '        }else{\n', '            if(_isExcluded[recipient]){\n', '                _transferToExcluded(sender, recipient, amount);    \n', '            }else{\n', '                _transferStandard(sender, recipient, amount);  \n', '            }\n', '        }\n', '\n', '    }\n', '\n', '    function _transferStandard(address sender, address recipient, uint256 valueToken) private {\n', '        (uint256 valueDiamondHands, uint256 valueDiamondHandsTransfer, uint256 valueDiamondHandsFee, uint256 valueTokenTransfer, uint256 valueTokenFee) = _getValues(valueToken);\n', '        _diamondHandsValueOwned[sender] = _diamondHandsValueOwned[sender].sub(valueDiamondHands);\n', '        _diamondHandsValueOwned[recipient] = _diamondHandsValueOwned[recipient].add(valueDiamondHandsTransfer);       \n', '        _tradingFee(valueDiamondHandsFee, valueTokenFee);\n', '        emit Transfer(sender, recipient, valueTokenTransfer);\n', '    }\n', '\n', '    function _transferToExcluded(address sender, address recipient, uint256 valueToken) private {\n', '        (uint256 valueDiamondHands, uint256 valueDiamondHandsTransfer, uint256 valueDiamondHandsFee, uint256 valueTokenTransfer, uint256 valueTokenFee) = _getValues(valueToken);\n', '        _diamondHandsValueOwned[sender] = _diamondHandsValueOwned[sender].sub(valueDiamondHands);\n', '        _tokenValueOwned[recipient] = _tokenValueOwned[recipient].add(valueTokenTransfer);\n', '        _diamondHandsValueOwned[recipient] = _diamondHandsValueOwned[recipient].add(valueDiamondHandsTransfer);           \n', '        _tradingFee(valueDiamondHandsFee, valueTokenFee);\n', '        emit Transfer(sender, recipient, valueTokenTransfer);\n', '    }\n', '\n', '    function _transferFromExcluded(address sender, address recipient, uint256 valueToken) private {\n', '        (uint256 valueDiamondHands, uint256 valueDiamondHandsTransfer, uint256 valueDiamondHandsFee, uint256 valueTokenTransfer, uint256 valueTokenFee) = _getValues(valueToken);\n', '        _tokenValueOwned[sender] = _tokenValueOwned[sender].sub(valueToken);\n', '        _diamondHandsValueOwned[sender] = _diamondHandsValueOwned[sender].sub(valueDiamondHands);\n', '        _diamondHandsValueOwned[recipient] = _diamondHandsValueOwned[recipient].add(valueDiamondHandsTransfer);   \n', '        _tradingFee(valueDiamondHandsFee, valueTokenFee);\n', '        emit Transfer(sender, recipient, valueTokenTransfer);\n', '    }\n', '\n', '    function _transferBothExcluded(address sender, address recipient, uint256 valueToken) private {\n', '        (uint256 valueDiamondHands, uint256 valueDiamondHandsTransfer, uint256 valueDiamondHandsFee, uint256 valueTokenTransfer, uint256 valueTokenFee) = _getValues(valueToken);\n', '        _tokenValueOwned[sender] = _tokenValueOwned[sender].sub(valueToken);\n', '        _diamondHandsValueOwned[sender] = _diamondHandsValueOwned[sender].sub(valueDiamondHands);\n', '        _tokenValueOwned[recipient] = _tokenValueOwned[recipient].add(valueTokenTransfer);\n', '        _diamondHandsValueOwned[recipient] = _diamondHandsValueOwned[recipient].add(valueDiamondHandsTransfer);        \n', '        _tradingFee(valueDiamondHandsFee, valueTokenFee);\n', '        emit Transfer(sender, recipient, valueTokenTransfer);\n', '    }\n', '\n', '    function _tradingFee(uint256 valueDiamondHandsFee, uint256 valueTokenFee) private {\n', '        _maxSupplyGen = _maxSupplyGen.sub(valueDiamondHandsFee);\n', '        _CurTotalFee = _CurTotalFee.add(valueTokenFee);\n', '    }\n', '\n', '    function _getRate() private view returns(uint256) {\n', '        (uint256 diamondHandsSupply, uint256 tokenSupply) = _getCurrentSupply();\n', '        return diamondHandsSupply.div(tokenSupply);\n', '    }\n', '\n', '    function _getCurrentSupply() private view returns(uint256, uint256) {\n', '        uint256 diamondHandsSupply = _maxSupplyGen;\n', '        uint256 tokenSupply = _totalSupply;      \n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_diamondHandsValueOwned[_excluded[i]] > diamondHandsSupply || _tokenValueOwned[_excluded[i]] > tokenSupply){\n', '                    return (_maxSupplyGen, _totalSupply);\n', '                } \n', '            diamondHandsSupply = diamondHandsSupply.sub(_diamondHandsValueOwned[_excluded[i]]);\n', '            tokenSupply = tokenSupply.sub(_tokenValueOwned[_excluded[i]]);\n', '        }\n', '        if (diamondHandsSupply < _maxSupplyGen.div(_totalSupply)){\n', '                return (_maxSupplyGen, _totalSupply);\n', '            } \n', '        return (diamondHandsSupply, tokenSupply);\n', '    }\n', '\n', '\n', '    function _getValues(uint256 valueToken) private view returns (uint256, uint256, uint256, uint256, uint256) {\n', '        (uint256 valueTokenTransfer, uint256 valueTokenFee) = _getTokenValues(valueToken,feePercent);\n', '        uint256 currentRate =  _getRate();\n', '        (uint256 valueDiamondHands, uint256 valueDiamondHandsTransfer, uint256 valueDiamondHandsFee) = _getDiamondHandsValues(valueToken, valueTokenFee, currentRate);\n', '        return (valueDiamondHands, valueDiamondHandsTransfer, valueDiamondHandsFee, valueTokenTransfer, valueTokenFee);\n', '    }\n', '\n', '    function _getTokenValues(uint256 valueToken, uint256 feePerc) private pure returns (uint256, uint256) {\n', '        uint256 valueTokenFee = valueToken.div(100/feePerc);\n', '        uint256 valueTokenTransfer = valueToken.sub(valueTokenFee);\n', '        return (valueTokenTransfer, valueTokenFee);\n', '    }\n', '\n', '    function _getDiamondHandsValues(uint256 valueToken, uint256 valueTokenFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n', '        uint256 valueDiamondHands = valueToken.mul(currentRate);\n', '        uint256 valueDiamondHandsFee = valueTokenFee.mul(currentRate);\n', '        uint256 valueDiamondHandsTransfer = valueDiamondHands.sub(valueDiamondHandsFee);\n', '        return (valueDiamondHands, valueDiamondHandsTransfer, valueDiamondHandsFee);\n', '    }\n', '\n', '\n', '\n', '}']