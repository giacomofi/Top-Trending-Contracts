['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', '// Price Oracle for Stabinol Token\n', '// This contract uses both Chainlink and Uniswap to obtain the token price\n', '// It initially uses 10 minute averages but can be updated on the fly by governance\n', '\n', 'pragma solidity 0.6.6;\n', '\n', '\n', 'interface AggregatorV3Interface {\n', '  function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n', '}\n', '\n', 'interface UniswapV2Pair {\n', '    function price0CumulativeLast() external view returns (uint256);\n', '    function price1CumulativeLast() external view returns (uint256);\n', '    function getReserves() external view returns (uint112, uint112, uint32);\n', '}\n', '\n', 'contract StabinolPriceOracle {\n', '\n', '    address public owner;\n', '    bool private _firstCapture = true;\n', '    uint256 private _stolUSDPrice = 0;\n', '    uint256 private _stolPriceWindow = 0; // The time period this price was calculated over, determines its weight\n', '    uint256 private _tokenIndex = 0;\n', '    uint256 public lastSTOLPriceUpdate; // The last time the price was updated\n', '    uint256 public updateFrequency = 10 minutes; // Oracle can be updated at least every 10 minutes\n', '    \n', '    address constant CHAINLINK_ETH_ORACLE = address(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n', '    uint256 constant DIVISION_FACTOR = 100000;\n', '    \n', '    // TWAP details\n', '    address public stolLiquidity;\n', '    uint256 private lastTWAPCumulativePrice;\n', '    uint32 private lastTWAPBlockTime;\n', '    uint256 private lastTWAPPrice;\n', '    \n', '    // Events\n', '    event NoLiquidity();\n', '    event FirstPriceCapture(); // First time price update is called, must wait til another time to update\n', '    event FailedPriceCapture(); // Not quick enough price movement for a twap to be calculated\n', '    \n', '    constructor(address _lp, uint256 _index) public {\n', '        owner = msg.sender;\n', '        stolLiquidity = _lp; // This is the address to the Uniswap pair\n', '        _tokenIndex = _index; // STOL could be in either position 1 or position 2\n', '    }\n', '    \n', '    modifier onlyGovernance() {\n', '        require(owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    \n', '    function getETHUSD() public view returns (uint256) {\n', '        // Returns this price with 18 decimal places\n', '        AggregatorV3Interface ethOracle = AggregatorV3Interface(CHAINLINK_ETH_ORACLE);\n', '        ( , int intEthPrice, , , ) = ethOracle.latestRoundData(); // We only want the answer \n', '        return uint256(intEthPrice) * 1e10;\n', '    }\n', '    \n', '    function getLatestSTOLUSD() external view returns (uint256) {\n', '        // Returns the stored price\n', '        return _stolUSDPrice;\n', '    }\n', '    \n', '    function governanceChangeFrequency(uint256 _freq) external onlyGovernance {\n', '        updateFrequency = _freq;\n', '    }\n', '    \n', '    function updateSTOLPrice() external {\n', '        if(now < lastSTOLPriceUpdate + updateFrequency){ return; } // Do nothing if update is called too soon\n', '        uint256 period = now - lastSTOLPriceUpdate; // Get the time between the last update and now\n', '        lastSTOLPriceUpdate = now;\n', '        // We will use a combination of the Twap and weighted averages to determine the current price\n', '        UniswapV2Pair pair = UniswapV2Pair(stolLiquidity);\n', '        (, uint112 reserve1, uint32 _blockTime) = pair.getReserves();\n', '        if(reserve1 == 0){\n', "            // Liquidity is gone/non-existant, can't update the price\n", '            // Reset the oracle\n', '            _stolUSDPrice = 0;\n', '            _stolPriceWindow = 0;\n', '            lastTWAPBlockTime = 0;\n', '            lastTWAPCumulativePrice = 0;\n', '            _firstCapture = true;\n', '            emit NoLiquidity();\n', '            return;\n', '        }\n', '        if(lastTWAPBlockTime != _blockTime){\n', '            // Uniswap twap price has updated, update our twap price\n', '            if(_firstCapture == true){\n', '                // Never had a price before, save the price accumulators\n', '                if(_tokenIndex == 0){\n', '                    lastTWAPCumulativePrice = pair.price0CumulativeLast();\n', '                }else{\n', '                    lastTWAPCumulativePrice = pair.price1CumulativeLast();\n', '                }\n', '                lastTWAPBlockTime = _blockTime;\n', '                _firstCapture = false;\n', '                emit FirstPriceCapture();\n', '                return;\n', '            }else{\n', '                // We already have a price cumulative, capture a new price\n', '                uint256 cumuPrice = 0;\n', '                if(_tokenIndex == 0){\n', '                    cumuPrice = pair.price0CumulativeLast();\n', '                }else{\n', '                    cumuPrice = pair.price1CumulativeLast();\n', '                }\n', '                // This is price in relationship to base pair\n', '                lastTWAPPrice = ((cumuPrice - lastTWAPCumulativePrice) / (_blockTime - lastTWAPBlockTime) * 1e18) >> 112;\n', '                lastTWAPCumulativePrice = cumuPrice;\n', '                lastTWAPBlockTime = _blockTime;\n', '            }\n', '        }\n', '        if(lastTWAPPrice == 0){\n', '            // Still no price calculation possible since no action on trading pair since last call\n', '            emit FailedPriceCapture();\n', '            return;\n', '        }\n', '        if(_stolPriceWindow == 0){\n', '            // First time price is calculated, set it to the twap price in USD\n', '            _stolPriceWindow = updateFrequency;\n', '            // Now calculate USD price from ETH Price\n', '            _stolUSDPrice = getETHUSD() / 1e10 * lastTWAPPrice / 1e8;\n', '        }else{\n', '            // There is already a price window and price, use weighted averages to determine the weight\n', '            uint256 price = getETHUSD() / 1e10 * lastTWAPPrice / 1e8;\n', '            _stolUSDPrice = (_stolUSDPrice * (_stolPriceWindow * DIVISION_FACTOR / (_stolPriceWindow + period)) / DIVISION_FACTOR);\n', '            _stolUSDPrice += (price * (period * DIVISION_FACTOR / (_stolPriceWindow + period)) / DIVISION_FACTOR);\n', '            _stolPriceWindow = period; // Set the window to the new period\n', '        }\n', '    }\n', '\n', '}']