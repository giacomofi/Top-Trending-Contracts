['// SPDX-License-Identifier: P-P-P-PONZO!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./TokensRecoverable.sol";\n', 'import "./IERC31337.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./IERC20.sol";\n', 'import "./RootKitTransferGate.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IPonzoMaBobberG1.sol";\n', 'import "./IFloorCalculator.sol";\n', '\n', '\n', 'contract PonzoMaBobberG1 is TokensRecoverable, IPonzoMaBobberG1\n', '\n', '    /*\n', '        Rooted-Ponzo-Ma-BobberV69.sol\n', '        Status: Fully functional ReKETH Edition     \n', '        Calibration: Saving the day\n', '        \n', '        The Ponzo-Ma-Bobber is a contract with access to critical system control\n', '        functions and liquidity tokens for ERC31337 / rooted token sets. it uses\n', '        the ERC-31337 sweeper functionality to streamline forced unit-value gain\n', '\n', '        Created by @ProfessorPonzo\n', '    */\n', '\n', '{\n', '    using SafeMath for uint256;\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    IERC20 rooted;\n', '    IERC20 base;\n', '    IERC31337 elite;\n', '    IERC20 rootedEliteLP;\n', '    IERC20 rootedBaseLP;\n', '    IFloorCalculator calculator;\n', '    RootKitTransferGate gate;\n', '    mapping (address => bool) public infinitePumpers;\n', '\n', '    constructor(IUniswapV2Router02 _uniswapV2Router)\n', '    {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        IUniswapV2Factory _uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '    }\n', '\n', '    function calibrate(IERC20 _base, IERC20 _rootedToken, IERC31337 _elite, IFloorCalculator _calculator, RootKitTransferGate _gate) public ownerOnly(){\n', '        base = _base;       \n', '        gate = _gate;\n', '        elite = _elite;\n', '        rooted = _rootedToken;\n', '        calculator = _calculator;\n', '\n', '        _base.approve(address(uniswapV2Router), uint256(-1));\n', '        _base.approve(address(_elite), uint256(-1));\n', '        _rootedToken.approve(address(uniswapV2Router), uint256(-1));\n', '        rootedBaseLP = IERC20(uniswapV2Factory.getPair(address(_base), address(_rootedToken)));\n', '        rootedBaseLP.approve(address(uniswapV2Router), uint256(-1));\n', '        _elite.approve(address(uniswapV2Router), uint256(-1));\n', '        rootedEliteLP = IERC20(uniswapV2Factory.getPair(address(_elite), address(_rootedToken)));\n', '        rootedEliteLP.approve(address(uniswapV2Router), uint256(-1));\n', '    }\n', '\n', '    function balancePriceBase(uint256 amount) public {\n', '        require(elite.balanceOf(address(this)) == 0, "kETH starting balance must be zero");\n', '        uint256 startingBalance = base.balanceOf(address(this));\n', '        amount = buyRootedToken(address(base), amount);\n', '        amount = sellRootedToken(address(elite), amount);\n', '        elite.withdrawTokens(amount);\n', '        require(startingBalance <= base.balanceOf(address(this)));\n', '    }\n', '\n', '    function balancePriceElite(uint256 amount) public {\n', '        require(elite.balanceOf(address(this)) == 0, "kETH starting balance must be zero");\n', '        uint256 startingBalance = base.balanceOf(address(this));\n', '        elite.depositTokens(amount);\n', '        amount = buyRootedToken(address(elite), amount);\n', '        amount = sellRootedToken(address(base), amount);\n', '        require(startingBalance <= base.balanceOf(address(this)));\n', '    }\n', '\n', '        // The Pump Button is really fun\n', '    function setInfinitePumper(address pumper, bool infinite) public ownerOnly() {\n', '        infinitePumpers[pumper] = infinite;\n', '    }\n', '        // Removes liquidity and buys from either pool \n', '    function pumpItPonzo (uint256 PUMPIT, address token) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        PUMPIT = removeLiq(token, PUMPIT);\n', '        buyRootedToken(token, PUMPIT);\n', '        gate.setUnrestricted(false);\n', '    }\n', '    function pumpRooted(address token, uint256 amountToSpend) public override { \n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        buyRootedToken(token, amountToSpend);\n', '    }\n', '\n', '        // Sweeps the Base token under the floor to this address\n', '    function sweepTheFloor() public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        elite.sweepFloor(address(this));\n', '    }\n', '        // Move liquidity from Elite pool --->> Base pool\n', '    function zapEliteToBase(uint256 liquidity) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(elite), liquidity);\n', '        elite.withdrawTokens(liquidity);\n', '        addLiq(address(base), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '        // Move liquidity from Base pool --->> Elite pool\n', '    function zapBaseToElite(uint256 liquidity) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        liquidity = removeLiq(address(base), liquidity);\n', '        elite.depositTokens(liquidity);\n', '        addLiq(address(elite), liquidity);\n', '        gate.setUnrestricted(false);\n', '    }\n', '    function wrapToElite(uint256 baseAmount) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        elite.depositTokens(baseAmount);\n', '    }\n', '    function unwrapElite(uint256 eliteAmount) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        elite.withdrawTokens(eliteAmount);\n', '    }\n', '    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        addLiq(eliteOrBase, baseAmount);\n', '        gate.setUnrestricted(false);\n', '    }\n', '    function removeLiquidity (address eliteOrBase, uint256 tokens) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        removeLiq(eliteOrBase, tokens);\n', '        gate.setUnrestricted(false);\n', '    }\n', '    function buyRooted(address token, uint256 amountToSpend) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        buyRootedToken(token, amountToSpend);\n', '    }\n', '    function sellRooted(address token, uint256 amountToSpend) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        sellRootedToken(token, amountToSpend);\n', '    }\n', '    function addLiq(address eliteOrBase, uint256 baseAmount) internal {\n', '        uniswapV2Router.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n', '    }\n', '    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256) {\n', '        (tokens,) = uniswapV2Router.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\n', '        return tokens;\n', '    }\n', '    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1]; \n', '        return amountToSpend;\n', '    }\n', '    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\n', '        uint256[] memory amounts = uniswapV2Router.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\n', '        amountToSpend = amounts[1]; \n', '        return amountToSpend;\n', '    }\n', '    function buyPath(address token) internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(token);\n', '        path[1] = address(rooted);\n', '        return path;\n', '    }\n', '    function sellPath(address token) internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(rooted);\n', '        path[1] = address(token);\n', '        return path;\n', '    }\n', '}']