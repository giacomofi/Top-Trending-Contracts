['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "../Ownable.sol" ;\n', '\n', '//@title SEPA Token contract interface\n', 'interface SEPA_Token {                                     \n', '    function balanceOf(address owner) external returns (uint256);\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '}\n', '\n', '//@title SEPA Public Contract\n', 'contract SEPA_Public is Ownable {\n', '    uint256 public SEPAPrice ;\n', '    \n', '    address public token_addr ; \n', '    SEPA_Token token_contract = SEPA_Token(token_addr) ;\n', '    \n', '    event bought(address buyer, uint256 amount) ;\n', '    event priceAdjusted(uint256 oldPrice, uint256 newPrice) ; \n', '    \n', '    mapping(address => uint256) claimed_amount;\n', '\n', '    constructor(uint256 SEPAperETH) {\n', '        SEPAPrice = SEPAperETH ; \n', '    }\n', '\n', '    /**\n', '     * @dev Multiply two integers with extra checking the result\n', '     * @param   a Integer 1 \n', '     *          b Integer 2\n', '     */\n', '    function safeMultiply(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0 ;\n', '        } else {\n', '            uint256 c = a * b ;\n', '            assert(c / a == b) ;\n', '            return c ;\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Divide two integers with checking b is positive\n', '     * @param   a Integer 1 \n', '     *          b Integer 2\n', '     */\n', '    function safeDivide(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0); \n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    /**\n', '     * @dev Set SEPA Token contract address\n', '     * @param addr Address of SEPA Token contract\n', '     */\n', '    function set_token_contract(address addr) external onlyOwner {\n', '        token_addr = addr ;\n', '        token_contract = SEPA_Token(token_addr) ;\n', '    }\n', '\n', '    /**\n', '     * @dev Buy SEPA tokens directly from the contract\n', '     */\n', '    function buy_SEPA() public payable returns (bool success) {\n', '        uint256 scaledAmount = safeMultiply(msg.value, SEPAPrice) ;\n', '        require(block.timestamp >= 1617912000, "Contract not yet active") ; //Thu, 08 Apr 2021 20:00:00 UTC\n', '\n', '        require(token_contract.balanceOf(address(this)) >= scaledAmount) ;\n', '        require(msg.value <= 3 ether, "Transaction value exceeds 3 ether") ; \n', '        require(claimed_amount[msg.sender] + msg.value <= 3 ether, "Maximum amount reached");\n', '\n', '\n', '        token_contract.transfer(msg.sender, scaledAmount) ;\n', '        \n', '        emit bought(msg.sender, scaledAmount) ; \n', '    \n', '        success =  true ; \n', '    }\n', '    \n', '    /**\n', '     * @dev Fallback function for when a user sends ether to the contract\n', '     * directly instead of calling the function\n', '     */\n', '    receive() external payable {\n', '        buy_SEPA() ; \n', '    }\n', '\n', '    /**\n', '     * @dev Adjust the SEPA token price\n', '     * @param   SEPAperETH the amount of SEPA a user receives for 1 ETH\n', '     */\n', '    function adjustPrice(uint SEPAperETH) external onlyOwner {\n', '        emit priceAdjusted(SEPAPrice, SEPAperETH) ; \n', '        \n', '        SEPAPrice = SEPAperETH ; \n', '        \n', '    }\n', '\n', '    /**\n', '     * @dev End the SEPA token distribution by sending all leftover tokens and ether to the contract owner\n', '     */\n', '    function endSEPAPublic() external onlyOwner {             \n', '        require(token_contract.transfer(owner(), token_contract.balanceOf(address(this)))) ;\n', '\n', '        msg.sender.transfer(address(this).balance) ;\n', '    }\n', '}']