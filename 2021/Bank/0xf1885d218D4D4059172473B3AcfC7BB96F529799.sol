['// SPDX-License-Identifier: --GRISE--\n', '\n', 'pragma solidity =0.7.6;\n', '\n', "import './Interfaces.sol';\n", "import './Randomness.sol';\n", '\n', 'contract LiquidityTransformer {\n', '\n', '    using SafeMathLT for uint256;\n', '    using SafeMathLT for uint128;\n', '\n', '    Randomness public randomness;\n', '    IGriseToken public GRISE_CONTRACT;\n', '    RefundSponsorI public REFUND_SPONSOR;\n', '   \n', '    UniswapRouterV2 public constant UNISWAP_ROUTER = UniswapRouterV2(\n', '        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D // mainnet\n', '    );\n', '\n', '    address payable constant TEAM_ADDRESS = 0xa377433831E83C7a4Fa10fB75C33217cD7CABec2; \n', '    address payable constant DEV_ADDRESS = 0xcD8DcbA8e4791B19719934886A8bA77EA3fad447;\n', '    address public TOKEN_DEFINER;\n', '\n', '    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // mainnet\n', '    \n', '    uint8 constant INVESTMENT_DAYS = 50;\n', '    uint8 constant MAX_DAY_SLOT = 147;\n', '\n', '    uint128 constant THRESHOLD_LIMIT_MIN = 100000000000000000 wei;\n', '    uint128 constant THRESHOLD_LIMIT_MAX = 20 ether;\n', '    uint256 public TEAM_ETHER;\n', '    uint128 constant MIN_INVEST = 100000000000000000 wei;   \n', '    uint128 constant DAILY_MAX_SUPPLY = 12000;\n', '    \n', '    uint256 constant REI_PER_GRISE = 10 ** uint256(18);\n', '\n', '    struct Globals {\n', '        uint64 generatedDays;\n', '        uint64 preparedReferrals;\n', '        uint256 totalTransferTokens;\n', '        uint256 totalWeiContributed;\n', '        uint256 totalReferralTokens;\n', '    }\n', '\n', '    Globals public g;\n', '\n', '    mapping(uint256 => uint256) dailyMinSupply;\n', '    mapping(uint256 => uint256) dailyMaxSupply;\n', '    mapping(uint256 => uint256) public dailyTotalSupply;\n', '    mapping(uint256 => uint256) public dailyTotalInvestment;\n', '    mapping(uint256 => uint256) public dailySlots;\n', '    \n', '    uint256 public totalInvestment;\n', '    uint8 public totalTransactions;\n', '    uint8 constant GAS_REFUND_THRESHOLD = 200;\n', '\n', '    mapping(uint256 => uint256) public investorAccountCount;\n', '    mapping(uint256 => mapping(uint256 => address)) public investorAccounts;\n', '    mapping(address => mapping(uint256 => uint256)) public investorBalances;\n', '    mapping(address => mapping(uint256 => uint256)) public investorBalancesRecord;\n', '\n', '    mapping(address => uint256) public referralAmount;\n', '    mapping(address => uint256) public referralTokens;\n', '    mapping(address => uint256) public investorTotalBalance;\n', '    mapping(address => uint256) originalInvestment;\n', '\n', '    uint256 public referralAccountCount;\n', '    uint256 public uniqueInvestorCount;\n', '\n', '    mapping (uint256 => address) public uniqueInvestors;\n', '    mapping (uint256 => address) public referralAccounts;\n', '\n', '    event GeneratedRandomSupply(\n', '        uint256 indexed investmentDay,\n', '        uint256 randomSupply\n', '    );\n', '\n', '    event GeneratedStaticSupply(\n', '        uint256 indexed investmentDay,\n', '        uint256 staticSupply\n', '    );\n', '\n', '\n', '    event ReferralAdded(\n', '        address indexed referral,\n', '        address indexed referee,\n', '        uint256 amount\n', '    );\n', '\n', '    event UniSwapResult(\n', '        uint256 amountToken,\n', '        uint256 amountETH,\n', '        uint256 liquidity\n', '    );\n', '\n', '    event GriseReservation(\n', '        address indexed sender,\n', '        uint256 indexed investmentDay,\n', '        uint256 amount\n', '    );\n', '\n', '    modifier afterInvestmentPhase() {\n', '        require(\n', '            _currentLPDay() > INVESTMENT_DAYS,\n', "            'GRISE: ongoing investment phase'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier afterUniswapTransfer() {\n', '        require (\n', '            g.generatedDays > 0 &&\n', '            g.totalWeiContributed == 0,\n', "            'GRISE: forward liquidity first'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier investmentDaysRange(uint256 _investmentDay) {\n', '        require(\n', '            _investmentDay > 0 &&\n', '            _investmentDay <= INVESTMENT_DAYS,\n', "            'GRISE: not in initial investment days range'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyFundedDays(uint256 _investmentDay) {\n', '        require(\n', '            dailyTotalInvestment[_investmentDay] > 0,\n', "            'GRISE: no investments on that day'\n", '        );\n', '        _;\n', '    }\n', '\n', '    modifier refundSponsorDynamic() {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = (21000 + gasStart - gasleft()).mul(tx.gasprice);\n', '        gasSpent = msg.value.div(10) > gasSpent ? gasSpent : msg.value.div(10);\n', '        \n', '        if(totalTransactions <= GAS_REFUND_THRESHOLD){\n', '        REFUND_SPONSOR.addGasRefund(msg.sender, gasSpent);\n', '        }\n', '    }\n', '\n', '    modifier refundSponsorFixed() {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = (21000 + gasStart - gasleft()).mul(tx.gasprice);\n', '        gasSpent = gasSpent > 5000000000000000 ? 5000000000000000 : gasSpent;\n', '        \n', '        if(totalTransactions <= GAS_REFUND_THRESHOLD){\n', '        REFUND_SPONSOR.addGasRefund(msg.sender, gasSpent);\n', '        }\n', '    }\n', '\n', '    modifier onlyTokenDefiner() {\n', '        require(\n', '            msg.sender == TOKEN_DEFINER,\n', "            'GRISE: wrong sender'\n", '        );\n', '        _;\n', '    }\n', '    \n', '\n', '    receive() external payable {\n', '        require (\n', '            msg.sender == address(UNISWAP_ROUTER) ||\n', '            msg.sender == TEAM_ADDRESS ||\n', '            msg.sender == DEV_ADDRESS ||\n', '            msg.sender == TOKEN_DEFINER,\n', "            'GRISE: direct deposits disabled'\n", '        );\n', '        \n', '    }\n', '\n', '    function defineToken(\n', '        address _griseToken\n', '    )\n', '        external\n', '        onlyTokenDefiner\n', '    {\n', '        GRISE_CONTRACT = IGriseToken(_griseToken);\n', '    }\n', '\n', '    function revokeAccess()\n', '        external\n', '        onlyTokenDefiner\n', '    {\n', '        TOKEN_DEFINER = address(0x0);\n', '    }\n', '\n', '    constructor(address _griseToken, Randomness _randomness, address _refundSponsor) {\n', '        randomness=_randomness;\n', '        GRISE_CONTRACT = IGriseToken(_griseToken);\n', '        REFUND_SPONSOR = RefundSponsorI(_refundSponsor);\n', '        TOKEN_DEFINER = msg.sender;\n', '\n', '        dailyMinSupply[1] = 6000;\n', '        dailyMinSupply[2] = 6000;\n', '        dailyMinSupply[3] = 6000;\n', '        dailyMinSupply[4] = 6000;\n', '        dailyMinSupply[5] = 2150;\n', '        dailyMinSupply[6] = 6000;\n', '        dailyMinSupply[7] = 3650;\n', '        dailyMinSupply[8] = 6000;\n', '        dailyMinSupply[9] = 3650;\n', '        dailyMinSupply[10] = 6000;\n', '        \n', '        dailyMinSupply[11] = 3650;\n', '        dailyMinSupply[12] = 6000;\n', '        dailyMinSupply[13] = 6000;\n', '        dailyMinSupply[14] = 2150;\n', '        dailyMinSupply[15] = 6000;\n', '        dailyMinSupply[16] = 3650;\n', '        dailyMinSupply[17] = 6000;\n', '        dailyMinSupply[18] = 3650;\n', '        dailyMinSupply[19] = 6000;\n', '        dailyMinSupply[20] = 2150;\n', '        \n', '        dailyMinSupply[21] = 6000;\n', '        dailyMinSupply[22] = 2150;\n', '        dailyMinSupply[23] = 6000;\n', '        dailyMinSupply[24] = 2150;\n', '        dailyMinSupply[25] = 6000;\n', '        dailyMinSupply[26] = 2150;\n', '        dailyMinSupply[27] = 6000;\n', '        dailyMinSupply[28] = 6000;\n', '        dailyMinSupply[29] = 3650;\n', '        dailyMinSupply[30] = 6000;\n', '        \n', '        dailyMinSupply[31] = 6000;\n', '        dailyMinSupply[32] = 2150;\n', '        dailyMinSupply[33] = 6000;\n', '        dailyMinSupply[34] = 3650;\n', '        dailyMinSupply[35] = 6000;\n', '        dailyMinSupply[36] = 3650;\n', '        dailyMinSupply[37] = 6000;\n', '        dailyMinSupply[38] = 2150;\n', '        dailyMinSupply[39] = 2150;\n', '        dailyMinSupply[40] = 6000;\n', '        \n', '        dailyMinSupply[41] = 3650;\n', '        dailyMinSupply[42] = 6000;\n', '        dailyMinSupply[43] = 6000;\n', '        dailyMinSupply[44] = 2150;\n', '        dailyMinSupply[45] = 6000;\n', '        dailyMinSupply[46] = 3650;\n', '        dailyMinSupply[47] = 2150;\n', '        dailyMinSupply[48] = 3650;\n', '        dailyMinSupply[49] = 6000;\n', '        dailyMinSupply[50] = 6000;\n', '        \n', '        \n', '        dailyMaxSupply[5] = 16850;\n', '        dailyMaxSupply[14] = 16850;\n', '        dailyMaxSupply[20] = 16850;\n', '        dailyMaxSupply[22] = 16850;\n', '        dailyMaxSupply[24] = 16850;\n', '        dailyMaxSupply[26] = 16850;\n', '        dailyMaxSupply[32] = 16850;\n', '        dailyMaxSupply[38] = 16850;\n', '        dailyMaxSupply[39] = 16850;\n', '        dailyMaxSupply[44] = 16850;\n', '        dailyMaxSupply[47] = 16850;\n', '        \n', '        dailyMaxSupply[7] = 11850;\n', '        dailyMaxSupply[9] = 11850;\n', '        dailyMaxSupply[11] = 11850;\n', '        dailyMaxSupply[16] = 11850;\n', '        dailyMaxSupply[18] = 11850;\n', '        dailyMaxSupply[29] = 11850;\n', '        dailyMaxSupply[34] = 11850;\n', '        dailyMaxSupply[36] = 11850;\n', '        dailyMaxSupply[41] = 11850;\n', '        dailyMaxSupply[46] = 11850;\n', '        dailyMaxSupply[48] = 11850;\n', '    }\n', '\n', '\n', '    //  GRISE RESERVATION (EXTERNAL FUNCTIONS)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @dev Performs reservation of GRISE tokens with ETH\n', '      * @param _investmentDays array of reservation days.\n', '      * @param _referralAddress referral address for bonus.\n', '      */\n', '    function reserveGrise(\n', '        uint8[] calldata _investmentDays,\n', '        address _referralAddress\n', '    )\n', '        external\n', '        payable\n', '        refundSponsorDynamic\n', '    {\n', '        checkInvestmentDays(\n', '            _investmentDays,\n', '            _currentLPDay(),\n', '            msg.sender,\n', '            msg.value\n', '        );\n', '        \n', '        \n', '        _reserveGrise(\n', '            _investmentDays,\n', '            _referralAddress,\n', '            msg.sender,\n', '            msg.value\n', '        );\n', '    }\n', '\n', '    /** @notice Allows reservation of GRISE tokens with other ERC20 tokens\n', '      * @dev this will require LT contract to be approved as spender\n', '      * @param _tokenAddress address of an ERC20 token to use\n', '      * @param _tokenAmount amount of tokens to use for reservation\n', '      * @param _investmentDays array of reservation days\n', '      * @param _referralAddress referral address for bonus\n', '      */\n', '    function reserveGriseWithToken(\n', '        address _tokenAddress,\n', '        uint256 _tokenAmount,\n', '        uint8[] calldata _investmentDays,\n', '        address _referralAddress\n', '    )\n', '        external\n', '        refundSponsorFixed\n', '    {\n', '        IERC20Token _token = IERC20Token(\n', '            _tokenAddress\n', '        );\n', '\n', '        _token.transferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            _tokenAmount\n', '        );\n', '\n', '        _token.approve(\n', '            address(UNISWAP_ROUTER),\n', '            _tokenAmount\n', '        );\n', '\n', '        address[] memory _path = preparePath(\n', '            _tokenAddress\n', '        );\n', '\n', '        uint256[] memory amounts =\n', '        UNISWAP_ROUTER.swapExactTokensForETH(\n', '            _tokenAmount,\n', '            0,\n', '            _path,\n', '            address(this),\n', '            block.timestamp.add(2 hours)\n', '        );\n', '\n', '\n', '        checkInvestmentDays(\n', '            _investmentDays,\n', '            _currentLPDay(),\n', '            msg.sender,\n', '            amounts[1]\n', '        );\n', '        \n', '\n', '        _reserveGrise(\n', '            _investmentDays,\n', '            _referralAddress,\n', '            msg.sender,\n', '            amounts[1]\n', '        );\n', '    }\n', '\n', '    //  GRISE RESERVATION (INTERNAL FUNCTIONS)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Distributes ETH equaly between selected reservation days\n', '      * @dev this will require LT contract to be approved as a spender\n', '      * @param _investmentDays array of selected reservation days\n', '      * @param _referralAddress referral address for bonus\n', '      * @param _senderAddress address of the investor\n', '      * @param _senderValue amount of ETH contributed\n', '      */\n', '    function _reserveGrise(\n', '        uint8[] memory _investmentDays,\n', '        address _referralAddress,\n', '        address _senderAddress,\n', '        uint256 _senderValue\n', '    )\n', '        internal\n', '    {\n', '        require(\n', '            _senderAddress != _referralAddress,\n', "            'GRISE: must be a different address'\n", '        );\n', '\n', '        require(\n', '            notContract(_referralAddress),\n', "            'GRISE: invalid referral address'\n", '        );\n', '\n', '        uint256 _investmentBalance = _referralAddress == address(0x0)\n', '            ? _senderValue \n', '            : referralAmount[_referralAddress].add(_senderValue) > THRESHOLD_LIMIT_MAX\n', '            ?_senderValue.mul(1100).div(1000)\n', '            :_senderValue.mul(10500).div(10000);\n', '\n', '\n', '\n', '        uint256 _totalDays = _investmentDays.length;\n', '        uint256 _dailyAmount = _investmentBalance.div(_totalDays);\n', '        uint256 _leftOver = _investmentBalance.mod(_totalDays);\n', '\n', '        _addBalance(\n', '            _senderAddress,\n', '            _investmentDays[0],\n', '            _dailyAmount.add(_leftOver)\n', '        );\n', '        \n', '       \n', '\n', '        for (uint8 _i = 1; _i < _totalDays; _i++) {\n', '            _addBalance(\n', '                _senderAddress,\n', '                _investmentDays[_i],\n', '                _dailyAmount\n', '            );\n', '             \n', '        }\n', '\n', '        _trackInvestors(\n', '            _senderAddress,\n', '            _investmentBalance\n', '        );\n', '\n', '        if (_referralAddress != address(0x0)) {\n', '\n', '            _trackReferrals(_referralAddress, _senderValue);\n', '\n', '            emit ReferralAdded(\n', '                _referralAddress,\n', '                _senderAddress,\n', '                _senderValue\n', '            );\n', '        }\n', '\n', '        originalInvestment[_senderAddress] += _senderValue;\n', '        g.totalWeiContributed += _senderValue;\n', '    }\n', '\n', '    /** @notice Allocates investors balance to specific day\n', '      * @param _senderAddress investors wallet address\n', '      * @param _investmentDay selected investment day\n', '      * @param _investmentBalance amount invested (with bonus)\n', '      */\n', '    function _addBalance(\n', '        address _senderAddress,\n', '        uint256 _investmentDay,\n', '        uint256 _investmentBalance\n', '    )\n', '        internal\n', '    {\n', '        if (investorBalances[_senderAddress][_investmentDay] == 0) {\n', '            investorAccounts[_investmentDay][investorAccountCount[_investmentDay]] = _senderAddress;\n', '            investorAccountCount[_investmentDay]++;\n', '        }\n', '\n', '        investorBalances[_senderAddress][_investmentDay] += _investmentBalance;\n', '        investorBalancesRecord[_senderAddress][_investmentDay] += _investmentBalance;\n', '        dailyTotalInvestment[_investmentDay] += _investmentBalance;\n', '        totalInvestment += _investmentBalance;\n', '        totalTransactions++;\n', '\n', '        emit GriseReservation(\n', '            _senderAddress,\n', '            _investmentDay,\n', '            _investmentBalance\n', '        );\n', '    }\n', '\n', '    //  GRISE RESERVATION (PRIVATE FUNCTIONS)  //\n', '    //  ------------------------------------  //\n', '\n', '    /** @notice Tracks investorTotalBalance and uniqueInvestors\n', '      * @dev used in _reserveGrise() internal function\n', '      * @param _investorAddress address of the investor\n', '      * @param _value ETH amount invested (with bonus)\n', '      */\n', '    function _trackInvestors(address _investorAddress, uint256 _value) private {\n', '       \n', '        if (investorTotalBalance[_investorAddress] == 0) {\n', '            uniqueInvestors[uniqueInvestorCount] = _investorAddress;\n', '            uniqueInvestorCount++;\n', '        }\n', '        investorTotalBalance[_investorAddress] += _value;\n', '    }\n', '\n', '    /** @notice Tracks referralAmount and referralAccounts\n', '      * @dev used in _reserveGrise() internal function\n', '      * @param _referralAddress address of the referrer\n', '      * @param _value ETH amount referred during reservation\n', '      */\n', '    function _trackReferrals(address _referralAddress, uint256 _value) private {\n', '        if (referralAmount[_referralAddress] == 0) {\n', '            referralAccounts[\n', '            referralAccountCount] = _referralAddress;\n', '            referralAccountCount++;\n', '        }\n', '        referralAmount[_referralAddress] += _value;\n', '    }\n', '\n', '\n', '    //  SUPPLY GENERATION (EXTERNAL FUNCTION)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Allows to generate supply for past funded days\n', '      * @param _investmentDay investemnt day index (1-50)\n', '      */\n', '    function generateSupply(\n', '        uint64 _investmentDay\n', '    )\n', '        external\n', '        investmentDaysRange(_investmentDay)\n', '        onlyFundedDays(_investmentDay)\n', '    {\n', '        require(\n', '            _investmentDay < _currentLPDay(),\n', "            'GRISE: investment day must be in past'\n", '        );\n', '\n', '        require(\n', '            dailyTotalSupply[_investmentDay] == 0,\n', "            'GRISE: supply already generated'\n", '        );\n', '                \n', '        DAILY_MAX_SUPPLY - dailyMinSupply[_investmentDay] == dailyMinSupply[_investmentDay]\n', '            ? _generateStaticSupply(_investmentDay)\n', '            : _generateRandomSupply(_investmentDay);\n', '    }\n', '\n', '\n', '    //  SUPPLY GENERATION (INTERNAL FUNCTIONS)  //\n', '    //  --------------------------------------  //\n', '\n', '    /** @notice Generates supply for days with static supply\n', '      * @param _investmentDay investemnt day index (1-50)\n', '      */\n', '    function _generateStaticSupply(\n', '        uint256 _investmentDay\n', '    )\n', '        internal\n', '    {\n', '        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay] * REI_PER_GRISE;\n', '        g.totalTransferTokens += dailyTotalSupply[_investmentDay];\n', '\n', '        g.generatedDays++;\n', '        \n', '        emit GeneratedStaticSupply(\n', '            _investmentDay,\n', '            dailyTotalSupply[_investmentDay]\n', '        );\n', '    }\n', '\n', '    /** @notice Generates supply for days with random supply\n', '      * @dev uses nreAPI to request random number\n', '      * @param _investmentDay investemnt day index (1-50)\n', '      */\n', '    function _generateRandomSupply(\n', '        uint256 _investmentDay\n', '    )\n', '        internal\n', '    {\n', '        uint256 ceilingDayMaxSupply = dailyMaxSupply[_investmentDay].sub(dailyMinSupply[_investmentDay]);\n', '        uint256 randomSupply =  randomness.stateRandomNumber() % ceilingDayMaxSupply;\n', '    \n', '        g.generatedDays = g.generatedDays + 1;\n', '        dailyTotalSupply[_investmentDay] = dailyMinSupply[_investmentDay]\n', '            .add(randomSupply)\n', '            .mul(REI_PER_GRISE);\n', '\n', '        g.totalTransferTokens = g.totalTransferTokens\n', '            .add(dailyTotalSupply[_investmentDay]);\n', '\n', '        emit GeneratedRandomSupply(\n', '            _investmentDay,\n', '            dailyTotalSupply[_investmentDay]\n', '        );\n', '\n', '    }\n', '    \n', '\n', '    //  PRE-LIQUIDITY GENERATION FUNCTION  //\n', '    //  ---------------------------------  //\n', '\n', '    /** @notice Pre-calculates amount of tokens each referrer will get\n', '      * @dev must run this for all referrer addresses in batches\n', '      * converts _referralAmount to _referralTokens based on dailyRatio\n', '      */\n', '    function prepareReferralBonuses(\n', '        uint256 _referralBatchFrom,\n', '        uint256 _referralBatchTo\n', '    )\n', '        external\n', '        afterInvestmentPhase\n', '    {\n', '        require(\n', '            _referralBatchFrom < _referralBatchTo,\n', "            'GRISE: incorrect referral batch'\n", '        );\n', '\n', '        require (\n', '            g.preparedReferrals < referralAccountCount,\n', "            'GRISE: all referrals already prepared'\n", '        );\n', '\n', '        uint256 _totalRatio = g.totalTransferTokens.div(g.totalWeiContributed);\n', '\n', '        for (uint256 i = _referralBatchFrom; i < _referralBatchTo; i++) {\n', '            address _referralAddress = referralAccounts[i];\n', '            uint256 _referralAmount = referralAmount[_referralAddress];\n', '            if (referralAmount[_referralAddress] > 0) {\n', '                referralAmount[_referralAddress] = 0;\n', '                if (_referralAmount >= THRESHOLD_LIMIT_MIN) {\n', '                    _referralAmount >= THRESHOLD_LIMIT_MAX\n', '                        ? _fullReferralBonus(_referralAddress, _referralAmount, _totalRatio)\n', '                        : _familyReferralBonus(_referralAddress, _referralAmount,  _totalRatio);\n', '\n', '                    g.totalReferralTokens = g.totalReferralTokens.add(\n', '                        referralTokens[_referralAddress]\n', '                    );\n', '                }\n', '                g.preparedReferrals++;\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @notice performs token allocation for 10% of referral amount\n', '      * @dev after liquidity is formed referrer can withdraw this amount\n', '      */\n', '    function _fullReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\n', '        referralTokens[_referralAddress] = _referralAmount.div(10).mul(_ratio);\n', '    }\n', '\n', '    /** @notice performs token allocation for 5% of referral amount\n', '      * @dev after liquidity is formed referrer can withdraw this amount\n', '      */\n', '    function _familyReferralBonus(address _referralAddress, uint256 _referralAmount, uint256 _ratio) internal {\n', '        referralTokens[_referralAddress] = _referralAmount.div(20).mul(_ratio);\n', '    }\n', '\n', '\n', '    //  LIQUIDITY GENERATION FUNCTION  //\n', '    //  -----------------------------  //\n', '\n', '    /** @notice Creates initial liquidity on Uniswap by forwarding\n', '      * reserved tokens equivalent to ETH contributed to the contract\n', '      * @dev check addLiquidityETH documentation\n', '      */\n', '    function forwardLiquidity(/*🦄*/)\n', '        external\n', '        afterInvestmentPhase\n', '    {\n', '        require(\n', '            g.generatedDays == fundedDays(),\n', "            'GRISE: must generate supply for all days'\n", '        );\n', '\n', '        require (\n', '            g.preparedReferrals == referralAccountCount,\n', "            'GRISE: must prepare all referrals'\n", '        );\n', '\n', '        require (\n', '            g.totalTransferTokens > 0,\n', "            'GRISE: must have tokens to transfer'\n", '        );\n', '\n', '        uint256 _balance = g.totalWeiContributed;\n', '        uint256 _buffer = g.totalTransferTokens + g.totalReferralTokens;\n', '        \n', '        uint256 _bounty = _buffer.mul(8).div(100);\n', '\n', '        _balance = _balance.sub(\n', '            _teamContribution(\n', '                _balance.mul(15).div(100)\n', '            )\n', '        );\n', '\n', '        _buffer = _buffer.mul(_balance).div(\n', '            g.totalWeiContributed\n', '        );\n', '        \n', '        _bounty = _bounty.add(_buffer.mul(8).div(100));\n', '        \n', '\n', '        GRISE_CONTRACT.mintSupply(\n', '            address(this), _buffer\n', '        );\n', '        \n', '        GRISE_CONTRACT.mintSupply(\n', '            TEAM_ADDRESS, _bounty\n', '        );\n', '        \n', '\n', '        GRISE_CONTRACT.approve(\n', '            address(UNISWAP_ROUTER), _buffer\n', '        );\n', '\n', '        (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        ) =\n', '\n', '        UNISWAP_ROUTER.addLiquidityETH{value: _balance}(\n', '            address(GRISE_CONTRACT),\n', '            _buffer,\n', '            0,\n', '            0,\n', '            address(0x0),\n', '            block.timestamp.add(2 hours)\n', '        );\n', '\n', '        g.totalTransferTokens = 0;\n', '        g.totalReferralTokens = 0;\n', '        g.totalWeiContributed = 0;\n', '\n', '        emit UniSwapResult(\n', '            amountToken, amountETH, liquidity\n', '        );\n', '    }\n', '\n', '\n', '    //  GRISE TOKEN PAYOUT FUNCTIONS (INDIVIDUAL)  //\n', '    //  ----------------------------------------  //\n', '\n', '    /** @notice Allows to mint all the tokens\n', '      * from investor and referrer perspectives\n', '      * @dev can be called after forwardLiquidity()\n', '      */\n', '    function getMyTokens(/*💰*/)\n', '        external\n', '        afterUniswapTransfer\n', '    {\n', '        payoutInvestorAddress(msg.sender);\n', '        payoutReferralAddress(msg.sender);\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for specific investor address\n', '      * @dev aggregades investors tokens across all investment days\n', '      * and uses GRISE_CONTRACT instance to mint all the GRISE tokens\n', '      * @param _investorAddress requested investor calculation address\n', '      * @return _payout amount minted to the investors address\n', '      */\n', '    function payoutInvestorAddress(\n', '        address _investorAddress\n', '    )\n', '        public\n', '        afterUniswapTransfer\n', '        returns (uint256 _payout)\n', '    {\n', '        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            if (investorBalances[_investorAddress][i] > 0) {\n', '                _payout += investorBalances[_investorAddress][i].mul(\n', '                    _calculateDailyRatio(i)\n', '                ).div(100E18);\n', '                investorBalances[_investorAddress][i] = 0;\n', '            }\n', '        }\n', '        if (_payout > 0) {\n', '            GRISE_CONTRACT.mintSupply(\n', '                _investorAddress,\n', '                _payout\n', '            );\n', '        }\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for specific referrer address\n', '      * @dev must be pre-calculated in prepareReferralBonuses()\n', '      * @param _referralAddress referrer payout address\n', '      * @return _referralTokens amount minted to the referrer address\n', '      */\n', '    function payoutReferralAddress(\n', '        address _referralAddress\n', '    ) public\n', '        afterUniswapTransfer\n', '        returns (uint256 _referralTokens)\n', '    {\n', '        _referralTokens = referralTokens[_referralAddress];\n', '        if (referralTokens[_referralAddress] > 0) {\n', '            referralTokens[_referralAddress] = 0;\n', '            GRISE_CONTRACT.mintSupply(\n', '                _referralAddress,\n', '                _referralTokens\n', '            );\n', '        }\n', '    }\n', '\n', '    //  GRISE TOKEN PAYOUT FUNCTIONS (BATCHES)  //\n', '    //  -------------------------------------  //\n', '\n', '    /** @notice Allows to mint tokens for specific investment day\n', '      * recommended batch size is up to 50 addresses per call\n', '      * @param _investmentDay processing investment day\n', '      * @param _investorBatchFrom batch starting index\n', '      * @param _investorBatchTo bach finishing index\n', '      */\n', '    function payoutInvestmentDayBatch(\n', '        uint256 _investmentDay,\n', '        uint256 _investorBatchFrom,\n', '        uint256 _investorBatchTo\n', '    )\n', '        external\n', '        afterUniswapTransfer\n', '        onlyFundedDays(_investmentDay)\n', '    {\n', '        require(\n', '            _investorBatchFrom < _investorBatchTo,\n', "            'GRISE: incorrect investment batch'\n", '        );\n', '\n', '        uint256 _dailyRatio = _calculateDailyRatio(_investmentDay);\n', '\n', '        for (uint256 i = _investorBatchFrom; i < _investorBatchTo; i++) {\n', '            address _investor = investorAccounts[_investmentDay][i];\n', '            uint256 _balance = investorBalances[_investor][_investmentDay];\n', '            uint256 _payout = _balance.mul(_dailyRatio).div(100E18);\n', '\n', '            if (investorBalances[_investor][_investmentDay] > 0) {\n', '                investorBalances[_investor][_investmentDay] = 0;\n', '                GRISE_CONTRACT.mintSupply(\n', '                    _investor,\n', '                    _payout\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @notice Allows to mint tokens for referrers in batches\n', '      * @dev can be called right after forwardLiquidity()\n', '      * recommended batch size is up to 50 addresses per call\n', '      * @param _referralBatchFrom batch starting index\n', '      * @param _referralBatchTo bach finishing index\n', '      */\n', '    function payoutReferralBatch(\n', '        uint256 _referralBatchFrom,\n', '        uint256 _referralBatchTo\n', '    )\n', '        external\n', '        afterUniswapTransfer\n', '    {\n', '        require(\n', '            _referralBatchFrom < _referralBatchTo,\n', "            'GRISE: incorrect referral batch'\n", '        );\n', '\n', '        for (uint256 i = _referralBatchFrom; i < _referralBatchTo; i++) {\n', '            address _referralAddress = referralAccounts[i];\n', '            uint256 _referralTokens = referralTokens[_referralAddress];\n', '            if (referralTokens[_referralAddress] > 0) {\n', '                referralTokens[_referralAddress] = 0;\n', '                GRISE_CONTRACT.mintSupply(\n', '                    _referralAddress,\n', '                    _referralTokens\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    //  INFO VIEW FUNCTIONS (PERSONAL)  //\n', '    //  ------------------------------  //\n', '\n', '    /** @notice checks for callers investment amount on specific day (with bonus)\n', '      * @return total amount invested across specific investment day (with bonus)\n', '      */\n', '    function myInvestmentAmount(uint256 _investmentDay) external view returns (uint256) {\n', '        return investorBalances[msg.sender][_investmentDay];\n', '    }\n', '\n', '    /** @notice checks for callers claimable amount on specific day (with bonus)\n', '      * @return total amount claimable across specific investment day (with bonus)\n', '      */\n', '    function myClaimAmount(uint256 _investmentDay) external view returns (uint256) {\n', '        if (investorBalances[msg.sender][_investmentDay] > 0) {\n', '            return investorBalances[msg.sender][_investmentDay].mul(\n', '                    _calculateDailyRatio(_investmentDay)).div(100E18);\n', '        }else{\n', '            return 0;\n', '        }            \n', '    }\n', '\n', '    /** @notice checks for callers investment amount on each day (with bonus)\n', '      * @return _myAllDays total amount invested across all days (with bonus)\n', '      */\n', '    function myInvestmentAmountAllDays() external view returns (uint256[51] memory _myAllDays) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _myAllDays[i] = investorBalances[msg.sender][i];\n', '        }\n', '    }\n', '\n', '    /** @notice checks for callers total investment amount (with bonus)\n', '      * @return total amount invested across all investment days (with bonus)\n', '      */\n', '    function myTotalInvestmentAmount() external view returns (uint256) {\n', '        return investorTotalBalance[msg.sender];\n', '    }\n', '\n', '    /** @notice checks for callers total claimable amount (with refferal bonus)\n', '      * @return total claimable amount across all investment days (with refferal bonus)\n', '      */\n', '    function myClaimAmountAllDays() external view returns (uint256) {\n', '        uint256 _payout;\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            if (investorBalances[msg.sender][i] > 0) {\n', '                _payout += investorBalances[msg.sender][i].mul(\n', '                    _calculateDailyRatio(i)\n', '                ).div(100E18);\n', '            }    \n', '        }\n', '\n', '        return _payout + referralTokens[msg.sender];\n', '    }\n', '\n', '\n', '    //  INFO VIEW FUNCTIONS (GLOBAL)  //\n', '    //  ----------------------------  //\n', '\n', '    /** @notice checks for investors count on specific day\n', '      * @return investors count for specific day\n', '      */\n', '    function investorsOnDay(uint256 _investmentDay) public view returns (uint256) {\n', '        return dailyTotalInvestment[_investmentDay] > 0 ? investorAccountCount[_investmentDay] : 0;\n', '    }\n', '\n', '    /** @notice checks for investors count on each day\n', '      * @return _allInvestors array with investors count for each day\n', '      */\n', '    function investorsOnAllDays() external view returns (uint256[51] memory _allInvestors) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allInvestors[i] = investorsOnDay(i);\n', '        }\n', '    }\n', '\n', '    /** @notice checks for investment amount on each day\n', '      * @return _allInvestments array with investment amount for each day\n', '      */\n', '    function investmentsOnAllDays() external view returns (uint256[51] memory _allInvestments) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allInvestments[i] = dailyTotalInvestment[i];\n', '        }\n', '    }\n', '\n', '    /** @notice checks for supply amount on each day\n', '      * @return _allSupply array with supply amount for each day\n', '      */\n', '    function supplyOnAllDays() external view returns (uint256[51] memory _allSupply) {\n', '        for (uint256 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            _allSupply[i] = dailyTotalSupply[i];\n', '        }\n', '    }\n', '\n', '\n', '    //  HELPER FUNCTIONS (PURE)  //\n', '    //  -----------------------  //\n', '\n', '    /** @notice checks that provided days are valid for investemnt\n', '      * @dev used in reserveGrise() and reserveGriseWithToken()\n', '      */\n', '    function checkInvestmentDays(\n', '        uint8[] memory _investmentDays,\n', '        uint64 _griseDay,\n', '        address _senderAddress,\n', '        uint256 _senderValue\n', '    )\n', '        internal\n', '    {\n', '        uint256 _totalDays = _investmentDays.length;\n', '        uint256 _dailyAmount = _senderValue.div(_totalDays);\n', '        \n', '        for (uint8 _i = 0; _i < _investmentDays.length; _i++) {\n', '            \n', '            require(\n', '                (_dailyAmount >= MIN_INVEST) || (investorBalances[_senderAddress][_investmentDays[_i]] > 0),\n', "                'GRISE: investment below minimum'\n", '            );\n', '            \n', '            require(\n', '                _investmentDays[_i] >= _griseDay,\n', "                'GRISE: investment day already passed'\n", '            );\n', '            require(\n', '                _investmentDays[_i] > 0 &&\n', '                _investmentDays[_i] <= INVESTMENT_DAYS,\n', "                'GRISE: incorrect investment day'\n", '            );\n', '            \n', '            \n', '            require(\n', '                (dailySlots[_investmentDays[_i]] < MAX_DAY_SLOT) || \n', '                (investorBalances[_senderAddress][_investmentDays[_i]] > 0)\n', '                ,\n', "                'GRISE: investment slots are not available'\n", '            );\n', '            \n', '            if(investorBalances[_senderAddress][_investmentDays[_i]] == 0){\n', '                dailySlots[_investmentDays[_i]]++;\n', '            }\n', '        }\n', '    }\n', '    \n', '    \n', '\n', '    /** @notice prepares path variable for uniswap to exchange tokens\n', '      * @dev used in reserveGriseWithToken() swapExactTokensForETH call\n', '      * @param _tokenAddress ERC20 token address to be swapped for ETH\n', '      * @return _path that is used to swap tokens for ETH on uniswap\n', '      */\n', '    function preparePath(\n', '        address _tokenAddress\n', '    ) internal pure returns (\n', '        address[] memory _path\n', '    ) {\n', '        _path = new address[](2);\n', '        _path[0] = _tokenAddress;\n', '        _path[1] = WETH;\n', '    }\n', '\n', '    /** @notice keeps team contribution \n', '      * @dev subtracts amount during forwardLiquidity()\n', '      * @return ETH amount the team is allowed to withdraw\n', '      */\n', '    function _teamContribution(\n', '        uint256 _teamAmount\n', '    ) internal returns (uint256) {\n', '        TEAM_ETHER = _teamAmount;\n', '        return _teamAmount;\n', '    }\n', '\n', '    /** @notice checks for invesments on all days\n', '      * @dev used in forwardLiquidity() requirements\n', '      * @return $fundedDays - amount of funded days 0-50\n', '      */\n', '    function fundedDays() public view returns (\n', '        uint8 $fundedDays\n', '    ) {\n', '        for (uint8 i = 1; i <= INVESTMENT_DAYS; i++) {\n', '            if (dailyTotalInvestment[i] > 0) $fundedDays++;\n', '        }\n', '    }\n', '\n', '    /** @notice GRISE equivalent in ETH price calculation\n', '      * @dev returned value has 100E18 precision - divided later on\n', '      * @return token price for specific day based on total investement\n', '      */\n', '    function _calculateDailyRatio(\n', '        uint256 _investmentDay\n', '    ) internal view returns (uint256) {\n', '\n', '        uint256 dailyRatio = dailyTotalSupply[_investmentDay].mul(100E18)\n', '            .div(dailyTotalInvestment[_investmentDay]);\n', '\n', '        uint256 remainderCheck = dailyTotalSupply[_investmentDay].mul(100E18)\n', '            .mod(dailyTotalInvestment[_investmentDay]);\n', '\n', '        return remainderCheck == 0 ? dailyRatio : dailyRatio.add(1);\n', '    }\n', '\n', '    //  TIMING FUNCTIONS  //\n', '    //  ----------------  //\n', '\n', '    /** @notice shows current slot of GriseToken\n', '      * @dev value is fetched from GRISE_CONTRACT\n', '      * @return iteration day since GRISE inception\n', '      */\n', '    function _currentLPDay() public view returns (uint64) {\n', '        return GRISE_CONTRACT.currentLPDay();\n', '    }\n', '\n', '    /** @notice allows to withdraw team funds for the work\n', '      * strictly only after the uniswap liquidity is formed\n', '      */\n', '    function requestTeamFunds()\n', '        external\n', '        afterUniswapTransfer\n', '    {\n', '        TEAM_ADDRESS.transfer(TEAM_ETHER.mul(4).div(5));\n', '        DEV_ADDRESS.transfer(TEAM_ETHER.div(5));\n', '    }\n', '\n', '    function notContract(address _addr) internal view returns (bool) {\n', '        uint32 size;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return (size == 0);\n', '    }\n', '\n', '}\n', '\n', 'library SafeMathLT {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', "        require(c >= a, 'GRISE: addition overflow');\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b <= a, 'GRISE: subtraction overflow');\n", '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', "        require(c / a == b, 'GRISE: multiplication overflow');\n", '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b > 0, 'GRISE: division by zero');\n", '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b != 0, 'GRISE: modulo by zero');\n", '        return a % b;\n', '    }\n', '}']