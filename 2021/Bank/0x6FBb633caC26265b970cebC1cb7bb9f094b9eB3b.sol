['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', "import './StrategyInterface.sol';\n", "import './ReentrancyGuard.sol';\n", "import './SafeERC20.sol';\n", '\n', 'contract RoyaleLP is ReentrancyGuard {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public constant DENOMINATOR = 10000;\n', '\n', '    uint128 public fees = 25; // for .25% fee, for 1.75% fee => 175\n', '\n', '    uint256 public poolPart = 750 ; // 7.5% of total Liquidity will remain in the pool\n', '\n', '    uint256 public selfBalance;\n', '\n', '    IERC20[3] public tokens;\n', '\n', '    IERC20 public rpToken;\n', '\n', '    rStrategy public strategy;\n', '    \n', '    address public wallet;\n', '    \n', '    address public nominatedWallet;\n', '\n', '    uint public YieldPoolBalance;\n', '    uint public liquidityProvidersAPY;\n', '\n', '    //storage for user related to supply and withdraw\n', '    \n', '    uint256 public lock_period = 1209600;\n', '\n', '    struct depositDetails {\n', '        uint index;\n', '        uint amount;\n', '        uint256 time;\n', '        uint256 remAmt;\n', '    }\n', '    \n', '    mapping(address => depositDetails[]) public amountSupplied;\n', '    mapping(address => uint256[3]) public amountWithdraw;\n', '    mapping(address => uint256[3]) public amountBurnt;\n', '    \n', '    mapping(address => bool) public isInQ;\n', '    \n', '    address[] public withdrawRecipients;\n', '    \n', '    uint public maxWithdrawRequests=25;\n', '    \n', '    uint256[3] public totalWithdraw;\n', '    \n', '    uint[3] public reserveAmount;\n', '    mapping(address => bool)public reserveRecipients;\n', '    \n', '    //storage to store total loan given\n', '    uint256 public loanGiven;\n', '    \n', '    uint public loanPart=2000;\n', '    \n', '  \n', '    modifier onlyWallet(){\n', '      require(wallet ==msg.sender, "NA");\n', '      _;\n', '    }\n', '  \n', '     modifier validAmount(uint amount){\n', '      require(amount > 0 , "NV");\n', '      _;\n', '    }\n', '    \n', '    // EVENTS \n', '    event userSupplied(address user,uint amount);\n', '    event userRecieved(address user,uint amount);\n', '    event userAddedToQ(address user,uint amount);\n', '    event yieldAdded(uint amount);\n', '    event walletNominated(address newOwner);\n', '    event walletChanged(address oldOwner, address newOwner);\n', '   \n', '    \n', '    constructor(address[3] memory _tokens,address _rpToken,address _wallet) public {\n', '        require(_wallet != address(0), "Wallet address cannot be 0");\n', '        for(uint8 i=0; i<3; i++) {\n', '            tokens[i] = IERC20(_tokens[i]);\n', '        }\n', '        rpToken = IERC20(_rpToken);\n', '        wallet=_wallet;\n', '    }\n', '    \n', '    function nominateNewOwner(address _wallet) external onlyWallet {\n', '        nominatedWallet = _wallet;\n', '        emit walletNominated(_wallet);\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(msg.sender == nominatedWallet, "You must be nominated before you can accept ownership");\n', '        emit walletChanged(wallet, nominatedWallet);\n', '        wallet = nominatedWallet;\n', '        nominatedWallet = address(0);\n', '    }\n', '\n', '\n', '    /* INTERNAL FUNCTIONS */\n', '   \n', '    \n', '    //For checking whether array contains any non zero elements or not.\n', '    function checkValidArray(uint256[3] memory amounts)internal pure returns(bool){\n', '        for(uint8 i=0;i<3;i++){\n', '            if(amounts[i]>0){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // This function deposits the liquidity to yield generation pool using yield Strategy contract\n', '    function _deposit(uint256[3] memory amounts) internal {\n', '        strategy.deposit(amounts);\n', '        uint decimal;\n', '        for(uint8 i=0;i<3;i++){\n', '            decimal=tokens[i].decimals();\n', '            YieldPoolBalance =YieldPoolBalance.add(amounts[i].mul(10**18).div(10**decimal));\n', '        }\n', '    }\n', '   \n', '\n', "    //This function is used to updating the array of user's individual deposit , called when users withdraw/claim tokens.\n", '    function updateLockedRPT(address recipient,uint256 amount) internal{\n', '        for(uint8 j=0; j<amountSupplied[recipient].length; j++) {\n', '            if(amountSupplied[recipient][j].remAmt > 0 && amount > 0 ) {\n', '                if(amount >= amountSupplied[recipient][j].remAmt) {\n', '                        amount = amount.sub( amountSupplied[recipient][j].remAmt);\n', '                        amountSupplied[recipient][j].remAmt = 0;\n', '                }\n', '                else {\n', '                        amountSupplied[recipient][j].remAmt =(amountSupplied[recipient][j].remAmt).sub(amount);\n', '                        amount = 0;\n', '                }\n', '            }\n', '        }\n', '     }\n', '\n', '    //Funtion determines whether requested withdrawl amount is available in the pool or not.\n', '    //If yes then fulfills withdraw request \n', '    //and if no then put the request into the withdraw queue.\n', '    function checkWithdraw(uint256 amount,uint256 burnAmt,uint _index) internal{\n', '        uint256 poolBalance;\n', '        poolBalance = getBalances(_index);\n', '        rpToken.burn(msg.sender, burnAmt);\n', '        if(amount <= poolBalance) {\n', '            uint decimal;\n', '            decimal=tokens[_index].decimals();\n', '            uint temp = amount.sub(amount.mul(fees).div(DENOMINATOR));\n', '            selfBalance=selfBalance.sub(temp.mul(10**18).div(10**decimal));\n', '            updateLockedRPT(msg.sender,burnAmt);\n', '            tokens[_index].safeTransfer(msg.sender, temp);\n', '            emit userRecieved(msg.sender, temp); \n', '         }\n', '         else {\n', '             require(withdrawRecipients.length<maxWithdrawRequests || isInQ[msg.sender],"requests limit Exceeded");\n', '            _takeBackQ(amount,burnAmt,_index);\n', '            emit userAddedToQ(msg.sender, amount);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    // this will add unfulfilled withdraw requests to the withdrawl queue\n', '    function _takeBackQ(uint256 amount,uint256 _burnAmount,uint256 _index) internal {\n', '        amountWithdraw[msg.sender][_index] =amountWithdraw[msg.sender][_index].add( amount);\n', '        amountBurnt[msg.sender][_index]=amountBurnt[msg.sender][_index].add(_burnAmount);\n', '        uint currentPoolAmount=getBalances(_index);\n', '        uint withdrawAmount=amount.sub(currentPoolAmount);\n', '        reserveAmount[_index] = reserveAmount[_index].add(currentPoolAmount);\n', '        totalWithdraw[_index]=totalWithdraw[_index].add(withdrawAmount);\n', '        uint total;\n', '        total=(totalWithdraw[1].add(totalWithdraw[2])).mul(1e18).div(10**6);\n', '        require((totalWithdraw[0]+total)<=YieldPoolBalance,"Not enough balance");\n', '        if(!isInQ[msg.sender]) {\n', '            isInQ[msg.sender] = true;\n', '            withdrawRecipients.push(msg.sender);\n', '            \n', '        }\n', '    }\n', '\n', '\n', '    //this function is called when Royale Govenance withdrawl from yield generation pool.It add all the withdrawl amount in the reserve amount.\n', '    //All the users who requested for the withdrawl are added to the reserveRecipients.\n', '    function updateWithdrawQueue() internal{\n', '        for(uint8 i=0;i<3;i++){\n', '            reserveAmount[i]=reserveAmount[i].add(totalWithdraw[i]);\n', '            totalWithdraw[i]=0;\n', '        }\n', '        for(uint i=0; i<withdrawRecipients.length; i++) {\n', '            reserveRecipients[withdrawRecipients[i]]=true;\n', '            isInQ[withdrawRecipients[i]]=false;\n', '        }\n', '        uint count=withdrawRecipients.length;\n', '        for(uint i=0;i<count;i++){\n', '            withdrawRecipients.pop();\n', '        }\n', '    }\n', '\n', '    // this will withdraw Liquidity from yield genaration pool using yield Strategy\n', '    function _withdraw(uint256[3] memory amounts) internal {\n', '        strategy.withdraw(amounts);\n', '        uint decimal;\n', '        for(uint8 i=0;i<3;i++){\n', '            decimal=tokens[i].decimals();\n', '            YieldPoolBalance =YieldPoolBalance.sub(amounts[i].mul(10**18).div(10**decimal));\n', '        }\n', '    }\n', '\n', '    //This function calculate RPT to be mint or burn\n', '    //amount parameter is amount of token\n', '    //_index can be 0/1/2 \n', '    //0-DAI\n', '    //1-USDC\n', '    //2-USDT\n', '    function calcRptAmount(uint256 amount,uint _index) public view returns(uint256) {\n', '        uint256 total = calculateTotalToken(true);\n', '        uint256 decimal = 0;\n', '        decimal=tokens[_index].decimals();\n', '        amount=amount.mul(1e18).div(10**decimal);\n', '        if(total==0){\n', '            return amount;\n', '        }\n', '        else{\n', '          return (amount.mul(rpToken.totalSupply()).div(total)); \n', '        }\n', '    }\n', '\n', '\n', '\n', '    //function to check available amount to withdraw for user\n', '    function availableLiquidity(address addr, uint coin,bool _time) public view returns(uint256 token,uint256 RPT) {\n', '        uint256 amount=0;\n', '        for(uint8 j=0; j<amountSupplied[addr].length; j++) {\n', '                if( (!_time || (now - amountSupplied[addr][j].time)  > lock_period)&&amountSupplied[addr][j].remAmt >0)   {\n', '                        amount =amount.add(amountSupplied[addr][j].remAmt);\n', '                }\n', '        }\n', '        for(uint8 i=0;i<3;i++){\n', '            amount =amount.sub(amountBurnt[addr][i]);\n', '        }\n', '        uint256 total=calculateTotalToken(true);\n', '        uint256 decimal;\n', '        decimal=tokens[coin].decimals();\n', '        return ((amount.mul(total).mul(10**decimal).div(rpToken.totalSupply())).div(10**18),amount);\n', '    }\n', '    \n', '\n', '    //calculated available total tokens in the pool by substracting withdrawal, reserve amount.\n', '    //In case supply is true , it adds total loan given.\n', '    function calculateTotalToken(bool _supply)public view returns(uint256){\n', '        uint256 decimal;\n', '        uint withdrawTotal;\n', '        uint reserveTotal;\n', '       \n', '        for(uint8 i=0; i<3; i++) {\n', '            decimal = tokens[i].decimals();\n', '            withdrawTotal=withdrawTotal.add(totalWithdraw[i].mul(1e18).div(10**decimal));\n', '            reserveTotal=reserveTotal.add(reserveAmount[i].mul(1e18).div(10**decimal));\n', '        } \n', '        if(_supply){\n', '            return selfBalance.sub(withdrawTotal).sub(reserveTotal).add(loanGiven);\n', '        }\n', '        else{\n', '            return selfBalance.sub(withdrawTotal).sub(reserveTotal);\n', '        }\n', '        \n', '    }\n', '    \n', '    /* USER FUNCTIONS (exposed to frontend) */\n', '   \n', '    //For depositing liquidity to the pool.\n', '    //_index will be 0/1/2     0-DAI , 1-USDC , 2-USDT\n', '    function supply(uint256 amount,uint256 _index) external nonReentrant  validAmount(amount){\n', '        uint decimal;\n', '        uint256 mintAmount=calcRptAmount(amount,_index);\n', '        amountSupplied[msg.sender].push(depositDetails(_index,amount,now,mintAmount));\n', '        decimal=tokens[_index].decimals();\n', '        selfBalance=selfBalance.add(amount.mul(10**18).div(10**decimal));\n', '        tokens[_index].safeTransferFrom(msg.sender, address(this), amount);\n', '        rpToken.mint(msg.sender, mintAmount);\n', '        emit userSupplied(msg.sender, amount);\n', '    }\n', '\n', '    \n', '    //for withdrawing the liquidity\n', '    //First Parameter is amount of RPT\n', '    //Second is which token to be withdrawal with this RPT.\n', '    function requestWithdrawWithRPT(uint256 amount,uint256 _index) external nonReentrant validAmount(amount){\n', '        require(!reserveRecipients[msg.sender],"Claim first");\n', '        require(rpToken.balanceOf(msg.sender) >= amount, "low RPT");\n', '        (,uint availableRPT)=availableLiquidity(msg.sender,_index,true );\n', '        require(availableRPT>=amount,"NA");\n', '        uint256 total = calculateTotalToken(true);\n', '        uint256 tokenAmount;\n', '        tokenAmount=amount.mul(total).div(rpToken.totalSupply());\n', '        require(tokenAmount <= calculateTotalToken(false),"Not Enough Pool balance");\n', '        uint decimal;\n', '        decimal=tokens[_index].decimals();\n', '        checkWithdraw(tokenAmount.mul(10**decimal).div(10**18),amount,_index);  \n', '    }\n', '    \n', '    //For claiming withdrawal after user added to the reserve recipient.\n', '    function claimTokens() external  nonReentrant{\n', '        require(reserveRecipients[msg.sender] , "request withdraw first");\n', '        \n', '        uint totalBurnt;\n', '        uint decimal;\n', '        for(uint8 i=0; i<3; i++) {\n', '            if(amountWithdraw[msg.sender][i] > 0) {\n', '                decimal=tokens[i].decimals();\n', '                uint temp = amountWithdraw[msg.sender][i].sub((amountWithdraw[msg.sender][i].mul(fees)).div(DENOMINATOR));\n', '                reserveAmount[i] =reserveAmount[i].sub(amountWithdraw[msg.sender][i]);\n', '                selfBalance = selfBalance.sub(temp.mul(1e18).div(10**decimal));\n', '                totalBurnt =totalBurnt.add(amountBurnt[msg.sender][i]);\n', '                amountWithdraw[msg.sender][i] = 0;\n', '                amountBurnt[msg.sender][i]=0;\n', '                tokens[i].safeTransfer(msg.sender,  temp);\n', '                emit userRecieved(msg.sender,temp);\n', '            }\n', '        }\n', '        updateLockedRPT(msg.sender,totalBurnt);\n', '        reserveRecipients[msg.sender] = false;\n', '    }\n', '\n', '\n', '    // this function deposits without minting RPT.\n', '    //Used to deposit Yield\n', '    function depositYield(uint256 amount,uint _index) external{\n', '        uint decimal;\n', '        decimal=tokens[_index].decimals();\n', '        selfBalance=selfBalance.add(amount.mul(1e18).div(10**decimal));\n', '        liquidityProvidersAPY=liquidityProvidersAPY.add(amount.mul(1e18).div(10**decimal));\n', '        tokens[_index].safeTransferFrom(msg.sender,address(this),amount);\n', '        emit yieldAdded(amount);\n', '    }\n', '\n', '\n', '    /* CORE FUNCTIONS (called by owner only) */\n', '\n', '    //Transfer token to rStrategy by maintaining pool ratio.\n', '    function deposit() onlyWallet() external  {\n', '        uint256[3] memory amounts;\n', '        uint256 totalAmount;\n', '        uint256 decimal;\n', '        totalAmount=calculateTotalToken(false);\n', '        uint balanceAmount=totalAmount.mul(poolPart.div(3)).div(DENOMINATOR);\n', '        uint tokenBalance;\n', '        for(uint8 i=0;i<3;i++){\n', '            decimal=tokens[i].decimals();\n', '            amounts[i]=getBalances(i);\n', '            tokenBalance=balanceAmount.mul(10**decimal).div(10**18);\n', '            if(amounts[i]>tokenBalance) {\n', '                amounts[i]=amounts[i].sub(tokenBalance);\n', '                tokens[i].safeTransfer(address(strategy),amounts[i]);\n', '            }\n', '            else{\n', '                amounts[i]=0;\n', '            }\n', '        }\n', '        if(checkValidArray(amounts)){\n', '            _deposit(amounts);\n', '        }\n', '    }\n', '    \n', '\n', '    //Withdraw from Yield genaration pool.\n', '    function withdraw() onlyWallet() external  {\n', '        require(checkValidArray(totalWithdraw), "queue empty");\n', '        _withdraw(totalWithdraw);\n', '        updateWithdrawQueue();\n', '    }\n', '\n', '   //Withdraw total liquidity from yield generation pool\n', '    function withdrawAll() external onlyWallet() {\n', '        uint[3] memory amounts;\n', '        amounts=strategy.withdrawAll();\n', '        uint decimal;\n', '        selfBalance=0;\n', '        for(uint8 i=0;i<3;i++){\n', '            decimal=tokens[i].decimals();\n', '            selfBalance=selfBalance.add((tokens[i].balanceOf(address(this))).mul(1e18).div(10**decimal));\n', '        }\n', '        YieldPoolBalance=0;\n', '        updateWithdrawQueue();\n', '    }\n', '\n', '\n', '    //function for rebalancing royale pool(ratio)      \n', '    function rebalance() onlyWallet() external {\n', '        uint256 currentAmount;\n', '        uint256[3] memory amountToWithdraw;\n', '        uint256[3] memory amountToDeposit;\n', '        uint totalAmount;\n', '        uint256 decimal;\n', '        totalAmount=calculateTotalToken(false);\n', '        uint balanceAmount=totalAmount.mul(poolPart.div(3)).div(DENOMINATOR);\n', '        uint tokenBalance;\n', '        for(uint8 i=0;i<3;i++) {\n', '           currentAmount=getBalances(i);\n', '           decimal=tokens[i].decimals();\n', '           tokenBalance=balanceAmount.mul(10**decimal).div(10**18);\n', '           if(tokenBalance > currentAmount) {\n', '              amountToWithdraw[i] = tokenBalance.sub(currentAmount);\n', '           }\n', '           else if(tokenBalance < currentAmount) {\n', '               amountToDeposit[i] = currentAmount.sub(tokenBalance);\n', '               tokens[i].safeTransfer(address(strategy), amountToDeposit[i]);\n', '               \n', '           }\n', '           else {\n', '               amountToWithdraw[i] = 0;\n', '               amountToDeposit[i] = 0;\n', '           }\n', '        }\n', '        if(checkValidArray(amountToDeposit)){\n', '             _deposit(amountToDeposit);\n', '             \n', '        }\n', '        if(checkValidArray(amountToWithdraw)) {\n', '            _withdraw(amountToWithdraw);\n', '            \n', '        }\n', '\n', '    }\n', '    \n', '    //For withdrawing loan from the royale Pool\n', '    function withdrawLoan(uint[3] memory amounts,address _recipient)external onlyWallet(){\n', '        require(checkValidArray(amounts),"amount can not zero");\n', '        uint decimal;\n', '        uint total;\n', '        for(uint i=0;i<3;i++){\n', '           decimal=tokens[i].decimals();\n', '           total=total.add(amounts[i].mul(1e18).div(10**decimal));\n', '        }\n', '        require(loanGiven.add(total)<=(calculateTotalToken(true).mul(loanPart).div(DENOMINATOR)),"Exceed limit");\n', '        require(total<calculateTotalToken(false),"Not enough balance");\n', '        _withdraw(amounts);\n', '        loanGiven =loanGiven.add(total);\n', '        selfBalance=selfBalance.sub(total);\n', '        for(uint8 i=0; i<3; i++) {\n', '            if(amounts[i] > 0) {\n', '                tokens[i].safeTransfer(_recipient, amounts[i]);\n', '            }\n', '        }\n', '        \n', '    }\n', '    \n', '   // For repaying the loan to the royale Pool.\n', '    function repayLoan(uint[3] memory amounts)external {\n', '        require(checkValidArray(amounts),"amount can\'t be zero");\n', '        uint decimal;\n', '        for(uint8 i=0; i<3; i++) {\n', '            if(amounts[i] > 0) {\n', '                decimal=tokens[i].decimals();\n', '                loanGiven =loanGiven.sub(amounts[i].mul(1e18).div(10**decimal));\n', '                selfBalance=selfBalance.add(amounts[i].mul(1e18).div(10**decimal));\n', '                tokens[i].safeTransferFrom(msg.sender,address(this),amounts[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '\n', '    //for changing pool ratio\n', '    function changePoolPart(uint128 _newPoolPart) external onlyWallet()  {\n', '        poolPart = _newPoolPart;\n', '        \n', '    }\n', '\n', '   //For changing yield Strategy\n', '    function changeStrategy(address _strategy) onlyWallet() external  {\n', '        for(uint8 i=0;i<3;i++){\n', '            require(YieldPoolBalance==0, "Call withdrawAll function first");\n', '        } \n', '        strategy=rStrategy(_strategy);\n', '        \n', '    }\n', '\n', '    function setLockPeriod(uint256 lockperiod) onlyWallet() external  {\n', '        lock_period = lockperiod;\n', '        \n', '    }\n', '\n', '     // for changing withdrawal fees  \n', '    function setWithdrawFees(uint128 _fees) onlyWallet() external {\n', '        fees = _fees;\n', '\n', '    }\n', '    \n', '    function changeLoanPart(uint256 _value)onlyWallet() external{\n', '        loanPart=_value;\n', '    }\n', '\n', '   /* function transferAllFunds(address _address)external onlyWallet(){\n', '        selfBalance=0;\n', '        for(uint8 i=0;i<3;i++){\n', '            tokens[i].safeTransfer(_address,tokens[i].balanceOf(address(this)));\n', '        }\n', '    } */  \n', '    \n', '    function getBalances(uint _index) public view returns(uint256) {\n', '        return (tokens[_index].balanceOf(address(this)).sub(reserveAmount[_index]));\n', '    }\n', '}']