['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\aggregator\\IAMMAggregator.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IAMMAggregator is IAMM {\n', '\n', '    function doubleProxy() external view returns (address);\n', '\n', '    function setDoubleProxy(address newDoubleProxy) external;\n', '\n', '    function amms() external view returns (address[] memory);\n', '\n', '    function remove(uint256) external;\n', '\n', '    function add(address[] calldata) external;\n', '\n', '    function findByLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory, address);\n', '\n', '    function info(address liquidityPoolAddress) external view returns(string memory name, uint256 version, address amm);\n', '\n', '    function data(address liquidityPoolAddress) external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools, address amm);\n', '\n', '    event AMM(address indexed amm, string name, uint256 version);\n', '}\n', '\n', 'interface IDoubleProxy {\n', '    function proxy() external view returns (address);\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns (address);\n', '    function getStateHolderAddress() external view returns(address);\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function getBool(string calldata varName) external view returns (bool);\n', '    function getUint256(string calldata name) external view returns(uint256);\n', '    function getAddress(string calldata name) external view returns(address);\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\aggregator\\AMMAggregator.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'contract AMMAggregator is IAMMAggregator {\n', '\n', '    address private _doubleProxy;\n', '\n', '    uint256 private _ammsLength;\n', '    mapping(uint256 => address) private _amms;\n', '\n', '    constructor(address dFODoubleProxy, address[] memory ammsToAdd) {\n', '        _doubleProxy = dFODoubleProxy;\n', '        for(uint256 i = 0 ; i < ammsToAdd.length; i++) {\n', '            IAMM amm = IAMM(_amms[_ammsLength++] = ammsToAdd[i]);\n', '            (string memory name, uint256 version) = amm.info();\n', '            emit AMM(ammsToAdd[i], name, version);\n', '        }\n', '    }\n', '\n', '    modifier byDFO virtual {\n', '        require(_isFromDFO(msg.sender), "Unauthorized action");\n', '        _;\n', '    }\n', '\n', '    function _isFromDFO(address sender) private view returns(bool) {\n', '        IMVDProxy proxy = IMVDProxy(IDoubleProxy(_doubleProxy).proxy());\n', '        if(IMVDFunctionalitiesManager(proxy.getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(sender)) {\n', '            return true;\n', '        }\n', '        return proxy.getMVDWalletAddress() == sender;\n', '    }\n', '\n', '    function doubleProxy() public view override returns (address) {\n', '        return _doubleProxy;\n', '    }\n', '\n', '    function setDoubleProxy(address newDoubleProxy) public override byDFO {\n', '        _doubleProxy = newDoubleProxy;\n', '    }\n', '\n', '    function amms() public override view returns (address[] memory returnData) {\n', '        returnData = new address[](_ammsLength);\n', '        for(uint256 i = 0 ; i < _ammsLength; i++) {\n', '            returnData[i] = _amms[i];\n', '        }\n', '    }\n', '\n', '    function remove(uint256 index) public override byDFO {\n', '        require(index < _ammsLength--, "Invalid index");\n', '        _amms[index] = _amms[_ammsLength];\n', '        delete _amms[_ammsLength];\n', '    }\n', '\n', '    function add(address[] memory ammsToAdd) public override byDFO {\n', '        for(uint256 i = 0 ; i < ammsToAdd.length; i++) {\n', '            IAMM amm = IAMM(_amms[_ammsLength++] = ammsToAdd[i]);\n', '            (string memory name, uint256 version) = amm.info();\n', '            emit AMM(ammsToAdd[i], name, version);\n', '        }\n', '    }\n', '\n', '    function findByLiquidityPool(address liquidityPoolAddress) public override view returns(uint256, uint256[] memory, address[] memory, address amm) {\n', '        for(uint256 i = 0; i < _ammsLength; i++) {\n', '            try IAMM(amm = _amms[i]).byLiquidityPool(liquidityPoolAddress) returns (uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokensAddresses) {\n', '                if(tokensAddresses.length > 0) {\n', '                    return (liquidityPoolAmount, tokensAmounts, tokensAddresses, amm);\n', '                }\n', '            } catch {\n', '            }\n', '            amm = address(0);\n', '        }\n', '    }\n', '\n', '    function info() public override view returns(string memory, uint256) {}\n', '\n', '    function data() public override view returns(address, uint256, bool) {}\n', '\n', '    function info(address liquidityPoolAddress) public override view returns(string memory name, uint256 version, address amm) {\n', '        (,,,amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        (name, version) = IAMM(amm).info();\n', '    }\n', '\n', '    function data(address liquidityPoolAddress) public override view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools, address amm) {\n', '        (,,,amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        (ethereumAddress, maxTokensPerLiquidityPool, hasUniqueLiquidityPools) = IAMM(amm).data();\n', '    }\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) public override view returns(uint256, uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        return IAMM(amm).balanceOf(liquidityPoolAddress, owner);\n', '    }\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) public override view returns(uint256 liquidityPoolAmount, uint256[] memory tokensAmounts, address[] memory tokensAddresses) {\n', '        (liquidityPoolAmount, tokensAmounts, tokensAddresses,) = findByLiquidityPool(liquidityPoolAddress);\n', '    }\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) public override view returns(uint256, uint256[] memory, address, address[] memory) {}\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) public override view returns (uint256, uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        return IAMM(amm).byPercentage(liquidityPoolAddress, numerator, denominator);\n', '    }\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) public override view returns(uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        return IAMM(amm).byLiquidityPoolAmount(liquidityPoolAddress, liquidityPoolAmount);\n', '    }\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) public override view returns(uint256, uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(liquidityPoolAddress);\n', '        return IAMM(amm).byTokenAmount(liquidityPoolAddress, tokenAddress, tokenAmount);\n', '    }\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) public override payable returns(uint256, uint256[] memory, address, address[] memory) {\n', '        revert("Impossibru");\n', '    }\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) public override payable returns(uint256, uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(data.liquidityPoolAddress);\n', '        return IAMM(amm).addLiquidity(data);\n', '    }\n', '\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) public override payable returns(uint256[] memory, uint256[][] memory, address[][] memory) {\n', '        (,,,address amm) = findByLiquidityPool(data[0].liquidityPoolAddress);\n', '        return IAMM(amm).addLiquidityBatch(data);\n', '    }\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) public override returns(uint256, uint256[] memory, address[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(data.liquidityPoolAddress);\n', '        return IAMM(amm).removeLiquidity(data);\n', '    }\n', '\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) public override returns(uint256[] memory, uint256[][] memory, address[][] memory) {\n', '        (,,,address amm) = findByLiquidityPool(data[0].liquidityPoolAddress);\n', '        return IAMM(amm).removeLiquidityBatch(data);\n', '    }\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata liquidityPoolAddresses, address[] calldata path) view public override returns(uint256[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(liquidityPoolAddresses[0]);\n', '        return IAMM(amm).getSwapOutput(tokenAddress, tokenAmount, liquidityPoolAddresses, path);\n', '    }\n', '\n', '    function swapLiquidity(SwapData calldata data) public override payable returns(uint256) {\n', '        (,,,address amm) = findByLiquidityPool(data.liquidityPoolAddresses[0]);\n', '        return IAMM(amm).swapLiquidity(data);\n', '    }\n', '\n', '    function swapLiquidityBatch(SwapData[] calldata data) public override payable returns(uint256[] memory) {\n', '        (,,,address amm) = findByLiquidityPool(data[0].liquidityPoolAddresses[0]);\n', '        return IAMM(amm).swapLiquidityBatch(data);\n', '    }\n', '}']