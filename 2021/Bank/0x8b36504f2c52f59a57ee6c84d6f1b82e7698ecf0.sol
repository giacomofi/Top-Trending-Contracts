['pragma solidity ^0.6.2;\n', '\n', '// https://github.com/iearn-finance/vaults/blob/master/contracts/vaults/yVault.sol\n', '\n', 'import "./IStrategy.sol";\n', 'import "./ERC20.sol";\n', 'import "./SafeMath.sol";\n', "import './SafeERC20.sol';\n", "import './Ownable.sol';\n", '\n', 'contract FxsFraxJar is ERC20, Ownable {\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 public token;\n', '\n', '    address public strategy;\n', '    bool public locked = false;\n', '\n', '    constructor(IStrategy _strategy)\n', '        public\n', '        ERC20(\n', '            string(abi.encodePacked("FxsFrax_vault")),\n', '            string(abi.encodePacked("vFxsFrax"))\n', '        )\n', '    {\n', '        _setupDecimals(ERC20(_strategy.want()).decimals());\n', '        token = IERC20(_strategy.want());\n', '        strategy = address(_strategy);\n', '    }\n', '\n', '    function balance() public view returns (uint256) {\n', '        return\n', '            token.balanceOf(address(this)).add(\n', '                IStrategy(strategy).balanceOf()\n', '            );\n', '    }\n', '\n', '    function earn() public {\n', '        uint256 _bal = token.balanceOf(address(this));\n', '        token.safeTransfer(strategy, _bal);\n', '        IStrategy(strategy).deposit();\n', '    }\n', '\n', '    function depositAll() external {\n', '        deposit(token.balanceOf(msg.sender));\n', '    }\n', '\n', '    function deposit(uint256 _amount) public {\n', '        require(msg.sender == tx.origin, "no contracts");\n', '\n', '        uint256 _pool = balance();\n', '        uint256 _before = token.balanceOf(address(this));\n', '        token.safeTransferFrom(msg.sender, address(this), _amount);\n', '        uint256 _after = token.balanceOf(address(this));\n', '        _amount = _after.sub(_before); // Additional check for deflationary tokens\n', '        uint256 shares = 0;\n', '        if (totalSupply() == 0) {\n', '            shares = _amount;\n', '        } else {\n', '            shares = (_amount.mul(totalSupply())).div(_pool);\n', '        }\n', '        _mint(msg.sender, shares);\n', '    }\n', '\n', '    function withdrawAll() external {\n', '        withdraw(balanceOf(msg.sender));\n', '    }\n', '\n', '    // No rebalance implementation for lower fees and faster swaps\n', '    function withdraw(uint256 _shares) public {\n', '        uint256 underlyingAmountToWithdraw = (balance().mul(_shares)).div(totalSupply());\n', '        _burn(msg.sender, _shares);\n', '\n', '        // Check balance\n', '        uint256 _bal = token.balanceOf(address(this));\n', '        if (_bal < underlyingAmountToWithdraw) {\n', '            uint256 _withdraw = underlyingAmountToWithdraw.sub(_bal);\n', '            IStrategy(strategy).withdraw(_withdraw);\n', '            uint256 _after = token.balanceOf(address(this));\n', '            uint256 _diff = _after.sub(_bal);\n', '            if (_diff < _withdraw) {\n', '                underlyingAmountToWithdraw = _bal.add(_diff);\n', '            }\n', '        }\n', '\n', '        token.safeTransfer(msg.sender, underlyingAmountToWithdraw);\n', '    }\n', '\n', '    function getRatio() public view returns (uint256) {\n', '        return balance().mul(1e18).div(totalSupply());\n', '    }\n', '\n', '    //This function is onlyOwner in order to prevent abuse\n', "    //Otherwise, someone could lock up everyone's stake for 3 years\n", '    //No stakes will be locked until the migration to Sushiswap is done\n', '    function earnLocked(uint256 _amount, uint256 _secs) public onlyOwner {\n', '        uint256 _bal = token.balanceOf(address(this));\n', '        //Withdraw some staked tokens to the jar if necessary\n', '        if (_bal < _amount) {\n', '            uint256 _withdraw = _amount.sub(_bal);\n', '            IStrategy(strategy).withdraw(_withdraw);\n', '        }\n', '        token.safeTransfer(strategy, _amount);\n', '        IStrategy(strategy).depositLocked(_secs);\n', '    }\n', '\n', '    //Withdraw some tokens from a locked stake back to the jar\n', '    //This is onlyOwner in order to prevent random people from unstaking us\n', '    function withdrawLocked(bytes32 kek_id) public onlyOwner {\n', '        IStrategy(strategy).withdrawLocked(kek_id);\n', '    }\n', '\n', '    address public FXS_FRAX_SUSHI_LP = 0xc218001e3D102e3d1De9bf2c0F7D9626d76C6f30;\n', '\n', '    //Migrates from Uniswap to Sushiswap\n', '    function migrate() public onlyOwner {\n', '        //old LP token should not be in this contract, or it will get stuck\n', '        uint256 _bal = token.balanceOf(address(this));\n', '        if(_bal > 0) {\n', '            token.safeTransfer(strategy, _bal);\n', '        }\n', '\n', '        token = IERC20(FXS_FRAX_SUSHI_LP);\n', '        IStrategy(strategy).migrate();\n', '    }\n', '}']