['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-03\n', '*/\n', '\n', '/**\n', ' * SPDX-License-Identifier: MIT\n', ' */\n', 'pragma solidity ^0.8.4;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'interface IERC20Metadata is IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '}\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {return msg.sender;}\n', '    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\n', '}\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked { require(b <= a, errorMessage); return a - b; }\n', '    }\n', '}\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0;}\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");(bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, "Address: low-level call failed");}\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, "Address: low-level call with value failed");}\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) { return returndata; } else {\n', '            if (returndata.length > 0) {\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {revert(errorMessage);}\n', '        }\n', '    }\n', '}\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '    address private _previousOwner;\n', '    uint256 private _lockTime;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    function getUnlockTime() public view returns (uint256) {\n', '        return _lockTime;\n', '    }\n', '    function lock(uint256 time) public virtual onlyOwner {\n', '        _previousOwner = _owner;\n', '        _owner = address(0);\n', '        _lockTime = block.timestamp + time;\n', '        emit OwnershipTransferred(_owner, address(0));\n', '    }\n', '    function unlock() public virtual {\n', '        require(_previousOwner == msg.sender, "Only the previous owner can unlock onwership");\n', '        require(block.timestamp > _lockTime , "The contract is still locked");\n', '        emit OwnershipTransferred(_owner, _previousOwner);\n', '        _owner = _previousOwner;\n', '    }\n', '}\n', 'abstract contract Manageable is Context {\n', '    address private _manager;\n', '    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n', '    constructor(){\n', '        address msgSender = _msgSender();\n', '        _manager = msgSender;\n', '        emit ManagementTransferred(address(0), msgSender);\n', '    }\n', '    function manager() public view returns(address){ return _manager; }\n', '    modifier onlyManager(){\n', '        require(_manager == _msgSender(), "Manageable: caller is not the manager");\n', '        _;\n', '    }\n', '    function transferManagement(address newManager) external virtual onlyManager {\n', '        emit ManagementTransferred(_manager, newManager);\n', '        _manager = newManager;\n', '    }\n', '}\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', 'interface IUniswapV2Router {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '/**\n', ' * Tokenomics:\n', ' * \n', ' * Redistribution    2%\n', ' * Burn             14%\n', ' * Dev/Marketing     4%\n', ' */\n', '\n', 'abstract contract Tokenomics {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    string internal constant NAME = "CRYPTO PHOENIX";\n', '    string internal constant SYMBOL = "$CPHX";\n', '    \n', '    uint16 internal constant FEES_DIVISOR = 10**3;\n', '    uint8 internal constant DECIMALS = 18;\n', '    uint256 internal constant ZEROES = 10**DECIMALS;\n', '    \n', '    uint256 private constant MAX = ~uint256(0);\n', '    uint256 internal constant TOTAL_SUPPLY = 1000000000000000 * ZEROES;\n', '    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\n', '\n', '    uint256 internal constant maxTransactionAmount = TOTAL_SUPPLY / 40; // 2.5% of the total supply\n', '    \n', '    uint256 internal constant maxWalletBalance = TOTAL_SUPPLY / 20; // 5% of the total supply\n', '\n', '    address internal dev1Address = 0x75d9ea6fAfdBEdB2Ce00B76622Aa0DF1B68CaaF6; \n', '    address internal dev2Address = 0x35EF633803aE3918f37571AF741bC39Ad11e3Eaa; \n', '    address internal dev3Address = 0xfdAF289C815701d2b1b7b34340af584A9fABD2D8;\n', '    address internal dev4Address = 0x641E8274ce7513e2df215FcAD97515165019C497; \n', '\n', '    address internal burnAddress = 0x0000000000000000000000000000000000000000;\n', '\n', '    enum FeeType { Antiwhale, Burn, Rfi, External, ExternalToETH }\n', '    struct Fee {\n', '        FeeType name;\n', '        uint256 value;\n', '        address recipient;\n', '        uint256 total;\n', '    }\n', '\n', '    Fee[] internal fees;\n', '    uint256 internal sumOfFees;\n', '\n', '    constructor() {\n', '        _addFees();\n', '    }\n', '\n', '    function _addFee(FeeType name, uint256 value, address recipient) private {\n', '        fees.push( Fee(name, value, recipient, 0 ) );\n', '        sumOfFees += value;\n', '    }\n', '\n', '    function _addFees() private {\n', '\n', '        _addFee(FeeType.Rfi, 20, address(this) ); \n', '\n', '        _addFee(FeeType.Burn, 160, burnAddress );\n', '        _addFee(FeeType.External, 10, dev1Address );\n', '        _addFee(FeeType.External, 10, dev2Address );\n', '        _addFee(FeeType.External, 10, dev3Address );\n', '        _addFee(FeeType.External, 10, dev4Address );\n', '\n', '    }\n', '\n', '    function _getFeesCount() internal view returns (uint256){ return fees.length; }\n', '\n', '    function _getFeeStruct(uint256 index) private view returns(Fee storage){\n', '        require( index >= 0 && index < fees.length, "FeesSettings._getFeeStruct: Fee index out of bounds");\n', '        return fees[index];\n', '    }\n', '    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\n', '        Fee memory fee = _getFeeStruct(index);\n', '        return ( fee.name, fee.value, fee.recipient, fee.total );\n', '    }\n', '    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\n', '        Fee storage fee = _getFeeStruct(index);\n', '        fee.total = fee.total.add(amount);\n', '    }\n', '\n', '    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\n', '        Fee memory fee = _getFeeStruct(index);\n', '        return fee.total;\n', '    }\n', '}\n', '\n', 'abstract contract Presaleable is Manageable {\n', '    bool internal isInPresale;\n', '    function setPreseableEnabled(bool value) external onlyManager {\n', '        isInPresale = value;\n', '    }\n', '}\n', '\n', 'abstract contract BaseRfiToken is IERC20, IERC20Metadata, Ownable, Presaleable, Tokenomics {\n', '\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) internal _reflectedBalances;\n', '    mapping (address => uint256) internal _balances;\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '    \n', '    mapping (address => bool) internal _isExcludedFromFee;\n', '    mapping (address => bool) internal _isExcludedFromRewards;\n', '    address[] private _excluded;\n', '    constructor(){\n', '        \n', '        _reflectedBalances[owner()] = _reflectedSupply;\n', '        \n', '        _isExcludedFromFee[owner()] = true;\n', '        _isExcludedFromFee[address(this)] = true;\n', '        \n', '        _exclude(owner());\n', '        _exclude(address(this));\n', '\n', '        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\n', '        \n', '    }\n', '    \n', '        function name() external pure override returns (string memory) { return NAME; }\n', '        function symbol() external pure override returns (string memory) { return SYMBOL; }\n', '        function decimals() external pure override returns (uint8) { return DECIMALS; }\n', '        \n', '        function totalSupply() external pure override returns (uint256) {\n', '            return TOTAL_SUPPLY;\n', '        }\n', '        \n', '        function balanceOf(address account) public view override returns (uint256){\n', '            if (_isExcludedFromRewards[account]) return _balances[account];\n', '            return tokenFromReflection(_reflectedBalances[account]);\n', '        }\n', '        \n', '        function transfer(address recipient, uint256 amount) external override returns (bool){\n', '            _transfer(_msgSender(), recipient, amount);\n', '            return true;\n', '        }\n', '        \n', '        function allowance(address owner, address spender) external view override returns (uint256){\n', '            return _allowances[owner][spender];\n', '        }\n', '    \n', '        function approve(address spender, uint256 amount) external override returns (bool) {\n', '            _approve(_msgSender(), spender, amount);\n', '            return true;\n', '        }\n', '        \n', '        function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\n', '            _transfer(sender, recipient, amount);\n', '            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '            return true;\n', '        }\n', '\n', '    function burn(uint256 amount) external {\n', '\n', '        address sender = _msgSender();\n', '        require(sender != address(0), "BaseRfiToken: burn from the zero address");\n', '        require(sender != address(burnAddress), "BaseRfiToken: burn from the burn address");\n', '\n', '        uint256 balance = balanceOf(sender);\n', '        require(balance >= amount, "BaseRfiToken: burn amount exceeds balance");\n', '\n', '        uint256 reflectedAmount = amount.mul(_getCurrentRate());\n', '\n', '        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\n', '        if (_isExcludedFromRewards[sender])\n', '            _balances[sender] = _balances[sender].sub(amount);\n', '\n', '        _burnTokens( sender, amount, reflectedAmount );\n', '    }\n', '    \n', '    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\n', '\n', '        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\n', '        if (_isExcludedFromRewards[burnAddress])\n', '            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\n', '\n', '        emit Transfer(sender, burnAddress, tBurn);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '    \n', '    function isExcludedFromReward(address account) external view returns (bool) {\n', '        return _isExcludedFromRewards[account];\n', '    }\n', '\n', '    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\n', '        require(tAmount <= TOTAL_SUPPLY, "Amount must be less than supply");\n', '        if (!deductTransferFee) {\n', '            (uint256 rAmount,,,,) = _getValues(tAmount,0);\n', '            return rAmount;\n', '        } else {\n', '            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees(_msgSender(), tAmount));\n', '            return rTransferAmount;\n', '        }\n', '    }\n', '\n', '    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\n', '        require(rAmount <= _reflectedSupply, "Amount must be less than total reflections");\n', '        uint256 currentRate = _getCurrentRate();\n', '        return rAmount.div(currentRate);\n', '    }\n', '    \n', '    function excludeFromReward(address account) external onlyOwner() {\n', '        require(!_isExcludedFromRewards[account], "Account is not included");\n', '        _exclude(account);\n', '    }\n', '    \n', '    function _exclude(address account) internal {\n', '        if(_reflectedBalances[account] > 0) {\n', '            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\n', '        }\n', '        _isExcludedFromRewards[account] = true;\n', '        _excluded.push(account);\n', '    }\n', '\n', '    function includeInReward(address account) external onlyOwner() {\n', '        require(_isExcludedFromRewards[account], "Account is not excluded");\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] == account) {\n', '                _excluded[i] = _excluded[_excluded.length - 1];\n', '                _balances[account] = 0;\n', '                _isExcludedFromRewards[account] = false;\n', '                _excluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\n', '    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\n', '    \n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "BaseRfiToken: approve from the zero address");\n', '        require(spender != address(0), "BaseRfiToken: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '    \n', '    function _isUnlimitedSender(address account) internal view returns(bool){\n', '        return (account == owner());\n', '    }\n', '\n', '    function _isUnlimitedRecipient(address account) internal view returns(bool){\n', '        return (account == owner() || account == burnAddress);\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) private {\n', '\n', '        require(sender != address(0), "BaseRfiToken: transfer from the zero address");\n', '        require(recipient != address(0), "BaseRfiToken: transfer to the zero address");\n', '        require(sender != address(burnAddress), "BaseRfiToken: transfer from the burn address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        \n', '        bool takeFee = true;\n', '\n', '        if ( isInPresale ){ takeFee = false; }\n', '        else {\n', '\n', '            if ( amount > maxTransactionAmount && !_isUnlimitedSender(sender) && !_isUnlimitedRecipient(recipient) ){\n', '                revert("Transfer amount exceeds the maxTxAmount.");\n', '            }\n', '\n', '            if ( maxWalletBalance > 0 && !_isUnlimitedSender(sender) && !_isUnlimitedRecipient(recipient) && !_isV2Pair(recipient) ){\n', '                uint256 recipientBalance = balanceOf(recipient);\n', '                require(recipientBalance + amount <= maxWalletBalance, "New balance would exceed the maxWalletBalance");\n', '            }\n', '        }\n', '\n', '        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\n', '\n', '        _transferTokens(sender, recipient, amount, takeFee);\n', '        \n', '    }\n', '\n', '    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\n', '    \n', '        uint256 sumOfFees = _getSumOfFees(sender, amount);\n', '        if ( !takeFee ){ sumOfFees = 0; }\n', '        \n', '        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\n', '        \n', '        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\n', '        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\n', '\n', '        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\n', '        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }\n', '        \n', '        _takeFees( amount, currentRate, sumOfFees );\n', '        emit Transfer(sender, recipient, tTransferAmount);\n', '    }\n', '    \n', '    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees ) private {\n', '        if ( sumOfFees > 0 && !isInPresale ){\n', '            _takeTransactionFees(amount, currentRate);\n', '        }\n', '    }\n', '    \n', '    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n', '        \n', '        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\n', '        uint256 tTransferAmount = tAmount.sub(tTotalFees);\n', '        uint256 currentRate = _getCurrentRate();\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '        uint256 rTotalFees = tTotalFees.mul(currentRate);\n', '        uint256 rTransferAmount = rAmount.sub(rTotalFees);\n', '        \n', '        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\n', '    }\n', '    \n', '    function _getCurrentRate() internal view returns(uint256) {\n', '        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n', '        return rSupply.div(tSupply);\n', '    }\n', '    \n', '    function _getCurrentSupply() internal view returns(uint256, uint256) {\n', '        uint256 rSupply = _reflectedSupply;\n', '        uint256 tSupply = TOTAL_SUPPLY;  \n', '\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_reflectedBalances[_excluded[i]] > rSupply || _balances[_excluded[i]] > tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\n', '            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\n', '            tSupply = tSupply.sub(_balances[_excluded[i]]);\n', '        }\n', '        if (tSupply == 0 || rSupply < _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\n', '        return (rSupply, tSupply);\n', '    }\n', '    \n', '    function _getSumOfFees(address sender, uint256 amount) internal view virtual returns (uint256);\n', '\n', '    function _isV2Pair(address account) internal view virtual returns(bool);\n', '\n', '    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\n', '        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rFee = tFee.mul(currentRate);\n', '\n', '        _reflectedSupply = _reflectedSupply.sub(rFee);\n', '        _addFeeCollectedAmount(index, tFee);\n', '    }\n', '\n', '    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal virtual;\n', '}\n', '\n', 'abstract contract UniHelper is Ownable, Manageable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private withdrawableBalance;\n', '\n', '    enum Env {Testnet, MainnetV2, MainnetV3}\n', '    Env private _env;\n', '\n', '    address private _mainnetRouterV2Address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '\n', '    IUniswapV2Router internal _router;\n', '    address internal _pair;\n', '\n', '    uint256 private maxTransactionAmount;\n', '\n', '    event RouterSet(address indexed router);\n', '\n', '    receive() external payable {}\n', '\n', '    function initializeRouterPair(Env env, uint256 maxTx) internal {\n', '        _env = env;\n', '        _setRouterAddress(_mainnetRouterV2Address);\n', '\n', '        maxTransactionAmount = maxTx;\n', '    }\n', '\n', '    function _setRouterAddress(address router) private {\n', '        IUniswapV2Router _newUniswapRouter = IUniswapV2Router(router);\n', '        _pair = IUniswapV2Factory(_newUniswapRouter.factory()).createPair(address(this), _newUniswapRouter.WETH());\n', '        _router = _newUniswapRouter;\n', '        emit RouterSet(router);\n', '    }\n', '\n', '    function setRouterAddress(address router) external onlyManager() {\n', '        _setRouterAddress(router);\n', '    }\n', '\n', '    function _approveDelegate(address owner, address spender, uint256 amount) internal virtual;\n', '\n', '}\n', '\n', 'abstract contract Antiwhale is Tokenomics {\n', '\n', '    function _getAntiwhaleFees(uint256, uint256) internal view returns (uint256){\n', '        return sumOfFees;\n', '    }\n', '}\n', '\n', 'abstract contract PhoenixAbstract is BaseRfiToken, UniHelper, Antiwhale {\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    constructor(Env _env){\n', '\n', '        initializeRouterPair(_env, maxTransactionAmount);\n', '\n', '        _exclude(_pair);\n', '        _exclude(burnAddress);\n', '    }\n', '    \n', '    function _isV2Pair(address account) internal view override returns(bool){\n', '        return (account == _pair);\n', '    }\n', '\n', '    function _getSumOfFees(address sender, uint256 amount) internal view override returns (uint256){ \n', '        return _getAntiwhaleFees(balanceOf(sender), amount); \n', '    }\n', '    \n', '    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal override {\n', '        \n', '        if( isInPresale ){ return; }\n', '\n', '        uint256 feesCount = _getFeesCount();\n', '        for (uint256 index = 0; index < feesCount; index++ ){\n', '            (FeeType name, uint256 value, address recipient,) = _getFee(index);\n', '            if ( value == 0 ) continue;\n', '\n', '            if ( name == FeeType.Rfi ){\n', '                _redistribute( amount, currentRate, value, index );\n', '            }\n', '            else if ( name == FeeType.Burn ){\n', '                _burn( amount, currentRate, value, index );\n', '            }\n', '            else {\n', '                _takeFee( amount, currentRate, value, recipient, index );\n', '            }\n', '        }\n', '    }\n', '\n', '    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\n', '        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rBurn = tBurn.mul(currentRate);\n', '\n', '        _burnTokens(address(this), tBurn, rBurn);\n', '        _addFeeCollectedAmount(index, tBurn);\n', '    }\n', '\n', '    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\n', '\n', '        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\n', '        uint256 rAmount = tAmount.mul(currentRate);\n', '\n', '        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\n', '        if(_isExcludedFromRewards[recipient])\n', '            _balances[recipient] = _balances[recipient].add(tAmount);\n', '\n', '        _addFeeCollectedAmount(index, tAmount);\n', '    }\n', '    \n', '    function _approveDelegate(address owner, address spender, uint256 amount) internal override {\n', '        _approve(owner, spender, amount);\n', '    }\n', '}\n', '\n', 'contract CRYPTOPHOENIX is PhoenixAbstract{\n', '\n', '    constructor() PhoenixAbstract(Env.MainnetV2){\n', '        _approve(owner(),address(_router), ~uint256(0));\n', '    }\n', '}']