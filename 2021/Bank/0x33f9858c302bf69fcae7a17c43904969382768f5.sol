['// SPDX-License-Identifier: J-J-J-JENGA!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./Owned.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./RootKit.sol";\n', 'import "./IERC31337.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./IWETH.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./IERC20.sol";\n', 'import "./RootKitTransferGate.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./KETH.sol";\n', 'import "./RootKitTwoPoolCalculator.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IPonzoMaBobberV69.sol";\n', 'import "./IERC31337.sol";\n', '\n', 'contract PonzoMaBobberV69 is TokensRecoverable, IPonzoMaBobberV69\n', '\n', '    /*\n', '        Ponzo-Ma-BobberV69.sol\n', '        Status: Fully functional Infinity Edition\n', '        Calibration: Pumping Rootkit\n', '        \n', '        The Ponzo-Ma-Bobber is a contract with access to critical system control\n', '        functions and liquidity tokens for ROOT. It uses kETH and the ERC-31337 \n', '        sweeper functionality to make upwards market manipulation less tiresome.\n', '\n', '        Created by @ProfessorPonzo\n', '\n', '\n', '        uhhh wht?\n', '        How does this all work you might ask?\n', '\n', '        Any token with a fixed supply and permentantly locked liquidity has a very\n', '        easy to calculate price floor. The ETH below the price floor is trapped \n', '        due to the unique market structure. In order to access this otherwise lost\n', '        value, ROOT uses ERC-31337 to wrap wETH an extra time into kETH. Any ETH \n', '        trapped below the price floor in the wETH/ROOT liquidity pool is moved to\n', '        the kETH/ROOT pool. The Floor Calculator checks how much ETH is trapped\n', '        and removes the backing from that amount of kETH, thereby extracting the\n', '        trapped value without effecting the market structure. Once the system is\n', '        propped up by enough unbacked liquidity, control over factors like price\n', '        and slippage become possible.\n', '\n', '        After blowing thousands of ETH messing about with the market I finally\n', '        Wrapped all my learnings into one function. A combination of...\n', '        - Sweeping the floor and wrapping the recovered wETH into fresh kETH\n', '        - Buying with the swept wETH and adding more liquidity\n', '        - Removing liquidity and buying with the kETH\n', '        - Temporarly removing ROOT tokens from circulating supply\n', '        - Self arbatrage to extract one sided ETH liquidity\n', '\n', '        Its just gunna pump forever lol.\n', '\n', '        @ProfessorPonzo\n', '\n', '    */\n', '\n', '{\n', '    using SafeMath for uint256;\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '    RootKit immutable rootKit;\n', '    IWETH immutable weth;\n', '    KETH immutable keth;\n', '    IERC20 IKETH;\n', '    IERC20 rootKeth;\n', '    IERC20 rootWeth;\n', '    RootKitTwoPoolCalculator calculator;\n', '    RootKitTransferGate gate;\n', '    mapping (address => bool) public infinitePumpers;\n', '    uint256 minRootReverve;\n', '    uint256 pumpItPonzoPumpAmount;\n', '    uint256 sellmod;\n', '\n', '    constructor(IUniswapV2Router02 _uniswapV2Router, KETH _keth, IWETH _weth, RootKit _rootKit, RootKitTwoPoolCalculator _calculator, RootKitTransferGate _gate)\n', '    {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        rootKit = _rootKit;\n', '        calculator = _calculator;\n', '        \n', '        IUniswapV2Factory _uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '        weth = _weth;       \n', '        keth = _keth;\n', '        gate = _gate;\n', '\n', '        _keth.approve(address(_uniswapV2Router), uint256(-1));\n', '        _weth.approve(address(_uniswapV2Router), uint256(-1));\n', '        _rootKit.approve(address(_uniswapV2Router), uint256(-1));\n', '        _weth.approve(address(_keth), uint256(-1));\n', '\n', '        rootKeth = IERC20(_uniswapV2Factory.getPair(address(_keth), address(_rootKit)));\n', '        rootKeth.approve(address(_uniswapV2Router), uint256(-1));\n', '        rootWeth = IERC20(_uniswapV2Factory.getPair(address(_weth), address(_rootKit)));\n', '        rootWeth.approve(address(_uniswapV2Router), uint256(-1));\n', '    }\n', '\n', '    // The pump button is really fun, cant keep it all to myself\n', '    function setInfinitePumper(address pumper, bool infinite) public ownerOnly() {\n', '        infinitePumpers[pumper] = infinite;\n', '    }\n', '    \n', '    // Minimum root balance to keep in contract\n', '    function setMinRootReverve(uint256 minRoot) public ownerOnly() {\n', '        minRootReverve = minRoot;\n', '    }\n', '    \n', '    // Amount of LPs to remove and pump with\n', '    function setPumpItPonzoPumpAmount(uint256 pumpAmount) public ownerOnly() {\n', '        pumpItPonzoPumpAmount = pumpAmount;\n', '    }\n', '\n', '    // Percent to modify sell amount. 1031 base\n', '    function setSellMod(uint256 mod) public ownerOnly() {\n', '        sellmod = mod;\n', '    }\n', '\n', '    // Pumps or cycles root back into the pool\n', '    function infinity() public override {\n', '        if (rootKit.balanceOf(address(this)) >= minRootReverve) {\n', '            uint256 pumpLPs = rootKeth.totalSupply().mul(1e18).mul(42069).div(100000).div(1e18);\n', '            ETHiplication(pumpLPs);\n', '        }\n', '        else {\n', '            PumpItPonzo(pumpItPonzoPumpAmount);\n', '        }\n', '    }\n', '\n', '    function ETHiplicate(uint256 lpAmount) public override ownerOnly() {\n', '        ETHiplication(lpAmount);\n', '    }\n', '\n', '    // Removes liq from keth pool, buys with all kETH, ignores all Root\n', '    // Builds up a root balance in the Ponzo-Ma-Bobber\n', '    function PumpItPonzo(uint256 liquidity) public override {\n', '        require (msg.sender == owner || infinitePumpers[msg.sender], "You Wish!!!");\n', '        gate.setUnrestricted(true);\n', '        uint256 amountKeth= removeLiq(address(keth), liquidity);\n', '        uint256 wethInWethLiq = weth.balanceOf(address(rootWeth));\n', '        liquidity = amountKeth.mul(1e18).mul(wethInWethLiq).div(keth.balanceOf(address(rootKeth)).add(wethInWethLiq)).div(1e18);\n', '        keth.withdrawTokens(liquidity);\n', '        uniswapV2Router.swapExactTokensForTokens(keth.balanceOf(address(this)), 0, buyPath(), address(this), block.timestamp);\n', '        uniswapV2Router.swapExactTokensForTokens(weth.balanceOf(address(this)), 0, buyPathWeth(), address(this), block.timestamp);\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    // Equivilant to removing ETH only liquidity. When combined with the sweep \n', '    // function we can cycle our Root balance back into the liquidity pool\n', '    function ETHiplication(uint256 LPsToArbAgainst) internal {\n', '        uint256 totalExcessETH = calculator.calculateExcessInPools(weth, keth);\n', '        //Sweep the floor - sweep it\n', '        keth.sweepFloor(address(this));\n', '        // Unlock LPs - unlock it\n', '        gate.setUnrestricted(true);\n', '        // Remove weth liq for ETH to arb with and extra root to dump - rug it left\n', '        uint256 wethRemoved = removeLiq(address(weth), rootWeth.balanceOf(address(this)));\n', '        // Change extra wETH into kETH - wrap it\n', '        keth.depositTokens(weth.balanceOf(address(this)));\n', '        // Remove kETH liq to extend price movements - rug it right\n', '        uint256 kethRemoved = removeLiq(address(keth), LPsToArbAgainst);\n', '        // Buy with all keth - pump it\n', '        iPump(keth.balanceOf(address(this)));\n', '        // calculate sell amount to return price to start - check it\n', '        uint256 amountIn = uniswapV2Router.getAmountIn(kethRemoved.add(wethRemoved), rootKit.balanceOf(address(rootKeth)), keth.balanceOf(address(rootKeth)));\n', '        // dump it back down - dump it\n', '        iDump(amountIn.mul(sellmod).div(1000));\n', '        // Withdraw original liquidity amount - unwrap it\n', '        keth.withdrawTokens(wethRemoved);\n', '        // Add back all weth liquidity - stitch it\n', '        addLiq(address(weth), weth.balanceOf(address(this)));\n', '        // Add back all weth liquidity - fix it\n', '        addLiq(address(keth), keth.balanceOf(address(this)));\n', '        // Lock LPs - lock it\n', '        gate.setUnrestricted(false);\n', '        // Check new floor against old floor - confirm it\n', '        require (calculator.calculateExcessInPools(weth, keth) >= totalExcessETH, "Should have let it break, its always fixable. RIP gas"); // Guess some checks are important\n', '    }\n', '\n', '    // Move liquidity from kETH --->> wETH\n', '    function zapKethToWeth(uint256 liquidity) public ownerOnly() {\n', '        gate.setUnrestricted(true);\n', '        removeLiq(address(keth),liquidity);\n', '        keth.withdrawTokens(keth.balanceOf(address(this)));\n', '        addLiq(address(weth), weth.balanceOf(address(this)));\n', '        gate.setUnrestricted(false);\n', '    }\n', '    \n', '    // Move liquidity from wETH --->> kETH\n', '    function zapWethToKeth(uint256 liquidity) public ownerOnly() {\n', '        gate.setUnrestricted(true);\n', '        removeLiq(address(weth),liquidity);\n', '        keth.depositTokens(weth.balanceOf(address(this)));\n', '        addLiq(address(keth), keth.balanceOf(address(this)));\n', '        gate.setUnrestricted(false);\n', '    }\n', '\n', '    // Helper functions\n', '    function iPump(uint256 pumpAmount) internal { \n', '        uniswapV2Router.swapExactTokensForTokens(pumpAmount, 1, buyPath(), address(this), block.timestamp);\n', '    }\n', '    function iDump(uint256 dumpAmount) internal { \n', '        uniswapV2Router.swapExactTokensForTokens(dumpAmount, 1, sellPath(), address(this), block.timestamp);\n', '    }\n', '    function addLiq(address kethORweth, uint256 ethAmount) internal {\n', '        uniswapV2Router.addLiquidity(address(kethORweth), address(rootKit), ethAmount, rootKit.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\n', '    }\n', '    function removeLiq(address kethORweth, uint256 tokens) internal returns (uint256) {\n', '        (tokens,) = uniswapV2Router.removeLiquidity(address(kethORweth), address(rootKit), tokens, 0, 0, address(this), block.timestamp);\n', '        return tokens;\n', '    }\n', '    function sellPath() internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(rootKit);\n', '        path[1] = address(keth);\n', '        return path;\n', '    }\n', '    function buyPath() internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(keth);\n', '        path[1] = address(rootKit);\n', '        return path;\n', '    }\n', '    function buyPathWeth() internal view returns(address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(weth);\n', '        path[1] = address(rootKit);\n', '        return path;\n', '    }\n', '}']