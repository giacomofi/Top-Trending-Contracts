['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "LPReward: Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address transferOwner) public onlyOwner {\n', '        require(transferOwner != newOwner);\n', '        newOwner = transferOwner;\n', '    }\n', '\n', '    function acceptOwnership() virtual public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'interface INimbusRouter {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external  view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface INimbusFactory {\n', '    function getPair(address tokenA, address tokenB) external  view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'LPReward: ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'LPReward: ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'LPReward: ds-math-mul-overflow');\n", '    }\n', '}\n', '\n', 'library Math {\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        z = x < y ? x : y;\n', '    }\n', '\n', '    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '    }\n', '}\n', '\n', 'contract LPReward is Ownable {\n', '    using SafeMath for uint;\n', '\n', '    uint public lpRewardMaxAmount = 100_000_000e18;\n', '    uint public lpRewardUsed;\n', '    uint public immutable startReward;\n', '    uint public constant rewardPeriod = 365 days;\n', '\n', '    address public NBU;\n', '    address public swapRouter;\n', '    INimbusFactory public swapFactory;\n', '\n', '    mapping (address => mapping (address => uint)) public lpTokenAmounts;\n', '    mapping (address => mapping (address => uint)) public weightedRatio;\n', '    mapping (address => mapping (address => uint)) public ratioUpdateLast;\n', '    mapping (address => mapping (address => uint[])) public unclaimedAmounts;\n', '    mapping (address => bool) public allowedPairs;\n', '    mapping (address => address[]) public pairTokens;\n', '\n', '    event RecordAddLiquidity(uint ratio, uint weightedRatio, uint oldWeighted, uint liquidity);\n', '    event RecordRemoveLiquidityUnclaimed(address recipient, address pair, uint amountA, uint amountB, uint liquidity);\n', '    event RecordRemoveLiquidityGiveNbu(address recipient, address pair, uint nbu, uint amountA, uint amountB, uint liquidity);\n', '    event ClaimLiquidityNbu(address recipient, uint nbu, uint amountA, uint amountB);\n', '    event Rescue(address to, uint amount);\n', '    event RescueToken(address token, address to, uint amount); \n', '\n', '    constructor(address nbu, address factory) {\n', '        swapFactory = INimbusFactory(factory);\n', '        NBU = nbu;\n', '        startReward = block.timestamp;\n', '    }\n', '    \n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', '        require(unlocked == 1, "LPReward: LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    modifier onlyRouter() {\n', '        require(msg.sender == swapRouter, "Caller is not the allowed router");\n', '        _;\n', '    }\n', '    \n', '    function recordAddLiquidity(address recipient, address pair, uint amountA, uint amountB, uint liquidity) external onlyRouter {\n', '        if (!allowedPairs[pair]) return;\n', '        uint ratio = Math.sqrt(amountA.mul(amountB)).mul(1e18) / liquidity;   \n', '        uint previousRatio = weightedRatio[recipient][pair];\n', '        if (ratio < previousRatio) {\n', '            return;\n', '        }\n', '        uint previousAmount = lpTokenAmounts[recipient][pair];\n', '        uint newAmount = previousAmount.add(liquidity);\n', '        uint weighted =  (previousRatio.mul(previousAmount) / newAmount).add(ratio.mul(liquidity) / newAmount); \n', '        weightedRatio[recipient][pair] = weighted;\n', '        lpTokenAmounts[recipient][pair] = newAmount;\n', '        ratioUpdateLast[recipient][pair] = block.timestamp;\n', '        emit RecordAddLiquidity(ratio, weighted, previousRatio, liquidity);\n', '    }\n', '\n', '    function recordRemoveLiquidity(address recipient, address tokenA, address tokenB, uint amountA, uint amountB, uint liquidity) external lock onlyRouter { \n', '        address pair = swapFactory.getPair(tokenA, tokenB);\n', '        if (!allowedPairs[pair]) return;\n', '        uint amount0;\n', '        uint amount1;\n', '        {\n', '        uint previousAmount = lpTokenAmounts[recipient][pair];\n', '        if (previousAmount == 0) return;\n', '        uint ratio = Math.sqrt(amountA.mul(amountB)).mul(1e18) / liquidity;   \n', '        uint previousRatio = weightedRatio[recipient][pair];\n', '        if (previousRatio == 0 || (previousRatio != 0 && ratio < previousRatio)) return;\n', '        uint difference = ratio.sub(previousRatio);\n', '        if (previousAmount < liquidity) liquidity = previousAmount;\n', '        weightedRatio[recipient][pair] = (previousRatio.mul(previousAmount.sub(liquidity)) / previousAmount).add(ratio.mul(liquidity) / previousAmount);    \n', '        lpTokenAmounts[recipient][pair] = previousAmount.sub(liquidity);\n', '        amount0 = amountA.mul(difference) / 1e18;\n', '        amount1 = amountB.mul(difference) / 1e18; \n', '        }\n', '\n', '        uint amountNbu;\n', '        if (tokenA != NBU && tokenB != NBU) {\n', '            address tokenToNbuPair = swapFactory.getPair(tokenA, NBU);\n', '            if (tokenToNbuPair != address(0)) {\n', '                amountNbu = INimbusRouter(swapRouter).getAmountsOut(amount0, getPathForToken(tokenA))[1];\n', '            }\n', '\n', '            tokenToNbuPair = swapFactory.getPair(tokenB, NBU);\n', '            if (tokenToNbuPair != address(0)) {\n', '                if (amountNbu != 0) {\n', '                    amountNbu = amountNbu.add(INimbusRouter(swapRouter).getAmountsOut(amount1, getPathForToken(tokenB))[1]);\n', '                } else  {\n', '                    amountNbu = INimbusRouter(swapRouter).getAmountsOut(amount1, getPathForToken(tokenB))[1].mul(2);\n', '                }\n', '            } else {\n', '                amountNbu = amountNbu.mul(2);\n', '            }\n', '        } else if (tokenA == NBU) { \n', '            amountNbu = amount0.mul(2);\n', '        } else {\n', '            amountNbu = amount1.mul(2);\n', '        }\n', '        \n', '        if (amountNbu != 0 && amountNbu <= availableReward() && IERC20(NBU).balanceOf(address(this)) >= amountNbu) {\n', '            IERC20(NBU).transfer(recipient, amountNbu);\n', '            lpRewardUsed = lpRewardUsed.add(amountNbu);\n', '            emit RecordRemoveLiquidityGiveNbu(recipient, pair, amountNbu, amountA, amountB, liquidity);            \n', '        } else {\n', '            uint amountS0;\n', '            uint amountS1;\n', '            {\n', '            (address token0,) = sortTokens(tokenA, tokenB);\n', '            (amountS0, amountS1) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n', '            }\n', '            if (unclaimedAmounts[recipient][pair].length == 0) { \n', '                unclaimedAmounts[recipient][pair].push(amountS0);\n', '                unclaimedAmounts[recipient][pair].push(amountS1);\n', '            } else {\n', '                unclaimedAmounts[recipient][pair][0] = unclaimedAmounts[recipient][pair][0].add(amountS0);\n', '                unclaimedAmounts[recipient][pair][1] = unclaimedAmounts[recipient][pair][1].add(amountS1);\n', '            }\n', '            \n', '            emit RecordRemoveLiquidityUnclaimed(recipient, pair, amount0, amount1, liquidity);\n', '        }\n', '        ratioUpdateLast[recipient][pair] = block.timestamp;\n', '    }\n', '    \n', '    function claimBonusBatch(address[] memory pairs, address recipient) external lock {\n', '        for (uint i; i < pairs.length; i++) {\n', '            claimBonus(pairs[i],recipient);\n', '        }\n', '    }\n', '    \n', '    function claimBonus(address pair, address recipient) public lock {\n', '        require (allowedPairs[pair], "LPReward: Not allowed pair");\n', '        require (unclaimedAmounts[recipient][pair].length > 0 && (unclaimedAmounts[recipient][pair][0] > 0 || unclaimedAmounts[recipient][pair][1] > 0), "LPReward: No undistributed fee bonuses");\n', '        uint amountA;\n', '        uint amountB;\n', '        amountA = unclaimedAmounts[recipient][pair][0];\n', '        amountB = unclaimedAmounts[recipient][pair][1];\n', '        unclaimedAmounts[recipient][pair][0] = 0;\n', '        unclaimedAmounts[recipient][pair][1] = 0;\n', '\n', '        uint amountNbu = nbuAmountForPair(pair, amountA, amountB);\n', '        require (amountNbu > 0, "LPReward: No NBU pairs to token A and token B");\n', '        require (amountNbu <= availableReward(), "LPReward: Available reward for the period is used");\n', '        \n', '        IERC20(NBU).transfer(recipient, amountNbu);\n', '        lpRewardUsed = lpRewardUsed.add(amountNbu);\n', '        emit ClaimLiquidityNbu(recipient, amountNbu, amountA, amountB);            \n', '    }\n', '\n', '    function unclaimedAmountNbu(address recipient, address pair) external view returns (uint) {\n', '        uint amountA;\n', '        uint amountB;\n', '        if (unclaimedAmounts[recipient][pair].length != 0) {\n', '            amountA = unclaimedAmounts[recipient][pair][0];\n', '            amountB = unclaimedAmounts[recipient][pair][1];\n', '        } else  {\n', '            return 0;\n', '        }\n', '\n', '        return nbuAmountForPair(pair, amountA, amountB);\n', '    }\n', '\n', '    function unclaimedAmount(address recipient, address pair) external view returns (uint amountA, uint amountB) {\n', '        if (unclaimedAmounts[recipient][pair].length != 0) {\n', '            amountA = unclaimedAmounts[recipient][pair][0];\n', '            amountB = unclaimedAmounts[recipient][pair][1];\n', '        }\n', '    }\n', '\n', '    function availableReward() public view returns (uint) {\n', '        uint rewardForPeriod = lpRewardMaxAmount.mul(block.timestamp - startReward) / rewardPeriod;\n', '        if (rewardForPeriod > lpRewardUsed) return rewardForPeriod.sub(lpRewardUsed);\n', '        else return 0;\n', '    }\n', '\n', '    function nbuAmountForPair(address pair, uint amountA, uint amountB) private view returns (uint amountNbu) {\n', '        address tokenA = pairTokens[pair][0];\n', '        address tokenB = pairTokens[pair][1];\n', '        if (tokenA != NBU && tokenB != NBU) {\n', '            address tokenToNbuPair = swapFactory.getPair(tokenA, NBU);\n', '            if (tokenToNbuPair != address(0)) {\n', '                amountNbu = INimbusRouter(swapRouter).getAmountsOut(amountA, getPathForToken(tokenA))[1];\n', '            }\n', '\n', '            tokenToNbuPair = swapFactory.getPair(tokenB, NBU);\n', '            if (tokenToNbuPair != address(0)) {\n', '                if (amountNbu != 0) {\n', '                    amountNbu = amountNbu.add(INimbusRouter(swapRouter).getAmountsOut(amountB, getPathForToken(tokenB))[1]);\n', '                } else  {\n', '                    amountNbu = INimbusRouter(swapRouter).getAmountsOut(amountB, getPathForToken(tokenB))[1].mul(2);\n', '                }\n', '            } else {\n', '                amountNbu = amountNbu.mul(2);\n', '            }\n', '        } else if (tokenA == NBU) {\n', '            amountNbu = amountA.mul(2);\n', '        } else {\n', '            amountNbu = amountB.mul(2);\n', '        }\n', '    }\n', '\n', '    function getPathForToken(address token) private view returns (address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = token;\n', '        path[1] = NBU;\n', '        return path;\n', '    }\n', '\n', '    function sortTokens(address tokenA, address tokenB) private pure returns (address token0, address token1) {\n', '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '    }\n', '\n', '\n', '\n', '    function rescue(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "LPReward: Address is zero");\n', '        require(amount > 0, "LPReward: Should be greater than 0");\n', '        TransferHelper.safeTransferETH(to, amount);\n', '        emit Rescue(to, amount);\n', '    }\n', '\n', '    function rescue(address to, address token, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "LPReward: Address is zero");\n', '        require(amount > 0, "LPReward: Should be greater than 0");\n', '        TransferHelper.safeTransfer(token, to, amount);\n', '        emit RescueToken(token, to, amount);\n', '    }\n', '\n', '    function updateSwapRouter(address newRouter) external onlyOwner {\n', '        require (newRouter != address(0), "LPReward: Zero address");\n', '        swapRouter = newRouter;\n', '    }\n', '\n', '    function updateAllowedPair(address tokenA, address tokenB, bool isAllowed) external onlyOwner {\n', '        require (tokenA != address(0) && tokenB != address(0) && tokenA != tokenB, "LPReward: Wrong addresses");\n', '        address pair = swapFactory.getPair(tokenA, tokenB);\n', '        require (pair != address(0), "LPReward: Pair not exists");\n', '        if (!allowedPairs[pair]) {\n', '            (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '            pairTokens[pair].push(token0);\n', '            pairTokens[pair].push(token1);\n', '        }\n', '        allowedPairs[pair] = isAllowed;\n', '    }\n', '\n', '    function updateRewardMaxAmount(uint newAmount) external onlyOwner {\n', '        lpRewardMaxAmount = newAmount;\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}']