['# Copyright (C) 2021 VolumeFi Software, Inc.\n', '\n', '#  This program is free software: you can redistribute it and/or modify\n', '#  it under the terms of the Apache 2.0 License. \n', '#  This program is distributed WITHOUT ANY WARRANTY without even the implied warranty of\n', '#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n', '#  @author VolumeFi, Software inc.\n', '#  @notice This Vyper contract Adds liquidity to any Balancer pool from ETH or any ERC20 Token.\n', '#  SPDX-License-Identifier: Apache-2.0\n', '\n', '# @version ^0.2.0\n', '\n', 'interface ERC20:\n', '    def allowance(owner: address, spender: address) -> uint256: view\n', '\n', 'interface BFactory:\n', '    def isBPool(b: address) -> bool: view\n', '\n', 'interface BPool:\n', '    def joinswapExternAmountIn(tokenIn: address, tokenAmountIn: uint256, minPoolAmountOut: uint256) -> uint256: payable\n', '    def isBound(t: address) -> bool: view\n', '    def getNumTokens() -> uint256: view\n', '\n', 'interface UniswapV2Factory:\n', '    def getPair(tokenA: address, tokenB: address) -> address: view\n', '\n', 'interface WrappedEth:\n', '    def deposit(): payable\n', '\n', 'event LPTokenMint:\n', '    lptoken: address\n', '    recipient: address\n', '    liquidity: uint256\n', '\n', 'event Paused:\n', '    paused: bool\n', '\n', 'event FeeChanged:\n', '    newFee: uint256\n', '\n', 'UNISWAPV2ROUTER02: constant(address) = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', 'UNISWAPV2FACTORY: constant(address) = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\n', 'BALANCERFACTORY: constant(address) = 0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd\n', 'VETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', 'WETH: constant(address) = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', 'DEADLINE: constant(uint256) = MAX_UINT256 # change\n', '\n', 'TRANSFERFROM_MID: constant(Bytes[4]) = method_id("transferFrom(address,address,uint256)")\n', 'TRANSFER_MID: constant(Bytes[4]) = method_id("transfer(address,uint256)")\n', 'APPROVE_MID: constant(Bytes[4]) = method_id("approve(address,uint256)")\n', 'SWAPETFT_MID: constant(Bytes[4]) = method_id("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)")\n', 'GETCURRENTTOKENS_MID: constant(Bytes[4]) = method_id("getCurrentTokens()")\n', '\n', 'paused: public(bool)\n', 'admin: public(address)\n', 'feeAmount: public(uint256)\n', 'feeAddress: public(address)\n', '\n', '@external\n', 'def __init__():\n', '    self.paused = False\n', '    self.admin = msg.sender\n', '    self.feeAddress = 0xf29399fB3311082d9F8e62b988cBA44a5a98ebeD\n', '    self.feeAmount = 5 * 10 ** 15\n', '\n', '@internal\n', 'def _enter2Balancer(_toBalancerPoolAddress: address, _fromTokenContractAddress: address, tokens2Trade: uint256) -> uint256:\n', '    assert BPool(_toBalancerPoolAddress).isBound(_fromTokenContractAddress), "Token not bound"\n', '    _response32: Bytes[32] = empty(Bytes[32])\n', '    if ERC20(_fromTokenContractAddress).allowance(self, _toBalancerPoolAddress) > 0:\n', '        _response32 = raw_call(\n', '            _fromTokenContractAddress,\n', '            concat(\n', '                APPROVE_MID,\n', '                convert(_toBalancerPoolAddress, bytes32),\n', '                convert(0, bytes32)\n', '            ),\n', '            max_outsize=32\n', '        )  # dev: failed approve\n', '        if len(_response32) > 0:\n', '            assert convert(_response32, bool), "Approve failed"  # dev: failed approve\n', '    _response32 = raw_call(\n', '        _fromTokenContractAddress,\n', '        concat(\n', '            APPROVE_MID,\n', '            convert(_toBalancerPoolAddress, bytes32),\n', '            convert(tokens2Trade, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed approve\n', '    if len(_response32) > 0:\n', '        assert convert(_response32, bool), "Approve failed"  # dev: failed approve\n', '    poolTokensOut: uint256 = BPool(_toBalancerPoolAddress).joinswapExternAmountIn(_fromTokenContractAddress, tokens2Trade, 1)\n', '    assert poolTokensOut > 0, "Error in entering balancer pool"\n', '    return poolTokensOut\n', '\n', 'interface UniswapV2Pair:\n', '    def token0() -> address: view\n', '    def token1() -> address: view\n', '    def getReserves() -> (uint256, uint256, uint256): view\n', '\n', '@internal\n', '@pure\n', 'def _getPairTokens(pair: address) -> (address, address):\n', '    token0: address = UniswapV2Pair(pair).token0()\n', '    token1: address = UniswapV2Pair(pair).token1()\n', '    return (token0, token1)\n', '\n', '@internal\n', '@view\n', 'def _getLiquidityInPool(midToken: address, pair: address) -> uint256:\n', '    res0: uint256 = 0\n', '    res1: uint256 = 0\n', '    token0: address = ZERO_ADDRESS\n', '    token1: address = ZERO_ADDRESS\n', '    blockTimestampLast: uint256 = 0\n', '    (res0, res1, blockTimestampLast) = UniswapV2Pair(pair).getReserves()\n', '    (token0, token1) = self._getPairTokens(pair)\n', '    if token0 == midToken:\n', '        return res0\n', '    else:\n', '        return res1\n', '\n', '@internal\n', '@view\n', 'def _getMidTokenNumber(midToken: address, tokens: address[8]) -> uint256:\n', '    maxeth: uint256 = 0\n', '    maxi: uint256 = 0\n', '    for i in range(8):\n', '        if tokens[i] == ZERO_ADDRESS:\n', '            break\n', '        if midToken == tokens[i]:\n', '            return i\n', '        pair: address = UniswapV2Factory(UNISWAPV2FACTORY).getPair(midToken, tokens[i])\n', '        eth: uint256 = 0\n', '        if pair != ZERO_ADDRESS:\n', '            eth = self._getLiquidityInPool(midToken, pair)\n', '        if eth > maxeth:\n', '            maxeth = eth\n', '            maxi = i\n', '    return maxi\n', '\n', '@internal\n', 'def _token2Token(fromToken: address, toToken: address, tokens2Trade: uint256, deadline: uint256) -> uint256:\n', '    if fromToken == toToken:\n', '        return tokens2Trade\n', '    _response32: Bytes[32] = empty(Bytes[32])\n', '    if ERC20(fromToken).allowance(self, UNISWAPV2ROUTER02) > 0:\n', '        _response32 = raw_call(\n', '            fromToken,\n', '            concat(\n', '                APPROVE_MID,\n', '                convert(UNISWAPV2ROUTER02, bytes32),\n', '                convert(0, bytes32)\n', '            ),\n', '            max_outsize=32\n', '        )  # dev: failed approve\n', '        if len(_response32) > 0:\n', '            assert convert(_response32, bool), "Approve failed"  # dev: failed approve\n', '    _response32 = raw_call(\n', '        fromToken,\n', '        concat(\n', '            APPROVE_MID,\n', '            convert(UNISWAPV2ROUTER02, bytes32),\n', '            convert(tokens2Trade, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed approve\n', '    if len(_response32) > 0:\n', '        assert convert(_response32, bool), "Approve failed"  # dev: failed approve\n', '    \n', '    addrBytes: Bytes[288] = concat(convert(tokens2Trade, bytes32), convert(0, bytes32), convert(160, bytes32), convert(self, bytes32), convert(deadline, bytes32), convert(2, bytes32), convert(fromToken, bytes32), convert(toToken, bytes32))\n', '    funcsig: Bytes[4] = SWAPETFT_MID\n', '    full_data: Bytes[292] = concat(funcsig, addrBytes)\n', '    \n', '    _response128: Bytes[128] = raw_call(\n', '        UNISWAPV2ROUTER02,\n', '        full_data,\n', '        max_outsize=128\n', '    )\n', '    tokenBought: uint256 = convert(slice(_response128, 96, 32), uint256)\n', '    assert tokenBought > 0, "Error Swapping Token 2"\n', '    return tokenBought\n', '\n', '@internal\n', 'def _enter2BalancerViaUniswap(_toBalancerPoolAddress: address, _fromTokenContractAddress: address, _tokens2Trade: uint256) -> uint256:\n', '    tokens2Trade: uint256 = self._token2Token(_fromTokenContractAddress, WETH, _tokens2Trade, DEADLINE)\n', '    numTokens: uint256 = BPool(_toBalancerPoolAddress).getNumTokens()\n', '    \n', '    funcsig: Bytes[4] = GETCURRENTTOKENS_MID\n', '    \n', '    _response320: Bytes[320] = raw_call(\n', '        _toBalancerPoolAddress,\n', '        funcsig,\n', '        is_static_call=True,\n', '        max_outsize=320\n', '    )\n', '    tokens: address[8] = [ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS]\n', '    for i in range(8):\n', '        tokens[i] = convert(convert(slice(_response320, 32 * (convert(i, uint256) + 2), 32), uint256), address)\n', '        if convert(i, uint256) == (numTokens - 1):\n', '            break\n', '    midTokenNumber: uint256 = self._getMidTokenNumber(WETH, tokens)\n', '    tokens2Trade = self._token2Token(WETH, tokens[midTokenNumber], tokens2Trade, DEADLINE)\n', '    tokens2Trade = self._enter2Balancer(_toBalancerPoolAddress, tokens[midTokenNumber], tokens2Trade)\n', '    return tokens2Trade\n', '\n', '@external\n', '@payable\n', "@nonreentrant('lock')\n", 'def investTokenForBalancerPoolToken(_token: address, _pair: address, amount: uint256, minPoolTokens: uint256, deadline: uint256=DEADLINE) -> uint256:\n', '    assert amount > 0, "Invalid input amount"\n', '    assert block.timestamp <= deadline, "Expired"\n', '    assert not self.paused, "Paused"\n', '    assert BFactory(BALANCERFACTORY).isBPool(_pair), "!Balancer Pool"\n', '    fee: uint256 = self.feeAmount\n', '    assert msg.value >= fee, "Insufficient fee"\n', '    send(self.feeAddress, fee)\n', '    msg_value: uint256 = msg.value\n', '    msg_value -= fee\n', '    token: address = _token\n', '    _response32: Bytes[32] = empty(Bytes[32])\n', '    if token == VETH or token == ZERO_ADDRESS:\n', '        if msg_value > amount:\n', '            send(msg.sender, msg_value - amount)\n', '        else:\n', '            assert msg_value >= amount, "Insufficient value"\n', '        WrappedEth(WETH).deposit(value=amount)\n', '        token = WETH\n', '    else:\n', '        _response32 = raw_call(\n', '            token,\n', '            concat(\n', '                TRANSFERFROM_MID,\n', '                convert(msg.sender, bytes32),\n', '                convert(self, bytes32),\n', '                convert(amount, bytes32),\n', '            ),\n', '            max_outsize=32\n', '        )  # dev: failed transfer\n', '        if len(_response32) > 0:\n', '            assert convert(_response32, bool), "TransferFrom failed"  # dev: failed transfer\n', '    isBound: bool = BPool(_pair).isBound(token)\n', '    balancerTokens: uint256 = 0\n', '    if (isBound):\n', '        balancerTokens = self._enter2Balancer(_pair, token, amount)\n', '    else:\n', '        balancerTokens = self._enter2BalancerViaUniswap(_pair, token, amount)\n', '    _response32 = raw_call(\n', '        _pair,\n', '        concat(\n', '            TRANSFER_MID,\n', '            convert(msg.sender, bytes32),\n', '            convert(balancerTokens, bytes32),\n', '        ),\n', '        max_outsize=32\n', '    )  # dev: failed transfer\n', '    if len(_response32) > 0:\n', '        assert convert(_response32, bool), "Transfer failed"  # dev: failed transfer\n', '\n', '    assert balancerTokens >= minPoolTokens, "High Slippage"\n', '\n', '    log LPTokenMint(_pair, msg.sender, balancerTokens)\n', '\n', '    return balancerTokens\n', '\n', '# Admin functions\n', '@external\n', 'def pause(_paused: bool):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.paused = _paused\n', '    log Paused(_paused)\n', '\n', '@external\n', 'def newAdmin(_admin: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.admin = _admin\n', '\n', '@external\n', 'def newFeeAmount(_feeAmount: uint256):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.feeAmount = _feeAmount\n', '    log FeeChanged(_feeAmount)\n', '\n', '@external\n', 'def newFeeAddress(_feeAddress: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    self.feeAddress = _feeAddress\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def batchWithdraw(token: address[8], amount: uint256[8], to: address[8]):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    for i in range(8):\n', '        if token[i] == VETH:\n', '            send(to[i], amount[i])\n', '        elif token[i] != ZERO_ADDRESS:\n', '            _response32: Bytes[32] = raw_call(\n', '                token[i],\n', '                concat(\n', '                    TRANSFER_MID,\n', '                    convert(to[i], bytes32),\n', '                    convert(amount[i], bytes32),\n', '                ),\n', '                max_outsize=32\n', '            )  # dev: failed transfer\n', '            if len(_response32) > 0:\n', '                assert convert(_response32, bool), "Transfer failed"  # dev: failed transfer\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw(token: address, amount: uint256, to: address):\n', '    assert msg.sender == self.admin, "Not admin"\n', '    if token == VETH:\n', '        send(to, amount)\n', '    elif token != ZERO_ADDRESS:\n', '        _response32: Bytes[32] = raw_call(\n', '            token,\n', '            concat(\n', '                TRANSFER_MID,\n', '                convert(to, bytes32),\n', '                convert(amount, bytes32),\n', '            ),\n', '            max_outsize=32\n', '        )  # dev: failed transfer\n', '        if len(_response32) > 0:\n', '            assert convert(_response32, bool), "Transfer failed"  # dev: failed transfer\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    assert msg.sender == WETH, "can\'t receive Eth"']