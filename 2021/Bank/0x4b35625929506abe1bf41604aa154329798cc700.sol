['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-12\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity >=0.5.16 <0.5.17;\n', '\n', '// based on MyAdvancedToken8,2017-2021, inspired by parity sampleContract, Consensys-ERC20 and openzepelin\n', '\n', 'contract TokenMaster {\n', '    address internal masterCopy;\n', '\n', '    bytes32 internal name32;\n', '    uint256 private ownerPrices;                                                // buyPrice, sellPrice, owner address\n', '\n', '    mapping(address => uint256)                     private balances;\n', '    mapping(address => mapping(address => uint256)) private allowed;\n', '\n', '    // -------------------------------------------------------------\n', '    \n', '    uint256 constant k_buyPr       = 1 ether / 1000000;                         // price per share\n', '    uint256 constant k_sellPr      = k_buyPr - (k_buyPr/10);\n', '    uint256 constant k_sellBuy     = uint256( (uint256(uint256(k_buyPr)<<160) + uint256(uint256(k_sellPr)<<208)) & k_pMask );\n', '    \n', '    uint256 private _guardCounter  = 1;\n', '    \n', '    uint256 constant contractShare = uint256(1000000*10*2);                     // 10% contract reserve\n', '    uint256 constant contractShare2= uint256(1000000*10*1);\n', '    \n', '    uint256 constant provision     = uint256(1111100*2);                        // 1.11% provision\n', '    uint256 constant provision2    = uint256(1111100*1);\n', '    \n', '    uint256 constant k_aMask       = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\n', '    uint256 constant k_sMask       = 0xffffffffffff0000000000000000000000000000000000000000000000000000;\n', '    uint256 constant k_bMask       = 0x000000000000ffffffffffff0000000000000000000000000000000000000000;\n', '    uint256 constant k_mask        = 0x0000000000000000000000000000000000000000000000000000ffffffffffff;\n', '    uint256 constant k_pMask       = 0xffffffffffffffffffffffff0000000000000000000000000000000000000000;\n', '    uint256 constant k_frozenFlag  = 0x0000000000000000000000000000000000000000000000000000000000000001;\n', '    uint256 constant k_shareMask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\n', '\n', '    address constant k_add00       = address(0x0);\n', '    address constant k_provisonRec = address(0x00ec140832E635eF2f5786C60a55cc83eAf8D59d);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event FrozenFunds(address target, bool frozen);\n', '    event Deposit(address from, uint256 value);\n', '    event Deployment(address owner, address theContract);\n', '    event Approval(address indexed owner,address indexed spender,uint256 value);\n', '\n', '    modifier nonReentrant() {\n', '      _guardCounter += 1;\n', '      uint256 localCounter = _guardCounter;\n', '      _;\n', '      require(localCounter == _guardCounter,"re-entrance attack prohibited. Yeah!");\n', '    }\n', '    \n', '    function owner() external view returns (address ow) {\n', '      return address(uint160(ownerPrices & k_aMask));\n', '    }\n', '    \n', '    function name() external view returns (string memory) {\n', '      return bytes32ToStr(name32);\n', '    }\n', '    \n', '    function standard() external pure returns (string memory std) {\n', "      return 'ERC-20';\n", '    }\n', '    \n', '    function symbol() external pure returns (string memory sym) {\n', "      return 'shares';\n", '    }\n', '    \n', '    function decimals() external pure returns (uint8 dec) {\n', '      return  2;\n', '    }\n', '    \n', '    function totalSupply() external pure returns (uint256 spl) {\n', '      return 1000000;\n', '    }\n', '    \n', '    function sellPrice() external view returns (uint256 sp) {\n', '      return uint256( (uint256( ownerPrices & k_sMask )>>208) & k_mask );\n', '    }\n', '    \n', '    function buyPrice() external view returns (uint256 bp) {\n', '      return uint256( (uint256( ownerPrices & k_bMask )>>160) & k_mask );\n', '    }\n', '    \n', '    function balanceOf(address tokenOwner) external view returns (uint thebalance) {\n', '      return balances[tokenOwner]>>1;\n', '    }\n', '    \n', '    function frozen(address tokenOwner) external view returns (bool isFrozen) {\n', '      return (uint256(balances[tokenOwner] & k_frozenFlag) > 0);\n', '    }\n', '    \n', '    function tokenAllow(address tokenOwner,address spender) external view returns (uint256 tokens) {\n', '      return allowed[tokenOwner][spender];\n', '    }\n', '    \n', '    function saveOwner(uint256 buyP,uint256 sellP,address own) private pure returns (bytes32 o) {\n', '      return bytes32( uint256(uint256(buyP)<<160) + uint256(uint256(sellP)<<208) + uint256(uint160(own)) );\n', '    }\n', '    \n', '    function char(byte b) private pure returns (byte c) {\n', '        if (uint8(b) < uint8(10)) return byte(uint8(b) + 0x30);\n', '        else return byte(uint8(b) + 0x57);\n', '    }\n', '\n', '    function b_String(bytes32 _bytes32, uint len, bool isString) private pure returns (string memory) {\n', '        uint8 off = 0;\n', '        if (isString) off = 2;\n', '        bytes memory s = new bytes((len*2)+off);\n', '\n', '        if (isString) {\n', '          s[0] = 0x30;\n', '          s[1] = 0x78;\n', '        }\n', '      \n', '        uint8 count = 0;\n', '        \n', '        for (uint i = 0; i < len; i++) {\n', '            byte b = byte(uint8(uint(_bytes32) / (2 ** (8 * ((len-1) - i)))));\n', '            byte hi = byte(uint8(b) / 16);\n', '            byte lo = byte(uint8(b) - 16 * uint8(hi));\n', '            s[off+(2 * i)] = char(hi);\n', '            s[off+(2 * i) + 1] = char(lo);\n', '            count++;\n', '        }\n', '        \n', '        return string(s);\n', '    }\n', '    \n', '    function mb32(bytes memory _data) private pure returns(bytes32 a) {\n', '      assembly {\n', '          a := mload(add(_data, 32))\n', '      }\n', '    }\n', '    \n', '    function bytes32ToStr(bytes32 _b) internal pure returns (string memory)\n', '    { \n', '      bytes memory bArr = new bytes(32); \n', '      for (uint256 i;i<32;i++) { bArr[i] = _b[i]; } \n', '      return string(bArr); \n', '    }  \n', '    \n', '    function approve_v2d(address spender, uint tokens) external {\n', '        require(uint256(balances[msg.sender] & k_frozenFlag)==0,"account frozen!");\n', '        require(allowed[msg.sender][spender] == 0, "approve = 0 required!");\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '    }\n', '    \n', '    function transfer_G8l(address toReceiver, uint amount) external {\n', '        uint balSender = balances[msg.sender];\n', '        require(uint256(balSender & k_frozenFlag)==0,"account frozen!");\n', '        \n', '        require(balSender>>1 >= amount,"not enough token!");\n', '        uint bal = balances[toReceiver]>>1;\n', '        require(bal + amount >= bal,"overflow error!");\n', '        balances[msg.sender] -= amount<<1;\n', '        balances[toReceiver] += amount<<1;\n', '        \n', '        emit Transfer(msg.sender, toReceiver, amount);\n', '    }\n', '    \n', '    function transferFrom_78S(address from, address toReceiver, uint amount) external {\n', '        require(uint256(balances[msg.sender] & k_frozenFlag)==0,"account frozen!");\n', '\n', '        require(allowed[from][msg.sender] >= amount,"allowance too small");\n', '        allowed[from][msg.sender] -= amount;\n', '        \n', '        require(balances[from]>>1 >= amount,"not enough token!");\n', '        uint bal = balances[toReceiver]>>1;\n', '        require(bal + amount >= bal,"overflow error!");\n', '        balances[from] -= amount<<1;\n', '        balances[toReceiver] += amount<<1;\n', '\n', '        emit Transfer(from, toReceiver, amount);\n', '    }\n', '    \n', '    function transferOwnership_m0(address newOwner) external {\n', '        uint256 oPrices = ownerPrices;\n', '        require(msg.sender == address(uint160(oPrices & k_aMask)),"only owner");\n', '        ownerPrices =  uint256(oPrices & k_pMask) + uint256(uint160(newOwner));\n', '    }\n', '    \n', '    function freezeAccount_16R(address target, bool freeze) external {\n', '        require(msg.sender == address(uint160(ownerPrices & k_aMask)),"only owner");\n', '        uint b = balances[target];\n', '        b = b-uint256(b%2);\n', '        if (!freeze||target==k_provisonRec) balances[target] = uint256(b); else balances[target] = uint256(b+1);\n', '        emit FrozenFunds(target, freeze);\n', '    }\n', '\n', '    function setPrices_7d4(uint256 newSellPrice, uint256 newBuyPrice) external {\n', '        address o = address(uint160(ownerPrices & k_aMask));\n', '        require(msg.sender == o,"only owner");\n', '        ownerPrices = uint256(newBuyPrice<<160) + uint256(newSellPrice<<208) + uint256(o);\n', '    }\n', '      \n', '    function buy_uae() payable external nonReentrant {\n', '        require(msg.value>0,"value 0!");\n', '        \n', '        uint bal = balances[msg.sender];\n', '        require(uint256(bal & k_frozenFlag)==0,"account frozen!");\n', '        \n', '        uint256 ownPrices = ownerPrices;\n', '        uint256 bPrice    = uint256( (uint256( ownPrices & k_bMask )>>160) & k_mask );\n', '        \n', '        require(msg.value>0&&bPrice>0,"value/price 0");\n', '        uint amount = uint256(msg.value / bPrice);\n', '        \n', '        require(balances[address(this)]>>1 >= amount,"not enough token!");\n', '        require((bal>>1) + (amount<<1) >= (bal>>1),"overflow error!");\n', '        balances[address(this)] -= amount<<1;\n', '        balances[msg.sender]    += amount<<1;\n', '\n', '        emit Transfer(address(this), msg.sender, amount);\n', '    }\n', '\n', '    function sell_LA2(uint256 amount) external nonReentrant {\n', '        uint bal = balances[msg.sender];\n', '        require(uint256(bal & k_frozenFlag)==0,"account frozen!");\n', '        \n', '        uint256 ownPrices = ownerPrices;\n', '        uint256 sPrice    = uint256( (uint256( ownPrices & k_sMask )>>208) & k_mask );\n', '\n', '        require(amount>0&&sPrice>0,"value/price 0");\n', '        require(bal>>1 >= amount,"not enough token!");\n', '        \n', '        bal = balances[address(this)]>>1;\n', '        require(bal+amount >= bal,"overflow error!");\n', '        balances[msg.sender] -= amount<<1;\n', '        balances[address(this)] += amount<<1;\n', '\n', '        msg.sender.transfer(amount * sPrice);\n', '        emit Transfer(msg.sender, address(this), amount);\n', '    }\n', '    \n', '    function newToken(uint256[] calldata _data) external payable nonReentrant\n', '    {\n', '        uint l = _data.length-1;\n', '        require(l<=31 && l>=2,"2-31 owners only");\n', '\n', '        ownerPrices = k_sellBuy + uint256(uint160(msg.sender) & k_aMask);        \n', '        name32      = bytes32(_data[l]);\n', '\n', '        address    iOwner;\n', '        uint256    iShare;\n', '        \n', '        uint i=0;\n', '        do {\n', '          iOwner = address(uint160(_data[i] & k_aMask));\n', '          iShare = uint256(uint256(_data[i] & k_pMask)>>159) & k_shareMask;          \n', '          require((iShare != 0) && (iOwner != k_add00),"Illegal owner/share in list.");\n', '          \n', '          balances[iOwner] = iShare;\n', '          emit Transfer(address(this), iOwner, iShare>>1);\n', '          \n', '          i++;\n', '        } while(i<l);\n', '\n', '        balances[address(this)] = contractShare;                                // +10.00% token for proxyToken contract\n', '        emit Transfer(k_add00, address(this), contractShare2);\n', '        \n', '        balances[k_provisonRec] = provision;                                    // + 1.11% token provision\n', '        emit Transfer(k_add00, k_provisonRec, provision2);\n', '    }\n', '\n', '    function() external payable {\n', '      if (msg.value > 0) emit Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    constructor (bytes32 tokenName) public payable\n', '    { \n', '        name32      = tokenName;\n', '        ownerPrices = k_sellBuy + uint256(uint160(msg.sender) & k_aMask);\n', '        emit Deployment(msg.sender, address(this));\n', '    }\n', '}']