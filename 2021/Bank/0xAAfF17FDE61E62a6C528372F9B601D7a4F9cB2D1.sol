['// SPDX-License-Identifier: MIT\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity ^0.7.1;\n', '\n', 'import {\n', '    IPangolinRouter\n', '} from "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol";\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', '\n', 'import "../interfaces/IExperiPie.sol";\n', 'import "../interfaces/IPangolinRebalanceManager.sol";\n', '\n', 'contract PangolinRebalanceManager is IPangolinRebalanceManager {\n', '    IExperiPie public immutable basket;\n', '    IPangolinRouter public immutable pangolin;\n', '    address public rebalanceManager; \n', '    IERC20 private immutable nativeToken;\n', '\n', '    event Rebalanced(address indexed basket);\n', '    event Swaped(\n', '        address indexed basket,\n', '        address indexed fromToken,\n', '        address indexed toToken,\n', '        uint256 quantity,\n', '        uint256 returnedQuantity\n', '    );\n', '    event RebalanceManagerSet(address indexed rebalanceManager);\n', '\n', '    constructor(address _basket, address _pangolin, address _nativeToken) {\n', '        require(_basket != address(0), "INVALID_BASKET");\n', '        require(_pangolin != address(0), "INVALID_PANGOLIN");\n', '        require(_nativeToken != address(0), "INVALID_NATIVE_TOKEN");\n', '\n', '        basket = IExperiPie(_basket);\n', '        pangolin = IPangolinRouter(_pangolin);\n', '        rebalanceManager = msg.sender;\n', '        nativeToken = IERC20(_nativeToken);\n', '    }\n', '\n', '    modifier onlyRebalanceManager() {\n', '        require(\n', '            msg.sender == rebalanceManager, "NOT_ALLOWED"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function setRebalanceManager(address _rebalanceManager) external onlyRebalanceManager {\n', '        rebalanceManager = _rebalanceManager;\n', '        emit RebalanceManagerSet(_rebalanceManager);\n', '    }\n', '\n', '    function _swap(\n', '        address fromToken,\n', '        address toToken,\n', '        uint256 quantity,\n', '        uint256 minReturn,\n', '        address recipient,\n', '        uint256 deadline\n', '    ) internal {\n', '        // approve fromToken to pangolin\n', '        // IERC20(fromToken).approve(address(pangolin), uint256(-1));\n', '        if(IERC20(fromToken).allowance(address(basket), address(pangolin)) < quantity){\n', '            basket.singleCall(\n', '                fromToken,\n', '                abi.encodeWithSelector(\n', '                    IERC20(fromToken).approve.selector,\n', '                    address(pangolin),\n', '                    uint256(-1)\n', '                ),\n', '                0\n', '            );\n', '        }\n', '\n', '        // Swap on pangolin\n', '        // pangolin.swapExactTokensForTokens(amount, minReturnAmount, path, recipient, deadline);\n', '        address[] memory path = new address[](3);\n', '        path[0] = fromToken;\n', '        path[1] = address(nativeToken);\n', '        path[2] = toToken;\n', '        basket.singleCall(\n', '            address(pangolin),\n', '            abi.encodeWithSelector(\n', '                pangolin.swapExactTokensForTokens.selector,\n', '                quantity,\n', '                minReturn,\n', '                path,\n', '                recipient,\n', '                deadline\n', '            ),\n', '            0\n', '        );\n', '\n', '        emit Swaped(address(basket), fromToken, toToken, quantity, minReturn);\n', '    }\n', '\n', '    function removeToken(address _token) internal {\n', '        uint256 balance = basket.balance(_token);\n', '        bool inPool = basket.getTokenInPool(_token);\n', '        //if there is a token balance of the token is not in the pool, skip\n', '        if (balance != 0 || !inPool) {\n', '            return;\n', '        }\n', '\n', '        // remove token\n', '        basket.singleCall(\n', '            address(basket),\n', '            abi.encodeWithSelector(basket.removeToken.selector, _token),\n', '            0\n', '        );\n', '    }\n', '\n', '    function addToken(address _token) internal {\n', '        uint256 balance = basket.balance(_token);\n', '        bool inPool = basket.getTokenInPool(_token);\n', '        // If token has no balance or is already in the pool, skip\n', '        if (balance == 0 || inPool) {\n', '            return;\n', '        }\n', '\n', '        // add token\n', '        basket.singleCall(\n', '            address(basket),\n', '            abi.encodeWithSelector(basket.addToken.selector, _token),\n', '            0\n', '        );\n', '    }\n', '\n', '    function lockBasketData(uint256 _block)\n', '        internal\n', '        returns (bytes memory data)\n', '    {\n', '        basket.singleCall(\n', '            address(basket),\n', '            abi.encodeWithSelector(basket.setLock.selector, _block),\n', '            0\n', '        );\n', '    }\n', '\n', '    /**\n', '        @notice Rebalance underling token\n', '        @param _swaps Swaps to perform\n', '        @param _deadline Unix timestamp after which the transaction will revert.\n', '    */\n', '    function rebalance(SwapStruct[] calldata _swaps, uint256 _deadline)\n', '        external\n', '        override\n', '        onlyRebalanceManager\n', '    {\n', '        lockBasketData(block.number + 30);\n', '\n', '        // remove token from array\n', '        for (uint256 i; i < _swaps.length; i++) {\n', '            SwapStruct memory swap = _swaps[i];\n', '\n', '            //swap token\n', '            _swap(\n', '                swap.from,\n', '                swap.to,\n', '                swap.quantity,\n', '                swap.minReturn,\n', '                address(basket),\n', '                _deadline\n', '            );\n', '\n', '            //add to token if missing\n', '            addToken(swap.to);\n', '\n', '            //remove from token if resulting quantity is 0\n', '            removeToken(swap.from);\n', '        }\n', '        emit Rebalanced(address(basket));\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.6.2;\n', '\n', 'interface IPangolinRouter {\n', '    function factory() external pure returns (address);\n', '    function WAVAX() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityAVAX(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountAVAXMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityAVAX(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountAVAXMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountAVAX);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityAVAXWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountAVAXMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountAVAX);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountAVAXMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountAVAX);\n', '    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountAVAXMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountAVAX);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import "@pie-dao/diamond/contracts/interfaces/IERC173.sol";\n', 'import "@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol";\n', 'import "@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol";\n', 'import "./IBasketFacet.sol";\n', 'import "./IERC20Facet.sol";\n', 'import "./ICallFacet.sol";\n', '\n', '/**\n', '    @title ExperiPie Interface\n', '    @dev Combines all ExperiPie facet interfaces into one\n', '*/\n', 'interface IExperiPie is\n', '    IERC20,\n', '    IBasketFacet,\n', '    IERC20Facet,\n', '    IERC173,\n', '    ICallFacet,\n', '    IDiamondLoupe,\n', '    IDiamondCut\n', '{\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity ^0.7.1;\n', '\n', 'import {\n', '    IPangolinRouter\n', '} from "@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol";\n', 'import "./IExperiPie.sol";\n', '\n', 'interface IPangolinRebalanceManager {\n', '    struct SwapStruct {\n', '        address from; //Token to sell\n', '        address to; //Token to buy\n', '        uint256 quantity; //Quantity to sell\n', '        uint256 minReturn; //Minimum quantity to buy //todo change to price for safty\n', '    }\n', '\n', '    /**\n', '        @notice Rebalance underling token\n', '        @param _swaps Swaps to perform\n', '        @param _deadline Unix timestamp after which the transaction will revert.\n', '    */\n', '    function rebalance(SwapStruct[] calldata _swaps, uint256 _deadline)\n', '        external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', '\n', '/// @title ERC-173 Contract Ownership Standard\n', '///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n', '/* is ERC165 */\n', 'interface IERC173 {\n', '    /// @dev This emits when ownership of a contract changes.\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice Get the address of the owner\n', '    /// @return owner_ The address of the owner.\n', '    function owner() external view returns (address owner_);\n', '\n', '    /// @notice Set the address of the new owner of the contract\n', '    /// @dev Set _newOwner to address(0) to renounce any ownership.\n', '    /// @param _newOwner The address of the new owner of the contract\n', '    function transferOwnership(address _newOwner) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// A loupe is a small magnifying glass used to look at diamonds.\n', '// These functions look at diamonds\n', 'interface IDiamondLoupe {\n', '    /// These functions are expected to be called frequently\n', '    /// by tools.\n', '\n', '    struct Facet {\n', '        address facetAddress;\n', '        bytes4[] functionSelectors;\n', '    }\n', '\n', '    /// @notice Gets all facet addresses and their four byte function selectors.\n', '    /// @return facets_ Facet\n', '    function facets() external view returns (Facet[] memory facets_);\n', '\n', '    /// @notice Gets all the function selectors supported by a specific facet.\n', '    /// @param _facet The facet address.\n', '    /// @return facetFunctionSelectors_\n', '    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n', '\n', '    /// @notice Get all the facet addresses used by a diamond.\n', '    /// @return facetAddresses_\n', '    function facetAddresses() external view returns (address[] memory facetAddresses_);\n', '\n', '    /// @notice Gets the facet that supports the given selector.\n', '    /// @dev If facet is not found return address(0).\n', '    /// @param _functionSelector The function selector.\n', '    /// @return facetAddress_ The facet address.\n', '    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/******************************************************************************\\\n', '* Author: Nick Mudge <[email\xa0protected]> (https://twitter.com/mudgen)\n', '/******************************************************************************/\n', '\n', 'interface IDiamondCut {\n', '    enum FacetCutAction {Add, Replace, Remove}\n', '\n', '    struct FacetCut {\n', '        address facetAddress;\n', '        FacetCutAction action;\n', '        bytes4[] functionSelectors;\n', '    }\n', '\n', '    /// @notice Add/replace/remove any number of functions and optionally execute\n', '    ///         a function with delegatecall\n', '    /// @param _diamondCut Contains the facet addresses and function selectors\n', '    /// @param _init The address of the contract or facet to execute _calldata\n', '    /// @param _calldata A function call, including function selector and arguments\n', '    ///                  _calldata is executed with delegatecall on _init\n', '    function diamondCut(\n', '        FacetCut[] calldata _diamondCut,\n', '        address _init,\n', '        bytes calldata _calldata\n', '    ) external;\n', '\n', '    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma experimental ABIEncoderV2;\n', 'pragma solidity ^0.7.1;\n', '\n', 'interface IBasketFacet {\n', '    event TokenAdded(address indexed _token);\n', '    event TokenRemoved(address indexed _token);\n', '    event EntryFeeSet(uint256 fee);\n', '    event ExitFeeSet(uint256 fee);\n', '    event AnnualizedFeeSet(uint256 fee);\n', '    event FeeBeneficiarySet(address indexed beneficiary);\n', '    event EntryFeeBeneficiaryShareSet(uint256 share);\n', '    event ExitFeeBeneficiaryShareSet(uint256 share);\n', '\n', '    event PoolJoined(address indexed who, uint256 amount, uint16 _referral);\n', '    event PoolExited(address indexed who, uint256 amount, uint16 _referral);\n', '    event FeeCharged(uint256 amount);\n', '    event LockSet(uint256 lockBlock);\n', '    event CapSet(uint256 cap);\n', '\n', '    /**\n', '        @notice Sets entry fee paid when minting\n', '        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n', '    */\n', '    function setEntryFee(uint256 _fee) external;\n', '\n', '    /**\n', '        @notice Get the entry fee\n', '        @return Current entry fee\n', '    */\n', '    function getEntryFee() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the exit fee paid when exiting\n', '        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n', '    */\n', '    function setExitFee(uint256 _fee) external;\n', '\n', '    /**\n', '        @notice Get the exit fee\n', '        @return Current exit fee\n', '    */\n', '    function getExitFee() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the annualized fee. Often referred to as streaming fee\n', '        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\n', '    */\n', '    function setAnnualizedFee(uint256 _fee) external;\n', '\n', '    /**\n', '        @notice Get the annualized fee.\n', '        @return Current annualized fee.\n', '    */\n', '    function getAnnualizedFee() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the address receiving the fees.\n', '    */\n', '    function setFeeBeneficiary(address _beneficiary) external;\n', '\n', '    /**\n', '        @notice Get the fee benificiary\n', '        @return The current fee beneficiary\n', '    */\n', '    function getFeeBeneficiary() external view returns (address);\n', '\n', '    /**\n', '        @notice Set the fee beneficiaries share of the entry fee\n', '        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\n', '    */\n', '    function setEntryFeeBeneficiaryShare(uint256 _share) external;\n', '\n', '    /**\n', '        @notice Get the entry fee beneficiary share\n', '        @return Feeshare amount\n', '    */\n', '    function getEntryFeeBeneficiaryShare() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the fee beneficiaries share of the exit fee\n', '        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\n', '    */\n', '    function setExitFeeBeneficiaryShare(uint256 _share) external;\n', '\n', '    /**\n', '        @notice Get the exit fee beneficiary share\n', '        @return Feeshare amount\n', '    */\n', '    function getExitFeeBeneficiaryShare() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Calculate the oustanding annualized fee\n', '        @return Amount of pool tokens to be minted to charge the annualized fee\n', '    */\n', '    function calcOutStandingAnnualizedFee() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Charges the annualized fee\n', '    */\n', '    function chargeOutstandingAnnualizedFee() external;\n', '\n', '    /**\n', '        @notice Pulls underlying from caller and mints the pool token\n', '        @param _amount Amount of pool tokens to mint\n', '        @param _referral Partners may receive rewards with their referral code\n', '    */\n', '    function joinPool(uint256 _amount, uint16 _referral) external;\n', '\n', '    /**\n', '        @notice Burns pool tokens from the caller and returns underlying assets\n', '    */\n', '    function exitPool(uint256 _amount, uint16 _referral) external;\n', '\n', '    /**\n', '        @notice Get if the pool is locked or not. (not accepting exit and entry)\n', '        @return Boolean indicating if the pool is locked\n', '    */\n', '    function getLock() external view returns (bool);\n', '\n', '    /**\n', '        @notice Get the block until which the pool is locked\n', '        @return The lock block\n', '    */\n', '    function getLockBlock() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the lock block\n', '        @param _lock Block height of the lock\n', '    */\n', '    function setLock(uint256 _lock) external;\n', '\n', '    /**\n', '        @notice Get the maximum of pool tokens that can be minted\n', '        @return Cap\n', '    */\n', '    function getCap() external view returns (uint256);\n', '\n', '    /**\n', '        @notice Set the maximum of pool tokens that can be minted\n', '        @param _maxCap Max cap\n', '    */\n', '    function setCap(uint256 _maxCap) external;\n', '\n', '    /**\n', '        @notice Get the amount of tokens owned by the pool\n', '        @param _token Addres of the token\n', '        @return Amount owned by the contract\n', '    */\n', '    function balance(address _token) external view returns (uint256);\n', '\n', '    /**\n', '        @notice Get the tokens in the pool\n', '        @return Array of tokens in the pool\n', '    */\n', '    function getTokens() external view returns (address[] memory);\n', '\n', '    /**\n', '        @notice Add a token to the pool. Should have at least a balance of 10**6\n', '        @param _token Address of the token to add\n', '    */\n', '    function addToken(address _token) external;\n', '\n', '    /**\n', '        @notice Removes a token from the pool\n', '        @param _token Address of the token to remove\n', '    */\n', '    function removeToken(address _token) external;\n', '\n', '    /**\n', '        @notice Checks if a token was added to the pool\n', '        @param _token address of the token\n', '        @return If token is in the pool or not\n', '    */\n', '    function getTokenInPool(address _token) external view returns (bool);\n', '\n', '    /**\n', '        @notice Calculate the amounts of underlying needed to mint that pool amount.\n', '        @param _amount Amount of pool tokens to mint\n', '        @return tokens Tokens needed\n', '        @return amounts Amounts of underlying needed\n', '    */\n', '    function calcTokensForAmount(uint256 _amount)\n', '        external\n', '        view\n', '        returns (address[] memory tokens, uint256[] memory amounts);\n', '\n', '    /**\n', '        @notice Calculate the amounts of underlying to receive when burning that pool amount\n', '        @param _amount Amount of pool tokens to burn\n', '        @return tokens Tokens returned\n', '        @return amounts Amounts of underlying returned\n', '    */\n', '    function calcTokensForAmountExit(uint256 _amount)\n', '        external\n', '        view\n', '        returns (address[] memory tokens, uint256[] memory amounts);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20Facet {\n', '    /**\n', '        @notice Get the token name\n', '        @return The token name\n', '    */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '        @notice Get the token symbol\n', '        @return The token symbol \n', '    */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '        @notice Get the amount of decimals\n', '        @return Amount of decimals\n', '    */\n', '    function decimals() external view returns (uint8);\n', '\n', '    /**\n', '        @notice Mints tokens. Can only be called by the contract owner or the contract itself\n', '        @param _receiver Address receiving the tokens\n', '        @param _amount Amount to mint\n', '    */\n', '    function mint(address _receiver, uint256 _amount) external;\n', '\n', '    /**\n', '        @notice Burns tokens. Can only be called by the contract owner or the contract itself\n', '        @param _from Address to burn from\n', '        @param _amount Amount to burn\n', '    */\n', '    function burn(address _from, uint256 _amount) external;\n', '\n', '    /**\n', '        @notice Sets up the metadata and initial supply. Can be called by the contract owner\n', '        @param _initialSupply Initial supply of the token\n', '        @param _name Name of the token\n', '        @param _symbol Symbol of the token\n', '    */\n', '    function initialize(\n', '        uint256 _initialSupply,\n', '        string memory _name,\n', '        string memory _symbol\n', '    ) external;\n', '\n', '    /**\n', '        @notice Set the token name of the contract. Can only be called by the contract owner or the contract itself\n', '        @param _name New token name\n', '    */\n', '    function setName(string calldata _name) external;\n', '\n', '    /**\n', '        @notice Set the token symbol of the contract. Can only be called by the contract owner or the contract itself\n', '        @param _symbol New token symbol\n', '    */\n', '    function setSymbol(string calldata _symbol) external;\n', '\n', '    /**\n', '        @notice Increase the amount of tokens another address can spend\n', '        @param _spender Spender\n', '        @param _amount Amount to increase by\n', '    */\n', '    function increaseApproval(address _spender, uint256 _amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '        @notice Decrease the amount of tokens another address can spend\n', '        @param _spender Spender\n', '        @param _amount Amount to decrease by\n', '    */\n', '    function decreaseApproval(address _spender, uint256 _amount)\n', '        external\n', '        returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.1;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface ICallFacet {\n', '    event CallerAdded(address indexed caller);\n', '    event CallerRemoved(address indexed caller);\n', '    event Call(\n', '        address indexed caller,\n', '        address indexed target,\n', '        bytes data,\n', '        uint256 value\n', '    );\n', '\n', '    /**\n', '        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool. Reverts if one of the calls fails\n', '        @param _targets Array of addresses of targets to call\n', '        @param _calldata Array of calldata for each call\n', '        @param _values Array of amounts of ETH to send with the call\n', '    */\n', '    function call(\n', '        address[] memory _targets,\n', '        bytes[] memory _calldata,\n', '        uint256[] memory _values\n', '    ) external;\n', '\n', '    /**\n', '        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool without sending any Ether. Reverts if one of the calls fail\n', '        @param _targets Array of addresses of targets to call\n', '        @param _calldata Array of calldata for each call\n', '    */\n', '    function callNoValue(address[] memory _targets, bytes[] memory _calldata)\n', '        external;\n', '\n', '    /**\n', '        @notice Lets whitelisted callers execute a single arbitrary call from the pool. Reverts if the call fails\n', '        @param _target Address of the target to call\n', '        @param _calldata Calldata of the call\n', '        @param _value Amount of ETH to send with the call\n', '    */\n', '    function singleCall(\n', '        address _target,\n', '        bytes calldata _calldata,\n', '        uint256 _value\n', '    ) external;\n', '\n', '    /**\n', '        @notice Add a whitelisted caller. Can only be called by the contract owner\n', '        @param _caller Caller to add\n', '    */\n', '    function addCaller(address _caller) external;\n', '\n', '    /**\n', '        @notice Remove a whitelisted caller. Can only be called by the contract owner\n', '    */\n', '    function removeCaller(address _caller) external;\n', '\n', '    /**\n', '        @notice Checks if an address is a whitelisted caller\n', '        @param _caller Address to check\n', '        @return If the address is whitelisted\n', '    */\n', '    function canCall(address _caller) external view returns (bool);\n', '\n', '    /**\n', '        @notice Get all whitelisted callers\n', '        @return Array of whitelisted callers\n', '    */\n', '    function getCallers() external view returns (address[] memory);\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']