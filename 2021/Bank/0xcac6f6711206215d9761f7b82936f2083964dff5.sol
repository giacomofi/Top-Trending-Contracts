['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '//   _    _ _   _                __ _                            \n', '//  | |  (_) | | |              / _(_)                           \n', '//  | | ___| |_| |_ ___ _ __   | |_ _ _ __   __ _ _ __   ___ ___ \n', "//  | |/ / | __| __/ _ \\ '_ \\  |  _| | '_ \\ / _` | '_ \\ / __/ _ \\\n", '//  |   <| | |_| ||  __/ | | |_| | | | | | | (_| | | | | (_|  __/\n', '//  |_|\\_\\_|\\__|\\__\\___|_| |_(_)_| |_|_| |_|\\__,_|_| |_|\\___\\___|\n', '//\n', '//  Kitten.Finance Lending\n', '//\n', '//  https://Kitten.Finance\n', '//  https://kittenswap.org\n', '//\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require (c >= a, "!!add");\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require (b <= a, "!!sub");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require (b <= a, errorMessage);\n', '        uint c = a - b;\n', '        return c;\n', '    }    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require (c / a == b, "!!mul");\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require (b > 0, "!!div");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', 'interface ERC20\n', '{\n', '    function balanceOf ( address account ) external view returns ( uint256 );\n', '    function transfer ( address recipient, uint256 amount ) external returns ( bool );\n', '    function transferFrom ( address sender, address recipient, uint256 amount ) external returns ( bool );\n', '}\n', '\n', '////////////////////////////////////////////////////////////////////////////////\n', '\n', 'contract KittenLending\n', '{\n', '    using SafeMath for uint;\n', '\n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    address public govAddr;\n', '    address public treasuryAddr;\n', '    uint public treasuryAmtTotal = 0;\n', '        \n', '    constructor () public {\n', '        govAddr = msg.sender;\n', '        treasuryAddr = msg.sender;\n', '    }\n', '    \n', '    modifier govOnly() {\n', '    \trequire (msg.sender == govAddr, "!gov");\n', '    \t_;\n', '    }\n', '    \n', '    function govTransferAddr(address newAddr) external govOnly {\n', '    \trequire (newAddr != address(0), "!addr");\n', '    \tgovAddr = newAddr;\n', '    }\n', '    \n', '    function govSetTreasury(address newAddr) external govOnly\n', '    {\n', '    \trequire(newAddr != address(0), "!addr");\n', '    \ttreasuryAddr = newAddr;\n', '    }    \n', '    \n', '    uint8 public DEFAULT_devFeeBP = 0;\n', '    \n', '    function govSet_DEFAULT_devFeeBP(uint8 $DEFAULT_devFeeBP) external govOnly {\n', '    \tDEFAULT_devFeeBP = $DEFAULT_devFeeBP;\n', '    }\n', '    \n', '    function govSet_devFeeBP(uint vaultId, uint8 $devFeeBP) external govOnly {\n', '    \tVAULT[vaultId].devFeeBP = $devFeeBP;\n', '    }\n', '    \n', '    mapping (address => uint) public tokenStatus; // 0 = normal, if >= TOKEN_STATUS_BANNED then banned\n', '    uint constant TOKEN_STATUS_BANNED = 1e60;\n', '    uint8 constant VAULT_STATUS_BANNED = 200;\n', '    \n', '    function govSet_tokenStatus(address token, uint $tokenStatus) external govOnly {\n', '    \ttokenStatus[token] = $tokenStatus;\n', '    }\n', '    \n', '    function govSet_vaultStatus(uint vaultId, uint8 $vaultStatus) external govOnly {\n', '    \tVAULT[vaultId].vaultStatus = $vaultStatus;\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    struct VAULT_INFO \n', '    {\n', '        address token;              // underlying token\n', '\n', '        uint32 tEnd;                // timestamp\n', '        uint128 priceEndScaled;     // scaled by PRICE_SCALE\n', '        uint24 apyBP;               // APY%% in Basis Points\n', '        uint8 devFeeBP;             // devFee%% in Basis Points\n', '        \n', '        uint8 vaultStatus;          // 0 = new, if >= VAULT_STATUS_BANNED then banned\n', '        \n', '        mapping (address => uint) share; // deposit ETH for vaultShare\n', '        uint shareTotal;\n', '        \n', '        mapping (address => uint) tllll; // token locked\n', '        uint tllllTotal;\n', '        \n', '        uint ethTotal;\n', '    }\n', '\n', '    uint constant PRICE_SCALE = 10 ** 18;\n', '\n', '    VAULT_INFO[] public VAULT;\n', '    \n', '    event CREATE_VAULT(address indexed token, uint indexed vaultId, address indexed user, uint32 tEnd, uint128 priceEndScaled, uint24 apyBP);\n', '\n', '    function createVault(address token, uint32 tEnd, uint128 priceEndScaled, uint24 apyBP) external \n', '    {\n', '        VAULT_INFO memory m;\n', '        require (token != address(0), "!token");\n', "        require (tokenStatus[token] < TOKEN_STATUS_BANNED, '!tokenBanned');\n", '        require (tEnd > block.timestamp, "!tEnd");\n', '        require (priceEndScaled > 0, "!priceEndScaled");\n', '        require (apyBP > 0, "!apyBP");\n', '    \n', '        m.token = token;\n', '    \tm.tEnd = tEnd;\n', '    \tm.priceEndScaled = priceEndScaled;\n', '        m.apyBP = apyBP;\n', '\n', '    \tm.devFeeBP = DEFAULT_devFeeBP;\n', '    \t\n', '    \tif (msg.sender == govAddr) {\n', '    \t    m.vaultStatus = 100;\n', '    \t}\n', '    \t\n', '    \tVAULT.push(m);\n', '    \t\n', '    \temit CREATE_VAULT(token, VAULT.length - 1, msg.sender, tEnd, priceEndScaled, apyBP);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    function vaultCount() external view returns (uint)\n', '    {\n', '        return VAULT.length;\n', '    }\n', '    \n', '    function getVaultStatForUser(uint vaultId, address user) external view returns (uint share, uint tllll)\n', '    {\n', '        share = VAULT[vaultId].share[user];\n', '        tllll = VAULT[vaultId].tllll[user];\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    function getVaultValueInEth(uint vaultId) public view returns (uint)\n', '    {\n', '        VAULT_INFO memory m = VAULT[vaultId];\n', '        \n', '        uint priceNowScaled;\n', '        if (block.timestamp >= m.tEnd)\n', '            priceNowScaled = m.priceEndScaled;\n', '        else {\n', '            uint FACTOR = 10**18;\n', '            priceNowScaled = uint(m.priceEndScaled) * FACTOR / (FACTOR + FACTOR * uint(m.apyBP) * (m.tEnd - block.timestamp) / (365 days) / 10000);\n', '        }\n', '        \n', '        uint ethValue = m.ethTotal;\n', '        uint tokenValue = (m.tllllTotal).mul(priceNowScaled) / (PRICE_SCALE);\n', '        \n', '        return ethValue.add(tokenValue);\n', '    }\n', '    \n', '    function getVaultPriceScaled(uint vaultId) public view returns (uint)\n', '    {\n', '        VAULT_INFO memory m = VAULT[vaultId];\n', '        \n', '        uint priceNowScaled;\n', '        if (block.timestamp >= m.tEnd)\n', '            priceNowScaled = m.priceEndScaled;\n', '        else {\n', '            uint FACTOR = 10**18;\n', '            priceNowScaled = uint(m.priceEndScaled) * FACTOR / (FACTOR + FACTOR * uint(m.apyBP) * (m.tEnd - block.timestamp) / (365 days) / 10000);\n', '        }\n', '        \n', '        return priceNowScaled;\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    event LOCK_ETH(uint indexed vaultId, address indexed user, uint ethAmt, uint shareAmt);\n', '    event UNLOCK_ETH(uint indexed vaultId, address indexed user, uint ethAmt, uint shareAmt);\n', '    \n', '    function _mintShare(VAULT_INFO storage m, address user, uint mintAmt) internal {\n', '        m.share[user] = (m.share[user]).add(mintAmt);\n', '        m.shareTotal = (m.shareTotal).add(mintAmt);        \n', '    }\n', '    function _burnShare(VAULT_INFO storage m, address user, uint burnAmt) internal {\n', "        m.share[user] = (m.share[user]).sub(burnAmt, '!notEnoughShare');\n", "        m.shareTotal = (m.shareTotal).sub(burnAmt, '!notEnoughShare');        \n", '    }\n', '    \n', '    function _mintTllll(VAULT_INFO storage m, address user, uint mintAmt) internal {\n', '        m.tllll[user] = (m.tllll[user]).add(mintAmt);\n', '        m.tllllTotal = (m.tllllTotal).add(mintAmt);        \n', '    }\n', '    function _burnTllll(VAULT_INFO storage m, address user, uint burnAmt) internal {\n', "        m.tllll[user] = (m.tllll[user]).sub(burnAmt, '!notEnoughTokenLocked');\n", "        m.tllllTotal = (m.tllllTotal).sub(burnAmt, '!notEnoughTokenLocked');        \n", '    }\n', '    \n', '    function _sendEth(VAULT_INFO storage m, address payable user, uint outAmt) internal {\n', "        m.ethTotal = (m.ethTotal).sub(outAmt, '!notEnoughEthInVault');\n", '        user.transfer(outAmt);\n', '    }\n', '\n', '    function lockEth(uint vaultId) external payable // lock ETH for lending, and mint vaultShare\n', '    {\n', '        VAULT_INFO storage m = VAULT[vaultId];\n', "    \trequire (block.timestamp < m.tEnd, '!vaultEnded');\n", '\n', '        //-------- receive ETH from user --------\n', '        address user = msg.sender;\n', '        uint ethInAmt = msg.value;\n', "        require (ethInAmt > 0, '!ethInAmt');\n", '        \n', '        //-------- compute vaultShare mint amt --------\n', '        uint shareMintAmt = 0;\n', '        if (m.shareTotal == 0) { \n', '            shareMintAmt = ethInAmt; // initial price: 1 share = 1 ETH\n', '        }\n', '        else {                \n', '            shareMintAmt = ethInAmt.mul(m.shareTotal).div(getVaultValueInEth(vaultId));\n', '        }\n', '\n', '        m.ethTotal = (m.ethTotal).add(ethInAmt); // add ETH after computing shareMintAmt\n', '        \n', '        //-------- mint vaultShare to user --------\n', '        _mintShare(m, user, shareMintAmt);\n', '        \n', '        emit LOCK_ETH(vaultId, user, ethInAmt, shareMintAmt);\n', '    }\n', '    \n', '    function unlockEth(uint vaultId, uint shareBurnAmt) external // unlock ETH, and burn vaultShare\n', '    {\n', '        VAULT_INFO storage m = VAULT[vaultId];\n', "    \trequire (block.timestamp < m.tEnd, '!vaultEnded');        \n", '\n', "        require (shareBurnAmt > 0, '!shareBurnAmt');\n", '        address payable user = msg.sender;\n', '        \n', '        //-------- compute ETH out amt --------\n', '        uint ethOutAmt = shareBurnAmt.mul(getVaultValueInEth(vaultId)).div(m.shareTotal);\n', '\n', '        //-------- burn vaultShare from user --------\n', '        _burnShare(m, user, shareBurnAmt);\n', '\n', '        //-------- send ETH to user --------\n', '        _sendEth(m, user, ethOutAmt);\n', '        emit UNLOCK_ETH(vaultId, user, ethOutAmt, shareBurnAmt);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    event LOCK_TOKEN(uint indexed vaultId, address indexed user, uint tokenAmt, uint ethAmt);\n', '    event UNLOCK_TOKEN(uint indexed vaultId, address indexed user, uint tokenAmt, uint ethAmt); \n', '    \n', '    function lockToken(uint vaultId, uint tokenInAmt) external // lock TOKEN to borrow ETH\n', '    {\n', '        VAULT_INFO storage m = VAULT[vaultId];\n', "    \trequire (block.timestamp < m.tEnd, '!vaultEnded');        \n", '\n', "    \trequire (m.vaultStatus < VAULT_STATUS_BANNED, '!vaultBanned');\n", "    \trequire (tokenStatus[m.token] < TOKEN_STATUS_BANNED, '!tokenBanned');\n", '\n', "        require (tokenInAmt > 0, '!tokenInAmt');\n", '        address payable user = msg.sender;\n', '        \n', '        //-------- compute ETH out amt --------\n', '        uint ethOutAmt = tokenInAmt.mul(getVaultPriceScaled(vaultId)) / (PRICE_SCALE);\n', '        \n', '        if (m.devFeeBP > 0) \n', '        {\n', '            uint treasuryAmt = ethOutAmt.mul(uint(m.devFeeBP)) / (10000);\n', '            treasuryAmtTotal = treasuryAmtTotal.add(treasuryAmt);\n', '            \n', '            ethOutAmt = ethOutAmt.sub(treasuryAmt);\n', "            m.ethTotal = (m.ethTotal).sub(treasuryAmt, '!ethInVault'); // remove treasuryAmt\n", '        }\n', '\n', '        //--------  send TOKEN to contract --------\n', '        ERC20(m.token).transferFrom(user, address(this), tokenInAmt);\n', '        _mintTllll(m, user, tokenInAmt);\n', '\n', '        //-------- send ETH to user --------\n', '        _sendEth(m, user, ethOutAmt);\n', '        emit LOCK_TOKEN(vaultId, user, tokenInAmt, ethOutAmt);\n', '    }\n', '    \n', '    function unlockToken(uint vaultId) external payable // payback ETH to unlock TOKEN\n', '    {\n', '        VAULT_INFO storage m = VAULT[vaultId];\n', "    \trequire (block.timestamp < m.tEnd, '!vaultEnded');         \n", '\n', '        //-------- receive ETH from user --------\n', '        uint ethInAmt = msg.value;\n', "        require (ethInAmt > 0, '!ethInAmt');\n", '        \n', '        uint ethReturnAmt = 0;\n', '        address payable user = msg.sender;\n', '        \n', '        //-------- compute LIQUID out amt --------\n', '        uint priceScaled = getVaultPriceScaled(vaultId);\n', '\n', '        uint tokenOutAmt = ethInAmt.mul(PRICE_SCALE).div(priceScaled);\n', '        if (tokenOutAmt > m.tllll[user])\n', '        {\n', '            tokenOutAmt = m.tllll[user];\n', '            ethReturnAmt = ethInAmt.sub(\n', '                    tokenOutAmt.mul(priceScaled) / (PRICE_SCALE)\n', '                );\n', '        }\n', '        \n', '        //-------- send TOKEN to user --------\n', '        _burnTllll(m, user, tokenOutAmt);\n', '        ERC20(m.token).transfer(user, tokenOutAmt);\n', '        \n', '        //-------- return extra ETH to user --------\n', '        m.ethTotal = (m.ethTotal).add(ethInAmt); // add input ETH first\n', '        if (ethReturnAmt > 0)\n', '            _sendEth(m, user, ethReturnAmt);\n', '        emit UNLOCK_TOKEN(vaultId, user, tokenOutAmt, ethInAmt.sub(ethReturnAmt));\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '    \n', '    event EXIT_SHARE(uint indexed vaultId, address indexed user, uint shareAmt);\n', '    \n', '    function exitShare(uint vaultId, address payable user) external // exit vaultShare after vault is closed\n', '    {\n', '        VAULT_INFO storage m = VAULT[vaultId];\n', "    \trequire (block.timestamp > m.tEnd, '!vaultStillOpen');\n", '\n', '    \t//-------- compute ETH & TOKEN out amt --------\n', '    \tuint userShareAmt = m.share[user];\n', "    \trequire (userShareAmt > 0, '!userShareAmt');\n", '\n', '    \tuint ethOutAmt = (m.ethTotal).mul(userShareAmt).div(m.shareTotal);\n', '    \tuint tokenOutAmt = (m.tllllTotal).mul(userShareAmt).div(m.shareTotal);\n', '\n', '        //-------- burn vaultShare from user --------\n', '        _burnShare(m, user, userShareAmt);\n', '\n', '        //-------- send ETH & TOKEN to user --------\n', '        if (tokenOutAmt > 0) {\n', '            m.tllllTotal = (m.tllllTotal).sub(tokenOutAmt); // remove tllll\n', '            ERC20(m.token).transfer(user, tokenOutAmt);\n', '        }\n', '        if (ethOutAmt > 0)\n', '            _sendEth(m, user, ethOutAmt);\n', '        \n', '        emit EXIT_SHARE(vaultId, user, userShareAmt);\n', '    }\n', '    \n', '    ////////////////////////////////////////////////////////////////////////////////\n', '\n', '    function treasurySend(uint amt) external\n', '    {\n', '        treasuryAmtTotal = treasuryAmtTotal.sub(amt);\n', '        \n', '        address payable _treasuryAddr = address(uint160(treasuryAddr));\n', '        _treasuryAddr.transfer(amt);\n', '    }    \n', '}']