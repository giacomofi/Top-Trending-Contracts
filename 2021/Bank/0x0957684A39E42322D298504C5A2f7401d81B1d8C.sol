['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-02\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity >=0.6.12;\n', '\n', '////// src/UniswapV2Callee.sol\n', '// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published\n', '// by the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity >=0.6.12; */\n', '\n', 'interface VatLike_7 {\n', '    function hope(address) external;\n', '}\n', '\n', 'interface GemJoinLike_2 {\n', '    function dec() external view returns (uint256);\n', '    function gem() external view returns (TokenLike_2);\n', '    function exit(address, uint256) external;\n', '}\n', '\n', 'interface DaiJoinLike_2 {\n', '    function dai() external view returns (TokenLike_2);\n', '    function vat() external view returns (VatLike_7);\n', '    function join(address, uint256) external;\n', '}\n', '\n', 'interface TokenLike_2 {\n', '    function approve(address, uint256) external;\n', '    function transfer(address, uint256) external;\n', '    function balanceOf(address) external view returns (uint256);\n', '    function token0() external view returns (TokenLike_2);\n', '    function token1() external view returns (TokenLike_2);\n', '}\n', '\n', 'interface UniswapV2Router02Like {\n', '    function swapExactTokensForTokens(uint256, uint256, address[] calldata, address, uint256) external returns (uint[] memory);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '}\n', '\n', '// Simple Callee Example to interact with MatchingMarket\n', '// This Callee contract exists as a standalone contract\n', 'contract UniswapV2Callee {\n', '    UniswapV2Router02Like   public uniRouter02;\n', '    DaiJoinLike_2             public daiJoin;\n', '    TokenLike_2               public dai;\n', '\n', '    uint256                 public constant RAY = 10 ** 27;\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = add(x, sub(y, 1)) / y;\n', '    }\n', '\n', '    function setUp(address uniRouter02_, address daiJoin_) internal {\n', '        uniRouter02 = UniswapV2Router02Like(uniRouter02_);\n', '        daiJoin = DaiJoinLike_2(daiJoin_);\n', '        dai = daiJoin.dai();\n', '\n', '        dai.approve(daiJoin_, uint256(-1));\n', '    }\n', '\n', '    function _fromWad(address gemJoin, uint256 wad) internal view returns (uint256 amt) {\n', '        amt = wad / 10 ** (sub(18, GemJoinLike_2(gemJoin).dec()));\n', '    }\n', '}\n', '\n', '// Uniswapv2Router02 route directs swaps from one pool to another\n', 'contract UniswapV2CalleeDai is UniswapV2Callee {\n', '    constructor(address uniRouter02_, address daiJoin_) public {\n', '        setUp(uniRouter02_, daiJoin_);\n', '    }\n', '\n', '    function swapGemForDai(\n', '        TokenLike_2 token,\n', '        address[] memory path,\n', '        address to\n', '    ) internal {\n', '        uint256 amountIn = token.balanceOf(address(this));\n', '        token.approve(address(uniRouter02), amountIn);\n', '        uniRouter02.swapExactTokensForTokens(\n', '            amountIn,\n', '            0, // amountOutMin is zero because minProfit is checked at the end\n', '            path,\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '        if (token.balanceOf(address(this)) > 0) {\n', '            token.transfer(to, token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    function clipperCall(\n', '        address sender,         // Clipper Caller and Dai deliveryaddress\n', '        uint256 daiAmt,         // Dai amount to payback[rad]\n', '        uint256 gemAmt,         // Gem amount received [wad]\n', '        bytes calldata data     // Extra data needed (gemJoin)\n', '    ) external {\n', '        (\n', '            address to,           // address to send remaining DAI to\n', '            address gemJoin,      // gemJoin adapter address\n', '            uint256 minProfit,    // minimum profit in DAI to make [wad]\n', '            address[] memory pathA, // Uniswap pool path\n', '            address[] memory pathB  // path of token B (LP tokens only)\n', '        ) = abi.decode(data, (address, address, uint256, address[], address[]));\n', '\n', '        // Convert gem amount to token precision\n', '        gemAmt = _fromWad(gemJoin, gemAmt);\n', '\n', '        // Exit collateral to token version\n', '        GemJoinLike_2(gemJoin).exit(address(this), gemAmt);\n', '\n', '        // Approve uniRouter02 to take gem\n', '        TokenLike_2 gem = GemJoinLike_2(gemJoin).gem();\n', '        gem.approve(address(uniRouter02), gemAmt);\n', '\n', '        // Calculate amount of DAI to Join (as erc20 WAD value)\n', '        uint256 daiToJoin = divup(daiAmt, RAY);\n', '\n', '        // Do operation and get dai amount bought (checking the profit is achieved)\n', '        try gem.token0() returns (TokenLike_2 tokenA) { // gem is an LP token\n', '            TokenLike_2 tokenB = gem.token1();\n', '            uniRouter02.removeLiquidity({ // burn token to obtain its components\n', '                tokenA: address(tokenA),\n', '                tokenB: address(tokenB),\n', '                liquidity: gemAmt,\n', '                amountAMin: 0, // minProfit is checked below\n', '                amountBMin: 0,\n', '                to: address(this),\n', '                deadline: block.timestamp\n', '            });\n', '            if (address(tokenA) != address(dai)) {\n', '                swapGemForDai(tokenA, pathA, to);\n', '            }\n', '            if (address(tokenB) != address(dai)) {\n', '                swapGemForDai(tokenB, pathB, to);\n', '            }\n', '            require(\n', '                dai.balanceOf(address(this)) >= add(daiToJoin, minProfit),\n', '                "UniswapV2Callee/insufficient-profit"\n', '            );\n', '        } catch {                                     // gem is not an LP token\n', '            uniRouter02.swapExactTokensForTokens(\n', '                gemAmt,\n', '                add(daiToJoin, minProfit),\n', '                pathA,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        // Although Uniswap will accept all gems, this check is a sanity check, just in case\n', '        // Transfer any lingering gem to specified address\n', '        if (gem.balanceOf(address(this)) > 0) {\n', '            gem.transfer(to, gem.balanceOf(address(this)));\n', '        }\n', '\n', '        // Convert DAI bought to internal vat value of the msg.sender of Clipper.take\n', '        daiJoin.join(sender, daiToJoin);\n', '\n', '        // Transfer remaining DAI to specified address\n', '        dai.transfer(to, dai.balanceOf(address(this)));\n', '    }\n', '}']