['// SPDX-License-Identifier: MIT\n', '\n', '// Version: 0.1.0, 1/20/2021\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "./IPToken.sol";\n', 'import "./ILToken.sol";\n', 'import "./IOracle.sol";\n', 'import "./ILiquidatorQualifier.sol";\n', 'import "./IMigratablePool.sol";\n', 'import "./IPreMiningPool.sol";\n', 'import "./IPerpetualPool.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./MixedSafeMathWithUnit.sol";\n', 'import "./MigratablePool.sol";\n', '\n', '/**\n', ' * @title Deri Protocol PerpetualPool Implementation\n', ' */\n', 'contract PerpetualPool is IMigratablePool, IPerpetualPool, MigratablePool {\n', '\n', '    using MixedSafeMathWithUnit for uint256;\n', '    using MixedSafeMathWithUnit for int256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Trading symbol\n', '    string private _symbol;\n', '\n', '    // Last price\n', '    uint256 private _price;\n', '    // Last price timestamp\n', '    uint256 private _lastPriceTimestamp;\n', '    // Last price block number\n', '    uint256 private _lastPriceBlockNumber;\n', '\n', '    // Base token contract, all settlements are done in base token\n', '    IERC20  private _bToken;\n', '    // Base token decimals\n', '    uint256 private _bDecimals;\n', '    // Position token contract\n', '    IPToken private _pToken;\n', '    // Liquidity provider token contract\n', '    ILToken private _lToken;\n', '    // For on-chain oracle, it is a contract and must have getPrice() method to fetch current price\n', '    // For off-chain signed price oracle, it is an EOA\n', '    // and its address is used to verify price signature\n', '    IOracle private _oracle;\n', '    // Is on-chain oracle, or off-chain oracle with signed price\n', '    bool private _isContractOracle;\n', '    // LiquidatorQualifier contract to check if an address can call liquidate function\n', '    // If this address is 0, means no liquidator qualification check, anyone can call liquidate\n', '    ILiquidatorQualifier private _liquidatorQualifier;\n', '\n', '    // Contract multiplier\n', '    uint256 private _multiplier;\n', '    // Trading fee ratio\n', '    uint256 private _feeRatio;\n', '    // Minimum pool margin ratio\n', '    uint256 private _minPoolMarginRatio;\n', '    // Minimum initial margin ratio for trader\n', '    uint256 private _minInitialMarginRatio;\n', '    // Minimum maintenance margin ratio for trader\n', '    uint256 private _minMaintenanceMarginRatio;\n', '    // Minimum amount requirement when add liquidity\n', '    uint256 private _minAddLiquidity;\n', '    // Redemption fee ratio when removing liquidity\n', '    uint256 private _redemptionFeeRatio;\n', '    // Funding rate coefficient\n', '    uint256 private _fundingRateCoefficient;\n', '    // Minimum liquidation reward\n', '    uint256 private _minLiquidationReward;\n', '    // Maximum liquidation reward\n', '    uint256 private _maxLiquidationReward;\n', '    // Cutting ratio for liquidator\n', '    uint256 private _liquidationCutRatio;\n', '    // Price delay allowance in seconds\n', '    uint256 private _priceDelayAllowance;\n', '\n', '    // Recorded cumulative funding rate, overflow of this value is intended\n', '    int256  private _cumuFundingRate;\n', '    // Last block number when cumulative funding rate was recorded\n', '    uint256 private _cumuFundingRateBlock;\n', '    // Total liquidity pool holds\n', '    uint256 private _liquidity;\n', '    // Total net volume of all traders in the pool\n', '    int256  private _tradersNetVolume;\n', '    // Total cost of current traders net volume\n', '    // The cost for a long position is positive, and short position is negative\n', '    int256  private _tradersNetCost;\n', '\n', '    bool private _mutex;\n', '    // Locker to prevent reentry\n', '    modifier _lock_() {\n', '        require(!_mutex, "PerpetualPool: reentry");\n', '        _mutex = true;\n', '        _;\n', '        _mutex = false;\n', '    }\n', '\n', '    /**\n', '     * @dev A dummy constructor, which deos not initialize any storage variables\n', '     * A template will be deployed with no initialization and real pool will be cloned\n', '     * from this template (same as create_forwarder_to mechanism in Vyper),\n', '     * and use `initialize` to initialize all storage variables\n', '     */\n', '    constructor () {}\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{initialize}\n', '     */\n', '    function initialize(\n', '        string memory symbol_,\n', '        address[5] calldata addresses_,\n', '        uint256[12] calldata parameters_\n', '    ) public override {\n', '        require(bytes(_symbol).length == 0 && _controller == address(0), "PerpetualPool: already initialized");\n', '\n', '        _controller = msg.sender;\n', '        _symbol = symbol_;\n', '\n', '        _bToken = IERC20(addresses_[0]);\n', '        _bDecimals = _bToken.decimals();\n', '        _pToken = IPToken(addresses_[1]);\n', '        _lToken = ILToken(addresses_[2]);\n', '        _oracle = IOracle(addresses_[3]);\n', '        _isContractOracle = _isContract(address(_oracle));\n', '        _liquidatorQualifier = ILiquidatorQualifier(addresses_[4]);\n', '\n', '        _multiplier = parameters_[0];\n', '        _feeRatio = parameters_[1];\n', '        _minPoolMarginRatio = parameters_[2];\n', '        _minInitialMarginRatio = parameters_[3];\n', '        _minMaintenanceMarginRatio = parameters_[4];\n', '        _minAddLiquidity = parameters_[5];\n', '        _redemptionFeeRatio = parameters_[6];\n', '        _fundingRateCoefficient = parameters_[7];\n', '        _minLiquidationReward = parameters_[8];\n', '        _maxLiquidationReward = parameters_[9];\n', '        _liquidationCutRatio = parameters_[10];\n', '        _priceDelayAllowance = parameters_[11];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IMigratablePool}.{approveMigration}\n', '     */\n', '    function approveMigration() public override _controller_ {\n', '        require(_migrationTimestamp != 0 && block.timestamp >= _migrationTimestamp, "PerpetualPool: migrationTimestamp not met yet");\n', '        // approve new pool to pull all base tokens from this pool\n', '        _bToken.safeApprove(_migrationDestination, uint256(-1));\n', '        // set pToken/lToken to new pool, after redirecting pToken/lToken to new pool, this pool will stop functioning\n', '        _pToken.setPool(_migrationDestination);\n', '        _lToken.setPool(_migrationDestination);\n', '    }\n', '\n', '    function setParameters(\n', '        uint256 feeRatio,\n', '        uint256 minPoolMarginRatio,\n', '        uint256 minInitialMarginRatio,\n', '        uint256 minMaintenanceMarginRatio,\n', '        uint256 minAddLiquidity,\n', '        uint256 redemptionFeeRatio,\n', '        uint256 fundingRateCoefficient,\n', '        uint256 minLiquidationReward,\n', '        uint256 maxLiquidationReward,\n', '        uint256 liquidationCutRatio,\n', '        uint256 priceDelayAllowance,\n', '        address oracleAddress,\n', '        address liquidatorQualifierAddress\n', '    ) public _controller_ {\n', '        _feeRatio = feeRatio;\n', '        _minPoolMarginRatio = minPoolMarginRatio;\n', '        _minInitialMarginRatio = minInitialMarginRatio;\n', '        _minMaintenanceMarginRatio = minMaintenanceMarginRatio;\n', '        _minAddLiquidity = minAddLiquidity;\n', '        _redemptionFeeRatio = redemptionFeeRatio;\n', '        _fundingRateCoefficient = fundingRateCoefficient;\n', '        _minLiquidationReward = minLiquidationReward;\n', '        _maxLiquidationReward = maxLiquidationReward;\n', '        _liquidationCutRatio = liquidationCutRatio;\n', '        _priceDelayAllowance = priceDelayAllowance;\n', '\n', '        _oracle = IOracle(oracleAddress);\n', '        _isContractOracle = _isContract(oracleAddress);\n', '        _liquidatorQualifier = ILiquidatorQualifier(liquidatorQualifierAddress);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IMigratablePool}.{executeMigration}\n', '     */\n', '    function executeMigration(address source) public override _controller_ {\n', '        uint256 migrationTimestamp_ = IPerpetualPool(source).migrationTimestamp();\n', '        address migrationDestination_ = IPerpetualPool(source).migrationDestination();\n', '        require(migrationTimestamp_ != 0 && block.timestamp >= migrationTimestamp_, "PerpetualPool: migrationTimestamp not met yet");\n', '        require(migrationDestination_ == address(this), "PerpetualPool: executeMigration to not destination pool");\n', '\n', '        // migrate base token\n', '        _bToken.safeTransferFrom(source, address(this), _bToken.balanceOf(source));\n', '\n', '        // migrate state values from PerpetualPool\n', '        (int256 cumuFundingRate, uint256 cumuFundingRateBlock, uint256 liquidity, int256 tradersNetVolume, int256 tradersNetCost) = IPerpetualPool(source).getStateValues();\n', '        _cumuFundingRate = cumuFundingRate;\n', '        _cumuFundingRateBlock = cumuFundingRateBlock;\n', '        _liquidity = liquidity;\n', '        _tradersNetVolume = tradersNetVolume;\n', '        _tradersNetCost = tradersNetCost;\n', '\n', '        // // migrate state values from PreMiningPool\n', '        // _liquidity = IPreMiningPool(source).getStateValues();\n', '\n', '        emit ExecuteMigration(migrationTimestamp_, source, address(this));\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{symbol}\n', '     */\n', '    function symbol() public view override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{getAddresses}\n', '     */\n', '    function getAddresses() public view override returns (\n', '        address bToken,\n', '        address pToken,\n', '        address lToken,\n', '        address oracle,\n', '        address liquidatorQualifier\n', '    ) {\n', '        return (\n', '            address(_bToken),\n', '            address(_pToken),\n', '            address(_lToken),\n', '            address(_oracle),\n', '            address(_liquidatorQualifier)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{getParameters}\n', '     */\n', '    function getParameters() public view override returns (\n', '        uint256 multiplier,\n', '        uint256 feeRatio,\n', '        uint256 minPoolMarginRatio,\n', '        uint256 minInitialMarginRatio,\n', '        uint256 minMaintenanceMarginRatio,\n', '        uint256 minAddLiquidity,\n', '        uint256 redemptionFeeRatio,\n', '        uint256 fundingRateCoefficient,\n', '        uint256 minLiquidationReward,\n', '        uint256 maxLiquidationReward,\n', '        uint256 liquidationCutRatio,\n', '        uint256 priceDelayAllowance\n', '    ) {\n', '        return (\n', '            _multiplier,\n', '            _feeRatio,\n', '            _minPoolMarginRatio,\n', '            _minInitialMarginRatio,\n', '            _minMaintenanceMarginRatio,\n', '            _minAddLiquidity,\n', '            _redemptionFeeRatio,\n', '            _fundingRateCoefficient,\n', '            _minLiquidationReward,\n', '            _maxLiquidationReward,\n', '            _liquidationCutRatio,\n', '            _priceDelayAllowance\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{getStateValues}\n', '     */\n', '    function getStateValues() public view override returns (\n', '        int256 cumuFundingRate,\n', '        uint256 cumuFundingRateBlock,\n', '        uint256 liquidity,\n', '        int256 tradersNetVolume,\n', '        int256 tradersNetCost\n', '    ) {\n', '        return (\n', '            _cumuFundingRate,\n', '            _cumuFundingRateBlock,\n', '            _liquidity,\n', '            _tradersNetVolume,\n', '            _tradersNetCost\n', '        );\n', '    }\n', '\n', '\n', '    //================================================================================\n', '    // Pool interactions\n', '    //================================================================================\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{tradeWithMargin}\n', '     */\n', '    function tradeWithMargin(int256 tradeVolume, uint256 bAmount) public override {\n', '        _updatePriceFromOracle();\n', '        _tradeWithMargin(tradeVolume, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{tradeWithMargin}\n', '     */\n', '    function tradeWithMargin(\n', '        int256 tradeVolume,\n', '        uint256 bAmount,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _tradeWithMargin(tradeVolume, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{trade}\n', '     */\n', '    function trade(int256 tradeVolume) public override {\n', '        _updatePriceFromOracle();\n', '        _trade(tradeVolume);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{trade}\n', '     */\n', '    function trade(\n', '        int256 tradeVolume,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _trade(tradeVolume);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{depositMargin}\n', '     */\n', '    function depositMargin(uint256 bAmount) public override {\n', '        _updatePriceFromOracle();\n', '        _depositMargin(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{depositMargin}\n', '     */\n', '    function depositMargin(\n', '        uint256 bAmount,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _depositMargin(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{withdrawMargin}\n', '     */\n', '    function withdrawMargin(uint256 bAmount) public override {\n', '        _updatePriceFromOracle();\n', '        _withdrawMargin(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{withdrawMargin}\n', '     */\n', '    function withdrawMargin(\n', '        uint256 bAmount,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _withdrawMargin(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{addLiquidity}\n', '     */\n', '    function addLiquidity(uint256 bAmount) public override {\n', '        _updatePriceFromOracle();\n', '        _addLiquidity(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{addLiquidity}\n', '     */\n', '    function addLiquidity(\n', '        uint256 bAmount,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _addLiquidity(bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{removeLiquidity}\n', '     */\n', '    function removeLiquidity(uint256 lShares) public override {\n', '        _updatePriceFromOracle();\n', '        _removeLiquidity(lShares);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{removeLiquidity}\n', '     */\n', '    function removeLiquidity(\n', '        uint256 lShares,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        _updatePriceWithSignature(timestamp, price, v, r, s);\n', '        _removeLiquidity(lShares);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{liquidate}\n', '     */\n', '    function liquidate(address owner) public override {\n', '        require(\n', '            address(_liquidatorQualifier) == address(0) || _liquidatorQualifier.isQualifiedLiquidator(msg.sender),\n', '            "PerpetualPool: not quanlified liquidator"\n', '        );\n', '        _updatePriceFromOracle();\n', '        _liquidate(owner, block.timestamp, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPerpetualPool}.{liquidate}\n', '     *\n', "     * A price signature with timestamp after position's lastUpdateTimestamp\n", '     * will be a valid liquidation price\n', '     */\n', '    function liquidate(\n', '        address owner,\n', '        uint256 timestamp,\n', '        uint256 price,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override {\n', '        require(\n', '            address(_liquidatorQualifier) == address(0) || _liquidatorQualifier.isQualifiedLiquidator(msg.sender),\n', '            "PerpetualPool: not quanlified liquidator"\n', '        );\n', '        _checkPriceSignature(timestamp, price, v, r, s);\n', '        _liquidate(owner, timestamp, price);\n', '    }\n', '\n', '\n', '    //================================================================================\n', '    // Pool critic logics\n', '    //================================================================================\n', '\n', '    /**\n', '     * @dev Low level tradeWithMargin implementation\n', '     * _lock_ is not need in this function, as sub-functions will apply _lock_\n', '     */\n', '    function _tradeWithMargin(int256 tradeVolume, uint256 bAmount) internal {\n', '        if (bAmount == 0) {\n', '            _trade(tradeVolume);\n', '        } else if (tradeVolume == 0) {\n', '            _depositMargin(bAmount);\n', '        } else {\n', '            _depositMargin(bAmount);\n', '            _trade(tradeVolume);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Low level trade implementation\n', '     */\n', '    function _trade(int256 tradeVolume) internal _lock_ {\n', '        require(tradeVolume != 0, "PerpetualPool: trade with 0 volume");\n', '        require(tradeVolume.reformat(0) == tradeVolume, "PerpetualPool: trade volume must be int");\n', '\n', "        // get trader's position, trader must have a position token to call this function\n", '        (int256 volume, int256 cost, int256 lastCumuFundingRate, uint256 margin,) = _pToken.getPosition(msg.sender);\n', '\n', '        // update cumulative funding rate\n', '        _updateCumuFundingRate(_price);\n', '\n', "        // calculate trader's funding fee\n", '        int256 funding = volume.mul(_cumuFundingRate - lastCumuFundingRate);\n', '\n', '        // calculate trading fee for this transaction\n', '        int256 curCost = tradeVolume.mul(_price).mul(_multiplier);\n', '        uint256 fee = _feeRatio.mul(curCost.abs());\n', '\n', '        // calculate realized cost\n', '        int256 realizedCost = 0;\n', '        if ((volume >= 0 && tradeVolume >= 0) || (volume <= 0 && tradeVolume <= 0)) {\n', '            // open in same direction, no realized cost\n', '        } else if (volume.abs() <= tradeVolume.abs()) {\n', '            // previous position is flipped\n', '            realizedCost = curCost.mul(volume.abs()).div(tradeVolume.abs()).add(cost);\n', '        } else {\n', '            // previous position is partially closed\n', '            realizedCost = cost.mul(tradeVolume.abs()).div(volume.abs()).add(curCost);\n', '        }\n', '\n', '        // total paid in this transaction, could be negative if there is realized pnl\n', '        // this paid amount should be a valid value in base token decimals representation\n', '        int256 paid = funding.add(fee).add(realizedCost).reformat(_bDecimals);\n', '\n', '        // settlements\n', '        volume = volume.add(tradeVolume);\n', '        cost = cost.add(curCost).sub(realizedCost);\n', '        margin = margin.sub(paid);\n', '        _tradersNetVolume = _tradersNetVolume.add(tradeVolume);\n', '        _tradersNetCost = _tradersNetCost.add(curCost).sub(realizedCost);\n', '        _liquidity = _liquidity.add(paid);\n', '        lastCumuFundingRate = _cumuFundingRate;\n', '\n', '        // check margin requirements\n', '        require(volume == 0 || _calculateMarginRatio(volume, cost, _price, margin) >= _minInitialMarginRatio,\n', '                "PerpetualPool: trader insufficient margin");\n', '        require(_tradersNetVolume == 0 || _calculateMarginRatio(_tradersNetVolume.neg(), _tradersNetCost.neg(), _price, _liquidity) >= _minPoolMarginRatio,\n', '                "PerpetualPool: pool insufficient liquidity");\n', '\n', '        _pToken.update(msg.sender, volume, cost, lastCumuFundingRate, margin, block.timestamp);\n', '        emit Trade(msg.sender, tradeVolume, _price);\n', '    }\n', '\n', '    /**\n', '     * @dev Low level depositMargin implementation\n', '     */\n', '    function _depositMargin(uint256 bAmount) internal _lock_ {\n', '        require(bAmount != 0, "PerpetualPool: deposit zero margin");\n', '        require(bAmount.reformat(_bDecimals) == bAmount, "PerpetualPool: _depositMargin bAmount not valid");\n', '\n', '        bAmount = _deflationCompatibleSafeTransferFrom(msg.sender, address(this), bAmount);\n', '        if (!_pToken.exists(msg.sender)) {\n', '            _pToken.mint(msg.sender, bAmount);\n', '        } else {\n', '            (int256 volume, int256 cost, int256 lastCumuFundingRate, uint256 margin,) = _pToken.getPosition(msg.sender);\n', '            margin = margin.add(bAmount);\n', '            _pToken.update(msg.sender, volume, cost, lastCumuFundingRate, margin, block.timestamp);\n', '        }\n', '        emit DepositMargin(msg.sender, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Low level withdrawMargin implementation\n', '     */\n', '    function _withdrawMargin(uint256 bAmount) internal _lock_ {\n', '        require(bAmount != 0, "PerpetualPool: withdraw zero margin");\n', '        require(bAmount.reformat(_bDecimals) == bAmount, "PerpetualPool: _withdrawMargin bAmount not valid");\n', '\n', '        (int256 volume, int256 cost, int256 lastCumuFundingRate, uint256 margin,) = _pToken.getPosition(msg.sender);\n', '        _updateCumuFundingRate(_price);\n', '\n', '        int256 funding = volume.mul(_cumuFundingRate - lastCumuFundingRate).reformat(_bDecimals);\n', '        margin = margin.sub(funding).sub(bAmount);\n', '        _liquidity = _liquidity.add(funding);\n', '        lastCumuFundingRate = _cumuFundingRate;\n', '\n', '        require(volume == 0 || _calculateMarginRatio(volume, cost, _price, margin) >= _minInitialMarginRatio,\n', '                "PerpetualPool: withdraw cause insufficient margin");\n', '\n', '        _pToken.update(msg.sender, volume, cost, lastCumuFundingRate, margin, block.timestamp);\n', '        _bToken.safeTransfer(msg.sender, bAmount.rescale(_bDecimals));\n', '        emit WithdrawMargin(msg.sender, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Low level addLiquidity implementation\n', '     */\n', '    function _addLiquidity(uint256 bAmount) internal _lock_ {\n', '        require(bAmount >= _minAddLiquidity, "PerpetualPool: add liquidity less than minimum requirement");\n', '        require(bAmount.reformat(_bDecimals) == bAmount, "PerpetualPool: _addLiquidity bAmount not valid");\n', '\n', '        _updateCumuFundingRate(_price);\n', '\n', '        bAmount = _deflationCompatibleSafeTransferFrom(msg.sender, address(this), bAmount);\n', '\n', '        uint256 poolDynamicEquity = _liquidity.add(_tradersNetCost.sub(_tradersNetVolume.mul(_price).mul(_multiplier)));\n', '        uint256 totalSupply = _lToken.totalSupply();\n', '        uint256 lShares;\n', '        if (totalSupply == 0) {\n', '            lShares = bAmount;\n', '        } else {\n', '            lShares = bAmount.mul(totalSupply).div(poolDynamicEquity);\n', '        }\n', '\n', '        _lToken.mint(msg.sender, lShares);\n', '        _liquidity = _liquidity.add(bAmount);\n', '\n', '        emit AddLiquidity(msg.sender, lShares, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Low level removeLiquidity implementation\n', '     */\n', '    function _removeLiquidity(uint256 lShares) internal _lock_ {\n', '        require(lShares > 0, "PerpetualPool: remove 0 liquidity");\n', '        uint256 balance = _lToken.balanceOf(msg.sender);\n', '        require(lShares == balance || balance.sub(lShares) >= 10**18, "PerpetualPool: remaining liquidity shares must be 0 or at least 1");\n', '\n', '        _updateCumuFundingRate(_price);\n', '\n', '        uint256 poolDynamicEquity = _liquidity.add(_tradersNetCost.sub(_tradersNetVolume.mul(_price).mul(_multiplier)));\n', '        uint256 totalSupply = _lToken.totalSupply();\n', '        uint256 bAmount = lShares.mul(poolDynamicEquity).div(totalSupply);\n', '        if (lShares < totalSupply) {\n', '            bAmount = bAmount.sub(bAmount.mul(_redemptionFeeRatio));\n', '        }\n', '        bAmount = bAmount.reformat(_bDecimals);\n', '\n', '        _liquidity = _liquidity.sub(bAmount);\n', '        require(_tradersNetVolume == 0 || _calculateMarginRatio(_tradersNetVolume.neg(), _tradersNetCost.neg(), _price, _liquidity) >= _minPoolMarginRatio,\n', '                "PerpetualPool: remove liquidity cause pool insufficient liquidity");\n', '\n', '        _lToken.burn(msg.sender, lShares);\n', '        _bToken.safeTransfer(msg.sender, bAmount.rescale(_bDecimals));\n', '\n', '        emit RemoveLiquidity(msg.sender, lShares, bAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Low level liquidate implementation\n', '     */\n', '    function _liquidate(address owner, uint256 timestamp, uint256 price) internal _lock_ {\n', '        (int256 volume, int256 cost, , uint256 margin, uint256 lastUpdateTimestamp) = _pToken.getPosition(owner);\n', '        require(timestamp > lastUpdateTimestamp, "PerpetualPool: liquidate price is before position timestamp");\n', '\n', '        int256 pnl = volume.mul(price).mul(_multiplier).sub(cost);\n', '        require(pnl.add(margin) <= 0 || _calculateMarginRatio(volume, cost, price, margin) < _minMaintenanceMarginRatio, "PerpetualPool: cannot liquidate");\n', '\n', '        _liquidity = _liquidity.add(margin);\n', '        _tradersNetVolume = _tradersNetVolume.sub(volume);\n', '        _tradersNetCost = _tradersNetCost.sub(cost);\n', '        _pToken.update(owner, 0, 0, 0, 0, 0);\n', '\n', '        uint256 reward;\n', '        if (margin <= _minLiquidationReward) {\n', '            reward = _minLiquidationReward;\n', '        } else if (margin >= _maxLiquidationReward) {\n', '            reward = _maxLiquidationReward;\n', '        } else {\n', '            reward = margin.sub(_minLiquidationReward).mul(_liquidationCutRatio).add(_minLiquidationReward);\n', '        }\n', '        reward = reward.reformat(_bDecimals);\n', '\n', '        _liquidity = _liquidity.sub(reward);\n', '        _bToken.safeTransfer(msg.sender, reward.rescale(_bDecimals));\n', '\n', '        emit Liquidate(owner, volume, cost, margin, timestamp, price, msg.sender, reward);\n', '    }\n', '\n', '\n', '    //================================================================================\n', '    // Helpers\n', '    //================================================================================\n', '\n', '    /**\n', '     * @dev Check if an address is a contract\n', '     */\n', '    function _isContract(address addr) internal view returns (bool) {\n', '        uint32 size;\n', '        assembly {\n', '            size := extcodesize(addr)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     *                            margin + unrealizedPnl\n', '     *@dev margin ratio = --------------------------------------\n', '     *                       abs(volume) * price * multiplier\n', '     *\n', '     * volume cannot be zero\n', '     */\n', '    function _calculateMarginRatio(int256 volume, int256 cost, uint256 price, uint256 margin)\n', '        internal view returns (uint256)\n', '    {\n', '        int256 value = volume.mul(price).mul(_multiplier);\n', '        uint256 ratio = margin.add(value.sub(cost)).div(value.abs());\n', '        return ratio;\n', '    }\n', '\n', '    /**\n', '     *                          _tradersNetVolume * price * multiplier\n', '     * @dev rate per block = ------------------------------------------- * coefficient\n', '     *                                      _liquidity\n', '     */\n', '    function _updateCumuFundingRate(uint256 price) private {\n', '        if (block.number > _cumuFundingRateBlock) {\n', '            int256 rate;\n', '            if (_liquidity != 0) {\n', '                rate = _tradersNetVolume.mul(price).mul(_multiplier).mul(_fundingRateCoefficient).div(_liquidity);\n', '            } else {\n', '                rate = 0;\n', '            }\n', '            int256 delta = rate * (int256(block.number.sub(_cumuFundingRateBlock))); // overflow is intended\n', '            _cumuFundingRate += delta; // overflow is intended\n', '            _cumuFundingRateBlock = block.number;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Check price signature\n', '     */\n', '    function _checkPriceSignature(uint256 timestamp, uint256 price, uint8 v, bytes32 r, bytes32 s)\n', '        internal view\n', '    {\n', '        require(v == 27 || v == 28, "PerpetualPool: v not valid");\n', '        bytes32 message = keccak256(abi.encodePacked(_symbol, timestamp, price));\n', '        bytes32 hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", message));\n', '        address signer = ecrecover(hash, v, r, s);\n', '        require(signer == address(_oracle), "PerpetualPool: price not signed by oracle");\n', '    }\n', '\n', '    /**\n', '     * @dev Check price signature to verify if price is authorized, and update _price\n', '     * only check/update once for one block\n', '     */\n', '    function _updatePriceWithSignature(\n', '        uint256 timestamp, uint256 price, uint8 v, bytes32 r, bytes32 s\n', '    ) internal\n', '    {\n', '        if (block.number != _lastPriceBlockNumber) {\n', '            require(timestamp >= _lastPriceTimestamp, "PerpetualPool: price is not the newest");\n', '            require(block.timestamp - timestamp <= _priceDelayAllowance, "PerpetualPool: price is older than allowance");\n', '\n', '            _checkPriceSignature(timestamp, price, v, r, s);\n', '\n', '            _price = price;\n', '            _lastPriceTimestamp = timestamp;\n', '            _lastPriceBlockNumber = block.number;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update price from on-chain Oracle\n', '     */\n', '    function _updatePriceFromOracle() internal {\n', '        require(_isContractOracle, "PerpetualPool: wrong type of orcale");\n', '        if (block.number != _lastPriceBlockNumber) {\n', '            _price = _oracle.getPrice();\n', '            _lastPriceBlockNumber = block.number;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev safeTransferFrom for base token with deflation protection\n', '     * Returns the actual received amount in base token (as base 10**18)\n', '     */\n', '    function _deflationCompatibleSafeTransferFrom(address from, address to, uint256 amount) internal returns (uint256) {\n', '        uint256 preBalance = _bToken.balanceOf(to);\n', '        _bToken.safeTransferFrom(from, to, amount.rescale(_bDecimals));\n', '        uint256 curBalance = _bToken.balanceOf(to);\n', '\n', '        uint256 a = curBalance.sub(preBalance);\n', '        uint256 b = 10**18;\n', '        uint256 c = a * b;\n', '        require(c / b == a, "PreMiningPool: _deflationCompatibleSafeTransferFrom multiplication overflows");\n', '\n', '        uint256 actualReceivedAmount = c / (10 ** _bDecimals);\n', '        return actualReceivedAmount;\n', '    }\n', '\n', '}']