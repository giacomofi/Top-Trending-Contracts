['pragma solidity ^0.5.8;\n', '\n', 'import "./IERC20.sol";\n', 'import "./TransferHelper.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./IPledgeMining.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract PledgeMining is IPledgeMining, ReentrancyGuard, Owned {\n', '\n', '    IERC20  _tokenA;\n', '    IERC20  _tokenB;\n', '    using TransferHelper for address;\n', '    using SafeMath for uint;\n', '    uint256 periodUnit = 1 days;\n', '    bool public mining_state;\n', '\n', '    struct Record {\n', '        uint256 id;\n', '        uint256 createTime;\n', '        uint256 stopTime;\n', '        uint256 heaven;\n', '        uint256 scale;\n', '        uint256 pledgeAmount;\n', '        uint256 releaseAmount;\n', '        uint256 over; // 1 processing 2 over\n', '    }\n', '\n', '    mapping(address => Record []) miningRecords;\n', '    mapping(uint256 => uint256) public typeConfig;\n', '\n', '\n', '    constructor(address tokenA, address tokenB) public {\n', '        _tokenA = IERC20(tokenA);\n', '        _tokenB = IERC20(tokenB);\n', '\n', '        // pledge type config init\n', '        typeConfig[uint256(30)] = uint256(5);\n', '        typeConfig[uint256(60)] = uint256(12);\n', '        typeConfig[uint256(90)] = uint256(21);\n', '        typeConfig[uint256(120)] = uint256(32);\n', '        typeConfig[uint256(150)] = uint256(45);\n', '        typeConfig[uint256(180)] = uint256(60);\n', '        mining_state = true;\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    // Does not accept ETH\n', '    function() external payable {\n', '        revert();\n', '    }\n', '\n', '    modifier mining {\n', '        require(mining_state, "PLEDGE:STOP_MINING");\n', '        _;\n', '    }\n', '\n', '\n', '    function stop_mining(uint256 tokenAAmount, uint256 tokenBAmount) public nonReentrant onlyOwner {\n', '        if (tokenAAmount > 0) {\n', '            require(address(_tokenA).safeTransfer(msg.sender, tokenAAmount), "PLEDGE:SAFE_TRANSFER_ERROR");\n', '        }\n', '        if (tokenBAmount > 0) {\n', '            require(address(_tokenB).safeTransfer(msg.sender, tokenBAmount), "PLEDGE:SAFE_TRANSFER_ERROR");\n', '        }\n', '        mining_state = false;\n', '    }\n', '\n', '\n', '    function pledge(uint256 _amount, uint256 _type) public mining nonReentrant returns (uint256){\n', '        require(_amount >= (10 ** uint(18)), "PLEDGE:AMOUNT_ERROR");\n', '        require(typeConfig[_type] != uint256(0), "PLEDGE:TYPE_ERROR");\n', '        require(address(_tokenA).safeTransferFrom(msg.sender, address(this), _amount), "PLEDGE:SAFE_TRANSFER_FROM_ERROR");\n', '\n', '        uint256 scale = typeConfig[_type];\n', '        Record [] storage records = miningRecords[msg.sender];\n', '        uint256 _id = records.length;\n', '        records.push(Record(_id, block.timestamp, 0, _type, scale, _amount, 0, 1));\n', '        emit PledgeEvent(msg.sender, _amount, _type);\n', '        return _id;\n', '    }\n', '\n', '\n', '    function receiveIncomeInternal(uint256 _index) internal returns (uint256){\n', '        uint256 income = calcReceiveIncome(msg.sender, _index);\n', '        if (income > 0) {\n', '            Record storage r = miningRecords[msg.sender][_index];\n', '            r.releaseAmount = r.releaseAmount.add(income);\n', '            require(address(_tokenB).safeTransfer(msg.sender, income), "PLEDGE:SAFE_TRANSFER_ERROR");\n', '            emit ReceiveIncomeEvent(msg.sender, income, _index);\n', '        }\n', '        return (income);\n', '    }\n', '\n', '    function closeRenewal(uint256 _index) public nonReentrant {\n', '        Record storage r = miningRecords[msg.sender][_index];\n', '        require(r.over == uint256(1) && r.stopTime == uint256(0), "PLEDGE:UNABLE_TO_CLOSE_RENEWAL");\n', '        r.stopTime = block.timestamp.sub(r.createTime)\n', '        .div(r.heaven.mul(periodUnit)).add(1)\n', '        .mul(r.heaven.mul(periodUnit)).add(r.createTime);\n', '    }\n', '\n', '    function openRenewal(uint256 _index) public nonReentrant {\n', '        Record storage r = miningRecords[msg.sender][_index];\n', '        require(r.over == uint256(1) && r.stopTime > 0 && block.timestamp < r.stopTime, "PLEDGE:UNABLE_TO_OPEN_RENEWAL");\n', '        r.stopTime = uint256(0);\n', '    }\n', '\n', '\n', '    function receiveIncome(uint256 _index) public nonReentrant returns (uint256){\n', '        uint256 income = receiveIncomeInternal(_index);\n', '        require(income > 0, "PLEDGE:NO_EXTRA_INCOME");\n', '        return (income);\n', '    }\n', '\n', '    function removePledge(uint256 _index) public nonReentrant returns (uint256){\n', '        Record storage r = miningRecords[msg.sender][_index];\n', '        require(r.over == uint256(1) && r.stopTime > 0 && block.timestamp >= r.stopTime, "PLEDGE:NOT_EXPIRED");\n', '        uint256 income = receiveIncomeInternal(_index);\n', '        require(address(_tokenA).safeTransfer(msg.sender, r.pledgeAmount), "PLEDGE:SAFE_TRANSFER_ERROR");\n', '        r.over = uint256(2);\n', '        emit RemovePledgeEvent(msg.sender, r.pledgeAmount, _index);\n', '        return (income);\n', '    }\n', '\n', '\n', '    function calcReceiveIncome(address addr, uint256 _index) public view returns (uint256){\n', '        Record storage r = miningRecords[addr][_index];\n', '        require(r.over == uint256(1), "PLEDGE:RECORD_OVER");\n', '\n', '        uint256 oneTotal = r.pledgeAmount.mul(r.scale).div(uint256(1000));\n', '        uint256 _income = oneTotal.mul(block.timestamp.sub(r.createTime)).div(r.heaven.mul(periodUnit));\n', '        if (r.stopTime > 0) {\n', '            uint256 _total = oneTotal\n', '            .mul(r.stopTime.sub(r.createTime).div(r.heaven.mul(periodUnit)));\n', '            if (_income > _total) {\n', '                _income = _total;\n', '            }\n', '        }\n', '        _income = _income.sub(r.releaseAmount);\n', '\n', '\n', '        uint256 _balance = _tokenB.balanceOf(address(this));\n', '        if (_income > 0 && _income > _balance) {\n', '            _income = _balance;\n', '        }\n', '\n', '        return (_income);\n', '    }\n', '\n', '\n', '\n', '    function getTokens() public view returns (address, address){\n', '        return (address(_tokenA), address(_tokenB));\n', '    }\n', '\n', '\n', '    function getUserRecords(address addr, uint256 offset, uint256 size) public view returns (\n', '        uint256 [4] memory page,\n', '        uint256 [] memory data\n', '    ){\n', '        require(offset >= 0);\n', '        require(size > 0);\n', '        Record [] storage records = miningRecords[addr];\n', '        uint256 lrSize = records.length;\n', '        uint256 len = 0;\n', '        uint256 prop_count = 8;\n', '        if (size > lrSize) {\n', '            size = lrSize;\n', '        }\n', '        data = new uint256[](size * prop_count);\n', '        if (lrSize == 0 || offset > (lrSize - 1)) {\n', '            return ([len, block.timestamp, lrSize, prop_count], data);\n', '        }\n', '        uint256 i = lrSize - 1 - offset;\n', '        uint256 iMax = 0;\n', '        if (offset <= (lrSize - size)) {\n', '            iMax = lrSize - size - offset;\n', '        }\n', '        while (i >= 0 && i >= iMax) {\n', '            Record memory r = records[i];\n', '            data[len * prop_count + 0] = r.id;\n', '            data[len * prop_count + 1] = r.createTime;\n', '            data[len * prop_count + 2] = r.stopTime;\n', '            data[len * prop_count + 3] = r.heaven;\n', '            data[len * prop_count + 4] = r.scale;\n', '            data[len * prop_count + 5] = r.pledgeAmount;\n', '            data[len * prop_count + 6] = r.releaseAmount;\n', '            data[len * prop_count + 7] = r.over;\n', '            len = len + 1;\n', '            if (i == 0) {\n', '                break;\n', '            }\n', '            i--;\n', '        }\n', '        return ([len, block.timestamp, lrSize, prop_count], data);\n', '    }\n', '\n', '\n', '}']