['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '// File: contracts/utils/AddressArray.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'library AddressArray{\n', '  function exists(address[] memory self, address addr) public pure returns(bool){\n', '    for (uint i = 0; i< self.length;i++){\n', '      if (self[i]==addr){\n', '        return true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function index_of(address[] memory self, address addr) public pure returns(uint){\n', '    for (uint i = 0; i< self.length;i++){\n', '      if (self[i]==addr){\n', '        return i;\n', '      }\n', '    }\n', '    require(false, "AddressArray:index_of, not exist");\n', '  }\n', '\n', '  function remove(address[] storage self, address addr) public returns(bool){\n', '    uint index = index_of(self, addr);\n', '    self[index] = self[self.length - 1];\n', '\n', '    delete self[self.length-1];\n', '    self.length--;\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/utils/SafeMath.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'library SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a, "add");\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a, "sub");\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "mul");\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0, "div");\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// File: contracts/utils/Ownable.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'contract Ownable {\n', '    address private _contract_owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = msg.sender;\n', '        _contract_owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _contract_owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_contract_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_contract_owner, newOwner);\n', '        _contract_owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/assets/TokenBankInterface.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'contract TokenBankInterface{\n', '  function issue(address token_addr, address payable _to, uint _amount) public returns (bool success);\n', '}\n', '\n', '// File: contracts/ERC20SalaryV2.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20SalaryV2 is Ownable{\n', '  using SafeMath for uint;\n', '  using AddressArray for address[];\n', '\n', '  struct employee_info{\n', '    uint salary;\n', '    uint period;\n', '    uint total;\n', '    uint claimed;\n', '    uint last_block_num;\n', '    uint pause_block_num;\n', '    address leader;\n', '    bool paused;\n', '    bool exists;\n', '  }\n', '\n', '  TokenBankInterface public erc20bank;\n', '  address public target_token;\n', '  string public token_name;\n', '  address[] public employee_accounts;\n', '  mapping (address => employee_info) public employee_infos;\n', '\n', '  event ClaimedSalary(address account, address to, uint amount);\n', '\n', '  constructor(string memory _name, address _target_token, address _erc20bank) public{\n', '    token_name = _name;\n', '    target_token = _target_token;\n', '    erc20bank = TokenBankInterface(_erc20bank);\n', '  }\n', '\n', '  function change_token_bank(address _addr) public onlyOwner{\n', '    require(_addr != address(0x0), "invalid address");\n', '    erc20bank = TokenBankInterface(_addr);\n', '  }\n', '\n', '  function unclaimed_amount() public view returns(uint){\n', '    uint total = 0;\n', '    for(uint i = 0; i < employee_accounts.length; ++i){\n', '      uint p = get_unclaimed_period(employee_accounts[i]);\n', '      uint t = employee_infos[employee_accounts[i]].total.safeSub(employee_infos[employee_accounts[i]].claimed);\n', '      uint s = employee_infos[employee_accounts[i]].salary;\n', '      total = total.safeAdd(p.safeMul(s));\n', '      total = total.safeAdd(t);\n', '    }\n', '    return total;\n', '  }\n', '\n', '  function add_employee(address account, uint last_block_num, uint period, uint salary, address leader)\n', '    public onlyOwner\n', '    returns(bool)\n', '    {\n', '      require(account != address(0));\n', '      require(last_block_num >0);\n', '      require(period > 0);\n', '      require(salary > 0);\n', '      require(leader != account, "cannot be self leader");\n', '      if(employee_infos[account].exists) return false;\n', '      _primitive_init_employee(account, last_block_num, 0, false, period, salary, 0, 0, leader);\n', '      return true;\n', '    }\n', '\n', '    function add_employee_with_meta(address account, uint last_block_num,\n', '                                    uint pause_block_num, bool paused, uint period,\n', '                                    uint salary, uint total, uint claimed, address leader)\n', '    public onlyOwner\n', '    returns(bool)\n', '      {\n', '      _primitive_init_employee(account, last_block_num, pause_block_num, paused, period, salary, total, claimed, leader);\n', '      return true;\n', '    }\n', '\n', '    function _primitive_init_employee(address account, uint last_block_num,\n', '                                     uint pause_block_num, bool paused, uint period,\n', '                                     uint salary, uint total, uint claimed, address leader) internal{\n', '      if(!employee_infos[account].exists) {\n', '        employee_accounts.push(account);\n', '      }\n', '\n', '      employee_infos[account].salary = salary;\n', '      employee_infos[account].period = period;\n', '      employee_infos[account].total = total;\n', '      employee_infos[account].claimed = claimed;\n', '      employee_infos[account].last_block_num = last_block_num;\n', '      employee_infos[account].pause_block_num = pause_block_num;\n', '      employee_infos[account].leader = leader;\n', '      employee_infos[account].paused = paused;\n', '      employee_infos[account].exists = true;\n', '    }\n', '\n', '    function remove_employee(address account) public onlyOwner{\n', '      _remove_employee(account);\n', '    }\n', '\n', '    function _remove_employee(address account) internal returns(bool){\n', '      if(!employee_infos[account].exists) return false;\n', '      employee_accounts.remove(account);\n', '      delete employee_infos[account];\n', '      return true;\n', '    }\n', '\n', '    function change_employee_period(address account, uint period) public onlyOwner{\n', '      require(employee_infos[account].exists);\n', '      _update_salary(account);\n', '      employee_infos[account].period = period;\n', '    }\n', '\n', '    function change_employee_salary(address account, uint salary) public onlyOwner{\n', '      require(employee_infos[account].exists);\n', '      _update_salary(account);\n', '      employee_infos[account].salary= salary;\n', '    }\n', '\n', '    function change_employee_leader(address account, address leader) public onlyOwner{\n', '      require(employee_infos[account].exists);\n', '      require(account != leader, "account cannot be self leader");\n', '      _update_salary(account);\n', '      employee_infos[account].leader = leader;\n', '    }\n', '\n', '    function change_employee_status(address account, bool pause) public onlyOwner{\n', '      require(employee_infos[account].exists);\n', '      require(employee_infos[account].paused != pause, "status already done");\n', '      _update_salary(account);\n', '      _change_employee_status(account, pause);\n', '    }\n', '\n', '    function _change_employee_status(address account, bool pause) internal {\n', '      employee_infos[account].paused = pause;\n', '      employee_infos[account].pause_block_num = (block.number - employee_infos[account].pause_block_num);\n', '    }\n', '\n', '    function change_subordinate_period(address account, uint period) public {\n', '      require(employee_infos[account].exists);\n', '      require(employee_infos[account].leader == msg.sender, "not your subordinate");\n', '      _update_salary(account);\n', '      employee_infos[account].period = period;\n', '    }\n', '    function change_subordinate_salary(address account, uint salary) public {\n', '      require(employee_infos[account].exists);\n', '      require(employee_infos[account].leader == msg.sender, "not your subordinate");\n', '\n', '      employee_infos[account].salary = salary;\n', '    }\n', '    function change_subordinate_status(address account, bool pause) public {\n', '      require(employee_infos[account].exists);\n', '      require(employee_infos[account].leader == msg.sender, "not your subordinate");\n', '      _update_salary(account);\n', '      _change_employee_status(account, pause);\n', '    }\n', '\n', '    function get_unclaimed_period(address account) public view returns(uint){\n', '      employee_info storage ei = employee_infos[account];\n', '      uint t = block.number.safeSub(ei.pause_block_num);\n', '      t = t.safeSub(ei.last_block_num).safeDiv(ei.period);\n', '      return t;\n', '    }\n', '    function _update_salary(address account) private {\n', '      employee_info storage ei = employee_infos[account];\n', '      if(ei.paused) return ;\n', '      uint p = get_unclaimed_period(account);\n', '      if(p == 0) return ;\n', '      ei.total = ei.total.safeAdd(p.safeMul(ei.salary));\n', '      ei.last_block_num = ei.last_block_num.safeAdd(p.safeMul(ei.period));\n', '    }\n', '\n', '    function update_salary(address account) public{\n', '      require(employee_infos[account].exists, "not exist");\n', '      _update_salary(account);\n', '    }\n', '\n', '    function claim_salary(address payable to, uint amount) public returns(bool){\n', '      require(employee_infos[msg.sender].exists, "not exist");\n', '      _update_salary(msg.sender);\n', '      employee_info storage ei = employee_infos[msg.sender];\n', '      require(ei.total.safeSub(ei.claimed) >= amount, "no balance");\n', '\n', '      ei.claimed  = ei.claimed.safeAdd(amount);\n', '      erc20bank.issue(target_token, to, amount);\n', '\n', '      emit ClaimedSalary(msg.sender, to, amount);\n', '      return true;\n', '    }\n', '\n', '    function get_employee_count() public view returns(uint){\n', '      return employee_accounts.length;\n', '    }\n', '\n', '    function get_employee_info_with_index(uint index) public view returns(uint salary, uint period, uint total, uint claimed, uint last_claim_block_num, uint paused_block_num, bool paused, address leader){\n', '      require(index >= 0 && index < employee_accounts.length);\n', '      address account = employee_accounts[index];\n', '      require(employee_infos[account].exists);\n', '      return get_employee_info_with_account(account);\n', '    }\n', '\n', '    function get_employee_info_with_account(address account) public view returns(uint salary, uint period, uint total,\n', '                                                                                 uint claimed, uint last_claim_block_num, uint paused_block_num, bool paused, address leader){\n', '      require(employee_infos[account].exists);\n', '      salary = employee_infos[account].salary;\n', '      period = employee_infos[account].period;\n', '      total = employee_infos[account].total;\n', '      claimed = employee_infos[account].claimed;\n', '      last_claim_block_num = employee_infos[account].last_block_num;\n', '      leader = employee_infos[account].leader;\n', '      paused = employee_infos[account].paused;\n', '      paused_block_num = employee_infos[account].pause_block_num;\n', '    }\n', '}\n', '\n', 'contract ERC20SalaryV2Factory{\n', '  event NewERC20Salary(address addr);\n', '  function createERC20SalaryV2(string memory name, address target_token, address erc20bank) public returns(address){\n', '    ERC20SalaryV2 salary = new ERC20SalaryV2(name, target_token, erc20bank);\n', '    emit NewERC20Salary(address(salary));\n', '    salary.transferOwnership(msg.sender);\n', '    return address(salary);\n', '  }\n', '}']