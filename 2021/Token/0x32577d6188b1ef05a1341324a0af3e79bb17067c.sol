['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-29\n', '*/\n', '\n', '///SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', '         _____                                           \n', '       \\/,---<                                           \n', '       ( )a a(      YOU STOLE FIZZY LIFTING DRINKS!!!    \n', '        C   >/                                           \n', '         \\ ~/      BUT THE D.A. MISHANDLED THE EVIDENCE, \n', "       ,- >o<-.    SO HERE'S THE KEYS TO MY FUDGE FACTORY\n", '      /   \\/   \\                                         \n', '     / /|  | |\\ \\     _                                  \n', '     \\ \\|  | | \\ `---/_)                                 \n', '      \\_\\_ | |  `----\\_O-                                \n', '      /_/____|                                           \n', '        |  | |                                           \n', '        |  | |                                           \n', '        |  | |               ____                        \n', '        |__|_|_           &&& x_ \\_,-------.___     |    \n', 'Stef00  (____)_)         &&&& x__*_\\\\._/__--_-_\\-._/_    \n', '\n', 'Image found here: http://www.asciiartfarts.com/20121102.html\n', '\n', 'My name is Millie Monka\n', 'I love Meme Coins\n', 'And also you do\n', 'So I decided to open the doors of my Meme Coin Factory to you\n', 'Every 35 hours you can create a meme coin sending at least 1 ETH\n', 'you can choose name, symbol, and total supply\n', 'Meme Coin will be created and 99.98% of the total supply will be stored in a pool on UniswapV2 using eth you provided\n', 'remaining 0.02% of the Meme Coin total supply will be sent to Meme Coin creator so they can be swapped in future to have back creation fees\n', 'Resulting liquidity pool token will be held by the Meme Coin itself\n', 'the first burning 65% of the Meme Coin total supply will extract 60% of the pool\n', 'All Meme Coins removed from the pool will be burned\n', '40% of removed eth will be sent to who burned tokens\n', '47% of removed eth will be sent back to pool\n', "remaining removed eth will be sent as Factory's fees\n", 'The remaining balance of liquidity pool token will be locked inside the Meme Coin forever\n', '\n', 'In Factory:\n', '\n', "you have create(string memory name, string memory symbol, uint256 totalSupplyPlain) method to create a new Meme Coin. The amount is expressed in the decimal format so you DON'T HAVE TO multiply it for 1e18, Meme Coin will directly do it for you.\n", '\n', 'you have memeCoins() method to retrieve all Meme Coins in order of creation, including latest one\n', 'you have lastMemeCoin() method to retrieve the last Meme Coin only\n', 'you have nextCreationBlock() method to know when the next Meme Coin can be created\n', 'you have canBeCreated() method returning if nextCreationBlock reached and new Meme Coin can be created\n', '\n', 'In every Meme Coin:\n', '\n', 'you have the burn() method which will do all burn stuff descrived above for you\n', '\n', 'you have burnt() method to check if the 65% of total supply was already burnt or not\n', '\n', 'You can build a Telegram bot or fork the Uniswap frontend to easily use the Meme Coins\n', '\n', 'Hope you will enjoy my Meme Coin Factory,\n', 'I will do.\n', '\n', 'Yours,\n', 'Millie\n', '\n', '*/\n', '\n', 'interface IUniswapV2Router {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidityETH(\n', '      address token,\n', '      uint amountTokenDesired,\n', '      uint amountTokenMin,\n', '      uint amountETHMin,\n', '      address to,\n', '      uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '\n', '    function removeLiquidityETH(\n', '      address token,\n', '      uint liquidity,\n', '      uint amountTokenMin,\n', '      uint amountETHMin,\n', '      address to,\n', '      uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '}\n', '\n', 'interface IUniswapLiquidityPool {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function sync() external;\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface WETHToken {\n', '    function deposit() external payable;\n', '    function transfer(address dst, uint wad) external returns (bool);\n', '}\n', '\n', 'contract MemeCoin {\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '    \n', '    IUniswapV2Router private UNISWAP;\n', '\n', '    address private _millie;\n', '\n', '    bool public burnt;\n', '\n', '    constructor(IUniswapV2Router uniswap, string memory _name, string memory _symbol, uint256 _totalSupply, address millie) {\n', '        UNISWAP = uniswap;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        _millie = millie;\n', '        _mint(msg.sender, _totalSupply);\n', '    }\n', '\n', '    receive() external payable {\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][msg.sender];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, msg.sender, currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function burn() public {\n', '        require(!burnt);\n', '        _burn(msg.sender, (totalSupply * 65) / 100);\n', '        burnt = true;\n', '        WETHToken weth = WETHToken(UNISWAP.WETH());\n', '        IUniswapLiquidityPool liquidityPool = IUniswapLiquidityPool(IUniswapV2Factory(UNISWAP.factory()).getPair(address(weth), address(this)));\n', '        uint256 poolBalance = (liquidityPool.balanceOf(address(this)) * 60) / 100;\n', '        liquidityPool.approve(address(UNISWAP), poolBalance);\n', '        (uint256 tokens, uint256 eths) = UNISWAP.removeLiquidityETH(address(this), poolBalance, 1, 1, address(this), block.timestamp + 1000000);\n', '        _burn(address(this), tokens);\n', '        poolBalance = eths;\n', '        payable(msg.sender).transfer(tokens = (eths * 40) / 100);\n', '        poolBalance -= tokens;\n', '        weth.deposit{value : tokens = (eths * 47) / 100}();\n', '        weth.transfer(address(liquidityPool), tokens);\n', '        liquidityPool.sync();\n', '        poolBalance -= tokens;\n', '        payable(_millie).transfer(poolBalance);\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '}\n', '\n', 'contract MemeCoinFactory {\n', '\n', '    uint256 private constant BLOCK_INTERVAL = 9333;\n', '    \n', '    IUniswapV2Router private constant UNISWAP = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '\n', '    address private _millie = msg.sender;\n', '\n', '    address[] private _memeCoins;\n', '\n', '    uint256 private _lastMemeCoinCreation;\n', '\n', '    function memeCoins() public view returns (address[] memory){\n', '        return _memeCoins;\n', '    }\n', '\n', '    function lastMemeCoin() public view returns (address) {\n', '        return _memeCoins[_memeCoins.length - 1];\n', '    }\n', '\n', '    function nextCreationBlock() public view returns (uint256) {\n', '        return _lastMemeCoinCreation == 0 ? block.number : _lastMemeCoinCreation + BLOCK_INTERVAL;\n', '    }\n', '\n', '    function canBeCreated() public view returns (bool) {\n', '        return _lastMemeCoinCreation == 0 ? true : block.number >= nextCreationBlock();\n', '    }\n', '\n', '    function create(string calldata name, string calldata symbol, uint256 totalSupplyPlain) public payable {\n', '        require(canBeCreated());\n', '        require(msg.value >= 1e18);\n', '        _lastMemeCoinCreation = block.number;\n', '        uint256 totalSupply = totalSupplyPlain * 1e18;\n', '        MemeCoin newMemeCoin = new MemeCoin(UNISWAP, name, symbol, totalSupply, _millie);\n', '        _memeCoins.push(address(newMemeCoin));\n', '        uint256 senderBalance = (totalSupply * 2) / 10000;\n', '        newMemeCoin.transfer(msg.sender, senderBalance);\n', '        totalSupply -= senderBalance;\n', '        newMemeCoin.approve(address(UNISWAP), totalSupply);\n', '        UNISWAP.addLiquidityETH{value : msg.value}(address(newMemeCoin), totalSupply, 1, 1, address(newMemeCoin), block.timestamp + 100000000);\n', '    }\n', '}']