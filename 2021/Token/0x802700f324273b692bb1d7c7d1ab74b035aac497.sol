['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-08\n', '*/\n', '\n', '//SPDX-License-Identifier: GNU GPLv3\n', 'pragma solidity ^0.7.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () public {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract SwapContract is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 public OldToken;\n', '    IERC20 public NewToken;\n', '    uint256 public Decimals;\n', '\n', '    uint BasisPoints = 10**9;\n', '\n', '    constructor(address OldTokenAddress, address NewTokenAddress ) public{\n', '         OldToken = IERC20(OldTokenAddress);\n', '        NewToken = IERC20(NewTokenAddress);\n', '        Decimals = 9;\n', '    }\n', '\n', '    function withdraw(IERC20 token) public onlyOwner {\n', '        token.transfer(address(owner()), token.balanceOf(address(this)));\n', '    }\n', '\n', '    function swapTokens() hasApprovedTransfer public {\n', '\n', '        uint tokenBalance = OldToken.balanceOf(msg.sender);\n', '        uint totalSupply = OldToken.totalSupply();\n', '        uint supplyPercentage = tokenBalance.mul(BasisPoints).div(totalSupply);\n', '        require(supplyPercentage > 0, "Must have larger balance to swap");\n', '\n', '        uint approvedTokenAmount = OldToken.allowance(msg.sender, address(this));\n', '        require(approvedTokenAmount >= tokenBalance, "Insufficient Tokens approved for transfer");\n', '\n', '        uint newTokenSupply = NewToken.totalSupply();\n', '        uint supplyTokenBasis = newTokenSupply.div(BasisPoints);\n', '        uint tokensToTransfer = supplyTokenBasis * supplyPercentage;\n', '\n', '        uint newTokenBalance = NewToken.balanceOf(address(this));\n', '        require(tokensToTransfer <= newTokenBalance, "Insufficient Tokens tokens on contract to swap");\n', '\n', '        require(OldToken.transferFrom(msg.sender, address(this), tokenBalance));\n', '        NewToken.transfer(msg.sender, tokensToTransfer);\n', '    }\n', '\n', '    modifier hasApprovedTransfer() {\n', '        require(OldToken.allowance(msg.sender, address(this)) > 0, "Tokens not approved for transfer");\n', '        _;\n', '    }\n', '}']