['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-11\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.1;\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract Album_Core {\n', '  string public artist;\n', '  string public uri;\n', '  address public owner_address;\n', '  uint16 public release_count;\n', '  uint16 public product_count;\n', '\n', '  constructor(string memory _artist, string memory _uri) {\n', '    owner_address = msg.sender;\n', '    artist = _artist;\n', '    uri = _uri;\n', '  }\n', '\n', '  event Release_Created(uint16 indexed release_id, uint8 indexed release_type, string name, string root_uri);\n', '  event Release_Limited(uint16 indexed release_id);\n', '  event Product_Created(uint16 indexed product_id, string name, string metadata_uri);\n', '  event Transfer(address indexed from, address indexed to, uint16[] indicies, uint32[] counts);\n', '  event Product_Listed(uint16 indexed product_id, address indexed currency, uint256 price);\n', '  event Product_Delisted(uint16 indexed product_id);\n', '  event Product_Purchased(uint16 indexed product_id, address indexed buyer);\n', '  event Approval(address indexed owner, address indexed target, bool approved);\n', '\n', '  struct release {\n', '      uint32 total_created;\n', '      bool limited;\n', '      uint8 release_type;\n', '  }\n', '\n', '  struct product {\n', '    uint16[] indicies;\n', '    uint32[] counts;\n', '    uint16 available_for_sale;\n', '    bool listed;\n', '    address currency;\n', '    uint256 price;\n', '    address profit_owner;\n', '  }\n', '\n', '  mapping(uint16 => release) public releases;\n', '  mapping(address=>mapping(address => bool)) public approvals;\n', '  mapping(uint16 => product) public products;\n', '  mapping(address => mapping(uint16 => uint32)) public balances;\n', '\n', '  function get_product_release_indicies(uint16 product_id) public view returns(uint16[] memory){\n', '    return products[product_id].indicies;\n', '  }\n', '  function get_product_release_counts(uint16 product_id) public view returns(uint32[] memory){\n', '    return products[product_id].counts;\n', '  }\n', '\n', '  function create_release(string calldata name, string calldata root_uri, uint8 release_type) public only_owner {\n', '    require(release_count + 1 > release_count, "no more releases allowed, launch new contract");\n', '    releases[release_count] = release(0, false, release_type);\n', '    emit Release_Created(release_count, release_type, name, root_uri);\n', '    release_count++;\n', '  }\n', '\n', '  function create_product(string calldata name, string calldata metadata_uri, uint16[] memory indicies, uint32[] memory counts, uint16 max_copies, address profit_owner) public only_owner {\n', '    require(product_count + 1 > product_count, "no more products allowed, launch new contract");\n', '    require(indicies.length == counts.length, "array mismatch");\n', '\n', '    //up to 255 item types in 1 product\n', '    for(uint8 item_idx = 0; item_idx < counts.length; item_idx++ ){\n', '      require(indicies[item_idx] < release_count, "cannot include unreleased items");\n', '      require(!releases[indicies[item_idx]].limited, "cannot include limited release");\n', '      require(releases[indicies[item_idx]].total_created + counts[item_idx] > releases[indicies[item_idx]].total_created, "too many of specific release");\n', '      releases[indicies[item_idx]].total_created = releases[indicies[item_idx]].total_created + (counts[item_idx] * max_copies);\n', '\n', '    }\n', '    products[product_count] = product(indicies, counts, max_copies, false, address(0), 0, profit_owner );\n', '    emit Product_Created(product_count, name, metadata_uri);\n', '    product_count++;\n', '  }\n', '  function limit_release(uint16 release_id) public only_owner{\n', '    require(release_id < release_count);\n', '    releases[release_id].limited = true;\n', '    emit Release_Limited(release_id);\n', '  }\n', '  function list_product(uint16 product_id, address currency, uint256 price) public only_owner {\n', '    products[product_id].listed = true;\n', '    products[product_id].currency = currency;\n', '    products[product_id].price = price;\n', '    emit Product_Listed(product_id, currency, price);\n', '  }\n', '\n', '  function delist_product(uint16 product_id) public only_owner {\n', '    products[product_id].listed = false;\n', '    emit Product_Delisted(product_id);\n', '  }\n', '\n', '  function change_uri(string memory new_uri) public only_owner {\n', '    uri = new_uri;\n', '  }\n', '  function change_owner(address new_address) public only_owner {\n', '    owner_address = new_address;\n', '  }\n', '\n', '  function buy_product(uint16 product_id, address currency, uint256 price) public {\n', '    require(products[product_id].listed);\n', '    require(products[product_id].available_for_sale > 0);\n', '    require(products[product_id].currency == currency);\n', '    require(products[product_id].price == price);\n', '    require(IERC20(currency).transferFrom(msg.sender, products[product_id].profit_owner, price));\n', '    for(uint8 item_idx = 0; item_idx < products[product_id].counts.length; item_idx++ ){\n', '        balances[msg.sender][products[product_id].indicies[item_idx]] += products[product_id].counts[item_idx];\n', '    }\n', '    products[product_id].available_for_sale--;\n', '    emit Product_Purchased(product_id, msg.sender);\n', "    //this is when it's actually popped into being\n", '    emit Transfer(address(0), msg.sender, products[product_id].indicies, products[product_id].counts);\n', '  }\n', '\n', '  function set_approve_all(address target, bool approve) public {\n', '    approvals[msg.sender][target] = approve;\n', '    emit Approval(msg.sender, target, approve);\n', '  }\n', '\n', '  function transfer_from(uint16[] memory indicies, uint32[] memory counts, address from, address target) public {\n', '    require(indicies.length == counts.length, "array mismatch");\n', '    require(approvals[msg.sender][from] || msg.sender == from, "not approved");\n', '    for(uint8 item_idx = 0; item_idx < counts.length; item_idx++ ){\n', '        require(balances[from][indicies[item_idx]] - counts[item_idx] < balances[from][indicies[item_idx]]);\n', '        balances[from][indicies[item_idx]] -= counts[item_idx];\n', '        balances[target][indicies[item_idx]] += counts[item_idx];\n', '    }\n', '    emit Transfer(from, target, indicies, counts);\n', '  }\n', '\n', '  modifier only_owner {\n', '     require(msg.sender == owner_address, "only owner");\n', '     _;\n', '  }\n', '}']