['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-02\n', '*/\n', '\n', 'pragma solidity 0.8.1; /*\n', '\n', '======================= Quick Stats ===================\n', '    => Name        : NEXT\n', '    => Symbol      : NEXT\n', '    => Initial     : 8,000,000 (8M)\n', '    => Max supply  : 30,300,000 (30,3M)\n', '    => Decimals    : 18\n', '============= Independant Audit of the code ============\n', '    => Community Audit by Bug Bounty program\n', '----------------------------------------------------------------------------\n', ' SPDX-License-Identifier: MIT\n', ' Copyright (c) 2021 NEXT. ( https://nextchain.dev/ )\n', '-----------------------------------------------------------------------------\n', '*/\n', '\n', '//*******************************************************************//\n', '//------------------------ SafeMath Library -------------------------//\n', '//*******************************************************************//\n', '/**\n', '    * @title SafeMath\n', '    * @dev Math operations with safety checks that throw on error\n', '    */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', "        require(c / a == b, 'SafeMath mul failed');\n", '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        require(b <= a, 'SafeMath sub failed');\n", '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', "        require(c >= a, 'SafeMath add failed');\n", '        return c;\n', '    }\n', '}\n', '\n', '\n', '//*******************************************************************//\n', '//------------------ Contract to Manage Ownership -------------------//\n', '//*******************************************************************//\n', '\n', 'contract owned {\n', '    address payable public owner;\n', '    address payable internal newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() {\n', '        owner = payable(msg.sender);\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address payable _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    //this flow is to prevent transferring ownership to wrong wallet by mistake\n', '    function acceptOwnership() external {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = payable(address(0));\n', '    }\n', '}\n', '\n', 'contract Minter is owned {\n', '    address payable public mintingowner;\n', '    address payable internal newMintingOwner;\n', '\n', '    event MintingOwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() {\n', '        mintingowner = payable(msg.sender);\n', '        emit MintingOwnershipTransferred(address(0), mintingowner);\n', '    }\n', '\n', '    modifier onlyMintingOwner {\n', '        require(msg.sender == mintingowner);\n', '        _;\n', '    }\n', '\n', '    function transferMintingOwnership(address payable _newMintingOwner) external onlyOwner {\n', '        newMintingOwner = _newMintingOwner;\n', '    }\n', '\n', '    //this flow is to prevent transferring ownership to wrong wallet by mistake\n', '    function acceptMintingOwnership() external {\n', '        require(msg.sender == newMintingOwner);\n', '        emit MintingOwnershipTransferred(mintingowner, newMintingOwner);\n', '        mintingowner = newMintingOwner;\n', '        newMintingOwner = payable(address(0));\n', '    }\n', '}\n', '\n', 'interface IERC1363Spender {\n', '    /*\n', '     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n', '     * 0x7b04a2d0 === bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))\n', '     */\n', '\n', '    /**\n', '     * @notice Handle the approval of ERC1363 tokens\n', '     * @dev Any ERC1363 smart contract calls this function on the recipient\n', '     * after an `approve`. This function MAY throw to revert and reject the\n', '     * approval. Return of other than the magic value MUST result in the\n', '     * transaction being reverted.\n', '     * Note: the token contract address is always the message sender.\n', '     * @param sender address The address which called `approveAndCall` function\n', '     * @param amount uint256 The amount of tokens to be spent\n', '     * @param data bytes Additional data with no specified format\n', '     * @return `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))` unless throwing\n', '     */\n', '    function onApprovalReceived(address sender, uint256 amount, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', 'interface IERC1363Receiver {\n', '    /*\n', '     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n', '     * 0x88a7ca5c === bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))\n', '     */\n', '\n', '    /**\n', '     * @notice Handle the receipt of ERC1363 tokens\n', '     * @dev Any ERC1363 smart contract calls this function on the recipient\n', '     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n', '     * transfer. Return of other than the magic value MUST result in the\n', '     * transaction being reverted.\n', '     * Note: the token contract address is always the message sender.\n', '     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n', '     * @param sender address The address which are token transferred from\n', '     * @param amount uint256 The amount of tokens transferred\n', '     * @param data bytes Additional data with no specified format\n', '     * @return `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))` unless throwing\n', '     */\n', '    function onTransferReceived(address operator, address sender, uint256 amount, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts may inherit from this and call {_registerInterface} to declare\n', ' * their support of an interface.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () {\n', '        // Derived contracts need only register support for their own interfaces,\n', '        // we register support for ERC165 itself here\n', '        _registerInterface(type(IERC165).interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev Registers the contract as an implementer of the interface defined by\n', '     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n', '     * registering its interface id is not required.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '\n', '//****************************************************************************//\n', '//---------------------        MAIN CODE STARTS HERE     ---------------------//\n', '//****************************************************************************//\n', '\n', 'contract NEXTToken is owned, Minter, ERC165 {\n', '\n', '    /*===============================\n', '    =         DATA STORAGE          =\n', '    ===============================*/\n', '\n', '    // Public variables of the token\n', '    using SafeMath for uint256;\n', '    string constant private _name = "NEXT";\n', '    string constant private _symbol = "NEXT";\n', '    uint256 constant private _decimals = 18;\n', '    uint256 private _totalSupply = 8000000 * (10**_decimals);         //8M\n', '    uint256 immutable public maxSupply = 30300000 * (10**_decimals);    //30,3M\n', '    bool public safeguard;  //putting safeguard on will halt all non-owner functions\n', '\n', '    // This creates a mapping with all data storage\n', '    mapping (address => uint256) private _balanceOf;\n', '    mapping (address => mapping (address => uint256)) private _allowance;\n', '\n', '\n', '    /*===============================\n', '    =         PUBLIC EVENTS         =\n', '    ===============================*/\n', '\n', '    // This generates a public event of token transfer\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    // This notifies clients about the amount burnt\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    // This generates a public event for frozen (blacklisting) accounts\n', '    event FrozenAccounts(address target, bool frozen);\n', '\n', '    // This will log approval of token Transfer\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '\n', '    /*======================================\n', '    =       STANDARD ERC20 FUNCTIONS       =\n', '    ======================================*/\n', '\n', '    /**\n', '     * Returns name of token\n', '     */\n', '    function name() external pure returns(string memory){\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * Returns symbol of token\n', '     */\n', '    function symbol() external pure returns(string memory){\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * Returns decimals of token\n', '     */\n', '    function decimals() external pure returns(uint256){\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * Returns totalSupply of token.\n', '     */\n', '    function totalSupply() external view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * Returns balance of token\n', '     */\n', '    function balanceOf(address user) external view returns(uint256){\n', '        return _balanceOf[user];\n', '    }\n', '\n', '    /**\n', '     * Returns allowance of token\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256) {\n', '        return _allowance[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * Internal transfer, only can be called by this contract\n', '     */\n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '\n', '        //checking conditions\n', '        require(!safeguard);\n', '        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\n', '\n', '        // overflow and undeflow checked by SafeMath Library\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);        // Add the same to the recipient\n', '\n', '        // emit Transfer event\n', '        emit Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '        * Transfer tokens\n', '        *\n', '        * Send `_value` tokens to `_to` from your account\n', '        *\n', '        * @param _to The address of the recipient\n', '        * @param _value the amount to send\n', '        */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        //no need to check for input validations, as that is ruled by SafeMath\n', '        _transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        * Transfer tokens from other address\n', '        *\n', '        * Send `_value` tokens to `_to` in behalf of `_from`\n', '        *\n', '        * @param _from The address of the sender\n', '        * @param _to The address of the recipient\n', '        * @param _value the amount to send\n', '        */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        //checking of allowance and token value is done by SafeMath\n', '        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        * Set allowance for other address\n', '        *\n', '        * Allows `_spender` to spend no more than `_value` tokens in your behalf\n', '        *\n', '        * @param _spender The address authorized to spend\n', '        * @param _value the max amount they can spend\n', '        */\n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        require(!safeguard);\n', '        /* AUDITOR NOTE:\n', '            Many dex and dapps pre-approve large amount of tokens to save gas for subsequent transaction. This is good use case.\n', '            On flip-side, some malicious dapp, may pre-approve large amount and then drain all token balance from user.\n', "            So following condition is kept in commented. It can be be kept that way or not based on client's consent.\n", '        */\n', '        //require(_balanceOf[msg.sender] >= _value, "Balance does not have enough tokens");\n', '        _allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to increase the allowance by.\n', '     */\n', '    function increase_allowance(address spender, uint256 value) external returns (bool) {\n', '        require(spender != address(0));\n', '        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\n', '        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when allowed_[_spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decrease_allowance(address spender, uint256 value) external returns (bool) {\n', '        require(spender != address(0));\n', '        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\n', '        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /*=====================================\n', '    =       CUSTOM PUBLIC FUNCTIONS       =\n', '    ======================================*/\n', '\n', '    constructor(){\n', '        //sending all the tokens to Owner\n', '        _balanceOf[owner] = _totalSupply;\n', '\n', '        //firing event which logs this transaction\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '\n', '        // register the supported interfaces to conform to ERC1363 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC1363_TRANSFER);\n', '        _registerInterface(_INTERFACE_ID_ERC1363_APPROVE);\n', '    }\n', '\n', '    receive () external payable {  }\n', '\n', '    /**\n', '        * Destroy tokens\n', '        *\n', '        * Remove `_value` tokens from the system irreversibly\n', '        *\n', '        * @param _value the amount of money to burn\n', '        */\n', '    function burn(uint256 _value) external returns (bool success) {\n', '        require(!safeguard);\n', '        //checking of enough token balance is done by SafeMath\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\n', '        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\n', '        emit Burn(msg.sender, _value);\n', '        emit Transfer(msg.sender, address(0), _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        * @notice Create `mintedAmount` tokens and send it to `target`\n', '        * @param target Address to receive the tokens\n', '        * @param mintedAmount the amount of tokens it will receive\n', '        */\n', '    function mintToken(address target, uint256 mintedAmount) onlyMintingOwner external {\n', '        require(_totalSupply.add(mintedAmount) <= maxSupply, "Cannot Mint more than maximum supply");\n', '        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\n', '        _totalSupply = _totalSupply.add(mintedAmount);\n', '        emit Transfer(address(0), target, mintedAmount);\n', '    }\n', '\n', '    /**\n', '        * Owner can transfer tokens from contract to owner address\n', '        *\n', '        * When safeguard is true, then all the non-owner functions will stop working.\n', '        * When safeguard is false, then all the functions will resume working back again!\n', '        */\n', '\n', '    function manualWithdrawTokens(uint256 tokenAmount) external onlyOwner{\n', '        // no need for overflow checking as that will be done in transfer function\n', '        _transfer(address(this), owner, tokenAmount);\n', '    }\n', '\n', '    //Just in rare case, owner wants to transfer Ether from contract to owner address\n', '    function manualWithdrawEther() onlyOwner external{\n', '        owner.transfer(address(this).balance);\n', '    }\n', '\n', '    /**\n', '        * Change safeguard status on or off\n', '        *\n', '        * When safeguard is true, then all the non-owner functions will stop working.\n', '        * When safeguard is false, then all the functions will resume working back again!\n', '        */\n', '    function changeSafeguardStatus() onlyOwner external{\n', '        if (safeguard == false){\n', '            safeguard = true;\n', '        }\n', '        else{\n', '            safeguard = false;\n', '        }\n', '    }\n', '\n', '    /*****************************************/\n', '    /*  Section for ERC1363 Implementation   */\n', '    /*****************************************/\n', '\n', '    /*\n', '     * Note: the ERC-165 identifier for this interface is 0x4bbee2df.\n', '     * 0x4bbee2df ===\n', "     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n", "     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n", "     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n", "     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)'))\n", '     */\n', '    bytes4 internal constant _INTERFACE_ID_ERC1363_TRANSFER = 0x4bbee2df;\n', '\n', '    /*\n', '     * Note: the ERC-165 identifier for this interface is 0xfb9ec8ce.\n', '     * 0xfb9ec8ce ===\n', "     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n", "     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n", '     */\n', '    bytes4 internal constant _INTERFACE_ID_ERC1363_APPROVE = 0xfb9ec8ce;\n', '\n', '    // Equals to `bytes4(keccak256("onTransferReceived(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC1363Receiver(0).onTransferReceived.selector`\n', '    bytes4 private constant _ERC1363_RECEIVED = 0x88a7ca5c;\n', '\n', '    // Equals to `bytes4(keccak256("onApprovalReceived(address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC1363Spender(0).onApprovalReceived.selector`\n', '    bytes4 private constant _ERC1363_APPROVED = 0x7b04a2d0;\n', '\n', '\n', '    /**\n', '     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\n', '     * @param recipient The address to transfer to.\n', '     * @param amount The amount to be transferred.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function transferAndCall(address recipient, uint256 amount) public virtual  returns (bool) {\n', '        return transferAndCall(recipient, amount, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\n', '     * @param recipient The address to transfer to\n', '     * @param amount The amount to be transferred\n', '     * @param data Additional data with no specified format\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function transferAndCall(address recipient, uint256 amount, bytes memory data) public virtual  returns (bool) {\n', '        transfer(recipient, amount);\n', '        require(_checkAndCallTransfer(_msgSender(), recipient, amount, data), "ERC1363: _checkAndCallTransfer reverts");\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\n', '     * @param sender The address which you want to send tokens from\n', '     * @param recipient The address which you want to transfer to\n', '     * @param amount The amount of tokens to be transferred\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function transferFromAndCall(address sender, address recipient, uint256 amount) public virtual  returns (bool) {\n', '        return transferFromAndCall(sender, recipient, amount, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\n', '     * @param sender The address which you want to send tokens from\n', '     * @param recipient The address which you want to transfer to\n', '     * @param amount The amount of tokens to be transferred\n', '     * @param data Additional data with no specified format\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function transferFromAndCall(address sender, address recipient, uint256 amount, bytes memory data) public virtual  returns (bool) {\n', '        transferFrom(sender, recipient, amount);\n', '        require(_checkAndCallTransfer(sender, recipient, amount, data), "ERC1363: _checkAndCallTransfer reverts");\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\n', '     * @param spender The address allowed to transfer to\n', '     * @param amount The amount allowed to be transferred\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function approveAndCall(address spender, uint256 amount) public virtual  returns (bool) {\n', '        return approveAndCall(spender, amount, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\n', '     * @param spender The address allowed to transfer to.\n', '     * @param amount The amount allowed to be transferred.\n', '     * @param data Additional data with no specified format.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function approveAndCall(address spender, uint256 amount, bytes memory data) public virtual  returns (bool) {\n', '        approve(spender, amount);\n', '        require(_checkAndCallApprove(spender, amount, data), "ERC1363: _checkAndCallApprove reverts");\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onTransferReceived` on a target address\n', '     *  The call is not executed if the target address is not a contract\n', '     * @param sender address Representing the previous owner of the given token value\n', '     * @param recipient address Target address that will receive the tokens\n', '     * @param amount uint256 The amount mount of tokens to be transferred\n', '     * @param data bytes Optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkAndCallTransfer(address sender, address recipient, uint256 amount, bytes memory data) internal virtual returns (bool) {\n', '        if (!isContract(recipient)) {\n', '            return false;\n', '        }\n', '        bytes4 retval = IERC1363Receiver(recipient).onTransferReceived(\n', '            _msgSender(), sender, amount, data\n', '        );\n', '        return (retval == _ERC1363_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onApprovalReceived` on a target address\n', '     *  The call is not executed if the target address is not a contract\n', '     * @param spender address The address which will spend the funds\n', '     * @param amount uint256 The amount of tokens to be spent\n', '     * @param data bytes Optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkAndCallApprove(address spender, uint256 amount, bytes memory data) internal virtual returns (bool) {\n', '        if (!isContract(spender)) {\n', '            return false;\n', '        }\n', '        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(\n', '            _msgSender(), amount, data\n', '        );\n', '        return (retval == _ERC1363_APPROVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * returns msg.sender\n', '     */\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    /**\n', '     * returns msg.data\n', '     */\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}']