['// SPDX-License-Identifier: GPL3\n', 'pragma solidity 0.8.0;\n', '\n', "import './MateriaOperator.sol';\n", "import './IMateriaOrchestrator.sol';\n", "import './IMateriaFactory.sol';\n", "import './IMateriaPair.sol';\n", "import './IERC20.sol';\n", "import './IERC20WrapperV1.sol';\n", '\n', "import './MateriaLibrary.sol';\n", "import './TransferHelper.sol';\n", '\n', 'contract MateriaLiquidityAdder is MateriaOperator {\n', '    function _addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin\n', '    ) private returns (uint256 amountA, uint256 amountB) {\n', '        address factory = address(IMateriaOrchestrator(address(this)).factory());\n', '\n', "        // create the pair if it doesn't exist yet\n", '        if (IMateriaFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n', '            IMateriaFactory(factory).createPair(tokenA, tokenB);\n', '        }\n', '        (uint256 reserveA, uint256 reserveB) = MateriaLibrary.getReserves(address(factory), tokenA, tokenB);\n', '        if (reserveA == 0 && reserveB == 0) {\n', '            (amountA, amountB) = (amountADesired, amountBDesired);\n', '        } else {\n', '            uint256 amountBOptimal = MateriaLibrary.quote(amountADesired, reserveA, reserveB);\n', '            if (amountBOptimal <= amountBDesired) {\n', "                require(amountBOptimal >= amountBMin, 'INSUFFICIENT_B_AMOUNT');\n", '                (amountA, amountB) = (amountADesired, amountBOptimal);\n', '            } else {\n', '                uint256 amountAOptimal = MateriaLibrary.quote(amountBDesired, reserveB, reserveA);\n', '                assert(amountAOptimal <= amountADesired);\n', "                require(amountAOptimal >= amountAMin, 'INSUFFICIENT_A_AMOUNT');\n", '                (amountA, amountB) = (amountAOptimal, amountBDesired);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doAddLiquidity(\n', '        address token,\n', '        address bridgeToken,\n', '        uint256 tokenAmountDesired,\n', '        uint256 bridgeAmountDesired,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to\n', '    )\n', '        private\n', '        returns (\n', '            uint256 tokenAmount,\n', '            uint256 bridgeAmount,\n', '            uint256 liquidity\n', '        )\n', '    {\n', '        (tokenAmount, bridgeAmount) = _addLiquidity(\n', '            token,\n', '            bridgeToken,\n', '            tokenAmountDesired,\n', '            bridgeAmountDesired,\n', '            tokenAmountMin,\n', '            bridgeAmountMin\n', '        );\n', '\n', '        address pair =\n', '            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\n', '        TransferHelper.safeTransfer(token, pair, tokenAmount);\n', '        TransferHelper.safeTransferFrom(bridgeToken, msg.sender, pair, bridgeAmount);\n', '        liquidity = IMateriaPair(pair).mint(to);\n', '    }\n', '\n', '    function addLiquidity(\n', '        address token,\n', '        uint256 tokenAmountDesired,\n', '        uint256 bridgeAmountDesired,\n', '        uint256 tokenAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) public ensure(deadline) {\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        address interoperable;\n', '\n', '        tokenAmountMin = _adjustAmount(token, tokenAmountMin);\n', '\n', '        TransferHelper.safeTransferFrom(token, msg.sender, address(this), tokenAmountDesired);\n', '        (interoperable, tokenAmountDesired) = _wrapErc20(token, tokenAmountDesired, erc20Wrapper);\n', '\n', '        (uint256 tokenAmount, , ) =\n', '            _doAddLiquidity(\n', '                interoperable,\n', '                address(IMateriaOrchestrator(address(this)).bridgeToken()),\n', '                tokenAmountDesired,\n', '                bridgeAmountDesired,\n', '                tokenAmountMin,\n', '                bridgeAmountMin,\n', '                to\n', '            );\n', '\n', '        uint256 dust = tokenAmountDesired - tokenAmount;\n', '        if (dust > 0) _unwrapErc20(IERC20WrapperV1(erc20Wrapper).object(token), token, dust, erc20Wrapper, msg.sender);\n', '    }\n', '\n', '    function addLiquidityETH(\n', '        uint256 bridgeAmountDesired,\n', '        uint256 ethAmountMin,\n', '        uint256 bridgeAmountMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        public\n', '        payable\n', '        ensure(deadline)\n', '        returns (\n', '            uint256 ethAmount,\n', '            uint256 bridgeAmount,\n', '            uint256 liquidity\n', '        )\n', '    {\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\n', '\n', '        address ieth =\n', '            address(\n', '                IERC20WrapperV1(erc20Wrapper).asInteroperable(\n', '                    uint256(IMateriaOrchestrator(address(this)).ETHEREUM_OBJECT_ID())\n', '                )\n', '            );\n', '\n', '        (ethAmount, bridgeAmount) = _addLiquidity(\n', '            ieth,\n', '            bridgeToken,\n', '            msg.value,\n', '            bridgeAmountDesired,\n', '            ethAmountMin,\n', '            bridgeAmountMin\n', '        );\n', '\n', '        _wrapEth(ethAmount, erc20Wrapper);\n', '\n', '        address pair =\n', '            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), ieth, bridgeToken);\n', '        TransferHelper.safeTransfer(ieth, pair, ethAmount);\n', '        TransferHelper.safeTransferFrom(bridgeToken, msg.sender, pair, bridgeAmount);\n', '        liquidity = IMateriaPair(pair).mint(to);\n', '\n', '        uint256 dust;\n', '        if ((dust = msg.value - ethAmount) > 0) TransferHelper.safeTransferETH(msg.sender, dust);\n', '    }\n', '\n', '    function addLiquidityItem(\n', '        uint256 itemId,\n', '        uint256 value,\n', '        address from,\n', '        bytes memory payload\n', '    ) private returns (uint256 itemAmount, uint256 bridgeAmount) {\n', '        address erc20Wrapper = address(IMateriaOrchestrator(address(this)).erc20Wrapper());\n', '        address bridgeToken = address(IMateriaOrchestrator(address(this)).bridgeToken());\n', '\n', '        uint256 bridgeAmountDesired;\n', '        address to;\n', '        uint256 deadline;\n', '        address token;\n', '\n', '        (bridgeAmountDesired, itemAmount, bridgeAmount, to, deadline) = abi.decode(\n', '            payload,\n', '            (uint256, uint256, uint256, address, uint256)\n', '        );\n', '\n', '        _ensure(deadline);\n', '\n', '        (itemAmount, bridgeAmount) = _addLiquidity(\n', '            (token = address(IERC20WrapperV1(erc20Wrapper).asInteroperable(itemId))),\n', '            bridgeToken,\n', '            value,\n', '            bridgeAmountDesired,\n', '            itemAmount,\n', '            bridgeAmount\n', '        );\n', '\n', '        address pair =\n', '            MateriaLibrary.pairFor(address(IMateriaOrchestrator(address(this)).factory()), token, bridgeToken);\n', '        TransferHelper.safeTransfer(token, pair, itemAmount);\n', '        TransferHelper.safeTransferFrom(bridgeToken, from, pair, bridgeAmount);\n', '        IMateriaPair(pair).mint(to);\n', '\n', '        // value now is for the possible dust\n', '        if ((value = value - itemAmount) > 0) TransferHelper.safeTransfer(token, from, value);\n', '        if ((value = bridgeAmountDesired - bridgeAmount) > 0) TransferHelper.safeTransfer(bridgeToken, from, value);\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    ) public override returns (bytes4) {\n', '        uint256 operation;\n', '        bytes memory payload;\n', '\n', '        (operation, payload) = abi.decode(data, (uint256, bytes));\n', '\n', '        if (operation == 1) {\n', '            addLiquidityItem(id, value, from, payload);\n', '        } else revert();\n', '\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        bytes calldata\n', '    ) public pure override returns (bytes4) {\n', '        revert();\n', '    }\n', '\n', '    function supportsInterface(bytes4) public pure override returns (bool) {\n', '        return false;\n', '    }\n', '}']