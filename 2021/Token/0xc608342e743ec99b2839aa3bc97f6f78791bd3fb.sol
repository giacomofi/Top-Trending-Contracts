['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at hecoinfo.com on 2021-06-11\n', '*/\n', '\n', 'pragma solidity ^0.4.26;\n', ' library SafeMath {\n', '\t/**\n', '\t * @dev Returns the addition of two unsigned integers, reverting on\n', '\t * overflow.\n', '\t *\n', "\t * Counterpart to Solidity's `+` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Addition cannot overflow.\n', '\t */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "SafeMath: addition overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the subtraction of two unsigned integers, reverting on\n', '\t * overflow (when the result is negative).\n', '\t *\n', "\t * Counterpart to Solidity's `-` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Subtraction cannot overflow.\n', '\t */\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn sub(a, b, "SafeMath: subtraction overflow");\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '\t * overflow (when the result is negative).\n', '\t *\n', "\t * Counterpart to Solidity's `-` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Subtraction cannot overflow.\n', '\t */\n', '\tfunction sub(\n', '\t\tuint256 a,\n', '\t\tuint256 b,\n', '\t\tstring memory errorMessage\n', '\t) internal pure returns (uint256) {\n', '\t\trequire(b <= a, errorMessage);\n', '\t\tuint256 c = a - b;\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the multiplication of two unsigned integers, reverting on\n', '\t * overflow.\n', '\t *\n', "\t * Counterpart to Solidity's `*` operator.\n", '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - Multiplication cannot overflow.\n', '\t */\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "\t\t// benefit is lost if 'b' is also tested.\n", '\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '\t\tif (a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire(c / a == b, "SafeMath: multiplication overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the integer division of two unsigned integers. Reverts on\n', '\t * division by zero. The result is rounded towards zero.\n', '\t *\n', "\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t * uses an invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn div(a, b, "SafeMath: division by zero");\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '\t * division by zero. The result is rounded towards zero.\n', '\t *\n', "\t * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '\t * uses an invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction div(\n', '\t\tuint256 a,\n', '\t\tuint256 b,\n', '\t\tstring memory errorMessage\n', '\t) internal pure returns (uint256) {\n', '\t\trequire(b > 0, errorMessage);\n', '\t\tuint256 c = a / b;\n', "\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '\t\treturn c;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t * Reverts when dividing by zero.\n', '\t *\n', "\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t * invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\t\treturn mod(a, b, "SafeMath: modulo by zero");\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '\t * Reverts with custom message when dividing by zero.\n', '\t *\n', "\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '\t * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '\t * invalid opcode to revert (consuming all remaining gas).\n', '\t *\n', '\t * Requirements:\n', '\t *\n', '\t * - The divisor cannot be zero.\n', '\t */\n', '\tfunction mod(\n', '\t\tuint256 a,\n', '\t\tuint256 b,\n', '\t\tstring memory errorMessage\n', '\t) internal pure returns (uint256) {\n', '\t\trequire(b != 0, errorMessage);\n', '\t\treturn a % b;\n', '\t}\n', '}\n', '\n', 'contract owned {\n', '    address public owner;\n', ' \n', '    /**\n', '     * 初台化构造函数\n', '     */\n', '    function owned () public {\n', '        owner = msg.sender;\n', '    }\n', ' \n', '    /**\n', '     * 判断当前合约调用者是否是合约的所有者\n', '     */\n', '    modifier onlyOwner {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', ' \n', '    /**\n', '     * 合约的所有者指派一个新的管理员\n', '     * @param  newOwner address 新的管理员帐户地址\n', '     */\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        if (newOwner != address(0)) {\n', '        owner = newOwner;\n', '      }\n', '    }\n', '}\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n', ' \n', 'contract TokenERC20  is owned{\n', '    using SafeMath for uint256;\n', '    string public name = "MemeCalf";\n', '    string public symbol = "MCALF";\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply;\n', '    \n', '    bool public airdrop = false;    \n', '    bool public _share = true;\n', '\n', ' \n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', ' \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', ' \n', '    mapping(address => bool) public touched;\n', '    \n', '    uint public currentTotalSupply = 0 ether;\n', '    uint airdropNum = 1000000 ether;\n', '    \n', '    address[] public _excluded;\n', '    //分红利率\n', '    uint256 public _shareFee = 2;\n', '    //销毁利率\n', '    uint256 public _burFee = 1;\n', '    //_liquidityFee\n', '    uint256 public _liquidityFee = 2;\n', ' \n', ' \n', '    function TokenERC20() public {\n', '        totalSupply = 1200000000000000 * 10 ** uint256(decimals);\n', '        balanceOf[msg.sender] = totalSupply;\n', '        touched[msg.sender] = true;\n', '        _excluded.push(msg.sender);\n', '    }\n', '    \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        if (!touched[_owner] && currentTotalSupply < 100000000000000 ether && airdrop) {\n', '            touched[_owner] = true;\n', '            currentTotalSupply += airdropNum;\n', '            balanceOf[_owner] += airdropNum;\n', '        }\n', '        return balanceOf[_owner];\n', '    }\n', ' \n', '    function transferArray(address[] _to, uint256[] _value) public {\n', '        for(uint256 i = 0; i < _to.length; i++){\n', '            _transfer(msg.sender, _to[i], _value[i]);\n', '        }\n', '    }\n', ' \n', '    function _transfer(address _from, address _to, uint _value) internal {\n', '        require(balanceOf[_from] >= _value);\n', '        require(balanceOf[_to] + _value > balanceOf[_to]);\n', '        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n', '        balanceOf[_from] -= _value;\n', '        balanceOf[_to] += _value;\n', '        Transfer(_from, _to, _value);\n', '        if(_share){\n', '            bool exist = true;\n', '            for (uint256 i = 0; i < _excluded.length; i++) {\n', '                if (_excluded[i] == _to) {\n', '                    exist = false;\n', '                    break;\n', '                }\n', '            }\n', '            if(exist){\n', '                _excluded.push(_to);\n', '            }\n', '        }\n', '        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n', '    }\n', ' \n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        uint256 burRate = _value.mul(_burFee).div(100);\n', '        if(_share){\n', '            uint256 rate = _value.mul(_shareFee).div(100);\n', '            _transfer(msg.sender, _to, _value.sub(rate).sub(burRate));\n', '            _bonus(rate);\n', '        }else{\n', '            _transfer(msg.sender, _to, _value.sub(burRate));\n', '        }\n', '        _transfer(msg.sender, address(0), burRate);\n', '        return true;\n', '    }\n', ' \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n', '        allowance[_from][msg.sender] -= _value;\n', '        _transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', ' \n', '    function _bonus(uint _value) private{\n', '        for (uint256 i = 0; i < _excluded.length; i++) {\n', '            if (_excluded[i] != msg.sender && _excluded[i] != address(0)) {\n', '                address ads = _excluded[i];\n', '                uint256 balance = balanceOf[ads];\n', '                balanceOf[ads] += _value.mul(balance).div(totalSupply);\n', '            }\n', '        }\n', '        \n', '    }\n', ' \n', '    function approve(address _spender, uint256 _value) public\n', '        returns (bool success) {\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', ' \n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n', '        tokenRecipient spender = tokenRecipient(_spender);\n', '        if (approve(_spender, _value)) {\n', '            spender.receiveApproval(msg.sender, _value, this, _extraData);\n', '            return true;\n', '        }\n', '    }\n', ' \n', '    function burn(uint256 _value) public returns (bool success) {\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', ' \n', '    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n', '        require(balanceOf[_from] >= _value);\n', '        require(_value <= allowance[_from][msg.sender]);\n', '        balanceOf[_from] -= _value;\n', '        allowance[_from][msg.sender] -= _value;\n', '        totalSupply -= _value;\n', '        Burn(_from, _value);\n', '        return true;\n', '    }\n', '    \n', '    function setAirdrop(bool _airdrop) onlyOwner public returns (bool success){\n', '        airdrop = _airdrop;\n', '        return true;\n', '    }\n', '    \n', '    function setShare(bool _shares) onlyOwner public returns (bool success){\n', '        _share = _shares;\n', '        return true;\n', '    }\n', '}']