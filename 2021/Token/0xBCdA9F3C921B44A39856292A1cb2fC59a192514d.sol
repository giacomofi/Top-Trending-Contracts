['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./Context.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Address.sol";\n', 'import "./Events.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract DAQ is Context, IERC20, Events {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  address contractOwner;\n', '\n', '  mapping(address => uint256) private _balances;\n', '  mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '  address[] private _addressList;\n', '  mapping(address => bool) private _isOnAddressList;\n', '\n', '  uint256 private _totalSupply;\n', '  string private _name;\n', '  string private _symbol;\n', '  uint8 private _decimals;\n', '  bool private _washedOut;\n', '\n', '  /**\n', '   * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '   * a default value of 18.\n', '   *\n', '   * To select a different value for {decimals}, use {_setupDecimals}.\n', '   *\n', '   * All three of these values are immutable: they can only be set once during\n', '   * construction.\n', '   */\n', '  constructor (uint256 totalSupply_) {\n', "    _name = 'Tixx Benefit Token';\n", "    _symbol = 'Tixx';\n", '    _decimals = 9;\n', '    _washedOut = false;\n', '    // set the contract owner\n', '    contractOwner = msg.sender;\n', '    _totalSupply = totalSupply_;\n', '    _balances[msg.sender] = totalSupply_;\n', '  }\n', '\n', '  // When attached to a function, restricts the calls to that function only to the contract owner\n', '  modifier onlyOwner {\n', '    require(msg.sender == contractOwner, "Only owner can call this function.");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the name of the token.\n', '   */\n', '  function name() public view returns (string memory) {\n', '    return _name;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the symbol of the token, usually a shorter version of the\n', '   * name.\n', '   */\n', '  function symbol() public view returns (string memory) {\n', '    return _symbol;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of decimals used to get its user representation.\n', '   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '   *\n', '   * Tokens usually opt for a value of 18, imitating the relationship between\n', '   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '   * called.\n', '   *\n', '   * NOTE: This information is only used for _display_ purposes: it in\n', '   * no way affects any of the arithmetic of the contract, including\n', '   * {IERC20-balanceOf} and {IERC20-transfer}.\n', '   */\n', '  function decimals() public view returns (uint8) {\n', '    return _decimals;\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-totalSupply}.\n', '   */\n', '  function totalSupply() public view override returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '\n', '  /**\n', '   * Calls the internal _mint function to generate the given amount of tokens and add them to the total supply.\n', "   * The tokens are added to the contract owner's address.\n", '   */\n', '  function mint(uint256 amount) public onlyOwner returns (bool){\n', '    _mint(contractOwner, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Sets the global variable _washedOut to true, meaning that all other functions that manage funds will not be\n', '   * executing.\n', '   * Also, the total supply is set to zero, so transferring tokens from the contract to users cannot happen.\n', '   */\n', '  function washout() public onlyOwner returns (bool) {\n', '    require(!_washedOut, "Total burn has already been executed");\n', '\n', '    _totalSupply = 0;\n', '    _washedOut = true;\n', '\n', '    emit Washout();\n', '    return true;\n', '  }\n', '\n', '  /**\n', "   * Burns a given amount ot tokens from the contract owner's address.\n", '   */\n', '  function burn(uint256 amount) public onlyOwner returns (bool) {\n', '    _burn(contractOwner, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * The the total count of the addresses in the list of addresses of the contract.\n', '   */\n', '  function getAddressCount() public view onlyOwner returns (uint count) {\n', '    return _addressList.length;\n', '  }\n', '\n', '  /**\n', '   * Get a given address at an index of the list of addresses.\n', '   */\n', '  function getAddressAtRow(uint row) public view onlyOwner returns (address theAddress) {\n', '    return _addressList[row];\n', '  }\n', '\n', '  /**\n', '   * Get the full list of addresses in the contract.\n', '   */\n', '  function getAddresses() public view onlyOwner returns (address[] memory) {\n', '    return _addressList;\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-balanceOf}.\n', '   */\n', '  function balanceOf(address account) public view override returns (uint256) {\n', '    return _balances[account];\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-transfer}.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `recipient` cannot be the zero address.\n', '   * - the caller must have a balance of at least `amount`.\n', '   */\n', '  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '    _transfer(_msgSender(), recipient, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-allowance}.\n', '   */\n', '  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '    return _allowances[owner][spender];\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-approve}.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `spender` cannot be the zero address.\n', '   */\n', '  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '    _approve(_msgSender(), spender, amount);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev See {IERC20-transferFrom}.\n', '   *\n', '   * Emits an {Approval} event indicating the updated allowance. This is not\n', '   * required by the EIP. See the note at the beginning of {ERC20};\n', '   *\n', '   * Requirements:\n', '   * - `sender` and `recipient` cannot be the zero address.\n', '   * - `sender` must have a balance of at least `amount`.\n', "   * - the caller must have allowance for ``sender``'s tokens of at least\n", '   * `amount`.\n', '   */\n', '  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '    _transfer(sender, recipient, amount);\n', '    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '   *\n', '   * This is an alternative to {approve} that can be used as a mitigation for\n', '   * problems described in {IERC20-approve}.\n', '   *\n', '   * Emits an {Approval} event indicating the updated allowance.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `spender` cannot be the zero address.\n', '   */\n', '  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '   *\n', '   * This is an alternative to {approve} that can be used as a mitigation for\n', '   * problems described in {IERC20-approve}.\n', '   *\n', '   * Emits an {Approval} event indicating the updated allowance.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `spender` cannot be the zero address.\n', '   * - `spender` must have allowance for the caller of at least\n', '   * `subtractedValue`.\n', '   */\n', '  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * Checks if the given address is already on the list of addresses, by checking if the address exists in the mapping\n', '   * signifying that the address is on the list of addresses.\n', '   */\n', '  function _isAddressPresent(address check) internal view returns (bool addressIsPresent) {\n', '    return _isOnAddressList[check];\n', '  }\n', '\n', '  /**\n', '   * Appends the given address to the list of addresses in the contract, and also to the mapping signifying whether\n', '   * the address is on the list.\n', '   */\n', '  function _appendAddressToList(address newAddress) internal virtual {\n', '    if (!_isAddressPresent(newAddress)) {\n', '      _addressList.push(newAddress);\n', '      _isOnAddressList[newAddress] = true;\n', '\n', '      emit NewAddressAppended(newAddress);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '   *\n', '   * This is internal function is equivalent to {transfer}, and can be used to\n', '   * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `sender` cannot be the zero address.\n', '   * - `recipient` cannot be the zero address.\n', '   * - `sender` must have a balance of at least `amount`.\n', '   */\n', '  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '    require(sender != address(0), "ERC20: transfer from the zero address");\n', '    require(recipient != address(0), "ERC20: transfer to the zero address");\n', '    if (recipient != contractOwner) {\n', '      require(!_washedOut, "All tokes have been burned");\n', '    }\n', '\n', '    _appendAddressToList(recipient);\n', '\n', '    _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '    _balances[recipient] = _balances[recipient].add(amount);\n', '    emit Transfer(sender, recipient, amount);\n', '  }\n', '\n', '  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '   * the total supply.\n', '   *\n', '   * Emits a {Transfer} event with `from` set to the zero address.\n', '   *\n', '   * Requirements\n', '   *\n', '   * - `to` cannot be the zero address.\n', '   */\n', '  function _mint(address account, uint256 amount) internal virtual {\n', '    require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '    _totalSupply = _totalSupply.add(amount);\n', '    _balances[account] = _balances[account].add(amount);\n', '    emit Transfer(address(0), account, amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Destroys `amount` tokens from `account`, reducing the\n', '   * total supply.\n', '   *\n', '   * Emits a {Transfer} event with `to` set to the zero address.\n', '   *\n', '   * Requirements\n', '   *\n', '   * - `account` cannot be the zero address.\n', '   * - `account` must have at least `amount` tokens.\n', '   */\n', '  function _burn(address account, uint256 amount) internal virtual {\n', '    require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '    _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '    _totalSupply = _totalSupply.sub(amount);\n', '    emit Transfer(account, address(0), amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '   *\n', '   * This internal function is equivalent to `approve`, and can be used to\n', '   * e.g. set automatic allowances for certain subsystems, etc.\n', '   *\n', '   * Emits an {Approval} event.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `owner` cannot be the zero address.\n', '   * - `spender` cannot be the zero address.\n', '   */\n', '  function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '    require(owner != address(0), "ERC20: approve from the zero address");\n', '    require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '    _allowances[owner][spender] = amount;\n', '    emit Approval(owner, spender, amount);\n', '  }\n', '}']