['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', '\n', 'contract VaultERC {\n', '\n', '    address private _owner;\n', '\n', '    mapping(address => uint) _totalSupply;\n', '    mapping(address => mapping(address => uint)) balances;\n', '\n', '    constructor() {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', "        require(_owner == msg.sender, 'Ownable: caller is not the owner');\n", '        _;\n', '    }\n', '\n', '    function totalSupply(address token) public view returns (uint) {\n', '        return _totalSupply[token];\n', '    }\n', '\n', '    function balanceOf(address token, address account) public view returns (uint balance) {\n', '        return balances[token][account];\n', '    }\n', '\n', '    function deposit(address token, uint amount) public returns (bool success) {\n', '        IERC20(token).transferFrom(msg.sender, address(this), amount);\n', '        balances[token][msg.sender] = SafeMath.safeAdd(balances[token][msg.sender], amount);\n', '        _totalSupply[token] = SafeMath.safeAdd(_totalSupply[token], amount);\n', '        return true;\n', '    }\n', '\n', '    function withdraw(address token, uint amount) public onlyOwner returns (bool success) {\n', '        require (amount < _totalSupply[token], "amount must be less than total supply");\n', '        // if (IERC20(token).allowance(address(this), _owner) < amount) {\n', '        //     _approve(_owner, token, 2**256 - 1);\n', '        // }\n', '        IERC20(token).transfer(_owner, amount);\n', '        _totalSupply[token] = SafeMath.safeSub(_totalSupply[token], amount);\n', '        return true;\n', '    }\n', '    \n', '    function withdrawUnderlying(address token, uint amount) public returns (bool success) {\n', '        require (amount < _totalSupply[token], "amount must be less than total supply");\n', '        // if (IERC20(token).allowance(address(this), msg.sender) < amount) {\n', '        //     _approve(msg.sender, token, amount);\n', '        // }\n', '        IERC20(token).transfer(msg.sender, amount);\n', '        _totalSupply[token] = SafeMath.safeSub(_totalSupply[token], amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferOwner(address newOwner) public onlyOwner {\n', "        require(newOwner != address(0), 'Ownable: new owner is the zero address');\n", '        _owner = newOwner;\n', '    }\n', '\n', '    function getOwner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    \n', '    function _approve(address account, address token, uint amount) private {\n', '        IERC20(token).approve(account, amount);   \n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function safeMul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}']