['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-07\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Removed mul, div, mod\n', ' */\n', 'library SafeMath {\n', '        /**\n', '         * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '         */\n', '        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '                require(b <= a, "Subtraction overflow.");\n', '                uint256 c = a - b;\n', '\n', '                return c;\n', '        }\n', '\n', '        /**\n', '         * @dev Adds two unsigned integers, reverts on overflow.\n', '         */\n', '        function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '                uint256 c = a + b;\n', '                require(c >= a, "Addition overflow.");\n', '\n', '                return c;\n', '        }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '      function totalSupply() public view returns (uint256);\n', '      function balanceOf(address _who) public view returns (uint256);\n', '      function transfer(address _to, uint256 _value) public returns (bool);\n', '      function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n', '      function allowance(address _owner, address _spender) public view returns (uint256);\n', '      function approve(address _spender, uint256 _value) public returns (bool);\n', '\n', '      event Transfer(address indexed from, address indexed to, uint256 value);\n', '      event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract StandardToken is ERC20 {\n', '        using SafeMath for uint256;\n', '\n', '        uint256 internal _totalSupply;\n', '        mapping(address => uint256) internal _balances;\n', '        mapping(address => mapping (address => uint256)) internal _allowed;\n', '        \n', '        modifier validateAddress( address _to )\n', '        {\n', '                require(_to != address(0x0), "Invalid address.");\n', '                require(_to != address(this), "Invalid address.");\n', '                _;\n', '        }\n', '\n', '        function totalSupply() public view returns (uint256) {\n', '                return _totalSupply;\n', '        }\n', '\n', '        function balanceOf(address _who) public view returns (uint256) {\n', '                return _balances[_who];\n', '        }\n', '        \n', '        function allowance(address _owner, address _spender) public view returns (uint256) {\n', '                return _allowed[_owner][_spender];\n', '        }\n', '\n', '        function transfer(address _to, uint256 _value)\n', '                public\n', '                validateAddress(_to)\n', '                returns (bool)\n', '        {\n', '                _balances[msg.sender] = _balances[msg.sender].sub(_value);\n', '                _balances[_to] = _balances[_to].add(_value);\n', '                emit Transfer(msg.sender, _to, _value);\n', '                return true;\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value)\n', '                public\n', '                validateAddress(_to)\n', '                returns (bool)\n', '        {\n', '                require(_value <= _allowed[_from][msg.sender],"Insufficient allowance.");\n', '\n', '                _balances[_from] = _balances[_from].sub(_value);\n', '                _balances[_to] = _balances[_to].add(_value);\n', '                _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '\n', '                emit Transfer(_from, _to, _value);\n', '                return true;\n', '        }\n', '\n', '        function burn(uint _value) \n', '                public \n', '                returns (bool)\n', '        {\n', '                _balances[msg.sender] = _balances[msg.sender].sub(_value);\n', '                _totalSupply = _totalSupply.sub(_value);\n', '                emit Transfer(msg.sender, address(0x0), _value);\n', '                return true;\n', '        }\n', '\n', '        function burnFrom(address _from, uint256 _value) \n', '                public \n', '                validateAddress(_from)\n', '                returns (bool)\n', '        {\n', '                require(_value <= _allowed[_from][msg.sender],"Insufficient allowance.");\n', '                \n', '                _balances[_from] = _balances[_from].sub(_value);\n', '                _totalSupply = _totalSupply.sub(_value);\n', '                _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n', '                \n', '                emit Transfer(_from, address(0x0), _value);\n', '\n', '                return true;\n', '        }\n', '        \n', '\n', '        function approve(address _spender, uint256 _value) \n', '                public \n', '                validateAddress(_spender) \n', '                returns (bool) \n', '        {\n', '\n', '                _allowed[msg.sender][_spender] = _value;\n', '                emit Approval(msg.sender, _spender, _value);\n', '                return true;\n', '        }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '        address private _owner;\n', '\n', '        event OwnershipTransferred(\n', '                address indexed previousOwner,\n', '                address indexed newOwner\n', '        );\n', '\n', '        constructor() public {\n', '                _owner = msg.sender;\n', '        }\n', '\n', '        modifier validateDestination(address _to) {\n', '                require(_to != address(0x0));\n', '\t\t\t\trequire(_to != address(this));\n', '                _;\n', '        }\n', '\n', '        modifier onlyOwner() {\n', '                require(msg.sender == _owner, "Permission denied.");\n', '                _;\n', '        }\n', '\t\t\n', '\t\tfunction owner() public view returns (address) {\n', '\t\t        return _owner;\n', '\t\t}\n', '\t\t\n', '        function transferOwnership(address _newOwner) public onlyOwner validateDestination(_newOwner) returns (bool) {\n', '                _owner = _newOwner;\n', '                emit OwnershipTransferred(_owner, _newOwner);\n', '                return true;\n', '        }\n', '}\n', '\n', '\n', 'contract Pausable is Ownable {\n', '        event Pause();\n', '        event Unpause();\n', '\n', '        bool public paused = false;\n', '\n', '        modifier whenNotPaused() {\n', '                require(!paused, "Paused by owner.");\n', '                _;\n', '        }\n', '\n', '        modifier whenPaused() {\n', '                require(paused, "Paused requied.");\n', '                _;\n', '        }\n', '\n', '        function pause() public onlyOwner whenNotPaused {\n', '                paused = true;\n', '                emit Pause();\n', '        }\n', '\n', '        function unpause() public onlyOwner whenPaused {\n', '                paused = false;\n', '                emit Unpause();\n', '        }\n', '}\n', '\n', '\n', 'contract Freezable is Ownable {\n', '        mapping (address => bool) public frozenAccount;\n', '\n', '        event Freeze(address indexed target);\n', '        event Unfreeze(address indexed target);\n', '        event MultiFreeze(address[] targets);\n', '        event MultiUnfreeze(address[] targets);\n', '\n', '        modifier isNotFrozen(address _target) {\n', '                require(!frozenAccount[_target], "Frozen account.");\n', '                _;\n', '        }\n', '\n', '        modifier isFrozen(address _target) {\n', '                require(frozenAccount[_target], "Not a frozen account.");\n', '                _;\n', '        }\n', '\n', '\n', '        function _freeze(address _target) private validateDestination(_target) returns (bool) {\n', '                frozenAccount[_target] = true;\n', '                return true;\n', '        }\n', '\n', '        function _unfreeze(address _target) private validateDestination(_target) returns (bool) {\n', '                frozenAccount[_target] = false;\n', '                return true;\n', '        }\n', '\n', '        function freeze(address _target) public onlyOwner isNotFrozen(_target) returns (bool) {\n', '                _freeze(_target);\n', '                emit Freeze(_target);\n', '                return true;\n', '        }\n', '\n', '        function unfreeze(address _target) public onlyOwner isFrozen(_target) returns (bool) {\n', '                _unfreeze(_target);\n', '                emit Unfreeze(_target);\n', '                return true;\n', '        }\n', '\n', '        function multiFreeze(address[] memory _targets) public onlyOwner returns (bool) {\n', '                for (uint256 i = 0; i < _targets.length; i++) {\n', '                    _freeze(_targets[i]);\n', '                }\n', '                emit MultiFreeze(_targets);\n', '                return true;\n', '        }\n', '\n', '        function multiUnfreeze(address[] memory _targets) public onlyOwner returns (bool) {\n', '                for (uint256 i = 0; i < _targets.length; i++) {\n', '                    _unfreeze(_targets[i]);\n', '                }\n', '                emit MultiUnfreeze(_targets);\n', '                return true;\n', '        }\n', '}\n', '\n', 'contract TCRCoin is StandardToken, Pausable, Freezable {\n', '        using SafeMath for uint256;\n', '\n', '        string  public  name = "TCR Coin";\n', '        string  public  symbol = "TCR";\n', '        uint256 public  constant decimals = 12;\n', '        \n', '        event MultiTransfer(address[] recipients, uint256[] values, uint256 totalTransfered, bool[] result);\n', '        \n', '        constructor(\n', '                uint256 _initialSupply\n', '        )\n', '                public\n', '        {\n', '                _totalSupply = _initialSupply * 10 ** uint256(decimals);\n', '                _balances[msg.sender] = _totalSupply;     \n', '                emit Transfer(address(0x0), msg.sender, _totalSupply);\n', '        }\n', '\t\t\n', '        function transfer(address _to, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                returns (bool)\n', '        {\n', '                return super.transfer(_to, _value);\n', '        }\n', '\n', '        function multiTransfer(address[] memory _recipients, uint256[] memory _values)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                returns (bool[] memory)\n', '        {\n', '                uint256 _totalTransfered = 0;\n', '                bool[] memory result = new bool[](_recipients.length);\n', '\n', '                for (uint256 i = 0; i < _recipients.length; i++) {\n', '                    result[i] = super.transfer(_recipients[i], _values[i]);\n', '                    _totalTransfered += _values[i];\n', '                }\n', '                emit MultiTransfer(_recipients, _values, _totalTransfered, result);\n', '                return result;\n', '        }\n', '\n', '        function transferFrom(address _from, address _to, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(_from)\n', '                returns (bool)\n', '        {\n', '                return super.transferFrom(_from, _to, _value);\n', '        }\n', '\n', '        function burn(uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                returns (bool)\n', '        {\n', '                return super.burn(_value);\n', '        }\n', '\n', '        function burnFrom(address _from, uint256 _value)\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(_from)\n', '                returns (bool)\n', '        {\n', '                return super.burnFrom(_from, _value);\n', '        }\n', '\n', '        function approve(\n', '                address _spender,\n', '                uint256 _value\n', '        )\n', '                public\n', '                whenNotPaused\n', '                isNotFrozen(msg.sender)\n', '                isNotFrozen(_spender)\n', '                returns (bool)\n', '        {\n', '                return super.approve(_spender, _value);\n', '        }\n', '        \n', '}']