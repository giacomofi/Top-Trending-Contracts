['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-20\n', '*/\n', '\n', '// File: contracts/I_Curve.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '/**\n', ' * @title   Interface Curve\n', ' * @notice  This contract acts as an interface to the curve contract. For\n', ' *          documentation please see the curve smart contract.\n', ' */\n', 'interface I_Curve {\n', '    \n', '    // -------------------------------------------------------------------------\n', '    // View functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to buy\n', '     * @return uint256 The cost to buy the _amount of tokens in the collateral\n', '     *         currency (see collateral token).\n', '     */\n', '    function buyPrice(uint256 _amount)\n', '        external\n', '        view\n', '        returns (uint256 collateralRequired);\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to sell\n', '     * @return collateralReward The reward for selling the _amount of tokens in the\n', '     *         collateral currency (see collateral token).\n', '     */\n', '    function sellReward(uint256 _amount)\n', '        external\n', '        view\n', '        returns (uint256 collateralReward);\n', '\n', '    /**\n', '      * @return If the curve is both active and initialised.\n', '      */\n', '    function isCurveActive() external view returns (bool);\n', '\n', '    /**\n', '      * @return The address of the collateral token (DAI)\n', '      */\n', '    function collateralToken() external view returns (address);\n', '\n', '    /**\n', '      * @return The address of the bonded token (BZZ).\n', '      */\n', '    function bondedToken() external view returns (address);\n', '\n', '    /**\n', '      * @return The required collateral amount (DAI) to initialise the curve.\n', '      */\n', '    function requiredCollateral(uint256 _initialSupply)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // State modifying functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function initializes the curve contract, and ensure the\n', '     *         curve has the required permissions on the token contract needed\n', '     *         to function.\n', '     */\n', '    function init() external;\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mint(uint256 _amount, uint256 _maxCollateralSpend)\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @param  _to The address to send the tokens to.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mintTo(\n', '        uint256 _amount, \n', '        uint256 _maxCollateralSpend, \n', '        address _to\n', '    )\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to sell.\n', '      * @param  _minCollateralReward The min amount of collateral (DAI) the user is\n', '      *         willing to receive for their tokens.\n', '      * @return The status of the burn. Note that should the total reward of the\n', '      *         burn be below the _minCollateralReward the transaction will revert.\n', '      */\n', '    function redeem(uint256 _amount, uint256 _minCollateralReward)\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @notice Shuts down the curve, disabling buying, selling and both price\n', '      *         functions. Can only be called by the owner. Will renounce the\n', '      *         minter role on the bonded token.\n', '      */\n', '    function shutDown() external;\n', '}\n', '\n', '// File: contracts/I_router_02.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '/**\n', '  * Please note that this interface was created as IUniswapV2Router02 uses\n', '  * Solidity >= 0.6.2, and the BZZ infastructure uses 0.5.0. \n', '  */\n', 'interface I_router_02 {\n', '    // Views & Pure\n', '    function WETH() external pure returns (address);\n', '\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '   \n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '\n', '    // State modifying\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        uint amountIn, \n', '        uint amountOutMin, \n', '        address[] calldata path, \n', '        address to, \n', '        uint deadline\n', '    )\n', '        external\n', '        returns (uint[] memory amounts);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/Eth_broker.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '\n', '\n', '\n', 'contract Eth_broker {\n', '    // The instance of the curve\n', '    I_Curve internal curve_;\n', '    // The instance of the Uniswap router\n', '    I_router_02 internal router_;\n', '    // The instance of the DAI token\n', '    IERC20 internal dai_;\n', '    // The address for the underlying token address\n', '    IERC20 internal bzz_;\n', '    // Mutex guard for state modifying functions\n', '    uint256 private status_;\n', '    // States for the guard \n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Events\n', '    // -------------------------------------------------------------------------\n', '\n', '    // Emitted when tokens are minted\n', '    event mintTokensWithEth(\n', '        address indexed buyer,      // The address of the buyer\n', '        uint256 amount,             // The amount of bonded tokens to mint\n', '        uint256 priceForTokensDai,  // The price in DAI for the token amount\n', '        uint256 EthTradedForDai,    // The ETH amount sold for DAI\n', '        uint256 maxSpendDai         // The max amount of DAI to spend\n', '    );\n', '    // Emitted when tokens are minted\n', '    event mintTokensToWithEth(\n', '        address indexed buyer,      // The address of the buyer\n', '        address indexed receiver,   // The address of the receiver of the tokens\n', '        uint256 amount,             // The amount of bonded tokens to mint\n', '        uint256 priceForTokensDai,  // The price in DAI for the token amount\n', '        uint256 EthTradedForDai,    // The ETH amount sold for DAI\n', '        uint256 maxSpendDai         // The max amount of DAI to spend\n', '    );\n', '    // Emitted when tokens are burnt\n', '    event burnTokensWithEth(\n', '        address indexed seller,     // The address of the seller\n', '        uint256 amount,             // The amount of bonded tokens to burn\n', '        uint256 rewardReceivedDai,  // The amount of DAI received for selling\n', '        uint256 ethReceivedForDai,  // How much ETH the DAI was traded for\n', '        uint256 minRewardDai        // The min amount of DAI to sell for\n', '    );\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Modifiers\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '      * @notice Checks if the curve is active (may be redundant).\n', '      */\n', '    modifier isCurveActive() {\n', '        require(curve_.isCurveActive(), "Curve inactive");\n', '        _;\n', '    }\n', '\n', '    /**\n', '      * @notice Protects against re-entrancy attacks\n', '      */\n', '    modifier mutex() {\n', '        require(status_ != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        // Any calls to non Reentrant after this point will fail\n', '        status_ = _ENTERED;\n', '        // Function executes\n', '        _;\n', '        // Status set to not entered\n', '        status_ = _NOT_ENTERED;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Constructor\n', '    // -------------------------------------------------------------------------\n', '\n', '    constructor(\n', '        address _bzzCurve, \n', '        address _collateralToken, \n', '        address _router02\n', '    ) \n', '        public \n', '    {\n', '        require(\n', '            _bzzCurve != address(0) &&\n', '            _collateralToken != address(0) &&\n', '            _router02 != address(0),\n', '            "Addresses of contracts cannot be 0x address"\n', '        );\n', '        curve_ = I_Curve(_bzzCurve);\n', '        dai_ = IERC20(_collateralToken);\n', '        router_ = I_router_02(_router02);\n', '        // Setting the address of the underlying token (BZZ)\n', '        bzz_ = IERC20(curve_.bondedToken());\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // View functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to buy\n', '     * @return uint256 The cost to buy the _amount of tokens in ETH\n', '     */\n', '    function buyPrice(uint256 _amount)\n', '        public\n', '        view\n', '        isCurveActive()\n', '        returns (uint256)\n', '    {\n', '        // Getting the current DAI cost for token amount\n', '        uint256 daiCost = curve_.buyPrice(_amount);\n', '        // Returning the required ETH to buy DAI amount\n', '        return router_.getAmountsIn(\n', '            daiCost, \n', '            getPath(true)\n', '        )[0];\n', '    }\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to sell\n', '     * @return uint256 The reward for selling the _amount of tokens in ETH\n', '     */\n', '    function sellReward(uint256 _amount)\n', '        public\n', '        view\n', '        isCurveActive()\n', '        returns (uint256)\n', '    {\n', '        // Getting the current DAI reward for token amount\n', '        uint256 daiReward = curve_.sellReward(_amount);\n', '        // Returning the ETH reward for token sale\n', '        return router_.getAmountsIn(\n', '            daiReward, \n', '            getPath(true)\n', '        )[0];\n', '    }\n', '    \n', '    /**\n', '      * @param  _daiAmount The amount of dai to be traded for ETH\n', '      * @return uint256 The amount of ETH that can be traded for given the\n', '      *         dai amount\n', '      */\n', '    function sellRewardDai(uint256 _daiAmount)\n', '        public\n', '        view\n', '        isCurveActive()\n', '        returns (uint256)\n', '    {\n', '        // Returning the ETH reward for the dai amount\n', '        return router_.getAmountsIn(\n', '            _daiAmount, \n', '            getPath(true)\n', '        )[0];\n', '    }\n', '    \n', '    /**\n', '      * @param  _buy If the path is for a buy or sell transaction\n', '      * @return address[] The path for the transaction\n', '      */\n', '    function getPath(bool _buy) public view returns(address[] memory) {\n', '        address[] memory buyPath = new address[](2);\n', '        if(_buy) {\n', '            buyPath[0] = router_.WETH();\n', '            buyPath[1] = address(dai_);\n', '        } else {\n', '            buyPath[0] = address(dai_);\n', '            buyPath[1] = router_.WETH();\n', '        }\n', '        \n', '        return buyPath;\n', '    }\n', '    \n', '    /**\n', '      * @return Gets the current time\n', '      */\n', '    function getTime() public view returns(uint256) {\n', '        return now;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // State modifying functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '      * @param  _tokenAmount The amount of BZZ tokens the user would like to\n', '      *         buy from the curve.\n', '      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\n', '      *         is willing to spend to buy the amount of tokens.\n', '      * @param  _deadline Unix timestamp after which the transaction will \n', '      *         revert. - Taken from Uniswap documentation: \n', '      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\n', '      * @return bool If the transaction completed successfully.\n', '      * @notice Before this function is called the caller does not need to\n', '      *         approve the spending of anything. Please assure that the amount\n', '      *         of ETH sent with this transaction is sufficient by first calling\n', '      *         `buyPrice` with the same token amount. Add your % slippage to\n', '      *         the max dai spend amount (you can get the expected amount by \n', '      *         calling `buyPrice` on the curve contract).\n', '      */\n', '    function mint(\n', '        uint256 _tokenAmount, \n', '        uint256 _maxDaiSpendAmount, \n', '        uint _deadline\n', '    )\n', '        external\n', '        payable\n', '        isCurveActive()\n', '        mutex()\n', '        returns (bool)\n', '    {\n', '        (uint256 daiNeeded, uint256 ethReceived) = _commonMint(\n', '            _tokenAmount,\n', '            _maxDaiSpendAmount,\n', '            _deadline,\n', '            msg.sender\n', '        );\n', '        // Emitting event with all important info\n', '        emit mintTokensWithEth(\n', '            msg.sender, \n', '            _tokenAmount, \n', '            daiNeeded, \n', '            ethReceived, \n', '            _maxDaiSpendAmount\n', '        );\n', '        // Returning that the mint executed successfully\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @param  _tokenAmount The amount of BZZ tokens the user would like to\n', '      *         buy from the curve.\n', '      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\n', '      *         is willing to spend to buy the amount of tokens.\n', '      * @param  _deadline Unix timestamp after which the transaction will \n', '      *         revert. - Taken from Uniswap documentation: \n', '      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\n', '      * @return bool If the transaction completed successfully.\n', '      * @notice Before this function is called the caller does not need to\n', '      *         approve the spending of anything. Please assure that the amount\n', '      *         of ETH sent with this transaction is sufficient by first calling\n', '      *         `buyPrice` with the same token amount. Add your % slippage to\n', '      *         the max dai spend amount (you can get the expected amount by \n', '      *         calling `buyPrice` on the curve contract).\n', '      */\n', '    function mintTo(\n', '        uint256 _tokenAmount, \n', '        uint256 _maxDaiSpendAmount, \n', '        uint _deadline,\n', '        address _to\n', '    )\n', '        external\n', '        payable\n', '        isCurveActive()\n', '        mutex()\n', '        returns (bool)\n', '    {\n', '        (uint256 daiNeeded, uint256 ethReceived) = _commonMint(\n', '            _tokenAmount,\n', '            _maxDaiSpendAmount,\n', '            _deadline,\n', '            _to\n', '        );\n', '        // Emitting event with all important info\n', '        emit mintTokensToWithEth(\n', '            msg.sender, \n', '            _to,\n', '            _tokenAmount, \n', '            daiNeeded, \n', '            ethReceived, \n', '            _maxDaiSpendAmount\n', '        );\n', '        // Returning that the mint executed successfully\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @notice The user needs to have approved this contract as a spender of\n', '      *         of the desired `_tokenAmount` to sell before calling this\n', '      *         transaction. Failure to do so will result in the call reverting.\n', '      *         This function is payable to receive ETH from internal calls.\n', '      *         Please do not send ETH to this function.\n', '      * @param  _tokenAmount The amount of BZZ tokens the user would like to\n', '      *         sell.\n', '      * @param  _minDaiSellValue The min value of collateral (DAI) the user\n', '      *         is willing to sell their tokens for.\n', '      * @param  _deadline Unix timestamp after which the transaction will \n', '      *         revert. - Taken from Uniswap documentation: \n', '      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapexacttokensforeth\n', '      * @return bool If the transaction completed successfully.\n', '      */\n', '    function redeem(\n', '        uint256 _tokenAmount, \n', '        uint256 _minDaiSellValue,\n', '        uint _deadline\n', '    )\n', '        external\n', '        payable\n', '        isCurveActive()\n', '        mutex()\n', '        returns (bool)\n', '    {\n', '        // Gets the current reward for selling the amount of tokens\n', '        uint256 daiReward = curve_.sellReward(_tokenAmount);\n', '        // The check that the dai reward amount is not more than the min sell \n', '        // amount happens in the curve.\n', '\n', '        // Transferring _amount of tokens into this contract\n', '        require(\n', '            bzz_.transferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                _tokenAmount\n', '            ),\n', '            "Transferring BZZ failed"\n', '        );\n', '        // Approving the curve as a spender\n', '        require(\n', '            bzz_.approve(\n', '                address(curve_),\n', '                _tokenAmount\n', '            ),\n', '            "BZZ approve failed"\n', '        );\n', '        // Selling tokens for DAI\n', '        require(\n', '            curve_.redeem(\n', '                _tokenAmount,\n', '                daiReward\n', '            ),\n', '            "Curve burn failed"\n', '        );\n', '        // Getting expected ETH for DAI\n', '        uint256 ethMin = sellRewardDai(dai_.balanceOf(address(this)));\n', '        // Approving the router as a spender\n', '        require(\n', '            dai_.approve(\n', '                address(router_),\n', '                daiReward\n', '            ),\n', '            "DAI approve failed"\n', '        );\n', '        // Selling DAI received for ETH\n', '        router_.swapExactTokensForETH(\n', '            daiReward, \n', '            ethMin, \n', '            getPath(false), \n', '            msg.sender, \n', '            _deadline\n', '        );\n', '        // Emitting event with all important info\n', '        emit burnTokensWithEth(\n', '            msg.sender, \n', '            _tokenAmount, \n', '            daiReward, \n', '            ethMin, \n', '            _minDaiSellValue\n', '        );\n', '        // Returning that the burn executed successfully\n', '        return true;\n', '    }\n', '\n', '    function() external payable {\n', '        require(\n', '            msg.sender == address(router_),\n', '            "ETH not accepted outside router"\n', '        );\n', '    }\n', '\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Internal functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '      * @param  _tokenAmount The amount of BZZ tokens the user would like to\n', '      *         buy from the curve.\n', '      * @param  _maxDaiSpendAmount The max amount of collateral (DAI) the user\n', '      *         is willing to spend to buy the amount of tokens.\n', '      * @param  _deadline Unix timestamp after which the transaction will \n', '      *         revert. - Taken from Uniswap documentation: \n', '      *         https://uniswap.org/docs/v2/smart-contracts/router02/#swapethforexacttokens\n', '      * @return uint256 The dai needed to buy the tokens.\n', '      * @return uint256 The Ether received from the user for the trade.\n', '      * @notice Before this function is called the caller does not need to\n', '      *         approve the spending of anything. Please assure that the amount\n', '      *         of ETH sent with this transaction is sufficient by first calling\n', '      *         `buyPrice` with the same token amount. Add your % slippage to\n', '      *         the max dai spend amount (you can get the expected amount by \n', '      *         calling `buyPrice` on the curve contract).\n', '      */\n', '    function _commonMint(\n', '        uint256 _tokenAmount, \n', '        uint256 _maxDaiSpendAmount, \n', '        uint _deadline,\n', '        address _to\n', '    )\n', '        internal\n', '        returns(\n', '            uint256 daiNeeded,\n', '            uint256 ethReceived\n', '        )\n', '    {\n', '        // Getting the exact needed amount of DAI for desired token amount\n', '        daiNeeded = curve_.buyPrice(_tokenAmount);\n', '        // Checking that this amount is not more than the max spend amount\n', '        require(\n', '            _maxDaiSpendAmount >= daiNeeded,\n', '            "DAI required for trade above max"\n', '        );\n', '        // Swapping sent ETH for exact amount of DAI needed\n', '        router_.swapETHForExactTokens.value(msg.value)(\n', '            daiNeeded, \n', '            getPath(true), \n', '            address(this), \n', '            _deadline\n', '        );\n', '        // Getting the amount of ETH received\n', '        ethReceived = address(this).balance;\n', '        // Approving the curve as a spender\n', '        require(\n', '            dai_.approve(address(curve_), daiNeeded),\n', '            "DAI approve failed"\n', '        );\n', '        // Buying tokens (BZZ) against the curve\n', '        require(\n', '            curve_.mintTo(_tokenAmount, daiNeeded, _to),\n', '            "BZZ mintTo failed"\n', '        );\n', '        // Refunding user excess ETH\n', '        msg.sender.transfer(ethReceived);\n', '    }\n', '}']