['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-15\n', '*/\n', '\n', '// File: contracts/ExchangeContract.sol\n', '\n', 'pragma solidity ^0.5.0;\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        \n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () public{\n', '        address msgSender = msg.sender;\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract NFTBANK721 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    function balanceOf(address owner) public view returns (uint256 balance);    \n', '    function tokenTransfer(address from, address to, uint256 tokenId) public;\n', '    function _mint(address to, uint256 tokenId, string memory uri) public;\n', '    function setApprovalForAll(address from, address to, bool approved, uint256 tokenId) public ;\n', '    function _burn(uint256 tokenId, address from, address admin) public;\n', '    function _transferOwnership(address newOwner) public;\n', '}\n', 'contract NFTBANK1155{\n', '   \n', '    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '    event URI(string _value, uint256 indexed _id);\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n', '\n', '    function balanceOf(address _owner, uint256 _id) public view returns (uint256);\n', '\n', '    function setApprovalForAll(address from, address _operator, bool _approved) public;\n', '    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n', '    function mint(address from, uint256 _id, uint256 _supply, string memory _uri) public;\n', '    function burn(address from, address admin, uint256 _id, uint256 _value) public ;\n', '    function _transferOwnership(address newOwner) public;\n', '}\n', 'contract BEP20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'contract Sale is Ownable{\n', '    event CancelOrder(address indexed from, uint256 indexed tokenId);\n', '    event ChangePrice(address indexed from, uint256 indexed tokenId, uint256 indexed value);\n', '    event OrderPlace(address indexed from, uint256 indexed tokenId, uint256 indexed value);\n', '    event FeeDetails(uint256 indexed owner, uint256 indexed admin, uint256 indexed admin2);\n', '    event Calcu(uint256 indexed owner, uint256 indexed admin, uint256 indexed admin2);\n', '    event FeeDiv(uint256 indexed owner, uint256 indexed admin, uint256 indexed admin2);\n', '    using SafeMath for uint256;\n', '    struct Order{\n', '        uint256 tokenId;\n', '        uint256 price;\n', '    }\n', '    uint256 public serviceValue;\n', '    mapping (address => mapping (uint256 => Order)) public order_place;\n', '    mapping (uint256 => mapping (address => bool)) public checkOrder;\n', '    mapping (uint256 =>  bool) public _operatorApprovals;\n', '    mapping (uint256 => address) public _creator;\n', '    mapping (uint256 => uint256) public _royal; \n', '    mapping (uint256 => mapping(address => uint256)) public balances;\n', '    constructor(uint256 _serviceValue) public{\n', '        serviceValue = _serviceValue * 2;\n', '    }\n', '    function _orderPlace(address from, uint256 tokenId, uint256 _price) internal{\n', '        require( balances[tokenId][from] > 0, "Is Not a Owner");\n', '        Order memory order;\n', '        order.tokenId = tokenId;\n', '        order.price = _price;\n', '        order_place[from][tokenId] = order;\n', '        checkOrder[tokenId][from] = true;\n', '        emit OrderPlace(from, tokenId, _price);\n', '    }\n', '    function _cancelOrder(address from, uint256 tokenId) internal{\n', '        require(balances[tokenId][msg.sender] > 0, "Is Not a Owner");\n', '        delete order_place[msg.sender][tokenId];\n', '        checkOrder[tokenId][from] = false;\n', '        emit CancelOrder(msg.sender, tokenId);\n', '    }\n', '    function _changePrice(uint256 value, uint256 tokenId) internal{\n', '        require( balances[tokenId][msg.sender] > 0, "Is Not a Owner");\n', '        require( value < order_place[msg.sender][tokenId].price);\n', '        order_place[msg.sender][tokenId].price = value;\n', '        emit ChangePrice(msg.sender, tokenId, value);\n', '    }\n', '    function _acceptBId(address token,address from, address admin, uint256 amount, uint256 tokenId) internal{\n', '        require(_operatorApprovals[tokenId], "Token Not approved");\n', '        require(balances[tokenId][msg.sender] > 0, "Is Not a Owner");\n', '        (uint256 _adminfee, uint256 roy, uint256 netamount) = calc(amount, _royal[tokenId], serviceValue);\n', '        BEP20 t = BEP20(token);\n', '        t.transferFrom(from,admin,_adminfee);\n', '        t.transferFrom(from,_creator[tokenId],roy);\n', '        t.transferFrom(from,msg.sender,netamount);\n', '    }\n', '    function checkTokenApproval(uint256 tokenId, address from) internal view returns (bool result){\n', '        require(checkOrder[tokenId][from], "This Token Not for Sale");\n', '        require(_operatorApprovals[tokenId], "Token Not approved");\n', '        return true;\n', '    }\n', '    function _saleToken(address payable from, address payable admin,uint256 tokenId, uint256 amount) internal{\n', '        require(amount> order_place[from][tokenId].price , "Insufficent found");\n', '        require(checkTokenApproval(tokenId, from));\n', '        address payable create = address(uint160(_creator[tokenId]));\n', '        (uint256 _adminfee, uint256 roy, uint256 netamount) = calc(amount, _royal[tokenId], serviceValue);\n', '        admin.transfer(_adminfee);\n', '        create.transfer(roy);\n', '        from.transfer(netamount);\n', '    }\n', '    function calc(uint256 amount, uint256 royal, uint256 _serviceValue) internal pure returns(uint256, uint256, uint256){\n', '        uint256 fee = percent(amount, _serviceValue.div(10));\n', '        uint256 ser=fee.div(2);\n', '        uint256 or_am = amount.sub(ser);\n', '        uint256 roy = percent(or_am, royal);\n', '        uint256 netamount = or_am.sub(ser.add(roy));\n', '        return (fee, roy, netamount);\n', '    }\n', '\n', '    function percent(uint256 value1, uint256 value2) internal pure returns(uint256){\n', '        uint256 result = value1.mul(value2).div(100);\n', '        return(result);\n', '    }\n', '    function setServiceValue(uint256 _serviceValue) internal{\n', '        serviceValue = _serviceValue.mul(2);\n', '    }\n', '\n', '\n', '}\n', 'contract ExchangeContract is Sale{\n', '    uint256 public tokenCount;\n', '    constructor(uint256 _serviceValue) Sale(_serviceValue) public{\n', '        \n', '    }\n', '    function serviceFunction(uint256 _serviceValue) public onlyOwner{\n', '        setServiceValue(_serviceValue);\n', '    }\n', '\n', '    function transferOwnershipForColle(address newOwner, address token721, address token1155) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        NFTBANK721 tok= NFTBANK721(token721);\n', '        NFTBANK1155 tok1155= NFTBANK1155(token1155);\n', '        tok._transferOwnership(newOwner);\n', '        tok1155._transferOwnership(newOwner);\n', '    }\n', '    function mint(address token ,string memory tokenuri, uint256 value, uint256 tokenId, uint256 royal, uint256 _type, uint256 supply) public{\n', '       require(_creator[tokenId] == address(0), "Token Already Minted");\n', '       if(_type == 721){\n', '           NFTBANK721 tok= NFTBANK721(token);\n', '           _creator[tokenId]=msg.sender;\n', '           _royal[tokenId]=royal;\n', '           tok._mint(msg.sender, tokenId, tokenuri);\n', '           balances[tokenId][msg.sender] = supply;\n', '           if(value != 0){\n', '                _orderPlace(msg.sender, tokenId, value);\n', '            }\n', '        }\n', '        else{\n', '            NFTBANK1155 tok = NFTBANK1155(token);\n', '            tok.mint(msg.sender, tokenId, supply, tokenuri);\n', '            _creator[tokenId]=msg.sender;\n', '            _royal[tokenId]=royal;\n', '            balances[tokenId][msg.sender] = supply;\n', '            if(value != 0){\n', '                _orderPlace(msg.sender, tokenId, value);\n', '            }\n', '       }\n', '       tokenCount++;\n', '       \n', '    }\n', '    function setApprovalForAll(address token, uint256 _type, address to, bool approved, uint256 tokenId) public {\n', '        _operatorApprovals[tokenId] = true;\n', '        if(_type == 721){\n', '            NFTBANK721 tok= NFTBANK721(token);\n', '            tok.setApprovalForAll(msg.sender, to,approved,tokenId);\n', '        }\n', '        else{\n', '            NFTBANK1155 tok = NFTBANK1155(token);\n', '            tok.setApprovalForAll(msg.sender, to, approved);\n', '        }\n', '    }\n', '    function saleToken(address payable from, address payable admin,uint256 tokenId, uint256 amount, address token, uint256 _type, uint256 NOFToken) public payable{\n', '       _saleToken(from, admin, tokenId, amount);\n', '       if(_type == 721){\n', '           NFTBANK721 tok= NFTBANK721(token);\n', '            if(checkOrder[tokenId][from]==true){\n', '                delete order_place[from][tokenId];\n', '                checkOrder[tokenId][from] = false;\n', '            }\n', '           tok.tokenTransfer(from, msg.sender, tokenId);\n', '           balances[tokenId][from] = balances[tokenId][from] - NOFToken;\n', '           balances[tokenId][msg.sender] = NOFToken;\n', '       }\n', '       else{\n', '            NFTBANK1155 tok= NFTBANK1155(token);\n', '            tok.safeTransferFrom(from, msg.sender, tokenId, NOFToken);\n', '            balances[tokenId][from] = balances[tokenId][from] - NOFToken;\n', '            balances[tokenId][msg.sender] = balances[tokenId][msg.sender] + NOFToken;\n', '            if(checkOrder[tokenId][from] == true){\n', '                if(balances[tokenId][from] == 0){\n', '                    delete order_place[from][tokenId];\n', '                    checkOrder[tokenId][from] = false;\n', '                }\n', '            }\n', '            \n', '       }\n', '        \n', '\n', '    }\n', '    function acceptBId(address bittoken,address from, address admin, uint256 amount, uint256 tokenId, address token, uint256 _type, uint256 NOFToken) public{\n', '        _acceptBId(bittoken, from, admin, amount, tokenId);\n', '        if(_type == 721){\n', '           NFTBANK721 tok= NFTBANK721(token);\n', '           if(checkOrder[tokenId][msg.sender]==true){\n', '                delete order_place[msg.sender][tokenId];\n', '                checkOrder[tokenId][msg.sender] = false;\n', '           }\n', '           tok.tokenTransfer(msg.sender, from, tokenId);\n', '           balances[tokenId][msg.sender] = balances[tokenId][msg.sender] - NOFToken;\n', '           balances[tokenId][from] = NOFToken;\n', '        }\n', '        else{\n', '            NFTBANK1155 tok= NFTBANK1155(token);\n', '            tok.safeTransferFrom(msg.sender, from, tokenId, NOFToken);\n', '            balances[tokenId][from] = balances[tokenId][from] + NOFToken;\n', '            balances[tokenId][msg.sender] = balances[tokenId][msg.sender] - NOFToken;\n', '            if(checkOrder[tokenId][msg.sender] == true){\n', '                if(balances[tokenId][msg.sender] == 0){   \n', '                    delete order_place[msg.sender][tokenId];\n', '                    checkOrder[tokenId][msg.sender] = false;\n', '                }\n', '            }\n', '\n', '        }\n', '    }\n', '    function orderPlace(uint256 tokenId, uint256 _price) public{\n', '        _orderPlace(msg.sender, tokenId, _price);\n', '    }\n', '    function cancelOrder(uint256 tokenId) public{\n', '        _cancelOrder(msg.sender, tokenId);\n', '    }\n', '    function changePrice(uint256 value, uint256 tokenId) public{\n', '        _changePrice(value, tokenId);\n', '    }\n', '\n', '    function burn(address admin, uint256 tokenId, address token, uint256 _type, uint256 NOFToken ) public{\n', '        require( balances[tokenId][msg.sender] >= NOFToken || msg.sender == admin, "Your Not a Token Owner or insuficient Token Balance");\n', '        if(_type == 721){\n', '            NFTBANK721 tok= NFTBANK721(token);\n', '            tok._burn(tokenId, msg.sender, admin);\n', '            balances[tokenId][msg.sender] = balances[tokenId][msg.sender].sub(NOFToken);\n', '            if(checkOrder[tokenId][msg.sender]==true){\n', '                delete order_place[msg.sender][tokenId];\n', '                checkOrder[tokenId][msg.sender] = false;\n', '            }\n', '            delete _creator[tokenId];\n', '            delete _royal[tokenId];\n', '        }\n', '        else{\n', '            NFTBANK1155 tok= NFTBANK1155(token);\n', '            tok.burn(msg.sender, admin, tokenId, NOFToken);\n', '            balances[tokenId][msg.sender] = balances[tokenId][msg.sender].sub(NOFToken);\n', '            if(balances[tokenId][msg.sender] == NOFToken){\n', '                if(checkOrder[tokenId][msg.sender]==true){\n', '                    delete order_place[msg.sender][tokenId];\n', '                    checkOrder[tokenId][msg.sender] = false;\n', '                }\n', '            }\n', '\n', '        }\n', '        tokenCount--;\n', '\n', '    }\n', '\n', '}']