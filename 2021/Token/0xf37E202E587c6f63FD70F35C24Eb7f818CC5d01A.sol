['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', "import {DebtTokenBase} from './DebtTokenBase.sol';\n", "import {MathUtils} from './MathUtils.sol';\n", "import {WadRayMath} from './WadRayMath.sol';\n", "import {IStableDebtToken} from './IStableDebtToken.sol';\n", "import {Errors} from './Errors.sol';\n", '\n', '/**\n', ' * @title StableDebtToken\n', ' * @notice Implements a stable debt token to track the borrowing positions of users\n', ' * at stable rate mode\n', ' * @author Aave\n', ' **/\n', 'contract StableDebtToken is IStableDebtToken, DebtTokenBase {\n', '  using WadRayMath for uint256;\n', '\n', '  uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n', '\n', '  uint256 internal _avgStableRate;\n', '  mapping(address => uint40) internal _timestamps;\n', '  mapping(address => uint256) internal _usersStableRate;\n', '  uint40 internal _totalSupplyTimestamp;\n', '\n', '  constructor(\n', '    address pool,\n', '    address underlyingAsset,\n', '    string memory name,\n', '    string memory symbol,\n', '    address incentivesController\n', '  ) public DebtTokenBase(pool, underlyingAsset, name, symbol, incentivesController) {}\n', '\n', '  /**\n', '   * @dev Gets the revision of the stable debt token implementation\n', '   * @return The debt token implementation revision\n', '   **/\n', '  function getRevision() internal pure virtual override returns (uint256) {\n', '    return DEBT_TOKEN_REVISION;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the average stable rate across all the stable rate debt\n', '   * @return the average stable rate\n', '   **/\n', '  function getAverageStableRate() external view virtual override returns (uint256) {\n', '    return _avgStableRate;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the timestamp of the last user action\n', '   * @return The last update timestamp\n', '   **/\n', '  function getUserLastUpdated(address user) external view virtual override returns (uint40) {\n', '    return _timestamps[user];\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the stable rate of the user\n', '   * @param user The address of the user\n', '   * @return The stable rate of user\n', '   **/\n', '  function getUserStableRate(address user) external view virtual override returns (uint256) {\n', '    return _usersStableRate[user];\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the current user debt balance\n', '   * @return The accumulated debt of the user\n', '   **/\n', '  function balanceOf(address account) public view virtual override returns (uint256) {\n', '    uint256 accountBalance = super.balanceOf(account);\n', '    uint256 stableRate = _usersStableRate[account];\n', '    if (accountBalance == 0) {\n', '      return 0;\n', '    }\n', '    uint256 cumulatedInterest =\n', '      MathUtils.calculateCompoundedInterest(stableRate, _timestamps[account]);\n', '    return accountBalance.rayMul(cumulatedInterest);\n', '  }\n', '\n', '  struct MintLocalVars {\n', '    uint256 previousSupply;\n', '    uint256 nextSupply;\n', '    uint256 amountInRay;\n', '    uint256 newStableRate;\n', '    uint256 currentAvgStableRate;\n', '  }\n', '\n', '  /**\n', '   * @dev Mints debt token to the `onBehalfOf` address.\n', '   * -  Only callable by the LendingPool\n', '   * - The resulting rate is the weighted average between the rate of the new debt\n', '   * and the rate of the previous debt\n', '   * @param user The address receiving the borrowed underlying, being the delegatee in case\n', '   * of credit delegate, or same as `onBehalfOf` otherwise\n', '   * @param onBehalfOf The address receiving the debt tokens\n', '   * @param amount The amount of debt tokens to mint\n', '   * @param rate The rate of the debt being minted\n', '   **/\n', '  function mint(\n', '    address user,\n', '    address onBehalfOf,\n', '    uint256 amount,\n', '    uint256 rate\n', '  ) external override onlyLendingPool returns (bool) {\n', '    MintLocalVars memory vars;\n', '\n', '    if (user != onBehalfOf) {\n', '      _decreaseBorrowAllowance(onBehalfOf, user, amount);\n', '    }\n', '\n', '    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(onBehalfOf);\n', '\n', '    vars.previousSupply = totalSupply();\n', '    vars.currentAvgStableRate = _avgStableRate;\n', '    vars.nextSupply = _totalSupply = vars.previousSupply.add(amount);\n', '\n', '    vars.amountInRay = amount.wadToRay();\n', '\n', '    vars.newStableRate = _usersStableRate[onBehalfOf]\n', '      .rayMul(currentBalance.wadToRay())\n', '      .add(vars.amountInRay.rayMul(rate))\n', '      .rayDiv(currentBalance.add(amount).wadToRay());\n', '\n', '    require(vars.newStableRate <= type(uint128).max, Errors.SDT_STABLE_DEBT_OVERFLOW);\n', '    _usersStableRate[onBehalfOf] = vars.newStableRate;\n', '\n', '    //solium-disable-next-line\n', '    _totalSupplyTimestamp = _timestamps[onBehalfOf] = uint40(block.timestamp);\n', '\n', '    // Calculates the updated average stable rate\n', '    vars.currentAvgStableRate = _avgStableRate = vars\n', '      .currentAvgStableRate\n', '      .rayMul(vars.previousSupply.wadToRay())\n', '      .add(rate.rayMul(vars.amountInRay))\n', '      .rayDiv(vars.nextSupply.wadToRay());\n', '\n', '    _mint(onBehalfOf, amount.add(balanceIncrease), vars.previousSupply);\n', '\n', '    emit Transfer(address(0), onBehalfOf, amount);\n', '\n', '    emit Mint(\n', '      user,\n', '      onBehalfOf,\n', '      amount,\n', '      currentBalance,\n', '      balanceIncrease,\n', '      vars.newStableRate,\n', '      vars.currentAvgStableRate,\n', '      vars.nextSupply\n', '    );\n', '\n', '    return currentBalance == 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns debt of `user`\n', '   * @param user The address of the user getting his debt burned\n', '   * @param amount The amount of debt tokens getting burned\n', '   **/\n', '  function burn(address user, uint256 amount) external override onlyLendingPool {\n', '    (, uint256 currentBalance, uint256 balanceIncrease) = _calculateBalanceIncrease(user);\n', '\n', '    uint256 previousSupply = totalSupply();\n', '    uint256 newAvgStableRate = 0;\n', '    uint256 nextSupply = 0;\n', '    uint256 userStableRate = _usersStableRate[user];\n', '\n', '    // Since the total supply and each single user debt accrue separately,\n', '    // there might be accumulation errors so that the last borrower repaying\n', '    // mght actually try to repay more than the available debt supply.\n', '    // In this case we simply set the total supply and the avg stable rate to 0\n', '    if (previousSupply <= amount) {\n', '      _avgStableRate = 0;\n', '      _totalSupply = 0;\n', '    } else {\n', '      nextSupply = _totalSupply = previousSupply.sub(amount);\n', '      uint256 firstTerm = _avgStableRate.rayMul(previousSupply.wadToRay());\n', '      uint256 secondTerm = userStableRate.rayMul(amount.wadToRay());\n', '\n', '      // For the same reason described above, when the last user is repaying it might\n', '      // happen that user rate * user balance > avg rate * total supply. In that case,\n', '      // we simply set the avg rate to 0\n', '      if (secondTerm >= firstTerm) {\n', '        newAvgStableRate = _avgStableRate = _totalSupply = 0;\n', '      } else {\n', '        newAvgStableRate = _avgStableRate = firstTerm.sub(secondTerm).rayDiv(nextSupply.wadToRay());\n', '      }\n', '    }\n', '\n', '    if (amount == currentBalance) {\n', '      _usersStableRate[user] = 0;\n', '      _timestamps[user] = 0;\n', '    } else {\n', '      //solium-disable-next-line\n', '      _timestamps[user] = uint40(block.timestamp);\n', '    }\n', '    //solium-disable-next-line\n', '    _totalSupplyTimestamp = uint40(block.timestamp);\n', '\n', '    if (balanceIncrease > amount) {\n', '      uint256 amountToMint = balanceIncrease.sub(amount);\n', '      _mint(user, amountToMint, previousSupply);\n', '      emit Mint(\n', '        user,\n', '        user,\n', '        amountToMint,\n', '        currentBalance,\n', '        balanceIncrease,\n', '        userStableRate,\n', '        newAvgStableRate,\n', '        nextSupply\n', '      );\n', '    } else {\n', '      uint256 amountToBurn = amount.sub(balanceIncrease);\n', '      _burn(user, amountToBurn, previousSupply);\n', '      emit Burn(user, amountToBurn, currentBalance, balanceIncrease, newAvgStableRate, nextSupply);\n', '    }\n', '\n', '    emit Transfer(user, address(0), amount);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the increase in balance since the last user interaction\n', '   * @param user The address of the user for which the interest is being accumulated\n', '   * @return The previous principal balance, the new principal balance and the balance increase\n', '   **/\n', '  function _calculateBalanceIncrease(address user)\n', '    internal\n', '    view\n', '    returns (\n', '      uint256,\n', '      uint256,\n', '      uint256\n', '    )\n', '  {\n', '    uint256 previousPrincipalBalance = super.balanceOf(user);\n', '\n', '    if (previousPrincipalBalance == 0) {\n', '      return (0, 0, 0);\n', '    }\n', '\n', '    // Calculation of the accrued interest since the last accumulation\n', '    uint256 balanceIncrease = balanceOf(user).sub(previousPrincipalBalance);\n', '\n', '    return (\n', '      previousPrincipalBalance,\n', '      previousPrincipalBalance.add(balanceIncrease),\n', '      balanceIncrease\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the principal and total supply, the average borrow rate and the last supply update timestamp\n', '   **/\n', '  function getSupplyData()\n', '    public\n', '    view\n', '    override\n', '    returns (\n', '      uint256,\n', '      uint256,\n', '      uint256,\n', '      uint40\n', '    )\n', '  {\n', '    uint256 avgRate = _avgStableRate;\n', '    return (super.totalSupply(), _calcTotalSupply(avgRate), avgRate, _totalSupplyTimestamp);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the the total supply and the average stable rate\n', '   **/\n', '  function getTotalSupplyAndAvgRate() public view override returns (uint256, uint256) {\n', '    uint256 avgRate = _avgStableRate;\n', '    return (_calcTotalSupply(avgRate), avgRate);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the total supply\n', '   **/\n', '  function totalSupply() public view override returns (uint256) {\n', '    return _calcTotalSupply(_avgStableRate);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the timestamp at which the total supply was updated\n', '   **/\n', '  function getTotalSupplyLastUpdated() public view override returns (uint40) {\n', '    return _totalSupplyTimestamp;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the principal debt balance of the user from\n', "   * @param user The user's address\n", '   * @return The debt balance of the user since the last burn/mint action\n', '   **/\n', '  function principalBalanceOf(address user) external view virtual override returns (uint256) {\n', '    return super.balanceOf(user);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the total supply\n', '   * @param avgRate The average rate at which the total supply increases\n', '   * @return The debt balance of the user since the last burn/mint action\n', '   **/\n', '  function _calcTotalSupply(uint256 avgRate) internal view virtual returns (uint256) {\n', '    uint256 principalSupply = super.totalSupply();\n', '\n', '    if (principalSupply == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 cumulatedInterest =\n', '      MathUtils.calculateCompoundedInterest(avgRate, _totalSupplyTimestamp);\n', '\n', '    return principalSupply.rayMul(cumulatedInterest);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints stable debt tokens to an user\n', '   * @param account The account receiving the debt tokens\n', '   * @param amount The amount being minted\n', '   * @param oldTotalSupply the total supply before the minting event\n', '   **/\n', '  function _mint(\n', '    address account,\n', '    uint256 amount,\n', '    uint256 oldTotalSupply\n', '  ) internal {\n', '    uint256 oldAccountBalance = _balances[account];\n', '    _balances[account] = oldAccountBalance.add(amount);\n', '\n', '    if (address(_incentivesController) != address(0)) {\n', '      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Burns stable debt tokens of an user\n', '   * @param account The user getting his debt burned\n', '   * @param amount The amount being burned\n', '   * @param oldTotalSupply The total supply before the burning event\n', '   **/\n', '  function _burn(\n', '    address account,\n', '    uint256 amount,\n', '    uint256 oldTotalSupply\n', '  ) internal {\n', '    uint256 oldAccountBalance = _balances[account];\n', '    _balances[account] = oldAccountBalance.sub(amount, Errors.SDT_BURN_EXCEEDS_BALANCE);\n', '\n', '    if (address(_incentivesController) != address(0)) {\n', '      _incentivesController.handleAction(account, oldTotalSupply, oldAccountBalance);\n', '    }\n', '  }\n', '}']