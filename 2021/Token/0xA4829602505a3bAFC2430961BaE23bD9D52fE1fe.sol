['// "SPDX-License-Identifier: MIT"\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'import "./vendors/interfaces/IERC20.sol";\n', 'import "./vendors/interfaces/IDelegableERC20.sol";\n', 'import "./vendors/libraries/SafeMath.sol";\n', 'import "./vendors/libraries/SafeERC20.sol";\n', 'import "./vendors/contracts/access/Ownable.sol";\n', '\n', '\n', 'contract TeamPoolPACT is Ownable{\n', '    \n', '    using SafeMath for uint;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event Withdraw(uint tokensAmount);\n', '\n', '    address public _PACT;\n', '    uint constant oneYear = 365 days;\n', '\n', '    uint[2][4] private annualSupplyPoints = [\n', '        [block.timestamp, 12500000e18],\n', '        [block.timestamp.add(oneYear.mul(1)), 12500000e18],\n', '        [block.timestamp.add(oneYear.mul(2)), 12500000e18],\n', '        [block.timestamp.add(oneYear.mul(3)), 12500000e18]\n', '    ];\n', ' \n', '    \n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner (`ownerAddress`) \n', '     * and pact contract address (`PACT`).\n', '     */\n', '    constructor (\n', '        address ownerAddress,\n', '        address PACT\n', '    ) public {\n', '        require (PACT != address(0), "PACT ADDRESS SHOULD BE NOT NULL");\n', '        _PACT = PACT;\n', '        transferOwnership(ownerAddress == address(0) ? msg.sender : ownerAddress);\n', '        IDelegableERC20(_PACT).delegate(ownerAddress);\n', '    }\n', '\n', '    \n', '    /**\n', '     * @dev Returns the annual supply points of the current contract.\n', '     */\n', '    function getReleases() external view returns(uint[2][4] memory) {\n', '        return annualSupplyPoints;\n', '    } \n', '\n', '    /**\n', '     * @dev Withdrawal tokens the address  (`to`) and amount (`amount`).\n', '     * Can only be called by the current owner.\n', '    */\n', '    function withdraw(address to,uint amount) external onlyOwner {\n', '        IERC20 PACT = IERC20(_PACT);\n', '        require (to != address(0), "ADDRESS SHOULD BE NOT NULL");\n', '        require(amount <= PACT.balanceOf(address(this)), "NOT ENOUGH PACT TOKENS ON TEAMPOOL CONTRACT BALANCE");\n', '        for(uint i; i < 4; i++) {\n', '            if(annualSupplyPoints[i][1] >= amount && block.timestamp >= annualSupplyPoints[i][0]) {\n', '               annualSupplyPoints[i][1] = annualSupplyPoints[i][1].sub(amount);\n', '               PACT.safeTransfer(to, amount);\n', '               return ;\n', '            }\n', '        }\n', '        require (false, "TokenTimelock: no tokens to release");              \n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../utils/Context.sol";\n', '\n', '// Copied from OpenZeppelin code:\n', '// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() public {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// Copied from OpenZeppelin code:\n', '// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IDelegable {\n', '    function delegate(address delegatee) external;\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\n', '    function getCurrentVotes(address account) external view returns (uint256);\n', '    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\n', '\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IDelegable.sol";\n', 'import "./IERC20WithMaxTotalSupply.sol";\n', '\n', 'interface IDelegableERC20 is IDelegable, IERC20WithMaxTotalSupply {}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IERC20.sol";\n', '\n', 'interface IERC20WithMaxTotalSupply is IERC20 {\n', '    event Mint(address indexed account, uint tokens);\n', '    event Burn(address indexed account, uint tokens);\n', '    function maxTotalSupply() external view returns (uint);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../interfaces/IERC20.sol";\n', '\n', 'library SafeERC20 {\n', '    function safeSymbol(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeName(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeDecimals(IERC20 token) public view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: Transfer failed");\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return add(a, b, "SafeMath: Add Overflow");\n', '    }\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);// "SafeMath: Add Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: Underflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;// "SafeMath: Underflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mul(a, b, "SafeMath: Mul Overflow");\n', '    }\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);// "SafeMath: Mul Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']