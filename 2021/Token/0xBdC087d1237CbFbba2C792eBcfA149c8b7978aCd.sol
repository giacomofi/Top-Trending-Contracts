['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '/*\n', '\n', 'Building in DeFi Sucks.\n', '\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(success, "Address: reverted");\n', '    }\n', '}\n', '\n', 'library Keep3rV1Library {\n', '    function getReserve(address pair, address reserve) external view returns (uint) {\n', '        (uint _r0, uint _r1,) = IUniswapV2Pair(pair).getReserves();\n', '        if (IUniswapV2Pair(pair).token0() == reserve) {\n', '            return _r0;\n', '        } else if (IUniswapV2Pair(pair).token1() == reserve) {\n', '            return _r1;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', 'library EnumerableSet {\n', '\n', '    struct Set {\n', '\n', '        bytes32[] _values;\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', "            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n", '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    struct Bytes32Set {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _add(set._inner, value);\n', '    }\n', '\n', '    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _remove(set._inner, value);\n', '    }\n', '\n', '    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n', '        return _contains(set._inner, value);\n', '    }\n', '\n', '    function length(Bytes32Set storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n', '        return _at(set._inner, index);\n', '    }\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint160(uint256(_at(set._inner, index))));\n', '    }\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IGovernance {\n', '    function proposeJob(address job) external;\n', '}\n', '\n', 'interface IKeep3rV1Helper {\n', '    function getQuoteLimit(uint gasUsed) external view returns (uint);\n', '}\n', '\n', 'interface IKeep3rV1 {\n', '    function delegate(address delegatee) external;\n', '    function addVotes(address voter, uint amount) external;\n', '    function addCredit(address credit, address job, uint amount) external;\n', '    function resolve(address keeper) external;\n', '    function unbond(address bonding, uint amount) external;\n', '    function bond(address bonding, uint amount) external;\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'contract Owned is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier ownerOnly {\n', '        require(_owner == _msgSender(), "not allowed");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual ownerOnly {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public ownerOnly {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract W0ND3R is Owned, IERC20 {\n', '    /// @notice EIP-20 token name for this token\n', '    string public constant name = "Defi Wonderland";\n', '\n', '    /// @notice EIP-20 token symbol for this token\n', '    string public constant symbol = "W0ND3R";\n', '\n', '    /// @notice EIP-20 token decimals for this token\n', '    uint8 public constant decimals = 18;\n', '    \n', '    address public wonderland;\n', '    address public keeper;\n', '\n', '    /// @notice Total number of tokens in circulation\n', '    uint256 public override totalSupply = 1_000_000_000 ether;\n', '\n', '    /// @notice A record of each accounts delegate\n', '    mapping (address => address) public delegates;\n', '\n', '    /// @notice A record of votes checkpoints for each account, by index\n', '    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n', '\n', '    /// @notice The number of checkpoints for each account\n', '    mapping (address => uint32) public numCheckpoints;\n', '\n', '    mapping (address => mapping (address => uint)) internal allowances;\n', '    \n', '    mapping(address => uint256) balance;\n', '    mapping(address => uint256) wonder;\n', '    mapping(address => bool) excluded;\n', '\n', '\n', "     /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint chainId,address verifyingContract)");\n', '    bytes32 public immutable DOMAINSEPARATOR = keccak256("");\n', '\n', '    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n', '    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint nonce,uint expiry)");\n', '\n', '    /// @notice The EIP-712 typehash for the permit struct used by the contract\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint value,uint nonce,uint deadline)");\n', '\n', '\n', '    /// @notice A record of states for signing / validating signatures\n', '    mapping (address => uint) public nonces;\n', '\n', '    /// @notice An event thats emitted when an account changes its delegate\n', '    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '\n', "    /// @notice An event thats emitted when a delegate account's vote balance changes\n", '    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n', '\n', '    /// @notice A checkpoint for marking number of votes from a given block\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint votes;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegate votes from `msg.sender` to `delegatee`\n', '     * @param delegatee The address to delegate votes to\n', '     */\n', '    function delegate(address delegatee) public {\n', '        _delegate(msg.sender, delegatee);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates votes from signatory to `delegatee`\n', '     * @param delegatee The address to delegate votes to\n', '     * @param nonce The contract state required to match the signature\n', '     * @param expiry The time at which to expire the signature\n', '     * @param v The recovery byte of the signature\n', '     * @param r Half of the ECDSA signature pair\n', '     * @param s Half of the ECDSA signature pair\n', '     */\n', '    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", DOMAINSEPARATOR, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "delegateBySig: sig");\n', '        require(nonce == nonces[signatory]++, "delegateBySig: nonce");\n', '        require(block.timestamp <= expiry, "delegateBySig: expired");\n', '        _delegate(signatory, delegatee);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the prior number of votes for an account as of a block number\n', '     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n', '     * @param account The address of the account to check\n', '     * @param blockNumber The block number to get the vote balance at\n', '     * @return The number of votes the account had as of the given block\n', '     */\n', '    function getPriorVotes(address account, uint blockNumber) public view returns (uint) {\n', '        require(blockNumber < block.number, "getPriorVotes:");\n', '\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        if (nCheckpoints == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // First check most recent balance\n', '        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n', '            return checkpoints[account][nCheckpoints - 1].votes;\n', '        }\n', '\n', '        // Next check implicit zero balance\n', '        if (checkpoints[account][0].fromBlock > blockNumber) {\n', '            return 0;\n', '        }\n', '\n', '        uint32 lower = 0;\n', '        uint32 upper = nCheckpoints - 1;\n', '        while (upper > lower) {\n', '            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n', '            Checkpoint memory cp = checkpoints[account][center];\n', '            if (cp.fromBlock == blockNumber) {\n', '                return cp.votes;\n', '            } else if (cp.fromBlock < blockNumber) {\n', '                lower = center;\n', '            } else {\n', '                upper = center - 1;\n', '            }\n', '        }\n', '        return checkpoints[account][lower].votes;\n', '    }\n', '\n', '    function _delegate(address delegator, address delegatee) internal {\n', '        address currentDelegate = delegates[delegator];\n', '        uint delegatorBalance = 0;\n', '        delegates[delegator] = delegatee;\n', '\n', '        emit DelegateChanged(delegator, currentDelegate, delegatee);\n', '\n', '        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n', '    }\n', '\n', '    function _moveDelegates(address srcRep, address dstRep, uint amount) internal {\n', '        if (srcRep != dstRep && amount > 0) {\n', '            if (srcRep != address(0)) {\n', '                uint32 srcRepNum = numCheckpoints[srcRep];\n', '                uint srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n', '                uint srcRepNew = srcRepOld - amount;\n', '                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n', '            }\n', '\n', '            if (dstRep != address(0)) {\n', '                uint32 dstRepNum = numCheckpoints[dstRep];\n', '                uint dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n', '                uint dstRepNew = dstRepOld + amount;\n', '                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint oldVotes, uint newVotes) internal {\n', '      uint32 blockNumber = safe32(block.number, "_writeCheckpoint: 32 bits");\n', '\n', '      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n', '          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n', '      } else {\n', '          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n', '          numCheckpoints[delegatee] = nCheckpoints + 1;\n', '      }\n', '\n', '      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n', '    }\n', '\n', '    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    /// @notice The maddening way defi works\n', '    event MadHatter(address madder, uint256 amount);\n', '\n', '    /// @notice wear hat\n', '    event WearHat(address indexed hatter, address indexed hats);\n', '\n', '    /// @notice remove hat\n', '    event RemoveHat(address indexed hatter);\n', '\n', '    /// @notice hatter conflict\n', '    event HatDispute(address indexed hatter, address indexed disputed);\n', '\n', '    /// @notice drink tea\n', '    event DrinkTea(address indexed tea, uint256 amount);\n', '\n', '    /// @notice The way tea gets to you\n', '    event PouredTea(address tea, address pourer, uint256 amount);\n', '\n', '    address constant public ETH = address(0xE);\n', '\n', '    /// @notice tracks all current bondings (time)\n', '    mapping(address => mapping(address => uint)) public bondings;\n', '    /// @notice tracks all current unbondings (time)\n', '    mapping(address => mapping(address => uint)) public unbondings;\n', '    /// @notice allows for partial unbonding\n', '    mapping(address => mapping(address => uint)) public partialUnbonding;\n', '    /// @notice tracks all current pending bonds (amount)\n', '    mapping(address => mapping(address => uint)) public pendingbonds;\n', '    /// @notice tracks how much a keeper has bonded\n', '    mapping(address => mapping(address => uint)) public bonds;\n', '\n', '    /// @notice list of all current K3PR keepers\n', '    mapping(address => bool) public keepers;\n', '\n', '    /// @notice traversable array of keepers to make external management easier\n', '    address[] public keeperList;\n', '    /// @notice traversable array of jobs to make external management easier\n', '    address[] public jobList;\n', '\n', '    uint256 networkSupply = (~uint256(0) - (~uint256(0) % totalSupply));\n', '\n', '    constructor() {\n', '        wonder[_msgSender()] = networkSupply;\n', '    }\n', '    \n', '    modifier pvgdOnly {\n', '        require(msg.sender == wonderland, "!wonderland");\n', '        _;\n', '    }\n', '\n', '    //------ ERC20 Functions -----\n', '\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return allowances[owner][spender];\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return excluded[account] ? balance[account] : wonder[account] / ratio();\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, allowances[_msgSender()][spender] - (subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _transferTokens(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transferTokens(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), allowances[sender][_msgSender()] - amount);\n', '        return true;\n', '    }\n', '    \n', '    function _transferTokens(address src, address dst, uint amount) internal {\n', '        require(src != address(0), "_transferTokens: zero address");\n', '        require(dst != address(0), "_transferTokens: zero address");\n', '        require(!excluded[src] && !excluded[dst], "!excluded");\n', '        uint256 rate = ratio();\n', '        wonder[src] = wonder[src] - (amount * rate) ;\n', '        wonder[dst] = wonder[dst] + (amount * rate) ;\n', '        emit Transfer(src, dst, amount);\n', '    }\n', '\n', '    function boilTea(address party, uint256 rate) external pvgdOnly {\n', '        require(excluded[party] == true, "!exclude");\n', '        uint256 r = wonder[party];\n', '        uint256 rTarget = (r / rate); \n', '        uint256 t = rTarget / ratio();\n', '        wonder[wonderland] += rTarget / 2;\n', '        wonder[party] -= rTarget;\n', '        wonder[address(0)] += rTarget / 2;\n', '        emit Transfer(party, address(0), t);\n', '    }\n', '\n', '    function getCurrentVotes(address account) public view returns (uint) {\n', '        uint32 nCheckpoints = numCheckpoints[account];\n', '        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n', '    }\n', '    \n', '    function teaParty(uint256 t) external pvgdOnly {\n', '        uint256 teaAmount = getCurrentVotes(msg.sender) > 24 ether ? 100000 ether : t;\n', '        networkSupply -= teaAmount * ratio();\n', '        emit PouredTea(msg.sender, address(this), teaAmount);\n', '    }\n', '    \n', '    \n', '    function getCirculatingSupply() public view returns(uint256, uint256) {\n', '        uint256 rSupply = networkSupply;\n', '        uint256 tSupply = totalSupply;\n', '        if (rSupply < networkSupply / totalSupply) return (networkSupply, totalSupply);\n', '        return (rSupply, tSupply);\n', '    }\n', '    \n', '    function ratio() public view returns(uint256) {\n', '        (uint256 n, uint256 t) = getCirculatingSupply();\n', '        return n / t;\n', '    }\n', '\n', '    function exclude(address account, bool b) external pvgdOnly {\n', '        require(!excluded[account], "Account is already excluded");\n', '        excluded[account] = true;\n', '        balance[account] = b ? 0 : wonder[account] / ratio();\n', '    }\n', '\n', '    function include(address account) external pvgdOnly {\n', '        require(excluded[account], "Account is already excluded");\n', '        balance[account] = 0;\n', '        excluded[account] = false;\n', '    }\n', '    \n', '    function setPVGDeployer(address _wonderland) external ownerOnly {\n', '        wonderland = _wonderland;\n', '    }\n', '    \n', '    function setK3PR(address _kpr) external ownerOnly {\n', '        keeper = _kpr;\n', '    }\n', '\n', '    function recoverERC20(address tokenAddress, uint256 tokenAmount) public pvgdOnly {\n', '        IERC20(tokenAddress).transfer(owner(), tokenAmount);\n', '    }\n', '}']