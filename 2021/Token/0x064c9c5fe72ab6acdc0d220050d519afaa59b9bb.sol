['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC1155 {\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) external;\n', '\n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) external;\n', '}\n', '\n', 'interface IERC721 {\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\n', '    \n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function approve(address to, uint256 tokenId) external;\n', '    \n', '    function isApprovedForAll(address owner, address operator) external returns (bool);\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '        * @dev Returns the amount of tokens owned by `account`.\n', '        */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '        *\n', '        * Returns a boolean value indicating whether the operation succeeded.\n', '        *\n', '        * Emits a {Transfer} event.\n', '        */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', '\n', 'interface INFT20Pair {\n', '    function withdraw(\n', '        uint256[] calldata _tokenIds,\n', '        uint256[] calldata amounts,\n', '        address recipient\n', '    ) external;\n', '\n', '    function withdraw(\n', '        uint256[] calldata _tokenIds,\n', '        uint256[] calldata amounts\n', '    ) external;\n', '\n', '    function track1155(uint256 _tokenId) external returns (uint256);\n', '\n', '    function multi721Deposit(uint256[] memory _ids, address _referral) external;\n', '}\n', '\n', 'interface INft20Registry {\n', '    function nftToErc20(address nftAddr) external view returns (address erc20Addr);\n', '}\n', '\n', 'library Nft20Market {\n', '\n', '    struct NftDetails {\n', '        address nftAddr;\n', '        uint256[] tokenIds;\n', '        uint256[] amounts;\n', '    }\n', '\n', '    INft20Registry public constant Nft20Registry = INft20Registry(0xB0244fDEf4E48c2bCBAcf10cC8dd07f0CB45E7Bf); \n', '    uint256 public constant NFT20_NFT_VALUE = 100 * 10**18;\n', '    address public constant REFERRAL = 0x073Ab1C0CAd3677cDe9BDb0cDEEDC2085c029579;\n', '\n', '    function _approve(address _operator, address _token) internal {\n', '        if(!IERC721(_token).isApprovedForAll(address(this), _operator)) {\n', '            IERC721(_token).setApprovalForAll(_operator, true);\n', '        }\n', '    }\n', '\n', '    function sellERC721ForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address _erc20Address, uint256 _erc20Amount) {        \n', '        address _fromERC721;\n', '        uint256[] memory _ids;\n', '        \n', '        (_fromERC721, _ids) = abi.decode(\n', '            data,\n', '            (address, uint256[])\n', '        );\n', '\n', '        // NFT20 ERC20 for the _fromERC721\n', '        _erc20Address = Nft20Registry.nftToErc20(_fromERC721);\n', '\n', '        // save gas in case only a single ERC721 needs to be sold\n', '        if(_ids.length == 1) {\n', '            // transfer the token to NFT20 ERC20\n', '            IERC721(_fromERC721).safeTransferFrom(\n', '                address(this),\n', '                _erc20Address,\n', '                _ids[0],\n', '                abi.encodePacked(REFERRAL) // referral\n', '            );\n', '        }\n', '        // in case multiple ERC721(s) need to be sold\n', '        else {\n', '            // approve tokens to the NFT20 ERC20 contract\n', '            _approve(_erc20Address, _fromERC721);\n', '            // mint NFT20 ERC20 \n', '            INFT20Pair(_erc20Address).multi721Deposit(\n', '                _ids,\n', '                REFERRAL // referral\n', '            );\n', '        }\n', '\n', '        return (\n', '            _erc20Address,\n', '            IERC20(_erc20Address).balanceOf(address(this))\n', '        );\n', '    }\n', '\n', '    function sellERC1155ForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address _erc20Address, uint256 _erc20Amount) {\n', '        address _fromERC1155;\n', '        uint256 _id;\n', '        uint256 _amount;\n', '        \n', '        (_fromERC1155, _id, _amount) = abi.decode(\n', '            data,\n', '            (address, uint256, uint256)\n', '        );\n', '\n', '        // NFT20 ERC20 for the _fromERC1155\n', '        _erc20Address = Nft20Registry.nftToErc20(_fromERC1155);\n', '\n', '        // transfer the token to NFT20 ERC20\n', '        IERC1155(_fromERC1155).safeTransferFrom(\n', '            address(this),\n', '            _erc20Address,\n', '            _id,\n', '            _amount,\n', '            abi.encodePacked(REFERRAL) // referral\n', '        );\n', '        return (\n', '            _erc20Address,\n', '            IERC20(_erc20Address).balanceOf(address(this))\n', '        );\n', '    }\n', '\n', '    function sellERC1155BatchForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address _erc20Address, uint256 _erc20Amount) {\n', '        address _fromERC1155;\n', '        uint256[] memory _ids;\n', '        uint256[] memory _amounts;\n', '\n', '        (_fromERC1155, _ids, _amounts) = abi.decode(\n', '            data,\n', '            (address, uint256[], uint256[])\n', '        );\n', '\n', '        // NFT20 ERC20 for the _fromERC1155\n', '        _erc20Address = Nft20Registry.nftToErc20(_fromERC1155);\n', '\n', '        // transfer the tokens to NFT20 ERC20\n', '        IERC1155(_fromERC1155).safeBatchTransferFrom(\n', '            address(this),\n', '            _erc20Address,\n', '            _ids,\n', '            _amounts,\n', '            abi.encodePacked(REFERRAL) // referral\n', '        );\n', '        return (\n', '            _erc20Address,\n', '            IERC20(_erc20Address).balanceOf(address(this))\n', '        );\n', '    }\n', '\n', '    function buyAssetsForErc20(bytes memory data, address recipient) external {\n', '        address _nftAddr;\n', '        address _fromERC20;\n', '        uint256[] memory _ids;\n', '        uint256[] memory _amounts;\n', '        \n', '        (_nftAddr, _fromERC20, _ids, _amounts) = abi.decode(\n', '            data,\n', '            (address, address, uint256[], uint256[])\n', '        );\n', '\n', '        // Handle special cases where we cannot directly send NFTs to the recipient\n', '        if(\n', '            _fromERC20 == 0x22C4AD011Cce6a398B15503e0aB64286568933Ed || // Doki Doki\n', '            _fromERC20 == 0x303Af77Cf2774AABff12462C110A0CCf971D7DbE || // Node Runners\n', '            _fromERC20 == 0xaDBEBbd65a041E3AEb474FE9fe6939577eB2544F || // Chonker Finance\n', '            _fromERC20 == 0x57C31c042Cb2F6a50F3dA70ADe4fEE20C86B7493    // Block Art         \n', '        ) {\n', '            for(uint256 i = 0; i < _ids.length; i++) {\n', '                uint256[] memory _tempIds = new uint256[](1);\n', '                uint256[] memory _tempAmounts = new uint256[](1);\n', '                _tempIds[0] =  _ids[i];\n', '                _tempAmounts[0] =  _amounts[i];\n', '                INFT20Pair(_fromERC20).withdraw(_tempIds, _tempAmounts);\n', '                \n', '                // transfer the ERC721 to the recipient\n', '                if(_fromERC20 == 0x57C31c042Cb2F6a50F3dA70ADe4fEE20C86B7493) {\n', '                    IERC721(_nftAddr).transferFrom(address(this), recipient, _ids[i]);\n', '                }\n', '            }\n', '            // transfer the ERC1155 to the recipient\n', '            IERC1155(_nftAddr).safeBatchTransferFrom(address(this), recipient, _ids, _amounts, "");\n', '        }\n', '        // send NFTs to the recipient\n', '        else {\n', '            INFT20Pair(_fromERC20).withdraw(_ids, _amounts, recipient);\n', '        }\n', '    }\n', '\n', '    function estimateBatchAssetPriceInErc20(bytes memory data) public view returns(address[] memory erc20Addrs, uint256[] memory erc20Amounts) {\n', '        // get nft details\n', '        NftDetails[] memory nftDetails;\n', '        (nftDetails) = abi.decode(\n', '            data,\n', '            (NftDetails[])\n', '        );\n', '\n', '        // initialize return variables\n', '        erc20Addrs = new address[](nftDetails.length); \n', '        erc20Amounts = new uint256[](nftDetails.length);\n', '\n', '        for (uint256 i = 0; i < nftDetails.length; i++) {\n', '            // populate equivalent ERC20 \n', '            erc20Addrs[i] = Nft20Registry.nftToErc20(nftDetails[i].nftAddr);\n', '            // nft should be supported\n', '            require(erc20Addrs[i] != address(0), "estimateBatchAssetPriceInErc20: unsupported nft");\n', '            // calculate token amount needed\n', '            for (uint256 j = 0; j < nftDetails[i].tokenIds.length; j++) {\n', '                erc20Amounts[i] = erc20Amounts[i] + nftDetails[i].amounts[j]*NFT20_NFT_VALUE;\n', '            }\n', '        }\n', '    }\n', '}']