['from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', 'event Transfer:\n', '\t_from: indexed(address)\n', '\t_to: indexed(address)\n', '\t_value: uint256\n', '\n', 'event Approval:\n', '\t_owner: indexed(address)\n', '\t_spender: indexed(address)\n', '\t_value: uint256\n', '\n', 'event Freeze:\n', '\t_account: indexed(address)\n', '\t_freeze: bool\n', '\n', 'name: public(String[10])\n', 'symbol: public(String[3])\n', 'coinSupply: public(uint256)\n', 'maxSupply: public(uint256)\n', 'decimals: public(uint256)\n', 'balances: public(HashMap[address, uint256])\n', '\n', 'allowed: HashMap[address, HashMap[address, uint256]]\n', 'frozenBalances: public(HashMap[address, bool])\n', 'owner: public(address)\n', '\n', 'ecoMgr: public(address)\n', '\n', '@external\n', 'def __init__():\n', '\t_initialSupply: uint256 = 10000000000\n', '\t_decimals: uint256 = 18\n', '\tself.coinSupply = _initialSupply * 10 ** _decimals\n', "\tself.name = 'SmartrCoin'\n", "\tself.symbol = 'SMC'\n", '\tself.decimals = _decimals\n', '\tself.owner = msg.sender\n', '\tself.balances[msg.sender] = self.coinSupply\n', '\tself.maxSupply = (_initialSupply * 10 ** _decimals) * 2\n', '\n', '\tlog Transfer(ZERO_ADDRESS, msg.sender, self.coinSupply)\n', '\n', '@external\n', 'def addMgr(_mgr: address) -> bool:\n', '\tassert msg.sender == self.owner\n', '\tself.ecoMgr = _mgr\n', '\treturn True\n', '\n', '@external\n', 'def freezeBalance(_target: address, _freeze: bool) -> bool:\n', '\tassert self.ecoMgr == msg.sender or msg.sender == self.owner\n', '\tself.frozenBalances[_target] = _freeze\n', '\n', '\tlog Freeze(_target, _freeze)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def mintCoin(_value: uint256) -> bool:\n', '\t"""\n', '\t@dev Mint an amount of coin\n', '\t@param _value The amount of coin to be minted.\n', '\t"""\n', '\tassert self.ecoMgr == msg.sender or self.owner == msg.sender\n', '\tassert self.coinSupply + _value <= self.maxSupply\n', '\tself.coinSupply += _value\n', '\tself.balances[msg.sender] += _value\n', '\n', '\tlog Transfer(ZERO_ADDRESS, msg.sender, _value)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def burnCoin(_value: uint256) -> bool:\n', '\t"""\n', '\t@dev Burn an amount of coin\n', '\t@param _value The amount of coin to be burned\n', '\t"""\n', '\tassert self.ecoMgr == msg.sender or self.owner == msg.sender\n', '\tassert self.balances[msg.sender] >= _value\n', '\tself.coinSupply -= _value\n', '\tself.balances[msg.sender] -= _value\n', '\n', '\tlog Transfer(msg.sender, ZERO_ADDRESS, _value)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def balanceOf(_owner: address) -> uint256:\n', '\treturn self.balances[_owner]\n', '\n', '@external\n', 'def transfer(_to: address, _amount: uint256) -> bool:\n', '\tassert _to != ZERO_ADDRESS\n', '\tassert self.balances[msg.sender] >= _amount\n', '\tassert self.frozenBalances[msg.sender] == False\n', '\tself.balances[msg.sender] -= _amount\n', '\tself.balances[_to] += _amount\n', '\n', '\tlog Transfer(msg.sender, _to, _amount)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def transferFrom(_from: address, _to: address, _value: uint256) -> bool:\n', '\tassert _value <= self.allowed[_from][msg.sender]\n', '\tassert _value <= self.balances[_from]\n', '\tassert self.frozenBalances[msg.sender] == False\n', '\n', '\tself.balances[_from] -= _value\n', '\tself.allowed[_from][msg.sender] -= _value\n', '\tself.balances[_to] += _value\n', '\n', '\tlog Transfer (_from, _to, _value)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def approve(_spender: address, _amount: uint256) -> bool:\n', '\tself.allowed[msg.sender][_spender] = _amount\n', '\n', '\tlog Approval(msg.sender, _spender, _amount)\n', '\n', '\treturn True\n', '\n', '@external\n', 'def allowance(_owner: address, _spender: address) -> uint256:\n', '\treturn self.allowed[_owner][_spender]\n', '\n', '@external\n', 'def totalSupply() -> uint256:\n', '\treturn self.coinSupply']