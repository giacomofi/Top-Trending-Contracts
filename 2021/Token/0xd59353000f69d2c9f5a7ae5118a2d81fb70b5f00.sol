['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract Erc20Token is IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping(address => uint256)) internal allowances;\n', '    uint256 internal totalSupply_;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public inflationRate; // in 10**2\n', '    uint256 private maximumSupply;\n', '    uint256 public startTime;\n', '    uint256 public lastTime;\n', '\n', '\n', '    constructor(uint256 initialSupply, uint256 InfRate, uint256 mSupply) public {\n', '        balances[mintAccessor] = initialSupply;\n', '        totalSupply_ = initialSupply;\n', '        emit Transfer(address(0), mintAccessor, initialSupply);\n', '        inflationRate = InfRate;\n', '        name = "Pallapay";\n', '        symbol = "PALL";\n', '        decimals = 8;\n', '        maximumSupply = mSupply;\n', '        startTime = block.timestamp;\n', '        lastTime = block.timestamp;\n', '    }\n', '\n', '\n', '    /**\n', "     * Transfer token from sender(caller) to '_to' account\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - `_to` cannot be the zero address.\n', '     * - the sender(caller) must have a balance of at least `_value`.\n', '     */\n', '    function transfer(address _to, uint256 _value) public override returns (bool) {\n', '        require (_value <= balances[msg.sender], "transfer value should be smaller than your balance");\n', '        require (_to != address(0));\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', "     * sender(caller) transfer '_value' token to '_to' address from '_from' address\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - `_to` and `_from` cannot be the zero address.\n', '     * - `_from` must have a balance of at least `_value` .\n', "     * - the sender(caller) must have allowance for `_from`'s tokens of at least `_value`.\n", '     */\n', '    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\n', '        require (_from != address(0),"_from address is not valid");\n', '        require (_to != address(0),"_to address is not valid");\n', '        require(_value<=allowances[_from][msg.sender], "_value should be smaller than your allowance");\n', '        require(_value<=balances[_from],"_value should be smaller than _from\'s balance");\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * change allowance of `_spender` to `_value` by sender(caller)\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address _spender, uint256 _value) public override returns (bool) {\n', '        require (_spender != address(0),  "_spender is not valid address");\n', '        allowances[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Atomically increases the allowance granted to `spender` by the sender(caller).\n', '    * Emits an {Approval} event indicating the updated allowance.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `spender` cannot be the zero address.\n', '    */\n', '    function increaseApproval(address _spender, uint _addedValue) public override returns (bool) {\n', '        require (_spender != address(0),  "_spender is not valid address");\n', '        allowances[msg.sender][_spender] = allowances[msg.sender][_spender].add(_addedValue);\n', '        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Atomically decreases the allowance granted to `spender` by the sender(caller).\n', '    * Emits an {Approval} event indicating the updated allowance.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `_spender` cannot be the zero address.\n', '    * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n', '    */\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public override returns (bool) {\n', '        require (_spender != address(0),  "_spender is not valid address");\n', '        uint oldValue = allowances[msg.sender][_spender];\n', '        allowances[msg.sender][_spender] = _subtractedValue > oldValue ? 0 : oldValue.sub(_subtractedValue);\n', '        emit Approval(msg.sender, _spender, allowances[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '\n', '    /**\n', '    * Destroys `amount` tokens from `account`, reducing the\n', '    * total supply.\n', '    * Emits a {Transfer} event with `to` set to the zero address.\n', '    *\n', '    * Requirements:\n', '    * - `amount` cannot be less than zero.\n', "    * - `amount` cannot be more than sender(caller)'s balance.\n", '    */\n', '    function burn(uint256 amount) public {\n', '        require(amount > 0, "amount cannot be less than zero");\n', '        require(amount <= balances[msg.sender], "amount to burn is more than the caller\'s balance");\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        totalSupply_ = totalSupply_.sub(amount);\n', '        emit Transfer(msg.sender, address(0), amount);\n', '    }\n', '    \n', '\n', '    /**\n', "    * sender(caller) create a 'value' token mint request.\n", '    *\n', '    * Requirement:\n', '    * - sender(Caller) should be mintAccessorAddress\n', '    */\n', '    function mint(uint256 value) public {\n', '        require(msg.sender == mintAccessor,"you are not permitted to create mint request!");\n', '        \n', '        if (block.timestamp.sub(lastTime) >= 366 days) {\n', '            maximumSupply = maximumSupply.mul(10**4 + inflationRate).div(10**4);\n', '            lastTime = block.timestamp;\n', '        }\n', '\n', '        require(totalSupply().add(value) <= maxSupply(), "mint value more than maxSupply is not allowed!");\n', '\n', '        totalSupply_ = totalSupply_.add(value);\n', '        balances[mintDest] = balances[mintDest].add(value);\n', '        emit Transfer(address(0), mintDest, value);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply_;\n', '    }\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '\n', '    function maxSupply() public view returns(uint256) {\n', '        return maximumSupply.add(maximumSupply.mul(inflationRate).mul(block.timestamp.sub(lastTime)).div(366 days).div(10**4));\n', '    }\n', '}']