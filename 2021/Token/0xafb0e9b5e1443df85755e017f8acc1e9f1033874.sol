['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-24\n', '*/\n', '\n', '// File: contracts/lib/InitializableOwnable.sol\n', '\n', '/*\n', '\n', '    Copyright 2021 DODO ZOO.\n', '    SPDX-License-Identifier: Apache-2.0\n', '\n', '*/\n', '\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract InitializableOwnable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '    bool internal _INITIALIZED_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier notInitialized() {\n', '        require(!_INITIALIZED_, "DODO_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function initOwner(address newOwner) public notInitialized {\n', '        _INITIALIZED_ = true;\n', '        _OWNER_ = newOwner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IERC20.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MUL_ERROR");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "DIVIDING_ERROR");\n', '        return a / b;\n', '    }\n', '\n', '    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 quotient = div(a, b);\n', '        uint256 remainder = a - quotient * b;\n', '        if (remainder > 0) {\n', '            return quotient + 1;\n', '        } else {\n', '            return quotient;\n', '        }\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SUB_ERROR");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ADD_ERROR");\n', '        return c;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = x / 2 + 1;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/DODOFee/FeeRateDIP3Impl.sol\n', '\n', '\n', '\n', 'interface ICrowdPooling {\n', '    function _QUOTE_RESERVE_() external view returns (uint256);\n', '    function getShares(address user) external view returns (uint256);\n', '}\n', '\n', 'interface IFee {\n', '    function getUserFee(address user) external view returns (uint256);\n', '}\n', '\n', 'interface IQuota {\n', '    function getUserQuota(address user) external view returns (int);\n', '}\n', '\n', 'interface IPool {\n', '    function version() external pure returns (string memory);\n', '    function _LP_FEE_RATE_() external view returns (uint256);\n', '}\n', '\n', 'contract FeeRateDIP3Impl is InitializableOwnable {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Storage  ============\n', '\n', '    uint256 public _LP_MT_RATIO_ = 25;\n', '\n', '    struct CPPoolInfo {\n', '        address quoteToken;\n', '        int globalQuota;\n', '        address feeAddr;\n', '        address quotaAddr;\n', '    }\n', '\n', '    mapping(address => CPPoolInfo) cpPools;\n', '\n', '    // ============ Ownable Functions ============\n', '    \n', '    function addCpPoolInfo(address cpPool, address quoteToken, int globalQuota, address feeAddr, address quotaAddr) external onlyOwner {\n', '        CPPoolInfo memory cpPoolInfo =  CPPoolInfo({\n', '            quoteToken: quoteToken,\n', '            feeAddr: feeAddr,\n', '            quotaAddr: quotaAddr,\n', '            globalQuota: globalQuota\n', '        });\n', '        cpPools[cpPool] = cpPoolInfo;\n', '    }\n', '\n', '    function setCpPoolInfo(address cpPool, address quoteToken, int globalQuota, address feeAddr, address quotaAddr) external onlyOwner {\n', '        cpPools[cpPool].quoteToken = quoteToken;\n', '        cpPools[cpPool].feeAddr = feeAddr;\n', '        cpPools[cpPool].quotaAddr = quotaAddr;\n', '        cpPools[cpPool].globalQuota = globalQuota;\n', '    }\n', '\n', '    function setLpMtRatio(uint256 newLpMtRatio) external onlyOwner {\n', '        _LP_MT_RATIO_ = newLpMtRatio;\n', '    }\n', '\n', '    // ============ View Functions ============\n', '\n', '    function getFeeRate(address pool, address user) external view returns (uint256) {\n', '        try IPool(pool).version() returns (string memory poolVersion) {\n', '            bytes32 hashPoolVersion = keccak256(abi.encodePacked(poolVersion));\n', '            if(hashPoolVersion == keccak256(abi.encodePacked("CP 1.0.0"))) {\n', '                CPPoolInfo memory cpPoolInfo = cpPools[pool];\n', '                address quoteToken = cpPoolInfo.quoteToken;\n', '                if(quoteToken == address(0)) {\n', '                    return 0;\n', '                }else {\n', '                    uint256 userInput = IERC20(quoteToken).balanceOf(pool).sub(ICrowdPooling(pool)._QUOTE_RESERVE_());\n', '                    uint256 userStake = ICrowdPooling(pool).getShares(user);\n', '                    address feeAddr = cpPoolInfo.feeAddr;\n', '                    address quotaAddr = cpPoolInfo.quotaAddr;\n', '                    int curQuota = cpPoolInfo.globalQuota;\n', '                    if(quotaAddr != address(0))\n', '                        curQuota = IQuota(quotaAddr).getUserQuota(user);\n', '\n', '                    require(curQuota == -1 || (curQuota != -1 && int(userInput.add(userStake)) <= curQuota), "DODOFeeImpl: EXCEED_YOUR_QUOTA");\n', '\n', '                    if(feeAddr == address(0)) {\n', '                        return 0;\n', '                    } else {\n', '                        return IFee(feeAddr).getUserFee(user);\n', '                    }\n', '                }\n', '            } else if(hashPoolVersion == keccak256(abi.encodePacked("DVM 1.0.2")) || hashPoolVersion == keccak256(abi.encodePacked("DSP 1.0.1"))) {\n', '                uint256 lpFeeRate = IPool(pool)._LP_FEE_RATE_();\n', '                uint256 mtFeeRate = lpFeeRate.mul(_LP_MT_RATIO_).div(100);\n', '                if(lpFeeRate.add(mtFeeRate) >= 10**18) {\n', '                    return 0;\n', '                } else {\n', '                    return mtFeeRate;\n', '                }\n', '            } else {\n', '                return 0;\n', '            }\n', '        } catch (bytes memory) {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getCPInfoByUser(address pool, address user) external view returns (bool isHaveCap, int curQuota, uint256 userFee) {\n', '        CPPoolInfo memory cpPoolInfo = cpPools[pool];\n', '        if(cpPoolInfo.quoteToken == address(0)) {\n', '            isHaveCap = false;\n', '            curQuota = -1;\n', '            userFee = 0;\n', '        }else {\n', '            address quotaAddr = cpPoolInfo.quotaAddr;\n', '            curQuota = cpPoolInfo.globalQuota;\n', '            if(quotaAddr != address(0))\n', '                curQuota = IQuota(quotaAddr).getUserQuota(user);\n', '        \n', '            if(curQuota == -1) {\n', '                isHaveCap = false;\n', '            }else {\n', '                isHaveCap = true;\n', '                uint256 userStake = ICrowdPooling(pool).getShares(user);\n', '                curQuota = int(uint256(curQuota).sub(userStake));\n', '            }\n', '\n', '            address feeAddr = cpPoolInfo.feeAddr;\n', '            if(feeAddr == address(0)) {\n', '                userFee =  0;\n', '            } else {\n', '                userFee = IFee(feeAddr).getUserFee(user);\n', '            }\n', '        }\n', '    }\n', '}']