['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-17\n', '*/\n', '\n', 'pragma solidity 0.4.24;\n', '\n', 'library SafeMath {\n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "      // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "      // benefit is lost if 'b' is also tested.\n", '      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '      if (a == 0) {\n', '         return 0;\n', '      }\n', '      c = a * b;  \n', '      assert(c / a == b);\n', '      return c;\n', '   }\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '      // uint256 c = a / b;\n', "      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '      return a / b;\n', '   }\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '   }\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '      c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '   }\n', '}\n', 'contract Token {\n', '   using SafeMath for uint256;\n', '   event Transfer(address indexed from, address indexed to, uint256 value);\n', '   event Approval(address indexed owner, address indexed spender, uint256 value);\n', '   mapping(address => uint256) balances;\n', '   uint256 totalSupply_;\n', '   function totalSupply() public view returns (uint256) {\n', '      return totalSupply_;\n', '   }\n', '   function transfer(address _to, uint256 _value) public returns (bool) {\n', '      require(_value <= balances[msg.sender], "balance of msg.sender insufficient");\n', '      require(_to != address(0));\n', '      balances[msg.sender] = balances[msg.sender].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      emit Transfer(msg.sender, _to, _value);\n', '      return true;\n', '   }\n', '   function balanceOf(address _owner) public view returns (uint256) {\n', '      return balances[_owner];\n', '   }\n', '   mapping (address => mapping (address => uint256)) internal allowed;\n', '   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n', '      require(_value <= balances[_from]);\n', '      require(_value <= allowed[_from][msg.sender]);\n', '      require(_to != address(0));\n', '      balances[_from] = balances[_from].sub(_value);\n', '      balances[_to] = balances[_to].add(_value);\n', '      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '      emit Transfer(_from, _to, _value);\n', '      return true;\n', '   }\n', '   function approve(address _spender, uint256 _value) public returns (bool) {\n', '      allowed[msg.sender][_spender] = _value;\n', '      emit Approval(msg.sender, _spender, _value);\n', '      return true;\n', '   }\n', '   function allowance(address _owner,address _spender) public view returns (uint256) {\n', '      return allowed[_owner][_spender];\n', '   }\n', '   function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n', '      allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n', '      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);   \n', '   }\n', '   function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n', '      uint256 oldValue = allowed[msg.sender][_spender];\n', '      if (_subtractedValue >= oldValue) {\n', '         allowed[msg.sender][_spender] = 0;\n', '      } else {\n', '         allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '      }\n', '      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '      return true;\n', '   }\n', '}\n', '\n', 'contract ChurroCoin is Token {\n', "   string public name = 'Churro Coin';\n", "   string public symbol = 'CHRR';\n", '   uint256 public decimals = 10;\n', '   uint256 public totalSupply = 1000e16;\n', '   address public crowdsaleAddress;\n', '   address public owner;\n', '   \n', '   modifier onlyCrowdsale {\n', '      require(msg.sender == crowdsaleAddress);\n', '      _;\n', '   }\n', '   modifier onlyOwner {\n', '      require(msg.sender == owner);\n', '      _;\n', '   }\n', '   constructor () public Token() {\n', '      owner = msg.sender;\n', '      balances[msg.sender] = 900e16;\n', '   }\n', '   function setCrowdsale(address _crowdsaleAddress) public onlyOwner {\n', '      require(_crowdsaleAddress != address(0));\n', '      crowdsaleAddress = _crowdsaleAddress;\n', '      balances[_crowdsaleAddress] = 100e16;\n', '   }\n', '   function buyTokens(address _receiver, uint256 _amount) public onlyCrowdsale {\n', '      require(_receiver != address(0));\n', '      require(_amount > 0);\n', '      \n', '      transfer(_receiver, _amount);\n', '   }\n', '}']