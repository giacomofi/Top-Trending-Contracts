['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-09\n', '*/\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/I_Token.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '/**\n', ' * @title   Interface Token\n', ' * @notice  Allows the Curve contract to interact with the token contract\n', ' *          without importing the entire smart contract. For documentation\n', ' *          please see the token contract:\n', ' *          https://gitlab.com/linumlabs/swarm-token\n', ' * @dev     This is not a full interface of the token, but instead a partial\n', ' *          interface covering only the functions that are needed by the curve.\n', ' */\n', 'interface I_Token {\n', '    // -------------------------------------------------------------------------\n', '    // IERC20 functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // ERC20 functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        external\n', '        returns (bool);\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        external\n', '        returns (bool);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // ERC20 Detailed\n', '    // -------------------------------------------------------------------------\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Burnable functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    function burn(uint256 amount) external;\n', '\n', '    function burnFrom(address account, uint256 amount) external;\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Mintable functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    function isMinter(address account) external view returns (bool);\n', '\n', '    function addMinter(address account) external;\n', '\n', '    function renounceMinter() external;\n', '\n', '    function mint(address account, uint256 amount) external returns (bool);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Capped functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    function cap() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/I_Curve.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '/**\n', ' * @title   Interface Curve\n', ' * @notice  This contract acts as an interface to the curve contract. For\n', ' *          documentation please see the curve smart contract.\n', ' */\n', 'interface I_Curve {\n', '    \n', '    // -------------------------------------------------------------------------\n', '    // View functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to buy\n', '     * @return uint256 The cost to buy the _amount of tokens in the collateral\n', '     *         currency (see collateral token).\n', '     */\n', '    function buyPrice(uint256 _amount)\n', '        external\n', '        view\n', '        returns (uint256 collateralRequired);\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to sell\n', '     * @return collateralReward The reward for selling the _amount of tokens in the\n', '     *         collateral currency (see collateral token).\n', '     */\n', '    function sellReward(uint256 _amount)\n', '        external\n', '        view\n', '        returns (uint256 collateralReward);\n', '\n', '    /**\n', '      * @return If the curve is both active and initialised.\n', '      */\n', '    function isCurveActive() external view returns (bool);\n', '\n', '    /**\n', '      * @return The address of the collateral token (DAI)\n', '      */\n', '    function collateralToken() external view returns (address);\n', '\n', '    /**\n', '      * @return The address of the bonded token (BZZ).\n', '      */\n', '    function bondedToken() external view returns (address);\n', '\n', '    /**\n', '      * @return The required collateral amount (DAI) to initialise the curve.\n', '      */\n', '    function requiredCollateral(uint256 _initialSupply)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // State modifying functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function initializes the curve contract, and ensure the\n', '     *         curve has the required permissions on the token contract needed\n', '     *         to function.\n', '     */\n', '    function init() external;\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mint(uint256 _amount, uint256 _maxCollateralSpend)\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @param  _to The address to send the tokens to.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mintTo(\n', '        uint256 _amount, \n', '        uint256 _maxCollateralSpend, \n', '        address _to\n', '    )\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to sell.\n', '      * @param  _minCollateralReward The min amount of collateral (DAI) the user is\n', '      *         willing to receive for their tokens.\n', '      * @return The status of the burn. Note that should the total reward of the\n', '      *         burn be below the _minCollateralReward the transaction will revert.\n', '      */\n', '    function redeem(uint256 _amount, uint256 _minCollateralReward)\n', '        external\n', '        returns (bool success);\n', '\n', '    /**\n', '      * @notice Shuts down the curve, disabling buying, selling and both price\n', '      *         functions. Can only be called by the owner. Will renounce the\n', '      *         minter role on the bonded token.\n', '      */\n', '    function shutDown() external;\n', '}\n', '\n', '// File: contracts/Curve.sol\n', '\n', 'pragma solidity 0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Curve is Ownable, I_Curve {\n', '    using SafeMath for uint256;\n', '    // The instance of the token this curve controls (has mint rights to)\n', '    I_Token internal bzz_;\n', '    // The instance of the collateral token that is used to buy and sell tokens\n', '    IERC20 internal dai_;\n', '    // Stores if the curve has been initialised\n', '    bool internal init_;\n', '    // The active state of the curve (false after emergency shutdown)\n', '    bool internal active_;\n', '    // Mutex guard for state modifying functions\n', '    uint256 private status_;\n', '    // States for the guard \n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Events\n', '    // -------------------------------------------------------------------------\n', '\n', '    // Emitted when tokens are minted\n', '    event mintTokens(\n', '        address indexed buyer,      // The address of the buyer\n', '        uint256 amount,             // The amount of bonded tokens to mint\n', '        uint256 pricePaid,          // The price in collateral tokens \n', '        uint256 maxSpend            // The max amount of collateral to spend\n', '    );\n', '    // Emitted when tokens are minted\n', '    event mintTokensTo(\n', '        address indexed buyer,      // The address of the buyer\n', '        address indexed receiver,   // The address of the receiver of the tokens\n', '        uint256 amount,             // The amount of bonded tokens to mint\n', '        uint256 pricePaid,          // The price in collateral tokens \n', '        uint256 maxSpend            // The max amount of collateral to spend\n', '    );\n', '    // Emitted when tokens are burnt\n', '    event burnTokens(\n', '        address indexed seller,     // The address of the seller\n', '        uint256 amount,             // The amount of bonded tokens to sell\n', '        uint256 rewardReceived,     // The collateral tokens received\n', '        uint256 minReward           // The min collateral reward for tokens\n', '    );\n', '    // Emitted when the curve is permanently shut down\n', '    event shutDownOccurred(address indexed owner);\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Modifiers\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '      * @notice Requires the curve to be initialised and active.\n', '      */\n', '    modifier isActive() {\n', '        require(active_ && init_, "Curve inactive");\n', '        _;\n', '    }\n', '\n', '    /**\n', '      * @notice Protects against re-entrancy attacks\n', '      */\n', '    modifier mutex() {\n', '        require(status_ != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        // Any calls to nonReentrant after this point will fail\n', '        status_ = _ENTERED;\n', '        // Function executes\n', '        _;\n', '        // Status set to not entered\n', '        status_ = _NOT_ENTERED;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Constructor\n', '    // -------------------------------------------------------------------------\n', '\n', '    constructor(address _bondedToken, address _collateralToken) public Ownable() {\n', '        bzz_ = I_Token(_bondedToken);\n', '        dai_ = IERC20(_collateralToken);\n', '        status_ = _NOT_ENTERED;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // View functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to buy\n', '     * @return uint256 The cost to buy the _amount of tokens in the collateral\n', '     *         currency (see collateral token).\n', '     */\n', '    function buyPrice(uint256 _amount)\n', '        public\n', '        view\n', '        isActive()\n', '        returns (uint256 collateralRequired)\n', '    {\n', '        collateralRequired = _mint(_amount, bzz_.totalSupply());\n', '        return collateralRequired;\n', '    }\n', '\n', '    /**\n', '     * @notice This function is only callable after the curve contract has been\n', '     *         initialized.\n', '     * @param  _amount The amount of tokens a user wants to sell\n', '     * @return collateralReward The reward for selling the _amount of tokens in the\n', '     *         collateral currency (see collateral token).\n', '     */\n', '    function sellReward(uint256 _amount)\n', '        public\n', '        view\n', '        isActive()\n', '        returns (uint256 collateralReward)\n', '    {\n', '        (collateralReward, ) = _withdraw(_amount, bzz_.totalSupply());\n', '        return collateralReward;\n', '    }\n', '\n', '    /**\n', '      * @return If the curve is both active and initialised.\n', '      */\n', '    function isCurveActive() public view returns (bool) {\n', '        if (active_ && init_) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '      * @param  _initialSupply The expected initial supply the bonded token\n', '      *         will have.\n', '      * @return The required collateral amount (DAI) to initialise the curve.\n', '      */\n', '    function requiredCollateral(uint256 _initialSupply)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _initializeCurve(_initialSupply);\n', '    }\n', '\n', '    /**\n', '      * @return The address of the bonded token (BZZ).\n', '      */\n', '    function bondedToken() external view returns (address) {\n', '        return address(bzz_);\n', '    }\n', '\n', '    /**\n', '      * @return The address of the collateral token (DAI)\n', '      */\n', '    function collateralToken() external view returns (address) {\n', '        return address(dai_);\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // State modifying functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '     * @notice This function initializes the curve contract, and ensure the\n', '     *         curve has the required permissions on the token contract needed\n', '     *         to function.\n', '     */\n', '    function init() external {\n', '        // Checks the curve has not already been initialized\n', '        require(!init_, "Curve is init");\n', '        // Checks the curve has the correct permissions on the given token\n', '        require(bzz_.isMinter(address(this)), "Curve is not minter");\n', '        // Gets the total supply of the token\n', '        uint256 initialSupply = bzz_.totalSupply();\n', '        // The curve requires that the initial supply is at least the expected\n', '        // open market supply\n', '        require(\n', '            initialSupply >= _MARKET_OPENING_SUPPLY,\n', '            "Curve equation requires pre-mint"\n', '        );\n', '        // Gets the price for the current supply\n', '        uint256 price = _initializeCurve(initialSupply);\n', '        // Requires the transfer for the collateral needed to back fill for the\n', '        // minted supply\n', '        require(\n', '            dai_.transferFrom(msg.sender, address(this), price),\n', '            "Failed to collateralized the curve"\n', '        );\n', '        // Sets the Curve to being active and initialised\n', '        active_ = true;\n', '        init_ = true;\n', '    }\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mint(\n', '        uint256 _amount, \n', '        uint256 _maxCollateralSpend\n', '    )\n', '        external\n', '        isActive()\n', '        mutex()\n', '        returns (bool success)\n', '    {\n', '        // Gets the price for the amount of tokens\n', '        uint256 price = _commonMint(_amount, _maxCollateralSpend, msg.sender);\n', '        // Emitting event with all important info\n', '        emit mintTokens(\n', '            msg.sender, \n', '            _amount, \n', '            price, \n', '            _maxCollateralSpend\n', '        );\n', '        // Returning that the mint executed successfully\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @param  _to The address to send the tokens to.\n', '      * @return The status of the mint. Note that should the total cost of the\n', '      *         purchase exceed the _maxCollateralSpend the transaction will revert.\n', '      */\n', '    function mintTo(\n', '        uint256 _amount, \n', '        uint256 _maxCollateralSpend, \n', '        address _to\n', '    )\n', '        external\n', '        isActive()\n', '        mutex()\n', '        returns (bool success)\n', '    {\n', '        // Gets the price for the amount of tokens\n', '        uint256 price =  _commonMint(_amount, _maxCollateralSpend, _to);\n', '        // Emitting event with all important info\n', '        emit mintTokensTo(\n', '            msg.sender,\n', '            _to, \n', '            _amount, \n', '            price, \n', '            _maxCollateralSpend\n', '        );\n', '        // Returning that the mint executed successfully\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to sell.\n', '      * @param  _minCollateralReward The min amount of collateral (DAI) the user is\n', '      *         willing to receive for their tokens.\n', '      * @return The status of the burn. Note that should the total reward of the\n', '      *         burn be below the _minCollateralReward the transaction will revert.\n', '      */\n', '    function redeem(uint256 _amount, uint256 _minCollateralReward)\n', '        external\n', '        isActive()\n', '        mutex()\n', '        returns (bool success)\n', '    {\n', '        // Gets the reward for the amount of tokens\n', '        uint256 reward = sellReward(_amount);\n', '        // Checks the reward has not slipped below the min amount the user\n', '        // wishes to receive.\n', '        require(reward >= _minCollateralReward, "Reward under min sell");\n', '        // Burns the number of tokens (fails - no bool return)\n', '        bzz_.burnFrom(msg.sender, _amount);\n', '        // Transfers the reward from the curve to the collateral token\n', '        require(\n', '            dai_.transfer(msg.sender, reward),\n', '            "Transferring collateral failed"\n', '        );\n', '        // Emitting event with all important info\n', '        emit burnTokens(\n', '            msg.sender, \n', '            _amount, \n', '            reward, \n', '            _minCollateralReward\n', '        );\n', '        // Returning that the burn executed successfully\n', '        return true;\n', '    }\n', '\n', '    /**\n', '      * @notice Shuts down the curve, disabling buying, selling and both price\n', '      *         functions. Can only be called by the owner. Will renounce the\n', '      *         minter role on the bonded token.\n', '      */\n', '    function shutDown() external onlyOwner() {\n', '        // Removes the curve as a minter on the token\n', '        bzz_.renounceMinter();\n', '        // Irreversibly shuts down the curve\n', '        active_ = false;\n', '        // Emitting address of owner who shut down curve permanently\n', '        emit shutDownOccurred(msg.sender);\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Internal functions\n', '    // -------------------------------------------------------------------------\n', '\n', '    /**\n', '      * @param  _amount The amount of tokens (BZZ) the user wants to buy.\n', '      * @param  _maxCollateralSpend The max amount of collateral (DAI) the user is\n', '      *         willing to spend in order to buy the _amount of tokens.\n', '      * @param  _to The address to send the tokens to.\n', '      * @return uint256 The price the user has paid for buying the _amount of \n', '      *         BUZZ tokens. \n', '      */\n', '    function _commonMint(\n', '        uint256 _amount,\n', '        uint256 _maxCollateralSpend,\n', '        address _to\n', '    )\n', '        internal\n', '        returns(uint256)\n', '    {\n', '        // Gets the price for the amount of tokens\n', '        uint256 price = buyPrice(_amount);\n', '        // Checks the price has not risen above the max amount the user wishes\n', '        // to spend.\n', '        require(price <= _maxCollateralSpend, "Price exceeds max spend");\n', '        // Transfers the price of tokens in the collateral token to the curve\n', '        require(\n', '            dai_.transferFrom(msg.sender, address(this), price),\n', '            "Transferring collateral failed"\n', '        );\n', '        // Mints the user their tokens\n', '        require(bzz_.mint(_to, _amount), "Minting tokens failed");\n', '        // Returns the price the user will pay for buy\n', '        return price;\n', '    }\n', '\n', '    // -------------------------------------------------------------------------\n', '    // Curve mathematical functions\n', '\n', '    uint256 internal constant _BZZ_SCALE = 1e16;\n', '    uint256 internal constant _N = 5;\n', '    uint256 internal constant _MARKET_OPENING_SUPPLY = 62500000 * _BZZ_SCALE;\n', '    // Equation for curve: \n', '\n', '    /**\n', '     * @param   x The supply to calculate at.\n', '     * @return  x^32/_MARKET_OPENING_SUPPLY^5\n', '     * @dev     Calculates the 32 power of `x` (`x` squared 5 times) times a \n', '     *          constant. Each time it squares the function it divides by the \n', '     *          `_MARKET_OPENING_SUPPLY` so when `x` = `_MARKET_OPENING_SUPPLY` \n', "     *          it doesn't change `x`. \n", '     *\n', '     *          `c*x^32` | `c` is chosen in such a way that \n', '     *          `_MARKET_OPENING_SUPPLY` is the fixed point of the helper \n', '     *          function.\n', '     *\n', '     *          The division by `_MARKET_OPENING_SUPPLY` also helps avoid an \n', '     *          overflow.\n', '     *\n', '     *          The `_helper` function is separate to the `_primitiveFunction` \n', '     *          as we modify `x`. \n', '     */\n', '    function _helper(uint256 x) internal view returns (uint256) {\n', '        for (uint256 index = 1; index <= _N; index++) {\n', '            x = (x.mul(x)).div(_MARKET_OPENING_SUPPLY);\n', '        }\n', '        return x;\n', '    }\n', '\n', '    /**\n', '     * @param   s The supply point being calculated for. \n', '     * @return  The amount of DAI required for the requested amount of BZZ (s). \n', '     * @dev     `s` is being added because it is the linear term in the \n', '     *          polynomial (this ensures no free BUZZ tokens).\n', '     *\n', '     *          primitive function equation: s + c*s^32.\n', '     * \n', '     *          See the helper function for the definition of `c`.\n', '     *\n', '     *          Converts from something measured in BZZ (1e16) to dai atomic \n', '     *          units 1e18.\n', '     */\n', '    function _primitiveFunction(uint256 s) internal view returns (uint256) {\n', '        return s.add(_helper(s));\n', '    }\n', '\n', '    /**\n', '     * @param  _supply The number of tokens that exist.\n', '     * @return uint256 The price for the next token up the curve.\n', '     */\n', '    function _spotPrice(uint256 _supply) internal view returns (uint256) {\n', '        return (_primitiveFunction(_supply.add(1)).sub(_primitiveFunction(_supply)));\n', '    }\n', '\n', '    /**\n', '     * @param  _amount The amount of tokens to be minted\n', '     * @param  _currentSupply The current supply of tokens\n', '     * @return uint256 The cost for the tokens\n', '     * @return uint256 The price being paid per token\n', '     */\n', '    function _mint(uint256 _amount, uint256 _currentSupply)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 deltaR = _primitiveFunction(_currentSupply.add(_amount)).sub(\n', '            _primitiveFunction(_currentSupply));\n', '        return deltaR;\n', '    }\n', '\n', '    /**\n', '     * @param  _amount The amount of tokens to be sold\n', '     * @param  _currentSupply The current supply of tokens\n', '     * @return uint256 The reward for the tokens\n', '     * @return uint256 The price being received per token\n', '     */\n', '    function _withdraw(uint256 _amount, uint256 _currentSupply)\n', '        internal\n', '        view\n', '        returns (uint256, uint256)\n', '    {\n', '        assert(_currentSupply - _amount > 0);\n', '        uint256 deltaR = _primitiveFunction(_currentSupply).sub(\n', '            _primitiveFunction(_currentSupply.sub(_amount)));\n', '        uint256 realized_price = deltaR.div(_amount);\n', '        return (deltaR, realized_price);\n', '    }\n', '\n', '    /**\n', '     * @param  _initial_supply The supply the curve is going to start with.\n', '     * @return initial_reserve How much collateral is needed to collateralized\n', '     *         the bonding curve.\n', '     * @return price The price being paid per token (averaged).\n', '     */\n', '    function _initializeCurve(uint256 _initial_supply)\n', '        internal\n', '        view\n', '        returns (uint256 price)\n', '    {\n', '        price = _mint(_initial_supply, 0);\n', '        return price;\n', '    }\n', '}']