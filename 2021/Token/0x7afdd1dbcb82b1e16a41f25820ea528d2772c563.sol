['# @version 0.1.0b17\n', '# only call calc_withdraw_one_coin for compatible with Swerve\n', '# (c) Curve.Fi, UU.finance 2021\n', 'from vyper.interfaces import ERC20\n', '\n', '# External Contracts\n', 'contract yERC20:\n', '    def totalSupply() -> uint256: constant\n', '    def allowance(_owner: address, _spender: address) -> uint256: constant\n', '    def transfer(_to: address, _value: uint256) -> bool: modifying\n', '    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: modifying\n', '    def approve(_spender: address, _value: uint256) -> bool: modifying\n', '    def name() -> string[64]: constant\n', '    def symbol() -> string[32]: constant\n', '    def decimals() -> uint256: constant\n', '    def balanceOf(arg0: address) -> uint256: constant\n', '    def deposit(depositAmount: uint256): modifying\n', '    def withdraw(withdrawTokens: uint256): modifying\n', '    def getPricePerFullShare() -> uint256: constant\n', '\n', '\n', '\n', '\n', '# Tether transfer-only ABI\n', 'contract USDT:\n', '    def transfer(_to: address, _value: uint256): modifying\n', '    def transferFrom(_from: address, _to: address, _value: uint256): modifying\n', '\n', '\n', 'contract Curve:\n', '    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256): modifying\n', '    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): modifying\n', '    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256): modifying\n', '    def balances(i: int128) -> uint256: constant\n', '    def A() -> uint256: constant\n', '    def fee() -> uint256: constant\n', '    def owner() -> address: constant\n', '\n', '\n', 'N_COINS: constant(int128) = 4\n', 'TETHERED: constant(bool[N_COINS]) = [False, False, True, False]\n', 'ZERO256: constant(uint256) = 0  # This hack is really bad XXX\n', 'ZEROS: constant(uint256[N_COINS]) = [ZERO256, ZERO256, ZERO256, ZERO256]  # <- change\n', 'LENDING_PRECISION: constant(uint256) = 10 ** 18\n', 'PRECISION: constant(uint256) = 10 ** 18\n', 'PRECISION_MUL: constant(uint256[N_COINS]) = [convert(1, uint256), convert(1000000000000, uint256), convert(1000000000000, uint256), convert(1, uint256)]\n', 'FEE_DENOMINATOR: constant(uint256) = 10 ** 10\n', 'FEE_IMPRECISION: constant(uint256) = 25 * 10 ** 8  # % of the fee\n', '\n', 'coins: public(address[N_COINS])\n', 'underlying_coins: public(address[N_COINS])\n', 'curve: public(address)\n', 'token: public(address)\n', '\n', '\n', '@public\n', 'def __init__(_coins: address[N_COINS], _underlying_coins: address[N_COINS],\n', '             _curve: address, _token: address):\n', '    self.coins = _coins\n', '    self.underlying_coins = _underlying_coins\n', '    self.curve = _curve\n', '    self.token = _token\n', '\n', '\n', '@public\n', "@nonreentrant('lock')\n", 'def add_liquidity(uamounts: uint256[N_COINS], min_mint_amount: uint256):\n', '    tethered: bool[N_COINS] = TETHERED\n', '    amounts: uint256[N_COINS] = ZEROS\n', '\n', '    for i in range(N_COINS):\n', '        uamount: uint256 = uamounts[i]\n', '\n', '        if uamount > 0:\n', '            # Transfer the underlying coin from owner\n', '            if tethered[i]:\n', '                USDT(self.underlying_coins[i]).transferFrom(\n', '                    msg.sender, self, uamount)\n', '            else:\n', '                assert_modifiable(ERC20(self.underlying_coins[i])\\\n', '                    .transferFrom(msg.sender, self, uamount))\n', '\n', '            # Mint if needed\n', '            ERC20(self.underlying_coins[i]).approve(self.coins[i], uamount)\n', '            yERC20(self.coins[i]).deposit(uamount)\n', '            amounts[i] = yERC20(self.coins[i]).balanceOf(self)\n', '            ERC20(self.coins[i]).approve(self.curve, amounts[i])\n', '\n', '    Curve(self.curve).add_liquidity(amounts, min_mint_amount)\n', '\n', '    tokens: uint256 = ERC20(self.token).balanceOf(self)\n', '    assert_modifiable(ERC20(self.token).transfer(msg.sender, tokens))\n', '\n', '\n', '@private\n', 'def _send_all(_addr: address, min_uamounts: uint256[N_COINS], one: int128):\n', '    tethered: bool[N_COINS] = TETHERED\n', '\n', '    for i in range(N_COINS):\n', '        if (one < 0) or (i == one):\n', '            _coin: address = self.coins[i]\n', '            _balance: uint256 = yERC20(_coin).balanceOf(self)\n', '            if _balance == 0:  # Do nothing for 0 coins\n', '                continue\n', '            yERC20(_coin).withdraw(_balance)\n', '\n', '            _ucoin: address = self.underlying_coins[i]\n', '            _uamount: uint256 = ERC20(_ucoin).balanceOf(self)\n', '            assert _uamount >= min_uamounts[i], "Not enough coins withdrawn"\n', '\n', '            if tethered[i]:\n', '                USDT(_ucoin).transfer(_addr, _uamount)\n', '            else:\n', '                assert_modifiable(ERC20(_ucoin).transfer(_addr, _uamount))\n', '\n', '\n', '@public\n', "@nonreentrant('lock')\n", 'def remove_liquidity(_amount: uint256, min_uamounts: uint256[N_COINS]):\n', '    zeros: uint256[N_COINS] = ZEROS\n', '\n', '    assert_modifiable(ERC20(self.token).transferFrom(msg.sender, self, _amount))\n', '    Curve(self.curve).remove_liquidity(_amount, zeros)\n', '\n', '    self._send_all(msg.sender, min_uamounts, -1)\n', '\n', '\n', '@public\n', "@nonreentrant('lock')\n", 'def remove_liquidity_imbalance(uamounts: uint256[N_COINS], max_burn_amount: uint256):\n', '    """\n', '    Get max_burn_amount in, remove requested liquidity and transfer back what is left\n', '    """\n', '    tethered: bool[N_COINS] = TETHERED\n', '    _token: address = self.token\n', '\n', '    amounts: uint256[N_COINS] = uamounts\n', '    for i in range(N_COINS):\n', '        if amounts[i] > 0:\n', '            rate: uint256 = yERC20(self.coins[i]).getPricePerFullShare()\n', '            amounts[i] = amounts[i] * LENDING_PRECISION / rate\n', '\n', '    # Transfrer max tokens in\n', '    _tokens: uint256 = ERC20(_token).balanceOf(msg.sender)\n', '    if _tokens > max_burn_amount:\n', '        _tokens = max_burn_amount\n', '    assert_modifiable(ERC20(_token).transferFrom(msg.sender, self, _tokens))\n', '\n', '    Curve(self.curve).remove_liquidity_imbalance(amounts, max_burn_amount)\n', '\n', '    # Transfer unused tokens back\n', '    _tokens = ERC20(_token).balanceOf(self)\n', '    assert_modifiable(ERC20(_token).transfer(msg.sender, _tokens))\n', '\n', "    # Unwrap and transfer all the coins we've got\n", '    self._send_all(msg.sender, ZEROS, -1)\n', '\n', '\n', '@private\n', '@constant\n', 'def _xp_mem(rates: uint256[N_COINS], _balances: uint256[N_COINS]) -> uint256[N_COINS]:\n', '    result: uint256[N_COINS] = rates\n', '    for i in range(N_COINS):\n', '        result[i] = result[i] * _balances[i] / PRECISION\n', '    return result\n', '\n', '\n', '@private\n', '@constant\n', 'def get_D(A: uint256, xp: uint256[N_COINS]) -> uint256:\n', '    S: uint256 = 0\n', '    for _x in xp:\n', '        S += _x\n', '    if S == 0:\n', '        return 0\n', '\n', '    Dprev: uint256 = 0\n', '    D: uint256 = S\n', '    Ann: uint256 = A * N_COINS\n', '    for _i in range(255):\n', '        D_P: uint256 = D\n', '        for _x in xp:\n', '            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\n', '        Dprev = D\n', '        D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)\n', '        # Equality with the precision of 1\n', '        if D > Dprev:\n', '            if D - Dprev <= 1:\n', '                break\n', '        else:\n', '            if Dprev - D <= 1:\n', '                break\n', '    return D\n', '\n', '\n', '@private\n', '@constant\n', 'def get_y(A: uint256, i: int128, _xp: uint256[N_COINS], D: uint256) -> uint256:\n', '    """\n', '    Calculate x[i] if one reduces D from being calculated for _xp to D\n', '    Done by solving quadratic equation iteratively.\n', "    x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n", '    x_1**2 + b*x_1 = c\n', '    x_1 = (x_1**2 + c) / (2*x_1 + b)\n', '    """\n', '    # x in the input is converted to the same price/precision\n', '\n', '    assert (i >= 0) and (i < N_COINS)\n', '\n', '    c: uint256 = D\n', '    S_: uint256 = 0\n', '    Ann: uint256 = A * N_COINS\n', '\n', '    _x: uint256 = 0\n', '    for _i in range(N_COINS):\n', '        if _i != i:\n', '            _x = _xp[_i]\n', '        else:\n', '            continue\n', '        S_ += _x\n', '        c = c * D / (_x * N_COINS)\n', '    c = c * D / (Ann * N_COINS)\n', '    b: uint256 = S_ + D / Ann\n', '    y_prev: uint256 = 0\n', '    y: uint256 = D\n', '    for _i in range(255):\n', '        y_prev = y\n', '        y = (y*y + c) / (2 * y + b - D)\n', '        # Equality with the precision of 1\n', '        if y > y_prev:\n', '            if y - y_prev <= 1:\n', '                break\n', '        else:\n', '            if y_prev - y <= 1:\n', '                break\n', '    return y\n', '\n', '\n', '@private\n', '@constant\n', 'def _calc_withdraw_one_coin(_token_amount: uint256, i: int128, rates: uint256[N_COINS]) -> uint256:\n', '    # First, need to calculate\n', '    # * Get current D\n', '    # * Solve Eqn against y_i for D - _token_amount\n', '    crv: address = self.curve\n', '    A: uint256 = Curve(crv).A()\n', '    fee: uint256 = Curve(crv).fee() * N_COINS / (4 * (N_COINS - 1))\n', '    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\n', '    precisions: uint256[N_COINS] = PRECISION_MUL\n', '    total_supply: uint256 = ERC20(self.token).totalSupply()\n', '\n', '    xp: uint256[N_COINS] = PRECISION_MUL\n', '    S: uint256 = 0\n', '    for j in range(N_COINS):\n', '        xp[j] *= Curve(crv).balances(j)\n', '        xp[j] = xp[j] * rates[j] / LENDING_PRECISION\n', '        S += xp[j]\n', '\n', '    D0: uint256 = self.get_D(A, xp)\n', '    D1: uint256 = D0 - _token_amount * D0 / total_supply\n', '    xp_reduced: uint256[N_COINS] = xp\n', '\n', '    # xp = xp - fee * | xp * D1 / D0 - (xp - S * dD / D0 * (0, ... 1, ..0))|\n', '    for j in range(N_COINS):\n', '        dx_expected: uint256 = 0\n', '        b_ideal: uint256 = xp[j] * D1 / D0\n', '        b_expected: uint256 = xp[j]\n', '        if j == i:\n', '            b_expected -= S * (D0 - D1) / D0\n', '        if b_ideal >= b_expected:\n', '            dx_expected += (b_ideal - b_expected)\n', '        else:\n', '            dx_expected += (b_expected - b_ideal)\n', '        xp_reduced[j] -= fee * dx_expected / FEE_DENOMINATOR\n', '\n', '    dy: uint256 = xp_reduced[i] - self.get_y(A, i, xp_reduced, D1)\n', '    dy = dy / precisions[i]\n', '\n', '    return dy\n', '\n', '\n', '@public\n', '@constant\n', 'def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\n', '    # rates: uint256[N_COINS] = ZEROS\n', '\n', '    # for j in range(N_COINS):\n', '    #    rates[j] = yERC20(self.coins[j]).getPricePerFullShare()\n', '\n', '    rates: uint256[N_COINS] = [convert(1, uint256), convert(1, uint256), convert(1, uint256), convert(1, uint256)]\n', '\n', '    return self._calc_withdraw_one_coin(_token_amount, i, rates)\n', '\n', '\n', '@public\n', "@nonreentrant('lock')\n", 'def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False):\n', '    """\n', '    Remove _amount of liquidity all in a form of coin i\n', '    """\n', '    rates: uint256[N_COINS] = ZEROS\n', '    _token: address = self.token\n', '\n', '    for j in range(N_COINS):\n', '        rates[j] = yERC20(self.coins[j]).getPricePerFullShare()\n', '\n', '    dy: uint256 = self._calc_withdraw_one_coin(_token_amount, i, rates)\n', '    assert dy >= min_uamount, "Not enough coins removed"\n', '\n', '    assert_modifiable(\n', '        ERC20(self.token).transferFrom(msg.sender, self, _token_amount))\n', '\n', '    amounts: uint256[N_COINS] = ZEROS\n', '    amounts[i] = dy * LENDING_PRECISION / rates[i]\n', '    token_amount_before: uint256 = ERC20(_token).balanceOf(self)\n', '    Curve(self.curve).remove_liquidity_imbalance(amounts, _token_amount)\n', '\n', "    # Unwrap and transfer all the coins we've got\n", '    self._send_all(msg.sender, ZEROS, i)\n', '\n', '    if not donate_dust:\n', '        # Transfer unused tokens back\n', '        token_amount_after: uint256 = ERC20(_token).balanceOf(self)\n', '        if token_amount_after > token_amount_before:\n', '            assert_modifiable(ERC20(_token).transfer(\n', '                msg.sender, token_amount_after - token_amount_before)\n', '            )\n', '\n', '\n', '@public\n', "@nonreentrant('lock')\n", 'def withdraw_donated_dust():\n', '    owner: address = Curve(self.curve).owner()\n', '    assert msg.sender == owner\n', '\n', '    _token: address = self.token\n', '    assert_modifiable(\n', '        ERC20(_token).transfer(owner, ERC20(_token).balanceOf(self)))']