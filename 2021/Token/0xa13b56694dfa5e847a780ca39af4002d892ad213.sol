['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// File: contracts\\modules\\SafeMath.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'SafeMath: addition overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'SafeMath: substraction underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'SafeMath: multiplication overflow');\n", '    }\n', '}\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\IFNXMinePool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IFNXMinePool {\n', '    function transferMinerCoin(address account,address recieptor,uint256 amount)external;\n', '    function mintMinerCoin(address account,uint256 amount) external;\n', '    function burnMinerCoin(address account,uint256 amount) external;\n', '    function addMinerBalance(address account,uint256 amount) external;\n', '}\n', 'contract ImportFNXMinePool is Ownable{\n', '    IFNXMinePool internal _FnxMinePool;\n', '    function getFNXMinePoolAddress() public view returns(address){\n', '        return address(_FnxMinePool);\n', '    }\n', '    function setFNXMinePoolAddress(address fnxMinePool)public onlyOwner{\n', '        _FnxMinePool = IFNXMinePool(fnxMinePool);\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\Erc20Data.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Erc20Data is Ownable{\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    \n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '    \n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\modules\\timeLimitation.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract timeLimitation is Ownable {\n', '    \n', '    /**\n', "     * @dev FPT has burn time limit. When user's balance is moved in som coins, he will wait `timeLimited` to burn FPT. \n", "     * latestTransferIn is user's latest time when his balance is moved in.\n", '     */\n', '    mapping(uint256=>uint256) internal itemTimeMap;\n', '    uint256 internal limitation = 1 hours;\n', '    /**\n', '     * @dev set time limitation, only owner can invoke. \n', '     * @param _limitation new time limitation.\n', '     */ \n', '    function setTimeLimitation(uint256 _limitation) public onlyOwner {\n', '        limitation = _limitation;\n', '    }\n', '    function setItemTimeLimitation(uint256 item) internal{\n', '        itemTimeMap[item] = now;\n', '    }\n', '    function getTimeLimitation() public view returns (uint256){\n', '        return limitation;\n', '    }\n', '    /**\n', "     * @dev Retrieve user's start time for burning. \n", '     * @param item item key.\n', '     */ \n', '    function getItemTimeLimitation(uint256 item) public view returns (uint256){\n', '        return itemTimeMap[item]+limitation;\n', '    }\n', '    modifier OutLimitation(uint256 item) {\n', '        require(itemTimeMap[item]+limitation<now,"Time limitation is not expired!");\n', '        _;\n', '    }    \n', '}\n', '\n', '// File: contracts\\FPTCoin\\FPTData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', 'contract FPTData is Erc20Data,ImportFNXMinePool,Managerable,timeLimitation{\n', '    /**\n', '    * @dev lock mechanism is used when user redeem collateral and left collateral is insufficient.\n', '    * _totalLockedWorth stores total locked worth, priced in USD.\n', "    * lockedBalances stores user's locked FPTCoin.\n", "    * lockedTotalWorth stores user's locked worth, priced in USD. For locked FPTCoin's net worth is constant when It was locked.\n", '    */\n', '    uint256 internal _totalLockedWorth;\n', '    mapping (address => uint256) internal lockedBalances;\n', '    mapping (address => uint256) internal lockedTotalWorth;\n', '    /**\n', '     * @dev Emitted when `owner` locked  `amount` FPT, which net worth is  `worth` in USD. \n', '     */\n', '    event AddLocked(address indexed owner, uint256 amount,uint256 worth);\n', '    /**\n', '     * @dev Emitted when `owner` burned locked  `amount` FPT, which net worth is  `worth` in USD. \n', '     */\n', '    event BurnLocked(address indexed owner, uint256 amount,uint256 worth);\n', '\n', '}\n', '\n', '// File: contracts\\FPTCoin\\SharedCoin.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract SharedCoin is FPTData  {\n', '    using SafeMath for uint256;\n', '    function initialize() onlyOwner public{\n', '        _totalSupply = 0;\n', '    }\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return balances[account];\n', '    }\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '    public\n', '    returns (bool)\n', '    {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount)\n', '    public\n', '    returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '    public\n', '    returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '    public\n', '    returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '/*\n', '    function burn(uint256 amount) public onlyOwner returns (bool){\n', '        _burn(msg.sender, amount);\n', '        return true;\n', '    }\n', '    function mint(address account,uint256 amount) public onlyOwner returns (bool){\n', '        _mint(account,amount);\n', '        return true;\n', '    }\n', '    */\n', '    /**\n', "     * @dev add `recipient`'s balance to iterable mapping balances.\n", '     */\n', '    function _addBalance(address recipient, uint256 amount) internal {\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        balances[recipient] = balances[recipient].add(amount);\n', '    }\n', '    /**\n', "     * @dev add `recipient`'s balance to iterable mapping balances.\n", '     */\n', '    function _subBalance(address recipient, uint256 amount) internal {\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        balances[recipient] = balances[recipient].sub(amount);\n', '    }\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        _subBalance(sender,amount);\n', '        _addBalance(recipient,amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _addBalance(account,amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '    /**\n', '    * @dev Destroys `amount` tokens from `account`, reducing the\n', '    * total supply.\n', '    *\n', '    * Emits a {Transfer} event with `to` set to the zero address.\n', '    *\n', '    * Requirements\n', '    *\n', '    * - `account` cannot be the zero address.\n', '    * - `account` must have at least `amount` tokens.\n', '    */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '        _subBalance(account,amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts\\FPTCoin\\FPTCoin.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title FPTCoin is finnexus collateral Pool token, implement ERC20 interface.\n', ' * @dev ERC20 token. Its inside value is collatral pool net worth.\n', ' *\n', ' */\n', 'contract FPTCoin is SharedCoin {\n', '    using SafeMath for uint256;\n', '    mapping (address => bool) internal timeLimitWhiteList;\n', '    constructor (address minePoolAddr,string memory tokenName)public{\n', '        initialize();\n', '        //_FnxMinePool = IFNXMinePool(minePoolAddr);\n', '        name = tokenName;\n', '        symbol = tokenName;\n', '    }\n', '    /**\n', '     * @dev constructor function. set FNX minePool contract address. \n', '     */ \n', '    function initialize() onlyOwner public{\n', '        SharedCoin.initialize();\n', '    }\n', '    function update() onlyOwner public{\n', '        timeLimitWhiteList[0xf1FF936B72499382983a8fBa9985C41cB80BE17D] = true;\n', '    }\n', '    /**\n', "     * @dev Retrieve user's start time for burning. \n", "     * @param user user's account.\n", '     */ \n', '    function getUserBurnTimeLimite(address user) public view returns (uint256){\n', '        return getItemTimeLimitation(uint256(user));\n', '    }\n', '    /**\n', '     * @dev Retrieve total locked worth. \n', '     */ \n', '    function getTotalLockedWorth() public view returns (uint256) {\n', '        return _totalLockedWorth;\n', '    }\n', '    /**\n', "     * @dev Retrieve user's locked balance. \n", "     * @param account user's account.\n", '     */ \n', '    function lockedBalanceOf(address account) public view returns (uint256) {\n', '        return lockedBalances[account];\n', '    }\n', '    /**\n', "     * @dev Retrieve user's locked net worth. \n", "     * @param account user's account.\n", '     */ \n', '    function lockedWorthOf(address account) public view returns (uint256) {\n', '        return lockedTotalWorth[account];\n', '    }\n', '    /**\n', "     * @dev Retrieve user's locked balance and locked net worth. \n", "     * @param account user's account.\n", '     */ \n', '    function getLockedBalance(address account) public view returns (uint256,uint256) {\n', '        return (lockedBalances[account],lockedTotalWorth[account]);\n', '    }\n', '    /**\n', '     * @dev Interface to manager FNX mine pool contract, add miner balance when user has bought some options. \n', "     * @param account user's account.\n", "     * @param amount user's pay for buying options, priced in USD.\n", '     */ \n', '    function addMinerBalance(address account,uint256 amount) public onlyOwner{\n', '        if (amount == 0){\n', '            timeLimitWhiteList[account] = false;\n', '        }else{\n', '            timeLimitWhiteList[account] = true;\n', '        }\n', '        //_FnxMinePool.addMinerBalance(account,amount);\n', '    }\n', '    function setTransferTimeLimitation(address from,address recipient) internal {\n', '        if (!timeLimitWhiteList[from]){\n', '            setItemTimeLimitation(uint256(recipient));\n', '        }\n', '    }\n', '    /**\n', "     * dev Burn user's locked balance, when user redeem collateral. \n", "     * param account user's account.\n", '     * param amount amount of burned FPT.\n', ' \n', '    function burnLocked(address account, uint256 amount) public onlyManager{\n', '        require(latestTransferIn[account]+timeLimited<now,"FPT coin locked time is not expired!");\n', '        uint256 lockedAmount = lockedBalances[account];\n', '        require(amount<=lockedAmount,"burnLocked: balance is insufficient");\n', '        if(lockedAmount>0){\n', '            uint256 lockedWorth = lockedTotalWorth[account];\n', '            if (amount == lockedAmount){\n', '                _subLockBalance(account,lockedAmount,lockedWorth);\n', '            }else{\n', '                uint256 burnWorth = amount*lockedWorth/lockedAmount;\n', '                _subLockBalance(account,amount,burnWorth);\n', '            }\n', '        }\n', '    }\n', '     */\n', '    /**\n', "     * @dev Move user's FPT to locked balance, when user redeem collateral. \n", "     * @param account user's account.\n", '     * @param amount amount of locked FPT.\n', '     * @param lockedWorth net worth of locked FPT.\n', '     */ \n', '    function addlockBalance(address account, uint256 amount,uint256 lockedWorth)public onlyManager {\n', '        burn(account,amount);\n', '        _addLockBalance(account,amount,lockedWorth);\n', '    }\n', '    /**\n', "     * @dev Move user's FPT to 'recipient' balance, a interface in ERC20. \n", "     * @param recipient recipient's account.\n", '     * @param amount amount of FPT.\n', '     */ \n', '    function transfer(address recipient, uint256 amount)public returns (bool){\n', '        //require(address(_FnxMinePool) != address(0),"FnxMinePool is not set");\n', '        //_FnxMinePool.transferMinerCoin(msg.sender,recipient,amount);\n', '        setTransferTimeLimitation(msg.sender,recipient);\n', '        return SharedCoin.transfer(recipient,amount);\n', '    }\n', '    /**\n', "     * @dev Move sender's FPT to 'recipient' balance, a interface in ERC20. \n", "     * @param sender sender's account.\n", "     * @param recipient recipient's account.\n", '     * @param amount amount of FPT.\n', '     */ \n', '    function transferFrom(address sender, address recipient, uint256 amount)public returns (bool){\n', '        //require(address(_FnxMinePool) != address(0),"FnxMinePool is not set");\n', '        //_FnxMinePool.transferMinerCoin(sender,recipient,amount);\n', '        setTransferTimeLimitation(sender,recipient);\n', '        return SharedCoin.transferFrom(sender,recipient,amount);\n', '    }\n', '    /**\n', "     * @dev burn user's FPT when user redeem FPTCoin. \n", "     * @param account user's account.\n", '     * @param amount amount of FPT.\n', '     */ \n', '    function burn(address account, uint256 amount) public onlyManager OutLimitation(uint256(account)) {\n', '        //require(address(_FnxMinePool) != address(0),"FnxMinePool is not set");\n', '        //_FnxMinePool.burnMinerCoin(account,amount);\n', '        SharedCoin._burn(account,amount);\n', '    }\n', '    /**\n', "     * @dev mint user's FPT when user add collateral. \n", "     * @param account user's account.\n", '     * @param amount amount of FPT.\n', '     */ \n', '    function mint(address account, uint256 amount) public onlyManager {\n', '        //require(address(_FnxMinePool) != address(0),"FnxMinePool is not set");\n', '        //_FnxMinePool.mintMinerCoin(account,amount);\n', '        setTransferTimeLimitation(address(0),account);\n', '        SharedCoin._mint(account,amount);\n', '    }\n', '    /**\n', "     * @dev An auxiliary function, add user's locked balance. \n", "     * @param account user's account.\n", '     * @param amount amount of FPT.\n', '     * @param lockedWorth net worth of FPT.\n', '     */ \n', '    function _addLockBalance(address account, uint256 amount,uint256 lockedWorth)internal {\n', '        lockedBalances[account]= lockedBalances[account].add(amount);\n', '        lockedTotalWorth[account]= lockedTotalWorth[account].add(lockedWorth);\n', '        _totalLockedWorth = _totalLockedWorth.add(lockedWorth);\n', '        emit AddLocked(account, amount,lockedWorth);\n', '    }\n', '    /**\n', "     * @dev An auxiliary function, deduct user's locked balance. \n", "     * @param account user's account.\n", '     * @param amount amount of FPT.\n', '     * @param lockedWorth net worth of FPT.\n', '     */ \n', '    function _subLockBalance(address account,uint256 amount,uint256 lockedWorth)internal {\n', '        lockedBalances[account]= lockedBalances[account].sub(amount);\n', '        lockedTotalWorth[account]= lockedTotalWorth[account].sub(lockedWorth);\n', '        _totalLockedWorth = _totalLockedWorth.sub(lockedWorth);\n', '        emit BurnLocked(account, amount,lockedWorth);\n', '    }\n', '    /**\n', '     * @dev An interface of redeem locked FPT, when user redeem collateral, only manager contract can invoke. \n', "     * @param account user's account.\n", '     * @param tokenAmount amount of FPT.\n', '     * @param leftCollateral left available collateral in collateral pool, priced in USD.\n', '     */ \n', '    function redeemLockedCollateral(address account,uint256 tokenAmount,uint256 leftCollateral)public onlyManager OutLimitation(uint256(account)) returns (uint256,uint256){\n', '        if (leftCollateral == 0){\n', '            return(0,0);\n', '        }\n', '        uint256 lockedAmount = lockedBalances[account];\n', '        uint256 lockedWorth = lockedTotalWorth[account];\n', '        if (lockedAmount == 0 || lockedWorth == 0){\n', '            return (0,0);\n', '        }\n', '        uint256 redeemWorth = 0;\n', '        uint256 lockedBurn = 0;\n', '        uint256 lockedPrice = lockedWorth/lockedAmount;\n', '        if (lockedAmount >= tokenAmount){\n', '            lockedBurn = tokenAmount;\n', '            redeemWorth = tokenAmount*lockedPrice;\n', '        }else{\n', '            lockedBurn = lockedAmount;\n', '            redeemWorth = lockedWorth;\n', '        }\n', '        if (redeemWorth > leftCollateral) {\n', '            lockedBurn = leftCollateral/lockedPrice;\n', '            redeemWorth = lockedBurn*lockedPrice;\n', '        }\n', '        if (lockedBurn > 0){\n', '            _subLockBalance(account,lockedBurn,redeemWorth);\n', '            return (lockedBurn,redeemWorth);\n', '        }\n', '        return (0,0);\n', '    }\n', '}']