['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-04\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity <= 0.8.0;\n', 'pragma abicoder v2;\n', '\n', '\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '\n', 'interface IERC1155 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '\n', 'interface IERC1155MetadataURI is IERC1155 {\n', '    /**\n', '     * @dev Returns the URI for token type `id`.\n', '     *\n', '     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n', '     * clients with the actual token type ID.\n', '     */\n', '    function uri(uint256 id) external view returns (string memory);\n', '}\n', '\n', '\n', '\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract SimpleAccessControl {\n', '\n', '    address internal _owner;\n', '    address internal _authorizedERC1155;\n', '\n', '    modifier isOwner() {\n', '        require(msg.sender == _owner, "ERR_NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier isAuthorizedERC1155() {\n', '        require(msg.sender == _authorizedERC1155, "ERR_NOT_AUTHORIZED_ERC1155");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    function setAuthorizedERC1155(address _erc1155) public isOwner {\n', '        require(_erc1155 != address(0), "ERR_ZERO_ADDR");\n', '        _authorizedERC1155 = _erc1155;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public isOwner {\n', '        require(newOwner != address(0), "ERR_ZERO_ADDR");\n', '        require(newOwner != _owner, "ERR_IS_OWNER");\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface for the optional metadata functions from the ERC20 standard.\n', ' */\n', 'interface IERC20Metadata is IERC20 {\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the decimals places of the token.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20, IERC20Metadata {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}.\n', '     *\n', '     * The defaut value of {decimals} is 18. To select a different value for\n', '     * {decimals} you should overload it.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n', '     * overloaded;\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual override returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) \n', '        public\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '}\n', '\n', 'contract ERC20Capped is ERC20 {\n', '\n', '    uint256 public maxSupply =  353925000000000000000000000;\n', '\n', '    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\n', '\n', '    function _mintCapped(address _account, uint256 _value) internal {\n', "        require(_totalSupply + _value <= maxSupply, 'ERR_EXCEEDED_MAX_SUPPLY');\n", '        _mint(_account, _value);\n', '    }\n', '}\n', '\n', '\n', 'contract ERC20Crowdsale is SimpleAccessControl, ERC20Capped {\n', '\n', '    uint256 private _crowdsaleRate = 0.00025 ether;\n', '    uint256 private _nominalRate = 0.0005 ether;\n', '\n', '    constructor(string memory _name, string memory _symbol) \n', '        ERC20Capped(_name, _symbol)\n', '    {}\n', '\n', '    function mintCrowdsale(uint256 _amount) external payable isAuthorizedERC1155 {\n', '        uint256 value = _amount * _crowdsaleRate / 10**decimals();\n', "        require(value <= msg.value, 'ERC20Crowdsale: ERR_NOT_ENOUGH_FUNDS');\n", '        _mintCapped(msg.sender, _amount);\n', '    }\n', '\n', '    function mintNominal(uint256 _amount) public payable {\n', "        require(_amount >= 2000, 'ERC20Crowdsale: ERR_MIN_AMOUNT');\n", '        uint256 value = _amount * _nominalRate / 10**decimals();\n', "        require(value <= msg.value, 'ERC20Crowdsale: ERR_NOT_ENOUGH_FUNDS');\n", '        _mintCapped(msg.sender, _amount);\n', '    }\n', '\n', '    function transferToERC1155(address sender, uint256 amount)\n', '        external\n', '        isAuthorizedERC1155\n', '        returns (bool)\n', '    {\n', '        _transfer(sender, _authorizedERC1155, amount);\n', '        return true;\n', '    }\n', '\n', '    function withdrawBalance() public isOwner {\n', '        uint256 _balance = address(this).balance;\n', '        payable(_owner).transfer(_balance);\n', '    }\n', '}\n', '\n', '\n', 'contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n', '    using Address for address;\n', '\n', '    // Mapping from token ID to account balances\n', '    mapping (uint256 => mapping(address => uint256)) internal _balances;\n', '\n', '    // Mapping from account to operator approvals\n', '    mapping (address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n', '    string internal _uri;\n', '\n', '    /**\n', '     * @dev See {_setURI}.\n', '     */\n', '    constructor () {}\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC165, IERC165) returns (bool) {\n', '        return interfaceId == type(IERC1155).interfaceId\n', '            || interfaceId == type(IERC1155MetadataURI).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155MetadataURI-uri}.\n', '     *\n', '     * This implementation returns the same URI for *all* token types. It relies\n', '     * on the token type ID substitution mechanism\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n', '     *\n', '     * Clients calling this function must replace the `\\{id\\}` substring with the\n', '     * actual token type ID.\n', '     */\n', '    function uri(uint256) external view virtual override returns (string memory) {\n', '        return _uri;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n', '        require(account != address(0), "ERC1155: balance query for the zero address");\n', '        return _balances[id][account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-balanceOfBatch}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(\n', '        address[] memory accounts,\n', '        uint256[] memory ids\n', '    )\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256[] memory)\n', '    {\n', '        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");\n', '\n', '        uint256[] memory batchBalances = new uint256[](accounts.length);\n', '\n', '        for (uint256 i = 0; i < accounts.length; ++i) {\n', '            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n', '        }\n', '\n', '        return batchBalances;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(_msgSender() != operator, "ERC1155: setting approval status for self");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[account][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        _transfer(from, to, id, amount);\n', '\n', '        emit TransferSingle(operator, from, to, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC1155-safeBatchTransferFrom}.\n', '     */\n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: transfer caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = _msgSender();\n', '\n', '        for (uint256 i = 0; i < ids.length; ++i) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            _transfer(from, to, id, amount);\n', '        }\n', '\n', '        emit TransferBatch(operator, from, to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets a new URI for all token types, by relying on the token type ID\n', '     * substitution mechanism\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n', '     *\n', '     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n', '     * URI or any of the amounts in the JSON file at said URI will be replaced by\n', '     * clients with the token type ID.\n', '     *\n', '     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n', '     * interpreted by clients as\n', '     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n', '     * for token type ID 0x4cce0.\n', '     *\n', '     * See {uri}.\n', '     *\n', '     * Because these URIs cannot be meaningfully represented by the {URI} event,\n', '     * this function emits no events.\n', '     */\n', '    function _setURI(string memory newuri) internal virtual {\n', '        _uri = newuri;\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 id, uint256 amount) internal {\n', '        uint256 fromBalance = _balances[id][from];\n', '        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '        _balances[id][from] = fromBalance - amount;\n', '        _balances[id][to] += amount;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n', '        require(account != address(0), "ERC1155: mint to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _balances[id][account] += amount;\n', '        emit TransferSingle(operator, address(0), account, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n', '    }\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n', '        require(to != address(0), "ERC1155: mint to the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        for (uint i = 0; i < ids.length; i++) {\n', '            _balances[ids[i]][to] += amounts[i];\n', '        }\n', '\n', '        emit TransferBatch(operator, address(0), to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens of token type `id` from `account`\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens of token type `id`.\n', '     */\n', '    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        uint256 accountBalance = _balances[id][account];\n', '        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '        _balances[id][account] = accountBalance - amount;\n', '\n', '        emit TransferSingle(operator, account, address(0), id, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     */\n', '    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        for (uint i = 0; i < ids.length; i++) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 accountBalance = _balances[id][account];\n', '            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '            _balances[id][account] = accountBalance - amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, account, address(0), ids, amounts);\n', '    }\n', '\n', '    function _doSafeTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doSafeBatchTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    )\n', '        private\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract ERC1155CappedV2 is ERC1155 {\n', '\n', "    // Mapping from token ID to token's supply cap\n", "    uint32[152] public maxSupply = [0, 45375000,82500,825,45375000,82500,825,45375000,82500,825,45375000,907500,15125,45375000,907500,15125,45375000,302500,6050,7562500,62500,3025000,25000,7562500,62500,45375000,3025,9075000,55000,45375000,412500,9375,45375000,412500,9375,2750000,22000,550000,12500,2750000,22000,9075000,60500,9075000,181500,9075,3781250,34375,312500,6250,312500,6250,302500,5500,312500,6250,3781250,15125,2750000,5500,2268750,103125,9375,45375000,90750,825,312500,15625,3125,3781250,151250,3025,412500,8250,45375000,82500,1650,82500,1650,412500,12500,412500,8250,250000,412500,13750,412500,9375,412500,6875,3781250,13750,7562500,137500,5500,5500,412500,12500,150000,3750,412500,20625,412500,12500,412500,6875,3200,3200,3000,412500,9375,75625,3025,2600,5000,2220,453750,18150,453750,18150,453750,18150,2200,1900,3600,1500,1500,2200,2200,60500,1100,1420,5400,45375,825,825,825,4200,5500,1100,5500,1100,700,680,500,500,500,6050000,34375,625,200,100];    // Mapping from token ID to token's circulating supply\n", ' \n', '    mapping(uint256 => uint256) public totalSupply;\n', '\n', '    constructor() ERC1155() {}\n', '\n', '    function _mintCapped(address _account, uint256 _id, uint256 _value) internal {\n', "        require(totalSupply[_id] + _value <= maxSupply[_id], 'ERC1155Capped: ERR_EXCEEDED_MAX_SUPPLY');\n", '        _mint(_account, _id, _value, new bytes(0));\n', '        totalSupply[_id] = totalSupply[_id] + _value;\n', '    }\n', '}\n', '\n', 'contract SimpleOwnable {\n', '\n', '    address internal _owner;\n', '\n', '    modifier isOwner() {\n', '        require(msg.sender == _owner, "ERR_NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public isOwner {\n', '        require(newOwner != address(0), "ERR_ZERO_ADDR");\n', '        require(newOwner != _owner, "ERR_IS_OWNER");\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract ERC1155CrowdsaleV2 is SimpleOwnable, ERC1155CappedV2 {\n', '    // Address to the ERC20 token contract\n', '    address private ERC20Token;\n', '\n', '    // Mapping from tokenID to corresponding minting cap locks. \n', '    mapping (uint256 => uint32) private mintingCapLocks;\n', '\n', '    // Evolution dependecies map\n', '    mapping (uint256 => uint256) private evolutions;\n', '\n', '    modifier isValidTokenID(uint256 _id) {\n', "        require(_id > 0 && _id < 152, 'ERC1155Crowdsale: ERR_INVALID_TOKENID');\n", '        _;\n', '    }\n', '\n', '    constructor(\n', '        address _token,\n', '        uint8[] memory _evolutions_ids,\n', '        uint8[] memory _evolutions\n', '    )\n', '        ERC1155CappedV2()\n', '    {\n', '        ERC20Token = _token;\n', '        for(uint8 i = 0; i < _evolutions.length; i++) {\n', '            evolutions[_evolutions_ids[i]] = _evolutions[i];\n', '        }\n', '    }\n', '\n', '    function setURI(string memory newuri) public isOwner {\n', '        _uri = newuri;\n', '    }\n', '    /**\n', '     * Implements crowdsale token minting protocol.\n', '     */\n', '    function mintCrowdsale(uint8 _id, uint32 _amount) public payable isValidTokenID(_id) {\n', "        require(mintingCapLocks[_id] > 0, 'ERC1155Crowdsale: ERR_INACTIVE_CROWDSALE');\n", '        uint256 price = _amount * _calculateTokenRate(_id);\n', '        (bool success,) = address(ERC20Token).call{ value: msg.value }(\n', '            abi.encodeWithSignature("mintCrowdsale(uint256)", price)\n', '        );\n', "        require(success, 'ERC1155Crowdsale: ERR_ERC20_CALL');\n", "        require(totalSupply[_id] + _amount <= mintingCapLocks[_id], 'ERC1155Crowdsale: ERR_EXCEEDED_CROWDSALE_SUPPLY');\n", '        _mintCapped(msg.sender, _id, _amount);\n', '    }\n', '\n', '    /**\n', '     * Implements normal token minting protocol.\n', '     */\n', '    function mintNominal(uint8 _id, uint32 _amount) public isValidTokenID(_id) {\n', "        require(evolutions[_id] == 0, 'ERC1155Crowdsale: ERR_CANT_MINT_EVOLUTION');\n", '        uint256 price = _amount * _calculateTokenRate(_id);\n', '        ERC20Crowdsale(ERC20Token).transferToERC1155(msg.sender, price);\n', '        _mintCapped(msg.sender, _id, _amount);\n', '    }\n', '\n', '    /**\n', '     * Implements evolution token minting protocol.\n', '     */\n', '    function mintEvolution(uint8 _id, uint32 _amount) public isValidTokenID(_id) {\n', "        require(evolutions[_id] != 0, 'ERC1155Crowdsale: ERR_NOT_EVOLUTION');\n", '        uint256 total = _amount * _calculateEvolutionRate(_id);\n', "        require(_balances[evolutions[_id]][msg.sender] >= total, 'ERC1155Crowdsale: ERR_NOT_ENOUGH_TOKENS');\n", '        _burn(msg.sender, evolutions[_id], total);\n', '        _mintCapped(msg.sender, _id, _amount);\n', '    }\n', '\n', '    function mintAward() public {\n', '        uint256[] memory ids = new uint256[](150);\n', '        uint256[] memory amounts = new uint256[](150);\n', '\n', '        for(uint8 i = 1; i < 151; i++) {\n', '            require(_balances[i][msg.sender] >= 2);\n', '            amounts[i-1] = 1;\n', '            ids[i-1] = i;\n', '        }\n', '\n', '        _burnBatch(msg.sender, ids, amounts);\n', '        _mintCapped(msg.sender, 151, 1);\n', '    }\n', '\n', '    function swapFromToken(uint8 _id, uint256 _amount) public isValidTokenID(_id) {\n', '        uint256 _price = _amount * _calculateTokenRate(_id);\n', '        ERC20Crowdsale(ERC20Token).transferToERC1155(msg.sender, _price);\n', '        _transfer(address(this), msg.sender, _id, _amount);\n', '    }\n', '\n', '    function swapToToken(uint8 _id, uint256 _amount) public isValidTokenID(_id) {\n', '        uint256 _price = _amount * _calculateTokenRate(_id);\n', '        ERC20Crowdsale(ERC20Token).transfer(msg.sender, _price);\n', '        _transfer(msg.sender, address(this), _id, _amount);\n', '    }\n', '\n', '    function setMintingCapLocks(uint8[] calldata _ids, uint32[] calldata _locks) public isOwner () {\n', '        for(uint8 i = 0; i < _ids.length; i++) {\n', '            mintingCapLocks[_ids[i]] = _locks[i];\n', '        }\n', '    }\n', '\n', '    function _calculateTokenRate(uint8 _id) internal view returns (uint256) {\n', '        return 4537500000000000000000000 / maxSupply[_id];\n', '    }\n', '\n', '    function _calculateEvolutionRate(uint8 _id) internal view returns (uint32) {\n', '        return maxSupply[evolutions[_id]] / maxSupply[_id];\n', '    }\n', '}']