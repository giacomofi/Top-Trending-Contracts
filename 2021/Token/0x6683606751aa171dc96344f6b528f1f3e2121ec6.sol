['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-23\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity 0.8.2;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function decimals() external view returns (uint8);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC2612 standard as defined in the EIP.\n', ' *\n', " * Adds the {permit} method, which can be used to change one's\n", ' * {IERC20-allowance} without having to send a transaction, by signing a\n', ' * message. This allows users to spend tokens without having to hold Ether.\n', ' *\n', ' * See https://eips.ethereum.org/EIPS/eip-2612.\n', ' */\n', 'interface IERC2612 {\n', '\n', '    /**\n', '     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n', '     * included whenever a signature is generated for {permit}.\n', '     *\n', "     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n", '     * prevents a signature from being used multiple times.\n', '     */\n', '    function nonces(address owner) external view returns (uint256);\n', '}\n', '\n', '/// @dev Wrapped ERC-20 v10 (AnyswapV3ERC20) is an ERC-20 ERC-20 wrapper. You can `deposit` ERC-20 and obtain an AnyswapV3ERC20 balance which can then be operated as an ERC-20 token. You can\n', '/// `withdraw` ERC-20 from AnyswapV3ERC20, which will then burn AnyswapV3ERC20 token in your wallet. The amount of AnyswapV3ERC20 token in any wallet is always identical to the\n', '/// balance of ERC-20 deposited minus the ERC-20 withdrawn with that specific wallet.\n', 'interface IAnyswapV3ERC20 is IERC20, IERC2612 {\n', '\n', "    /// @dev Sets `value` as allowance of `spender` account over caller account's AnyswapV3ERC20 token,\n", '    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n', '    /// Emits {Approval} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n', '    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n', '\n', "    /// @dev Moves `value` AnyswapV3ERC20 token from caller's account to account (`to`),\n", '    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n', '    /// A transfer to `address(0)` triggers an ERC-20 withdraw matching the sent AnyswapV3ERC20 token in favor of caller.\n', '    /// Emits {Transfer} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// Requirements:\n', '    ///   - caller account must have at least `value` AnyswapV3ERC20 token.\n', '    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n', '    function transferAndCall(address to, uint value, bytes calldata data) external returns (bool);\n', '}\n', '\n', 'interface ITransferReceiver {\n', '    function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\n', '}\n', '\n', 'interface IApprovalReceiver {\n', '    function onTokenApproval(address, uint, bytes calldata) external returns (bool);\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ImpossibleFinanceV2 is IAnyswapV3ERC20 {\n', '    using SafeERC20 for IERC20;\n', '    string public name;\n', '    string public symbol;\n', '    uint8  public immutable override decimals;\n', '\n', '    address public immutable underlying;\n', '\n', '    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant TRANSFER_TYPEHASH = keccak256("Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public immutable DOMAIN_SEPARATOR;\n', '\n', '    /// @dev Records amount of AnyswapV3ERC20 token owned by account.\n', '    mapping (address => uint256) public override balanceOf;\n', '    uint256 private _totalSupply;\n', '\n', '    // init flag for setting immediate vault, needed for CREATE2 support\n', '    bool private _init;\n', '\n', '    // flag to enable/disable swapout vs vault.burn so multiple events are triggered\n', '    bool private _vaultOnly;\n', '\n', '    // configurable delay for timelock functions\n', '    uint public delay = 2*24*3600;\n', '\n', '\n', '    // set of minters, can be this bridge or other bridges\n', '    mapping(address => bool) public isMinter;\n', '    address[] public minters;\n', '\n', '    // primary controller of the token contract\n', '    address public vault;\n', '\n', '    address public pendingMinter;\n', '    uint public delayMinter;\n', '\n', '    address public pendingVault;\n', '    uint public delayVault;\n', '\n', '    uint public pendingDelay;\n', '    uint public delayDelay;\n', '\n', '\n', '    modifier onlyAuth() {\n', '        require(isMinter[msg.sender], "AnyswapV4ERC20: FORBIDDEN");\n', '        _;\n', '    }\n', '\n', '    modifier onlyVault() {\n', '        require(msg.sender == mpc(), "AnyswapV3ERC20: FORBIDDEN");\n', '        _;\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return mpc();\n', '    }\n', '\n', '    function mpc() public view returns (address) {\n', '        if (block.timestamp >= delayVault) {\n', '            return pendingVault;\n', '        }\n', '        return vault;\n', '    }\n', '\n', '    function setVaultOnly(bool enabled) external onlyVault {\n', '        _vaultOnly = enabled;\n', '    }\n', '\n', '    function initVault(address _vault) external onlyVault {\n', '        require(_init);\n', '        vault = _vault;\n', '        pendingVault = _vault;\n', '        isMinter[_vault] = true;\n', '        minters.push(_vault);\n', '        delayVault = block.timestamp;\n', '        _init = false;\n', '    }\n', '\n', '    function setMinter(address _auth) external onlyVault {\n', '        pendingMinter = _auth;\n', '        delayMinter = block.timestamp + delay;\n', '    }\n', '\n', '    function setVault(address _vault) external onlyVault {\n', '        pendingVault = _vault;\n', '        delayVault = block.timestamp + delay;\n', '    }\n', '\n', '    function applyVault() external onlyVault {\n', '        require(block.timestamp >= delayVault);\n', '        vault = pendingVault;\n', '    }\n', '\n', '    function applyMinter() external onlyVault {\n', '        require(block.timestamp >= delayMinter);\n', '        isMinter[pendingMinter] = true;\n', '        minters.push(pendingMinter);\n', '    }\n', '\n', '    // No time delay revoke minter emergency function\n', '    function revokeMinter(address _auth) external onlyVault {\n', '        isMinter[_auth] = false;\n', '    }\n', '\n', '    function getAllMinters() external view returns (address[] memory) {\n', '        return minters;\n', '    }\n', '\n', '\n', '    function changeVault(address newVault) external onlyVault returns (bool) {\n', '        require(newVault != address(0), "AnyswapV3ERC20: address(0x0)");\n', '        pendingVault = newVault;\n', '        delayVault = block.timestamp + delay;\n', '        emit LogChangeVault(vault, pendingVault, delayVault);\n', '        return true;\n', '    }\n', '\n', '    function changeMPCOwner(address newVault) public onlyVault returns (bool) {\n', '        require(newVault != address(0), "AnyswapV3ERC20: address(0x0)");\n', '        pendingVault = newVault;\n', '        delayVault = block.timestamp + delay;\n', '        emit LogChangeMPCOwner(vault, pendingVault, delayVault);\n', '        return true;\n', '    }\n', '\n', '    function mint(address to, uint256 amount) external onlyAuth returns (bool) {\n', '        _mint(to, amount);\n', '        return true;\n', '    }\n', '\n', '    function burn(address from, uint256 amount) external onlyAuth returns (bool) {\n', '        require(from != address(0), "AnyswapV3ERC20: address(0x0)");\n', '        _burn(from, amount);\n', '        return true;\n', '    }\n', '\n', '    function Swapin(bytes32 txhash, address account, uint256 amount) public onlyAuth returns (bool) {\n', '        _mint(account, amount);\n', '        emit LogSwapin(txhash, account, amount);\n', '        return true;\n', '    }\n', '\n', '    function Swapout(uint256 amount, address bindaddr) public returns (bool) {\n', '        require(!_vaultOnly, "AnyswapV4ERC20: onlyAuth");\n', '        require(bindaddr != address(0), "AnyswapV3ERC20: address(0x0)");\n', '        _burn(msg.sender, amount);\n', '        emit LogSwapout(msg.sender, bindaddr, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\n', "    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\n", '    mapping (address => uint256) public override nonces;\n', '\n', '    /// @dev Records number of AnyswapV3ERC20 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\n', '    mapping (address => mapping (address => uint256)) public override allowance;\n', '\n', '    event LogChangeVault(address indexed oldVault, address indexed newVault, uint indexed effectiveTime);\n', '    event LogChangeMPCOwner(address indexed oldOwner, address indexed newOwner, uint indexed effectiveHeight);\n', '    event LogSwapin(bytes32 indexed txhash, address indexed account, uint amount);\n', '    event LogSwapout(address indexed account, address indexed bindaddr, uint amount);\n', '    event LogAddAuth(address indexed auth, uint timestamp);\n', '\n', '    constructor(string memory _name, string memory _symbol, uint8 _decimals, address _underlying, address _vault) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '        underlying = _underlying;\n', '        if (_underlying != address(0x0)) {\n', '            require(_decimals == IERC20(_underlying).decimals());\n', '        }\n', '\n', '        // Use init to allow for CREATE2 accross all chains\n', '        _init = true;\n', '\n', '        // Disable/Enable swapout for v1 tokens vs mint/burn for v3 tokens\n', '        _vaultOnly = false;\n', '\n', '        vault = _vault;\n', '        pendingVault = _vault;\n', '        delayVault = block.timestamp;\n', '\n', '        uint256 chainId;\n', '        assembly {chainId := chainid()}\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name)),\n', '                keccak256(bytes("1")),\n', '                chainId,\n', '                address(this)));\n', '\n', '    }\n', '\n', '    /// @dev Returns the total supply of AnyswapV3ERC20 token as the ETH held in this contract.\n', '    function totalSupply() external view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function depositWithPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n', '        IERC20(underlying).permit(target, address(this), value, deadline, v, r, s);\n', '        IERC20(underlying).safeTransferFrom(target, address(this), value);\n', '        return _deposit(value, to);\n', '    }\n', '\n', '    function depositWithTransferPermit(address target, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s, address to) external returns (uint) {\n', '        IERC20(underlying).transferWithPermit(target, address(this), value, deadline, v, r, s);\n', '        return _deposit(value, to);\n', '    }\n', '\n', '    function deposit() external returns (uint) {\n', '        uint _amount = IERC20(underlying).balanceOf(msg.sender);\n', '        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);\n', '        return _deposit(_amount, msg.sender);\n', '    }\n', '\n', '    function deposit(uint amount) external returns (uint) {\n', '        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n', '        return _deposit(amount, msg.sender);\n', '    }\n', '\n', '    function deposit(uint amount, address to) external returns (uint) {\n', '        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n', '        return _deposit(amount, to);\n', '    }\n', '\n', '    function depositVault(uint amount, address to) external onlyVault returns (uint) {\n', '        return _deposit(amount, to);\n', '    }\n', '\n', '    function _deposit(uint amount, address to) internal returns (uint) {\n', '        require(underlying != address(0x0) && underlying != address(this));\n', '        _mint(to, amount);\n', '        return amount;\n', '    }\n', '\n', '    function withdraw() external returns (uint) {\n', '        return _withdraw(msg.sender, balanceOf[msg.sender], msg.sender);\n', '    }\n', '\n', '    function withdraw(uint amount) external returns (uint) {\n', '        return _withdraw(msg.sender, amount, msg.sender);\n', '    }\n', '\n', '    function withdraw(uint amount, address to) external returns (uint) {\n', '        return _withdraw(msg.sender, amount, to);\n', '    }\n', '\n', '    function withdrawVault(address from, uint amount, address to) external onlyVault returns (uint) {\n', '        return _withdraw(from, amount, to);\n', '    }\n', '\n', '    function _withdraw(address from, uint amount, address to) internal returns (uint) {\n', '        _burn(from, amount);\n', '        IERC20(underlying).safeTransfer(to, amount);\n', '        return amount;\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply += amount;\n', '        balanceOf[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        balanceOf[account] -= amount;\n', '        _totalSupply -= amount;\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', "    /// @dev Sets `value` as allowance of `spender` account over caller account's AnyswapV3ERC20 token.\n", '    /// Emits {Approval} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    function approve(address spender, uint256 value) external override returns (bool) {\n', '        // _approve(msg.sender, spender, value);\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '\n', '        return true;\n', '    }\n', '\n', "    /// @dev Sets `value` as allowance of `spender` account over caller account's AnyswapV3ERC20 token,\n", '    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n', '    /// Emits {Approval} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n', '    function approveAndCall(address spender, uint256 value, bytes calldata data) external override returns (bool) {\n', '        // _approve(msg.sender, spender, value);\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '\n', '        return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\n', '    }\n', '\n', "    /// @dev Sets `value` as allowance of `spender` account over `owner` account's AnyswapV3ERC20 token, given `owner` account's signed approval.\n", '    /// Emits {Approval} event.\n', '    /// Requirements:\n', '    ///   - `deadline` must be timestamp in future.\n', '    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\n', "    ///   - the signature must use `owner` account's current nonce (see {nonces}).\n", '    ///   - the signer cannot be zero address and must be `owner` account.\n', '    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\n', '    /// AnyswapV3ERC20 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\n', '    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n', '        require(block.timestamp <= deadline, "AnyswapV3ERC20: Expired permit");\n', '\n', '        bytes32 hashStruct = keccak256(\n', '            abi.encode(\n', '                PERMIT_TYPEHASH,\n', '                target,\n', '                spender,\n', '                value,\n', '                nonces[target]++,\n', '                deadline));\n', '\n', '        require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n', '\n', '        // _approve(owner, spender, value);\n', '        allowance[target][spender] = value;\n', '        emit Approval(target, spender, value);\n', '    }\n', '\n', '    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override returns (bool) {\n', '        require(block.timestamp <= deadline, "AnyswapV3ERC20: Expired permit");\n', '\n', '        bytes32 hashStruct = keccak256(\n', '            abi.encode(\n', '                TRANSFER_TYPEHASH,\n', '                target,\n', '                to,\n', '                value,\n', '                nonces[target]++,\n', '                deadline));\n', '\n', '        require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\n', '\n', '        require(to != address(0) || to != address(this));\n', '\n', '        uint256 balance = balanceOf[target];\n', '        require(balance >= value, "AnyswapV3ERC20: transfer amount exceeds balance");\n', '\n', '        balanceOf[target] = balance - value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(target, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\n', '        bytes32 hash = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                hashStruct));\n', '        address signer = ecrecover(hash, v, r, s);\n', '        return (signer != address(0) && signer == target);\n', '    }\n', '\n', '    function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\n', '        bytes32 hash = prefixed(hashStruct);\n', '        address signer = ecrecover(hash, v, r, s);\n', '        return (signer != address(0) && signer == target);\n', '    }\n', '\n', '    // Builds a prefixed hash to mimic the behavior of eth_sign.\n', '    function prefixed(bytes32 hash) internal view returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", DOMAIN_SEPARATOR, hash));\n', '    }\n', '\n', "    /// @dev Moves `value` AnyswapV3ERC20 token from caller's account to account (`to`).\n", '    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent AnyswapV3ERC20 token in favor of caller.\n', '    /// Emits {Transfer} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// Requirements:\n', '    ///   - caller account must have at least `value` AnyswapV3ERC20 token.\n', '    function transfer(address to, uint256 value) external override returns (bool) {\n', '        require(to != address(0) || to != address(this));\n', '        uint256 balance = balanceOf[msg.sender];\n', '        require(balance >= value, "AnyswapV3ERC20: transfer amount exceeds balance");\n', '\n', '        balanceOf[msg.sender] = balance - value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(msg.sender, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev Moves `value` AnyswapV3ERC20 token from account (`from`) to account (`to`) using allowance mechanism.\n', "    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n", '    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent AnyswapV3ERC20 token in favor of caller.\n', '    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n', '    /// unless allowance is set to `type(uint256).max`\n', '    /// Emits {Transfer} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// Requirements:\n', '    ///   - `from` account must have at least `value` balance of AnyswapV3ERC20 token.\n', '    ///   - `from` account must have approved caller to spend at least `value` of AnyswapV3ERC20 token, unless `from` and caller are the same account.\n', '    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n', '        require(to != address(0) || to != address(this));\n', '        if (from != msg.sender) {\n', '            // _decreaseAllowance(from, msg.sender, value);\n', '            uint256 allowed = allowance[from][msg.sender];\n', '            if (allowed != type(uint256).max) {\n', '                require(allowed >= value, "AnyswapV3ERC20: request exceeds allowance");\n', '                uint256 reduced = allowed - value;\n', '                allowance[from][msg.sender] = reduced;\n', '                emit Approval(from, msg.sender, reduced);\n', '            }\n', '        }\n', '\n', '        uint256 balance = balanceOf[from];\n', '        require(balance >= value, "AnyswapV3ERC20: transfer amount exceeds balance");\n', '\n', '        balanceOf[from] = balance - value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(from, to, value);\n', '\n', '        return true;\n', '    }\n', '\n', "    /// @dev Moves `value` AnyswapV3ERC20 token from caller's account to account (`to`),\n", '    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\n', '    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent AnyswapV3ERC20 token in favor of caller.\n', '    /// Emits {Transfer} event.\n', '    /// Returns boolean value indicating whether operation succeeded.\n', '    /// Requirements:\n', '    ///   - caller account must have at least `value` AnyswapV3ERC20 token.\n', '    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n', '    function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool) {\n', '        require(to != address(0) || to != address(this));\n', '\n', '        uint256 balance = balanceOf[msg.sender];\n', '        require(balance >= value, "AnyswapV3ERC20: transfer amount exceeds balance");\n', '\n', '        balanceOf[msg.sender] = balance - value;\n', '        balanceOf[to] += value;\n', '        emit Transfer(msg.sender, to, value);\n', '\n', '        return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\n', '    }\n', '}']