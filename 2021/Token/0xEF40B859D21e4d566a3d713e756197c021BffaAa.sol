['pragma solidity ^0.4.18;\n', '\n', 'import "./StandardTokenWithFees.sol";\n', 'import "./Pausable.sol";\n', 'import "./BlackList.sol";\n', '\n', 'contract UpgradedStandardToken is StandardToken {\n', '    // those methods are called by the legacy contract\n', '    // and they must ensure msg.sender to be the contract address\n', '    uint public _totalSupply;\n', '    function transferByLegacy(address from, address to, uint value) public returns (bool);\n', '    function transferFromByLegacy(address sender, address from, address spender, uint value) public returns (bool);\n', '    function approveByLegacy(address from, address spender, uint value) public returns (bool);\n', '    function increaseApprovalByLegacy(address from, address spender, uint addedValue) public returns (bool);\n', '    function decreaseApprovalByLegacy(address from, address spender, uint subtractedValue) public returns (bool);\n', '}\n', '\n', '/**\n', ' *    ERC20 APENFT Token (NFT)\n', ' */\n', '\n', 'contract ERC20APENFT is Pausable, StandardTokenWithFees, BlackList {\n', '\n', '    address public upgradedAddress;\n', '    bool public deprecated;\n', '\n', '    //  The contract can be initialized with a number of tokens\n', '    //  All the tokens are deposited to the owner address\n', '    function ERC20APENFT() public {\n', '        _totalSupply = 0; \n', '        name = "APENFT";\n', '        symbol = "NFT";\n', '        decimals = 6;\n', '        deprecated = false;\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function transfer(address _to, uint _value) public whenNotPaused returns (bool) {\n', '        require(!isBlackListed[msg.sender]);\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferByLegacy(msg.sender, _to, _value);\n', '        } else {\n', '            return super.transfer(_to, _value);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool) {\n', '        require(!isBlackListed[_from]);\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).transferFromByLegacy(msg.sender, _from, _to, _value);\n', '        } else {\n', '            return super.transferFrom(_from, _to, _value);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function balanceOf(address who) public constant returns (uint) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).balanceOf(who);\n', '        } else {\n', '            return super.balanceOf(who);\n', '        }\n', '    }\n', '\n', '    // Allow checks of balance at time of deprecation\n', '    function oldBalanceOf(address who) public constant returns (uint) {\n', '        if (deprecated) {\n', '            return super.balanceOf(who);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function approve(address _spender, uint _value) public whenNotPaused returns (bool) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).approveByLegacy(msg.sender, _spender, _value);\n', '        } else {\n', '            return super.approve(_spender, _value);\n', '        }\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).increaseApprovalByLegacy(msg.sender, _spender, _addedValue);\n', '        } else {\n', '            return super.increaseApproval(_spender, _addedValue);\n', '        }\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\n', '        if (deprecated) {\n', '            return UpgradedStandardToken(upgradedAddress).decreaseApprovalByLegacy(msg.sender, _spender, _subtractedValue);\n', '        } else {\n', '            return super.decreaseApproval(_spender, _subtractedValue);\n', '        }\n', '    }\n', '\n', '    // Forward ERC20 methods to upgraded contract if this one is deprecated\n', '    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n', '        if (deprecated) {\n', '            return StandardToken(upgradedAddress).allowance(_owner, _spender);\n', '        } else {\n', '            return super.allowance(_owner, _spender);\n', '        }\n', '    }\n', '\n', '    // deprecate current contract in favour of a new one\n', '    function deprecate(address _upgradedAddress) public onlyOwner {\n', '        require(_upgradedAddress != address(0));\n', '        deprecated = true;\n', '        upgradedAddress = _upgradedAddress;\n', '        Deprecate(_upgradedAddress);\n', '    }\n', '\n', '    // deprecate current contract if favour of a new one\n', '    function totalSupply() public constant returns (uint) {\n', '        if (deprecated) {\n', '            return StandardToken(upgradedAddress).totalSupply();\n', '        } else {\n', '            return _totalSupply;\n', '        }\n', '    }\n', '\n', '    // Issue a new amount of tokens\n', '    // these tokens are deposited into the owner address\n', '    //\n', '    // @param _amount Number of tokens to be issued\n', '    function issue(uint amount) public onlyOwner {\n', '        balances[owner] = balances[owner].add(amount);\n', '        _totalSupply = _totalSupply.add(amount);\n', '        Issue(amount);\n', '        Transfer(address(0), owner, amount);\n', '    }\n', '\n', '    // Redeem tokens.\n', '    // These tokens are withdrawn from the owner address\n', '    // if the balance must be enough to cover the redeem\n', '    // or the call will fail.\n', '    // @param _amount Number of tokens to be issued\n', '    function redeem(uint amount) public onlyOwner {\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        balances[owner] = balances[owner].sub(amount);\n', '        Redeem(amount);\n', '        Transfer(owner, address(0), amount);\n', '    }\n', '\n', '    function destroyBlackFunds (address _blackListedUser) public onlyOwner {\n', '        require(isBlackListed[_blackListedUser]);\n', '        uint dirtyFunds = balanceOf(_blackListedUser);\n', '        balances[_blackListedUser] = 0;\n', '        _totalSupply = _totalSupply.sub(dirtyFunds);\n', '        DestroyedBlackFunds(_blackListedUser, dirtyFunds);\n', '    }\n', '\n', '    event DestroyedBlackFunds(address indexed _blackListedUser, uint _balance);\n', '\n', '    // Called when new token are issued\n', '    event Issue(uint amount);\n', '\n', '    // Called when tokens are redeemed\n', '    event Redeem(uint amount);\n', '\n', '    // Called when contract is deprecated\n', '    event Deprecate(address newAddress);\n', '\n', '}']