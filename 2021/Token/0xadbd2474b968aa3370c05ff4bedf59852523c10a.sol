['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-18\n', '*/\n', '\n', '// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IArmorMaster {\n', '    function registerModule(bytes32 _key, address _module) external;\n', '    function getModule(bytes32 _key) external view returns(address);\n', '    function keep() external;\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * \n', ' * @dev Completely default OpenZeppelin.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function initializeOwnable() internal {\n', '        require(_owner == address(0), "already initialized");\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "msg.sender is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    function receiveOwnership() public {\n', '        require(msg.sender == _pendingOwner, "only pending owner can call this function");\n', '        _transferOwnership(_pendingOwner);\n', '        _pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', 'library Bytes32 {\n', '    function toString(bytes32 x) internal pure returns (string memory) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint256 j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (uint256 j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n', '**/\n', 'contract ArmorModule {\n', '    IArmorMaster internal _master;\n', '\n', '    using Bytes32 for bytes32;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == Ownable(address(_master)).owner(), "only owner can call this function");\n', '        _;\n', '    }\n', '\n', '    modifier doKeep() {\n', '        _master.keep();\n', '        _;\n', '    }\n', '\n', '    modifier onlyModule(bytes32 _module) {\n', '        string memory message = string(abi.encodePacked("only module ", _module.toString()," can call this function"));\n', '        require(msg.sender == getModule(_module), message);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Used when multiple can call.\n', '    **/\n', '    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n', '        string memory message = string(abi.encodePacked("only module ", _moduleOne.toString()," or ", _moduleTwo.toString()," can call this function"));\n', '        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n', '        _;\n', '    }\n', '\n', '    function initializeModule(address _armorMaster) internal {\n', '        require(address(_master) == address(0), "already initialized");\n', '        require(_armorMaster != address(0), "master cannot be zero address");\n', '        _master = IArmorMaster(_armorMaster);\n', '    }\n', '\n', '    function changeMaster(address _newMaster) external onlyOwner {\n', '        _master = IArmorMaster(_newMaster);\n', '    }\n', '\n', '    function getModule(bytes32 _key) internal view returns(address) {\n', '        return _master.getModule(_key);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IARNXMVault {\n', '    function unwrapWnxm() external;\n', '    function buyNxmWithEther(uint256 _minAmount) external payable;\n', '}\n', '\n', 'interface IClaimManager {\n', '    function initialize(address _armorMaster) external;\n', '    function transferNft(address _to, uint256 _nftId) external;\n', '    function exchangeWithdrawal(uint256 _amount) external;\n', '}\n', '\n', '/**\n', ' * @dev Quick interface for the Nexus Mutual contract to work with the Armor Contracts.\n', ' **/\n', '\n', '// to get nexus mutual contract address\n', 'interface INXMMaster {\n', '    function tokenAddress() external view returns(address);\n', '    function owner() external view returns(address);\n', '    function pauseTime() external view returns(uint);\n', '    function masterInitialized() external view returns(bool);\n', '    function isPause() external view returns(bool check);\n', '    function isMember(address _add) external view returns(bool);\n', '    function getLatestAddress(bytes2 _contractName) external view returns(address payable contractAddress);\n', '}\n', '\n', 'interface INXMPool {\n', '    function buyNXM(uint minTokensOut) external payable;\n', '}\n', '\n', 'interface IBFactory {\n', '    function isBPool(address _pool) external view returns(bool);\n', '}\n', '\n', 'interface IBPool {\n', '    function swapExactAmountIn(address tokenin, uint256 inamount, address out, uint256 minreturn, uint256 maxprice) external returns(uint tokenAmountOut, uint spotPriceAfter);\n', '}\n', '\n', 'interface IUniswapV2Router02 {\n', '    function swapExactETHForTokens(uint256 minReturn, address[] calldata path, address to, uint256 deadline) external payable returns(uint256[] memory);\n', '}\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', '/**\n', ' * ExchangeManager contract enables us to slowly exchange excess claim funds for wNXM then transfer to the arNXM vault. \n', '**/\n', 'contract ExchangeManager is ArmorModule {\n', '    \n', '    address public exchanger;\n', '    IARNXMVault public constant ARNXM_VAULT = IARNXMVault(0x1337DEF1FC06783D4b03CB8C1Bf3EBf7D0593FC4);\n', '    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    IERC20 public constant WNXM = IERC20(0x0d438F3b5175Bebc262bF23753C1E53d03432bDE);\n', '    INXMMaster public constant NXM_MASTER = INXMMaster(0x01BFd82675DBCc7762C84019cA518e701C0cD07e);\n', '    IBFactory public constant BALANCER_FACTORY = IBFactory(0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd);\n', '    IUniswapV2Router02 public constant UNI_ROUTER = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    IUniswapV2Router02 public constant SUSHI_ROUTER = IUniswapV2Router02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n', '\n', '    // Address allowed to exchange tokens.\n', '    modifier onlyExchanger {\n', '        require(msg.sender == exchanger, "Sender is not approved to exchange.");\n', '        _;\n', '    }\n', '\n', '    // ClaimManager will be sending Ether to this contract.\n', '    receive() external payable { }\n', '    \n', '    /**\n', '     * @dev Initialize master for the contract. Owner must also add module for ExchangeManager to master upon deployment.\n', '     * @param _armorMaster Address of the ArmorMaster contract.\n', '    **/\n', '    function initialize(address _armorMaster, address _exchanger)\n', '      external\n', '    {\n', '        initializeModule(_armorMaster);\n', '        exchanger = _exchanger;\n', '    }\n', '    \n', '    /**\n', '     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\n', '     * @param _amount Amount of Ether (in Wei) to withdraw from ClaimManager.\n', '     * @param _minReturn Minimum amount of wNXM we will accept in return for the Ether exchanged.\n', '    **/\n', '    function buyWNxmUni(uint256 _amount, uint256 _minReturn, address[] memory _path)\n', '      external\n', '      onlyExchanger\n', '    {\n', '        _requestFunds(_amount);\n', '        _exchangeAndSendToVault(address(UNI_ROUTER), _minReturn, _path);\n', '    }\n', '    \n', '    /**\n', '     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\n', '     * @param _amount Amount of Ether (in Wei) to withdraw from ClaimManager.\n', '     * @param _minReturn Minimum amount of wNXM we will accept in return for the Ether exchanged.\n', '    **/\n', '    function buyWNxmSushi(uint256 _amount, uint256 _minReturn, address[] memory _path)\n', '      external\n', '      onlyExchanger\n', '    {\n', '        _requestFunds(_amount);\n', '        _exchangeAndSendToVault(address(SUSHI_ROUTER), _minReturn, _path);\n', '    }\n', '\n', '    function buyWNxmBalancer(uint256 _amount, address _bpool, uint256 _minReturn, uint256 _maxPrice)\n', '      external\n', '      onlyExchanger\n', '    {\n', '        require(BALANCER_FACTORY.isBPool(_bpool), "NOT_BPOOL");\n', '        _requestFunds(_amount);\n', '        uint256 balance = address(this).balance;\n', '        IWETH(address(WETH)).deposit{value:balance}();\n', '        WETH.approve(_bpool, balance);\n', '        IBPool(_bpool).swapExactAmountIn(address(WETH), balance, address(WNXM), _minReturn, _maxPrice);\n', '        _transferWNXM();\n', '        ARNXM_VAULT.unwrapWnxm();\n', '    }\n', '    \n', '    /**\n', '     * @dev Main function to withdraw Ether from ClaimManager, exchange, then transfer to arNXM Vault.\n', '     * @param _ethAmount Amount of Ether (in Wei) to withdraw from ClaimManager.\n', '     * @param _minNxm Minimum amount of NXM we will accept in return for the Ether exchanged.\n', '    **/\n', '    function buyNxm(uint256 _ethAmount, uint256 _minNxm)\n', '      external\n', '      onlyExchanger\n', '    {\n', '        _requestFunds(_ethAmount);\n', '        ARNXM_VAULT.buyNxmWithEther{value:_ethAmount}(_minNxm);\n', '    }\n', '\n', '    /**\n', '     * @dev Call ClaimManager to request Ether from the contract.\n', '     * @param _amount Ether (in Wei) to withdraw from ClaimManager.\n', '    **/\n', '    function _requestFunds(uint256 _amount)\n', '      internal\n', '    {\n', '        IClaimManager( getModule("CLAIM") ).exchangeWithdrawal(_amount);\n', '    }\n', ' \n', '    /**\n', '     * @dev Exchange all Ether for wNXM on uniswap-like exchanges\n', '     * @param _router router address of uniswap-like protocols(uni/sushi)\n', '     * @param _minReturn Minimum amount of wNXM we wish to receive from the exchange.\n', '    **/\n', '    function _exchangeAndSendToVault(address _router, uint256 _minReturn, address[] memory _path)\n', '      internal\n', '    {\n', '        uint256 ethBalance = address(this).balance;\n', '        IUniswapV2Router02(_router).swapExactETHForTokens{value:ethBalance}(_minReturn, _path, address(ARNXM_VAULT), uint256(~0) );\n', '        ARNXM_VAULT.unwrapWnxm();\n', '    }\n', '    \n', '    /**\n', '     * @dev Transfer all wNXM directly to arNXM. This will not mint more arNXM so it will add value to arNXM.\n', '    **/\n', '    function _transferWNXM()\n', '      internal\n', '    {\n', '        uint256 wNxmBalance = WNXM.balanceOf( address(this) );\n', '        WNXM.transfer(address(ARNXM_VAULT), wNxmBalance);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer all NXM directly to arNXM. This will not mint more arNXM so it will add value to arNXM.\n', '    **/\n', '    function _transferNXM()\n', '      internal\n', '    {\n', '        IERC20 NXM = IERC20(NXM_MASTER.tokenAddress());\n', '        uint256 nxmBalance = NXM.balanceOf( address(this) );\n', '        NXM.transfer(address(ARNXM_VAULT), nxmBalance);\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner may change the address allowed to exchange tokens.\n', '     * @param _newExchanger New address to make exchanger.\n', '    **/\n', '    function changeExchanger(address _newExchanger)\n', '      external\n', '      onlyOwner\n', '    {\n', '        exchanger = _newExchanger;\n', '    }\n', '    \n', '}']