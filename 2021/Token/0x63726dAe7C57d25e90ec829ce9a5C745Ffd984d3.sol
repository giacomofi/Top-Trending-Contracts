['pragma solidity >=0.6.6;\n', '\n', 'import "./library/SafeMathDEOR.sol";\n', 'import "./library/Ownable.sol";\n', 'import "./interfaces/IDEOR.sol";\n', '\n', 'contract DEOR is IDEOR, Ownable {\n', '\n', '    using SafeMathDEOR for uint256;\n', '\n', '    mapping(address => uint256) _balances;\n', '    mapping (address => mapping (address => uint256)) _allowed;\n', '\n', '    string private _name = "DEOR";\n', '    string private _symbol = "DEOR";\n', '    uint256 private _decimals = 10;\n', '    uint256 private _totalSupply;\n', '    uint256 private _maxSupply = 100000000 * (10**_decimals);\n', '    bool public mintingFinished = false;\n', '\tuint256 public startTime = 1488294000;\n', '\n', '    constructor() public {}\n', '\n', '    receive () external payable {\n', '        revert();\n', '    }\n', '\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view virtual returns (uint256) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view virtual override(IDEOR) returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address _owner) external view override(IDEOR) returns (uint256) {\n', '        return _balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) external override(IDEOR) returns (bool) {\n', '        _balances[msg.sender] = _balances[msg.sender].sub(_value);\n', '        _balances[_to] = _balances[_to].add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external override(IDEOR) returns (bool) {\n', '        uint256 _allowance = _allowed[_from][msg.sender];\n', '\n', '        _allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        _balances[_to] = _balances[_to].add(_value);\n', '        _balances[_from] = _balances[_from].sub(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) external override(IDEOR) returns (bool) {\n', '        _allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) external view override(IDEOR) returns (uint256) {\n', '        return _allowed[_owner][_spender];\n', '    }\n', '\n', '\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * Function to mint tokens\n', '    * @param _to The address that will recieve the minted tokens.\n', '    * @param _amount The amount of tokens to mint.\n', '    * @return A boolean that indicates if the operation was successful.\n', '    */\n', '    function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n', '        uint256 amount = _maxSupply.sub(_totalSupply);\n', '        if (amount > _amount) {\n', '            amount = _amount;\n', '        }\n', '        else {\n', '            mintingFinished = true;\n', '            emit MintFinished();\n', '        }\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[_to] = _balances[_to].add(amount);\n', '        emit Mint(_to, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * Function to stop minting new tokens.\n', '    * @return True if the operation was successful.\n', '    */\n', '    function finishMinting() public onlyOwner returns (bool) {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '        return true;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// pragma solidity ^0.7.0;\n', 'pragma solidity >=0.6.6;\n', '// pragma solidity >=0.4.21 <0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMathDEOR {\n', '  /**\n', '    * @dev Returns the addition of two unsigned integers, reverting on\n', '    * overflow.\n', '    *\n', "    * Counterpart to Solidity's `+` operator.\n", '    *\n', '    * Requirements:\n', '    * - Addition cannot overflow.\n', '    */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '    * @dev Returns the subtraction of two unsigned integers, reverting on\n', '    * overflow (when the result is negative).\n', '    *\n', "    * Counterpart to Solidity's `-` operator.\n", '    *\n', '    * Requirements:\n', '    * - Subtraction cannot overflow.\n', '    */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath: subtraction overflow");\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '    * @dev Returns the multiplication of two unsigned integers, reverting on\n', '    * overflow.\n', '    *\n', "    * Counterpart to Solidity's `*` operator.\n", '    *\n', '    * Requirements:\n', '    * - Multiplication cannot overflow.\n', '    */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '    * @dev Returns the integer division of two unsigned integers. Reverts on\n', '    * division by zero. The result is rounded towards zero.\n', '    *\n', "    * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '    * uses an invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    * - The divisor cannot be zero.\n', '    */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, "SafeMath: division by zero");\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '    * Reverts when dividing by zero.\n', '    *\n', "    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '    * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '    * invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    * - The divisor cannot be zero.\n', '    */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0, "SafeMath: modulo by zero");\n', '    return a % b;\n', '  }\n', '\n', '  /**\n', '    * @dev Returns the ceiling of log_2,\n', '    *\n', '    */\n', '  function log_2(uint256 x) internal pure returns (uint256) {\n', '    uint256 idx = 1;\n', '    uint256 res = 0;\n', '    while (x > idx) {\n', '      idx = idx << 1;\n', '      res = add(res, 1);\n', '    }\n', '    return res;\n', '  }\n', '}\n', '\n', 'pragma solidity >=0.6.6;\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public devAddr = address(0x7e9f1f3F25515F0421D44d23cC98f76bdA1db2D1);\n', '    address public treasury = address(0x92126534bc8448de051FD9Cb8c54C31b82525669);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner, address newDev) public onlyOwner {\n', '        if (newOwner != address(0)) {\n', '            owner = newOwner;\n', '        }\n', '        if (newDev != address(0)) {\n', '            devAddr = newDev;\n', '        }\n', '    }\n', '\n', '}\n', '\n', '// pragma solidity >=0.4.21 <0.6.0;\n', 'pragma solidity >=0.6.6;\n', '\n', 'interface IDEOR {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '}']