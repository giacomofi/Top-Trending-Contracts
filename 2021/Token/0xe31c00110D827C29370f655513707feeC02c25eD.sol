['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-27\n', '*/\n', '\n', '// File: contracts/MultiSigInterface.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'contract MultiSigInterface{\n', '  function update_and_check_reach_majority(uint64 id, string memory name, bytes32 hash, address sender) public returns (bool);\n', '  function is_signer(address addr) public view returns(bool);\n', '}\n', '\n', '// File: contracts/MultiSigToolsWithReward.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', 'contract RewardInterface{\n', '  function reward(address payable to, uint256 amount) public;\n', '}\n', '\n', '//We do not inherit from MultiSigTools\n', 'contract MultiSigToolsWithReward{\n', '  MultiSigInterface public multisig_contract;\n', '  RewardInterface public reward_contract;\n', '\n', '  constructor(address _contract, address _rewarder) public{\n', '    require(_contract!= address(0x0));\n', '    reward_contract = RewardInterface(_rewarder);\n', '\n', '    multisig_contract = MultiSigInterface(_contract);\n', '  }\n', '\n', '  modifier only_signer{\n', '    require(multisig_contract.is_signer(msg.sender), "only a signer can call in MultiSigTools");\n', '    _;\n', '  }\n', '\n', '  modifier is_majority_sig(uint64 id, string memory name) {\n', '    uint256 gas_start = gasleft();\n', '    bytes32 hash = keccak256(abi.encodePacked(msg.sig, msg.data));\n', '    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\n', '      _;\n', '    }\n', '    uint256 gasused = (gas_start - gasleft()) * tx.gasprice;\n', '    if(reward_contract != RewardInterface(0x0)){\n', '      reward_contract.reward(tx.origin, gasused);\n', '    }\n', '  }\n', '\n', '  modifier is_majority_sig_with_hash(uint64 id, string memory name, bytes32 hash) {\n', '    uint256 gas_start = gasleft();\n', '    if(multisig_contract.update_and_check_reach_majority(id, name, hash, msg.sender)){\n', '      _;\n', '    }\n', '    uint256 gasused = (gas_start - gasleft()) * tx.gasprice;\n', '    if(reward_contract != RewardInterface(0x0)){\n', '      reward_contract.reward(tx.origin, gasused);\n', '    }\n', '  }\n', '\n', '  event ChangeRewarder(address _old, address _new);\n', '  function changeRewarder(uint64 id, address _rewarder) public only_signer\n', '  is_majority_sig(id, "changeRewarder"){\n', '    address old = address(reward_contract);\n', '    reward_contract = RewardInterface(_rewarder);\n', '    emit ChangeRewarder(old, _rewarder);\n', '  }\n', '\n', '  event TransferMultiSig(address _old, address _new);\n', '  function transfer_multisig(uint64 id, address _contract) public only_signer\n', '  is_majority_sig(id, "transfer_multisig"){\n', '    require(_contract != address(0x0));\n', '    address old = address(multisig_contract);\n', '    multisig_contract = MultiSigInterface(_contract);\n', '    emit TransferMultiSig(old, _contract);\n', '  }\n', '}\n', '\n', '// File: contracts/erc20/IERC20.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/utils/TokenClaimer.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', 'contract TokenClaimer{\n', '\n', '    event ClaimedTokens(address indexed _token, address indexed _to, uint _amount);\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '  function _claimStdTokens(address _token, address payable to) internal {\n', '        if (_token == address(0x0)) {\n', '            to.transfer(address(this).balance);\n', '            return;\n', '        }\n', '        uint balance = IERC20(_token).balanceOf(address(this));\n', '\n', '        (bool status,) = _token.call(abi.encodeWithSignature("transfer(address,uint256)", to, balance));\n', '        require(status, "call failed");\n', '        emit ClaimedTokens(_token, to, balance);\n', '  }\n', '}\n', '\n', '// File: contracts/MultiSigBody.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', '\n', 'contract MultiSigBody is MultiSigToolsWithReward, TokenClaimer{\n', '\n', '  constructor(address _multisig, address _reward) MultiSigToolsWithReward(_multisig, _reward) public{}\n', '\n', '  function call_contract(uint64 id, address _addr, bytes memory _data, uint256 _value)\n', '    public only_signer is_majority_sig(id, "call_contract"){\n', '    (bool success,) = _addr.call.value(_value)(_data);\n', '    require(success, "MultisigBody call failed");\n', '  }\n', '\n', '  function claimStdTokens(uint64 id, address _token, address payable to)\n', '  public only_signer is_majority_sig(id, "claimStdTokens"){\n', '    _claimStdTokens(_token, to);\n', '  }\n', '\n', '  event RecvETH(uint256 v);\n', '  function() external payable{\n', '    emit RecvETH(msg.value);\n', '  }\n', '}\n', '\n', 'contract MultiSigBodyFactory{\n', '\n', '  event NewMultiSigBody(address addr, address _multisig);\n', '  function createMultiSig(address _multisig, address _reward) public returns(address){\n', '    MultiSigBody ms = new MultiSigBody(_multisig, _reward);\n', '    emit NewMultiSigBody(address(ms), _multisig);\n', '    return address(ms);\n', '  }\n', '}']