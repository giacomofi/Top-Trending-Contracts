['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-01\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2019-07-08\n', '*/\n', '\n', 'pragma solidity ^0.4.11;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '\n', '  bool public paused = false;\n', '\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '\n', '\n', 'contract Token {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '    /// total amount of tokens\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of tokens to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', 'contract StandardToken is Token {\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) public balances; // *added public\n', '    mapping (address => mapping (address => uint256)) public allowed; // *added public\n', '}\n', '\n', '\n', 'contract APDNToken is StandardToken, Pausable {\n', '\n', '    string public constant name = "APDN Token";\n', '    string public constant symbol = "APDN";\n', '    uint8 public constant decimals = 6;\n', '    uint256 public constant totalSupply = 210000000000000000;\n', '\n', '    // Holds the amount and date of a given balance lock.\n', '    struct BalanceLock {\n', '        uint256 amount;\n', '        uint256 unlockDate;\n', '    }\n', '\n', '    // A mapping of balance lock to a given address.\n', '    mapping (address => BalanceLock) public balanceLocks;\n', '\n', '    // An event to notify that _owner has locked a balance.\n', '    event BalanceLocked(address indexed _owner, uint256 _oldLockedAmount,\n', '    uint256 _newLockedAmount, uint256 _expiry);\n', '\n', '    /** @dev Constructor for the contract.\n', '      */\n', '    function APDNToken()\n', '        Pausable() {\n', '        balances[msg.sender] = totalSupply;\n', '        Transfer(0x0, msg.sender, totalSupply);\n', '    }\n', '\n', '    /** @dev Sets a token balance to be locked by the sender, on the condition\n', '      * that the amount is equal or greater than the previous amount, or if the\n', '      * previous lock time has expired.\n', '      * @param _value The amount be locked.\n', '      */\n', '      //设置锁仓\n', '    function lockBalance(address addr, uint256 _value,uint256 lockingDays) onlyOwner {\n', '\n', '        // Check if the lock on previously locked tokens is still active.\n', '        if (balanceLocks[addr].unlockDate > now) { // 未到可转账日期\n', '            // Only allow confirming the lock or adding to it.\n', '            require(_value >= balanceLocks[addr].amount);\n', '        }\n', '        // Ensure that no more than the balance can be locked.\n', '        require(balances[addr] >= _value);\n', '        // convert days to seconds\n', '        uint256 lockingPeriod = lockingDays*24*3600;\n', '        // Lock tokens and notify.\n', '        uint256 _expiry = now + lockingPeriod;\n', '        BalanceLocked(addr, balanceLocks[addr].amount, _value, _expiry);\n', '        balanceLocks[addr] = BalanceLock(_value, _expiry);\n', '    }\n', '\n', '    /** @dev Returns the balance that a given address has available for transfer.\n', '      * @param _owner The address of the token owner.\n', '      */\n', '    // 返回用户当前可用余额\n', '    function availableBalance(address _owner) constant returns(uint256) {\n', '        if (balanceLocks[_owner].unlockDate < now) {\n', '            return balances[_owner];\n', '        } else {\n', '            assert(balances[_owner] >= balanceLocks[_owner].amount);\n', '            return balances[_owner] - balanceLocks[_owner].amount;\n', '        }\n', '    }\n', '\n', '    /** @dev Send `_value` token to `_to` from `msg.sender`, on the condition\n', '      * that there are enough unlocked tokens in the `msg.sender` account.\n', '      * @param _to The address of the recipient.\n', '      * @param _value The amount of token to be transferred.\n', '      * @return Whether the transfer was successful or not.\n', '      */\n', '      // \n', '    function transfer(address _to, uint256 _value) whenNotPaused returns (bool success) {\n', '        require(availableBalance(msg.sender) >= _value);\n', '        return super.transfer(_to, _value);\n', '    }\n', '\n', '    /** @dev Send `_value` token to `_to` from `_from` on the condition\n', '      * that there are enough unlocked tokens in the `_from` account.\n', '      * @param _from The address of the sender.\n', '      * @param _to The address of the recipient.\n', '      * @param _value The amount of token to be transferred.\n', '      * @return Whether the transfer was successful or not.\n', '      */\n', '    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused\n', '        returns (bool success) {\n', '        require(availableBalance(_from) >= _value);\n', '        return super.transferFrom(_from, _to, _value);\n', '    }\n', '}']