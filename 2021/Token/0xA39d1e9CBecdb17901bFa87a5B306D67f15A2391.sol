['pragma solidity ^0.6.6;\n', '\n', "import './Ownable.sol';\n", "import './ACOAssetHelper.sol';\n", '\n', 'contract ACODistributor is Ownable {\n', '\n', '    event Claim(bytes32 indexed id, address indexed account, address indexed aco, uint256 amount);\n', '    event WithdrawToken(address indexed token, uint256 amount, address destination);\n', '    event Halt(bool previousHalted, bool newHalted);\n', '\t\n', '    address immutable public signer;\n', '    \n', '    address[] public acos;\n', '    mapping(address => uint256) public acosAmount;\n', '    \n', '    bool public halted;\n', '    \n', '    mapping(bytes32 => bool) public claimed;\n', '    \n', '    modifier isValidMessage(bytes32 id, address account, uint256 amount, uint8 v, bytes32 r, bytes32 s) {\n', '\t\trequire(signer == ecrecover(\n', '\t\t    keccak256(abi.encodePacked(\n', '\t            "\\x19Ethereum Signed Message:\\n32", \n', '\t            keccak256(abi.encodePacked(address(this), id, account, amount))\n', '            )), v, r, s), "Invalid arguments");\n', '\t\t_;\n', '\t}\n', '    \n', '    constructor (address _signer, address[] memory _acos) public {\n', '        super.init();\n', '        \n', '        signer = _signer;\n', '        halted = false;\n', '        \n', '        for (uint256 i = 0; i < _acos.length; ++i) {\n', '            acos.push(_acos[i]);\n', '        }\n', '    }\n', '    \n', '    function withdrawToken(address token, uint256 amount, address destination) onlyOwner external {\n', '        uint256 _balance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\n', '        if (_balance < amount) {\n', '            amount = _balance;\n', '        }\n', '        if (acosAmount[token] > 0) {\n', '            acosAmount[token] = _balance - amount;    \n', '        }\n', '        ACOAssetHelper._transferAsset(token, destination, amount);\n', '        emit WithdrawToken(token, amount, destination);\n', '    }\n', '\n', '    function setAcoBalances() onlyOwner external {\n', '        for (uint256 i = 0; i < acos.length; ++i) {\n', '            acosAmount[acos[i]] = ACOAssetHelper._getAssetBalanceOf(acos[i], address(this));\n', '        }\n', '    }\n', '\n', '    function setHalt(bool _halted) onlyOwner external {\n', '        emit Halt(halted, _halted);\n', '        halted = _halted;\n', '    }\n', '    \n', '    function acosLength() view external returns(uint256) {\n', '        return acos.length;\n', '    }\n', '    \n', '    function getClaimableAcos(uint256 amount) view external returns(address[] memory _acos, uint256[] memory _amounts) {\n', '        uint256 qty = 0;\n', '        uint256 remaining = amount;\n', '        for (uint256 i = 0; i < acos.length; ++i) {\n', '            address _aco = acos[i];\n', '            uint256 available = acosAmount[_aco];\n', '            if (available > 0) {\n', '                ++qty;\n', '                if (available >= remaining) {\n', '                    break;\n', '                } else {\n', '                    remaining = remaining - available;\n', '                }\n', '            }\n', '        }\n', '\n', '        _acos = new address[](qty);\n', '        _amounts = new uint256[](qty);\n', '        \n', '        if (qty > 0) {\n', '            uint256 index = 0;\n', '            remaining = amount;\n', '            for (uint256 i = 0; i < acos.length; ++i) {\n', '                address _aco = acos[i];\n', '                uint256 available = acosAmount[_aco];\n', '                if (available > 0) {\n', '                    _acos[index] = _aco;\n', '                    if (available >= remaining) {\n', '                        _amounts[index] = remaining;\n', '                        break;\n', '                    } else {\n', '                        remaining = remaining - available;\n', '                        _amounts[index] = available;\n', '                    }\n', '                    ++index;\n', '                }\n', '            }\n', '        }\n', '    }\n', '    \n', '    function claim(\n', '        bytes32 id, \n', '        address account, \n', '        uint256 amount, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s\n', '    ) isValidMessage(id, account, amount, v, r, s) external {\n', '        require(!halted, "Halted");\n', '        require(!claimed[id], "Claimed");\n', '        \n', '        claimed[id] = true;\n', '        _claim(id, account, amount);\n', '    }\n', '    \n', '    function _claim(bytes32 id, address account, uint256 amount) internal {\n', '        for (uint256 i = 0; i < acos.length; ++i) {\n', '            address _aco = acos[i];\n', '            uint256 available = acosAmount[_aco];\n', '            if (available > 0) {\n', '                if (available >= amount) {\n', '                    acosAmount[_aco] = available - amount;\n', '                    ACOAssetHelper._callTransferERC20(_aco, account, amount);\n', '\t\t            emit Claim(id, account, _aco, amount);\n', '                    break;\n', '                } else {\n', '                    amount = amount - available;\n', '                    acosAmount[_aco] = 0;\n', '                    ACOAssetHelper._callTransferERC20(_aco, account, available);\n', '\t\t            emit Claim(id, account, _aco, available);\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']