['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity =0.7.5;\n', '\n', 'import "./ContextOwnable.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ERC20.sol";\n', '\n', 'contract FlamerToken is ERC20 {\n', '\n', '    using SafeMath for uint256; \n', '\n', '    address private _factory;\n', '    address private _router;\n', '    address private burnModeExcluded;\n', '    \n', '    uint256 public BurnRate = 4;\n', '    uint256 public constant BurnRatePercentsDevider = 1000;\n', '    uint256 _supplyTokens;\n', '    uint256 _supplyNotForBurn;\n', '    uint256 _alreadyBurnedTokens;\n', '    bool _transactionsWithBurnMode;\n', '    \n', '    event burnTokensDuringTransactions (bool _transactionsWithBurnMode);\n', '\n', '    constructor (address router, address factory) ERC20(_name, _symbol) {\n', '    \n', '        // default router and factory setup\n', '        _router = router;\n', '        _factory = factory;\n', '             \n', '        _name = "Flamer";\n', '        _symbol = "FLAME";\n', '        _decimals = 18;\n', '        \n', '        // supply:\n', '        _supplyTokens = 1000000 *10 **(_decimals);\n', '        _totalSupply = _totalSupply.add(_supplyTokens);\n', '        _balances[msg.sender] = _balances[msg.sender].add(_supplyTokens);\n', '        emit Transfer(address(0), msg.sender, _supplyTokens);\n', '    \n', '        // separate the half of the total supply tokens from brun mode.\n', '        _supplyNotForBurn = _supplyTokens.div(2);\n', '    \n', '        // disable (by default) burn tokens mode during each transaction.\n', '        _transactionsWithBurnMode = false;\n', '        \n', '        // exclude owner from the burn mode.\n', '        burnModeExcluded = msg.sender;\n', '    }\n', ' \n', '     /**\n', '     * @dev Transfer, which will burn tokens mode for each transaction.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal override {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '        \n', '        // Calculate amount of tokens to burn and execute it. Then add that amount to statistic variable\n', '        // of already burned tokens and calculate how many tokens left after burn.\n', '        uint256 finalAmount = amount;\n', '        if(_totalSupply > _supplyNotForBurn && _transactionsWithBurnMode == true\n', '        && sender != burnModeExcluded && recipient != burnModeExcluded) {\n', '            uint256 amountToBurn = amount.mul(BurnRate).div(BurnRatePercentsDevider);\n', '            _burn(sender, amountToBurn);\n', '            _alreadyBurnedTokens = _alreadyBurnedTokens.add(amountToBurn);\n', '            finalAmount = amount.sub(amountToBurn);\n', '        }\n', '        _balances[sender] = _balances[sender].sub(finalAmount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(finalAmount);\n', '        emit Transfer(sender, recipient, finalAmount);\n', '    }\n', '    \n', '    /**\n', '     * @dev Return an amount of already burned tokens.\n', '     */ \n', '    function AlreadyBurnedTokens () public view returns (uint256) {\n', '        return _alreadyBurnedTokens;\n', '    }\n', '    \n', '    /**\n', '     * @dev Return a value of tokens, that cannot be burned.\n', '     */\n', '    function SupplyNotForBurn() public view returns (uint256) {\n', '        return _supplyNotForBurn;\n', '    }\n', '    \n', '    /**\n', '     * @dev Allows to trun burn mode on. This will burn some tokens during each transaction.\n', '     */\n', '    function StartBurnModeDuringTransactions() public authorized {\n', '        _transactionsWithBurnMode = true;\n', '        emit burnTokensDuringTransactions(_transactionsWithBurnMode);\n', '    }\n', '    \n', '    /**\n', '     * @dev Return state of burn mode.\n', '     */ \n', '    function TransactionsWithBurnModeOn() public view returns (bool) {\n', '        return _transactionsWithBurnMode;\n', '    }\n', '    \n', '    /**\n', '     * @dev Return a balacne of tokens locked in the contract.\n', '     */ \n', '    function TokensLockedInContract() public view returns (uint256) {\n', '        return _balances[address(this)];\n', '    }\n', '    \n', '    /**\n', '     * @dev Burns 10 percent of additionl tokens locked in the contract.\n', '     */\n', '    function Burn10percentOfLockedTokens() public authorized {\n', '        // Calculate 10% of tokens (locked in contract) and burn them.\n', '        // Add burned amount to statistic variable of already burned tokens.\n', '        uint256 _supplyToBurn10percent = _balances[address(this)].mul(10).div(100);\n', '        _balances[address(this)] = _balances[address(this)].sub(_supplyToBurn10percent, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(_supplyToBurn10percent);\n', '        _alreadyBurnedTokens = _alreadyBurnedTokens.add(_supplyToBurn10percent);\n', '        emit Transfer(address(this), address(0), _supplyToBurn10percent);\n', '    }\n', '}']