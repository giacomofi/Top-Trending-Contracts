['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) public pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) public pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) public pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) public pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) public pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) public pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SavixSupply.sol";\n', '\n', 'contract Savix is IERC20\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    address private _owner;\n', '    string private constant NAME = "Savix";\n', '    string private constant SYMBOL = "SVX";\n', '    uint private constant DECIMALS = 9;\n', '    uint private _constGradient = 0;\n', '    address private constant BURNADDR = 0x000000000000000000000000000000000000dEaD; // global burn address\n', '\n', '    bool private _stakingActive = false;\n', '    uint256 private _stakingSince = 0;\n', '\n', '    uint256 private constant MAX_UINT256 = 2**256 - 1;\n', '    uint256 private constant INITIAL_TOKEN_SUPPLY = 10**5 * 10**DECIMALS;\n', '\n', '    // TOTAL_FRAGMENTS is a multiple of INITIAL_TOKEN_SUPPLY so that _fragmentsPerToken is an integer.\n', '    // Use the highest value that fits in a uint256 for max granularity.\n', '    uint256 private constant TOTAL_FRAGMENTS = MAX_UINT256 - (MAX_UINT256 % INITIAL_TOKEN_SUPPLY);\n', '\n', '    uint256 private _totalSupply = INITIAL_TOKEN_SUPPLY;\n', '    uint256 private _lastTotalSupply = INITIAL_TOKEN_SUPPLY;\n', '    // ** added: new variable _adjustTime\n', '    uint256 private _adjustTime = 0;\n', '    uint256 private _lastAdjustTime = 0;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '    uint256 private _burnAmount;\n', '    uint256[2][] private _supplyMap;\n', '\n', '    constructor() public\n', '    {\n', '        _owner = msg.sender;\n', '        \n', '         _totalSupply = INITIAL_TOKEN_SUPPLY;\n', '        _balances[_owner] = TOTAL_FRAGMENTS;\n', '\n', '        _supplyMap.push([0, 100000 * 10**DECIMALS]);\n', '        _supplyMap.push([7 * SavixSupply.SECPERDAY, 115000 * 10**DECIMALS]);\n', '        _supplyMap.push([30 * SavixSupply.SECPERDAY, 130000 * 10**DECIMALS]);\n', '        _supplyMap.push([6 * 30 * SavixSupply.SECPERDAY, 160000 * 10**DECIMALS]);\n', '        _supplyMap.push([12 * 30 * SavixSupply.SECPERDAY, 185000 * 10**DECIMALS]);\n', '        _supplyMap.push([18 * 30 * SavixSupply.SECPERDAY, 215000 * 10**DECIMALS]);\n', '        _supplyMap.push([24 * 30 * SavixSupply.SECPERDAY, 240000 * 10**DECIMALS]);\n', '        _supplyMap.push([48 * 30 * SavixSupply.SECPERDAY, 300000 * 10**DECIMALS]);\n', '        // ** changed: gradient changed for slightly higher interest in far future \n', '        // _constGradient = SafeMath.div(INITIAL_TOKEN_SUPPLY * CONSTINTEREST, 360 * SavixSupply.SECPERDAY * 100); ** old version\n', '        _constGradient = 8 * 10**(DECIMALS - 4);\n', '    }\n', '    \n', '    modifier validRecipient(address to)\n', '    {\n', '        require(to != address(0) && to != address(this), "Invalid Recipient");\n', '        _;\n', '    }\n', '    \n', '    modifier onlyOwner \n', '    {\n', '        require(msg.sender == _owner, "Only owner can call this function.");\n', '        _;\n', '    }\n', '\n', '    function supplyMap() external view returns (uint256[2][] memory) \n', '    {\n', '        return _supplyMap;\n', '    }\n', '\n', '    function initialSupply() external pure returns (uint256) \n', '    {\n', '        return INITIAL_TOKEN_SUPPLY;\n', '    }\n', '\n', '    function finalGradient() external view returns (uint) \n', '    {\n', '        return _constGradient;\n', '    }\n', '\n', '    function lastAdjustTime() external view returns (uint) \n', '    {\n', '        return _lastAdjustTime;\n', '    }\n', '\n', '    function lastTotalSupply() external view returns (uint) \n', '    {\n', '        return _lastTotalSupply;\n', '    }\n', '\n', '    function startStaking() \n', '      external \n', '      onlyOwner\n', '    {\n', '        _stakingActive = true;\n', '        _stakingSince = block.timestamp;\n', '        _totalSupply = _supplyMap[0][1];\n', '        _lastTotalSupply = _totalSupply;\n', '        _lastAdjustTime = 0;\n', '        // ** added: new variable _adjustTime\n', '        _adjustTime = 0;\n', '    }\n', '\n', '    function name() external pure returns (string memory) \n', '    {\n', '        return NAME;\n', '    }\n', '\n', '    function symbol() external pure returns (string memory)\n', '    {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function decimals() external pure returns (uint8)\n', '    {\n', '        return uint8(DECIMALS);\n', '    }\n', '\n', '    function stakingActive() external view returns (bool)\n', '    {\n', '        return _stakingActive;\n', '    }\n', '\n', '    function stakingSince() external view returns (uint256)\n', '    {\n', '        return _stakingSince;\n', '    }\n', '\n', '    function stakingFrequence() external pure returns (uint)\n', '    {\n', '        return SavixSupply.MINTIMEWIN;\n', '    }\n', '\n', '    \n', '    function totalSupply() override external view returns (uint256)\n', '    {\n', '        // since we cannot directly decrease total supply without affecting all balances, we\n', '        // track burned tokens and substract them here\n', '        // we also substact burned tokens from the global burn address\n', '        return _totalSupply - _burnAmount.div(TOTAL_FRAGMENTS.div(_totalSupply)) - balanceOf(BURNADDR);\n', '    }\n', '\n', '    // dailyInterest rate is given in percent with 2 decimals => result has to be divede by 10**9 to get correct number with precision 2\n', '    function dailyInterest() external view returns (uint)\n', '    {\n', '            return SavixSupply.getDailyInterest(block.timestamp - _stakingSince, _lastAdjustTime, _totalSupply, _lastTotalSupply); \n', '    }\n', '\n', '    // ** new method\n', '    // yearlyInterest rate is given in percent with 2 decimals => result has to be divede by 10**9 to get correct number with precision 2\n', '    function yearlyInterest() external view returns (uint)\n', '    {\n', '            return SavixSupply.getYearlyInterest(block.timestamp - _stakingSince, _lastAdjustTime, _totalSupply, _lastTotalSupply); \n', '    }\n', '\n', '    function balanceOf(address account) override public view returns (uint256)\n', '    {\n', '        return _balances[account].div(TOTAL_FRAGMENTS.div(_totalSupply));\n', '    }\n', '\n', '    function _calculateFragments(uint256 value) internal returns (uint256)\n', '    {\n', '        if(_stakingActive && (block.timestamp - _stakingSince) - _lastAdjustTime >= SavixSupply.MINTIMEWIN)\n', '        {\n', '            uint256 newSupply = SavixSupply.getAdjustedSupply(_supplyMap, (block.timestamp - _stakingSince), _constGradient);\n', '            if (_totalSupply != newSupply)\n', '            {\n', '              // ** changed: assignment order\n', '              // ** added: new variable _adjustTime\n', '              _lastAdjustTime = _adjustTime;\n', '              _adjustTime = block.timestamp - _stakingSince;\n', '              _lastTotalSupply = _totalSupply;\n', '              _totalSupply = newSupply;\n', '            }\n', '        }\n', '        // return value.mul(TOTAL_FRAGMENTS.div(_totalSupply));  ** old version\n', '        // return TOTAL_FRAGMENTS.mul(value).div(_totalSupply);  ** this would be appropriate in order to multiply before division\n', '        // But => leads to multiplication overflow due to extremly high numbers in which supply fragments are held \n', '        return TOTAL_FRAGMENTS.div(_totalSupply).mul(value);\n', '    }\n', '\n', '    function burn(uint256 value)\n', '      external\n', '      returns (bool)\n', '    {\n', '        uint256 rAmount = _calculateFragments(value);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(rAmount,"burn amount exceeds balance");\n', '        // cannot modify totalsupply directly, otherwise all balances would decrease\n', '        // we keep track of the burn amount and use it in the totalSupply() function to correctly\n', '        // compute the totalsupply\n', '        // also, burned tokens have to be stored as fragments (percentage) of the total supply\n', '        // This means they gets affected by staking: the burned amount will automatically increase accordingly\n', '        _burnAmount += rAmount;\n', '        emit Transfer(msg.sender, address(0), value);\n', '        return true;\n', '    }\n', '\n', '    function getBurnAmount() external view returns (uint256)\n', '    {\n', '        return _burnAmount.div(TOTAL_FRAGMENTS.div(_totalSupply)) + balanceOf(BURNADDR);\n', '    }\n', '\n', '    function transfer(address to, uint256 value) override\n', '        external\n', '        validRecipient(to)\n', '        returns (bool)\n', '    {\n', '        uint256 rAmount = _calculateFragments(value);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(rAmount,"ERC20: transfer amount exceeds balance");\n', '        _balances[to] = _balances[to].add(rAmount);\n', '        emit Transfer(msg.sender, to, value);       \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 value) \n', '        override\n', '        external\n', '        returns (bool)\n', '    {\n', '        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(value,"ERC20: transfer amount exceeds allowance");\n', '        uint256 rAmount = _calculateFragments(value);\n', '\n', '        _balances[sender] = _balances[sender].sub(rAmount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(rAmount);\n', '        emit Transfer(sender, recipient, value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) override external view returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    \n', '    function increaseAllowance(address spender, uint256 addedValue) external returns (bool)\n', '    {\n', '        uint256 newValue = _allowances[msg.sender][spender].add(addedValue);\n', '        _allowances[msg.sender][spender] = 0;\n', '        _approve(msg.sender, spender, newValue);\n', '        return true;\n', '    }\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool)\n', '    {\n', '        uint256 newValue = _allowances[msg.sender][spender].sub(subtractedValue,"ERC20: decreased allowance below zero");\n', '        _allowances[msg.sender][spender] = 0;\n', '        _approve(msg.sender, spender, newValue);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function approve(address spender, uint256 value) override external returns (bool) \n', '    {\n', '        _allowances[msg.sender][spender] = 0;\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 value) internal \n', '    {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        // In order to exclude front-running attacks:\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        // allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        // already 0 to mitigate the race condition described here:\n', '        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((value == 0 || _allowances[owner][spender] == 0), "possible front-running attack");\n', '\n', '        _allowances[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    // use same logic to adjust balances as in function transfer\n', '    // only distribute from owner wallet (ecosystem fund)\n', '    // gas friendly way to do airdrops or giveaways\n', '    function distributeTokens(address[] memory addresses, uint256 value)\n', '        external\n', '        onlyOwner\n', '    {\n', '        uint256 rAmount = _calculateFragments(value);\n', '        _balances[_owner] = _balances[_owner].sub(rAmount * addresses.length,"ERC20: distribution total amount exceeds balance");\n', '        \n', '        uint256 addressesLength = addresses.length;\n', '        for (uint i = 0; i < addressesLength; i++)\n', '        {\n', '            _balances[addresses[i]] = _balances[addresses[i]].add(rAmount);\n', '            emit Transfer(_owner, addresses[i], value);       \n', '        }\n', '    }\n', '\n', '    // use same logic to adjust balances as in function transfer\n', '    // only distribute from owner wallet (ecosystem fund)\n', '    // gas friendly way to do airdrops or giveaways\n', '    function distributeTokensFlexSum(address[] memory addresses, uint256[] memory values)\n', '        external\n', '        onlyOwner\n', '    {\n', '        // there has to be exacly 1 value per address\n', '        require(addresses.length == values.length, "there has to be exacly 1 value per address"); // Overflow check\n', '\n', '        uint256 valuesum = 0;\n', '        uint256 valueLength = values.length;\n', '        for (uint i = 0; i < valueLength; i++)\n', '            valuesum += values[i];\n', '\n', '        _balances[_owner] = _balances[_owner].sub( _calculateFragments(valuesum),"ERC20: distribution total amount exceeds balance");\n', '\n', '        uint256 addressesLength = addresses.length;\n', '        for (uint i = 0; i < addressesLength; i++)\n', '        {\n', '            _balances[addresses[i]] = _balances[addresses[i]].add(_calculateFragments(values[i]));\n', '            emit Transfer(_owner, addresses[i], values[i]);       \n', '        }\n', '    }\n', '    \n', '    function getOwner() \n', '      external\n', '      view \n', '    returns(address)\n', '    {\n', '        return _owner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'import "./SafeMath.sol";\n', '\n', '/**\n', ' * @dev savix interest and supply calculations.\n', ' *\n', '*/\n', ' library SavixSupply {\n', '     \n', '    uint256 public constant MAX_UINT256 = 2**256 - 1;\n', '    uint256 public constant MAX_UINT128 = 2**128 - 1;\n', '    uint public constant MINTIMEWIN = 7200; // 2 hours\n', '    uint public constant SECPERDAY = 3600 * 24;\n', '    uint public constant DECIMALS = 9;\n', '\n', '    struct SupplyWinBoundary \n', '    {\n', '        uint256 x1;\n', '        uint256 x2;\n', '        uint256 y1;\n', '        uint256 y2;\n', '    }\n', '\n', '    function getSupplyWindow(uint256[2][] memory map, uint256 calcTime) internal pure returns (SupplyWinBoundary memory)\n', '    {\n', '        SupplyWinBoundary memory winBound;\n', '        \n', '        winBound.x1 = 0;\n', '        winBound.x2 = 0;\n', '\n', '        winBound.y1 = map[0][1];\n', '        winBound.y2 = 0;\n', '\n', '        for (uint i=0; i < map.length; i++)\n', '        {\n', '            if (map[i][0] == 0) \n', '              continue;\n', '\n', '            if (calcTime < map[i][0])\n', '            {\n', '                winBound.x2 = map[i][0];\n', '                winBound.y2 = map[i][1];\n', '                break;\n', '            }\n', '            else\n', '            {\n', '                winBound.x1 = map[i][0];\n', '                winBound.y1 = map[i][1];\n', '            }\n', '        }\n', '        if (winBound.x2 == 0) winBound.x2 = MAX_UINT128;\n', '        if (winBound.y2 == 0) winBound.y2 = MAX_UINT128;\n', '        return winBound;\n', '    }\n', '\n', '    // function to calculate new Supply with SafeMath for divisions only, shortest (cheapest) form\n', '    function getAdjustedSupply(uint256[2][] memory map, uint256 transactionTime, uint constGradient) internal pure returns (uint256)\n', '    {\n', '        if (transactionTime >= map[map.length-1][0])\n', '        {\n', '            // return (map[map.length-1][1] + constGradient * (SafeMath.sub(transactionTime, map[map.length-1][0])));  ** old version\n', '            return (map[map.length-1][1] + SafeMath.mul(constGradient, SafeMath.sub(transactionTime, map[map.length-1][0])));\n', '        }\n', '        \n', '        SupplyWinBoundary memory winBound = getSupplyWindow(map, transactionTime);\n', '        // return (winBound.y1 + SafeMath.div(winBound.y2 - winBound.y1, winBound.x2 - winBound.x1) * (transactionTime - winBound.x1));  ** old version\n', '        return (winBound.y1 + SafeMath.div(SafeMath.mul(SafeMath.sub(winBound.y2, winBound.y1), SafeMath.sub(transactionTime, winBound.x1)), SafeMath.sub(winBound.x2, winBound.x1)));\n', '    }\n', '\n', '    function getDailyInterest(uint256 currentTime, uint256 lastAdjustTime, uint256 currentSupply, uint256 lastSupply) internal pure returns (uint)\n', '    {\n', '        if (currentTime <= lastAdjustTime)\n', '        {\n', '           return uint128(0);\n', '        }\n', '\n', '        // ** old version                \n', '        // uint256 InterestSinceLastAdjust = SafeMath.div((currentSupply - lastSupply) * 100, lastSupply);\n', '        // return (SafeMath.div(InterestSinceLastAdjust * SECPERDAY, currentTime - lastAdjustTime));\n', '        return (SafeMath.div(SafeMath.sub(currentSupply, lastSupply) * 100 * 10**DECIMALS * SECPERDAY, SafeMath.mul(SafeMath.sub(currentTime, lastAdjustTime), lastSupply)));\n', '    }\n', ' \n', '    // ** new method\n', '    // yearlyInterest rate is given in percent with 2 decimals => result has to be divede by 10**9 to get correct number with precision 2\n', '    function getYearlyInterest(uint256 currentTime, uint256 lastAdjustTime, uint256 currentSupply, uint256 lastSupply) internal pure returns (uint)\n', '    {\n', '        if (currentTime <= lastAdjustTime)\n', '        {\n', '           return uint128(0);\n', '        }\n', '        return (SafeMath.div(SafeMath.sub(currentSupply, lastSupply) * 100 * 10**DECIMALS * SECPERDAY * 360, SafeMath.mul(SafeMath.sub(currentTime, lastAdjustTime), lastSupply)));\n', '    }\n', '}']