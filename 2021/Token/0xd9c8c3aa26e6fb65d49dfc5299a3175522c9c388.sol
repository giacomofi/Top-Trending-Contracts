['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-03\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2017-05-06\n', '*/\n', '\n', 'pragma solidity >=0.4.4;\n', '\n', '// Copyright 2017 Alchemy Limited LLC, Do not distribute\n', '\n', 'contract Constants {\n', '    uint DECIMALS = 8;\n', '}\n', '\n', '\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) throw;\n', '        _;\n', '    }\n', '\n', '    address newOwner;\n', '\n', '    function changeOwner(address _newOwner) onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() {\n', '        if (msg.sender == newOwner) {\n', '            owner = newOwner;\n', '        }\n', '    }\n', '}\n', '\n', '//from Zeppelin\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b) internal returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b) internal returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '    function assert(bool assertion) internal {\n', '        if (!assertion) throw;\n', '    }\n', '}\n', '\n', '\n', '\n', '//Copyright 2017 Alchemy Limited LLC DO not distribute\n', '//ERC20 token\n', '\n', 'contract Token is SafeMath, Owned, Constants {\n', '    uint public currentSupply;\n', '    uint public remainingOwner;\n', '    uint public remainingAuctionable;\n', '    uint public ownerTokensFreeDay;\n', '    bool public launched = false;\n', '\n', '    bool public remaindersSet = false;\n', '    bool public mintingDone = false;\n', '\n', '    address public controller;\n', '\n', '    string public name;\n', '    uint8 public decimals;\n', '    string public symbol;\n', '\n', '    modifier onlyController() {\n', '        if (msg.sender != controller) throw;\n', '        _;\n', '    }\n', '\n', '    modifier isLaunched() {\n', '        assert(launched == true);\n', '        _;\n', '    }\n', '\n', '    modifier onlyPayloadSize(uint numwords) {\n', '        assert(msg.data.length == numwords * 32 + 4);\n', '        _;\n', '    }\n', '\n', '    function Token() {\n', '        owner = msg.sender;\n', '        name = "Monolith RPT";\n', '        decimals = uint8(DECIMALS);\n', '        symbol = "RPT";\n', '    }\n', '\n', '    function Launch() onlyOwner {\n', '        launched = true;\n', '    }\n', '\n', '    function setOwnerFreeDay(uint day) onlyOwner {\n', '        if (ownerTokensFreeDay != 0) throw;\n', '\n', '        ownerTokensFreeDay = day;\n', '    }\n', '\n', '    function totalSupply() constant returns(uint) {\n', '        return currentSupply + remainingOwner;\n', '    }\n', '\n', '    function setRemainders(uint _remainingOwner, uint _remainingAuctionable) onlyOwner {\n', '        if (remaindersSet) { throw; }\n', '\n', '        remainingOwner = _remainingOwner;\n', '        remainingAuctionable = _remainingAuctionable;\n', '    }\n', '\n', '    function finalizeRemainders() onlyOwner {\n', '        remaindersSet = true;\n', '    }\n', '\n', '    function setController(address _controller) onlyOwner {\n', '        controller = _controller;\n', '    }\n', '\n', '    function claimOwnerSupply() onlyOwner {\n', '        if (now < ownerTokensFreeDay) throw;\n', '        if (remainingOwner == 0) throw;\n', '        if (!remaindersSet) throw; // must finalize remainders\n', '\n', '        balanceOf[owner] = safeAdd(balanceOf[owner], remainingOwner);\n', '        remainingOwner = 0;\n', '    }\n', '\n', '    function claimAuctionableTokens(uint amount) onlyController {\n', '        if (amount > remainingAuctionable) throw;\n', '\n', '        balanceOf[controller] = safeAdd(balanceOf[controller], amount);\n', '        currentSupply = safeAdd(currentSupply, amount);\n', '        remainingAuctionable = safeSub(remainingAuctionable,amount);\n', '\n', '        Transfer(0, controller, amount);\n', '    }\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '\n', '    function mint(address addr, uint amount) onlyOwner onlyPayloadSize(2) {\n', '        if (mintingDone) throw;\n', '\n', '        balanceOf[addr] = safeAdd(balanceOf[addr], amount);\n', '\n', '        currentSupply = safeAdd(currentSupply, amount);\n', '\n', '        Transfer(0, addr, amount);\n', '    }\n', '\n', '\n', '    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n', '\n', "    // We don't use safe math in this function\n", '    // because this will be called for the owner before the contract\n', '    // is published and we need to save gas.\n', '    function multiMint(uint[] data) onlyOwner {\n', '        if (mintingDone) throw;\n', '\n', '        uint supplyAdd;\n', '        for (uint i = 0; i < data.length; i++ ) {\n', '            address addr = address( data[i] & (D160-1) );\n', '            uint amount = data[i] / D160;\n', '\n', '            balanceOf[addr] += amount;\n', '            supplyAdd += amount;\n', '            Transfer(0, addr, amount);\n', '        }\n', '        currentSupply += supplyAdd;\n', '    }\n', '\n', '    function completeMinting() onlyOwner {\n', '        mintingDone = true;\n', '    }\n', '\n', '    mapping(address => uint) public balanceOf;\n', '    mapping(address => mapping (address => uint)) public allowance;\n', '\n', '    function transfer(address _to, uint _value) isLaunched notPaused\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        if (balanceOf[msg.sender] < _value) return false;\n', '        if (_to == 0x0) return false;\n', '\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value)  isLaunched notPaused\n', '    onlyPayloadSize(3)\n', '    returns (bool success) {\n', '        if (_to == 0x0) return false;\n', '        if (balanceOf[_from] < _value) return false;\n', '\n', '        var allowed = allowance[_from][msg.sender];\n', '        if (allowed < _value) return false;\n', '\n', '        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n', '        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n', '        allowance[_from][msg.sender] = safeSub(allowed, _value);\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        //require user to set to zero before resetting to nonzero\n', '        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\n', '            return false;\n', '        }\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function increaseApproval (address _spender, uint _addedValue)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        uint oldValue = allowance[msg.sender][_spender];\n', '        allowance[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\n', '        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval (address _spender, uint _subtractedValue)\n', '    onlyPayloadSize(2)\n', '    returns (bool success) {\n', '        uint oldValue = allowance[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '            allowance[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowance[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n', '        }\n', '        Approval(msg.sender, _spender, allowance[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) returns (bool success) {\n', '        if (!approve(_spender, _amount)) throw;\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    //Holds accumulated dividend tokens other than RPT\n', '    TokenHolder public tokenholder;\n', '\n', '    //once locked, can no longer upgrade tokenholder\n', '    bool public lockedTokenHolder;\n', '\n', '    function lockTokenHolder() onlyOwner {\n', '        lockedTokenHolder = true;\n', '    }\n', '\n', '    function setTokenHolder(address _th) onlyOwner {\n', '        if (lockedTokenHolder) throw;\n', '        tokenholder = TokenHolder(_th);\n', '    }\n', '\n', '    function burn(uint _amount) notPaused returns (bool result)  {\n', '        if (_amount > balanceOf[msg.sender]) return false;\n', '\n', '        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _amount);\n', '        currentSupply  = safeSub(currentSupply, _amount);\n', '        result = tokenholder.burn(msg.sender, _amount);\n', '        if (!result) throw;\n', '        Transfer(msg.sender, 0, _amount);\n', '    }\n', '\n', "    // Peterson's Law Protection\n", '    event logTokenTransfer(address token, address to, uint amount);\n', '\n', '    function claimTokens(address _token) onlyOwner {\n', '        if (_token == 0x0) {\n', '            owner.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        Token token = Token(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(owner, balance);\n', '        logTokenTransfer(_token, owner, balance);\n', '    }\n', '\n', '    // Pause mechanism\n', '\n', '    bool public pausingMechanismLocked = false;\n', '    bool public paused = false;\n', '\n', '    modifier notPaused() {\n', '        if (paused) throw;\n', '        _;\n', '    }\n', '\n', '    function pause() onlyOwner {\n', '        if (pausingMechanismLocked) throw;\n', '        paused = true;\n', '    }\n', '\n', '    function unpause() onlyOwner {\n', '        if (pausingMechanismLocked) throw;\n', '        paused = false;\n', '    }\n', '\n', '    function neverPauseAgain() onlyOwner {\n', '        pausingMechanismLocked = true;\n', '    }\n', '}\n', '\n', 'contract TokenHolder {\n', '    function burn(address , uint )\n', '    returns (bool result) {\n', '        return false;\n', '    }\n', '}\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\n', '}']