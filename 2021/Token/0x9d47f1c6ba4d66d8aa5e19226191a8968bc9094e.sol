['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', '\n', 'pragma solidity ^0.8.1;\n', '\n', 'interface ISupplyController {\n', '\tfunction mintIncentive(address addr) external;\n', '\tfunction mintableIncentive(address addr) external view returns (uint);\n', '\tfunction mint(address token, address owner, uint amount) external;\n', '\tfunction changeSupplyController(IADXToken token, address newSupplyController) external;\n', '}\n', '\n', 'interface IADXToken {\n', '\tfunction transfer(address to, uint256 amount) external returns (bool);\n', '\tfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '\tfunction approve(address spender, uint256 amount) external returns (bool);\n', '\tfunction balanceOf(address spender) external view returns (uint);\n', '\tfunction allowance(address owner, address spender) external view returns (uint);\n', '\tfunction totalSupply() external returns (uint);\n', '\tfunction supplyController() external view returns (ISupplyController);\n', '\tfunction changeSupplyController(address newSupplyController) external;\n', '\tfunction mint(address owner, uint amount) external;\n', '}\n', '\n', '\n', 'contract ADXSupplyController {\n', '\tenum GovernanceLevel { None, Mint, All }\n', '\n', '\tuint public constant CAP = 150000000 * 1e18;\n', '\t// This amount was burned on purpose when migrating from Tom pool 2 (Staking with token 0xade) to Tom pool 3 (StakingPool with token 0xade)\n', '\tuint public immutable BURNED_MIN = 35000000 * 1e18;\n', '\tIADXToken public immutable ADX;\n', '\n', '\tmapping (address => uint8) public governance;\n', '\t// Some addresses (eg StakingPools) are incentivized with a certain allowance of ADX per year\n', '\tmapping (address => uint) public incentivePerSecond;\n', '\t// Keep track of when incentive tokens were last minted for a given addr\n', '\tmapping (address => uint) public incentiveLastMint;\n', '\n', '\tconstructor(IADXToken token) {\n', '\t\tgovernance[msg.sender] = uint8(GovernanceLevel.All);\n', '\t\tADX = token;\n', '\t}\n', '\n', '\tfunction changeSupplyController(address newSupplyController) external {\n', '\t\trequire(governance[msg.sender] >= uint8(GovernanceLevel.All), "NOT_GOVERNANCE");\n', '\t\tADX.changeSupplyController(newSupplyController);\n', '\t}\n', '\n', '\tfunction setGovernance(address addr, uint8 level) external {\n', '\t\trequire(governance[msg.sender] >= uint8(GovernanceLevel.All), "NOT_GOVERNANCE");\n', '\t\tgovernance[addr] = level;\n', '\t}\n', '\n', '\tfunction setIncentive(address addr, uint amountPerSecond) external {\n', '\t\trequire(governance[msg.sender] >= uint8(GovernanceLevel.All), "NOT_GOVERNANCE");\n', '\t\t// no more than 1 ADX per second\n', '\t\trequire(amountPerSecond < 1e18, "AMOUNT_TOO_LARGE");\n', '\t\tincentiveLastMint[addr] = block.timestamp;\n', '\t\tincentivePerSecond[addr] = amountPerSecond;\n', '\t\t// AUDIT: pending incentive lost here\n', '\t}\n', '\n', '\tfunction innerMint(IADXToken token, address owner, uint amount) internal {\n', '\t\tuint totalSupplyAfter = token.totalSupply() + amount;\n', '\t\trequire(totalSupplyAfter <= CAP + BURNED_MIN, "MINT_TOO_LARGE");\n', '\t\ttoken.mint(owner, amount);\n', '\t}\n', '\n', '\t// Kept because it"s used for ADXLoyaltyPool\n', '\tfunction mint(IADXToken token, address owner, uint amount) external {\n', '\t\trequire(governance[msg.sender] >= uint8(GovernanceLevel.Mint), "NOT_GOVERNANCE");\n', '\t\tinnerMint(token, owner, amount);\n', '\t}\n', '\n', '\t// Incentive mechanism\n', '\tfunction mintableIncentive(address addr) public view returns (uint) {\n', '\t\treturn (block.timestamp - incentiveLastMint[addr]) * incentivePerSecond[addr];\n', '\t}\n', '\n', '\tfunction mintIncentive(address addr) external {\n', '\t\tuint amount = mintableIncentive(addr);\n', '\t\tincentiveLastMint[addr] = block.timestamp;\n', '\t\tinnerMint(ADX, addr, amount);\n', '\t}\n', '}']