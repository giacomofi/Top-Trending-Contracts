['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-20\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'contract StandardBullERC20 {\n', '    // 合约名称\n', '    string public constant name = "BULL";\n', '    // 代币符号\n', '    string public constant symbol = "BULL";\n', '    // 代币精度\n', '    uint8 public constant decimals = 6;\n', '    // 代币总供应量： 100 million ERC\n', '    uint private _totalSupply = 100000000e6; \n', '    \n', '    // 授权数量 \n', '    mapping (address => mapping (address => uint256)) internal allowances;\n', '    // 账户余额\n', '    mapping (address => uint256) internal balances;\n', '\n', '    address public owner;\n', '    address public burner;\n', '    \n', '    /**\n', '     * 构造一个代币合约实例\n', '     * @param account 使用account作为owner\n', '     */\n', '    constructor(address account) public {\n', '        owner = account;\n', '        balances[owner] = uint256(_totalSupply);\n', '        emit Transfer(address(0), owner, _totalSupply);\n', '    }\n', '\n', '    /**\n', '     * 查询代币总供应量\n', '     * @return 代币总供应量\n', '     */\n', '    function totalSupply() external view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * 查询指定地址的代币数量\n', '     * @param 账户地址\n', '     * @return 代币数量\n', '     */\n', '    function balanceOf(address account) external view returns (uint) {\n', '        return balances[account];\n', '    }\n', '    \n', '    /**\n', '     * 查询账户授权给指定合约的可交易代币数量\n', '     * @param account 指定用户\n', '     * @param spender 指定合约账户\n', '     * @return 授权数量\n', '     */\n', '    function allowance(address account, address spender) external view returns (uint) {\n', '        return allowances[account][spender];\n', '    }\n', '\n', '    /**\n', '     * 授权给合约从自身发送一定数量的交易\n', '     * @param spender 授权目标合约\n', '     * @param amount 交易代币数量\n', '     * @return 交易是否成功\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool) {\n', '        allowances[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * 普通转账\n', '     * @param dst 目标地址\n', '     * @param 转账数量\n', '     * @return 转账是否成功\n', '     */\n', '    function transfer(address dst, uint256 amount) external returns (bool) {\n', '        _transferTokens(msg.sender, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice 调用合约转账，从src到dst，需要先对代币进行授权\n', '     * @param src 源头地址\n', '     * @param dst 目标地址\n', '     * @param 转账数量\n', '     * @return 转账是否成功\n', '     */\n', '    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n', '        address spender = msg.sender;\n', '        uint256 spenderAllowance = allowances[src][spender];\n', '\n', '        if (spender != src && spenderAllowance != uint256(-1)) {\n', '            uint256 newAllowance = sub(spenderAllowance, amount, "StandERC20::transferFrom: transfer amount exceeds spender allowance");\n', '            allowances[src][spender] = newAllowance;\n', '\n', '            emit Approval(src, spender, newAllowance);\n', '        }\n', '\n', '        _transferTokens(src, dst, amount);\n', '        return true;\n', '    }\n', '\n', '    function _transferTokens(address src, address dst, uint256 amount) internal {\n', '        require(src != address(0), "StandERC20::_transferTokens: cannot transfer from the zero address");\n', '        require(dst != address(0), "StandERC20::_transferTokens: cannot transfer to the zero address");\n', '\n', '        balances[src] = sub(balances[src], amount, "StandERC20::_transferTokens: transfer amount exceeds balance");\n', '        balances[dst] = add(balances[dst], amount, "StandERC20::_transferTokens: transfer amount overflows");\n', '        emit Transfer(src, dst, amount);\n', '    }\n', '    \n', '    // 设置销毁人员 \n', '    function setBurner(address newBurner) external returns (bool) {\n', '        require(msg.sender == owner, "StandERC20Expend::setBurner: onlyOwner method called by non-owner");\n', '        burner = newBurner;\n', '        return true;\n', '    }\n', '    \n', '    // 代币销毁 \n', '    function burn(uint256 amount) external returns (bool) {\n', '        require(msg.sender == burner, "StandERC20Expend::burn: onlyBurner methods called by non-burner");\n', '\n', '        balances[burner] = sub(balances[burner], amount, "StandERC20Expend::burn: transfer amount exceeds balance");\n', '        _totalSupply = sub(_totalSupply, amount, "StandERC20Expend::burn: transfer amount exceeds balance");\n', '        emit Burn(burner, amount);\n', '        return true;\n', '    }\n', '\n', '    // 转账事件，供需要监听的合约使用\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    // 授权事件，供需要监听的合约使用\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    // 销毁事件，供需要监听的合约使用\n', '    event Burn(address indexed burner, uint256 value);\n', '\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '}']