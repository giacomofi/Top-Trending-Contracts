['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./ERC20.sol";\n', 'import "./ERC20Capped.sol";\n', "import './SafeMath.sol';\n", '\n', 'contract FairoxMembershipCoin is ERC20Capped {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public last_extracted;\n', '    uint256 extractions = 0;\n', '    address proposedOwner = address(0);\n', '    address private _owner;\n', '\n', '    constructor ()\n', '    ERC20("Fairox Membership Coin", "FOMC")\n', '    ERC20Capped(25000000 * 1 ether)\n', '    {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '        // Set last_extracted to current block and initialize extaction until next year.\n', '        last_extracted = block.timestamp;\n', '        // Mint 80% of total supply for manual distribution/burn\n', '        _mint(msg.sender, (20000000 * 1 ether));\n', '    }\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Burned(address indexed burner, uint256 amount);\n', '    event Minted(address indexed rewarded, uint256 amount);\n', '    event Extracted(address indexed rewarded, uint256 amount);\n', '\n', '    // Burn function is a wrapper around the internal _burn function to remove owned coins.\n', '    function burn(uint256 _amount) public returns (bool) {\n', '        require(_amount > 0, "FOMCERC20: Cannot burn 0 tokens");\n', '        _burn(msg.sender, _amount);\n', '        emit Burned(msg.sender, _amount);\n', '        return true;\n', '    } \n', '\n', '    // Extract function will mint 2% of the total supply for the contract owner.\n', '    // This function can only be accesed every year since the first extract.\n', '    function extract() public onlyOwner {\n', '        require(extractions < 10, "FOMCERC20: There has been already 10 extractions for the supply");\n', '        require(getNextExtractionAvailable() < block.timestamp, "FOMCERC20: Unable to extract on this period");\n', '        uint256 amount = 500000 * 1 ether;\n', '        _mint(msg.sender, amount);\n', '        emit Minted(msg.sender, amount);\n', '        last_extracted = last_extracted.add(365 days);\n', '        extractions = extractions.add(1);\n', '        emit Extracted(msg.sender, amount);\n', '    }\n', '\n', '    function getNextExtractionAvailable() public view returns (uint256) {\n', '        return last_extracted.add(365 days);\n', '    }\n', '\n', '    function proposeOwner(address _proposedOwner) public onlyOwner {\n', '        require(msg.sender != _proposedOwner, "ERROR_CALLER_ALREADY_OWNER");\n', '        proposedOwner = _proposedOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '    require(msg.sender == proposedOwner, "ERROR_NOT_PROPOSED_OWNER");\n', '        emit OwnershipTransferred(_owner, proposedOwner);\n', '        _owner = proposedOwner;\n', '        proposedOwner = address(0);\n', '    }\n', '\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '}']