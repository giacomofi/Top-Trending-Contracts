['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-27\n', '*/\n', '\n', 'pragma solidity 0.6.4;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a <= b ? a : b;\n', '    }\n', '\n', '    function abs(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a < b) {\n', '            return b - a;\n', '        }\n', '        return a - b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'interface IFToken is IERC20 {\n', '    function mint(address user, uint256 amount) external returns (bytes memory);\n', '\n', '    function borrow(address borrower, uint256 borrowAmount)\n', '        external\n', '        returns (bytes memory);\n', '\n', '    function withdraw(\n', '        address payable withdrawer,\n', '        uint256 withdrawTokensIn,\n', '        uint256 withdrawAmountIn\n', '    ) external returns (uint256, bytes memory);\n', '\n', '    function underlying() external view returns (address);\n', '\n', '    function accrueInterest() external;\n', '\n', '    function getAccountState(address account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function MonitorEventCallback(\n', '        address who,\n', '        bytes32 funcName,\n', '        bytes calldata payload\n', '    ) external;\n', '\n', '    function exchangeRateCurrent() external view returns (uint256 exchangeRate);\n', '\n', '    function repay(address borrower, uint256 repayAmount)\n', '        external\n', '        returns (uint256, bytes memory);\n', '\n', '    function borrowBalanceStored(address account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256 exchangeRate);\n', '\n', '    function liquidateBorrow(\n', '        address liquidator,\n', '        address borrower,\n', '        uint256 repayAmount,\n', '        address fTokenCollateral\n', '    ) external returns (bytes memory);\n', '\n', '    function borrowBalanceCurrent(address account) external returns (uint256);\n', '\n', '    function balanceOfUnderlying(address owner) external returns (uint256);\n', '\n', '    function _reduceReserves(uint256 reduceAmount) external;\n', '\n', '    function _addReservesFresh(uint256 addAmount) external;\n', '\n', '    function cancellingOut(address striker)\n', '        external\n', '        returns (bool strikeOk, bytes memory strikeLog);\n', '\n', '    function APR() external view returns (uint256);\n', '\n', '    function APY() external view returns (uint256);\n', '\n', '    function calcBalanceOfUnderlying(address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function borrowSafeRatio() external view returns (uint256);\n', '\n', '    function tokenCash(address token, address account)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getBorrowRate() external view returns (uint256);\n', '\n', '    function addTotalCash(uint256 _addAmount) external;\n', '\n', '    function subTotalCash(uint256 _subAmount) external;\n', '\n', '    function totalCash() external view returns (uint256);\n', '\n', '    function totalReserves() external view returns (uint256);\n', '\n', '    function totalBorrows() external view returns (uint256);\n', '}\n', '\n', 'interface IBankController {\n', '    function getCashPrior(address underlying) external view returns (uint256);\n', '\n', '    function getCashAfter(address underlying, uint256 msgValue)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getFTokeAddress(address underlying)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function transferToUser(\n', '        address token,\n', '        address payable user,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function transferIn(\n', '        address account,\n', '        address underlying,\n', '        uint256 amount\n', '    ) external payable;\n', '\n', '    function borrowCheck(\n', '        address account,\n', '        address underlying,\n', '        address fToken,\n', '        uint256 borrowAmount\n', '    ) external;\n', '\n', '    function repayCheck(address underlying) external;\n', '\n', '    function liquidateBorrowCheck(\n', '        address fTokenBorrowed,\n', '        address fTokenCollateral,\n', '        address borrower,\n', '        address liquidator,\n', '        uint256 repayAmount\n', '    ) external;\n', '\n', '    function liquidateTokens(\n', '        address fTokenBorrowed,\n', '        address fTokenCollateral,\n', '        uint256 actualRepayAmount\n', '    ) external view returns (uint256);\n', '\n', '    function withdrawCheck(\n', '        address fToken,\n', '        address withdrawer,\n', '        uint256 withdrawTokens\n', '    ) external view returns (uint256);\n', '\n', '    function transferCheck(\n', '        address fToken,\n', '        address src,\n', '        address dst,\n', '        uint256 transferTokens\n', '    ) external;\n', '\n', '    function marketsContains(address fToken) external view returns (bool);\n', '\n', '    function seizeCheck(address cTokenCollateral, address cTokenBorrowed)\n', '        external;\n', '\n', '    function mintCheck(\n', '        address underlying,\n', '        address minter,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function addReserves(address underlying, uint256 addAmount)\n', '        external\n', '        payable;\n', '\n', '    function reduceReserves(\n', '        address underlying,\n', '        address payable account,\n', '        uint256 reduceAmount\n', '    ) external;\n', '\n', '    function calcMaxBorrowAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxWithdrawAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxCashOutAmount(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function calcMaxBorrowAmountWithRatio(address user, address token)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function transferEthGasCost() external view returns (uint256);\n', '\n', '    function isFTokenValid(address fToken) external view returns (bool);\n', '\n', '    function balance(address token) external view returns (uint256);\n', '\n', '    function flashloanFeeBips() external view returns (uint256);\n', '\n', '    function flashloanVault() external view returns (address);\n', '\n', '    function transferFlashloanAsset(\n', '        address token,\n', '        address payable user,\n', '        uint256 amount\n', '    ) external;\n', '}\n', '\n', 'enum RewardType {\n', '    DefaultType,\n', '    Deposit,\n', '    Borrow,\n', '    Withdraw,\n', '    Repay,\n', '    Liquidation,\n', '    TokenIn,\n', '    TokenOut\n', '}\n', '\n', 'library EthAddressLib {\n', '    /**\n', '     * @dev returns the address used within the protocol to identify ETH\n', '     * @return the address assigned to ETH\n', '     */\n', '    function ethAddress() internal pure returns (address) {\n', '        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', '\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(\n', '            initializing || isConstructor() || !initialized,\n', '            "Contract instance has already been initialized"\n', '        );\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @title IFlashLoanReceiver interface\n', ' * @notice Interface for the Aave fee IFlashLoanReceiver.\n', ' * @author Aave\n', ' * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n', ' */\n', 'interface IFlashLoanReceiver {\n', '    function executeOperation(\n', '        address token,\n', '        uint256 amount,\n', '        uint256 fee,\n', '        bytes calldata params\n', '    ) external;\n', '}\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract Bank is Initializable {\n', '    using SafeMath for uint256;\n', '\n', '    bool public paused;\n', '\n', '    address public mulSig;\n', '\n', '    //monitor event\n', '    event MonitorEvent(bytes32 indexed funcName, bytes payload);\n', '    event FlashLoan(\n', '        address indexed receiver,\n', '        address indexed token,\n', '        uint256 amount,\n', '        uint256 fee\n', '    );\n', '\n', '    modifier onlyFToken(address fToken) {\n', '        require(\n', '            controller.marketsContains(fToken) ||\n', '                msg.sender == address(controller),\n', '            "only supported ftoken or controller"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function MonitorEventCallback(bytes32 funcName, bytes calldata payload)\n', '        external\n', '        onlyFToken(msg.sender)\n', '    {\n', '        emit MonitorEvent(funcName, payload);\n', '    }\n', '\n', '    IBankController public controller;\n', '\n', '    address public admin;\n', '\n', '    address public proposedAdmin;\n', '    address public pauser;\n', '\n', '    bool private loaning;\n', '    modifier nonSelfLoan() {\n', '        require(!loaning, "re-loaning");\n', '        loaning = true;\n', '        _;\n', '        loaning = false;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin, "OnlyAdmin");\n', '        _;\n', '    }\n', '\n', '    modifier whenUnpaused {\n', '        require(!paused, "System paused");\n', '        _;\n', '    }\n', '\n', '    modifier onlyMulSig {\n', '        require(msg.sender == mulSig, "require mulsig");\n', '        _;\n', '    }\n', '\n', '    modifier onlySelf {\n', '        require(msg.sender == address(this), "require self");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPauser {\n', '        require(msg.sender == pauser, "require pauser");\n', '        _;\n', '    }\n', '\n', '    function initialize(address _controller, address _mulSig)\n', '        public\n', '        initializer\n', '    {\n', '        controller = IBankController(_controller);\n', '        mulSig = _mulSig;\n', '        paused = false;\n', '        admin = msg.sender;\n', '    }\n', '\n', '    function setController(address _controller) public onlyAdmin {\n', '        controller = IBankController(_controller);\n', '    }\n', '\n', '    function setPaused() public onlyPauser {\n', '        paused = true;\n', '    }\n', '\n', '    function setUnpaused() public onlyPauser {\n', '        paused = false;\n', '    }\n', '\n', '    function setPauser(address _pauser) public onlyAdmin {\n', '        pauser = _pauser;\n', '    }\n', '\n', '    function proposeNewAdmin(address admin_) external onlyMulSig {\n', '        proposedAdmin = admin_;\n', '    }\n', '\n', '    function claimAdministration() external {\n', '        require(msg.sender == proposedAdmin, "Not proposed admin.");\n', '        admin = proposedAdmin;\n', '        proposedAdmin = address(0);\n', '    }\n', '\n', '    function deposit(address token, uint256 amount)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '    {\n', '        return this._deposit{value: msg.value}(token, amount, msg.sender);\n', '    }\n', '\n', '    function _deposit(\n', '        address token,\n', '        uint256 amount,\n', '        address account\n', '    ) external payable whenUnpaused onlySelf nonSelfLoan {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        bytes memory flog = fToken.mint(account, amount);\n', '        controller.transferIn{value: msg.value}(account, token, amount);\n', '\n', '        fToken.addTotalCash(amount);\n', '\n', '        emit MonitorEvent("Deposit", flog);\n', '    }\n', '\n', '    function borrow(address underlying, uint256 borrowAmount)\n', '        public\n', '        whenUnpaused\n', '        nonSelfLoan\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        bytes memory flog = fToken.borrow(msg.sender, borrowAmount);\n', '        emit MonitorEvent("Borrow", flog);\n', '    }\n', '\n', '    function withdraw(address underlying, uint256 withdrawTokens)\n', '        public\n', '        whenUnpaused\n', '        nonSelfLoan\n', '        returns (uint256)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 amount, bytes memory flog) =\n', '            fToken.withdraw(msg.sender, withdrawTokens, 0);\n', '        emit MonitorEvent("Withdraw", flog);\n', '        return amount;\n', '    }\n', '\n', '    function withdrawUnderlying(address underlying, uint256 withdrawAmount)\n', '        public\n', '        whenUnpaused\n', '        nonSelfLoan\n', '        returns (uint256)\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(underlying));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 amount, bytes memory flog) =\n', '            fToken.withdraw(msg.sender, 0, withdrawAmount);\n', '        emit MonitorEvent("WithdrawUnderlying", flog);\n', '        return amount;\n', '    }\n', '\n', '    function repay(address token, uint256 repayAmount)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '        returns (uint256)\n', '    {\n', '        return this._repay{value: msg.value}(token, repayAmount, msg.sender);\n', '    }\n', '\n', '    function _repay(\n', '        address token,\n', '        uint256 repayAmount,\n', '        address account\n', '    ) public payable whenUnpaused onlySelf nonSelfLoan returns (uint256) {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        (uint256 actualRepayAmount, bytes memory flog) =\n', '            fToken.repay(account, repayAmount);\n', '        controller.transferIn{value: msg.value}(\n', '            account,\n', '            token,\n', '            actualRepayAmount\n', '        );\n', '\n', '        fToken.addTotalCash(actualRepayAmount);\n', '\n', '        emit MonitorEvent("Repay", flog);\n', '        return actualRepayAmount;\n', '    }\n', '\n', '    function liquidateBorrow(\n', '        address borrower,\n', '        address underlyingBorrow,\n', '        address underlyingCollateral,\n', '        uint256 repayAmount\n', '    ) public payable whenUnpaused nonSelfLoan {\n', '        require(msg.sender != borrower, "Liquidator cannot be borrower");\n', '        require(repayAmount > 0, "Liquidate amount not valid");\n', '\n', '        IFToken fTokenBorrow =\n', '            IFToken(controller.getFTokeAddress(underlyingBorrow));\n', '        IFToken fTokenCollateral =\n', '            IFToken(controller.getFTokeAddress(underlyingCollateral));\n', '        bytes memory flog =\n', '            fTokenBorrow.liquidateBorrow(\n', '                msg.sender,\n', '                borrower,\n', '                repayAmount,\n', '                address(fTokenCollateral)\n', '            );\n', '        controller.transferIn{value: msg.value}(\n', '            msg.sender,\n', '            underlyingBorrow,\n', '            repayAmount\n', '        );\n', '\n', '        fTokenBorrow.addTotalCash(repayAmount);\n', '\n', '        emit MonitorEvent("LiquidateBorrow", flog);\n', '    }\n', '\n', '    function tokenIn(address token, uint256 amountIn)\n', '        public\n', '        payable\n', '        whenUnpaused\n', '    {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        cancellingOut(token);\n', '        uint256 curBorrowBalance = fToken.borrowBalanceCurrent(msg.sender);\n', '        uint256 actualRepayAmount;\n', '\n', '        if (amountIn == uint256(-1)) {\n', '            require(curBorrowBalance > 0, "no debt to repay");\n', '            if (token != EthAddressLib.ethAddress()) {\n', '                require(\n', '                    msg.value == 0,\n', '                    "msg.value should be 0 for ERC20 repay"\n', '                );\n', '                actualRepayAmount = this._repay{value: 0}(\n', '                    token,\n', '                    amountIn,\n', '                    msg.sender\n', '                );\n', '            } else {\n', '                require(\n', '                    msg.value >= curBorrowBalance,\n', '                    "msg.value need great or equal than current debt"\n', '                );\n', '                actualRepayAmount = this._repay{value: curBorrowBalance}(\n', '                    token,\n', '                    amountIn,\n', '                    msg.sender\n', '                );\n', '                if (msg.value > actualRepayAmount) {\n', '                    (bool result, ) =\n', '                        msg.sender.call{\n', '                            value: msg.value.sub(actualRepayAmount),\n', '                            gas: controller.transferEthGasCost()\n', '                        }("");\n', '                    require(result, "Transfer of exceed ETH failed");\n', '                }\n', '            }\n', '\n', '            emit MonitorEvent("TokenIn", abi.encode(token, actualRepayAmount));\n', '        } else {\n', '            if (curBorrowBalance > 0) {\n', '                uint256 repayEthValue =\n', '                    SafeMath.min(curBorrowBalance, amountIn);\n', '                if (token != EthAddressLib.ethAddress()) {\n', '                    repayEthValue = 0;\n', '                }\n', '                actualRepayAmount = this._repay{value: repayEthValue}(\n', '                    token,\n', '                    SafeMath.min(curBorrowBalance, amountIn),\n', '                    msg.sender\n', '                );\n', '            }\n', '\n', '            if (actualRepayAmount < amountIn) {\n', '                uint256 exceedAmout = SafeMath.sub(amountIn, actualRepayAmount);\n', '                if (token != EthAddressLib.ethAddress()) {\n', '                    exceedAmout = 0;\n', '                }\n', '                this._deposit{value: exceedAmout}(\n', '                    token,\n', '                    SafeMath.sub(amountIn, actualRepayAmount),\n', '                    msg.sender\n', '                );\n', '            }\n', '\n', '            emit MonitorEvent("TokenIn", abi.encode(token, amountIn));\n', '        }\n', '    }\n', '\n', '    function tokenOut(address token, uint256 amountOut) external whenUnpaused {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        require(\n', '            controller.marketsContains(address(fToken)),\n', '            "unsupported token"\n', '        );\n', '\n', '        cancellingOut(token);\n', '\n', '        uint256 supplyAmount = 0;\n', '        if (amountOut == uint256(-1)) {\n', '            uint256 fBalance = fToken.balanceOf(msg.sender);\n', '            require(fBalance > 0, "no asset to withdraw");\n', '            supplyAmount = withdraw(token, fBalance);\n', '\n', '            emit MonitorEvent("TokenOut", abi.encode(token, supplyAmount));\n', '        } else {\n', '            uint256 userSupplyBalance =\n', '                fToken.calcBalanceOfUnderlying(msg.sender);\n', '            if (userSupplyBalance > 0) {\n', '                if (userSupplyBalance < amountOut) {\n', '                    supplyAmount = withdraw(\n', '                        token,\n', '                        fToken.balanceOf(msg.sender)\n', '                    );\n', '                } else {\n', '                    supplyAmount = withdrawUnderlying(token, amountOut);\n', '                }\n', '            }\n', '\n', '            if (supplyAmount < amountOut) {\n', '                borrow(token, amountOut.sub(supplyAmount));\n', '            }\n', '\n', '            emit MonitorEvent("TokenOut", abi.encode(token, amountOut));\n', '        }\n', '    }\n', '\n', '    function cancellingOut(address token) public whenUnpaused nonSelfLoan {\n', '        IFToken fToken = IFToken(controller.getFTokeAddress(token));\n', '        (bool strikeOk, bytes memory strikeLog) =\n', '            fToken.cancellingOut(msg.sender);\n', '        if (strikeOk) {\n', '            emit MonitorEvent("CancellingOut", strikeLog);\n', '        }\n', '    }\n', '\n', '    function flashloan(\n', '        address receiver,\n', '        address token,\n', '        uint256 amount,\n', '        bytes memory params\n', '    ) public whenUnpaused nonSelfLoan {\n', '        uint256 balanceBefore = controller.balance(token);\n', '        require(\n', '            amount > 0 && amount <= balanceBefore,\n', '            "insufficient flashloan liquidity"\n', '        );\n', '\n', '        uint256 fee = amount.mul(controller.flashloanFeeBips()).div(10000);\n', '        address payable _receiver = address(uint160(receiver));\n', '\n', '        controller.transferFlashloanAsset(token, _receiver, amount);\n', '        IFlashLoanReceiver(_receiver).executeOperation(\n', '            token,\n', '            amount,\n', '            fee,\n', '            params\n', '        );\n', '\n', '        uint256 balanceAfter = controller.balance(token);\n', '        require(\n', '            balanceAfter >= balanceBefore.add(fee),\n', '            "invalid flashloan payback amount"\n', '        );\n', '\n', '        address payable vault = address(uint160(controller.flashloanVault()));\n', '        controller.transferFlashloanAsset(token, vault, fee);\n', '\n', '        emit FlashLoan(receiver, token, amount, fee);\n', '    }\n', '}']