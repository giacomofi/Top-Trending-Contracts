['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-19\n', '*/\n', '\n', '// SPDX-License-Identifier: Unlicensed\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'library SafeMath { // Only relevant functions\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      assert(b <= a);\n', '      return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256)   {\n', '      uint256 c = a + b;\n', '      assert(c >= a);\n', '      return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '      }\n', '     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '         if (a == 0) {\n', '          return 0;\n', '        }\n', '        uint256 c = a / b;\n', '        return c;\n', '      }\n', '}\n', '\n', 'contract doco\n', '{\n', '    using SafeMath for uint256;\n', '    string  public name ;\n', '    string public symbol;\n', '    uint public decimals;\n', '    uint256 public initialSupply;\n', '    uint256 public totalSupply;\n', '    uint256 public burnStopSupply;\n', '    string public burnPercentage;\n', '    uint256 public burnedTillDate;\n', '    address payable creator;\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '   \n', '    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n', '    event Transfer(address indexed from, address indexed to,uint256 tokens);\n', '    event Received(address, uint256);\n', '\n', '    constructor( ) payable{\n', '        creator = payable(msg.sender);\n', '        name = "DOCO TOKEN";   \n', '        symbol = "DOCO"; \n', '        initialSupply = 100000000 *10**18;   // Value is 100000000\n', '        totalSupply = 100000000 *10**18;   // Value is 100000000\n', '        burnStopSupply = 90000000 *10**18;   // Value is 20000000\n', '        burnPercentage = "0.001%";  \n', '        decimals = 18;\n', '        burnedTillDate=0;\n', '        balances[msg.sender] = totalSupply;\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '    \n', '    function balanceOf(address tokenOwner) public view returns (uint256) {\n', '        return balances[tokenOwner];\n', '    }\n', '    \n', '    function findBurnTokens(uint256 numTokens) public view returns (uint256)  {\n', '        uint256 burntokens_ =0;\n', '        if (totalSupply > burnStopSupply)\n', '        {\n', '            burntokens_= numTokens.mul(1000000000).div(1000000000000);\n', '        }\n', '        return burntokens_;\n', '  }\n', '    \n', '    function transfer(address receiver,uint256 numTokens) public returns (bool) {\n', '        require(numTokens <= balances[msg.sender]);\n', '        uint256 burntokens_ = findBurnTokens(numTokens);\n', '        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n', '        balances[receiver] = balances[receiver].add(numTokens);\n', '        balances[creator] = balances[creator].sub(burntokens_);\n', '        totalSupply = totalSupply.sub(burntokens_);\n', '        burnedTillDate = burnedTillDate.add(burntokens_);\n', '        emit Transfer(msg.sender, receiver, numTokens);\n', '        return true;\n', '    }\n', '    \n', '    function approve(address delegate,uint256 numTokens) public returns (bool) {\n', '        allowed[msg.sender][delegate] = numTokens;\n', '        emit Approval(msg.sender, delegate, numTokens);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address owner,address delegate) public view returns (uint) {\n', '        return allowed[owner][delegate];\n', '    }\n', '    \n', '    function transferFrom(address owner, address buyer, uint256 numTokens) public returns (bool) {\n', '      \n', '        require(numTokens <= allowed[owner][msg.sender]);\n', '        \n', '        uint256 burntokens_ = findBurnTokens(numTokens);\n', '        totalSupply = totalSupply.sub(burntokens_);\n', '        burnedTillDate = burnedTillDate.add(burntokens_);\n', '        balances[creator] = balances[creator].sub(burntokens_);\n', '        \n', '        balances[owner] = balances[owner].sub(numTokens);\n', '       allowed[owner][msg.sender]= allowed[owner][msg.sender].sub(numTokens);\n', '        balances[buyer] = balances[buyer].add(numTokens);\n', '        emit Transfer(owner, buyer, numTokens);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    receive() external payable \n', '    {\n', '         creator.transfer(msg.value);\n', '    }\n', '    \n', '    fallback() external payable {\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '}']