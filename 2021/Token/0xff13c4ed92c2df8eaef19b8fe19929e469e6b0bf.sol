['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-04\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title yV1\n', ' * @dev yearn v1 vault\n', ' */\n', 'interface yV1 {\n', '    function deposit(uint256 _amount) external;\n', '    function withdraw(uint256 _shares) external;\n', '}\n', '\n', '/**\n', ' * @title yS1\n', ' * @dev yearn v1 strategy\n', ' */\n', 'interface yS1 {\n', '    function setStrategist(address _strategist) external;\n', '    function setKeeper(address _keeper) external;\n', '}\n', '\n', '/**\n', ' * @title yV2\n', ' * @dev yearn v2 vault\n', ' */\n', 'interface yV2 {\n', '    function deposit() external;\n', '    function deposit(uint256 _amount) external;\n', '    function withdraw() external;\n', '    function withdraw(uint256 _shares) external;\n', '}\n', '\n', '/**\n', ' * @title yS2\n', ' * @dev yearn v2 strategy\n', ' */\n', 'interface yS2 {\n', '    function setRewards(address _rewards) external;\n', '}\n', '\n', '/**\n', ' * @title 1SplitAudit\n', ' * @dev 1split on-chain aggregator\n', ' */\n', 'interface One {\n', '    /**\n', '     * @notice Calculate expected returning amount of `destToken`\n', '     * @param fromToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param destToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param amount (uint256) Amount for `fromToken`\n', '     * @param parts (uint256) Number of pieces source volume could be splitted,\n', '     * works like granularity, higly affects gas usage. Should be called offchain,\n', '     * but could be called onchain if user swaps not his own funds, but this is still considered as not safe.\n', '     * @param flags (uint256) Flags for enabling and disabling some features, default 0\n', '     */\n', '    function getExpectedReturn(\n', '        IERC20 fromToken,\n', '        IERC20 destToken,\n', '        uint256 amount,\n', '        uint256 parts,\n', '        uint256 flags // See contants in IOneSplit.sol\n', '    )\n', '        external\n', '        view\n', '        returns(\n', '            uint256 returnAmount,\n', '            uint256[] memory distribution\n', '        );\n', '\n', '    /**\n', '     * @notice Calculate expected returning amount of `destToken`\n', '     * @param fromToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param destToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param amount (uint256) Amount for `fromToken`\n', '     * @param parts (uint256) Number of pieces source volume could be splitted,\n', '     * works like granularity, higly affects gas usage. Should be called offchain,\n', '     * but could be called onchain if user swaps not his own funds, but this is still considered as not safe.\n', '     * @param flags (uint256) Flags for enabling and disabling some features, default 0\n', '     * @param destTokenEthPriceTimesGasPrice (uint256) destToken price to ETH multiplied by gas price\n', '     */\n', '    function getExpectedReturnWithGas(\n', '        IERC20 fromToken,\n', '        IERC20 destToken,\n', '        uint256 amount,\n', '        uint256 parts,\n', '        uint256 flags, // See constants in IOneSplit.sol\n', '        uint256 destTokenEthPriceTimesGasPrice\n', '    )\n', '        external\n', '        view\n', '        returns(\n', '            uint256 returnAmount,\n', '            uint256 estimateGasAmount,\n', '            uint256[] memory distribution\n', '        );\n', '\n', '    /**\n', '     * @notice Swap `amount` of `fromToken` to `destToken`\n', '     * @param fromToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param destToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param amount (uint256) Amount for `fromToken`\n', '     * @param minReturn (uint256) Minimum expected return, else revert\n', '     * @param distribution (uint256[]) Array of weights for volume distribution returned by `getExpectedReturn`\n', '     * @param flags (uint256) Flags for enabling and disabling some features, default 0\n', '     */\n', '    function swap(\n', '        IERC20 fromToken,\n', '        IERC20 destToken,\n', '        uint256 amount,\n', '        uint256 minReturn,\n', '        uint256[] memory distribution,\n', '        uint256 flags // See contants in IOneSplit.sol\n', '    ) external payable returns(uint256);\n', '\n', '    /**\n', '     * @notice Swap `amount` of `fromToken` to `destToken`\n', '     * @param fromToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param destToken (IERC20) Address of token or `address(0)` for Ether\n', '     * @param amount (uint256) Amount for `fromToken`\n', '     * @param minReturn (uint256) Minimum expected return, else revert\n', '     * @param distribution (uint256[]) Array of weights for volume distribution returned by `getExpectedReturn`\n', '     * @param flags (uint256) Flags for enabling and disabling some features, default 0\n', '     * @param referral (address) Address of referral\n', '     * @param feePercent (uint256) Fees percents normalized to 1e18, limited to 0.03e18 (3%)\n', '     */\n', '    function swapWithReferral(\n', '        IERC20 fromToken,\n', '        IERC20 destToken,\n', '        uint256 amount,\n', '        uint256 minReturn,\n', '        uint256[] calldata distribution,\n', '        uint256 flags, // See contants in IOneSplit.sol\n', '        address referral,\n', '        uint256 feePercent\n', '    ) external payable returns(uint256);\n', '}\n', '\n', 'contract Toolkit {\n', '\n', '    address public oneProto = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n', '\n', '    constructor() public {}\n', '\n', '    function setStrategists(address[] calldata _targets, address _strategist) public {\n', '        for(uint256 i = 0; i < _targets.length; ++i) {\n', '            yS1(_targets[i]).setStrategist(_strategist);\n', '        }\n', '    }\n', '\n', '    function setKeepers(address[] calldata _targets, address _keeper) public {\n', '        for(uint256 i = 0; i < _targets.length; ++i) {\n', '            yS1(_targets[i]).setKeeper(_keeper);\n', '        }\n', '    }\n', '\n', '    function setRewards(address[] calldata _targets, address _rewards) public {\n', '        for(uint256 i = 0; i < _targets.length; ++i) {\n', '            yS2(_targets[i]).setRewards(_rewards);\n', '        }\n', '    }\n', '\n', '    function approves(\n', '        address[] calldata _tokens, \n', '        address[] calldata _spenders, \n', '        uint256[] calldata _amounts\n', '    ) public returns (bool) {\n', '        for(uint256 i = 0; i < _tokens.length; ++i) {\n', '            IERC20 token = IERC20(_tokens[i]);\n', '            token.approve(_spenders[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function approvesMAX(\n', '        address[] calldata _tokens, \n', '        address[] calldata _spenders\n', '    ) public returns (bool) {\n', '        for(uint256 i = 0; i < _tokens.length; ++i) {\n', '            IERC20 token = IERC20(_tokens[i]);\n', '            token.approve(_spenders[i], uint256(-1));\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transfers(\n', '        address[] calldata _tokens, \n', '        address[] calldata _recipients, \n', '        uint256[] calldata _amounts\n', '    ) public returns (bool) {\n', '        for(uint256 i = 0; i < _tokens.length; ++i) {\n', '            IERC20 token = IERC20(_tokens[i]);\n', '            token.transfer(_recipients[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferFroms(\n', '        address[] calldata _tokens, \n', '        address[] calldata _senders, \n', '        address[] calldata _recipients, \n', '        uint256[] calldata _amounts\n', '    ) external returns (bool) {\n', '        for(uint256 i = 0; i < _tokens.length; ++i) {\n', '            IERC20 token = IERC20(_tokens[i]);\n', '            token.transferFrom(_senders[i], _recipients[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function batchTransfers(\n', '        address _token, \n', '        address[] calldata _recipients, \n', '        uint256[] calldata _amounts\n', '    ) public returns (bool) {\n', '        IERC20 token = IERC20(_token);\n', '        for(uint256 i = 0; i < _recipients.length; ++i) {\n', '            token.transfer(_recipients[i], _amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function deposit(address _to, uint256 _amount) external {\n', '        yV1(_to).deposit(_amount);\n', '    }\n', '\n', '    function deposits(address[] calldata _tos, uint256[] calldata _amounts) external {\n', '        for(uint256 i = 0; i < _tos.length; ++i) {\n', '            yV1(_tos[i]).deposit(_amounts[i]);\n', '        }\n', '    }\n', '\n', '    function withdraw(address _to, uint256 _share) external {\n', '        yV1(_to).withdraw(_share);\n', '    }\n', '\n', '    function withdraws(address[] calldata _tos, uint256[] calldata _shares) external {\n', '        for(uint256 i = 0; i < _tos.length; ++i) {\n', '            yV1(_tos[i]).withdraw(_shares[i]);\n', '        }\n', '    }\n', '\n', '    function swap(\n', '        address _from, \n', '        address _to, \n', '        uint256 _fromAmount, \n', '        uint256 _minReturn, \n', '        uint256[] calldata distribution, \n', '        uint256 _flags\n', '    ) public payable {\n', '        if (_from == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n', '            require(_fromAmount == msg.value, "swap::eth value not match");\n', '        }\n', '        else {\n', '            IERC20(_from).approve(oneProto, uint256(-1));\n', '        }\n', '        One(oneProto).swap(IERC20(_from), IERC20(_to), _fromAmount, _minReturn, distribution, _flags);\n', '    }\n', '\n', '    function seizes(address[] calldata _tokens) public returns (bool) {\n', '        for(uint256 i = 0; i < _tokens.length; ++i) {\n', '            IERC20 token = IERC20(_tokens[i]);\n', '            token.transfer(msg.sender, token.balanceOf(address(this)));\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function sweep() public returns (bool success) {\n', '        address sender = address(uint160(msg.sender));\n', '        uint256 _balance = address(this).balance;\n', '        (success, ) = sender.call{value: _balance}("");\n', '    }\n', '}']