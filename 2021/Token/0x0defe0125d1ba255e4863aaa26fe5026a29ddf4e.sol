['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address addr) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '}\n', '\n', 'contract BalancesAndAllowancesHelper {\n', '    \n', '    uint256 private constant infinityAllowance = 1 << 248;\n', '    \n', '    function getBalances(IERC20[] calldata tokens, address wallet) external view returns (uint256[] memory indexAndBalance) {\n', '        uint counter = 0;\n', '        uint256[] memory tmp = new uint256[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            try tokens[i].balanceOf(wallet) returns (uint256 balance) {\n', '                if (balance == 0) {\n', '                continue;\n', '            }\n', '            \n', '            tmp[counter] = i << 248 | balance;\n', '            counter++;\n', '            } catch {\n', '                \n', '            }\n', '        }\n', '        \n', '        indexAndBalance = new uint256[](counter);\n', '        for (uint i = 0; i < counter; i++) {\n', '            indexAndBalance[i] = tmp[i];\n', '        }\n', '    }\n', '    \n', '    function getAllowances(IERC20[] calldata tokens, address owner, address spender) external view returns (uint256[] memory indexAndAllowance) {\n', '        uint counter = 0;\n', '        uint256[] memory tmp = new uint256[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            try tokens[i].allowance(owner, spender) returns (uint256 allowance) {\n', '                if (allowance == 0) {\n', '                    continue;\n', '                }\n', '            \n', '                if (allowance > infinityAllowance) {\n', '                    tmp[counter] = (i << 248) | (1 << 247);        \n', '                } else {\n', '                    tmp[counter] = (i << 248) | allowance;       \n', '                }\n', '                counter++;\n', '            } catch {\n', '                \n', '            }\n', '        }\n', '        \n', '        indexAndAllowance = new uint256[](counter);\n', '        for (uint i = 0; i < counter; i++) {\n', '            indexAndAllowance[i] = tmp[i];\n', '        }\n', '    }\n', '}']