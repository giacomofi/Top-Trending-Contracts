['// SPDX-License-Identifier: MIT\n', '\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./Context.sol";\n', 'import "./ERC20CappedUnburnable.sol";\n', 'import "./ERC20Unburnable.sol";\n', 'import "./ERC20PausableUnburnable.sol";\n', '\n', 'contract LBCToken is Context, ERC20CappedUnburnable {\n', '\n', '    /*\n', '    ** Global State\n', '    */\n', '    bool public initialized; // default : false\n', '\n', '    /*\n', '    ** Addresses\n', '    */\n', '    address public _deployingAddress; // should be changed to multisig contract address\n', "    address public _pauserAddress; // should be deployer's\n", "    address public _minterAddress; // should be ico's address then poe's\n", '    address public _reserveAddress; // should be multisig then humble reserve\n', '\n', '    /*\n', '    ** Events\n', '    */\n', '    event InitializedContract(address indexed reserveAddress);\n', '    event ChangedMinterAddress(address indexed minterAddress, address indexed changerAddress);\n', '    event ChangedPauserAddress(address indexed pauserAddress, address indexed changerAddress);\n', '    event ChangedReserveAddress(address indexed reserveAddress, address indexed changerAddress);\n', '    event ChangedDeployerAddress(address indexed deployerAddress, address indexed changerAddress);\n', '\n', '\n', '    constructor(\n', '        string memory name,\n', '        string memory symbol\n', '    )\n', '    ERC20Unburnable(name, symbol)\n', '    ERC20CappedUnburnable(300000000000000000000000000)\n', '    {\n', '        _deployingAddress = msg.sender;\n', '    }\n', '\n', '    /*\n', '    ** Initializes the contract address and affects addresses to their roles.\n', '    */\n', '    function init(\n', '        address minterAddress,\n', '        address pauserAddress,\n', '        address reserveAddress\n', '    )\n', '    public\n', '    isNotInitialized\n', '    onlyDeployingAddress\n', '    {\n', '        require(minterAddress != address(0), "_minterAddress cannot be 0x");\n', '        require(pauserAddress != address(0), "_pauserAddress cannot be 0x");\n', '        require(reserveAddress != address(0), "_reserveAddress cannot be 0x");\n', '\n', '        _minterAddress = minterAddress;\n', '        _pauserAddress = pauserAddress;\n', '        _reserveAddress = reserveAddress;\n', '\n', '        initialized = true;\n', '\n', '        emit InitializedContract(reserveAddress);\n', '    }\n', '\n', '    /*\n', '    ** Mint function that can only be called by minter address and mints a specified amount and sends it to an address\n', '    */\n', '    function mint(address to, uint256 amount)\n', '    public\n', '    onlyMinterAddress\n', '    virtual\n', '    returns (bool) {\n', '       _mint(to, amount);\n', '       return true;\n', '    }\n', '\n', '    /*\n', '    ** Freeze function that stops transactions and can only be called by pauser address\n', '    */\n', '    function pause()\n', '    public\n', '    onlyPauserAddress\n', '    virtual {\n', '        _pause();\n', '    }\n', '\n', '    /*\n', '    ** Unfreeze function that resumes transactions and can only be called by pauser address\n', '    */\n', '    function unpause()\n', '    public\n', '    onlyPauserAddress\n', '    virtual {\n', '        _unpause();\n', '    }\n', '\n', '    /*\n', '    ** Changes the address with pause role and can only be called by previous pauser address\n', '    */\n', '    function changePauser(address newPauserAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    whenNotPaused\n', '    {\n', '        _pauserAddress = newPauserAddress;\n', '        emit ChangedPauserAddress(newPauserAddress, _msgSender());\n', '    }\n', '\n', '    /*\n', '    ** Changes the address with minter role and can only be called by previous minter address\n', '    */\n', '    function changeMinter(address newMinterAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    whenNotPaused\n', '    {\n', '        _minterAddress = newMinterAddress;\n', '        emit ChangedMinterAddress(newMinterAddress, _msgSender());\n', '    }\n', '\n', '    /*\n', '    ** Changes the address with deployer role and can only be called by deployer\n', '    */\n', '    function changeDeployer(address newDeployerAddress)\n', '    public\n', '    onlyDeployingAddress\n', '    {\n', '        _deployingAddress = newDeployerAddress;\n', '        emit ChangedDeployerAddress(_deployingAddress, _msgSender());\n', '    }\n', '\n', '    /*\n', '    ** Checks if the sender is the minter controller address\n', '    */\n', '    modifier onlyDeployingAddress() {\n', '        require(msg.sender == _deployingAddress, "Only the deploying address can call this method.");\n', '        _;\n', '    }\n', '\n', '    /*\n', '    ** Checks if the sender is the minter controller address\n', '    */\n', '    modifier onlyMinterAddress() {\n', '        require(msg.sender == _minterAddress, "Only the minter address can call this method.");\n', '        _;\n', '    }\n', '\n', '    /*\n', '    ** Checks if the sender is the pauser controller address\n', '    */\n', '    modifier onlyPauserAddress() {\n', '        require(msg.sender == _pauserAddress, "Only the pauser address can call this method.");\n', '        _;\n', '    }\n', '\n', '    /*\n', "    ** Checks if the contract hasn't already been initialized\n", '    */\n', '    modifier isNotInitialized() {\n', '        require(initialized == false, "Contract is already initialized.");\n', '        _;\n', '    }\n', '\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20CappedUnburnable) {\n', '        super._beforeTokenTransfer(from, to, amount);\n', '    }\n', '}']