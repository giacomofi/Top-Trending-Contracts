['// SPDX-License-Identifier: MIT\n', 'pragma solidity =0.7.5;\n', '\n', '// VokenTB (TeraByte) EarlyBird-Sale\n', '//\n', '// More info:\n', '//   https://voken.io\n', '//\n', '// Contact us:\n', '//   [email\xa0protected]\n', '\n', '\n', 'import "LibSafeMath.sol";\n', 'import "LibIERC20.sol";\n', 'import "LibIVesting.sol";\n', 'import "LibIVokenTB.sol";\n', 'import "LibAuthPause.sol";\n', 'import "EbWithVestingPermille.sol";\n', '\n', '\n', 'interface IUniswapV2Router02 {\n', '    function WETH() external pure returns (address);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '}\n', '\n', '\n', '/**\n', ' * @dev EarlyBird-Sale v2\n', ' */\n', 'contract EarlyBirdSaleV2 is AuthPause, IVesting, WithVestingPermille {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private immutable VOKEN_ISSUE_MAX = 21_000_000e9;  // 21 million for early-birds\n', '    uint256 private immutable VOKEN_ISSUE_MID = 10_500_000e9;\n', '    uint256 private immutable WEI_PAYMENT_MAX = 5.0 ether;\n', '    uint256 private immutable WEI_PAYMENT_MID = 3.0 ether;\n', '    uint256 private immutable WEI_PAYMENT_MIN = 0.1 ether;\n', '    uint256 private immutable USD_PRICE_START = 0.5e6;  // $ 0.5 USD\n', '    uint256 private immutable USD_PRICE_DISTA = 0.4e6;  // $ 0.4 USD = 0.9 - 0.5\n', '    uint256 private _vokenIssued;\n', '    uint256 private _vokenRandom;\n', '\n', '    IUniswapV2Router02 private immutable UniswapV2Router02 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    IVokenTB private immutable VOKEN_TB = IVokenTB(0x1234567a022acaa848E7D6bC351d075dBfa76Dd4);\n', '    IERC20 private immutable DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n', '\n', '    struct Account {\n', '        uint256 issued;\n', '        uint256 bonuses;\n', '        uint256 referred;\n', '        uint256 rewards;\n', '    }\n', '\n', '    mapping (address => Account) private _accounts;\n', '\n', '    event Payment(address indexed account, uint256 daiAmount, uint256 issued, uint256 random);\n', '    event Reward(address indexed account, address indexed referrer, uint256 amount);\n', '    \n', '\n', '    constructor () {\n', '        _vokenIssued = 346029681993722;\n', '        _vokenRandom = 19229107282040;\n', '    }\n', '\n', '    receive()\n', '        external\n', '        payable\n', '    {\n', '        _swap();\n', '    }\n', '\n', '    function swap()\n', '        external\n', '        payable\n', '    {\n', '        _swap();\n', '    }\n', '\n', '    function data(address account)\n', '        public\n', '        view\n', '        returns (\n', '            uint256 weiMin,\n', '            uint256 weiMax,\n', '\n', '            uint256 vokenPrice,\n', '            uint256 totalIssued,\n', '            uint256 totalRandom,\n', '\n', '            bool agent,\n', '            uint256 issued,\n', '            uint256 bonuses,\n', '            uint256 referred,\n', '            uint256 rewards,\n', '            \n', '            uint256 vesting\n', '        )\n', '    {\n', '        weiMin = WEI_PAYMENT_MIN;\n', '        weiMax = _vokenIssued < VOKEN_ISSUE_MID ? WEI_PAYMENT_MAX : WEI_PAYMENT_MID;\n', '        \n', '        vokenPrice = vokenUSDPrice();\n', '        totalIssued = _vokenIssued;\n', '        totalRandom = _vokenRandom;\n', '        \n', '        agent = isAgent(account);\n', '        issued = _accounts[account].issued;\n', '        bonuses = _accounts[account].bonuses;\n', '        referred = _accounts[account].referred;\n', '        rewards = _accounts[account].rewards;\n', '        \n', '        vesting = vestingOf(account);\n', '    }\n', '\n', '    function vestingOf(address account)\n', '        public\n', '        override\n', '        view\n', '        returns (uint256 vesting)\n', '    {\n', '        vesting = vesting.add(_getVestingAmountForIssued(_accounts[account].issued));\n', '        vesting = vesting.add(_getVestingAmountForBonuses(_accounts[account].bonuses));\n', '        vesting = vesting.add(_getVestingAmountForRewards(_accounts[account].rewards));\n', '    }\n', '\n', '    function vokenUSDPrice()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return USD_PRICE_START.add(USD_PRICE_DISTA.mul(_vokenIssued).div(VOKEN_ISSUE_MAX));\n', '    }\n', '    \n', '    function daiTransfer(address to, uint256 amount)\n', '        external\n', '        onlyAgent\n', '    {\n', '        DAI.transfer(to, amount);\n', '    }\n', '\n', '    function _swap()\n', '        private\n', '        onlyNotPaused\n', '    {\n', '        require(msg.value >= WEI_PAYMENT_MIN, "Insufficient ether");\n', '        require(_vokenIssued < VOKEN_ISSUE_MAX, "Early-Bird sale completed");\n', '        require(_accounts[msg.sender].issued == 0, "Caller is already an early-bird");\n', '\n', '        uint256 weiPayment = msg.value;\n', '        uint256 weiPaymentMax = _vokenIssued < VOKEN_ISSUE_MID ? WEI_PAYMENT_MAX : WEI_PAYMENT_MID;\n', '\n', '        // Limit the Payment and Refund (if needed)\n', '        if (weiPayment > weiPaymentMax)\n', '        {\n', '            msg.sender.transfer(weiPayment.sub(weiPaymentMax));\n', '            weiPayment = weiPaymentMax;\n', '        }\n', '\n', '        uint256 daiAmount = _swapExactETH2DAI(weiPayment);\n', '        uint256 vokenIssued = daiAmount.div(1e3).div(vokenUSDPrice());\n', '        uint256 vokenRandom;\n', '\n', '        // Voken Bonus & Rewards\n', '        address payable referrer = VOKEN_TB.referrer(msg.sender);\n', '        if (referrer != address(0))\n', '        {\n', '            // Voken Random: 1% - 10%\n', '            vokenRandom = vokenIssued.mul(uint256(blockhash(block.number - 1)).mod(10).add(1)).div(100);\n', '            emit Reward(msg.sender, referrer, vokenRandom);\n', '\n', '            _vokenRandom = _vokenRandom.add(vokenRandom.mul(2));\n', '            _accounts[msg.sender].bonuses = _accounts[msg.sender].bonuses.add(vokenRandom);\n', '            _accounts[referrer].referred = _accounts[referrer].referred.add(vokenIssued);\n', '            _accounts[referrer].rewards = _accounts[referrer].rewards.add(vokenRandom);\n', '\n', '            // VOKEN_TB.mintWithVesting(msg.sender, vokenRandom, address(this));\n', '            VOKEN_TB.mintWithVesting(referrer, vokenRandom, address(this));\n', '        }\n', '\n', '        _vokenIssued = _vokenIssued.add(vokenIssued);\n', '        _accounts[msg.sender].issued = _accounts[msg.sender].issued.add(vokenIssued);\n', '        \n', '        // Issued + Random\n', '        VOKEN_TB.mintWithVesting(msg.sender, vokenIssued.add(vokenRandom), address(this));\n', '\n', '        // Payment Event\n', '        emit Payment(msg.sender, daiAmount, vokenIssued, vokenRandom);\n', '    }\n', '\n', '    function etherUSDPrice()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return UniswapV2Router02.getAmountsOut(1_000_000, _pathETH2DAI())[1];\n', '    }\n', '\n', '    function _swapExactETH2DAI(uint256 etherAmount)\n', '        private\n', '        returns (uint256)\n', '    {\n', '        uint256[] memory _result = UniswapV2Router02.swapExactETHForTokens{value: etherAmount}(0, _pathETH2DAI(), address(this), block.timestamp + 1 days);\n', '        return _result[1];\n', '    }\n', '\n', '    function _pathETH2DAI()\n', '        private\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory path = new address[](2);\n', '        path[0] = UniswapV2Router02.WETH();\n', '        path[1] = address(DAI);\n', '        return path;\n', '    }\n', '}']