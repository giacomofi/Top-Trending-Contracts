['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-08\n', '*/\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '    function acceptOwnership() public {\n', '        assert(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract PepeCoin is Owned, SafeMath {\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimal;\n', '    uint256 public TotalSupply;\n', '    uint256 public coinPrice;\n', '    uint256 private conversion;\n', '    uint256 public coinSold;\n', '    \n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Sell(address _buyer, uint256 _amount);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) internal Allowance;\n', '\n', '    constructor (uint256 InitialSupply) public {\n', '        name = "PepeCoin";\n', '        symbol = "PEPE";\n', '        decimal = 18;\n', '        balanceOf[owner] = InitialSupply;\n', '        TotalSupply = InitialSupply;\n', '    }\n', '\n', '    function transfer(address to, uint coins) public returns (bool success) {\n', '        balanceOf[msg.sender] = sub(balanceOf[msg.sender], coins);\n', '        balanceOf[to] = add(balanceOf[to], coins);\n', '        emit Transfer(msg.sender, to, coins);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint coins) public returns (bool success) {\n', '        Allowance[msg.sender][spender] = coins;\n', '        emit Approval(msg.sender, spender, coins);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint coins) public returns (bool success) {\n', '        balanceOf[from] = sub(balanceOf[from], coins);\n', '        Allowance[from][msg.sender] = sub(Allowance[from][msg.sender], coins);\n', '        balanceOf[to] = add(balanceOf[to], coins);\n', '        emit Transfer(from, to, coins);\n', '        return true;\n', '    }\n', '    \n', '    function mint(address account, uint256 coins) external onlyOwner {\n', '        require(account != address(0));\n', '\n', '        TotalSupply = add(TotalSupply, coins);\n', '        balanceOf[account] = add(balanceOf[account], coins);\n', '        emit Transfer(address(0), account, coins);\n', '    }   \n', '    \n', '    function burn(address account, uint256 coins) external onlyOwner {\n', '        require(account != address(0));\n', '\n', '        TotalSupply = sub(TotalSupply, coins);\n', '        balanceOf[account] = sub(balanceOf[account], coins);\n', '        emit Transfer(account, address(0), coins);\n', '    }\n', '\n', '    function PepeCoinSale(uint256 _coinPrice, uint256 _conversion) public onlyOwner {\n', '        coinPrice = _coinPrice;\n', '        conversion = _conversion;\n', '    }\n', '\n', '    function buyCoins(uint256 quan) public payable {\n', '        uint256 Quan = mul(quan, conversion);\n', '        require(msg.value == mul(quan, coinPrice));\n', '        require(balanceOf[owner] >= Quan);\n', '        balanceOf[owner] = sub(balanceOf[owner], Quan);\n', '        balanceOf[msg.sender] = add(balanceOf[msg.sender], Quan);\n', '\n', '        coinSold = add(Quan, coinSold);\n', '\n', '        emit Sell(msg.sender, Quan);\n', '    }\n', '\n', '    function withdrawl(uint amount) external onlyOwner returns(bool) {\n', '        require(amount <= address(this).balance);\n', '        msg.sender.transfer(amount);\n', '        return true;\n', '        \n', '    }\n', '}']