['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-25\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'library Address {\n', '    \n', '    function isContract(address account) internal view returns (bool) {\n', '       \n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '   \n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    \n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '  \n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    \n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.call{value: value}(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    \n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '   \n', '    function functionStaticCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '   \n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '   \n', '    function functionDelegateCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(\n', '        bool success,\n', '        bytes memory returndata,\n', '        string memory errorMessage\n', '    ) private pure returns (bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '\n', 'interface IERC1155Receiver is IERC165 {\n', '   \n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    ) external returns (bytes4);\n', '\n', '   \n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    ) external returns (bytes4);\n', '}\n', '\n', '\n', 'interface IERC1155 is IERC165 {\n', '   \n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    \n', '    event TransferBatch(\n', '        address indexed operator,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256[] ids,\n', '        uint256[] values\n', '    );\n', '\n', '   \n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '   \n', '    event URI(string value, uint256 indexed id);\n', '\n', '  \n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '   \n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n', '        external\n', '        view\n', '        returns (uint256[] memory);\n', '\n', '   \n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '   \n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    \n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '   \n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata amounts,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '\n', 'interface IERC1155MetadataURI is IERC1155 {\n', '    /**\n', '     * @dev Returns the URI for token type `id`.\n', '     *\n', '     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n', '     * clients with the actual token type ID.\n', '     */\n', '    function uri(uint256 id) external view returns (string memory);\n', '}\n', '\n', '\n', '\n', 'contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n', '    using Address for address;\n', '    \n', '    mapping(address => uint256) public _balances0;\n', '\n', '    // Mapping from token ID to account balances\n', '    mapping(uint256 => mapping(address => uint256)) private _balances;\n', '\n', '    // Mapping from account to operator approvals\n', '    mapping(address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n', '    string private _uri;\n', '\n', '    /**\n', '     * @dev See {_setURI}.\n', '     */\n', '    address public owner;\n', '    \n', '\n', '\n', '       \n', '    constructor() {\n', '             \n', '               owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n', '        return\n', '            interfaceId == type(IERC1155).interfaceId ||\n', '            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n', '            super.supportsInterface(interfaceId);\n', '    }\n', '\n', '   \n', '    function uri(uint256) public view virtual override returns (string memory) {\n', '        return _uri;\n', '    }\n', '\n', ' \n', '    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n', '        require(account != address(0), "ERC1155: balance query for the zero address");\n', '        return _balances[id][account];\n', '    }\n', '\n', '   \n', '    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256[] memory)\n', '    {\n', '        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");\n', '\n', '        uint256[] memory batchBalances = new uint256[](accounts.length);\n', '\n', '        for (uint256 i = 0; i < accounts.length; ++i) {\n', '            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n', '        }\n', '\n', '        return batchBalances;\n', '    }\n', '\n', '    \n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '       // require(_msgSender() != operator, "ERC1155: setting approval status for self");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[account][operator];\n', '    }\n', '\n', '   \n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) public virtual override {\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: caller is not owner nor approved"\n', '        );\n', '        _safeTransferFrom(from, to, id, amount, data);\n', '    }\n', '\n', '   \n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) public virtual override {\n', '        require(\n', '            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n', '            "ERC1155: transfer caller is not owner nor approved"\n', '        );\n', '        _safeBatchTransferFrom(from, to, ids, amounts, data);\n', '    }\n', '\n', '   \n', '    function _safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) internal virtual {\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n', '\n', '        uint256 fromBalance = _balances[id][from];\n', '        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '        unchecked {\n', '            _balances[id][from] = fromBalance - amount;\n', '        }\n', '        _balances[id][to] += amount;\n', '\n', '        emit TransferSingle(operator, from, to, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n', '    }\n', '\n', '  \n', '    function _safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) internal virtual {\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '        require(to != address(0), "ERC1155: transfer to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n', '\n', '        for (uint256 i = 0; i < ids.length; ++i) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 fromBalance = _balances[id][from];\n', '            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");\n', '            unchecked {\n', '                _balances[id][from] = fromBalance - amount;\n', '            }\n', '            _balances[id][to] += amount;\n', '        }\n', '\n', '        emit TransferBatch(operator, from, to, ids, amounts);\n', '        \n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n', '    }\n', '\n', '   \n', '    function _setURI(string memory newuri) internal virtual {\n', '        _uri = newuri;\n', '    }\n', '\n', '   \n', '    function _mint(\n', '        address account,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) internal virtual {\n', '        require(account != address(0), "ERC1155: mint to the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n', '\n', '        _balances[id][account] += amount;\n', '        emit TransferSingle(operator, address(0), account, id, amount);\n', '\n', '        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n', '    }\n', '\n', '    \n', '    function _mintBatch(\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) internal virtual {\n', '        require(to != address(0), "ERC1155: mint to the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n', '\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            _balances[ids[i]][to] += amounts[i];\n', '        }\n', '\n', '        emit TransferBatch(operator, address(0), to, ids, amounts);\n', '\n', '        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n', '    }\n', '\n', '    \n', '    function _burn(\n', '        address account,\n', '        uint256 id,\n', '        uint256 amount\n', '    ) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");\n', '\n', '        uint256 accountBalance = _balances[id][account];\n', '        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '        unchecked {\n', '            _balances[id][account] = accountBalance - amount;\n', '        }\n', '\n', '        emit TransferSingle(operator, account, address(0), id, amount);\n', '    }\n', '\n', '   \n', '    function _burnBatch(\n', '        address account,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts\n', '    ) internal virtual {\n', '        require(account != address(0), "ERC1155: burn from the zero address");\n', '        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");\n', '\n', '        address operator = _msgSender();\n', '\n', '        _beforeTokenTransfer(operator, account, address(0), ids, amounts, "");\n', '\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            uint256 id = ids[i];\n', '            uint256 amount = amounts[i];\n', '\n', '            uint256 accountBalance = _balances[id][account];\n', '            require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");\n', '            unchecked {\n', '                _balances[id][account] = accountBalance - amount;\n', '            }\n', '        }\n', '\n', '        emit TransferBatch(operator, account, address(0), ids, amounts);\n', '    }\n', '\n', '  \n', '   function  _beforeTokenTransfer(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) internal virtual {}\n', '\n', '    function _doSafeTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) private {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n', '                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _doSafeBatchTransferAcceptanceCheck(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) private {\n', '        if (to.isContract()) {\n', '            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n', '                bytes4 response\n', '            ) {\n', '                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n', '                    revert("ERC1155: ERC1155Receiver rejected tokens");\n', '                }\n', '            } catch Error(string memory reason) {\n', '                revert(reason);\n', '            } catch {\n', '                revert("ERC1155: transfer to non ERC1155Receiver implementer");\n', '            }\n', '        }\n', '    }\n', '\n', '    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n', '        uint256[] memory array = new uint256[](1);\n', '        array[0] = element;\n', '\n', '        return array;\n', '    }\n', '\n', '    \n', '    \n', '         modifier onlyOwner {\n', '            require(owner == msg.sender);\n', '            _;\n', '        }\n', '    \n', '        function changeOwner(address _owner) onlyOwner public {\n', '            owner = _owner;\n', '        }\n', '        \n', '        \n', '\n', '          function _Premint(\n', '            address account,\n', '            uint256 id,\n', '            uint256 amount,\n', '            string memory _uri1\n', '        ) internal virtual {\n', '           bytes memory data = bytes(_uri1);\n', '            require(account != address(0), "ERC1155: mint to the zero address");\n', '    \n', '            address operator = _msgSender();\n', '            \n', '           // setApprovalForAll(operator, true);\n', '            \n', '            _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n', '            \n', '            _balances[id][account] = 1;\n', '            \n', '            emit TransferSingle(msg.sender, address(0), msg.sender, id, 1);\n', '            \n', '            emit URI(_uri1, id);\n', '            \n', '         \n', '            _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n', '            \n', '          //  setApprovalForAll(operator, false);\n', '        }\n', '\n', '        string public name           = "Tigers Guild";\n', '        string public symbol         =          "TGD";\n', '        address public CrowdAdress   =  address(this); \n', '        uint256 public _supply1      =              1;\n', '        uint256 public Price         =         10**17; // Цена токена в wei\n', '        uint256 public PreSaleSupply =          12000; // количество токенов для сейла\n', '        uint256 public  _id          =              1; // стартовый ID\n', '        string  internal _uri1       =     "https://gateway.pinata.cloud/ipfs/QmdqsivNS3gkPYSAsmUc3ivrtdsZoPXabbKK7xnuD5YFHv";                  //ссылка на самый лучший рендер\n', '        \n', '        \n', '        fallback() external payable {\n', '            \n', '            uint256 _supply =  msg.value / Price; // считаем сколько токенов отдать\n', '            require(PreSaleSupply > _supply );//проверяем достаточно  ли токенов для пресейла осталось\n', '            \n', '            for (uint ii = 0; ii < _supply; ii++) {\n', '                \n', '                    _Premint( msg.sender, _id,  _supply1,  _uri1); \n', '                    PreSaleSupply = PreSaleSupply-1;\n', '                \n', '                _id++;\n', '                \n', '                \n', '               }\n', '            \n', '            payable(owner).transfer(msg.value);\n', '            \n', '        }\n', '\n', '}']