['// SPDX-License-Identifier: Unlicense\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "IERC20.sol";\n', 'import "IERC20Metadata.sol";\n', 'import "Context.sol";\n', '\n', '\n', 'contract ERC20 is Context, IERC20, IERC20Metadata {\n', '    // Instance of Token\n', '    IERC20 token;\n', '    \n', '    //  MAPPINGS\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\tmapping (address => uint256) public lockTokens;\n', '    // VARAIBLES\n', '    uint256 private _totalSupply;\n', '    uint256 public tokenPrice;\n', '    uint256 public remainingTokens;\n', '    string private _name;\n', '    string private _symbol;\n', '    address payable ownerAccount;\n', '    uint256 releaseTime;\n', '    uint256 public cap;\n', '    uint256 lockedAmount;\n', '    uint256 releaseTimeOwner;\n', '\tuint256 public mintCapAnnual;\n', '\tuint256 public mintAvailableDate;\n', '\tuint256 private _mini;\n', '    \n', '    \n', '    //  MODIFIERS\n', '    modifier onlyOwner(){\n', '        require(msg.sender == ownerAccount, "You are not an Owner.");\n', '        _;\n', '    }\n', '    \n', '    \n', '    constructor () public {\n', '        _name = "Ice Cube";\n', '        _symbol = "iCube";\n', '        _totalSupply = 1050000000000 * (10**18);\n', '        _balances[_msgSender()] = _totalSupply;\n', '        ownerAccount = msg.sender;\n', '        tokenPrice = 800000000;\n', '        token = IERC20(address(this));\n', '        cap = 2100000000000 * (10**18);\n', '\t\tmintCapAnnual = cap/50;\n', '        releaseTime = 0;  \n', '        lockedAmount = 0;\n', '        releaseTimeOwner = 0;\n', '\t\tmintAvailableDate = 1655683200;\n', '    }   \n', '\t\n', '    \n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    \n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    \n', '    function decimals() public view virtual override returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    \n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        if(address(this) == msg.sender){\n', '            _transfer(_msgSender(), recipient, amount);\n', '        }\n', '        else{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n', '            uint256 checkBalance = (_balances[_msgSender()] - lockTokens[_msgSender()]);\n', '            require(now >= releaseTime || checkBalance >= amount,"Token is Paused");\n', '            require(amount <= cap,"Cap amount exceeded...");\n', '            if(ownerAccount == _msgSender()){\n', '                if(releaseTimeOwner != 0){\n', '                     require((_balances[ownerAccount] - amount) >= lockedAmount,"Passed wrong value");\n', '                     require( now >= releaseTimeOwner,"Owner can not transfer this time");    \n', '                    _transfer(_msgSender(), recipient, amount);\n', '                    \n', '                }else{\n', '                    _transfer(_msgSender(), recipient, amount);\n', '                }\n', '            }else{\n', '                _transfer(_msgSender(), recipient, amount);\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function noPausedtransfer(address recipient, uint256 amount) internal returns (bool) {\n', '        require(amount <= cap,"Cap amount exceeded...");\n', '        \n', '        if(ownerAccount == _msgSender()){\n', '            if(releaseTimeOwner != 0){\n', '                 require((_balances[ownerAccount] - amount) >= lockedAmount,"Passed wrong value");\n', '                 require( now >= releaseTimeOwner,"Owner can not transfer this time");    \n', '                _transfer(_msgSender(), recipient, amount);\n', '                \n', '            }else{\n', '                _transfer(_msgSender(), recipient, amount);\n', '            }\n', '        }else{\n', '            _transfer(_msgSender(), recipient, amount);\n', '        }\n', '    }\n', '    \n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        require(now >= releaseTime || lockTokens[_msgSender()] <= 0,"Token is Paused");\n', '        require(amount <= cap,"Cap amount exceeded...");\n', '        if(ownerAccount == _msgSender()){\n', '            if(releaseTimeOwner != 0){\n', '                 require((_balances[ownerAccount] - amount) >= lockedAmount,"Passed wrong value");\n', '                 require( now >= releaseTimeOwner,"Owner can not transfer this time");    \n', '                 uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '                 require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '                _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '            }else{\n', '                uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '                require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '                _approve(sender, _msgSender(), currentAllowance - amount);\n', '            }\n', '        }else{\n', '            uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '            require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '            _approve(sender, _msgSender(), currentAllowance - amount);\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    \n', '\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    \n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    // THIS FUNCTION WILL CALL ONLY OWNER FOR MINTING THE TOKENS \n', '    // IF TOTAL SUPPLY ACHIEVED THE CAPPED VALUE THEN NO MINTING WILL ALLOWED\n', "    // THEN OWNER NEED TO INCREASE THE CAP VALUE BY USING 'setCapAmount' FUNCTION\n", '    function mint(address account, uint256 amount) public onlyOwner{\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '        require(_totalSupply + amount<= cap,"Amount Exceeded Market Cap");\n', '\t\trequire(amount<= mintCapAnnual,"Amount Exceeded Mint Cap");\n', '\t\trequire(mintAvailableDate<= now,"Coin Not Ready for Mint");\n', '\t\tmintAvailableDate += 31536000;\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    // THIS FUNCTION WILL CALL ONLY FOR OWNER FOR BURNING THE TOKENS\n', '    function burn(address account, uint256 amount) public onlyOwner{\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '        if(ownerAccount == msg.sender){\n', '            if(releaseTimeOwner != 0){\n', '                require((_balances[ownerAccount] - amount) >= lockedAmount,"Passed wrong value");\n', '                require( now >= releaseTimeOwner,"Owner can not transfer this time");\n', '                uint256 accountBalance = _balances[account];\n', '                require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '                _balances[account] = accountBalance - amount;\n', '                _totalSupply -= amount;\n', '                emit Transfer(account, address(0), amount);   \n', '            }else{\n', '                uint256 accountBalance = _balances[account];\n', '                require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '                _balances[account] = accountBalance - amount;\n', '                _totalSupply -= amount;\n', '                emit Transfer(account, address(0), amount);\n', '            }\n', '        }else{\n', '            uint256 accountBalance = _balances[account];\n', '            require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '            _balances[account] = accountBalance - amount;\n', '            _totalSupply -= amount;\n', '            emit Transfer(account, address(0), amount);\n', '        }\n', '    }\n', '\n', '    // THIS WILL PAUSE THE TOKEN\n', '    function pauseToken(uint256 timestamp) public onlyOwner{\n', '        releaseTime = timestamp;\n', '    }\n', '    \n', '    // THIS WILL SET THE PRICE OF TOKEN\n', '    function setPrice(uint256 _price) public onlyOwner{\n', '        tokenPrice = _price;\n', '    }\n', '    \n', '    \n', '    // OWNER NEED TO CALL THIS FUNCTION BEFORE START ICO\n', '    // OWNER ALSO NEED TO SET A GOAL OF TOKEN AMOUNT FOR FUND RAISING\n', '    // THIS FUNCTION WILL TRANSFER THE TOKENS FROM OWNER TO CONTRACT\n', '    function startBuying(uint256 tokenAmount, uint256 time) public onlyOwner{\n', '        releaseTime = time;\n', '        remainingTokens = tokenAmount;\n', '        noPausedtransfer(address(this),tokenAmount);\n', '    }\n', '    \n', '   \n', '    \n', '  \n', '    //  THIS FUMCTION WILL BE USED BY INVESTOR FOR BUYING TOKENS\n', '    //  IF THE OWNER WILL END ICO THEN NO ONE CAN INVEST ANYMORE \n', '    function buyToken() public payable{\n', '        require(msg.value > 0,"You are passing wrong value");\n', '\t\trequire(msg.value <= 10**19,"Maximum order size is 10 ETH");\n', '        require(msg.sender != address(0),"Invalid Address of Buyer");\n', '        require(now <= releaseTime, "TokenSale is ended.");\n', '        address sender = msg.sender; \n', '        uint256 quantity = (msg.value / tokenPrice) * 10**18;\n', '\t\tlockTokens[sender] += quantity;\t\t\t\t\t\t\t\t \n', '        ownerAccount.transfer(msg.value);\n', '        token.transfer(sender,quantity);\n', '        remainingTokens -= quantity; \n', '    }\n', '    \n', '\t//  OWNER CAN LOCK THEIR TOKENS\t\n', '    function lockOwnerTokens(uint256 amount, uint256 _time) public onlyOwner {\n', '        lockedAmount = amount;\n', '        releaseTimeOwner = _time;\n', '    }\n', '    \n', '\t// WITHDRAW\n', '    function withdraw() public onlyOwner{\n', '        require(remainingTokens > 0,"All tokens are Sold.");\n', '        token.transfer(ownerAccount,remainingTokens);\n', '    }\n', '      \n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    \n', '}']