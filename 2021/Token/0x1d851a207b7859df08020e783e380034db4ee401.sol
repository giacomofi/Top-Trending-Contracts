['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'library SafeMathLib {\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', "    require(a == 0 || c / a == b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) public pure returns (uint) {\n', "    require(b <= a, 'Underflow detected');\n", '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) public pure returns (uint) {\n', '    uint c = a + b;\n', "    require(c>=a && c>=b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract UniformTimeVault {\n', '    using SafeMathLib for uint;\n', '\n', '    IERC20 public token;\n', '    uint public numTranches = 0;\n', '    uint public startTime = 0;\n', '    uint public endTime = 0;\n', '    uint public vestingPeriodLength = 0;\n', '    uint public totalAllocation = 0;\n', '\n', '    struct Tranche {\n', '        uint id;\n', '        address destination;\n', '        uint totalCoins;\n', '        uint currentCoins;\n', '        uint coinsPerSecond;\n', '        uint lastWithdrawalTime;\n', '    }\n', '\n', '    mapping (uint => Tranche) public tranches;\n', '\n', '    event WithdrawalOccurred(uint trancheId, uint numTokens, uint tokensLeft);\n', '    event TrancheAdded(uint id, address destination, uint totalCoins);\n', '\n', '    constructor(address tokenAddr, address[] memory destinations, uint[] memory tokenAllocations, uint _endTime, uint _startTime) {\n', '        token = IERC20(tokenAddr);\n', '        endTime = _endTime;\n', '        startTime = _startTime;\n', '        vestingPeriodLength = endTime - startTime;\n', "        require(vestingPeriodLength > 0 , 'start time must be before end time');\n", '\n', '        for (uint i = 0; i < destinations.length; i++)  {\n', '            uint trancheId = i + 1;\n', '            uint coinsPerSecond = tokenAllocations[i] / vestingPeriodLength;\n', '            totalAllocation = totalAllocation.plus(tokenAllocations[i]);\n', '            tranches[trancheId] = Tranche(\n', '                trancheId,\n', '                destinations[i],\n', '                tokenAllocations[i],\n', '                tokenAllocations[i],\n', '                coinsPerSecond,\n', '                _startTime\n', '            );\n', '            emit TrancheAdded(trancheId, destinations[i], tokenAllocations[i]);\n', '        }\n', '        numTranches = destinations.length;\n', '    }\n', '\n', '    function withdraw(uint trancheId) external {\n', '        Tranche storage tranche = tranches[trancheId];\n', "        require(tranche.currentCoins >  0, 'No coins left to withdraw');\n", '        uint currentWithdrawal = 0;\n', '\n', '        // if after vesting period ends, give them the remaining coins\n', '        if (block.timestamp >= endTime) {\n', '            currentWithdrawal = tranche.currentCoins;\n', '        } else {\n', '            // compute allowed withdrawal\n', '            currentWithdrawal = (block.timestamp.minus(tranche.lastWithdrawalTime)).times(tranche.coinsPerSecond);\n', '        }\n', '\n', '        // update struct\n', '        tranche.currentCoins = tranche.currentCoins.minus(currentWithdrawal);\n', '        tranche.lastWithdrawalTime = block.timestamp;\n', '\n', '        // transfer the tokens, brah\n', '        token.transfer(tranche.destination, currentWithdrawal);\n', '        emit WithdrawalOccurred(trancheId, currentWithdrawal, tranche.currentCoins);\n', '    }\n', '\n', '    function changeDestination(uint trancheId, address newDestination) external {\n', '        Tranche storage tranche = tranches[trancheId];\n', "        require(tranche.destination == msg.sender, 'Can only change destination if you are the destination');\n", '        tranche.destination = newDestination;\n', '    }\n', '}']