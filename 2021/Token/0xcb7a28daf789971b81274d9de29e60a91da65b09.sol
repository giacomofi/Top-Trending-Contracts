['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-08\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'interface ITetherERC20 {\n', '    function totalSupply() public view returns (uint supply);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public;\n', '    function transferFrom(address _from, address _to, uint _value) public;\n', '    function approve(address _spender, uint _value) public;\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '    function decimals() public view returns(uint8 digits);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * See https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract ERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @title Basic token\n', ' * @dev Basic version of StandardToken, with no allowances.\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => uint256) balances; // Storage slot 0\n', '\n', '  uint256 totalSupply_; // Storage slot 1\n', '\n', '  /**\n', '  * @dev Total number of tokens in existence\n', '  */\n', '  function totalSupply() public view returns (uint256) {\n', '    return totalSupply_;\n', '  }\n', '\n', '  /**\n', '  * @dev Transfer token for a specified address\n', '  * @param _to The address to transfer to.\n', '  * @param _value The amount to be transferred.\n', '  */\n', '  function transfer(address _to, uint256 _value) public returns (bool) {\n', '    require(_to != address(0));\n', '    require(_value <= balances[msg.sender]);\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /**\n', '  * @dev Gets the balance of the specified address.\n', '  * @param _owner The address to query the the balance of.\n', '  * @return An uint256 representing the amount owned by the passed address.\n', '  */\n', '  function balanceOf(address _owner) public view returns (uint256) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', '* @title Standard ERC20 token\n', '*\n', '* @dev Implementation of the basic standard token.\n', '* https://github.com/ethereum/EIPs/issues/20\n', '* Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', '*/\n', 'contract StandardToken is ERC20, BasicToken {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => mapping (address => uint256)) internal allowed; // Storage slot 2\n', '\n', '    /**\n', '    * @dev Transfer tokens from one address to another\n', '    * @param _from address The address which you want to send tokens from\n', '    * @param _to address The address which you want to transfer to\n', '    * @param _value uint256 the amount of tokens to be transferred\n', '    */\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        require(_to != address(0));\n', '        require(_value <= balances[_from]);\n', '        require(_value <= allowed[_from][msg.sender]);\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _value The amount of tokens to be spent.\n', '    */\n', '    function approve(address _spender, uint256 _value) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    * @param _owner address The address which owns the funds.\n', '    * @param _spender address The address which will spend the funds.\n', '    * @return A uint256 specifying the amount of tokens still available for the spender.\n', '    */\n', '    function allowance(\n', '        address _owner,\n', '        address _spender\n', '    )\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /**\n', '    * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '    * approve should be called when allowed[_spender] == 0. To increment\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _addedValue The amount of tokens to increase the allowance by.\n', '    */\n', '    function increaseApproval(\n', '        address _spender,\n', '        uint256 _addedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = (\n', '        allowed[msg.sender][_spender].add(_addedValue));\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '    * approve should be called when allowed[_spender] == 0. To decrement\n', '    * allowed value is better to use this function to avoid 2 calls (and wait until\n', '    * the first transaction is mined)\n', '    * From MonolithDAO Token.sol\n', '    * @param _spender The address which will spend the funds.\n', '    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n', '    */\n', '    function decreaseApproval(\n', '        address _spender,\n', '        uint256 _subtractedValue\n', '    )\n', '        public\n', '        returns (bool)\n', '    {\n', '        uint256 oldValue = allowed[msg.sender][_spender];\n', '        if (_subtractedValue > oldValue) {\n', '        allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '        return true;\n', '    }\n', '\n', '}\n', '\n', 'contract StandardTokenMintableBurnable is StandardToken {\n', '  using SafeMath for uint256;\n', '\n', '  function _mint(address account, uint256 amount) internal {\n', '    require(account != address(0), "ERC20: mint to the zero address");\n', '    totalSupply_ = totalSupply_.add(amount);\n', '    balances[account] = balances[account].add(amount);\n', '    emit Transfer(address(0), account, amount);\n', '  }\n', '\n', '  function burn(uint256 amount) public {\n', '    _burn(msg.sender, amount);\n', '  }\n', '\n', '  function _burn(address account, uint256 amount) internal {\n', '    require(account != address(0), "ERC20: burn from the zero address");\n', '    totalSupply_ = totalSupply_.sub(amount);\n', '    balances[account] = balances[account].sub(amount);\n', '    emit Transfer(account, address(0), amount);\n', '  }\n', '}\n', '\n', 'contract WhiteListToken is StandardTokenMintableBurnable{\n', '  address public whiteListAdmin;\n', '  bool public isTransferRestricted;\n', '  bool public isReceiveRestricted;\n', '  mapping(address => bool) public transferWhiteList;\n', '  mapping(address => bool) public receiveWhiteList;\n', '\n', '\n', '  constructor(address _admin) public {\n', '    whiteListAdmin = _admin;\n', '    isReceiveRestricted = true;\n', '  }\n', '\n', '  modifier isWhiteListAdmin() {\n', '      require(msg.sender == whiteListAdmin);\n', '      _;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool){\n', '    if (isTransferRestricted) {\n', '      require(transferWhiteList[msg.sender], "only whitelist senders can transfer tokens");\n', '    }\n', '    if (isReceiveRestricted) {\n', '      require(receiveWhiteList[_to], "only whiteList receivers can receive tokens");\n', '    }\n', '    return super.transfer(_to, _value);\n', '  }\n', '\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '    if (isTransferRestricted) {\n', '      require(transferWhiteList[_from], "only whiteList senders can transfer tokens");\n', '    }\n', '    if (isReceiveRestricted) {\n', '      require(receiveWhiteList[_to], "only whiteList receivers can receive tokens");\n', '    }\n', '    return super.transferFrom(_from, _to, _value);\n', '  }\n', '\n', '  function enableTransfer() isWhiteListAdmin public {\n', '    require(isTransferRestricted);\n', '    isTransferRestricted = false;\n', '  }\n', '\n', '  function restrictTransfer() isWhiteListAdmin public {\n', '    require(isTransferRestricted == false);\n', '    isTransferRestricted = true;\n', '  }\n', '\n', '  function enableReceive() isWhiteListAdmin public {\n', '    require(isReceiveRestricted);\n', '    isReceiveRestricted = false;\n', '  }\n', '\n', '  function restrictReceive() isWhiteListAdmin public {\n', '    require(isReceiveRestricted == false);\n', '    isReceiveRestricted = true;\n', '  }\n', '\n', '\n', '  function removeTransferWhiteListAddress(address _whiteListAddress) public isWhiteListAdmin returns(bool) {\n', '    require(transferWhiteList[_whiteListAddress]);\n', '    transferWhiteList[_whiteListAddress] = false;\n', '    return true;\n', '  }\n', '\n', '  function addTransferWhiteListAddress(address _whiteListAddress) public isWhiteListAdmin returns(bool) {\n', '    require(transferWhiteList[_whiteListAddress] == false);\n', '    transferWhiteList[_whiteListAddress] = true;\n', '    return true;\n', '  }\n', '\n', '  function removeReceiveWhiteListAddress(address _whiteListAddress) public isWhiteListAdmin returns(bool) {\n', '    require(receiveWhiteList[_whiteListAddress]);\n', '    receiveWhiteList[_whiteListAddress] = false;\n', '    return true;\n', '  }\n', '\n', '  function addReceiveWhiteListAddress(address _whiteListAddress) public isWhiteListAdmin returns(bool) {\n', '    require(receiveWhiteList[_whiteListAddress] == false);\n', '    receiveWhiteList[_whiteListAddress] = true;\n', '    return true;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract SimpleOracleAccruedRatioUSD {\n', '    using SafeMath for uint256;\n', '    address public admin;\n', '    address public superAdmin;\n', '    uint256 public accruedRatioUSD;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public MAXIMUM_CHANGE_PCT = 3;\n', '\n', '    constructor(uint256 _accruedRatioUSD, address _admin, address _superAdmin) public {\n', '        admin = _admin;\n', '        superAdmin = _superAdmin;\n', '        accruedRatioUSD = _accruedRatioUSD;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin || msg.sender == superAdmin);\n', '        _;\n', '    }\n', '\n', '    modifier onlySuperAdmin {\n', '        require(msg.sender == superAdmin);\n', '        _;\n', '    }\n', '\n', '    function isValidRatio(uint256 _accruedRatioUSD) view internal {\n', '      require(_accruedRatioUSD >= accruedRatioUSD, "ratio should be monotonically increased");\n', '      uint256 maximumChange = accruedRatioUSD.mul(MAXIMUM_CHANGE_PCT).div(100);\n', '      require(_accruedRatioUSD.sub(accruedRatioUSD) < maximumChange, "exceeds maximum chagne");\n', '    }\n', '\n', '    function checkTimeStamp() view internal {\n', '      // 82800 = 23 * 60 * 60  (23 hours)\n', '      require(block.timestamp.sub(lastUpdateTime) > 82800, "oracle are not allowed to update two times within 23 hours");\n', '    }\n', '\n', '    function set(uint256 _accruedRatioUSD) onlyAdmin public{\n', '        if(msg.sender != superAdmin) {\n', '          isValidRatio(_accruedRatioUSD);\n', '          checkTimeStamp();\n', '        }\n', '        lastUpdateTime = block.timestamp;\n', '        accruedRatioUSD = _accruedRatioUSD;\n', '    }\n', '\n', '    function query() external view returns(uint256)  {\n', '        // QueryEvent(msg.sender, block.number);\n', '        return accruedRatioUSD;\n', '    }\n', '}\n', '\n', 'interface CERC20 {\n', '    function mint(uint mintAmount) returns (uint);\n', '    function redeem(uint redeemTokens) returns (uint);\n', '    function supplyRatePerBlock() returns (uint);\n', '    function exchangeRateCurrent() returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function balanceOfUnderlying(address account) returns (uint);\n', '}\n', '\n', 'interface CEther {\n', '    function mint() payable;\n', '    function redeem(uint redeemTokens) returns (uint);\n', '    function supplyRatePerBlock() returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function balanceOfUnderlying(address account) returns (uint);\n', '}\n', '\n', 'contract CoolBitETFUSDTAndCompound is WhiteListToken{\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public baseRatio;\n', '    string public name = "X-Saving Certificate";\n', '    string public constant symbol = "XSCert";\n', '    uint8 public decimals;\n', '\n', '    // USDT token contract\n', '    ITetherERC20 public StableToken;\n', '    SimpleOracleAccruedRatioUSD public oracle;\n', '    // Defi contract\n', '    CERC20 public cToken;\n', '\n', '    // Roles\n', '    address public bincentiveHot; // i.e., Platform Owner\n', '    address public bincentiveCold;\n', '    address[] public investors;\n', '    mapping(address => bool) public isInInvestorList;\n', '\n', '    uint256 public numAUMDistributedInvestors; // i.e., number of investors that already received AUM\n', '\n', '    // Contract(Fund) Status\n', '    // 0: not initialized\n', '    // 1: initialized\n', '    // 2: not enough fund came in in time\n', '    // 3: fundStarted\n', '    // 4: running\n', '    // 5: stoppped\n', '    // 6: closed\n', '    // 7: suspended\n', '    uint256 public fundStatus;\n', '\n', '    // Money\n', '    mapping(address => uint256) public investorDepositUSDTAmount;  // denominated in stable token\n', '    uint256 public currentInvestedAmount;  // denominated in stable token\n', '\n', '    // Fund Parameters\n', '    uint256 public investPaymentDueTime;  // deadline for deposit which comes in before fund starts running\n', '    uint256 public percentageOffchainFund;  // percentage of fund that will be transfered off-chain\n', '    uint256 public percentageMinimumFund;  // minimum percentage of fund required to keep the fund functioning\n', '    uint256 public minimumFund;  // minimum amounf required to keep the fund functioning\n', '    uint256 public minPenalty;  // a minimum 100 USDT penalty\n', '\n', '    // Events\n', '    event Deposit(address indexed investor, uint256 investAmount, uint256 mintedAmount);\n', '    event UserInfo(bytes32 indexed uuid, string referralCode);\n', '    event StartFund(uint256 timeStamp, uint256 num_investors, uint256 totalInvestedAmount, uint256 totalMintedTokenAmount);\n', '    event Withdraw(address indexed investor, uint256 tokenAmount, uint256 USDTAmount, uint256 ToBincentiveColdUSDTAmount);\n', '    event MidwayQuit(address indexed investor, uint256 tokenAmount, uint256 USDTAmount);\n', '    event ReturnAUM(uint256 StableTokenAmount);\n', '    event DistributeAUM(address indexed to, uint256 tokenAmount, uint256 StableTokenAmount);\n', '    // Admin Events\n', '    event NewBincentiveCold(address newBincentiveCold);\n', '    // Defi Events\n', '    event MintcUSDT(uint USDTAmount);\n', '    event RedeemcUSDT(uint RedeemcUSDTAmount);\n', '\n', '    // Modifiers\n', '    modifier initialized() {\n', '        require(fundStatus == 1);\n', '        _;\n', '    }\n', '\n', '    // modifier fundStarted() {\n', '    //     require(fundStatus == 3);\n', '    //     _;\n', '    // }\n', '\n', '    modifier running() {\n', '        require(fundStatus == 4);\n', '        _;\n', '    }\n', '\n', '    modifier runningOrSuspended() {\n', '        require((fundStatus == 4) || (fundStatus == 7));\n', '        _;\n', '    }\n', '\n', '    modifier stoppedOrSuspended() {\n', '        require((fundStatus == 5) || (fundStatus == 7));\n', '        _;\n', '    }\n', '\n', '    modifier runningOrStoppedOrSuspended() {\n', '        require((fundStatus == 4) || (fundStatus == 5) || (fundStatus == 7));\n', '        _;\n', '    }\n', '\n', '    modifier closedOrAbortedOrSuspended() {\n', '        require((fundStatus == 6) || (fundStatus == 2) || (fundStatus == 7));\n', '        _;\n', '    }\n', '\n', '    modifier isBincentive() {\n', '        require(\n', '            (msg.sender == bincentiveHot) || (msg.sender == bincentiveCold)\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier isBincentiveCold() {\n', '        require(msg.sender == bincentiveCold);\n', '        _;\n', '    }\n', '\n', '    modifier isInvestor() {\n', '        // bincentive is not investor\n', '        require(msg.sender != bincentiveHot);\n', '        require(msg.sender != bincentiveCold);\n', '        require(balances[msg.sender] > 0);\n', '        _;\n', '    }\n', '\n', '\n', '    // Transfer functions for USDT\n', '    function checkBalanceTransfer(address to, uint256 amount) internal {\n', '        uint256 balanceBeforeTransfer = StableToken.balanceOf(to);\n', '        uint256 balanceAfterTransfer;\n', '        StableToken.transfer(to, amount);\n', '        balanceAfterTransfer = StableToken.balanceOf(to);\n', '        require(balanceAfterTransfer == balanceBeforeTransfer.add(amount));\n', '    }\n', '\n', '    function checkBalanceTransferFrom(address from, address to, uint256 amount) internal {\n', '        uint256 balanceBeforeTransfer = StableToken.balanceOf(to);\n', '        uint256 balanceAfterTransfer;\n', '        StableToken.transferFrom(from, to, amount);\n', '        balanceAfterTransfer = StableToken.balanceOf(to);\n', '        require(balanceAfterTransfer == balanceBeforeTransfer.add(amount));\n', '    }\n', '\n', '\n', '    // Getter Functions\n', '\n', '    // Get the balance of an investor, denominated in stable token\n', '    function getBalanceValue(address investor) public view returns(uint256) {\n', '        uint256 accruedRatioUSDT = oracle.query();\n', '        return balances[investor].mul(accruedRatioUSDT).div(baseRatio);\n', '    }\n', '\n', '    // Defi Functions\n', '\n', '    function querycUSDTAmount() internal returns(uint256) {\n', '        return cToken.balanceOf(address(this));\n', '    }\n', '\n', '    function querycExgRate() internal returns(uint256) {\n', '        return cToken.exchangeRateCurrent();\n', '    }\n', '\n', '    function mintcUSDT(uint USDTAmount) public isBincentive {\n', '\n', '        StableToken.approve(address(cToken), USDTAmount); // approve the transfer\n', '        assert(cToken.mint(USDTAmount) == 0);\n', '\n', '        emit MintcUSDT(USDTAmount);\n', '    }\n', '\n', '    function redeemcUSDT(uint RedeemcUSDTAmount) public isBincentive {\n', '\n', '        require(cToken.redeem(RedeemcUSDTAmount) == 0, "something went wrong");\n', '\n', '        emit RedeemcUSDT(RedeemcUSDTAmount);\n', '    }\n', '\n', '\n', '    // Investor Deposit\n', '    // It can either be called by investor directly or by bincentive accounts.\n', '    // Only the passed in argument `investor` would be treated as the real investor.\n', '    function deposit(address investor, uint256 depositUSDTAmount, bytes32 uuid, string referralCode) initialized public {\n', '        require(now < investPaymentDueTime, "Deposit too late");\n', '        require((investor != bincentiveHot) && (investor != bincentiveCold), "Investor can not be bincentive accounts");\n', '        require(depositUSDTAmount > 0, "Deposited stable token amount should be greater than zero");\n', '\n', '        // Transfer Stable Token to this contract\n', '        checkBalanceTransferFrom(msg.sender, address(this), depositUSDTAmount);\n', '\n', '        // Add investor to investor list if not present in the record before\n', '        if(isInInvestorList[investor] == false) {\n', '            investors.push(investor);\n', '            isInInvestorList[investor] = true;\n', '        }\n', '        currentInvestedAmount = currentInvestedAmount.add(depositUSDTAmount);\n', '        investorDepositUSDTAmount[investor] = investorDepositUSDTAmount[investor].add(depositUSDTAmount);\n', '\n', '        // Query Oracle for current stable token ratio\n', '        uint256 accruedRatioUSDT = oracle.query();\n', '        // Mint and distribute tokens to investors\n', '        uint256 mintedTokenAmount;\n', '        mintedTokenAmount = depositUSDTAmount.mul(baseRatio).div(accruedRatioUSDT);\n', '        _mint(investor, mintedTokenAmount);\n', '\n', '        emit Deposit(investor, depositUSDTAmount, mintedTokenAmount);\n', '        emit UserInfo(uuid, referralCode);\n', '    }\n', '\n', '    // Start Investing\n', '    // Send part of the funds offline\n', '    // and calculate the minimum amount of fund needed to keep the fund functioning\n', '    // and calculate the maximum amount of fund allowed to be withdrawn per period.\n', '    function start() initialized isBincentive public {\n', '        // Send some USDT offline\n', '        uint256 amountSentOffline = currentInvestedAmount.mul(percentageOffchainFund).div(100);\n', '        checkBalanceTransfer(bincentiveCold, amountSentOffline);\n', '\n', '        minimumFund = totalSupply().mul(percentageMinimumFund).div(100);\n', '        // Start the contract\n', '        fundStatus = 4;\n', '        emit StartFund(now, investors.length, currentInvestedAmount, totalSupply());\n', '    }\n', '\n', '    function amountWithdrawable() public view returns(uint256) {\n', '        return totalSupply().sub(minimumFund);\n', '    }\n', '\n', '    function isAmountWithdrawable(address investor, uint256 tokenAmount) public view returns(bool) {\n', '        require(tokenAmount > 0, "Withdrawn amount must be greater than zero");\n', '        require(balances[investor] >= tokenAmount, "Not enough token to be withdrawn");\n', '        require(totalSupply().sub(tokenAmount) >= minimumFund, "Amount of fund left would be less than minimum fund threshold after withdrawal");\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw(address investor, uint256 tokenAmount) running isBincentive public {\n', '        require(tokenAmount > 0, "Withdrawn amount must be greater than zero");\n', '        require(balances[investor] >= tokenAmount, "Not enough token to be withdrawn");\n', '        require(totalSupply().sub(tokenAmount) >= minimumFund, "Amount of fund left would be less than minimum fund threshold after withdrawal");\n', '\n', '        uint256 investorBalanceBeforeWithdraw = balances[investor];\n', "        // Substract withdrawing amount from investor's balance\n", '        _burn(investor, tokenAmount);\n', '\n', '        uint256 depositUSDTAmount = investorDepositUSDTAmount[investor];\n', '\n', '        // Query Oracle for current stable token ratio\n', '        uint256 accruedRatioUSDT = oracle.query();\n', '        uint256 principle;\n', '        uint256 interest;\n', '        uint256 amountUSDTToWithdraw;\n', '        uint256 amountUSDTForInvestor;\n', '        uint256 amountUSDTToBincentiveCold;\n', '\n', '        amountUSDTToWithdraw = tokenAmount.mul(accruedRatioUSDT).div(baseRatio);\n', '        principle = depositUSDTAmount.mul(tokenAmount).div(investorBalanceBeforeWithdraw);\n', '        interest = amountUSDTToWithdraw.sub(principle);\n', '        amountUSDTForInvestor = principle.mul(99).div(100).add(interest.div(2));\n', '        amountUSDTToBincentiveCold = amountUSDTToWithdraw.sub(amountUSDTForInvestor);\n', '\n', '        // Check if `amountUSDTToBincentiveCold >= penalty`\n', '        if (amountUSDTToBincentiveCold < minPenalty) {\n', '            uint256 dif = minPenalty.sub(amountUSDTToBincentiveCold);\n', '            require(dif <= amountUSDTForInvestor, "Withdraw amount is not enough to cover minimum penalty");\n', '            amountUSDTForInvestor = amountUSDTForInvestor.sub(dif);\n', '            amountUSDTToBincentiveCold = minPenalty;\n', '        }\n', '\n', '        investorDepositUSDTAmount[investor] = investorDepositUSDTAmount[investor].sub(principle);\n', '\n', '        checkBalanceTransfer(investor, amountUSDTForInvestor);\n', '        checkBalanceTransfer(bincentiveCold, amountUSDTToBincentiveCold);\n', '\n', '        emit Withdraw(investor, tokenAmount, amountUSDTForInvestor, amountUSDTToBincentiveCold);\n', '\n', '        // Suspend the contract if not enough fund remained\n', '        if(totalSupply() == minimumFund) {\n', '            fundStatus = 7;\n', '        }\n', '    }\n', '\n', '    // Return AUM\n', '    // Transfer the fund back to the contract\n', '    function returnAUM(uint256 stableTokenAmount) runningOrSuspended isBincentiveCold public {\n', '        // Option 1: contract transfer AUM directly from bincentiveCold\n', '        checkBalanceTransferFrom(bincentiveCold, address(this), stableTokenAmount);\n', '\n', '        emit ReturnAUM(stableTokenAmount);\n', '\n', '        // If fund is running, stop the fund after AUM is returned\n', '        if(fundStatus == 4) fundStatus = 5;\n', '    }\n', '\n', '    // Add an overlay on top of underlying token transfer\n', '    // because token receiver should also be added to investor list to be able to receive AUM.\n', '    function transfer(address _to, uint256 _value) public returns (bool){\n', '        uint256 tokenBalanceBeforeTransfer = balances[msg.sender];\n', '        bool success = super.transfer(_to, _value);\n', '\n', '        if(success == true) {\n', '            if(isInInvestorList[_to] == false) {\n', '                investors.push(_to);\n', '                isInInvestorList[_to] = true;\n', '            }\n', '            // Also transfer the deposited USDT so the receiver can withdraw\n', '            uint256 USDTAmountToTransfer = investorDepositUSDTAmount[msg.sender].mul(_value).div(tokenBalanceBeforeTransfer);\n', '            investorDepositUSDTAmount[msg.sender] = investorDepositUSDTAmount[msg.sender].sub(USDTAmountToTransfer);\n', '            investorDepositUSDTAmount[_to] = investorDepositUSDTAmount[_to].add(USDTAmountToTransfer);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    // Add an overlay on top of underlying token transferFrom\n', '    // because token receiver should also be added to investor list to be able to receive AUM.\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\n', '        uint256 tokenBalanceBeforeTransfer = balances[_from];\n', '        bool success = super.transferFrom(_from, _to, _value);\n', '\n', '        if(success == true) {\n', '            if(isInInvestorList[_to] == false) {\n', '                investors.push(_to);\n', '                isInInvestorList[_to] = true;\n', '            }\n', '            // Also transfer the deposited USDT so the receiver can withdraw\n', '            uint256 USDTAmountToTransfer = investorDepositUSDTAmount[_from].mul(_value).div(tokenBalanceBeforeTransfer);\n', '            investorDepositUSDTAmount[_from] = investorDepositUSDTAmount[_from].sub(USDTAmountToTransfer);\n', '            investorDepositUSDTAmount[_to] = investorDepositUSDTAmount[_to].add(USDTAmountToTransfer);\n', '        }\n', '        return success;\n', '    }\n', '\n', '    function update_investor(address _old_address, address _new_address) public isBincentiveCold {\n', '        require((_new_address != bincentiveHot) && (_new_address != bincentiveCold), "Investor can not be bincentive accounts");\n', '        require(isInInvestorList[_old_address] == true, "Investor does not exist");\n', '\n', '        uint256 balance = balances[_old_address];\n', '        balances[_old_address] = balances[_old_address].sub(balance);\n', '        balances[_new_address] = balances[_new_address].add(balance);\n', '        emit Transfer(_old_address, _new_address, balance);\n', '        if(isInInvestorList[_new_address] == false) {\n', '            investors.push(_new_address);\n', '            isInInvestorList[_new_address] = true;\n', '        }\n', '        uint256 USDTAmountToTransfer = investorDepositUSDTAmount[_old_address];\n', '        investorDepositUSDTAmount[_old_address] = investorDepositUSDTAmount[_old_address].sub(USDTAmountToTransfer);\n', '        investorDepositUSDTAmount[_new_address] = investorDepositUSDTAmount[_new_address].add(USDTAmountToTransfer);\n', '    }\n', '\n', '    // Distribute AUM\n', '    // Dispense the fund returned to each investor according to his portion of the token he possessed.\n', '    // All withdraw requests should be processed before calling this function.\n', '    // Since there might be too many investors, each time this function is called,\n', '    // a parameter `numInvestorsToDistribute` is passed in to indicate how many investors to process this time.\n', '    function distributeAUM(uint256 numInvestorsToDistribute) stoppedOrSuspended isBincentive public {\n', '        require(numAUMDistributedInvestors.add(numInvestorsToDistribute) <= investors.length, "Distributing to more than total number of investors");\n', '\n', '        // Query Oracle for current stable token ratio\n', '        uint256 accruedRatioUSDT = oracle.query();\n', '\n', '        uint256 stableTokenDistributeAmount;\n', '        address investor;\n', '        uint256 investor_amount;\n', '        // Distribute Stable Token to investors\n', '        for(uint i = numAUMDistributedInvestors; i < (numAUMDistributedInvestors.add(numInvestorsToDistribute)); i++) {\n', '            investor = investors[i];\n', '            investor_amount = balances[investor];\n', '            if(investor_amount == 0) continue;\n', '            _burn(investor, investor_amount);\n', '\n', '            stableTokenDistributeAmount = investor_amount.mul(accruedRatioUSDT).div(baseRatio);\n', '            checkBalanceTransfer(investor, stableTokenDistributeAmount);\n', '\n', '            emit DistributeAUM(investor, investor_amount, stableTokenDistributeAmount);\n', '        }\n', '\n', '        numAUMDistributedInvestors = numAUMDistributedInvestors.add(numInvestorsToDistribute);\n', '        // If all investors have received AUM, then close the fund.\n', '        if(numAUMDistributedInvestors >= investors.length) {\n', '            currentInvestedAmount = 0;\n', '            // If fund is stopped, close the fund\n', '            if(fundStatus == 5) fundStatus = 6;\n', '        }\n', '    }\n', '\n', '    function claimWronglyTransferredFund() closedOrAbortedOrSuspended isBincentive public {\n', '        // withdraw leftover funds from Defi\n', '        uint256 totalcUSDTAmount;\n', '        totalcUSDTAmount = querycUSDTAmount();\n', '        redeemcUSDT(totalcUSDTAmount);\n', '\n', '        uint256 leftOverAmount = StableToken.balanceOf(address(this));\n', '        if(leftOverAmount > 0) {\n', '            checkBalanceTransfer(bincentiveCold, leftOverAmount);\n', '        }\n', '    }\n', '\n', '    function updateBincentiveColdAddress(address _newBincentiveCold) public isBincentiveCold {\n', '        require(_newBincentiveCold != address(0), "New BincentiveCold address can not be zero");\n', '\n', '        bincentiveCold = _newBincentiveCold;\n', '        emit NewBincentiveCold(_newBincentiveCold);\n', '    }\n', '\n', '    constructor(\n', '        address _oracle,\n', '        address _StableToken,\n', '        address _cToken,\n', '        address _bincentiveHot,\n', '        address _bincentiveCold,\n', '        uint256 _investPaymentPeriod,\n', '        uint256 _percentageOffchainFund,\n', '        uint256 _percentageMinimumFund) WhiteListToken(_bincentiveCold) public {\n', '\n', '        oracle = SimpleOracleAccruedRatioUSD(_oracle);\n', '        bincentiveHot = _bincentiveHot;\n', '        bincentiveCold = _bincentiveCold;\n', '        StableToken = ITetherERC20(_StableToken);\n', '        cToken = CERC20(_cToken);\n', '\n', '        decimals = StableToken.decimals();\n', '        minPenalty = 100 * (10 ** uint256(decimals));  // a minimum 100 USDT penalty\n', '        baseRatio = oracle.query();\n', '        require(baseRatio > 0, "baseRatio should always greater than zero");\n', '\n', '        // Set parameters\n', '        investPaymentDueTime = now.add(_investPaymentPeriod);\n', '        percentageOffchainFund = _percentageOffchainFund;\n', '        percentageMinimumFund = _percentageMinimumFund;\n', '\n', '        // Initialized the contract\n', '        fundStatus = 1;\n', '    }\n', '}']