['# @version 0.2.8\n', '"""\n', '@author Curve.Fi\n', '@license Copyright (c) Curve.Fi, 2020 - all rights reserved\n', '"""\n', '\n', '# The following code has been copied with minimal modifications from\n', '# https://github.com/curvefi/curve-contract/blob/3fa3b6c/contracts/pools/steth/StableSwapSTETH.vy\n', '\n', '\n', 'N_COINS: constant(int128) = 2\n', 'FEE_DENOMINATOR: constant(uint256) = 10 ** 10\n', 'A_PRECISION: constant(uint256) = 100\n', '\n', '\n', '@pure\n', '@internal\n', 'def get_D(xp: uint256[N_COINS], amp: uint256) -> uint256:\n', '    S: uint256 = 0\n', '    Dprev: uint256 = 0\n', '\n', '    for _x in xp:\n', '        S += _x\n', '    if S == 0:\n', '        return 0\n', '\n', '    D: uint256 = S\n', '    Ann: uint256 = amp * N_COINS\n', '    for _i in range(255):\n', '        D_P: uint256 = D\n', '        for _x in xp:\n', '            D_P = D_P * D / (_x * N_COINS + 1)  # +1 is to prevent /0\n', '        Dprev = D\n', '        D = (Ann * S / A_PRECISION + D_P * N_COINS) * D / ((Ann - A_PRECISION) * D / A_PRECISION + (N_COINS + 1) * D_P)\n', '        # Equality with the precision of 1\n', '        if D > Dprev:\n', '            if D - Dprev <= 1:\n', '                return D\n', '        else:\n', '            if Dprev - D <= 1:\n', '                return D\n', '    # convergence typically occurs in 4 rounds or less, this should be unreachable!\n', '    # if it does happen the pool is borked and LPs can withdraw via `remove_liquidity`\n', '    raise\n', '\n', '\n', '@view\n', '@internal\n', 'def get_y(i: int128, j: int128, x: uint256, xp: uint256[N_COINS], amp: uint256) -> uint256:\n', '    # x in the input is converted to the same price/precision\n', '\n', '    assert i != j       # dev: same coin\n', '    assert j >= 0       # dev: j below zero\n', '    assert j < N_COINS  # dev: j above N_COINS\n', '\n', '    # should be unreachable, but good for safety\n', '    assert i >= 0\n', '    assert i < N_COINS\n', '\n', '    D: uint256 = self.get_D(xp, amp)\n', '    Ann: uint256 = amp * N_COINS\n', '    c: uint256 = D\n', '    S_: uint256 = 0\n', '    _x: uint256 = 0\n', '    y_prev: uint256 = 0\n', '\n', '    for _i in range(N_COINS):\n', '        if _i == i:\n', '            _x = x\n', '        elif _i != j:\n', '            _x = xp[_i]\n', '        else:\n', '            continue\n', '        S_ += _x\n', '        c = c * D / (_x * N_COINS)\n', '    c = c * D * A_PRECISION / (Ann * N_COINS)\n', '    b: uint256 = S_ + D * A_PRECISION / Ann  # - D\n', '    y: uint256 = D\n', '    for _i in range(255):\n', '        y_prev = y\n', '        y = (y*y + c) / (2 * y + b - D)\n', '        # Equality with the precision of 1\n', '        if y > y_prev:\n', '            if y - y_prev <= 1:\n', '                return y\n', '        else:\n', '            if y_prev - y <= 1:\n', '                return y\n', '    raise\n', '\n', '\n', '@view\n', '@external\n', 'def get_dy(i: int128, j: int128, dx: uint256, xp: uint256[N_COINS], A: uint256, fee: uint256) -> uint256:\n', '    x: uint256 = xp[i] + dx\n', '    y: uint256 = self.get_y(i, j, x, xp, A)\n', '    dy: uint256 = xp[j] - y - 1\n', '    return dy - fee * dy / FEE_DENOMINATOR']