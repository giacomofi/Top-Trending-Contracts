['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// File: contracts/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/IHTLCs.sol\n', '\n', '// Copyright (C) 2021 Autonomous Worlds Ltd\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '/**\n', ' * @dev Interface for a contract that allows using HTLCs for ERC-20 tokens.\n', ' */\n', 'interface IHTLCs\n', '{\n', '\n', '  /**\n', '   * @dev Returns the hash used in HTLCs of the given data.\n', '   */\n', '  function hashData (bytes memory data) external pure returns (bytes20);\n', '\n', '  /**\n', '   * @dev Computes and returns the hash / ID of an HTLC corresponding\n', '   * to the given data.\n', '   */\n', '  function getId (IERC20 token, address from, address to, uint256 value,\n', '                  uint endtime, bytes20 hash) external pure returns (bytes32);\n', '\n', '  /**\n', '   * @dev Creates a new HTLC:  value tokens are removed from the message\n', '   * sender\'s balance and "locked" into the HTLC.  They can be reclaimed\n', '   * by the message sender at the endtime block time, or redeemed for the\n', '   * receiver if the preimage of hash is provided.\n', '   */\n', '  function create (IERC20 token, address to, uint256 value,\n', '                   uint endtime, bytes20 hash)\n', '      external returns (bytes32);\n', '\n', '  /**\n', '   * @dev Refunds a HTLC that has timed out.  All data for the HTLC has to be\n', '   * provided here again, and the contract will check that a HTLC with this\n', '   * data exists (as well as that it is timed out).\n', '   */\n', '  function timeout (IERC20 token, address from, address to, uint256 value,\n', '                    uint endtime, bytes20 hash) external;\n', '\n', '  /**\n', '   * @dev Redeems a HTLC with the preimage to the receiver.  The data\n', '   * for the HTLC has to be passed in (the hash is computed from the preimage).\n', '   */\n', '  function redeem (IERC20 token, address from, address to, uint256 value,\n', '                   uint endtime, bytes memory preimage) external;\n', '\n', '  /** @dev Emitted when a new HTLC has been created.  */\n', '  event Created (IERC20 token, address from, address to, uint256 value,\n', '                 uint endtime, bytes20 hash, bytes32 id);\n', '\n', '  /** @dev Emitted when a HTLC is timed out.  */\n', '  event TimedOut (IERC20 token, address from, address to, uint256 value,\n', '                  uint endtime, bytes20 hash, bytes32 id);\n', '\n', '  /** @dev Emitted when a HTLC is redeemed.  */\n', '  event Redeemed (IERC20 token, address from, address to, uint256 value,\n', '                  uint endtime, bytes20 hash, bytes32 id);\n', '\n', '}\n', '\n', '// File: contracts/HTLCs.sol\n', '\n', '// Copyright (C) 2021 Autonomous Worlds Ltd\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '\n', '/**\n', ' * @dev This contract allows creating (and redeeming) HTLCs based on RIPMED-160\n', ' * for ERC-20 tokens.  With this, those tokens can be used in atomic\n', ' * swaps e.g. with Bitcoin-based blockchains or even Lightning.\n', ' */\n', 'contract HTLCs is IHTLCs\n', '{\n', '\n', '  /**\n', '   * @dev Hashes of all currently active HTLCs.  Each HTLC consists of\n', "   * its token's address, the value in tokens, a sender and receiver address,\n", '   * a timestamp for when it times out, and a hash value with which the\n', '   * receiver can redeem it.\n', '   *\n', '   * These pieces of data are hashed together to produce an ID, which is\n', '   * stored here in a set.  This way, the contract can verify any claims about\n', '   * active HTLCs, while not having to store all the corresponding data\n', '   * itself in contract storage.\n', '   */\n', '  mapping (bytes32 => bool) public active;\n', '\n', '  /**\n', '   * @dev Returns the hash used for HTLCs.  We use RIPEMD160, to be\n', '   * compatible with HTLCs from BOLT 03 (Lightning).\n', '   */\n', '  function hashData (bytes memory data) public override pure returns (bytes20)\n', '  {\n', '    return ripemd160 (data);\n', '  }\n', '\n', '  /**\n', '   * @dev Computes and returns the ID that we use internally to refer\n', '   * to an HTLC with the given data.  This is a hash value of the data,\n', "   * so commits to the HTLC's content.\n", '   */\n', '  function getId (IERC20 token, address from, address to, uint256 value,\n', '                  uint endtime, bytes20 hash)\n', '      public override pure returns (bytes32)\n', '  {\n', '    return keccak256 (abi.encodePacked (address (token), from, to, value,\n', '                                        endtime, hash));\n', '  }\n', '\n', '  /**\n', '   * @dev Creates a new HTLC, locking the tokens and marking its hash as active.\n', '   */\n', '  function create (IERC20 token, address to, uint256 value,\n', '                   uint endtime, bytes20 hash)\n', '      external override returns (bytes32)\n', '  {\n', '    bytes32 id = getId (token, msg.sender, to, value, endtime, hash);\n', '    require (!active[id], "HTLCs: HTLC with this data is already active");\n', '\n', '    require (token.transferFrom (msg.sender, address (this), value),\n', '             "HTLCs: failed to receive tokens");\n', '    active[id] = true;\n', '\n', '    emit Created (token, msg.sender, to, value, endtime, hash, id);\n', '    return id;\n', '  }\n', '\n', '  /**\n', '   * @dev Times out an HTLC.  This can be called by anyone who wants to\n', '   * execute the transaction, and will pay back to the original sender\n', '   * who locked the tokens.\n', '   */\n', '  function timeout (IERC20 token, address from, address to, uint256 value,\n', '                    uint endtime, bytes20 hash) external override\n', '  {\n', '    require (block.timestamp >= endtime,\n', '             "HTLCs: HTLC is not yet timed out");\n', '\n', '    bytes32 id = getId (token, from, to, value, endtime, hash);\n', '    require (active[id], "HTLCs: HTLC with this data is not active");\n', '\n', '    delete active[id];\n', '    require (token.transfer (from, value), "HTLCs: failed to send tokens");\n', '\n', '    emit TimedOut (token, from, to, value, endtime, hash, id);\n', '  }\n', '\n', '  /**\n', '   * @dev Redeems an HTLC with its preimage to the receiver.  This can be\n', '   * called by anyone willing to pay for execution, and will send the tokens\n', "   * always to the HTLC's receiver.\n", '   */\n', '  function redeem (IERC20 token, address from, address to, uint256 value,\n', '                   uint endtime, bytes memory preimage) external override\n', '  {\n', '    bytes20 hash = hashData (preimage);\n', '    bytes32 id = getId (token, from, to, value, endtime, hash);\n', '    /* Since we compute the hash from the preimage, and then the HTLC ID\n', '       from the hash, the check below automatically verifies that the\n', '       sender knows a preimage to the HTLC.  */\n', '    require (active[id], "HTLCs: HTLC with this data is not active");\n', '\n', '    delete active[id];\n', '    require (token.transfer (to, value), "HTLCs: failed to send tokens");\n', '\n', '    emit Redeemed (token, from, to, value, endtime, hash, id);\n', '  }\n', '\n', '}']