['// contracts/RealCryptoPunks.sol\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC721URIStorage.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract RealCryptoPunks is ERC721URIStorage, Ownable {\n', '    uint256 public constant MAX_NFT_SUPPLY = 10000;\n', '    bool public saleStarted = false;\n', '    mapping(address => uint256) private _bonusBalance;\n', '    uint256 public _counter = 110;\n', '    uint256 public _ownerCounter;\n', '    \n', '    constructor() ERC721("RealCryptoPunks by VT3.com", "RCP") {}\n', '    \n', '    function _baseURI() internal view virtual override returns (string memory) {\n', '        return "https://realcryptopunks.com/api/";\n', '    }\n', '    \n', '    function getPrice() public view returns (uint256) {\n', '        require(_counter < MAX_NFT_SUPPLY, "Sale has ended.");\n', '        uint256 currentSupply = _counter;\n', '        if (currentSupply >= 9500) { \n', '            return 1500000000000000000; // 1.5 ETH\n', '        } else if (currentSupply >= 9000) { \n', '            return 1200000000000000000; // 1.2 ETH\n', '        } else if (currentSupply >= 8500) { \n', '            return 800000000000000000; // 0.8 ETH\n', '        } else if (currentSupply >= 8000) { \n', '            return 650000000000000000; // 0.65 ETH\n', '        } else if (currentSupply >= 7500) { \n', '            return 500000000000000000; // 0.5 ETH\n', '        } else if (currentSupply >= 7000) { \n', '            return 400000000000000000; // 0.4 ETH\n', '        } else if (currentSupply >= 6500) { \n', '            return 300000000000000000; // 0.3 ETH\n', '        } else if (currentSupply >= 6000) { \n', '            return 250000000000000000; // 0.25 ETH\n', '        } else if (currentSupply >= 5500) { \n', '            return 200000000000000000; // 0.2 ETH\n', '        } else if (currentSupply >= 5000) { \n', '            return 150000000000000000; // 0.15 ETH\n', '        } else if (currentSupply >= 4500) { \n', '            return 100000000000000000; // 0.1 ETH\n', '        } else if (currentSupply >= 4000) { \n', '            return 85000000000000000; // 0.085 ETH\n', '        } else if (currentSupply >= 3500) { \n', '            return 70000000000000000; // 0.07 ETH\n', '        } else if (currentSupply >= 3000) { \n', '            return 60000000000000000; // 0.06 ETH\n', '        } else if (currentSupply >= 2500) { \n', '            return 50000000000000000; // 0.05 ETH\n', '        } else if (currentSupply >= 2000) { \n', '            return 40000000000000000; // 0.04 ETH\n', '        } else if (currentSupply >= 1500) { \n', '            return 30000000000000000; // 0.03 ETH\n', '        } else if (currentSupply >= 1000) { \n', '            return 20000000000000000; // 0.02 ETH\n', '        } else if (currentSupply >= 500) { \n', '            return 10000000000000000; // 0.01 ETH\n', '        } else {  \n', '            return 5000000000000000; // 0.005 ETH  \n', '        }\n', '    }\n', '    \n', '    function buyPunks(uint256 amount, address refferer) public payable {\n', '        require(saleStarted == true, "Sale has not started.");\n', '        require(_counter < MAX_NFT_SUPPLY, "Supply has ended.");\n', '        require(amount > 0, "You must buy at least one RealCryptoPunk.");\n', '        require(amount <= 25, "You can only buy max 25 RealCryptoPunks at a time.");\n', '        require(_counter + amount <= MAX_NFT_SUPPLY, "The amount you are trying to buy exceeds MAX_NFT_SUPPLY.");\n', '        if (amount == 25){\n', '            require(getPrice() / 100 * 75 * amount == msg.value, "Incorrect Ether value.");\n', '        } else if (amount >= 10) {\n', '            require(getPrice() / 100 * 90 * amount == msg.value, "Incorrect Ether value.");\n', '        } else {\n', '            require(getPrice() * amount == msg.value, "Incorrect Ether value.");\n', '        }\n', '        \n', '        for (uint256 i = 0; i < amount; i++) {\n', '            _safeMint(msg.sender, _counter + i);\n', '            if (_counter == 9999){\n', '                _safeMint(msg.sender, 10000);\n', '            }\n', '            \n', '            _bonusBalance[msg.sender] = _bonusBalance[msg.sender] + 10;\n', '            if (refferer != msg.sender && refferer != address(0)){\n', '                _bonusBalance[refferer] = _bonusBalance[refferer] + 5;\n', '            }\n', '        }\n', '        \n', '        _counter += amount;\n', '    }\n', '    \n', '    function redeemPunks(uint256 amount) public {\n', '        require(saleStarted == true, "Sale has not started.");\n', '        require(_counter < 9999, "Supply has ended.");\n', '        require(amount > 0, "You must buy at least one RealCryptoPunk.");\n', '        require(amount <= 10, "You can only buy max 10 RealCryptoPunks at a time.");\n', '        require(_counter + amount <= 9999, "The amount you are trying to buy exceeds 9999.");\n', '        require(100 * amount <= bonusBalanceOf(msg.sender), "Not enough bonus points.");\n', '        for (uint256 i = 0; i < amount; i++) {\n', '            _safeMint(msg.sender, _counter + i);\n', '        }\n', '        _counter += amount;\n', '        _bonusBalance[msg.sender] = _bonusBalance[msg.sender] - (100 * amount);\n', '    }\n', '    \n', '    function ownerMint(uint256 amount, address to) public onlyOwner{\n', '        require(to != address(0), "ERC721: query for the zero address");\n', '        require(_ownerCounter < _counter, "Supply has ended.");\n', '        require(amount > 0, "You must buy at least one RealCryptoPunk.");\n', '        require(_ownerCounter + amount <= 110, "The amount you are trying to buy exceeds max owner mint.");\n', '        for (uint256 i = 0; i < amount; i++) {\n', '            _safeMint(to, _ownerCounter + i);\n', '        }\n', '        _ownerCounter += amount;\n', '    }\n', '    \n', '    function bonusBalanceOf(address owner) public view returns(uint256){\n', '        require(owner != address(0), "ERC721: query for the zero address");\n', '        return _bonusBalance[owner];\n', '    }\n', '    \n', '    function tokensOfOwner(address owner) external view returns(uint256[] memory ownerTokens) {\n', '        uint256 tokenCount = balanceOf(owner);\n', '\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            uint256 resultIndex = 0;\n', '\n', '            for (uint256 id = 0; id <= MAX_NFT_SUPPLY; id++) {\n', '                if (_exists(id)){\n', '                    if (ownerOf(id) == owner) {\n', '                        result[resultIndex] = id;\n', '                        resultIndex++;\n', '                    }\n', '                }\n', '            }\n', '\n', '            return result;\n', '        }\n', '    }\n', '    \n', '    function withdrawAll() public payable onlyOwner{\n', '        require(payable(msg.sender).send(address(this).balance));\n', '    }\n', '\n', '    function startDrop() public onlyOwner{\n', '        saleStarted = true;\n', '    }\n', '\n', '    function pauseDrop() public onlyOwner{\n', '        saleStarted = false;\n', '    }\n', '        \n', '}']