['pragma solidity ^0.7.0;\n', '\n', 'import "SafeMath.sol";\n', '\n', "import 'IERC20.sol';\n", "import 'ICommune.sol';\n", '\n', 'contract Commune is ICommune {\n', '    using SafeMath for uint256;\n', '\n', '    struct aCommune {\n', '        bool allowsJoining;\n', '        bool allowsRemoving;\n', '        bool allowsOutsideContribution;\n', '        address asset;\n', '        uint256 proratedTotal;\n', '        uint256 memberCount;\n', '        address controller;\n', '        string uri;\n', '    }\n', '\n', '    mapping (uint256 => aCommune) public getCommune;\n', '\n', '    // maybe we should rather use \n', '    // mapping (address => EnumerableSet.UintSet) private _holderTokens;\n', '    // like https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L33\n', '    mapping (uint256 => mapping(address => bool)) private _isCommuneMember;\n', '    \n', '    // commune -> address -> balance\n', '    mapping (uint256 => mapping (address => uint256)) private _balanceAtJoin;\n', '\n', '    // commune -> address -> balance \n', '    mapping (uint256 => mapping (address => uint256)) private _spentBalance;\n', '\n', '    // in basis points, 0 through 500, i.e. max take 5%\n', '    uint256 private _feeRate = 100;\n', '\n', '    // where fee goes to\n', '    address private _treasuryAddress;\n', '\n', '    // for creating new commune IDs\n', '    uint256 private _nonce;\n', '\n', '    // can update treasury address and fee rate \n', '    address private _controllerAddress;\n', '\n', '\n', '    // Getters /// \n', '\n', '    function numberOfCommunes() external override view returns (uint256){\n', '        return _nonce;\n', '    }\n', '\n', '    function isCommuneMember(uint256 commune, address account) external communeExists(commune) override view returns (bool){\n', '        return _isCommuneMember[commune][account];\n', '    }\n', '\n', '    function feeRate() external override view returns (uint256){\n', '        return _feeRate;\n', '    }\n', '\n', '    function treasuryAddress() external override view returns (address){\n', '        return _treasuryAddress;\n', '    }\n', '\n', '    function controller() external override view returns (address){\n', '        return _controllerAddress;\n', '    }\n', '    \n', '\n', '    // modifiers \n', '    modifier controllerOnly(){\n', '        require(msg.sender == _controllerAddress, "Commune: only contract controller can do this");\n', '        _;\n', '    }\n', '\n', '    modifier communeControllerOnly(uint256 commune){\n', '        require(getCommune[commune].controller == msg.sender, "Commune: only the commune controller can do this");\n', '        _;\n', '    }\n', '\n', '    modifier communeExists(uint256 commune){\n', '        require(commune <= _nonce, "Commune: commune does not exists");\n', '        _;\n', '    }\n', '\n', '    function contribute(uint256 amount, uint256 commune) external communeExists(commune) override { \n', '        require(_isCommuneMember[commune][msg.sender] || getCommune[commune].allowsOutsideContribution, "Commune: Must be a member to contribute");\n', '        require(getCommune[commune].memberCount > 0, "Commune: commune has no members, cannot accept contributions");\n', '\n', '        address assetAddress = getCommune[commune].asset;\n', '        IERC20 asset = IERC20(assetAddress);\n', '\n', '        uint256 fee = amount\n', '            .mul(_feeRate)\n', '            .div(10000);\n', '        \n', '        uint256 amountToCommune = amount\n', '            .sub(fee)\n', '            .div(getCommune[commune].memberCount);\n', '\n', '        asset.transferFrom(msg.sender, address(this), amountToCommune);\n', '        asset.transferFrom(msg.sender, _treasuryAddress, fee);\n', '\n', '        getCommune[commune].proratedTotal = getCommune[commune].proratedTotal.add(amountToCommune);\n', '\n', '        emit Contribute(msg.sender, commune, amount);\n', '    }\n', '\n', '    /**\n', '        @dev _uri should link to a JSON file of the form \n', '        {\n', '            "title": "Commune Title",\n', '            "description": "Commune description"\n', '        }\n', '    */\n', '    function createCommune(string memory _uri, address asset, bool allowJoining, bool allowRemoving, bool allowOutsideContribution) external override returns(uint256 _id) {  \n', '        require((!allowJoining && allowRemoving) || (allowJoining && !allowRemoving) || (!allowJoining && !allowRemoving), "Commune: cannot both allow joining and removing");\n', '\n', '        _id = ++_nonce;\n', '\n', '        getCommune[_id].controller = msg.sender;\n', '        getCommune[_id].allowsJoining = allowJoining;\n', '        getCommune[_id].allowsRemoving = allowRemoving;\n', '        getCommune[_id].allowsOutsideContribution = allowOutsideContribution;\n', '        getCommune[_id].asset = asset;\n', '        getCommune[_id].uri = _uri;\n', '\n', '        emit URI(_uri, _id);\n', '    }\n', '\n', '    //Join/Add Functions\n', '    function joinCommune(uint256 commune) external override {\n', '        require(getCommune[commune].allowsJoining, "Commune: commune does not allow joining");\n', '        _addCommuneMember(msg.sender, commune);\n', '    }\n', '\n', '    function addCommuneMember(address account, uint256 commune) external communeControllerOnly(commune) override {\n', '        _addCommuneMember(account, commune);\n', '    }\n', '\n', '    function _addCommuneMember(address account, uint256 commune) private communeExists(commune) {\n', '        require(!_isCommuneMember[commune][account], "Commune: account is already in commune");\n', '\n', '        _isCommuneMember[commune][account] = true;\n', '        ++getCommune[commune].memberCount;\n', '        _balanceAtJoin[commune][account] = getCommune[commune].proratedTotal;\n', '\n', '        emit AddCommuneMember(account, commune);\n', '    }\n', '\n', '\n', '    // Leave/Remove Functions\n', '    function leaveCommune(uint256 commune) external override {\n', '        _removeCommuneMember(msg.sender, commune);\n', '    }\n', '\n', '    function removeCommuneMember(address account, uint256 commune) external communeControllerOnly(commune) override {\n', '        require(getCommune[commune].allowsRemoving, "Commune: commune does not allow removing");\n', '\n', '        _removeCommuneMember(account, commune);\n', '    }\n', '\n', '    function _removeCommuneMember(address account, uint256 commune) private communeExists(commune) {\n', '        require(_isCommuneMember[commune][account], "Commune: account is not in commune");\n', '\n', '        _isCommuneMember[commune][account] = false;\n', '        getCommune[commune].memberCount = getCommune[commune].memberCount.sub(1);\n', "        // we reset the spent balance, incase they'e added back later, to prevent a negative number \n", '         _spentBalance[commune][account] = 0;\n', '\n', '        emit RemoveCommuneMember(account, commune);\n', '    }\n', '\n', '\n', '\n', '    constructor(address _controller) {\n', '        _setURI("your-uri-here");\n', '\n', '        _controllerAddress = _controller;\n', '        _treasuryAddress = _controller;\n', '    }\n', '\n', '    /// controller functions ///\n', '\n', '    function updateCommuneController(address account, uint256 commune) external communeControllerOnly(commune) override {\n', '        getCommune[commune].controller = account;\n', '\n', '        emit UpdateCommuneController(account, commune);\n', '    }\n', '\n', '    function updateCommuneURI(string memory _uri, uint256 commune) external communeControllerOnly(commune) override {\n', '        getCommune[commune].uri = _uri;\n', '\n', '        emit URI(_uri, commune);\n', '    }\n', '\n', '    function updateController(address account) external controllerOnly override {\n', '        _controllerAddress = account;\n', '\n', '        emit UpdateController(account);\n', '    }\n', '\n', '    function updateFee(uint256 rate) external controllerOnly override {\n', '        // max fee is 5%\n', '        require(rate <= 500 && rate >= 0, "Commune: fee rate must be between 0 and 500");\n', '        _feeRate = rate;\n', '\n', '        emit UpdateFee(rate);\n', '    }\n', '\n', '    function setTreasuryAddress(address newTreasury) external controllerOnly override {\n', '        _treasuryAddress = newTreasury;\n', '\n', '        emit UpdateTreasuryAddress(newTreasury);\n', '    }\n', '\n', '    // boiler, mostly ripped from ERC1155 then modified\n', '\n', '    // Mapping from account to operator approvals\n', '    mapping (address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    string private _uri;\n', '    \n', '    function uri(uint256 commune) communeExists(commune) external view  returns (string memory) {\n', '\n', '        string memory _communeURI = getCommune[commune].uri;\n', '\n', '        // if the commune URI is set, return it. Note, might still need to replace `\\{id\\}`\n', '        if (bytes(_communeURI).length > 0) {\n', '            return _communeURI;\n', '        } \n', '\n', '        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n', '        return _uri;\n', '    }\n', '\n', '    function _setURI(string memory newuri) internal virtual {\n', '        _uri = newuri;\n', '    }\n', '\n', '    function balanceOf(address account, uint256 commune) public view virtual override returns (uint256) {\n', '        require(account != address(0), "Commune: balance query for the zero address");\n', '        if(!_isCommuneMember[commune][account]){\n', '            return 0;\n', '        }\n', '        return getCommune[commune].proratedTotal\n', '            .sub(_balanceAtJoin[commune][account])\n', '            .sub(_spentBalance[commune][account]);\n', '    }\n', '\n', '    /**\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(\n', '        address[] memory accounts,\n', '        uint256[] memory ids\n', '    )\n', '        public\n', '        view\n', '        override\n', '        returns (uint256[] memory)\n', '    {\n', '        require(accounts.length == ids.length, "Commune: accounts and ids length mismatch");\n', '\n', '        uint256[] memory batchBalances = new uint256[](accounts.length);\n', '\n', '        for (uint256 i = 0; i < accounts.length; ++i) {\n', '            require(accounts[i] != address(0), "Commune: batch balance query for the zero address");\n', '            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n', '        }\n', '\n', '        return batchBalances;\n', '    }\n', '\n', '\n', '    function setApprovalForAll(address operator, bool approved) public virtual {\n', '        require(msg.sender != operator, "Commune: setting approval status for self");\n', '\n', '        _operatorApprovals[msg.sender][operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '\n', '\n', '    function isApprovedForAll(address account, address operator) public view returns (bool) {\n', '        return _operatorApprovals[account][operator];\n', '    }\n', '\n', '    function withdraw(address account, address to, uint256 commune, uint256 amount) public override {\n', '        require(to != address(0), "Commune: Cannot withdraw to the zero address");\n', '        require(\n', '            account == msg.sender || isApprovedForAll(account, msg.sender),\n', '            "Commune: Caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = msg.sender;\n', '\n', '        balanceOf(account, commune).sub(amount, "Commune: withdraw amount exceeds balance");\n', '        _spentBalance[commune][account] = _spentBalance[commune][account].add(amount);\n', '\n', '        IERC20(getCommune[commune].asset).transfer(to, amount);\n', '\n', '        emit Withdraw(operator, account, to, commune, amount);\n', '    }\n', '\n', '    function withdrawBatch(address account, address to, uint256[] memory communes, uint256[] memory amounts) public override {\n', '        require(to != address(0), "Commune: Cannot withdraw to the zero address");\n', '        require(\n', '            account == msg.sender || isApprovedForAll(account, msg.sender),\n', '            "Commune: Caller is not owner nor approved"\n', '        );\n', '\n', '        address operator = msg.sender;\n', '\n', '        for (uint i = 0; i < communes.length; i++) {\n', '            balanceOf(account, communes[i]).sub(amounts[i], "Commune: withdraw amount exceeds balance");\n', '            _spentBalance[communes[i]][account] = _spentBalance[communes[i]][account].add(amounts[i]);\n', '            IERC20(getCommune[communes[i]].asset).transfer(to, amounts[i]);\n', '        }\n', '\n', '        emit WithdrawBatch(operator, account, to, communes, amounts);\n', '    }\n', '    \n', '}']