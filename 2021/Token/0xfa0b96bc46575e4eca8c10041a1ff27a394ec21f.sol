['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-19\n', '*/\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow.");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow.");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow.");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero.");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero.");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '\n', '    uint256 public _totalSupply;\n', '    mapping (address => uint256) public _balanceOf;\n', '    mapping (address => mapping (address => uint256)) public _allowance;\n', '\n', '    constructor (string memory _name, string memory _symbol, uint8 _decimals) {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        decimals = _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balanceOf[account];\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return _allowance[owner][spender];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public override returns (bool _success) {\n', '        _allowance[msg.sender][_spender] = _value;\n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address _to, uint256 _value) public override returns (bool _success) {\n', '        require(_to != address(0), "ERC20: Recipient address is null.");\n', '        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool _success) {\n', '        require(_to != address(0), "ERC20: Recipient address is null.");\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_value);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_value);\n', '        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function _mint(address _to, uint256 _amount) internal {\n', '        _totalSupply = _totalSupply.add(_amount);\n', '        _balanceOf[_to] = _balanceOf[_to].add(_amount);\n', '        emit Transfer(address(0), _to, _amount);\n', '    }\n', '\n', '    function _burn(address _from, uint256 _amount) internal {\n', '        require(_from != address(0), "ERC20: Burning from address 0.");\n', '        _balanceOf[_from] = _balanceOf[_from].sub(_amount, "ERC20: burn amount exceeds balance.");\n', '        _totalSupply = _totalSupply.sub(_amount);\n', '        emit Transfer(_from, address(0), _amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <[email\xa0protected]Ï€.com>, Eenae <[email\xa0protected]>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor() {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', 'contract WrappedNFT is ERC20, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    IERC721 public nftAddress=IERC721(0x50f5474724e0Ee42D9a4e711ccFB275809Fd6d4a);\n', '    uint256[] public depositedNftTokenIds;\n', '    mapping (uint256 => bool) private tokenIdIsDeposited;\n', '    \n', '    event NftWrapped(uint256 axieId);\n', '    event NftUnwrapped(uint256 axieId);\n', '\n', '    constructor(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint8 _decimals\n', '    ) ERC20(_name, _symbol, _decimals) {\n', '    }\n', '\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint32 _size;\n', '        assembly {\n', '            _size:= extcodesize(_addr)\n', '        }\n', '        return (_size > 0);\n', '    }\n', '\n', '    function wrap(uint256[] calldata _IdsToWrap) external nonReentrant {\n', '        for (uint256 i = 0; i < _IdsToWrap.length; i++) {\n', '            depositedNftTokenIds.push(_IdsToWrap[i]);\n', '            tokenIdIsDeposited[_IdsToWrap[i]] = true;\n', '            nftAddress.safeTransferFrom(msg.sender, address(this), _IdsToWrap[i]);\n', '            emit NftWrapped(_IdsToWrap[i]);\n', '        }\n', '        _mint(msg.sender, _IdsToWrap.length * (10**decimals));\n', '    }\n', '\n', '    function _popNft() internal returns(uint256){\n', "        require(depositedNftTokenIds.length > 0, 'there are no NFTs in the array');\n", '        uint256 tokenId = depositedNftTokenIds[depositedNftTokenIds.length -1];\n', '        depositedNftTokenIds.pop();\n', '        while(tokenIdIsDeposited[tokenId] == false){\n', '            tokenId = depositedNftTokenIds[depositedNftTokenIds.length - 1];\n', '            depositedNftTokenIds.pop();\n', '        }\n', '        tokenIdIsDeposited[tokenId] = false;\n', '        return tokenId;\n', '    }\n', '    \n', '    function unwrap(uint256 _amount) external nonReentrant {\n', '        _burn(msg.sender, _amount * (10**decimals));\n', '        for (uint256 i = 0; i < _amount; i++) {\n', '            uint256 _tokenId = _popNft();\n', '            nftAddress.safeTransferFrom(address(this), msg.sender, _tokenId);\n', '            emit NftUnwrapped(_tokenId);\n', '        }\n', '    }\n', '\n', '    function unwrapFor(uint256 _amount, address _recipient) external nonReentrant {\n', '        require(_recipient != address(0), "WrappedNFT: Cannot send to void address.");\n', '        _burn(msg.sender, _amount * (10**decimals));\n', '        for (uint256 i = 0; i < _amount; i++) {\n', '            uint256 _tokenId = _popNft();\n', '            nftAddress.safeTransferFrom(address(this), _recipient, _tokenId);\n', '            emit NftUnwrapped(_tokenId);\n', '        }\n', '    }\n', '\n', '    function unwrapFor(uint256[] calldata _tokenIds, address _recipient) external nonReentrant {\n', '        require(_recipient != address(0), "WrappedNFT: Cannot send to void address.");\n', '        uint256 numTokensToBurn = _tokenIds.length;\n', '        _burn(msg.sender, numTokensToBurn * (10**decimals));\n', '        for (uint256 i = 0; i < numTokensToBurn; i++) {\n', '            uint256 _tokenIdToWithdraw = _tokenIds[i];\n', "            require(tokenIdIsDeposited[_tokenIdToWithdraw] == true, 'this NFT has already been withdrawn');\n", '            tokenIdIsDeposited[_tokenIdToWithdraw] = false;\n', '            nftAddress.safeTransferFrom(address(this), _recipient, _tokenIdToWithdraw);\n', '            emit NftUnwrapped(_tokenIdToWithdraw);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Receiver-onERC721Received}.\n', '     *\n', '     * Always returns `IERC721Receiver.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n', '        require(msg.sender == address(nftAddress), "Not proper NFT");\n', '        return this.onERC721Received.selector;\n', '    }\n', '}']