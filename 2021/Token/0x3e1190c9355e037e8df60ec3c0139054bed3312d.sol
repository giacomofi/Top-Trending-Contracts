['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-08\n', '*/\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.1;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract TokenVesting {\n', '\n', '  event TrancheCreated(uint8 indexed tranche_id, uint256 cliff_start, uint256 duration);\n', '  event TrancheBalanceAdded(address indexed user, uint8 indexed tranche_id, uint256 amount);\n', '  event TrancheBalanceRemoved(address indexed user, uint8 indexed tranche_id, uint256 amount);\n', '  event StakeDeposited(address indexed user, uint256 amount, bytes32 vega_public_key);\n', '  event StakeRemoved(address indexed user, uint256 amount);\n', '  event IssuerPermitted(address indexed issuer, uint256 amount);\n', '  event IssuerRevoked(address indexed issuer);\n', '  event ControllerSet(address indexed new_controller);\n', '\n', '  /// @notice controller is similar to "owner" in other contracts\n', '  address public controller;\n', '  /// @notice tranche_count starts at 1 to cause tranche 0 (perma-lock) to exist as the default tranche\n', '  uint8 public tranche_count = 1;\n', '  /// @notice user => has been migrated\n', '  mapping(address => bool) public v1_migrated;\n', '  /// @notice user => user_stat struct\n', '  mapping(address=> user_stat) public user_stats;\n', '  /// @notice total_locked is the total amount of tokens "on" this contract that are locked into a tranche\n', '  uint256 public total_locked;\n', "  /// @notice v1_address is the address for Vega's v1 ERC20 token that has already been deployed\n", '  address public v1_address; // mainnet = 0xD249B16f61cB9489Fe0Bb046119A48025545b58a;\n', "  /// @notice v2_address is the address for Vega's v2 ERC20 token that replaces v1\n", '  address public v2_address;\n', '  /// @notice accuracy_scale is the multiplier to assist in integer division\n', '  uint256 constant public accuracy_scale = 100000000000;\n', '  /// @notice default_tranche_id is the tranche_id for the default tranche\n', '  uint8 constant public default_tranche_id = 0;\n', '\n', '  /****ADDRESS MIGRATION**/\n', '  /// @notice new address => old address\n', '  mapping(address => address) public address_migration;\n', '  /*****/\n', '\n', "  /// @param token_v1_address Vega's already deployed v1 ERC20 token address\n", "  /// @param token_v2_address Vega's v2 ERC20 token and the token being vested here\n", '  /// @dev emits Controller_Set event\n', '  constructor(address token_v1_address, address token_v2_address, address[] memory old_addresses, address[] memory new_addresses) {\n', '    require(old_addresses.length == new_addresses.length, "array length mismatch");\n', '\n', '    for(uint8 map_idx = 0; map_idx < old_addresses.length; map_idx++) {\n', '      v1_migrated[old_addresses[map_idx]] = true;\n', '      address_migration[new_addresses[map_idx]] = old_addresses[map_idx];\n', '    }\n', '\n', '    v1_address = token_v1_address;\n', '    /// @notice this initializes the total_locked with the amount of already issued v1 VEGA ERC20 tokens\n', '    total_locked = IERC20(token_v1_address).totalSupply() - IERC20(token_v1_address).balanceOf(token_v1_address);\n', '    v2_address = token_v2_address;\n', '    controller = msg.sender;\n', '    emit ControllerSet(controller);\n', '  }\n', '\n', '  /// @notice tranche_balance has the params necessary to track what a user is owed in a single tranche\n', '  /// @param total_deposited is the total number of tokens deposited into this single tranche for a single user\n', '  /// @param total_claimed is the total number of tokens in this tranche that have been withdrawn\n', '  struct tranche_balance {\n', '      uint256 total_deposited;\n', '      uint256 total_claimed;\n', '  }\n', '\n', "  /// @notice user_stat is a struct that holds all the details needed to handle a single user's vesting\n", '  /// @param total_in_all_tranches is the total number of tokens currently in all tranches that have been migrated to v2\n', '  /// @param lien total amount of locked tokens that have been marked for staking\n', '  /// @param tranche_balances is a mapping of tranche_id => tranche_balance\n', '  struct user_stat {\n', '    uint256 total_in_all_tranches;\n', '    uint256 lien;\n', '    mapping (uint8 => tranche_balance) tranche_balances;\n', '  }\n', '\n', '  /// @notice tranche is a struct that hold the details needed for calculating individual tranche vesting\n', '  /// @param cliff_start is a timestamp after which vesting starts\n', '  /// @param duration is the number of seconds after cliff_start until the tranche is 100% vested\n', '  struct tranche {\n', '    uint256 cliff_start;\n', '    uint256 duration;\n', '  }\n', '\n', '  /// @notice tranche_id => tranche struct\n', '  mapping(uint8 => tranche) public tranches;\n', '  /// @notice issuer address => permitted issuance allowance\n', '  mapping(address => uint256) public permitted_issuance;\n', '\n', '  /// @notice this function allows the contract controller to create a tranche\n', '  /// @notice tranche zero is perma-locked and already exists prior to running this function, making the first vesting tranche "tranche:1"\n', '  /// @param cliff_start is a timestamp in seconds of when vesting begins for this tranche\n', '  /// @param duration is the number of seconds after cliff_start that the tranche will be fully vested\n', '  function create_tranche(uint256 cliff_start, uint256 duration) public only_controller {\n', '    tranches[tranche_count] = tranche(cliff_start, duration);\n', '    emit TrancheCreated(tranche_count, cliff_start, duration);\n', '    /// @notice sol ^0.8 comes with auto-overflow protection\n', '    tranche_count++;\n', '  }\n', '\n', '  /// @notice this function allows the conroller or permitted issuer to issue tokens from this contract itself (no tranches) into the specified tranche\n', '  /// @notice tranche MUST be created\n', '  /// @notice once assigned to a tranche, tokens can never be clawed back, but they can be reassigned IFF they are in tranche_id:0\n', '  /// @param user The user being issued the tokens\n', '  /// @param tranche_id the id of the target tranche\n', '  /// @param amount number of tokens to be issued into tranche\n', '  /// @dev emits Tranche_Balance_Added event\n', '  function issue_into_tranche(address user, uint8 tranche_id, uint256 amount) public controller_or_issuer {\n', '    require(tranche_id < tranche_count, "tranche_id out of bounds");\n', '    if(permitted_issuance[msg.sender] > 0){\n', '      /// @dev if code gets here, they are an issuer if not they must be the controller\n', '      require(permitted_issuance[msg.sender] >= amount, "not enough permitted balance");\n', '      require(user != msg.sender, "cannot issue to self");\n', '      permitted_issuance[msg.sender] -= amount;\n', '    }\n', '    require( IERC20(v2_address).balanceOf(address(this)) - (total_locked + amount) >= 0, "contract token balance low" );\n', '\n', '    /// @dev only runs once\n', '    if(!v1_migrated[user]){\n', '      uint256 bal = v1_bal(user);\n', '      user_stats[user].tranche_balances[0].total_deposited += bal;\n', '      user_stats[user].total_in_all_tranches += bal;\n', '      v1_migrated[user] = true;\n', '    }\n', '    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\n', '    user_stats[user].total_in_all_tranches += amount;\n', '    total_locked += amount;\n', '    emit TrancheBalanceAdded(user, tranche_id, amount);\n', '  }\n', '\n', '\n', '  /// @notice this function allows the controller to move tokens issued into tranche zero to the target tranche\n', '  /// @notice can only be moved from tranche 0\n', '  /// @param user The user being issued the tokens\n', '  /// @param tranche_id the id of the target tranche\n', '  /// @param amount number of tokens to be moved from tranche 0\n', '  /// @dev emits Tranche_Balance_Removed event\n', '  /// @dev emits Tranche_Balance_Added event\n', '  function move_into_tranche(address user, uint8 tranche_id, uint256 amount) public only_controller {\n', '    require(tranche_id > 0 && tranche_id < tranche_count);\n', '\n', '    /// @dev only runs once\n', '    if(!v1_migrated[user]){\n', '      uint256 bal = v1_bal(user);\n', '      user_stats[user].tranche_balances[default_tranche_id].total_deposited += bal;\n', '      user_stats[user].total_in_all_tranches += bal;\n', '      v1_migrated[user] = true;\n', '    }\n', '    require(user_stats[user].tranche_balances[default_tranche_id].total_deposited >= amount);\n', '    user_stats[user].tranche_balances[default_tranche_id].total_deposited -= amount;\n', '    user_stats[user].tranche_balances[tranche_id].total_deposited += amount;\n', '    emit TrancheBalanceRemoved(user, default_tranche_id, amount);\n', '    emit TrancheBalanceAdded(user, tranche_id, amount);\n', '  }\n', '\n', '  /// @notice this view returns the balance of the given tranche for the given user\n', "  /// @notice tranche 0 balance of a non-v1_migrated user will return user's v1 token balance as they are pre-issued to the current hodlers\n", '  /// @param user Target user address\n', '  /// @param tranche_id target tranche\n', '  /// @return balance of target tranche of user\n', '  function get_tranche_balance(address user, uint8 tranche_id) public view returns(uint256) {\n', '    if(tranche_id == default_tranche_id && !v1_migrated[user]){\n', '      return v1_bal(user);\n', '    } else {\n', '      return user_stats[user].tranche_balances[tranche_id].total_deposited - user_stats[user].tranche_balances[tranche_id].total_claimed;\n', '    }\n', '  }\n', '\n', '  /// @notice This view returns the amount that is currently vested in a given tranche\n', '  /// @notice This does NOT take into account any current lien\n', '  /// @param user Target user address\n', '  /// @param tranche_id Target tranche\n', '  /// @return number of tokens vested in the target tranche for the target user\n', '  function get_vested_for_tranche(address user, uint8 tranche_id) public view returns(uint256) {\n', '    if(block.timestamp < tranches[tranche_id].cliff_start){\n', '      return 0;\n', '    }\n', '    else if(block.timestamp > tranches[tranche_id].cliff_start + tranches[tranche_id].duration || tranches[tranche_id].duration == 0){\n', '      return user_stats[user].tranche_balances[tranche_id].total_deposited -  user_stats[user].tranche_balances[tranche_id].total_claimed;\n', '    } else {\n', '      return (((( accuracy_scale * (block.timestamp - tranches[tranche_id].cliff_start) )  / tranches[tranche_id].duration\n', '          ) * user_stats[user].tranche_balances[tranche_id].total_deposited\n', '        ) / accuracy_scale ) - user_stats[user].tranche_balances[tranche_id].total_claimed;\n', '    }\n', '  }\n', '\n', '  /// @notice This view returns the balance remaining in Vega V1 for a given user\n', '  /// @notice Once migrated, the balance will always return zero, hence "remaining"\n', '  /// @param user Target user\n', '  /// @return remaining v1 balance\n', '  function v1_bal(address user) internal view returns(uint256) {\n', '    if(!v1_migrated[user]){\n', '      if(address_migration[user] != address(0)){\n', '        return IERC20(v1_address).balanceOf(user) + IERC20(v1_address).balanceOf(address_migration[user]);\n', '      } else {\n', '        return IERC20(v1_address).balanceOf(user);\n', '      }\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  /// @notice This view returns the current amount of tokens locked in all tranches\n', '  /// @notice This includes remaining v1 balance\n', '  /// @param user Target user\n', '  /// @return the current amount of tokens for target user in all tranches\n', '  function user_total_all_tranches(address user) public view returns(uint256){\n', '    return user_stats[user].total_in_all_tranches + v1_bal(user);\n', '  }\n', '\n', '  /// @notice This function withdraws all the currently available vested tokens from the target tranche\n', "  /// @notice This will not allow a user's total tranch balance to go below the user's lien amount\n", '  /// @dev Emits Tranche_Balance_Removed event if successful\n', '  /// @param tranche_id Id of target tranche\n', '  function withdraw_from_tranche(uint8 tranche_id) public {\n', '    require(tranche_id != default_tranche_id);\n', '    uint256 to_withdraw = get_vested_for_tranche(msg.sender, tranche_id);\n', '    require(user_stats[msg.sender].total_in_all_tranches - to_withdraw >=  user_stats[msg.sender].lien);\n', '    user_stats[msg.sender].tranche_balances[tranche_id].total_claimed += to_withdraw;\n', '    user_stats[msg.sender].total_in_all_tranches -= to_withdraw;\n', '    total_locked -= to_withdraw;\n', '    require(IERC20(v2_address).transfer(msg.sender, to_withdraw));\n', '    emit TrancheBalanceRemoved(msg.sender, tranche_id, to_withdraw);\n', '  }\n', '\n', '  /// @notice This function will put a lien on the user who runs this function\n', '  /// @dev Emits Stake_Deposited event if successful\n', '  /// @param amount Amount of tokens to stake\n', '  /// @param vega_public_key Target Vega public key to be credited with the stake lock\n', '  function stake_tokens(uint256 amount, bytes32 vega_public_key) public {\n', '    require(user_stats[msg.sender].lien + amount > user_stats[msg.sender].lien);\n', '    require(user_total_all_tranches(msg.sender) >= user_stats[msg.sender].lien + amount);\n', '    //user applies this to themselves which only multisig control can remove\n', '    user_stats[msg.sender].lien += amount;\n', '    emit StakeDeposited(msg.sender, amount, vega_public_key);\n', '  }\n', '\n', '  /// @notice This function will remove the lien from the user who runs this function\n', '  /// @notice clears "amount" of lien\n', '  /// @dev emits Stake_Removed event if successful\n', '  /// @param amount Amount of tokens to remove from Staking\n', '  function remove_stake(uint256 amount) public {\n', '    /// @dev TODO add multisigControl IFF needed\n', '\n', '    /// @dev Solidity ^0.8 has overflow protection, if this next line overflows, the transaction will revert\n', '    user_stats[msg.sender].lien -= amount;\n', '    emit StakeRemoved(msg.sender, amount);\n', '  }\n', '\n', '  /// @notice This function allows the controller to permit the given address to issue the given Amount\n', '  /// @notice Target users MUST have a zero (0) permitted issuance balance (try revoke_issuer)\n', '  /// @dev emits Issuer_Permitted event\n', '  /// @param issuer Target address to be allowed to issue given amount\n', '  /// @param amount Number of tokens issuer is permitted to issue\n', '  function permit_issuer(address issuer, uint256 amount) public only_controller {\n', '    /// @notice revoke is required first to stop a simple double allowance attack\n', '    require(amount > 0, "amount must be > 0");\n', '    require(permitted_issuance[issuer] == 0, "issuer already permitted, revoke first");\n', '    require(controller != issuer, "controller cannot be permitted issuer");\n', '    permitted_issuance[issuer] = amount;\n', '    emit IssuerPermitted(issuer, amount);\n', '  }\n', '\n', '  /// @notice This function allows the controller to revoke issuance permission from given target\n', '  /// @notice permitted_issuance must be greater than zero (0)\n', '  /// @dev emits Issuer_Revoked event\n', '  /// @param issuer Target address of issuer to be revoked\n', '  function revoke_issuer(address issuer) public only_controller {\n', '    require(permitted_issuance[issuer] != 0, "issuer already revoked");\n', '    permitted_issuance[issuer] = 0;\n', '    emit IssuerRevoked(issuer);\n', '  }\n', '\n', '  /// @notice This function allows the controller to assign a new controller\n', '  /// @dev Emits Controller_Set event\n', '  /// @param new_controller Address of the new controller\n', '  function set_controller(address new_controller) public only_controller {\n', '    controller = new_controller;\n', '    if(permitted_issuance[new_controller] > 0){\n', '      permitted_issuance[new_controller] = 0;\n', '      emit IssuerRevoked(new_controller);\n', '    }\n', '    emit ControllerSet(new_controller);\n', '  }\n', '\n', '  /// @notice this modifier requires that msg.sender is the controller of this contract\n', '  modifier only_controller {\n', '         require( msg.sender == controller, "not controller" );\n', '         _;\n', '  }\n', '\n', '  /// @notice this modifier requires that msg.sender is the controller of this contract or has a permitted issuance remaining of more than zero (0)\n', '  modifier controller_or_issuer {\n', '         require( msg.sender == controller || permitted_issuance[msg.sender] > 0,"not controller or issuer" );\n', '         _;\n', '  }\n', '}']