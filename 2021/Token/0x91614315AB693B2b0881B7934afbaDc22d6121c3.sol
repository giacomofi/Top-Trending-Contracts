['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-21\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0); \n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    uint256 c = a - b;\n', '    return c;\n', '  }\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'library Roles {\n', '    \n', '  struct Role {\n', '    mapping (address => bool) bearer;\n', '  }\n', '  function add(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(!has(role, account));\n', '    role.bearer[account] = true;\n', '  }\n', '  function remove(Role storage role, address account) internal {\n', '    require(account != address(0));\n', '    require(has(role, account));\n', '    role.bearer[account] = false;\n', '  }\n', '  function has(Role storage role, address account) internal view returns (bool) {\n', '    require(account != address(0));\n', '    return role.bearer[account];\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address private _owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), _owner);\n', '  }\n', '  function owner() public view returns(address) {\n', '    return _owner;\n', '  }\n', '  modifier onlyOwner() {\n', '    require(isOwner());\n', '    _;\n', '  }\n', '  function isOwner() public view returns(bool) {\n', '    return msg.sender == _owner;\n', '  }\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '\n', '    function tokenFallback(address _from, uint256 _value, bytes _data) public;\n', '}\n', '\n', 'interface IERC20 {\n', '    \n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  //event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  //ERC223\n', '  function transfer(address to, uint256 value, bytes data) external returns (bool success);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract ERC20 is IERC20, Ownable {\n', '    \n', '  using SafeMath for uint256;\n', '  mapping (address => uint256) private _balances;\n', '  mapping (address => mapping (address => uint256)) private _allowed;\n', '  mapping (address => bool) public frozenAccount;\n', '  event frozenFunds(address account, bool freeze);\n', '  uint256 private _totalSupply;\n', '  function totalSupply() public view returns (uint256) {\n', '    return _totalSupply;\n', '  }\n', '  function balanceOf(address owner) public view returns (uint256) {\n', '    return _balances[owner];\n', '  }\n', '  function allowance(address owner, address spender) public view returns (uint256) {\n', '    return _allowed[owner][spender];\n', '  }\n', '  function transfer(address to, uint256 value) public returns (bool) {\n', '    _transfer(msg.sender, to, value);\n', '    return true;\n', '  }\n', '  function transfer(address to, uint256 value, bytes data) external returns (bool) {\n', '    require(transfer(to, value));\n', '\n', '   uint codeLength;\n', '\n', '   assembly {\n', '    // Retrieve the size of the code on target address, this needs assembly.\n', '    codeLength := extcodesize(to)\n', '  }\n', '\n', '  if (codeLength > 0) {\n', '    ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\n', '    receiver.tokenFallback(msg.sender, value, data);\n', '    }\n', '  return true;\n', '  }\n', '  function approve(address spender, uint256 value) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = value;\n', '    emit Approval(msg.sender, spender, value);\n', '    return true;\n', '  }\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '    require(value <= _allowed[from][msg.sender]);\n', '    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '    _transfer(from, to, value);\n', '    return true;\n', '  }\n', '  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].add(addedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '    require(spender != address(0));\n', '    _allowed[msg.sender][spender] = (\n', '      _allowed[msg.sender][spender].sub(subtractedValue));\n', '    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '    return true;\n', '  }\n', '  function _transfer(address from, address to, uint256 value) internal {\n', '    require(value <= _balances[from]);\n', '    require(to != address(0));\n', '    _balances[from] = _balances[from].sub(value);\n', '    _balances[to] = _balances[to].add(value);\n', '    emit Transfer(from, to, value);\n', '   require(!frozenAccount[msg.sender]);\n', '  }\n', '  function _mint(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    _totalSupply = _totalSupply.add(value);\n', '    _balances[account] = _balances[account].add(value);\n', '    emit Transfer(address(0), account, value);\n', '  }\n', '  function _burn(address account, uint256 value) internal {\n', '    require(account != 0);\n', '    require(value <= _balances[account]);\n', '    _totalSupply = _totalSupply.sub(value);\n', '    _balances[account] = _balances[account].sub(value);\n', '    emit Transfer(account, address(0), value);\n', '  }\n', '  function _burnFrom(address account, uint256 value) internal {\n', '    require(value <= _allowed[account][msg.sender]);\n', '    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\n', '    _burn(account, value);\n', '  }\n', '}\n', '\n', 'contract PauserRole {\n', '    \n', '  using Roles for Roles.Role;\n', '  event PauserAdded(address indexed account);\n', '  event PauserRemoved(address indexed account);\n', '  Roles.Role private pausers;\n', '  constructor() internal {\n', '    _addPauser(msg.sender);\n', '  }\n', '  modifier onlyPauser() {\n', '    require(isPauser(msg.sender));\n', '    _;\n', '  }\n', '  function isPauser(address account) public view returns (bool) {\n', '    return pausers.has(account);\n', '  }\n', '  function addPauser(address account) public onlyPauser {\n', '    _addPauser(account);\n', '  }\n', '  function renouncePauser() public {\n', '    _removePauser(msg.sender);\n', '  }\n', '  function _addPauser(address account) internal {\n', '    pausers.add(account);\n', '    emit PauserAdded(account);\n', '  }\n', '  function _removePauser(address account) internal {\n', '    pausers.remove(account);\n', '    emit PauserRemoved(account);\n', '  }\n', '}\n', '\n', 'contract Pausable is PauserRole {\n', '    \n', '  event Paused(address account);\n', '  event Unpaused(address account);\n', '  bool private _paused;\n', '  constructor() internal {\n', '    _paused = false;\n', '  }\n', '  function paused() public view returns(bool) {\n', '    return _paused;\n', '  }\n', '  modifier whenNotPaused() {\n', '    require(!_paused);\n', '    _;\n', '  }\n', '  modifier whenPaused() {\n', '    require(_paused);\n', '    _;\n', '  }\n', '  function pause() public onlyPauser whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '  function unpause() public onlyPauser whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', 'contract MinterRole {\n', '    \n', '  using Roles for Roles.Role;\n', '  event MinterAdded(address indexed account);\n', '  event MinterRemoved(address indexed account);\n', '  Roles.Role private minters;\n', '  constructor() internal {\n', '    _addMinter(msg.sender);\n', '  }\n', '  modifier onlyMinter() {\n', '    require(isMinter(msg.sender));\n', '    _;\n', '  }\n', '  function isMinter(address account) public view returns (bool) {\n', '    return minters.has(account);\n', '  }\n', '  function addMinter(address account) public {\n', '    _addMinter(account);\n', '  }\n', '  function renounceMinter() public {\n', '    _removeMinter(msg.sender);\n', '  }\n', '  function _addMinter(address account) internal {\n', '    minters.add(account);\n', '    emit MinterAdded(account);\n', '  }\n', '  function _removeMinter(address account) internal {\n', '    minters.remove(account);\n', '    emit MinterRemoved(account);\n', '  }\n', '}\n', '\n', 'contract ERC20Mintable is ERC20, MinterRole {\n', '\n', '//   uint256 private _maxSupply = 1000000000000000000000000001;\n', '  uint256 private _totalSupply;\n', '//   function maxSupply() public view returns (uint256) {\n', '//     return _maxSupply;\n', '//   }\n', '  function mint(address to, uint256 value) public returns (bool) {\n', '    //   function mint(address to, uint256 value) public onlyMinter returns (bool) {\n', '    // require(_maxSupply > totalSupply().add(value));\n', '    _mint(to, value);\n', '    return true;        \n', '  }\n', '}\n', '\n', 'contract ERC20Burnable is ERC20 {\n', '\n', '  function burn(uint256 value) public {\n', '    _burn(msg.sender, value);\n', '  }\n', '  function burnFrom(address from, uint256 value) public {\n', '    _burnFrom(from, value);\n', '  }\n', '}\n', '\n', 'contract ERC20Pausable is ERC20, Pausable {\n', '\n', '  function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n', '    return super.transfer(to, value);\n', '  }\n', '  function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n', '    return super.transferFrom(from, to, value);\n', '  }\n', '  function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\n', '    return super.approve(spender, value);\n', '  }\n', '  function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool success) {\n', '    return super.increaseAllowance(spender, addedValue);\n', '  }\n', '  function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool success) {\n', '    return super.decreaseAllowance(spender, subtractedValue);\n', '  }\n', '}\n', '\n', 'library SafeERC20 {\n', '\n', '  using SafeMath for uint256;\n', '  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '    require(token.transfer(to, value));\n', '  }\n', '  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '    require(token.transferFrom(from, to, value));\n', '  }\n', '  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '    require((value == 0) || (token.allowance(msg.sender, spender) == 0));\n', '    require(token.approve(spender, value));\n', '  }\n', '  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '    require(token.approve(spender, newAllowance));\n', '  }\n', '  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '    require(token.approve(spender, newAllowance));\n', '  }\n', '}\n', '\n', 'contract ERC20Frozen is ERC20 {\n', '    \n', '  function freezeAccount (address target, bool freeze) onlyOwner public {\n', '    frozenAccount[target]=freeze;\n', '    emit frozenFunds(target, freeze);\n', '  }\n', '}\n', '\n', 'contract DFSCToken is ERC20Mintable, ERC20Burnable, ERC20Pausable, ERC20Frozen {\n', '\n', '  string public constant name = "DfiansCoin";\n', '  string public constant symbol = "DFSC";\n', '  uint8 public constant decimals = 18;\n', '//   uint256 public constant INITIAL_SUPPLY = 0;\n', '  uint256 public constant INITIAL_SUPPLY = 6000000000 * (10 ** uint256(decimals));\n', '  \n', '  constructor() public {\n', '    _mint(msg.sender, INITIAL_SUPPLY);\n', '    \n', '  }\n', '}']