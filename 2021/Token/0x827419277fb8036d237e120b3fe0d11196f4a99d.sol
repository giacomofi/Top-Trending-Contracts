['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./Context.sol";\n', 'import "./IERC20.sol";\n', 'import "./ERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'abstract contract ERC20Burnable is Context, ERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public virtual {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', "     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n", '     * allowance.\n', '     *\n', '     * See {ERC20-_burn} and {ERC20-allowance}.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have allowance for ``accounts``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public virtual {\n', '        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, "ERC20: burn amount exceeds allowance");\n', '\n', '        _approve(account, _msgSender(), decreasedAllowance);\n', '        _burn(account, amount);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev All contracts that will be owned by a Governor entity should extend this contract.\n', ' */\n', 'contract Governed {\n', ' \n', '    address private governor;\n', '    address public pendingGovernor;\n', '\n', '    event newPendingOwnership(address indexed from, address indexed to);\n', '    event newOwnership(address indexed from, address indexed to);\n', '\n', '    /**\n', '     * @dev Check if the caller is the governor.\n', '     */\n', '    modifier onlyGovernor {\n', '        require(msg.sender == governor, "Only Governor can call");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initialize the governor to the contract caller.\n', '     */\n', '    function _initialize(address _initGovernor) internal {\n', '        governor = _initGovernor;\n', '    }\n', '\n', '    /**\n', '     * @dev Admin function to begin change of governor. The `_newGovernor` must call\n', '     * `newOwnershipAccept` to finalize the transfer.\n', '     * @param _newGovernor Address of new `governor`\n', '     */\n', '    function transferOwnership(address _newGovernor) external onlyGovernor {\n', '        require(_newGovernor != address(0), "Governor must be set");\n', '\n', '        address oldPendingGovernor = pendingGovernor;\n', '        pendingGovernor = _newGovernor;\n', '\n', '        emit newPendingOwnership(oldPendingGovernor, pendingGovernor);\n', '    }\n', '\n', '    /**\n', '     * @dev Admin function for pending governor to accept role and update governor.\n', '     * This function must called by the pending governor.\n', '     */\n', '    function newOwnershipAccept() external {\n', '        require(\n', '            pendingGovernor != address(0) && msg.sender == pendingGovernor,\n', '            "Caller must be pending governor"\n', '        );\n', '\n', '        address oldGovernor = governor;\n', '        address oldPendingGovernor = pendingGovernor;\n', '\n', '        governor = pendingGovernor;\n', '        pendingGovernor = address(0);\n', '\n', '        emit newOwnership(oldGovernor, governor);\n', '        emit newPendingOwnership(oldPendingGovernor, pendingGovernor);\n', '    }\n', '}\n', '\n', '/**\n', ' * The token is initially owned by the deployer address, who create the initial distribution.\n', ' * For convenience, an initial supply can be passed in the constructor that will be\n', ' * assigned to the deployer.\n', ' *\n', ' */\n', 'contract Mariburn is Governed, ERC20, ERC20Burnable {\n', '    using SafeMath for uint256;\n', '  \n', '    // initialSupply variable initial state\n', '    bool initialSupplyFinished = false;\n', '  \n', '    constructor() ERC20("t.me/marijuanaburn", "MARIburn") {\n', '        Governed._initialize(msg.sender);\n', '     }\n', '\n', '    /**\n', '     * @dev This implementation is agnostic to the way tokens are created. \n', '     * This means that a supply mechanism has to be added in a derived contract.\n', '     * \n', "     *  'initailSupplyfinish' must be 'false' to execute this function,\n", "     *  however after first use, 'true' will be changed to 'false' to lock this function forever.\n", '     * \n', '     */\n', '    function initialSupply(address contractAddress, uint256 InitialSupply) public onlyGovernor {\n', '        require(initialSupplyFinished == false);\n', '        _totalSupply = _totalSupply.add(InitialSupply);\n', '        _balances[contractAddress] = _balances[contractAddress].add(InitialSupply);\n', '        InitialSupplyFinished = true;\n', '    }\n', '\n', '   /**\n', '     * @dev This return state of initialSupply function:\n', '     * \n', "     * 'false' means that initialSupply is not done yet.\n", "     * 'true' means that it's locked forever.\n", '     * \n', '     */\n', '    function isInitialSupplyFinished () public view returns (bool) {\n', '        return InitialSupplyFinished;\n', '    }\n', '}']