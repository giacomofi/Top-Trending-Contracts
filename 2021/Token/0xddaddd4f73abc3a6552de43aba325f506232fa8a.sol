['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'library SafeMaths {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', 'contract Memefund {\n', '\n', '    using SafeMaths for uint256;\n', '\n', '    address public rebaseOracle;       // Used for authentication\n', '    address public owner;              // Used for authentication\n', '    address public newOwner;\n', '\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '    string public name;\n', '    string public symbol;\n', '\n', '    uint256 private constant MAX_UINT256 = ~uint256(0);   // (2^256) - 1\n', '    uint256 private constant MAXSUPPLY = ~uint128(0);  // (2^128) - 1\n', '\n', '    uint256 private totalAtoms;\n', '    uint256 private atomsPerMolecule;\n', '\n', '    mapping (address => uint256) private atomBalances;\n', '    mapping (address => mapping (address => uint256)) private allowedMolecules;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    event LogRebase(uint256 _totalSupply);\n', '    event LogNewRebaseOracle(address _rebaseOracle);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public\n', '    {\n', '        decimals = 9;                               // decimals  \n', '        totalSupply = 100000000*10**9;                // initialSupply\n', '        name = "Memefund";                         // Set the name for display purposes\n', '        symbol = "MFUND";                            // Set the symbol for display purposes\n', '\n', '        owner = msg.sender;\n', '        totalAtoms = MAX_UINT256 - (MAX_UINT256 % totalSupply);     // totalAtoms is a multiple of totalSupply so that atomsPerMolecule is an integer.\n', '        atomBalances[msg.sender] = totalAtoms;\n', '        atomsPerMolecule = totalAtoms.div(totalSupply);\n', '\n', '        emit Transfer(address(0), msg.sender, totalSupply);\n', '    }\n', '\n', '    /**\n', '     * @param newRebaseOracle The address of the new oracle for rebasement (used for authentication).\n', '     */\n', '    function setRebaseOracle(address newRebaseOracle) external {\n', '        require(msg.sender == owner, "Can only be executed by owner.");\n', '        rebaseOracle = newRebaseOracle;\n', '\n', '        emit LogNewRebaseOracle(rebaseOracle);\n', '    }\n', '\n', '    /**\n', '     * @dev Propose a new owner.\n', '     * @param _newOwner The address of the new owner.\n', '     */\n', '    function transferOwnership(address _newOwner) public\n', '    {\n', '        require(msg.sender == owner, "Can only be executed by owner.");\n', '        require(_newOwner != address(0), "0x00 address not allowed.");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Accept new owner.\n', '     */\n', '    function acceptOwnership() public\n', '    {\n', '        require(msg.sender == newOwner, "Sender not authorized.");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Notifies Benchmark contract about a new rebase cycle.\n', '     * @param supplyDelta The number of new molecule tokens to add into or remove from circulation.\n', '     * @param increaseSupply Whether to increase or decrease the total supply.\n', '     * @return The total number of molecules after the supply adjustment.\n', '     */\n', '    function rebase(uint256 supplyDelta, bool increaseSupply) external returns (uint256) {\n', '        require(msg.sender == rebaseOracle, "Can only be executed by rebaseOracle.");\n', '        \n', '        if (supplyDelta == 0) {\n', '            emit LogRebase(totalSupply);\n', '            return totalSupply;\n', '        }\n', '\n', '        if (increaseSupply == true) {\n', '            totalSupply = totalSupply.add(supplyDelta);\n', '        } else {\n', '            totalSupply = totalSupply.sub(supplyDelta);\n', '        }\n', '\n', '        if (totalSupply > MAXSUPPLY) {\n', '            totalSupply = MAXSUPPLY;\n', '        }\n', '\n', '        atomsPerMolecule = totalAtoms.div(totalSupply);\n', '\n', '        emit LogRebase(totalSupply);\n', '        return totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @param who The address to query.\n', '     * @return The balance of the specified address.\n', '     */\n', '    function balanceOf(address who) public view returns (uint256) {\n', '        return atomBalances[who].div(atomsPerMolecule);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens to a specified address.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     * @return True on success, false otherwise.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        require(to != address(0),"Invalid address.");\n', '        require(to != address(this),"Molecules contract can\'t receive MARK.");\n', '\n', '        uint256 atomValue = value.mul(atomsPerMolecule);\n', '\n', '        atomBalances[msg.sender] = atomBalances[msg.sender].sub(atomValue);\n', '        atomBalances[to] = atomBalances[to].add(atomValue);\n', '\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner has allowed to a spender.\n', '     * @param owner_ The address which owns the funds.\n', '     * @param spender The address which will spend the funds.\n', '     * @return The number of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner_, address spender) public view returns (uint256) {\n', '        return allowedMolecules[owner_][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * @param from The address you want to send tokens from.\n', '     * @param to The address you want to transfer to.\n', '     * @param value The amount of tokens to be transferred.\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        require(to != address(0),"Invalid address.");\n', '        require(to != address(this),"Molecules contract can\'t receive MARK.");\n', '\n', '        allowedMolecules[from][msg.sender] = allowedMolecules[from][msg.sender].sub(value);\n', '\n', '        uint256 atomValue = value.mul(atomsPerMolecule);\n', '        atomBalances[from] = atomBalances[from].sub(atomValue);\n', '        atomBalances[to] = atomBalances[to].add(atomValue);\n', '        \n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of\n', '     * msg.sender. This method is included for ERC20 compatibility.\n', '     * IncreaseAllowance and decreaseAllowance should be used instead.\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        allowedMolecules[msg.sender][spender] = value;\n', '\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner has allowed to a spender.\n', '     * This method should be used instead of approve() to avoid the double approval vulnerability.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        allowedMolecules[msg.sender][spender] = allowedMolecules[msg.sender][spender].add(addedValue);\n', '\n', '        emit Approval(msg.sender, spender, allowedMolecules[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner has allowed to a spender.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        uint256 oldValue = allowedMolecules[msg.sender][spender];\n', '        if (subtractedValue >= oldValue) {\n', '            allowedMolecules[msg.sender][spender] = 0;\n', '        } else {\n', '            allowedMolecules[msg.sender][spender] = oldValue.sub(subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, spender, allowedMolecules[msg.sender][spender]);\n', '        return true;\n', '    }\n', '}']