['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'library SafeMath {\n', '   \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '   \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        \n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Context {\n', '    \n', '    constructor () internal { }\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    constructor() internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    function renounceOwnership() public  onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library BasisPoints {\n', '    using SafeMath for uint;\n', '\n', '    uint constant private BASIS_POINTS = 10000;\n', '\n', '    function mulBP(uint amt, uint bp) internal pure returns (uint) {\n', '        if (amt == 0) return 0;\n', '        return amt.mul(bp).div(BASIS_POINTS);\n', '    }\n', '\n', '    function divBP(uint amt, uint bp) internal pure returns (uint) {\n', '        require(bp > 0, "Cannot divide by zero.");\n', '        if (amt == 0) return 0;\n', '        return amt.mul(BASIS_POINTS).div(bp);\n', '    }\n', '\n', '    function addBP(uint amt, uint bp) internal pure returns (uint) {\n', '        if (amt == 0) return 0;\n', '        if (bp == 0) return amt;\n', '        return amt.add(mulBP(amt, bp));\n', '    }\n', '\n', '    function subBP(uint amt, uint bp) internal pure returns (uint) {\n', '        if (amt == 0) return 0;\n', '        if (bp == 0) return amt;\n', '        return amt.sub(mulBP(amt, bp));\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Staking is Context, Ownable {\n', '    using BasisPoints for uint;\n', '    using SafeMath for uint;\n', '\n', '    uint256 constant internal DISTRIBUTION_MULTIPLIER = 2 ** 64;\n', '\n', '    IERC20 private token;\n', '\n', '    mapping(address => uint) public stakeValue;\n', '    mapping(address => int) public stakerPayouts;\n', '\n', '    uint public totalDistributions;\n', '    uint public totalStaked;\n', '    uint public totalStakers;\n', '    uint public profitPerShare;\n', '    uint private emptyStakeTokens; //These are eth given to the contract when there are no stakers.\n', '\n', '    uint public startTime;\n', '\n', '    event OnDistribute(address sender, uint amountSent);\n', '    event OnStake(address sender, uint amount);\n', '    event OnUnstake(address sender, uint amount);\n', '    event OnReinvest(address sender, uint amount);\n', '    event OnWithdraw(address sender, uint amount);\n', '\n', '    struct Checkpoint {\n', '      uint128 fromBlock;\n', '      uint128 value;\n', '    }\n', '\n', '    mapping(address => Checkpoint[]) internal stakeValueHistory;\n', '\n', '    Checkpoint[] internal totalStakedHistory;\n', '\n', '    modifier whenStakingActive {\n', '        require(startTime != 0 && now > startTime, "Staking not yet started.");\n', '        _;\n', '    }\n', '\n', '    constructor(IERC20 _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    function setStartTime(uint _startTime) external onlyOwner {\n', '        startTime = _startTime;\n', '    }\n', '\n', '    function stake(uint amount) public whenStakingActive {\n', '        require(token.balanceOf(msg.sender) >= amount, "Cannot stake more Tokens than you hold unstaked.");\n', '        if (stakeValue[msg.sender] == 0) totalStakers = totalStakers.add(1);\n', '        _addStake(amount);\n', '        require(token.transferFrom(msg.sender, address(this), amount), "Stake failed due to failed transfer.");\n', '        emit OnStake(msg.sender, amount);\n', '    }\n', '\n', '    function unstake(uint amount) external whenStakingActive {\n', '        require(stakeValue[msg.sender] >= amount, "Cannot unstake more Token than you have staked.");\n', "        // Update staker's history\n", '        _updateCheckpointValueAtNow(\n', '        stakeValueHistory[msg.sender],\n', '        stakeValue[msg.sender],\n', '        stakeValue[msg.sender].sub(amount)\n', '        );\n', '\n', '        // Update total staked history\n', '        _updateCheckpointValueAtNow(\n', '        totalStakedHistory,\n', '        totalStaked,\n', '        totalStaked.sub(amount)\n', '        );\n', '        \n', '        //must withdraw all dividends, to prevent overflows\n', '        withdraw(dividendsOf(msg.sender));\n', '        if (stakeValue[msg.sender] == amount) totalStakers = totalStakers.sub(1);\n', '        totalStaked = totalStaked.sub(amount);\n', '        stakeValue[msg.sender] = stakeValue[msg.sender].sub(amount);\n', '\n', '        stakerPayouts[msg.sender] = uintToInt(profitPerShare.mul(stakeValue[msg.sender]));\n', '        \n', '        require(token.transferFrom(address(this), msg.sender, amount), "Unstake failed due to failed transfer.");\n', '        emit OnUnstake(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint amount) public whenStakingActive {\n', '        require(dividendsOf(msg.sender) >= amount, "Cannot withdraw more dividends than you have earned.");\n', '        stakerPayouts[msg.sender] = stakerPayouts[msg.sender] + uintToInt(amount.mul(DISTRIBUTION_MULTIPLIER));\n', '        msg.sender.transfer(amount);\n', '        emit OnWithdraw(msg.sender, amount);\n', '    }\n', '\n', '    function distribute() external payable {\n', '        uint amount = msg.value;\n', '        if(amount > 0){\n', '            totalDistributions = totalDistributions.add(amount);\n', '            _increaseProfitPerShare(amount);\n', '            emit OnDistribute(msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function dividendsOf(address staker) public view returns (uint) {\n', '        int divPayout = uintToInt(profitPerShare.mul(stakeValue[staker]));\n', '        require(divPayout >= stakerPayouts[staker], "dividend calc overflow");\n', '        return uint(divPayout - stakerPayouts[staker])\n', '            .div(DISTRIBUTION_MULTIPLIER);\n', '    }\n', '\n', '    function totalStakedAt(uint _blockNumber) public view returns(uint) {\n', "        // If we haven't initialized history yet\n", '        if (totalStakedHistory.length == 0) {\n', '            // Use the existing value\n', '            return totalStaked;\n', '        } else {\n', '            // Binary search history for the proper staked amount\n', '            return _getCheckpointValueAt(\n', '                totalStakedHistory,\n', '                _blockNumber\n', '            );\n', '        }\n', '    }\n', '\n', '    function stakeValueAt(address _owner, uint _blockNumber) public view returns (uint) {\n', "        // If we haven't initialized history yet\n", '        if (stakeValueHistory[_owner].length == 0) {\n', '            // Use the existing latest value\n', '            return stakeValue[_owner];\n', '        } else {\n', '            // Binary search history for the proper staked amount\n', '            return _getCheckpointValueAt(stakeValueHistory[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '    function uintToInt(uint val) internal pure returns (int) {\n', '        if (val >= uint(-1).div(2)) {\n', '            require(false, "Overflow. Cannot convert uint to int.");\n', '        } else {\n', '            return int(val);\n', '        }\n', '    }\n', '\n', '    function _addStake(uint _amount) internal {\n', "        // Update staker's history\n", '        _updateCheckpointValueAtNow(\n', '        stakeValueHistory[msg.sender],\n', '        stakeValue[msg.sender],\n', '        stakeValue[msg.sender].add(_amount)\n', '        );\n', '\n', '        // Update total staked history\n', '        _updateCheckpointValueAtNow(\n', '        totalStakedHistory,\n', '        totalStaked,\n', '        totalStaked.add(_amount)\n', '        );\n', '\n', '        totalStaked = totalStaked.add(_amount);\n', '        stakeValue[msg.sender] = stakeValue[msg.sender].add(_amount);\n', '        \n', '        uint payout = profitPerShare.mul(_amount);\n', '        stakerPayouts[msg.sender] = stakerPayouts[msg.sender] + uintToInt(payout);\n', '    }\n', '\n', '    function _increaseProfitPerShare(uint amount) internal {\n', '        if (totalStaked != 0) {\n', '            if (emptyStakeTokens != 0) {\n', '                amount = amount.add(emptyStakeTokens);\n', '                emptyStakeTokens = 0;\n', '            }\n', '            profitPerShare = profitPerShare.add(amount.mul(DISTRIBUTION_MULTIPLIER).div(totalStaked));\n', '        } else {\n', '            emptyStakeTokens = emptyStakeTokens.add(amount);\n', '        }\n', '    }\n', '\n', '    function _getCheckpointValueAt(Checkpoint[] storage checkpoints, uint _block) view internal returns (uint) {\n', '    // This case should be handled by caller\n', '    if (checkpoints.length == 0)\n', '      return 0;\n', '\n', '    // Use the latest checkpoint\n', '    if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '      return checkpoints[checkpoints.length-1].value;\n', '\n', '    // Use the oldest checkpoint\n', '    if (_block < checkpoints[0].fromBlock)\n', '      return checkpoints[0].value;\n', '\n', '    // Binary search of the value in the array\n', '    uint min = 0;\n', '    uint max = checkpoints.length-1;\n', '    while (max > min) {\n', '      uint mid = (max + min + 1) / 2;\n', '      if (checkpoints[mid].fromBlock<=_block) {\n', '        min = mid;\n', '      } else {\n', '        max = mid-1;\n', '      }\n', '    }\n', '    return checkpoints[min].value;\n', '  }\n', '\n', '  function _updateCheckpointValueAtNow(\n', '    Checkpoint[] storage checkpoints,\n', '    uint _oldValue,\n', '    uint _value\n', '  ) internal {\n', '    require(_value <= uint128(-1));\n', '    require(_oldValue <= uint128(-1));\n', '\n', '    if (checkpoints.length == 0) {\n', '      Checkpoint storage genesis = checkpoints[checkpoints.length++];\n', '      genesis.fromBlock = uint128(block.number - 1);\n', '      genesis.value = uint128(_oldValue);\n', '    }\n', '\n', '    if (checkpoints[checkpoints.length - 1].fromBlock < block.number) {\n', '      Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n', '      newCheckPoint.fromBlock = uint128(block.number);\n', '      newCheckPoint.value = uint128(_value);\n', '    } else {\n', '      Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n', '      oldCheckPoint.value = uint128(_value);\n', '    }\n', '  }\n', '  \n', '}']