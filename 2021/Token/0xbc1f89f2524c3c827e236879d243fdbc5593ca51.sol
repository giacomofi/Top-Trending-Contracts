['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-21\n', '*/\n', '\n', 'pragma solidity ^0.8.3;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\n', '    function transfer(address to, uint256 tokens) external returns (bool success);\n', '    function approve(address spender, uint256 tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\n', '}\n', '\n', 'contract ClearingHouse is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => bool) supportedTokens;\n', '    mapping(address => uint256) nonces;\n', '\n', '    // Double mapping as token address -> owner -> balance\n', '    event TokensWrapped(address token, string receiver, uint256 amount);\n', '\n', '    function deposit(address token, uint256 amount, string memory receiver) public {\n', "        require(supportedTokens[token] == true, 'Unsupported token!');\n", '\n', '        IERC20 tokenERC = IERC20(token);\n', '        tokenERC.transferFrom(msg.sender, address(this), amount);\n', '\n', '        emit TokensWrapped(token, receiver, amount);\n', '    }\n', '\n', '    function hashEthMsg(bytes32 _messageHash) public pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _messageHash));\n', '    }\n', '\n', '\n', '    function hash(bytes memory x) public pure returns (bytes32) {\n', '        return keccak256(x);\n', '    }\n', '    \n', '    function encode(address token, uint256 amount, uint256 nonce, address sender) public pure returns (bytes memory) {\n', '                return abi.encode(\n', '                    token,\n', '                    amount,\n', '                    nonce,\n', '                    sender\n', '                );\n', '    }\n', '    \n', '    function withdraw(address token, uint256 amount, uint256 nonce, uint8 v, bytes32 r, bytes32 s) public {\n', '            bytes memory encoded = encode(token, amount, nonce, msg.sender);\n', '            bytes32 hashed = hash(encoded);\n', '            hashed = hashEthMsg(hashed);\n', '            address recoveredAddress = ecrecover(hashed, v, r, s);\n', "            require(recoveredAddress != address(0) && recoveredAddress == owner(), 'Invalid Signature!');\n", "            require(recoveredAddress != address(0) && recoveredAddress == owner(), 'Invalid Signature!');\n", '            IERC20 tokenERC = IERC20(token);\n', '            tokenERC.transfer(msg.sender, amount);\n', '    }\n', '\n', '    // Admin functions for adding and removing tokens from the wrapped token system\n', '    function addToken(address token) public onlyOwner {\n', '        supportedTokens[token] = true;\n', '    }\n', '\n', '    function removeToken(address token) public onlyOwner {\n', '        supportedTokens[token] = false;\n', '    }\n', '}']