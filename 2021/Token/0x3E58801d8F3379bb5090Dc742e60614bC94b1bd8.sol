['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-16\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'contract CloneFactory {\n', '\n', '  function createClone(address target) internal returns (address result) {\n', '    bytes20 targetBytes = bytes20(target);\n', '    assembly {\n', '      let clone := mload(0x40)\n', '      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '      mstore(add(clone, 0x14), targetBytes)\n', '      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '      result := create(0, clone, 0x37)\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    \n', '    function initOwnable() internal{\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', 'contract MinterRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event MinterAdded(address indexed account);\n', '    event MinterRemoved(address indexed account);\n', '\n', '    Roles.Role private _minters;\n', '\n', '    function initMinter() internal{\n', '        _addMinter(_msgSender());\n', '    }\n', '\n', '    constructor () internal {\n', '        _addMinter(_msgSender());\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(isMinter(_msgSender()), "MinterRole: caller does not have the Minter role");\n', '        _;\n', '    }\n', '\n', '    function isMinter(address account) public view returns (bool) {\n', '        return _minters.has(account);\n', '    }\n', '\n', '    function addMinter(address account) public onlyMinter {\n', '        _addMinter(account);\n', '    }\n', '\n', '    function renounceMinter() public {\n', '        _removeMinter(_msgSender());\n', '    }\n', '\n', '    function _addMinter(address account) internal {\n', '        _minters.add(account);\n', '        emit MinterAdded(account);\n', '    }\n', '\n', '    function _removeMinter(address account) internal {\n', '        _minters.remove(account);\n', '        emit MinterRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    function initWhiteListAdmin() internal{\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas\n', '     * @param _interfaceId The interface identifier, as specified in ERC-165\n', '     */\n', '    function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '   * @dev Multiplies two unsigned integers, reverts on overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath#mul: OVERFLOW");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, "SafeMath#div: DIVISION_BY_ZERO");\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath#sub: UNDERFLOW");\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two unsigned integers, reverts on overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath#add: OVERFLOW");\n', '\n', '    return c; \n', '  }\n', '\n', '  /**\n', '   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '   * reverts when dividing by zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0, "SafeMath#mod: DIVISION_BY_ZERO");\n', '    return a % b;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @dev ERC-1155 interface for accepting safe transfers.\n', ' */\n', 'interface IERC1155TokenReceiver {\n', '\n', '  /**\n', '   * @notice Handle the receipt of a single ERC1155 token type\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value MUST result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _id        The id of the token being transferred\n', '   * @param _amount    The amount of tokens being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '   */\n', '  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n', '\n', '  /**\n', '   * @notice Handle the receipt of multiple ERC1155 token types\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value WILL result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeBatchTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _ids       An array containing ids of each token being transferred\n', '   * @param _amounts   An array containing amounts of each token being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '   */\n', '  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n', '\n', '  /**\n', '   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n', '   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n', '   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n', '   *      This function MUST NOT consume more than 5,000 gas.\n', '   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n', '   */\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '\n', '}\n', '\n', 'interface IERC1155 {\n', '  // Events\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n', '\n', '  /**\n', '   * @dev MUST emit when an approval is updated\n', '   */\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  /**\n', '   * @dev MUST emit when the URI is updated for a token ID\n', '   *   URIs are defined in RFC 3986\n', '   *   The URI MUST point a JSON file that conforms to the "ERC-1155 Metadata JSON Schema"\n', '   */\n', '  event URI(string _amount, uint256 indexed _id);\n', '\n', '  /**\n', '   * @notice Transfers amount of an _id from the _from address to the _to address specified\n', '   * @dev MUST emit TransferSingle event on success\n', "   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '   * MUST throw if `_to` is the zero address\n', '   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n', '   * MUST throw on any other error\n', '   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   * @param _data    Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @dev MUST emit TransferBatch event on success\n', "   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '   * MUST throw if `_to` is the zero address\n', '   * MUST throw if length of `_ids` is not the same as length of `_amounts`\n', '   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n', '   * MUST throw on any other error\n', '   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   * @param _data     Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n', '  \n', '  /**\n', "   * @notice Get the balance of an account's Tokens\n", '   * @param _owner  The address of the token holder\n', '   * @param _id     ID of the Token\n', "   * @return        The _owner's balance of the Token type requested\n", '   */\n', '  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the balance of multiple account/token pairs\n', '   * @param _owners The addresses of the token holders\n', '   * @param _ids    ID of the Tokens\n', "   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n", '   */\n', '  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n', '\n', '  /**\n', '   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n', '   * @dev MUST emit the ApprovalForAll event on success\n', '   * @param _operator  Address to add to the set of authorized operators\n', '   * @param _approved  True if the operator is approved, false to revoke approval\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '  /**\n', '   * @notice Queries the approval status of an operator for a given owner\n', '   * @param _owner     The owner of the Tokens\n', '   * @param _operator  Address of authorized operator\n', '   * @return           True if the operator is approved, false if not\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n', '\n', '}\n', '\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call.value(value)(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of Multi-Token Standard contract\n', ' */\n', 'contract ERC1155 is IERC165 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '\n', '  /***********************************|\n', '  |        Variables and Events       |\n', '  |__________________________________*/\n', '\n', '  // onReceive function signatures\n', '  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n', '  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n', '\n', '  // Objects balances\n', '  mapping (address => mapping(uint256 => uint256)) internal balances;\n', '\n', '  // Operator Functions\n', '  mapping (address => mapping(address => bool)) internal operators;\n', '\n', '  // Events\n', '  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n', '  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  event URI(string _uri, uint256 indexed _id);\n', '\n', '\n', '  /***********************************|\n', '  |     Public Transfer Functions     |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   * @param _data    Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    public\n', '  {\n', '    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeTransferFrom: INVALID_OPERATOR");\n', '    require(_to != address(0),"ERC1155#safeTransferFrom: INVALID_RECIPIENT");\n', '    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n', '\n', '    _safeTransferFrom(_from, _to, _id, _amount);\n', '    _callonERC1155Received(_from, _to, _id, _amount, _data);\n', '  }\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   * @param _data     Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    public\n', '  {\n', '    // Requirements\n', '    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeBatchTransferFrom: INVALID_OPERATOR");\n', '    require(_to != address(0), "ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT");\n', '\n', '    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n', '    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Internal Transfer Functions    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   */\n', '  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n', '    internal\n', '  {\n', '    // Update balances\n', '    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\n', '    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n', '   */\n', '  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    internal\n', '  {\n', '    // Check if recipient is contract\n', '    if (_to.isContract()) {\n', '      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\n', '      require(retval == ERC1155_RECEIVED_VALUE, "ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE");\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   */\n', '  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of transfer to execute\n', '    uint256 nTransfer = _ids.length;\n', '\n', '    // Executing all transfers\n', '    for (uint256 i = 0; i < nTransfer; i++) {\n', '      // Update storage balance of previous bin\n', '      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n', '      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n', '    }\n', '\n', '    // Emit event\n', '    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n', '  }\n', '\n', '  /**\n', '   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n', '   */\n', '  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    internal\n', '  {\n', '    // Pass data if recipient is contract\n', '    if (_to.isContract()) {\n', '      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\n', '      require(retval == ERC1155_BATCH_RECEIVED_VALUE, "ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE");\n', '    }\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |         Operator Functions        |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n', '   * @param _operator  Address to add to the set of authorized operators\n', '   * @param _approved  True if the operator is approved, false to revoke approval\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved)\n', '    external\n', '  {\n', '    // Update operator status\n', '    operators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @notice Queries the approval status of an operator for a given owner\n', '   * @param _owner     The owner of the Tokens\n', '   * @param _operator  Address of authorized operator\n', '   * @return True if the operator is approved, false if not\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool isOperator)\n', '  {\n', '    return operators[_owner][_operator];\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |         Balance Functions         |\n', '  |__________________________________*/\n', '\n', '  /**\n', "   * @notice Get the balance of an account's Tokens\n", '   * @param _owner  The address of the token holder\n', '   * @param _id     ID of the Token\n', "   * @return The _owner's balance of the Token type requested\n", '   */\n', '  function balanceOf(address _owner, uint256 _id)\n', '    public view returns (uint256)\n', '  {\n', '    return balances[_owner][_id];\n', '  }\n', '\n', '  /**\n', '   * @notice Get the balance of multiple account/token pairs\n', '   * @param _owners The addresses of the token holders\n', '   * @param _ids    ID of the Tokens\n', "   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n", '   */\n', '  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n', '    public view returns (uint256[] memory)\n', '  {\n', '    require(_owners.length == _ids.length, "ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH");\n', '\n', '    // Variables\n', '    uint256[] memory batchBalances = new uint256[](_owners.length);\n', '\n', '    // Iterate over each owner and token ID\n', '    for (uint256 i = 0; i < _owners.length; i++) {\n', '      batchBalances[i] = balances[_owners[i]][_ids[i]];\n', '    }\n', '\n', '    return batchBalances;\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |          ERC165 Functions         |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256("supportsInterface(bytes4)"));\n', '   */\n', '  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n', '\n', '  /**\n', '   * INTERFACE_SIGNATURE_ERC1155 =\n', '   * bytes4(keccak256("safeTransferFrom(address,address,uint256,uint256,bytes)")) ^\n', '   * bytes4(keccak256("safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)")) ^\n', '   * bytes4(keccak256("balanceOf(address,uint256)")) ^\n', '   * bytes4(keccak256("balanceOfBatch(address[],uint256[])")) ^\n', '   * bytes4(keccak256("setApprovalForAll(address,bool)")) ^\n', '   * bytes4(keccak256("isApprovedForAll(address,address)"));\n', '   */\n', '  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceID  The interface identifier, as specified in ERC-165\n', '   * @return `true` if the contract implements `_interfaceID` and\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n', '        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @notice Contract that handles metadata related methods.\n', ' * @dev Methods assume a deterministic generation of URI based on token IDs.\n', ' *      Methods also assume that URI uses hex representation of token IDs.\n', ' */\n', 'contract ERC1155Metadata {\n', '\n', "  // URI's default URI prefix\n", '  string internal baseMetadataURI;\n', '  event URI(string _uri, uint256 indexed _id);\n', '\n', '\n', '  /***********************************|\n', '  |     Metadata Public Function s    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n', '   * @dev URIs are defined in RFC 3986.\n', '   *      URIs are assumed to be deterministically generated based on token ID\n', '   *      Token IDs are assumed to be represented in their hex format in URIs\n', '   * @return URI string\n', '   */\n', '  function uri(uint256 _id) public view returns (string memory) {\n', '    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json"));\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Metadata Internal Functions    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Will emit default URI log event for corresponding token _id\n', '   * @param _tokenIDs Array of IDs of tokens to log default URI\n', '   */\n', '  function _logURIs(uint256[] memory _tokenIDs) internal {\n', '    string memory baseURL = baseMetadataURI;\n', '    string memory tokenURI;\n', '\n', '    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), ".json"));\n', '      emit URI(tokenURI, _tokenIDs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Will emit a specific URI log event for corresponding token\n', '   * @param _tokenIDs IDs of the token corresponding to the _uris logged\n', '   * @param _URIs    The URIs of the specified _tokenIDs\n', '   */\n', '  function _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal {\n', '    require(_tokenIDs.length == _URIs.length, "ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH");\n', '    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '      emit URI(_URIs[i], _tokenIDs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', "   * @notice Will update the base URL of token's URI\n", "   * @param _newBaseMetadataURI New base URL of token's URI\n", '   */\n', '  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n', '    baseMetadataURI = _newBaseMetadataURI;\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Utility Internal Functions     |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Convert uint256 to string\n', '   * @param _i Unsigned integer to convert to string\n', '   */\n', '  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n', '    if (_i == 0) {\n', '      return "0";\n', '    }\n', '\n', '    uint256 j = _i;\n', '    uint256 ii = _i;\n', '    uint256 len;\n', '\n', '    // Get number of bytes\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '\n', '    bytes memory bstr = new bytes(len);\n', '    uint256 k = len - 1;\n', '\n', '    // Get each individual ASCII\n', '    while (ii != 0) {\n', '      bstr[k--] = byte(uint8(48 + ii % 10));\n', '      ii /= 10;\n', '    }\n', '\n', '    // Convert to string\n', '    return string(bstr);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n', ' *      a parent contract to be executed as they are `internal` functions\n', ' */\n', 'contract ERC1155MintBurn is ERC1155 {\n', '\n', '\n', '  /****************************************|\n', '  |            Minting Functions           |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '   * @notice Mint _amount of tokens of a given id\n', '   * @param _to      The address to mint tokens to\n', '   * @param _id      Token id to mint\n', '   * @param _amount  The amount to be minted\n', '   * @param _data    Data to pass if receiver is contract\n', '   */\n', '  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    internal\n', '  {\n', '    // Add _amount\n', '    balances[_to][_id] = balances[_to][_id].add(_amount);\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n', '\n', '    // Calling onReceive method if recipient is contract\n', '    _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\n', '  }\n', '\n', '  /**\n', '   * @notice Mint tokens for each ids in _ids\n', '   * @param _to       The address to mint tokens to\n', '   * @param _ids      Array of ids to mint\n', '   * @param _amounts  Array of amount of tokens to mint per id\n', '   * @param _data    Data to pass if receiver is contract\n', '   */\n', '  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of mints to execute\n', '    uint256 nMint = _ids.length;\n', '\n', '     // Executing all minting\n', '    for (uint256 i = 0; i < nMint; i++) {\n', '      // Update storage balance\n', '      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n', '    }\n', '\n', '    // Emit batch mint event\n', '    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n', '\n', '    // Calling onReceive method if recipient is contract\n', '    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\n', '  }\n', '\n', '\n', '  /****************************************|\n', '  |            Burning Functions           |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '   * @notice Burn _amount of tokens of a given token id\n', '   * @param _from    The address to burn tokens from\n', '   * @param _id      Token id to burn\n', '   * @param _amount  The amount to be burned\n', '   */\n', '  function _burn(address _from, uint256 _id, uint256 _amount)\n', '    internal\n', '  {\n', '    //Substract _amount\n', '    balances[_from][_id] = balances[_from][_id].sub(_amount);\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n', '   * @param _from     The address to burn tokens from\n', '   * @param _ids      Array of token ids to burn\n', '   * @param _amounts  Array of the amount to be burned\n', '   */\n', '  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of mints to execute\n', '    uint256 nBurn = _ids.length;\n', '\n', '     // Executing all minting\n', '    for (uint256 i = 0; i < nBurn; i++) {\n', '      // Update storage balance\n', '      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n', '    }\n', '\n', '    // Emit batch mint event\n', '    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n', '  }\n', '\n', '}\n', '\n', 'library Strings {\n', '\t// via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c,\n', '\t\tstring memory _d,\n', '\t\tstring memory _e\n', '\t) internal pure returns (string memory) {\n', '\t\tbytes memory _ba = bytes(_a);\n', '\t\tbytes memory _bb = bytes(_b);\n', '\t\tbytes memory _bc = bytes(_c);\n', '\t\tbytes memory _bd = bytes(_d);\n', '\t\tbytes memory _be = bytes(_e);\n', '\t\tstring memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '\t\tbytes memory babcde = bytes(abcde);\n', '\t\tuint256 k = 0;\n', '\t\tfor (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '\t\tfor (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '\t\tfor (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '\t\tfor (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '\t\tfor (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '\t\treturn string(babcde);\n', '\t}\n', '\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c,\n', '\t\tstring memory _d\n', '\t) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, _c, _d, "");\n', '\t}\n', '\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c\n', '\t) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, _c, "", "");\n', '\t}\n', '\n', '\tfunction strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, "", "", "");\n', '\t}\n', '\n', '\tfunction uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n', '\t\tif (_i == 0) {\n', '\t\t\treturn "0";\n', '\t\t}\n', '\t\tuint256 j = _i;\n', '\t\tuint256 len;\n', '\t\twhile (j != 0) {\n', '\t\t\tlen++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(len);\n', '\t\tuint256 k = len - 1;\n', '\t\twhile (_i != 0) {\n', '\t\t\tbstr[k--] = bytes1(uint8(48 + (_i % 10)));\n', '\t\t\t_i /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '}\n', '\n', 'contract OwnableDelegateProxy {}\n', '\n', 'contract ProxyRegistry {\n', '\tmapping(address => OwnableDelegateProxy) public proxies;\n', '}\n', '\n', '/**\n', ' * @title ERC1155Tradable\n', ' * ERC1155Tradable - ERC1155 contract that whitelists an operator address, \n', ' * has create and mint functionality, and supports useful standards from OpenZeppelin,\n', '  like _exists(), name(), symbol(), and totalSupply()\n', ' */\n', 'contract ERC1155Tradable is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable, MinterRole, WhitelistAdminRole {\n', '\tusing Strings for string;\n', '\n', '\taddress proxyRegistryAddress;\n', '\tuint256 private _currentTokenID = 0;\n', '\tmapping(uint256 => address) public creators;\n', '\tmapping(uint256 => uint256) public tokenSupply;\n', '\tmapping(uint256 => uint256) public tokenMaxSupply;\n', '\t// Contract name\n', '\tstring public name;\n', '\t// Contract symbol\n', '\tstring public symbol;\n', '\n', '    mapping(uint256 => string) private uris;\n', '\n', '    bool private constructed = false;\n', '\n', '    function init(\n', '\t\tstring memory _name,\n', '\t\tstring memory _symbol,\n', '\t\taddress _proxyRegistryAddress\n', '\t) public {\n', '\t    \n', '\t    require(!constructed, "ERC155 Tradeable must not be constructed yet");\n', '\t    \n', '\t    constructed = true;\n', '\t    \n', '\t\tname = _name;\n', '\t\tsymbol = _symbol;\n', '\t\tproxyRegistryAddress = _proxyRegistryAddress;\n', '\t\t\n', '\t\tsuper.initOwnable();\n', '\t\tsuper.initMinter();\n', '\t\tsuper.initWhiteListAdmin();\n', '\t}\n', '\n', '\tconstructor(\n', '\t\tstring memory _name,\n', '\t\tstring memory _symbol,\n', '\t\taddress _proxyRegistryAddress\n', '\t) public {\n', '\t    constructed = true;\n', '\t\tname = _name;\n', '\t\tsymbol = _symbol;\n', '\t\tproxyRegistryAddress = _proxyRegistryAddress;\n', '\t}\n', '\n', '\tfunction removeWhitelistAdmin(address account) public onlyOwner {\n', '\t\t_removeWhitelistAdmin(account);\n', '\t}\n', '\n', '\tfunction removeMinter(address account) public onlyOwner {\n', '\t\t_removeMinter(account);\n', '\t}\n', '\n', '\tfunction uri(uint256 _id) public view returns (string memory) {\n', '\t\trequire(_exists(_id), "ERC721Tradable#uri: NONEXISTENT_TOKEN");\n', '\t\t//return super.uri(_id);\n', '\t\t\n', '\t\tif(bytes(uris[_id]).length > 0){\n', '\t\t    return uris[_id];\n', '\t\t}\n', '\t\treturn Strings.strConcat(baseMetadataURI, Strings.uint2str(_id));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the total quantity for a token ID\n', '\t * @param _id uint256 ID of the token to query\n', '\t * @return amount of token in existence\n', '\t */\n', '\tfunction totalSupply(uint256 _id) public view returns (uint256) {\n', '\t\treturn tokenSupply[_id];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the max quantity for a token ID\n', '\t * @param _id uint256 ID of the token to query\n', '\t * @return amount of token in existence\n', '\t */\n', '\tfunction maxSupply(uint256 _id) public view returns (uint256) {\n', '\t\treturn tokenMaxSupply[_id];\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Will update the base URL of token's URI\n", "\t * @param _newBaseMetadataURI New base URL of token's URI\n", '\t */\n', '\tfunction setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyWhitelistAdmin {\n', '\t\t_setBaseMetadataURI(_newBaseMetadataURI);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Creates a new token type and assigns _initialSupply to an address\n', '\t * @param _maxSupply max supply allowed\n', '\t * @param _initialSupply Optional amount to supply the first owner\n', '\t * @param _uri Optional URI for this token type\n', '\t * @param _data Optional data to pass if receiver is contract\n', '\t * @return The newly created token ID\n', '\t */\n', '\tfunction create(\n', '\t\tuint256 _maxSupply,\n', '\t\tuint256 _initialSupply,\n', '\t\tstring calldata _uri,\n', '\t\tbytes calldata _data\n', '\t) external onlyWhitelistAdmin returns (uint256 tokenId) {\n', '\t\trequire(_initialSupply <= _maxSupply, "Initial supply cannot be more than max supply");\n', '\t\tuint256 _id = _getNextTokenID();\n', '\t\t_incrementTokenTypeId();\n', '\t\tcreators[_id] = msg.sender;\n', '\n', '\t\tif (bytes(_uri).length > 0) {\n', '\t\t    uris[_id] = _uri;\n', '\t\t\temit URI(_uri, _id);\n', '\t\t}\n', '\t\telse{\n', '\t\t    emit URI(string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json")), _id);\n', '\t\t}\n', '\n', '\t\tif (_initialSupply != 0) _mint(msg.sender, _id, _initialSupply, _data);\n', '\t\ttokenSupply[_id] = _initialSupply;\n', '\t\ttokenMaxSupply[_id] = _maxSupply;\n', '\t\treturn _id;\n', '\t}\n', '\t\n', '\tfunction updateUri(uint256 _id, string calldata _uri) external onlyWhitelistAdmin{\n', '\t    if (bytes(_uri).length > 0) {\n', '\t\t    uris[_id] = _uri;\n', '\t\t\temit URI(_uri, _id);\n', '\t\t}\n', '\t\telse{\n', '\t\t    emit URI(string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json")), _id);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction burn(address _address, uint256 _id, uint256 _amount) external {\n', '\t    require((msg.sender == _address) || isApprovedForAll(_address, msg.sender), "ERC1155#burn: INVALID_OPERATOR");\n', '\t    require(balances[_address][_id] >= _amount, "Trying to burn more tokens than you own");\n', '\t    _burn(_address, _id, _amount);\n', '\t}\n', '\t\n', '\tfunction updateProxyRegistryAddress(address _proxyRegistryAddress) external onlyWhitelistAdmin{\n', '\t    require(_proxyRegistryAddress != address(0), "No zero address");\n', '\t    proxyRegistryAddress = _proxyRegistryAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Mints some amount of tokens to an address\n', '\t * @param _id          Token ID to mint\n', '\t * @param _quantity    Amount of tokens to mint\n', '\t * @param _data        Data to pass if receiver is contract\n', '\t */\n', '\tfunction mint(\n', '\t\tuint256 _id,\n', '\t\tuint256 _quantity,\n', '\t\tbytes memory _data\n', '\t) public onlyMinter {\n', '\t\tuint256 tokenId = _id;\n', '\t\trequire(tokenSupply[tokenId].add(_quantity) <= tokenMaxSupply[tokenId], "Max supply reached");\n', '\t\t_mint(msg.sender, _id, _quantity, _data);\n', '\t\ttokenSupply[_id] = tokenSupply[_id].add(_quantity);\n', '\t}\n', '\n', '\t/**\n', "\t * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\n", '\t */\n', '\t\n', '\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator) {\n', '\t\t// Whitelist OpenSea proxy contract for easy trading.\n', '\t\tProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n', '\t\tif (address(proxyRegistry.proxies(_owner)) == _operator) {\n', '\t\t\treturn true;\n', '\t\t}\n', '\n', '\t\treturn ERC1155.isApprovedForAll(_owner, _operator);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns whether the specified token exists by checking to see if it has a creator\n', '\t * @param _id uint256 ID of the token to query the existence of\n', '\t * @return bool whether the token exists\n', '\t */\n', '\tfunction _exists(uint256 _id) internal view returns (bool) {\n', '\t\treturn creators[_id] != address(0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev calculates the next token ID based on value of _currentTokenID\n', '\t * @return uint256 for the next token ID\n', '\t */\n', '\tfunction _getNextTokenID() private view returns (uint256) {\n', '\t\treturn _currentTokenID.add(1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev increments the value of _currentTokenID\n', '\t */\n', '\tfunction _incrementTokenTypeId() private {\n', '\t\t_currentTokenID++;\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Unifty\n', ' * Unifty - NFT Tools\n', ' * \n', ' * Rinkeby Opensea: 0xf57b2c51ded3a29e6891aba85459d600256cf317 \n', ' * Mainnet Opensea: 0xa5409ec958c83c3f309868babaca7c86dcb077c1\n', ' */\n', 'contract Unifty is ERC1155Tradable {\n', '    \n', '    string private _contractURI = "https://unifty.io/meta/contract.json";\n', '    \n', '\tconstructor(address _proxyRegistryAddress) public ERC1155Tradable("Unifty", "UNIF", _proxyRegistryAddress) {\n', '\t\t_setBaseMetadataURI("https://unifty.io/meta/");\n', '\t}\n', '\n', '\tfunction contractURI() public view returns (string memory) {\n', '\t\treturn _contractURI;\n', '\t}\n', '\t\n', '\tfunction setContractURI(string memory _uri) public onlyWhitelistAdmin{\n', '\t    _contractURI = _uri;\n', '\t}\n', '\t\n', '\tfunction version() external pure returns (uint256) {\n', '\t\treturn 1;\n', '\t}\n', '\t\n', '}\n', '\n', 'contract PauserRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event PauserAdded(address indexed account);\n', '    event PauserRemoved(address indexed account);\n', '\n', '    Roles.Role private _pausers;\n', '\n', '    function initPauserRole() internal{\n', '        _addPauser(_msgSender());\n', '    }\n', '\n', '    constructor () internal {\n', '        _addPauser(_msgSender());\n', '    }\n', '\n', '    modifier onlyPauser() {\n', '        require(isPauser(_msgSender()), "PauserRole: caller does not have the Pauser role");\n', '        _;\n', '    }\n', '\n', '    function isPauser(address account) public view returns (bool) {\n', '        return _pausers.has(account);\n', '    }\n', '\n', '    function addPauser(address account) public onlyPauser {\n', '        _addPauser(account);\n', '    }\n', '\n', '    function renouncePauser() public {\n', '        _removePauser(_msgSender());\n', '    }\n', '\n', '    function _addPauser(address account) internal {\n', '        _pausers.add(account);\n', '        emit PauserAdded(account);\n', '    }\n', '\n', '    function _removePauser(address account) internal {\n', '        _pausers.remove(account);\n', '        emit PauserRemoved(account);\n', '    }\n', '}\n', '\n', 'contract Pausable is Context, PauserRole {\n', '\n', '    event Paused(address account);\n', '    event Unpaused(address account);\n', '    bool private _paused;\n', '\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    function pause() public onlyPauser whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    function unpause() public onlyPauser whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', 'contract Wrap {\n', '\tusing SafeMath for uint256;\n', '\tusing SafeERC20 for IERC20;\n', '\tIERC20 public token;\n', '\n', '\tconstructor(IERC20 _tokenAddress) public {\n', '\t\ttoken = IERC20(_tokenAddress);\n', '\t}\n', '\n', '\tuint256 private _totalSupply;\n', '\tmapping(address => uint256) private _balances;\n', '\n', '\tfunction totalSupply() external view returns (uint256) {\n', '\t\treturn _totalSupply;\n', '\t}\n', '\n', '\tfunction balanceOf(address account) public view returns (uint256) {\n', '\t\treturn _balances[account];\n', '\t}\n', '\n', '\tfunction stake(uint256 amount) public {\n', '\t\t_totalSupply = _totalSupply.add(amount);\n', '\t\t_balances[msg.sender] = _balances[msg.sender].add(amount);\n', '\t\tIERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n', '\t}\n', '\n', '\tfunction withdraw(uint256 amount) public {\n', '\t\t_totalSupply = _totalSupply.sub(amount);\n', '\t\t_balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '\t\tIERC20(token).safeTransfer(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction _rescueScore(address account) internal {\n', '\t\tuint256 amount = _balances[account];\n', '\n', '\t\t_totalSupply = _totalSupply.sub(amount);\n', '\t\t_balances[account] = _balances[account].sub(amount);\n', '\t\tIERC20(token).safeTransfer(account, amount);\n', '\t}\n', '}\n', '\n', 'interface DetailedERC20 {\n', '    \n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', 'contract UniftyFarm is Wrap, Ownable, Pausable, CloneFactory, WhitelistAdminRole {\n', '\tusing SafeMath for uint256;\n', '\n', '\tstruct Card {\n', '\t\tuint256 points;\n', '\t\tuint256 releaseTime;\n', '\t\tuint256 mintFee;\n', '\t\tuint256 controllerFee;\n', '\t\taddress artist;\n', '\t\taddress erc1155;\n', '\t\tbool nsfw;\n', '\t\tbool shadowed;\n', '\t\tuint256 supply;\n', '\t}\n', '\t\n', '\taddress public nifAddress = address(0x3dF39266F1246128C39086E1b542Db0148A30d8c);\n', '\taddress payable public feeAddress = address(0x4Ae96401dA3D541Bf426205Af3d6f5c969afA3DB);\n', '    uint256 public farmFee = 1250000000000000000;\n', '    uint256 public farmFeeMinimumNif = 5000 * 10**18;\n', '    uint256[] public wildcards;\n', '    ERC1155Tradable public wildcardErc1155Address;\n', '\tbool public isCloned = false;\n', '    mapping(address => address[]) public farms;\n', '    bool public constructed = false;\n', '    \n', '    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n', '    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n', '    bytes4 constant internal ERC1155_RECEIVED_ERR_VALUE = 0x0;\n', '    \n', '\tuint256 public periodStart;\n', '\tuint256 public minStake;\n', '\tuint256 public maxStake;\n', '\tuint256 public rewardRate = 86400; // 1 point per day per staked token, multiples of this lowers time per staked token\n', '\tuint256 public totalFeesCollected;\n', '\tuint256 public spentScore;\n', '\taddress public rescuer;\n', '\taddress public controller;\n', '\n', '\tmapping(address => uint256) public pendingWithdrawals;\n', '\tmapping(address => uint256) public lastUpdateTime;\n', '\tmapping(address => uint256) public points;\n', '\tmapping(address => mapping ( uint256 => Card ) ) public cards;\n', '\n', '\tevent CardAdded(address indexed erc1155, uint256 indexed card, uint256 points, uint256 mintFee, address indexed artist, uint256 releaseTime);\n', '\tevent CardType(address indexed erc1155, uint256 indexed card, string indexed cardType);\n', '\tevent CardShadowed(address indexed erc1155, uint256 indexed card, bool indexed shadowed);\n', '\tevent Removed(address indexed erc1155, uint256 indexed card, address indexed recipient, uint256 amount);\n', '\tevent Staked(address indexed user, uint256 amount);\n', '\tevent Withdrawn(address indexed user, uint256 amount);\n', '\tevent Redeemed(address indexed user, address indexed erc1155, uint256 indexed id, uint256 amount);\n', '\tevent RescueRedeemed(address indexed user, uint256 amount);\n', '\tevent FarmCreated(address indexed user, address indexed farm, uint256 fee, string uri);\n', '\tevent FarmUri(address indexed farm, string uri);\n', '\n', '\tmodifier updateReward(address account) {\n', '\t\tif (account != address(0)) {\n', '\t\t\tpoints[account] = earned(account);\n', '\t\t\tlastUpdateTime[account] = block.timestamp;\n', '\t\t}\n', '\t\t_;\n', '\t}\n', '\n', '\tconstructor(\n', '\t\tuint256 _periodStart,\n', '\t\tuint256 _minStake,\n', '\t\tuint256 _maxStake,\n', '\t\taddress _controller,\n', '\t\tIERC20 _tokenAddress,\n', '\t\tstring memory _uri\n', '\t) public Wrap(_tokenAddress) {\n', '\t    require(_minStake >= 0 && _maxStake > 0 && _maxStake >= _minStake, "Problem with min and max stake setup");\n', '\t    constructed = true;\n', '\t\tperiodStart = _periodStart;\n', '\t\tminStake = _minStake;\n', '\t\tmaxStake = _maxStake;\n', '\t\tcontroller = _controller;\n', '\t\temit FarmCreated(msg.sender, address(this), 0, _uri);\n', '\t    emit FarmUri(address(this), _uri);\n', '\t}\n', '\n', '\tfunction cardMintFee(address erc1155Address, uint256 id) external view returns (uint256) {\n', '\t\treturn cards[erc1155Address][id].mintFee.add(cards[erc1155Address][id].controllerFee);\n', '\t}\n', '\n', '\tfunction cardReleaseTime(address erc1155Address, uint256 id) external view returns (uint256) {\n', '\t\treturn cards[erc1155Address][id].releaseTime;\n', '\t}\n', '\n', '\tfunction cardPoints(address erc1155Address, uint256 id) external view returns (uint256) {\n', '\t\treturn cards[erc1155Address][id].points;\n', '\t}\n', '\n', '\tfunction earned(address account) public view returns (uint256) {\n', '\t\t\n', '\t\tuint256 decimals = DetailedERC20(address(token)).decimals();\n', '\t\tuint256 pow = 1;\n', '\n', '        for(uint256 i = 0; i < decimals; i++){\n', '            pow = pow.mul(10);\n', '        }\n', '\t\t\n', '\t\treturn points[account].add(\n', '\t\t    getCurrPoints(account, pow)\n', '\t    );\n', '\t}\n', '\t\n', '\tfunction getCurrPoints(address account, uint256 pow) internal view returns(uint256){\n', '\t    uint256 blockTime = block.timestamp;\n', '\t    return blockTime.sub(lastUpdateTime[account]).mul(pow).div(rewardRate).mul(balanceOf(account)).div(pow);\n', '\t}\n', '\t\n', '\tfunction setRewardRate(uint256 _rewardRate) external onlyWhitelistAdmin{\n', '\t    require(_rewardRate > 0, "Reward rate too low");\n', '\t    rewardRate = _rewardRate;\n', '\t}\n', '\t\n', '\tfunction setMinMaxStake(uint256 _minStake, uint256 _maxStake) external onlyWhitelistAdmin{\n', '\t    require(_minStake >= 0 && _maxStake > 0 && _maxStake >= _minStake, "Problem with min and max stake setup");\n', '\t    minStake = _minStake;\n', '\t    maxStake = _maxStake;\n', '\t}\n', '\t\n', '\tfunction stake(uint256 amount) public updateReward(msg.sender) whenNotPaused() {\n', '\t\trequire(block.timestamp >= periodStart, "Pool not open");\n', '\t\trequire(amount.add(balanceOf(msg.sender)) >= minStake && amount.add(balanceOf(msg.sender)) > 0, "Too few deposit");\n', '\t\trequire(amount.add(balanceOf(msg.sender)) <= maxStake, "Deposit limit reached");\n', '\n', '\t\tsuper.stake(amount);\n', '\t\temit Staked(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction withdraw(uint256 amount) public updateReward(msg.sender) {\n', '\t\trequire(amount > 0, "Cannot withdraw 0");\n', '\n', '\t\tsuper.withdraw(amount);\n', '\t\temit Withdrawn(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction exit() external {\n', '\t\twithdraw(balanceOf(msg.sender));\n', '\t}\n', '\n', '\tfunction redeem(address erc1155Address, uint256 id) external payable updateReward(msg.sender) {\n', '\t\trequire(cards[erc1155Address][id].points != 0, "Card not found");\n', '\t\trequire(block.timestamp >= cards[erc1155Address][id].releaseTime, "Card not released");\n', '\t\trequire(points[msg.sender] >= cards[erc1155Address][id].points, "Redemption exceeds point balance");\n', '\t\t\n', '\t\tuint256 fees = cards[erc1155Address][id].mintFee.add( cards[erc1155Address][id].controllerFee );\n', '\t\t\n', '        // wildcards and nif passes disabled in clones\n', '        bool enableFees = fees > 0;\n', '        \n', '        if(!isCloned){\n', '            uint256 nifBalance = IERC20(nifAddress).balanceOf(msg.sender);\n', '            if(nifBalance >= farmFeeMinimumNif || iHaveAnyWildcard()){\n', '                enableFees = false;\n', '                fees = 0;\n', '            }\n', '        }\n', '        \n', '        require(msg.value == fees, "Send the proper ETH for the fees");\n', '\n', '\t\tif (enableFees) {\n', '\t\t\ttotalFeesCollected = totalFeesCollected.add(fees);\n', '\t\t\tpendingWithdrawals[controller] = pendingWithdrawals[controller].add( cards[erc1155Address][id].controllerFee );\n', '\t\t\tpendingWithdrawals[cards[erc1155Address][id].artist] = pendingWithdrawals[cards[erc1155Address][id].artist].add( cards[erc1155Address][id].mintFee );\n', '\t\t}\n', '\n', '\t\tpoints[msg.sender] = points[msg.sender].sub(cards[erc1155Address][id].points);\n', '\t\tspentScore = spentScore.add(cards[erc1155Address][id].points);\n', '\t\t\n', '\t\tERC1155Tradable(cards[erc1155Address][id].erc1155).safeTransferFrom(address(this), msg.sender, id, 1, "");\n', '\t\t\n', '\t\temit Redeemed(msg.sender, cards[erc1155Address][id].erc1155, id, cards[erc1155Address][id].points);\n', '\t}\n', '\n', '\tfunction rescueScore(address account) external updateReward(account) returns (uint256) {\n', '\t\trequire(msg.sender == rescuer, "!rescuer");\n', '\t\tuint256 earnedPoints = points[account];\n', '\t\tspentScore = spentScore.add(earnedPoints);\n', '\t\tpoints[account] = 0;\n', '\n', '\t\tif (balanceOf(account) > 0) {\n', '\t\t\t_rescueScore(account);\n', '\t\t}\n', '\n', '\t\temit RescueRedeemed(account, earnedPoints);\n', '\t\treturn earnedPoints;\n', '\t}\n', '\n', '\tfunction setController(address _controller) external onlyWhitelistAdmin {\n', '\t\tuint256 amount = pendingWithdrawals[controller];\n', '\t\tpendingWithdrawals[controller] = 0;\n', '\t\tpendingWithdrawals[_controller] = pendingWithdrawals[_controller].add(amount);\n', '\t\tcontroller = _controller;\n', '\t}\n', '\n', '\tfunction setRescuer(address _rescuer) external onlyWhitelistAdmin {\n', '\t\trescuer = _rescuer;\n', '\t}\n', '\n', '\tfunction setControllerFee(address _erc1155Address, uint256 _id, uint256 _controllerFee) external onlyWhitelistAdmin {\n', '\t\tcards[_erc1155Address][_id].controllerFee = _controllerFee;\n', '\t}\n', '\t\n', '\tfunction setShadowed(address _erc1155Address, uint256 _id, bool _shadowed) external onlyWhitelistAdmin {\n', '\t\tcards[_erc1155Address][_id].shadowed = _shadowed;\n', '\t\temit CardShadowed(_erc1155Address, _id, _shadowed);\n', '\t}\n', '\t\n', '\tfunction emitFarmUri(string calldata _uri) external onlyWhitelistAdmin{\n', '\t    emit FarmUri(address(this), _uri);\n', '\t} \n', '\t\n', '\tfunction removeNfts(address _erc1155Address, uint256 _id, uint256 _amount, address _recipient) external onlyWhitelistAdmin{\n', '\t    \n', '\t    ERC1155Tradable(_erc1155Address).safeTransferFrom(address(this), _recipient, _id, _amount, "");\n', '\t    emit Removed(_erc1155Address, _id, _recipient, _amount);\n', '\t} \n', '\n', '\tfunction createNft(\n', '\t\tuint256 _supply,\n', '\t\tuint256 _points,\n', '\t\tuint256 _mintFee,\n', '\t\tuint256 _controllerFee,\n', '\t\taddress _artist,\n', '\t\tuint256 _releaseTime,\n', '\t\taddress _erc1155Address,\n', '\t\tstring calldata _uri,\n', '\t\tstring calldata _cardType\n', '\t) external onlyWhitelistAdmin returns (uint256) {\n', '\t\tuint256 tokenId = ERC1155Tradable(_erc1155Address).create(_supply, _supply, _uri, "");\n', '\t\trequire(tokenId > 0, "ERC1155 create did not succeed");\n', '        Card storage c = cards[_erc1155Address][tokenId];\n', '\t\tc.points = _points;\n', '\t\tc.releaseTime = _releaseTime;\n', '\t\tc.mintFee = _mintFee;\n', '\t\tc.controllerFee = _controllerFee;\n', '\t\tc.artist = _artist;\n', '\t\tc.erc1155 = _erc1155Address;\n', '\t\tc.supply = _supply;\n', '\t\temitCardAdded(_erc1155Address, tokenId, _points, _mintFee, _controllerFee, _artist, _releaseTime, _cardType);\n', '\t\treturn tokenId;\n', '\t}\n', '\t\n', '\tfunction addNfts(\n', '\t\tuint256 _points,\n', '\t\tuint256 _mintFee,\n', '\t\tuint256 _controllerFee,\n', '\t\taddress _artist,\n', '\t\tuint256 _releaseTime,\n', '\t\taddress _erc1155Address,\n', '\t\tuint256 _tokenId,\n', '\t\tstring calldata _cardType,\n', '\t\tuint256 _cardAmount\n', '\t) external onlyWhitelistAdmin returns (uint256) {\n', '\t\trequire(_tokenId > 0, "Invalid token id");\n', '\t\trequire(_cardAmount > 0, "Invalid card amount");\n', '\t\tCard storage c = cards[_erc1155Address][_tokenId];\n', '\t\tc.points = _points;\n', '\t\tc.releaseTime = _releaseTime;\n', '\t\tc.mintFee = _mintFee;\n', '\t\tc.controllerFee = _controllerFee;\n', '\t\tc.artist = _artist;\n', '\t\tc.erc1155 = _erc1155Address;\n', '\t\tc.supply = c.supply.add(_cardAmount);\n', '\t\tERC1155Tradable(_erc1155Address).safeTransferFrom(msg.sender, address(this), _tokenId, _cardAmount, "");\n', '\t\temitCardAdded(_erc1155Address, _tokenId, _points, _mintFee, _controllerFee, _artist, _releaseTime, _cardType);\n', '\t\treturn _tokenId;\n', '\t}\n', '\t\n', '\tfunction updateNftData(\n', '\t    address _erc1155Address, \n', '\t    uint256 _id,\n', '\t    uint256 _points,\n', '\t\tuint256 _mintFee,\n', '\t\tuint256 _controllerFee,\n', '\t\taddress _artist,\n', '\t\tuint256 _releaseTime,\n', '\t\tbool _nsfw,\n', '\t\tbool _shadowed,\n', '\t\tstring calldata _cardType\n', '    ) external onlyWhitelistAdmin{\n', '        require(_id > 0, "Invalid token id");\n', '\t    Card storage c = cards[_erc1155Address][_id];\n', '\t\tc.points = _points;\n', '\t\tc.releaseTime = _releaseTime;\n', '\t\tc.mintFee = _mintFee;\n', '\t\tc.controllerFee = _controllerFee;\n', '\t\tc.artist = _artist;\n', '\t\tc.nsfw = _nsfw;\n', '\t\tc.shadowed = _shadowed;\n', '\t\temit CardType(_erc1155Address, _id, _cardType);\n', '\t}\n', '\t\n', '\tfunction supply(address _erc1155Address, uint256 _id) external view returns (uint256){\n', '\t    return cards[_erc1155Address][_id].supply;\n', '\t}\n', '\t\n', '\tfunction emitCardAdded(address _erc1155Address, uint256 tokenId, uint256 _points, uint256 _mintFee, uint256 _controllerFee, address _artist, uint256 _releaseTime, string memory _cardType) private onlyWhitelistAdmin{\n', '\t    emit CardAdded(_erc1155Address, tokenId, _points, _mintFee.add(_controllerFee), _artist, _releaseTime);\n', '\t\temit CardType(_erc1155Address, tokenId, _cardType);\n', '\t}\n', '\n', '\tfunction withdrawFee() external {\n', '\t\tuint256 amount = pendingWithdrawals[msg.sender];\n', '\t\trequire(amount > 0, "nothing to withdraw");\n', '\t\tpendingWithdrawals[msg.sender] = 0;\n', '\t\tmsg.sender.transfer(amount);\n', '\t}\n', '\t\n', '\tfunction getFarmsLength(address _address) external view returns (uint256) {\n', '\t    return farms[_address].length;\n', '\t}\n', '\t\n', '\tfunction onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4){\n', '\t    \n', '\t    if(ERC1155Tradable(_operator) == ERC1155Tradable(address(this))){\n', '\t    \n', '\t        return ERC1155_RECEIVED_VALUE;\n', '\t    \n', '\t    }\n', '\t    \n', '\t    return ERC1155_RECEIVED_ERR_VALUE;\n', '\t}\n', '\t\n', '\tfunction onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4){\n', '\t      \n', '        if(ERC1155Tradable(_operator) == ERC1155Tradable(address(this))){\n', '    \n', '            return ERC1155_BATCH_RECEIVED_VALUE;\n', '    \n', '        }\n', '    \n', '        return ERC1155_RECEIVED_ERR_VALUE;\n', '    }\n', '\t\n', '\t/**\n', '\t * Cloning functions\n', '\t * Disabled in clones and only working in the genesis contract.\n', '\t * */\n', '\t function init( \n', '\t    uint256 _periodStart,\n', '\t    uint256 _minStake,\n', '\t\tuint256 _maxStake,\n', '\t\taddress _controller,\n', '\t\tIERC20 _tokenAddress,\n', '\t\tstring calldata _uri,\n', '\t\taddress _creator\n', '\t) external {\n', '\t    require(!constructed && !isCloned, "UniftyFarm must not be constructed yet or cloned.");\n', '\t    require(_minStake >= 0 && _maxStake > 0 && _maxStake >= _minStake, "Problem with min and max stake setup");\n', '\t    \n', '\t    rewardRate = 86400;\n', '\t    \n', '\t    periodStart = _periodStart;\n', '\t    minStake = _minStake;\n', '\t\tmaxStake = _maxStake;\n', '\t\tcontroller = _controller;\n', '\t\ttoken = _tokenAddress;\n', '\t    \n', '\t\tsuper.initOwnable();\n', '\t\tsuper.initWhiteListAdmin();\n', '\t\tsuper.initPauserRole();\n', '\t\t\n', '\t\temit FarmCreated(_creator, address(this), 0, _uri);\n', '\t    emit FarmUri(address(this), _uri);\n', '\t}\n', '\t\n', '\t function newFarm(\n', '\t    uint256 _periodStart,\n', '\t    uint256 _minStake,\n', '\t\tuint256 _maxStake,\n', '\t\taddress _controller,\n', '\t\tIERC20 _tokenAddress,\n', '\t\tstring calldata _uri\n', '    ) external payable {\n', '\t    \n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    \n', '\t    uint256 nifBalance = IERC20(nifAddress).balanceOf(msg.sender);\n', '\t    if(nifBalance < farmFeeMinimumNif && !iHaveAnyWildcard()){\n', '\t        require(msg.value == farmFee, "Invalid farm fee");\n', '\t    }\n', '\t    \n', '\t    address clone = createClone(address(this));\n', '\t    \n', '\t    UniftyFarm(clone).init(_periodStart, _minStake, _maxStake, _controller, _tokenAddress, _uri, msg.sender);\n', '\t    UniftyFarm(clone).setCloned();\n', '\t    UniftyFarm(clone).addWhitelistAdmin(msg.sender);\n', '\t    UniftyFarm(clone).addPauser(msg.sender);\n', '\t    UniftyFarm(clone).renounceWhitelistAdmin();\n', '\t    UniftyFarm(clone).renouncePauser();\n', '\t    UniftyFarm(clone).transferOwnership(msg.sender);\n', '\t    \n', '\t    farms[msg.sender].push(clone);\n', '\t    \n', "\t    // enough NIF or a wildcard? then there won't be no fee\n", '\t    if(nifBalance < farmFeeMinimumNif && !iHaveAnyWildcard()){\n', '\t        feeAddress.transfer(msg.value);\n', '\t    }\n', '\t    \n', '\t    emit FarmCreated(msg.sender, clone, nifBalance < farmFeeMinimumNif && !iHaveAnyWildcard() ? farmFee : 0, _uri);\n', '\t    emit FarmUri(clone, _uri);\n', '\t}\n', '\t\n', '\tfunction iHaveAnyWildcard() public view returns (bool){\n', '\t    for(uint256 i = 0; i < wildcards.length; i++){\n', '\t        if(wildcardErc1155Address.balanceOf(msg.sender, wildcards[i]) > 0){\n', '\t            return true;\n', '\t        }\n', '\t    }\n', '\t  \n', '\t    return false;\n', '\t}\n', '\t\n', '\tfunction setNifAddress(address _nifAddress) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    nifAddress = _nifAddress;\n', '\t}\n', '\t\n', '\tfunction setFeeAddress(address payable _feeAddress) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    feeAddress = _feeAddress;\n', '\t}\n', '\t\n', '\tfunction setFarmFee(uint256 _farmFee) external onlyWhitelistAdmin{\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    farmFee = _farmFee;\n', '\t}\n', '\t\n', '\tfunction setFarmFeeMinimumNif(uint256 _minNif) external onlyWhitelistAdmin{\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    farmFeeMinimumNif = _minNif;\n', '\t}\n', '\t\n', '\tfunction setCloned() external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    isCloned = true;\n', '\t}\n', '\t\n', '\tfunction setWildcard(uint256 wildcard) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    wildcards.push(wildcard);\n', '\t}\n', '\t\n', '\tfunction setWildcardErc1155Address(ERC1155Tradable _address) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    wildcardErc1155Address = _address;\n', '\t}\n', '\t\n', '\t\n', '\tfunction removeWildcard(uint256 wildcard) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "Not callable from clone");\n', '\t    uint256 tmp = wildcards[wildcards.length - 1];\n', '\t    bool found = false;\n', '\t    for(uint256 i = 0; i < wildcards.length; i++){\n', '\t        if(wildcards[i] == wildcard){\n', '\t            wildcards[i] = tmp;\n', '\t            found = true;\n', '\t            break;\n', '\t        }\n', '\t    }\n', '\t    if(found){\n', '\t        delete wildcards[wildcards.length - 1];\n', '\t        wildcards.length--;\n', '\t    }\n', '\t}\n', '}\n', '\n', '\n', 'contract UniftyFarmShopAddon is  Ownable, CloneFactory, WhitelistAdminRole {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\taddress payable public feeAddress = address(0x2989018B83436C6bBa00144A8277fd859cdafA7D);\n', '    uint256 public addonFee = 1000000000000000;\n', '    uint256[] public wildcards;\n', '    ERC1155Tradable public wildcardErc1155Address;\n', '\tbool public isCloned = false;\n', '    address public farm;\n', '    bool public constructed = false;\n', '    // owner => farms\n', '    mapping(address => address[]) public addons;\n', '    // owner => farm => addon address\n', '    mapping(address => address) public addon;\n', '    \n', '    uint256 public runMode = 0; // 0 = regular farming, turned off, 1 = farming + buyout, 2 = shop, only, no farming\n', '    \n', '    mapping(address => mapping( bytes => uint256 ) ) public prices;\n', '    mapping(address => mapping( bytes => uint256 ) ) public artistPrices;\n', '    \n', '    bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n', '    bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n', '    bytes4 constant internal ERC1155_RECEIVED_ERR_VALUE = 0x0;\n', '    \n', '    event NewShop(address indexed _user, address indexed _farmAddress, address indexed _shopAddress);\n', '    \n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'FarmShopAddon: LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '    \n', '\n', '\tconstructor() public  {\n', '\t    \n', '\t    constructed = true;\n', '\t\t\n', '\t}\n', '\t\n', '\tfunction obtain(address _erc1155Address, uint256 _id, uint256 _amount) external lock payable {\n', '\t    \n', '\t    require(runMode == 1 || runMode == 2, "UniftyFarmShopAddon#obtain: Farm not open for direct sales.");\n', '\t    require(ERC1155Tradable(_erc1155Address).balanceOf(farm, _id) >= _amount, "UniftyFarmShopAddon#obtain: Desired amount exceeds stock.");\n', '\t    \n', '\t    bytes memory id = abi.encode(_id);\n', '\t    require(prices[_erc1155Address][id] != 0 || artistPrices[_erc1155Address][id] != 0, "UniftyFarmShopAddon#obtain: Price not set");\n', '\t    require(prices[_erc1155Address][id].add(artistPrices[_erc1155Address][id]).mul(_amount) == msg.value && msg.value > 0, "UniftyFarmShopAddon#obtain: Invalid value");\n', '\t    \n', '\t    (,,,,address _artist,,,,) = UniftyFarm(farm).cards(_erc1155Address, _id);\n', '\t    \n', '\t    if(address(_artist) != address(0)){\n', '\t        address(address(uint160(_artist))).transfer(artistPrices[_erc1155Address][id].mul(_amount));\n', '\t        address(address(uint160(UniftyFarm(farm).controller()))).transfer(prices[_erc1155Address][id].mul(_amount));\n', '\t    }else{\n', '\t        address(address(uint160(UniftyFarm(farm).controller()))).transfer(msg.value);\n', '\t    }\n', '\t    \n', '\t    UniftyFarm(address(farm)).removeNfts(_erc1155Address, _id, _amount, msg.sender);\n', '\t    \n', '\t}\n', '\n', '\t\n', '\tfunction getPrice(address _erc1155Address, uint256 _id) external view returns(uint256, uint256){\n', '\t    \n', '\t    return (prices[_erc1155Address][abi.encode(_id)], artistPrices[_erc1155Address][abi.encode(_id)]);\n', '\t}\n', '\t\n', '\tfunction hasAddon(address _farmAddress) external view returns(bool){\n', '\t    \n', '\t    return addon[_farmAddress] != address(0);\n', '\t}\n', '\t\n', '\tfunction getAddon(address _farmAddress) external view returns(address){\n', '\t    \n', '\t    return addon[_farmAddress];\n', '\t}\n', '\t\n', '\tfunction setPrice(address _erc1155Address, uint256 _id, uint256 _price, uint256 _artistPrice) external onlyWhitelistAdmin{\n', '\t    \n', '\t    prices[_erc1155Address][abi.encode(_id)] = _price;\n', '\t    artistPrices[_erc1155Address][abi.encode(_id)] = _artistPrice;\n', '\t}\n', '\t\n', '\tfunction setFarmStakePause(bool _paused) internal onlyWhitelistAdmin {\n', '\t    if(_paused && !UniftyFarm(address(farm)).paused()){\n', '\t        UniftyFarm(address(farm)).pause();\n', '\t    }else if(UniftyFarm(address(farm)).paused()){\n', '\t        UniftyFarm(address(farm)).unpause();\n', '\t    }\n', '\t}\n', '\t\n', '\tfunction setRunMode(uint256 _runMode) external onlyWhitelistAdmin {\n', '\t   runMode = _runMode;\n', '\t   \n', '\t   if(_runMode == 2){\n', '\t       setFarmStakePause(true);\n', '\t   }\n', '\t   else{\n', '\t       setFarmStakePause(false);\n', '\t   }\n', '\t}\n', '\t\n', '\tfunction onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4){\n', '\t    \n', '\t    if(ERC1155Tradable(_operator) == ERC1155Tradable(address(this))){\n', '\t    \n', '\t        return ERC1155_RECEIVED_VALUE;\n', '\t    \n', '\t    }\n', '\t    \n', '\t    return ERC1155_RECEIVED_ERR_VALUE;\n', '\t}\n', '\t\n', '\tfunction onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4){\n', '\t      \n', '        if(ERC1155Tradable(_operator) == ERC1155Tradable(address(this))){\n', '    \n', '            return ERC1155_BATCH_RECEIVED_VALUE;\n', '    \n', '        }\n', '    \n', '        return ERC1155_RECEIVED_ERR_VALUE;\n', '    }\n', '\t\n', '\t/**\n', '\t * Cloning functions\n', '\t * Disabled in clones and only working in the genesis contract.\n', '\t * */\n', '\t function init() external {\n', '\t    require(!constructed && !isCloned, "UniftyFarmShopAddon must not be constructed yet or cloned.");\n', '\t    \n', '\t\tsuper.initOwnable();\n', '\t\tsuper.initWhiteListAdmin();\n', '\t\tunlocked = 1;\n', '\t\t\n', '\t}\n', '\t\n', '\t function newAddon(address _farmAddress) external lock payable returns(address){\n', '\t    \n', '\t    require(!isCloned, "FarmShopAddon#newAddon: Not callable from clone");\n', '\t    require(UniftyFarm(_farmAddress).owner() == msg.sender, "FarmShopAddon#newAddon: Not the farm owner");\n', '\t    \n', '\t    if(!iHaveAnyWildcard()){\n', '\t        require(msg.value == addonFee, "FarmShopAddon#newAddon: Invalid addon fee");\n', '\t    }\n', '\t    \n', '\t    address clone = createClone(address(this));\n', '\t    \n', '\t    UniftyFarmShopAddon(clone).init();\n', '\t    UniftyFarmShopAddon(clone).setFarm(_farmAddress);\n', '\t    UniftyFarmShopAddon(clone).setCloned();\n', '\t    UniftyFarmShopAddon(clone).addWhitelistAdmin(msg.sender);\n', '\t    UniftyFarmShopAddon(clone).renounceWhitelistAdmin();\n', '\t    UniftyFarmShopAddon(clone).transferOwnership(msg.sender);\n', '\t    \n', '\t    addons[msg.sender].push(clone);\n', '\t    addon[_farmAddress] = clone;\n', '\t    \n', "\t    // enough NIF or a wildcard? then there won't be no fee\n", '\t    if(!iHaveAnyWildcard()){\n', '\t        feeAddress.transfer(msg.value);\n', '\t    }\n', '\t    \n', '\t    emit NewShop(msg.sender, _farmAddress, clone);\n', '\t    \n', '\t    return clone;\n', '\t    \n', '\t}\n', '\t\n', '\tfunction iHaveAnyWildcard() public view returns (bool){\n', '\t    for(uint256 i = 0; i < wildcards.length; i++){\n', '\t        if(wildcardErc1155Address.balanceOf(msg.sender, wildcards[i]) > 0){\n', '\t            return true;\n', '\t        }\n', '\t    }\n', '\t  \n', '\t    return false;\n', '\t}\n', '\t\n', '\tfunction setFeeAddress(address payable _feeAddress) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#setFeeAddress: Not callable from clone");\n', '\t    feeAddress = _feeAddress;\n', '\t}\n', '\t\n', '\tfunction setAddonFee(uint256 _addonFee) external onlyWhitelistAdmin{\n', '\t    require(!isCloned, "FarmShopAddon#setAddonFee: Not callable from clone");\n', '\t    addonFee = _addonFee;\n', '\t}\n', '\t\n', '\tfunction setCloned() external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#setCloned: Not callable from clone");\n', '\t    isCloned = true;\n', '\t}\n', '\t\n', '\tfunction setFarm(address _farmAddress) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#setFarm: Not callable from clone");\n', '\t    farm = _farmAddress;\n', '\t}\n', '\t\n', '\tfunction setWildcard(uint256 wildcard) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#setWildcard: Not callable from clone");\n', '\t    wildcards.push(wildcard);\n', '\t}\n', '\t\n', '\tfunction setWildcardErc1155Address(ERC1155Tradable _address) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#setWildcardErc1155Address: Not callable from clone");\n', '\t    wildcardErc1155Address = _address;\n', '\t}\n', '\t\n', '\t\n', '\tfunction removeWildcard(uint256 wildcard) external onlyWhitelistAdmin {\n', '\t    require(!isCloned, "FarmShopAddon#removeWildcard: Not callable from clone");\n', '\t    uint256 tmp = wildcards[wildcards.length - 1];\n', '\t    bool found = false;\n', '\t    for(uint256 i = 0; i < wildcards.length; i++){\n', '\t        if(wildcards[i] == wildcard){\n', '\t            wildcards[i] = tmp;\n', '\t            found = true;\n', '\t            break;\n', '\t        }\n', '\t    }\n', '\t    if(found){\n', '\t        delete wildcards[wildcards.length - 1];\n', '\t        wildcards.length--;\n', '\t    }\n', '\t}\n', '}']