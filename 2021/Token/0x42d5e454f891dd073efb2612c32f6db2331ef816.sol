['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/**\n', 'Public good from https://twitter.com/0xfoobar\n', '\n', 'Cycle through NFTX pools until you find the ID you want\n', '\n', 'See https://github.com/NFTX-project/x-contracts-private/blob/4650f3cae4c2d776ca45effba65513c9e6ec4b6b/contracts/NFTX.sol\n', '\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'interface NFTXv7 {\n', '    function requestMint(uint256 vaultId, uint256[] memory nftIds) external payable;\n', '\n', '    // Burns a Meebit, gives you MEEBIT; see https://etherscan.io/tx/0x8d443e00c0a7b702b105cb1fbc4cafbd424a5cee756965007877a164203ee359\n', '    function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount) external payable;\n', '\n', '    // Burns PUNK-BASIC, gives you a WPUNK; see https://etherscan.io/tx/0x7b30eabbcdad9a6827029ba6ffb8196fa1921f9960214b3ccc463b764b4a72ea\n', '    function redeem(uint256 vaultId, uint256 amount) external;\n', '\n', '\n', '}\n', '\n', 'interface xStore {\n', '    function xTokenAddress(uint256 vaultId) external view returns (address);\n', '    function nftAddress(uint256 vaultId) external view returns (address);\n', '}\n', '\n', 'interface IERC20 {\n', '    function transferFrom(address _from, address _to, uint256 amount) external payable;\n', '    function approve(address _spender, uint256 amount) external;\n', '}\n', '\n', 'interface IERC721 {\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '    function ownerOf(uint256 _tokenId) external view returns (address);\n', '    function approve(address _spender, uint256 _tokenId) external;\n', '}\n', '\n', 'interface ERC721TokenReceiver {\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n', '}\n', '\n', '\n', 'contract CycleNFTX is ERC721TokenReceiver {\n', '\n', '    address owner;\n', '    NFTXv7 nftx = NFTXv7(0xAf93fCce0548D3124A5fC3045adAf1ddE4e8Bf7e);\n', '    xStore store = xStore(0xBe54738723cea167a76ad5421b50cAa49692E7B7);\n', '    uint256 currentTokenId;\n', '    uint256[] desiredIds;\n', '\n', '    constructor() {\n', '        // owner = _owner;\n', '    }\n', '\n', '    // modifier onlyOwner() {\n', '    //     require(msg.sender == owner, "Not owner");\n', '    //     _;\n', '    // }\n', '\n', '    /**\n', '     * Precondition: have PUNK-BASIC tokens in your wallet and approve contract for transfer\n', '     * This will revert with out-of-gas unless the proper token is found, so no need to return tokens to user\n', '     * Uses 3.15M gas to do 10 iterations\n', '     * Uses 332k gas to do 1 iteration\n', '     */\n', '    function cycle(uint256 vaultId, uint256[] memory _desiredIds, uint256 maxIterations, bool acceptAny) public {\n', '        address xToken = store.xTokenAddress(vaultId); // PUNK-BASIC\n', '        address nftAddress = store.nftAddress(vaultId); // WPUNKS\n', '        uint256[] memory currentTokenIds = new uint256[](1);\n', '        desiredIds = _desiredIds;\n', '        IERC20(xToken).transferFrom(msg.sender, address(this), 1 ether);\n', '        uint iterations = 0;\n', '        while(true) {\n', '            IERC20(xToken).approve(address(nftx), 1 ether);\n', '            nftx.redeem(vaultId, 1);\n', '            if(acceptAny || isDesired(currentTokenId)) {\n', '                IERC721(nftAddress).transferFrom(address(this), msg.sender, currentTokenId);\n', '                return;\n', '            }\n', '            iterations += 1;\n', '            if(iterations >= maxIterations) {\n', '                require(false, "Hit maximum iterations");\n', '            }\n', '            currentTokenIds[0] = currentTokenId;\n', '            IERC721(nftAddress).approve(address(nftx), currentTokenId);\n', '            nftx.mint(vaultId, currentTokenIds, 1);\n', '        }\n', '    }\n', '\n', '    function isDesired(uint256 _tokenId) internal view returns (bool) {\n', '        for(uint i = 0; i < desiredIds.length; i++) {\n', '            if(_tokenId == desiredIds[i]) {\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) public override returns (bytes4) {\n', '        currentTokenId = _tokenId;\n', '        // TODO: hardcode this hash\n', '        return 0x150b7a02; //bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));\n', '    }\n', '\n', '}']