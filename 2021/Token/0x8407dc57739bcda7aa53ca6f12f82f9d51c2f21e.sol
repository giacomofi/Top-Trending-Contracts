['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-28\n', '*/\n', '\n', '// File: @axie/contract-library/contracts/cryptography/ECVerify.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library ECVerify {\n', '\n', '  enum SignatureMode {\n', '    EIP712,\n', '    GETH,\n', '    TREZOR\n', '  }\n', '\n', '  function recover(bytes32 _hash, bytes memory _signature) internal pure returns (address _signer) {\n', '    return recover(_hash, _signature, 0);\n', '  }\n', '\n', '  // solium-disable-next-line security/no-assign-params\n', '  function recover(bytes32 _hash, bytes memory _signature, uint256 _index) internal pure returns (address _signer) {\n', '    require(_signature.length >= _index + 66);\n', '\n', '    SignatureMode _mode = SignatureMode(uint8(_signature[_index]));\n', '    bytes32 _r;\n', '    bytes32 _s;\n', '    uint8 _v;\n', '\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly {\n', '      _r := mload(add(_signature, add(_index, 33)))\n', '      _s := mload(add(_signature, add(_index, 65)))\n', '      _v := and(255, mload(add(_signature, add(_index, 66))))\n', '    }\n', '\n', '    if (_v < 27) {\n', '      _v += 27;\n', '    }\n', '\n', '    require(_v == 27 || _v == 28);\n', '\n', '    if (_mode == SignatureMode.GETH) {\n', '      _hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash));\n', '    } else if (_mode == SignatureMode.TREZOR) {\n', '      _hash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n\\x20", _hash));\n', '    }\n', '\n', '    return ecrecover(_hash, _v, _r, _s);\n', '  }\n', '\n', '  function ecverify(bytes32 _hash, bytes memory _signature, address _signer) internal pure returns (bool _valid) {\n', '    return _signer == recover(_hash, _signature);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    require(c / a == b);\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Since Solidity automatically asserts when dividing by 0,\n', '    // but we only need it to revert.\n', '    require(b > 0);\n', '    return a / b;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Same reason as `div`.\n', '    require(b > 0);\n', '    return a % b;\n', '  }\n', '\n', '  function ceilingDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    return add(div(a, b), mod(a, b) > 0 ? 1 : 0);\n', '  }\n', '\n', '  function subU64(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function addU8(uint8 a, uint8 b) internal pure returns (uint8 c) {\n', '    c = a + b;\n', '    require(c >= a);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'interface IERC20 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  function totalSupply() external view returns (uint256 _supply);\n', '  function balanceOf(address _owner) external view returns (uint256 _balance);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool _success);\n', '  function allowance(address _owner, address _spender) external view returns (uint256 _value);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool _success);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/IERC20Mintable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'interface IERC20Mintable {\n', '  function mint(address _to, uint256 _value) external returns (bool _success);\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'interface IERC721 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  function balanceOf(address _owner) external view returns (uint256 _balance);\n', '  function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address _operator);\n', '\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool _approved);\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc721/IERC721Mintable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'interface IERC721Mintable {\n', '  function mint(address _to, uint256 _tokenId) external returns (bool);\n', '  function mintNew(address _to) external returns (uint256 _tokenId);\n', '}\n', '\n', '// File: @axie/contract-library/contracts/util/AddressUtils.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'library AddressUtils {\n', '  function toPayable(address _address) internal pure returns (address payable _payable) {\n', '    return address(uint160(_address));\n', '  }\n', '\n', '  function isContract(address _address) internal view returns (bool _correct) {\n', '    uint256 _size;\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    assembly { _size := extcodesize(_address) }\n', '    return _size > 0;\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract ERC20 is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupply;\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) public allowance;\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool _success) {\n', '    allowance[msg.sender][_spender] = _value;\n', '    emit Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool _success) {\n', '    require(_to != address(0));\n', '    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n', '    balanceOf[_to] = balanceOf[_to].add(_value);\n', '    emit Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n', '    require(_to != address(0));\n', '    balanceOf[_from] = balanceOf[_from].sub(_value);\n', '    balanceOf[_to] = balanceOf[_to].add(_value);\n', '    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n', '    emit Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/IERC20Detailed.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'interface IERC20Detailed {\n', '  function name() external view returns (string memory _name);\n', '  function symbol() external view returns (string memory _symbol);\n', '  function decimals() external view returns (uint8 _decimals);\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/ERC20Detailed.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract ERC20Detailed is ERC20, IERC20Detailed {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/access/HasAdmin.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract HasAdmin {\n', '  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\n', '  event AdminRemoved(address indexed _oldAdmin);\n', '\n', '  address public admin;\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin);\n', '    _;\n', '  }\n', '\n', '  constructor() internal {\n', '    admin = msg.sender;\n', '    emit AdminChanged(address(0), admin);\n', '  }\n', '\n', '  function changeAdmin(address _newAdmin) external onlyAdmin {\n', '    require(_newAdmin != address(0));\n', '    emit AdminChanged(admin, _newAdmin);\n', '    admin = _newAdmin;\n', '  }\n', '\n', '  function removeAdmin() external onlyAdmin {\n', '    emit AdminRemoved(admin);\n', '    admin = address(0);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/access/HasMinters.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract HasMinters is HasAdmin {\n', '  event MinterAdded(address indexed _minter);\n', '  event MinterRemoved(address indexed _minter);\n', '\n', '  address[] public minters;\n', '  mapping (address => bool) public minter;\n', '\n', '  modifier onlyMinter {\n', '    require(minter[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function addMinters(address[] memory _addedMinters) public onlyAdmin {\n', '    address _minter;\n', '\n', '    for (uint256 i = 0; i < _addedMinters.length; i++) {\n', '      _minter = _addedMinters[i];\n', '\n', '      if (!minter[_minter]) {\n', '        minters.push(_minter);\n', '        minter[_minter] = true;\n', '        emit MinterAdded(_minter);\n', '      }\n', '    }\n', '  }\n', '\n', '  function removeMinters(address[] memory _removedMinters) public onlyAdmin {\n', '    address _minter;\n', '\n', '    for (uint256 i = 0; i < _removedMinters.length; i++) {\n', '      _minter = _removedMinters[i];\n', '\n', '      if (minter[_minter]) {\n', '        minter[_minter] = false;\n', '        emit MinterRemoved(_minter);\n', '      }\n', '    }\n', '\n', '    uint256 i = 0;\n', '\n', '    while (i < minters.length) {\n', '      _minter = minters[i];\n', '\n', '      if (!minter[_minter]) {\n', '        minters[i] = minters[minters.length - 1];\n', '        delete minters[minters.length - 1];\n', '        minters.length--;\n', '      } else {\n', '        i++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function isMinter(address _addr) public view returns (bool) {\n', '    return minter[_addr];\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/token/erc20/ERC20Mintable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract ERC20Mintable is HasMinters, ERC20 {\n', '  function mint(address _to, uint256 _value) public onlyMinter returns (bool _success) {\n', '    return _mint(_to, _value);\n', '  }\n', '\n', '  function _mint(address _to, uint256 _value) internal returns (bool success) {\n', '    totalSupply = totalSupply.add(_value);\n', '    balanceOf[_to] = balanceOf[_to].add(_value);\n', '    emit Transfer(address(0), _to, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/WETH.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', 'contract WETH is ERC20Detailed {\n', '\n', '  event Deposit(\n', '    address _sender,\n', '    uint256 _value\n', '  );\n', '\n', '  event Withdrawal(\n', '    address _sender,\n', '    uint256 _value\n', '  );\n', '\n', '  constructor () ERC20Detailed("Wrapped Ether", "WETH", 18)\n', '    public\n', '  {}\n', '\n', '  function deposit()\n', '    external\n', '    payable\n', '  {\n', '    balanceOf[msg.sender] += msg.value;\n', '\n', '    emit Deposit(msg.sender, msg.value);\n', '  }\n', '\n', '  function withdraw(uint256 _wad)\n', '    external\n', '  {\n', '    require(balanceOf[msg.sender] >= _wad);\n', '    balanceOf[msg.sender] -= _wad;\n', '    msg.sender.transfer(_wad);\n', '\n', '    emit Withdrawal(msg.sender, _wad);\n', '  }\n', '}\n', '\n', '// File: @axie/contract-library/contracts/proxy/ProxyStorage.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ProxyStorage\n', ' * @dev Store the address of logic contact that the proxy should forward to.\n', ' */\n', 'contract ProxyStorage is HasAdmin {\n', '  address internal _proxyTo;\n', '}\n', '\n', '// File: @axie/contract-library/contracts/lifecycle/Pausable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract Pausable is HasAdmin {\n', '  event Paused();\n', '  event Unpaused();\n', '\n', '  bool public paused;\n', '\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '\n', '  function pause() public onlyAdmin whenNotPaused {\n', '    paused = true;\n', '    emit Paused();\n', '  }\n', '\n', '  function unpause() public onlyAdmin whenPaused {\n', '    paused = false;\n', '    emit Unpaused();\n', '  }\n', '}\n', '\n', '// File: contracts/chain/common/IValidator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', 'contract IValidator {\n', '  event ValidatorAdded(uint256 indexed _id, address indexed _validator);\n', '  event ValidatorRemoved(uint256 indexed _id, address indexed _validator);\n', '  event ThresholdUpdated(\n', '    uint256 indexed _id,\n', '    uint256 indexed _numerator,\n', '    uint256 indexed _denominator,\n', '    uint256 _previousNumerator,\n', '    uint256 _previousDenominator\n', '  );\n', '\n', '  function isValidator(address _addr) public view returns (bool);\n', '  function getValidators() public view returns (address[] memory _validators);\n', '\n', '  function checkThreshold(uint256 _voteCount) public view returns (bool);\n', '}\n', '\n', '// File: contracts/chain/common/Validator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', 'contract Validator is IValidator {\n', '  using SafeMath for uint256;\n', '\n', '  mapping(address => bool) validatorMap;\n', '  address[] public validators;\n', '  uint256 public validatorCount;\n', '\n', '  uint256 public num;\n', '  uint256 public denom;\n', '\n', '  constructor(address[] memory _validators, uint256 _num, uint256 _denom)\n', '    public\n', '  {\n', '    validators = _validators;\n', '    validatorCount = _validators.length;\n', '\n', '    for (uint256 _i = 0; _i < validatorCount; _i++) {\n', '      address _validator = _validators[_i];\n', '      validatorMap[_validator] = true;\n', '    }\n', '\n', '    num = _num;\n', '    denom = _denom;\n', '  }\n', '\n', '  function isValidator(address _addr)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return validatorMap[_addr];\n', '  }\n', '\n', '  function getValidators()\n', '    public\n', '    view\n', '    returns (address[] memory _validators)\n', '  {\n', '    _validators = validators;\n', '  }\n', '\n', '  function checkThreshold(uint256 _voteCount)\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    return _voteCount.mul(denom) >= num.mul(validatorCount);\n', '  }\n', '\n', '  function _addValidator(uint256 _id, address _validator)\n', '    internal\n', '  {\n', '    require(!validatorMap[_validator]);\n', '\n', '    validators.push(_validator);\n', '    validatorMap[_validator] = true;\n', '    validatorCount++;\n', '\n', '    emit ValidatorAdded(_id, _validator);\n', '  }\n', '\n', '  function _removeValidator(uint256 _id, address _validator)\n', '    internal\n', '  {\n', '    require(isValidator(_validator));\n', '\n', '    uint256 _index;\n', '    for (uint256 _i = 0; _i < validatorCount; _i++) {\n', '      if (validators[_i] == _validator) {\n', '        _index = _i;\n', '        break;\n', '      }\n', '    }\n', '\n', '    validatorMap[_validator] = false;\n', '    validators[_index] = validators[validatorCount - 1];\n', '    validators.pop();\n', '\n', '    validatorCount--;\n', '\n', '    emit ValidatorRemoved(_id, _validator);\n', '  }\n', '\n', '  function _updateQuorum(uint256 _id, uint256 _numerator, uint256 _denominator)\n', '    internal\n', '  {\n', '    require(_numerator <= _denominator);\n', '    uint256 _previousNumerator = num;\n', '    uint256 _previousDenominator = denom;\n', '\n', '    num = _numerator;\n', '    denom = _denominator;\n', '\n', '    emit ThresholdUpdated(\n', '      _id,\n', '      _numerator,\n', '      _denominator,\n', '      _previousNumerator,\n', '      _previousDenominator\n', '    );\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainValidator.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Validator\n', ' * @dev Simple validator contract\n', ' */\n', 'contract MainchainValidator is Validator, HasAdmin {\n', '  uint256 nonce;\n', '\n', '  constructor(\n', '    address[] memory _validators,\n', '    uint256 _num,\n', '    uint256 _denom\n', '  ) Validator(_validators, _num, _denom) public {\n', '  }\n', '\n', '  function addValidators(address[] calldata _validators) external onlyAdmin {\n', '    for (uint256 _i; _i < _validators.length; ++_i) {\n', '      _addValidator(nonce++, _validators[_i]);\n', '    }\n', '  }\n', '\n', '  function removeValidator(address _validator) external onlyAdmin {\n', '    _removeValidator(nonce++, _validator);\n', '  }\n', '\n', '  function updateQuorum(uint256 _numerator, uint256 _denominator) external onlyAdmin {\n', '    _updateQuorum(nonce++, _numerator, _denominator);\n', '  }\n', '}\n', '\n', '// File: contracts/chain/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', 'contract Registry is HasAdmin {\n', '\n', '  event ContractAddressUpdated(\n', '    string indexed _name,\n', '    bytes32 indexed _code,\n', '    address indexed _newAddress\n', '  );\n', '\n', '  event TokenMapped(\n', '    address indexed _mainchainToken,\n', '    address indexed _sidechainToken,\n', '    uint32 _standard\n', '  );\n', '\n', '  string public constant GATEWAY = "GATEWAY";\n', '  string public constant WETH_TOKEN = "WETH_TOKEN";\n', '  string public constant VALIDATOR = "VALIDATOR";\n', '  string public constant ACKNOWLEDGEMENT = "ACKNOWLEDGEMENT";\n', '\n', '  struct TokenMapping {\n', '    address mainchainToken;\n', '    address sidechainToken;\n', '    uint32 standard; // 20, 721 or any other standards\n', '  }\n', '\n', '  mapping(bytes32 => address) public contractAddresses;\n', '  mapping(address => TokenMapping) public mainchainMap;\n', '  mapping(address => TokenMapping) public sidechainMap;\n', '\n', '  function getContract(string calldata _name)\n', '    external\n', '    view\n', '    returns (address _address)\n', '  {\n', '    bytes32 _code = getCode(_name);\n', '    _address = contractAddresses[_code];\n', '    require(_address != address(0));\n', '  }\n', '\n', '  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\n', '    external\n', '    view\n', '    returns (bool)\n', '  {\n', '    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n', '\n', '    return _mapping.mainchainToken != address(0) &&\n', '      _mapping.sidechainToken != address(0) &&\n', '      _mapping.standard == _standard;\n', '  }\n', '\n', '  function updateContract(string calldata _name, address _newAddress)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    bytes32 _code = getCode(_name);\n', '    contractAddresses[_code] = _newAddress;\n', '\n', '    emit ContractAddressUpdated(_name, _code, _newAddress);\n', '  }\n', '\n', '  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    TokenMapping memory _map = TokenMapping(\n', '      _mainchainToken,\n', '      _sidechainToken,\n', '      _standard\n', '    );\n', '\n', '    mainchainMap[_mainchainToken] = _map;\n', '    sidechainMap[_sidechainToken] = _map;\n', '\n', '    emit TokenMapped(\n', '      _mainchainToken,\n', '      _sidechainToken,\n', '      _standard\n', '    );\n', '  }\n', '\n', '  function clearMapToken(address _mainchainToken, address _sidechainToken)\n', '    external\n', '    onlyAdmin\n', '  {\n', '    TokenMapping storage _mainchainMap = mainchainMap[_mainchainToken];\n', '    _clearMapEntry(_mainchainMap);\n', '\n', '    TokenMapping storage _sidechainMap = sidechainMap[_sidechainToken];\n', '    _clearMapEntry(_sidechainMap);\n', '  }\n', '\n', '  function getMappedToken(\n', '    address _token,\n', '    bool _isMainchain\n', '  )\n', '    external\n', '    view\n', '  returns (\n', '    address _mainchainToken,\n', '    address _sidechainToken,\n', '    uint32 _standard\n', '  )\n', '  {\n', '    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n', '    _mainchainToken = _mapping.mainchainToken;\n', '    _sidechainToken = _mapping.sidechainToken;\n', '    _standard = _mapping.standard;\n', '  }\n', '\n', '  function getCode(string memory _name)\n', '    public\n', '    pure\n', '    returns (bytes32)\n', '  {\n', '    return keccak256(abi.encodePacked(_name));\n', '  }\n', '\n', '  function _getTokenMapping(\n', '    address _token,\n', '    bool isMainchain\n', '  )\n', '    internal\n', '    view\n', '    returns (TokenMapping memory _mapping)\n', '  {\n', '    if (isMainchain) {\n', '      _mapping = mainchainMap[_token];\n', '    } else {\n', '      _mapping = sidechainMap[_token];\n', '    }\n', '  }\n', '\n', '  function _clearMapEntry(TokenMapping storage _entry)\n', '    internal\n', '  {\n', '    _entry.mainchainToken = address(0);\n', '    _entry.sidechainToken = address(0);\n', '    _entry.standard = 0;\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainGatewayStorage.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title GatewayStorage\n', ' * @dev Storage of deposit and withdraw information.\n', ' */\n', 'contract MainchainGatewayStorage is ProxyStorage, Pausable {\n', '\n', '  event TokenDeposited(\n', '    uint256 indexed _depositId,\n', '    address indexed _owner,\n', '    address indexed _tokenAddress,\n', '    address _sidechainAddress,\n', '    uint32  _standard,\n', '    uint256 _tokenNumber // ERC-20 amount or ERC721 tokenId\n', '  );\n', '\n', '  event TokenWithdrew(\n', '    uint256 indexed _withdrawId,\n', '    address indexed _owner,\n', '    address indexed _tokenAddress,\n', '    uint256 _tokenNumber\n', '  );\n', '\n', '  struct DepositEntry {\n', '    address owner;\n', '    address tokenAddress;\n', '    address sidechainAddress;\n', '    uint32  standard;\n', '    uint256 tokenNumber;\n', '  }\n', '\n', '  struct WithdrawalEntry {\n', '    address owner;\n', '    address tokenAddress;\n', '    uint256 tokenNumber;\n', '  }\n', '\n', '  Registry public registry;\n', '\n', '  uint256 public depositCount;\n', '  DepositEntry[] public deposits;\n', '  mapping(uint256 => WithdrawalEntry) public withdrawals;\n', '\n', '  function updateRegistry(address _registry) external onlyAdmin {\n', '    registry = Registry(_registry);\n', '  }\n', '}\n', '\n', '// File: contracts/chain/mainchain/MainchainGatewayManager.sol\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title MainchainGatewayManager\n', ' * @dev Logic to handle deposits and withdrawl on Mainchain.\n', ' */\n', 'contract MainchainGatewayManager is MainchainGatewayStorage {\n', '  using AddressUtils for address;\n', '  using SafeMath for uint256;\n', '  using ECVerify for bytes32;\n', '\n', '  modifier onlyMappedToken(address _token, uint32 _standard) {\n', '    require(\n', '      registry.isTokenMapped(_token, _standard, true),\n', '      "MainchainGatewayManager: Token is not mapped"\n', '    );\n', '    _;\n', '  }\n', '\n', '  modifier onlyNewWithdrawal(uint256 _withdrawalId) {\n', '    WithdrawalEntry storage _entry = withdrawals[_withdrawalId];\n', '    require(_entry.owner == address(0) && _entry.tokenAddress == address(0));\n', '    _;\n', '  }\n', '\n', '  // Should be able to withdraw from WETH\n', '  function()\n', '    external\n', '    payable\n', '  {}\n', '\n', '  function depositEth()\n', '    external\n', '    whenNotPaused\n', '    payable\n', '    returns (uint256)\n', '  {\n', '    return depositEthFor(msg.sender);\n', '  }\n', '\n', '  function depositERC20(address _token, uint256 _amount)\n', '    external\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    return depositERC20For(msg.sender, _token, _amount);\n', '  }\n', '\n', '  function depositERC721(address _token, uint256 _tokenId)\n', '    external\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    return depositERC721For(msg.sender, _token, _tokenId);\n', '  }\n', '\n', '  function depositEthFor(address _owner)\n', '    public\n', '    whenNotPaused\n', '    payable\n', '    returns (uint256)\n', '  {\n', '    address _weth = registry.getContract(registry.WETH_TOKEN());\n', '    WETH(_weth).deposit.value(msg.value)();\n', '    return _createDepositEntry(_owner, _weth, 20, msg.value);\n', '  }\n', '\n', '  function depositERC20For(address _user, address _token, uint256 _amount)\n', '    public\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    require(\n', '      IERC20(_token).transferFrom(msg.sender, address(this), _amount),\n', '      "MainchainGatewayManager: ERC-20 token transfer failed"\n', '    );\n', '    return _createDepositEntry(_user, _token, 20, _amount);\n', '  }\n', '\n', '  function depositERC721For(address _user, address _token, uint256 _tokenId)\n', '    public\n', '    whenNotPaused\n', '    returns (uint256)\n', '  {\n', '    IERC721(_token).transferFrom(msg.sender, address(this), _tokenId);\n', '    return _createDepositEntry(_user, _token, 721, _tokenId);\n', '  }\n', '\n', '  function depositBulkFor(\n', '    address _user,\n', '    address[] memory _tokens,\n', '    uint256[] memory _tokenNumbers\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    require(_tokens.length == _tokenNumbers.length);\n', '\n', '    for (uint256 _i = 0; _i < _tokens.length; _i++) {\n', '      address _token = _tokens[_i];\n', '      uint256 _tokenNumber = _tokenNumbers[_i];\n', '      (,, uint32 _standard) = registry.getMappedToken(_token, true);\n', '\n', '      if (_standard == 20) {\n', '        depositERC20For(_user, _token, _tokenNumber);\n', '      } else if (_standard == 721) {\n', '        depositERC721For(_user, _token, _tokenNumber);\n', '      } else {\n', '        revert("Token is not mapped or token type not supported");\n', '      }\n', '    }\n', '  }\n', '\n', '  function withdrawToken(\n', '    uint256 _withdrawalId,\n', '    address _token,\n', '    uint256 _amount,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    withdrawTokenFor(\n', '      _withdrawalId,\n', '      msg.sender,\n', '      _token,\n', '      _amount,\n', '      _signatures\n', '    );\n', '  }\n', '\n', '  function withdrawTokenFor(\n', '    uint256 _withdrawalId,\n', '    address _user,\n', '    address _token,\n', '    uint256 _amount,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    (,, uint32 _tokenType) = registry.getMappedToken(_token, true);\n', '\n', '    if (_tokenType == 20) {\n', '      withdrawERC20For(\n', '        _withdrawalId,\n', '        _user,\n', '        _token,\n', '        _amount,\n', '        _signatures\n', '      );\n', '    } else if (_tokenType == 721) {\n', '      withdrawERC721For(\n', '        _withdrawalId,\n', '        _user,\n', '        _token,\n', '        _amount,\n', '        _signatures\n', '      );\n', '    }\n', '  }\n', '\n', '  function withdrawERC20(\n', '    uint256 _withdrawalId,\n', '    address _token,\n', '    uint256 _amount,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    withdrawERC20For(\n', '      _withdrawalId,\n', '      msg.sender,\n', '      _token,\n', '      _amount,\n', '      _signatures\n', '    );\n', '  }\n', '\n', '  function withdrawERC20For(\n', '    uint256 _withdrawalId,\n', '    address _user,\n', '    address _token,\n', '    uint256 _amount,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '    onlyMappedToken(_token, 20)\n', '  {\n', '    bytes32 _hash = keccak256(\n', '      abi.encodePacked(\n', '        "withdrawERC20",\n', '        _withdrawalId,\n', '        _user,\n', '        _token,\n', '        _amount\n', '      )\n', '    );\n', '\n', '    require(verifySignatures(_hash, _signatures));\n', '\n', '    if (_token == registry.getContract(registry.WETH_TOKEN())) {\n', '      _withdrawETHFor(_user, _amount);\n', '    } else {\n', '      uint256 _gatewayBalance = IERC20(_token).balanceOf(address(this));\n', '\n', '      if (_gatewayBalance < _amount) {\n', '        require(\n', '          IERC20Mintable(_token).mint(address(this), _amount.sub(_gatewayBalance)),\n', '          "MainchainGatewayManager: Minting ERC20 token to gateway failed"\n', '        );\n', '      }\n', '\n', '      require(IERC20(_token).transfer(_user, _amount), "Transfer failed");\n', '    }\n', '\n', '    _insertWithdrawalEntry(\n', '      _withdrawalId,\n', '      _user,\n', '      _token,\n', '      _amount\n', '    );\n', '  }\n', '\n', '  function withdrawERC721(\n', '    uint256 _withdrawalId,\n', '    address _token,\n', '    uint256 _tokenId,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    withdrawERC721For(\n', '      _withdrawalId,\n', '      msg.sender,\n', '      _token,\n', '      _tokenId,\n', '      _signatures\n', '    );\n', '  }\n', '\n', '  function withdrawERC721For(\n', '    uint256 _withdrawalId,\n', '    address _user,\n', '    address _token,\n', '    uint256 _tokenId,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    whenNotPaused\n', '    onlyMappedToken(_token, 721)\n', '  {\n', '    bytes32 _hash = keccak256(\n', '      abi.encodePacked(\n', '        "withdrawERC721",\n', '        _withdrawalId,\n', '        _user,\n', '        _token,\n', '        _tokenId\n', '      )\n', '    );\n', '\n', '    require(verifySignatures(_hash, _signatures));\n', '\n', '    if (!_tryERC721TransferFrom(_token, address(this), _user, _tokenId)) {\n', '      require(\n', '        IERC721Mintable(_token).mint(_user, _tokenId),\n', '        "MainchainGatewayManager: Minting ERC721 token to gateway failed"\n', '      );\n', '    }\n', '\n', '    _insertWithdrawalEntry(_withdrawalId, _user, _token, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev returns true if there is enough signatures from validators.\n', '   */\n', '  function verifySignatures(\n', '    bytes32 _hash,\n', '    bytes memory _signatures\n', '  )\n', '    public\n', '    view\n', '    returns (bool)\n', '  {\n', '    uint256 _signatureCount = _signatures.length.div(66);\n', '\n', '    Validator _validator = Validator(registry.getContract(registry.VALIDATOR()));\n', '    uint256 _validatorCount = 0;\n', '    address _lastSigner = address(0);\n', '\n', '    for (uint256 i = 0; i < _signatureCount; i++) {\n', '      address _signer = _hash.recover(_signatures, i.mul(66));\n', '      if (_validator.isValidator(_signer)) {\n', '        _validatorCount++;\n', '      }\n', '      // Prevent duplication of signatures\n', '      require(_signer > _lastSigner);\n', '      _lastSigner = _signer;\n', '    }\n', '\n', '    return _validator.checkThreshold(_validatorCount);\n', '  }\n', '\n', '  function _createDepositEntry(\n', '    address _owner,\n', '    address _token,\n', '    uint32 _standard,\n', '    uint256 _number\n', '  )\n', '    internal\n', '    onlyMappedToken(_token, _standard)\n', '    returns (uint256 _depositId)\n', '  {\n', '    (,address _sidechainToken, uint32 _tokenStandard) = registry.getMappedToken(_token, true);\n', '    require(_standard == _tokenStandard);\n', '\n', '    DepositEntry memory _entry = DepositEntry(\n', '      _owner,\n', '      _token,\n', '      _sidechainToken,\n', '      _standard,\n', '      _number\n', '    );\n', '\n', '    deposits.push(_entry);\n', '    _depositId = depositCount++;\n', '\n', '    emit TokenDeposited(\n', '      _depositId,\n', '      _owner,\n', '      _token,\n', '      _sidechainToken,\n', '      _standard,\n', '      _number\n', '    );\n', '  }\n', '\n', '  function _insertWithdrawalEntry(\n', '    uint256 _withdrawalId,\n', '    address _owner,\n', '    address _token,\n', '    uint256 _number\n', '  )\n', '    internal\n', '    onlyNewWithdrawal(_withdrawalId)\n', '  {\n', '    WithdrawalEntry memory _entry = WithdrawalEntry(\n', '      _owner,\n', '      _token,\n', '      _number\n', '    );\n', '\n', '    withdrawals[_withdrawalId] = _entry;\n', '\n', '    emit TokenWithdrew(_withdrawalId, _owner, _token, _number);\n', '  }\n', '\n', '  function _withdrawETHFor(\n', '    address _user,\n', '    uint256 _amount\n', '  )\n', '    internal\n', '  {\n', '    address _weth = registry.getContract(registry.WETH_TOKEN());\n', '    WETH(_weth).withdraw(_amount);\n', '    _user.toPayable().transfer(_amount);\n', '  }\n', '\n', '  // See more here https://blog.polymath.network/try-catch-in-solidity-handling-the-revert-exception-f53718f76047\n', '  function _tryERC721TransferFrom(\n', '    address _token,\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    returns (bool)\n', '  {\n', '    (bool success,) = _token.call(\n', '      abi.encodeWithSelector(\n', '        IERC721(_token).transferFrom.selector, _from, _to, _tokenId\n', '      )\n', '    );\n', '    return success;\n', '  }\n', '}']