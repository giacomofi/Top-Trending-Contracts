['pragma solidity ^0.6.11;\n', '\n', 'import "ERC20.sol"; // basic ERC20 functionality, including _mint and _burn\n', 'import "SafeERC20.sol"; // call ERC20 safely\n', 'import "SafeMath.sol";\n', 'import "Address.sol";\n', '\n', 'contract SVC001 is ERC20 {\n', '\tusing SafeERC20 for IERC20;\n', '\tusing Address for address;\n', '    using SafeMath for uint256;\n', '\n', '    address public governance;\n', '    uint256 constant public LOOP_LIMIT = 200;\n', '\n', '    constructor () public ERC20("Stacker.vc VCFund1 Token", "SVC001") {\n', '    \tgovernance = msg.sender;\n', '    \t_setupDecimals(8);\n', '\t}\n', '\n', '\t// NOTE: set governance to 0x0 in order to disable minting\n', '\tfunction setGovernance(address _governance) external {\n', '\t\trequire(msg.sender == governance, "SVC001: !governance");\n', '\t\tgovernance = _governance;\n', '\t}\n', '\n', '\tfunction mint(address _account, uint256 _amount) external {\n', '\t\trequire(msg.sender == governance, "SVC001: !governance");\n', '\t\t_mint(_account, _amount);\n', '\t}\n', '\n', '\tfunction mintMany(address[] calldata _accounts, uint256[] calldata _amounts) external {\n', '\t\trequire(msg.sender == governance, "SVC001: !governance");\n', '\t\trequire(_accounts.length == _amounts.length, "SVC001: length mismatch");\n', '\t\trequire(_accounts.length <= LOOP_LIMIT, "SVC001: length > LOOP_LIMIT");\n', '\n', '\t\tfor (uint256 i = 0; i < _accounts.length; i++){\n', '\t\t\t_mint(_accounts[i], _amounts[i]);\n', '\t\t}\n', '\t}\n', '}']