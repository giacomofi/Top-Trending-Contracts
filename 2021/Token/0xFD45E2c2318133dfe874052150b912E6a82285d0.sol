['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-29\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.3;\n', '\n', '\n', 'abstract contract ERC20Basic {\n', '    uint256 public totalSupply;\n', '    function balanceOf(address who) virtual public view returns (uint256);\n', '    function transfer(address to, uint256 value) virtual public returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    function allowance(address owner, address spender) virtual public view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) virtual public returns (bool);\n', '    function approve(address spender, uint256 value) virtual public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    function isOwnable() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract BasicToken is Ownable, ERC20Basic {\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) internal allowed;\n', '    function transfer(address to, uint256 value) public override(ERC20Basic) returns (bool) {\n', '        require(to != address(0));\n', '        require(value <= balances[msg.sender]);\n', '\n', '        assert(balances[msg.sender] <= value);\n', '        balances[msg.sender] = balances[msg.sender] - (value);\n', '        balances[to] = balances[to]+(value);\n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    function balanceOf(address _owner) public override(ERC20Basic) view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    function transferFrom(address from, address to, uint256 value) public override(ERC20Basic) returns (bool) {\n', '        require(to != address(0));\n', '        require(value <= balances[from]);\n', '        require(value <= allowed[from][msg.sender]);\n', '        assert(balances[from] <= value);\n', '        balances[from] = balances[from]- (value);\n', '        balances[to] = balances[to] + (value);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender] - (value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '    function approve(address spender, uint256 value) public override(ERC20Basic) returns (bool) {\n', '        allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '    function allowance(address owner, address spender) public override(ERC20Basic) view returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '    function increaseApproval(address spender, uint addedValue) public returns (bool) {\n', '        allowed[msg.sender][spender] = allowed[msg.sender][spender] + (addedValue);\n', '        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {\n', '        uint oldValue = allowed[msg.sender][spender];\n', '        if (subtractedValue > oldValue) {\n', '            allowed[msg.sender][spender] = 0;\n', '        } else {\n', '            assert(oldValue <= subtractedValue);\n', '            allowed[msg.sender][spender] = oldValue - (subtractedValue);\n', '        }\n', '        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '    event Mint(address indexed to, uint256 amount);\n', '    event MintFinished();\n', '    bool public mintingFinished = false;\n', '    modifier canMint() {\n', '        require(!mintingFinished);\n', '        _;\n', '    }\n', '    function mint(address to, uint256 amount) onlyOwner canMint virtual public returns (bool) {\n', '        totalSupply = totalSupply+(amount);\n', '        balances[to] = balances[to]+(amount);\n', '        emit Mint(to, amount);\n', '        emit Transfer(address(0), to, amount);\n', '        return true;\n', '    }\n', '    function finishMinting() onlyOwner canMint public returns (bool) {\n', '        mintingFinished = true;\n', '        emit MintFinished();\n', '        return true;\n', '    }\n', '    event Burn(address indexed burner, uint256 value);\n', '    function burn(uint256 _amount) public {\n', '        require(_amount <= balances[msg.sender]);\n', '        address burner = msg.sender;\n', '        assert(balances[burner] <= _amount);\n', '        balances[burner] = balances[burner] - (_amount);\n', '        assert(totalSupply <= _amount);\n', '        totalSupply = totalSupply - (_amount);\n', '        emit Burn(burner, _amount);\n', '    }\n', '}\n', '\n', '/*contract ICogwayToken is Ownable, VariableSupplyToken {\n', 'function mint(address to, uint256 amount) public override(MintableToken) returns (bool);\n', 'function burn(uint256 _amount) public override(VariableSupplyToken);\n', '}*/\n', '\n', 'contract Cogway is BasicToken {\n', '    string public name = "Cogway Token";\n', '    uint8 public decimals = 8;\n', '    string public symbol = "COG";\n', '    string public version = "0.1";\n', '    constructor(uint256 total_supply) {\n', '        totalSupply += total_supply;\n', '    }\n', '}']