['# @version 0.2.12\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', 'event Transfer:\n', '    sender: indexed(address)\n', '    receiver: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'event Approval:\n', '    owner: indexed(address)\n', '    spender: indexed(address)\n', '    value: uint256\n', '\n', '\n', 'allowance: public(HashMap[address, HashMap[address, uint256]])\n', 'balanceOf: public(HashMap[address, uint256])\n', 'totalSupply: public(uint256)\n', 'nonces: public(HashMap[address, uint256])\n', 'DOMAIN_SEPARATOR: public(bytes32)\n', "DOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n", 'PERMIT_TYPE_HASH: constant(bytes32) = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n', '\n', 'YFI: constant(address) = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e\n', '\n', '\n', '@external\n', 'def __init__():\n', '    self.DOMAIN_SEPARATOR = keccak256(\n', '        concat(\n', '            DOMAIN_TYPE_HASH,\n', '            keccak256(convert("Woofy", Bytes[5])),\n', '            keccak256(convert("1", Bytes[1])),\n', '            convert(chain.id, bytes32),\n', '            convert(self, bytes32)\n', '        )\n', '    )\n', '\n', '\n', '@view\n', '@external\n', 'def name() -> String[5]:\n', '    return "Woofy"\n', '\n', '\n', '@view\n', '@external\n', 'def symbol() -> String[5]:\n', '    return "WOOFY"\n', '\n', '\n', '@view\n', '@external\n', 'def decimals() -> uint256:\n', '    return 12\n', '\n', '\n', '@internal\n', 'def _mint(receiver: address, amount: uint256):\n', '    assert not receiver in [self, ZERO_ADDRESS]\n', '\n', '    self.balanceOf[receiver] += amount\n', '    self.totalSupply += amount\n', '\n', '    log Transfer(ZERO_ADDRESS, receiver, amount)\n', '\n', '\n', '@internal\n', 'def _burn(sender: address, amount: uint256):\n', '    self.balanceOf[sender] -= amount\n', '    self.totalSupply -= amount\n', '\n', '    log Transfer(sender, ZERO_ADDRESS, amount)\n', '\n', '\n', '@internal\n', 'def _transfer(sender: address, receiver: address, amount: uint256):\n', '    assert not receiver in [self, ZERO_ADDRESS]\n', '\n', '    self.balanceOf[sender] -= amount\n', '    self.balanceOf[receiver] += amount\n', '\n', '    log Transfer(sender, receiver, amount)\n', '\n', '\n', '@external\n', 'def transfer(receiver: address, amount: uint256) -> bool:\n', '    self._transfer(msg.sender, receiver, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\n', '    self.allowance[sender][msg.sender] -= amount\n', '    self._transfer(sender, receiver, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(spender: address, amount: uint256) -> bool:\n', '    self.allowance[msg.sender][spender] = amount\n', '    log Approval(msg.sender, spender, amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def woof(amount: uint256 = MAX_UINT256, receiver: address = msg.sender) -> bool:\n', '    mint_amount: uint256 = min(amount, ERC20(YFI).balanceOf(msg.sender))\n', '    assert ERC20(YFI).transferFrom(msg.sender, self, mint_amount)\n', '    self._mint(receiver, mint_amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def unwoof(amount: uint256 = MAX_UINT256, receiver: address = msg.sender) -> bool:\n', '    burn_amount: uint256 = min(amount, self.balanceOf[msg.sender])\n', '    self._burn(msg.sender, burn_amount)\n', '    assert ERC20(YFI).transfer(receiver, burn_amount)\n', '    return True\n', '\n', '\n', '@external\n', 'def permit(owner: address, spender: address, amount: uint256, expiry: uint256, signature: Bytes[65]) -> bool:\n', '    assert owner != ZERO_ADDRESS  # dev: invalid owner\n', '    assert expiry == 0 or expiry >= block.timestamp  # dev: permit expired\n', '    nonce: uint256 = self.nonces[owner]\n', '    digest: bytes32 = keccak256(\n', '        concat(\n', "            b'\\x19\\x01',\n", '            self.DOMAIN_SEPARATOR,\n', '            keccak256(\n', '                concat(\n', '                    PERMIT_TYPE_HASH,\n', '                    convert(owner, bytes32),\n', '                    convert(spender, bytes32),\n', '                    convert(amount, bytes32),\n', '                    convert(nonce, bytes32),\n', '                    convert(expiry, bytes32),\n', '                )\n', '            )\n', '        )\n', '    )\n', '    # NOTE: signature is packed as r, s, v\n', '    r: uint256 = convert(slice(signature, 0, 32), uint256)\n', '    s: uint256 = convert(slice(signature, 32, 32), uint256)\n', '    v: uint256 = convert(slice(signature, 64, 1), uint256)\n', '    assert ecrecover(digest, v, r, s) == owner  # dev: invalid signature\n', '    self.allowance[owner][spender] = amount\n', '    self.nonces[owner] = nonce + 1\n', '    log Approval(owner, spender, amount)\n', '    return True']