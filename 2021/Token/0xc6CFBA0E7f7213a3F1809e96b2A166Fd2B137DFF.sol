['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.6.6;\n', '\n', 'interface Token {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'contract HackerFederation {\n', '    using SafeMath for uint256;\n', '\n', '    // Hashrate decimals\n', '    uint256 public constant hashRateDecimals = 5;\n', '    // 10 usdt = 1 T\n', '    uint256 public constant hashRatePerUsdt = 10;\n', '    // Manager address\n', '    address public owner;\n', '    // Root address\n', '    address public rootAddress;\n', '    // Burn address\n', '    address public burnAddress;\n', '\n', '    // DAI-HE3 pair address\n', '    address public daiToHe3Address;\n', '\n', '    // DAI ERC20 address\n', '    address public daiTokenAddress;\n', '    Token tokenDai;\n', '    // HE-3 ERC20 address\n', '    address public he3TokenAddress;\n', '    Token tokenHe3;\n', '\n', '    // HE-1 ERC20 address\n', '    address public he1TokenAddress;\n', '\n', '    // Userinfo\n', '    struct User {\n', '        address superior;\n', '        uint256 hashRate;\n', '        bool isUser;\n', '    }\n', '    mapping(address => User) public users;\n', '\n', '    // Buy hashrate event\n', '    event LogBuyHashRate(address indexed owner, address indexed superior, uint256 hashRate);\n', '\n', '    constructor(\n', '        address _rootAddress, \n', '        address _burnAddress, \n', '        address _daiToHe3Address, \n', '        address _daiTokenAddress, \n', '        address _he3TokenAddress, \n', '        address _he1TokenAddress\n', '    ) public {\n', '        owner = msg.sender;\n', '        rootAddress = _rootAddress;\n', '        burnAddress = _burnAddress;\n', '        daiToHe3Address = _daiToHe3Address;\n', '\n', '        daiTokenAddress = _daiTokenAddress;\n', '        tokenDai = Token(daiTokenAddress);\n', '\n', '        he3TokenAddress = _he3TokenAddress;\n', '        tokenHe3 = Token(he3TokenAddress);\n', '\n', '        he1TokenAddress = _he1TokenAddress;\n', '    }\n', '\n', '    // Modifier func\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "This function is restricted to the owner");\n', '        _;\n', '    }\n', '\n', '    modifier notAddress0(address newAddress) {\n', '        require(newAddress != address(0), "Address should not be address(0)");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Use HE-1 to buy hashrate\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `_tokenAmount`: Amount of HE-1 \n', "     * - `_superior`: User's inviter\n", '     */\n', '    function buyHashRateWithHE1(uint256 _tokenAmount, address _superior) public {\n', '        _buyHashRate(he1TokenAddress, _tokenAmount, _tokenAmount.div(10**12), _superior);\n', '    }\n', '\n', '    /**\n', '     * Use HE-3 to buy hashrate\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `_tokenAmount`: Amount of HE-3\n', "     * - `_superior`: User's inviter\n", '     */\n', '    function buyHashRateWithHE3(uint256 _tokenAmount, address _superior) public {\n', '        uint256 totalDai = getHe3ToDai(_tokenAmount);\n', '        _buyHashRate(he3TokenAddress, _tokenAmount, totalDai.div(10**12), _superior);\n', '    }\n', '\n', '    /**\n', '     * Buy hashrate\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `_token`: HE-1 or HE-3 address\n', '     * - `_tokenAmount`: Amount of token\n', '     * - `_usdtAmount`: Value of _tokenAmount to USDT\n', '     * - `_superior`: inviter\n', '     */\n', '    function _buyHashRate(address _tokenAddress,uint256 _tokenAmount, uint256 _usdtAmount, address _superior) internal {\n', '        // require _superior\n', '        require(users[_superior].isUser || _superior == rootAddress, "Superiorshould be a user or rootAddress");\n', '        \n', '        // burn the token sent by user\n', '        bool sent = Token(_tokenAddress).transferFrom(msg.sender, burnAddress, _tokenAmount);\n', '        require(sent, "Token transfer failed");\n', '\n', '        // USDT decimals = 6\n', '        require(_usdtAmount >= 10000000, "Usdt should be great than or equal 10");\n', '        \n', '        uint256 hashRate = _usdtAmount.div(10).div(hashRatePerUsdt);\n', '        if (users[msg.sender].isUser) {\n', '            users[msg.sender].hashRate = users[msg.sender].hashRate.add(hashRate);\n', '        } else {\n', '            users[msg.sender].superior = _superior;\n', '            users[msg.sender].hashRate = hashRate;\n', '            users[msg.sender].isUser = true;\n', '        }\n', '        \n', '        // Buy hashrate event\n', '        emit LogBuyHashRate(msg.sender, _superior, hashRate);\n', '    }\n', '\n', '    // Update owner address\n', '    function updateOwnerAddress(address _newOwnerAddress) public onlyOwner {\n', '        owner = _newOwnerAddress;\n', '    }\n', '\n', '    // Update burn address\n', '    function updateBurnAddress(address _newBurnAddress) public onlyOwner {\n', '        burnAddress = _newBurnAddress;\n', '    }\n', '\n', '    // update HE-3 contract address\n', '    function updateHe3TokenAddress(address _he3TokenAddress) public onlyOwner notAddress0(_he3TokenAddress) {\n', '        he3TokenAddress = _he3TokenAddress;\n', '        tokenHe3 = Token(he3TokenAddress);\n', '    }\n', '\n', '    // update HE-1 contract address\n', '    function updateHe1TokenAddress(address _he1TokenAddress) public onlyOwner notAddress0(_he1TokenAddress) {\n', '        he1TokenAddress = _he1TokenAddress;\n', '    }\n', '\n', '    // update DAI contract address\n', '    function updateDaiToHe3AddressAddress(address _daiToHe3Address) public onlyOwner notAddress0(_daiToHe3Address) {\n', '        daiToHe3Address = _daiToHe3Address;\n', '    }\n', '\n', '    // update DAI-HE3 uniswap pair contract address\n', '    function updateDaiTokenAddress(address _daiTokenAddress) public onlyOwner notAddress0(_daiTokenAddress) {\n', '        daiTokenAddress = _daiTokenAddress;\n', '        tokenDai = Token(daiTokenAddress);\n', '    }\n', '\n', '    /**\n', '     * Is user?\n', '     */\n', '    function isUser(address _userAddress) public view returns (bool) {\n', '        return users[_userAddress].isUser;\n', '    }\n', '\n', '    // Get amount 1 HE3 to DAI\n', '    function getDaiPerHe3() public view returns (uint256) {\n', '        return getHe3ToDai(10**18);\n', '    }\n', '\n', '    // Get amount _he3Amount HE3 to DAI \n', '    function getHe3ToDai(uint256 _he3Amount) internal view returns (uint256) {\n', '        return tokenDai.balanceOf(daiToHe3Address).mul(_he3Amount).div(tokenHe3.balanceOf(daiToHe3Address));\n', '    }\n', '}']