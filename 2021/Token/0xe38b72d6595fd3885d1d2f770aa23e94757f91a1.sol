['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-13\n', '*/\n', '\n', '// SPDX-License-Identifier: Unlicense\n', 'pragma solidity 0.8.2;\n', '\n', '// interface need to claim rouge tokens from contract and handle upgraded functions\n', 'abstract contract IERC20 {\n', '    function balanceOf(address owner) public view virtual returns (uint256);\n', '\n', '    function transfer(address to, uint256 amount) public virtual;\n', '\n', '    function allowance(address owner, address spender)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint256);\n', '\n', '    function totalSupply() public view virtual returns (uint256);\n', '}\n', '\n', '// interface to potential future upgraded contract,\n', '// only essential write functions that need check that this contract is caller\n', 'abstract contract IUpgradedToken {\n', '    function transferByLegacy(\n', '        address sender,\n', '        address to,\n', '        uint256 amount\n', '    ) public virtual returns (bool);\n', '\n', '    function transferFromByLegacy(\n', '        address sender,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) public virtual returns (bool);\n', '\n', '    function approveByLegacy(\n', '        address sender,\n', '        address spender,\n', '        uint256 amount\n', '    ) public virtual;\n', '}\n', '\n', '//\n', '// The ultimate ERC20 token contract for TecraCoin project\n', '//\n', 'contract TcrToken {\n', '    //\n', '    // ERC20 basic information\n', '    //\n', '    uint8 public constant decimals = 8;\n', '    string public constant name = "TecraCoin";\n', '    string public constant symbol = "TCR";\n', '    uint256 private _totalSupply;\n', '    uint256 public constant maxSupply = 21000000000000000;\n', '\n', '    string public constant version = "1";\n', '    uint256 public immutable getChainId;\n', '\n', '    //\n', '    // other flags, data and constants\n', '    //\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    bool public paused;\n', '\n', '    bool public deprecated;\n', '    address public upgradedAddress;\n', '\n', '    bytes32 public immutable DOMAIN_SEPARATOR;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH =\n', '        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    string private constant ERROR_DAS = "Different array sizes";\n', '    string private constant ERROR_BTL = "Balance too low";\n', '    string private constant ERROR_ATL = "Allowance too low";\n', '    string private constant ERROR_OO = "Only Owner";\n', '\n', '    //\n', '    // events\n', '    //\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Paused();\n', '    event Unpaused();\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    event AddedToBlacklist(address indexed account);\n', '    event RemovedFromBlacklist(address indexed account);\n', '\n', '    //\n', '    // data stores\n', '    //\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => bool) public isBlacklisted;\n', '\n', '    mapping(address => bool) public isBlacklistAdmin;\n', '    mapping(address => bool) public isMinter;\n', '    mapping(address => bool) public isPauser;\n', '\n', '    mapping(address => uint256) public nonces;\n', '\n', '    //\n', '    // contract constructor\n', '    //\n', '    constructor() {\n', '        owner = msg.sender;\n', '        getChainId = block.chainid;\n', '        // EIP712 Domain\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256(\n', '                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '                ),\n', '                keccak256(bytes(name)),\n', '                keccak256(bytes(version)),\n', '                block.chainid,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    //\n', '    // "approve"\n', '    //\n', '    function approve(address spender, uint256 amount) external {\n', '        if (deprecated) {\n', '            return\n', '                IUpgradedToken(upgradedAddress).approveByLegacy(\n', '                    msg.sender,\n', '                    spender,\n', '                    amount\n', '                );\n', '        }\n', '        _approve(msg.sender, spender, amount);\n', '    }\n', '\n', '    //\n', '    // "burnable"\n', '    //\n', '    function burn(uint256 amount) external {\n', '        require(_balances[msg.sender] >= amount, ERROR_BTL);\n', '        _burn(msg.sender, amount);\n', '    }\n', '\n', '    function burnFrom(address from, uint256 amount) external {\n', '        require(_allowances[msg.sender][from] >= amount, ERROR_ATL);\n', '        require(_balances[from] >= amount, ERROR_BTL);\n', '        _approve(msg.sender, from, _allowances[msg.sender][from] - amount);\n', '        _burn(from, amount);\n', '    }\n', '\n', '    //\n', '    // "transfer"\n', '    //\n', '    function transfer(address to, uint256 amount) external returns (bool) {\n', '        if (deprecated) {\n', '            return\n', '                IUpgradedToken(upgradedAddress).transferByLegacy(\n', '                    msg.sender,\n', '                    to,\n', '                    amount\n', '                );\n', '        }\n', '        require(_balances[msg.sender] >= amount, ERROR_BTL);\n', '        _transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) external returns (bool) {\n', '        if (deprecated) {\n', '            return\n', '                IUpgradedToken(upgradedAddress).transferFromByLegacy(\n', '                    msg.sender,\n', '                    from,\n', '                    to,\n', '                    amount\n', '                );\n', '        }\n', '        _allowanceTransfer(msg.sender, from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // non-ERC20 functionality\n', '    //\n', '    // Rouge tokens and ETH withdrawal\n', '    function acquire(address token) external onlyOwner {\n', '        if (token == address(0)) {\n', '            payable(owner).transfer(address(this).balance);\n', '        } else {\n', '            uint256 amount = IERC20(token).balanceOf(address(this));\n', '            require(amount > 0, ERROR_BTL);\n', '            IERC20(token).transfer(owner, amount);\n', '        }\n', '    }\n', '\n', '    //\n', '    // "blacklist"\n', '    //\n', '    function addBlacklister(address user) external onlyOwner {\n', '        isBlacklistAdmin[user] = true;\n', '    }\n', '\n', '    function removeBlacklister(address user) external onlyOwner {\n', '        isBlacklistAdmin[user] = false;\n', '    }\n', '\n', '    modifier onlyBlacklister {\n', '        require(isBlacklistAdmin[msg.sender], "Not a Blacklister");\n', '        _;\n', '    }\n', '\n', '    modifier notOnBlacklist(address user) {\n', '        require(!isBlacklisted[user], "Address on blacklist");\n', '        _;\n', '    }\n', '\n', '    function addBlacklist(address user) external onlyBlacklister {\n', '        isBlacklisted[user] = true;\n', '        emit AddedToBlacklist(user);\n', '    }\n', '\n', '    function removeBlacklist(address user) external onlyBlacklister {\n', '        isBlacklisted[user] = false;\n', '        emit RemovedFromBlacklist(user);\n', '    }\n', '\n', '    function burnBlackFunds(address user) external onlyOwner {\n', '        require(isBlacklisted[user], "Address not on blacklist");\n', '        _burn(user, _balances[user]);\n', '    }\n', '\n', '    //\n', '    // "bulk transfer"\n', '    //\n', '    // transfer to list of address-amount\n', '    function bulkTransfer(address[] calldata to, uint256[] calldata amount)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(to.length == amount.length, ERROR_DAS);\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            require(_balances[msg.sender] >= amount[i], ERROR_BTL);\n', '            _transfer(msg.sender, to[i], amount[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // transferFrom to list of address-amount\n', '    function bulkTransferFrom(\n', '        address from,\n', '        address[] calldata to,\n', '        uint256[] calldata amount\n', '    ) external returns (bool) {\n', '        require(to.length == amount.length, ERROR_DAS);\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            _allowanceTransfer(msg.sender, from, to[i], amount[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // send same amount to multiple addresses\n', '    function bulkTransfer(address[] calldata to, uint256 amount)\n', '        external\n', '        returns (bool)\n', '    {\n', '        require(_balances[msg.sender] >= amount * to.length, ERROR_BTL);\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            _transfer(msg.sender, to[i], amount);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // send same amount to multiple addresses by allowance\n', '    function bulkTransferFrom(\n', '        address from,\n', '        address[] calldata to,\n', '        uint256 amount\n', '    ) external returns (bool) {\n', '        require(_balances[from] >= amount * to.length, ERROR_BTL);\n', '        for (uint256 i = 0; i < to.length; i++) {\n', '            _allowanceTransfer(msg.sender, from, to[i], amount);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    //\n', '    // "mint"\n', '    //\n', '    modifier onlyMinter {\n', '        require(isMinter[msg.sender], "Not a Minter");\n', '        _;\n', '    }\n', '\n', '    function addMinter(address user) external onlyOwner {\n', '        isMinter[user] = true;\n', '    }\n', '\n', '    function removeMinter(address user) external onlyOwner {\n', '        isMinter[user] = false;\n', '    }\n', '\n', '    function mint(address to, uint256 amount) external onlyMinter {\n', '        _balances[to] += amount;\n', '        _totalSupply += amount;\n', '        require(_totalSupply < maxSupply, "You can not mine that much");\n', '        emit Transfer(address(0), to, amount);\n', '    }\n', '\n', '    //\n', '    // "ownable"\n', '    //\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, ERROR_OO);\n', '        _;\n', '    }\n', '\n', '    function giveOwnership(address _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(msg.sender == newOwner, ERROR_OO);\n', '        newOwner = address(0);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    //\n', '    // "pausable"\n', '    //\n', '    function addPauser(address user) external onlyOwner {\n', '        isPauser[user] = true;\n', '    }\n', '\n', '    function removePauser(address user) external onlyOwner {\n', '        isPauser[user] = false;\n', '    }\n', '\n', '    modifier onlyPauser {\n', '        require(isPauser[msg.sender], "Not a Pauser");\n', '        _;\n', '    }\n', '\n', '    modifier notPaused {\n', '        require(!paused, "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    function pause() external onlyPauser notPaused {\n', '        paused = true;\n', '        emit Paused();\n', '    }\n', '\n', '    function unpause() external onlyPauser {\n', '        require(paused, "Contract not paused");\n', '        paused = false;\n', '        emit Unpaused();\n', '    }\n', '\n', '    //\n', '    // "permit"\n', '    // Uniswap integration EIP-2612\n', '    //\n', '    function permit(\n', '        address user,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        require(deadline >= block.timestamp, "permit: EXPIRED");\n', '        bytes32 digest =\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    "\\x19\\x01",\n', '                    DOMAIN_SEPARATOR,\n', '                    keccak256(\n', '                        abi.encode(\n', '                            PERMIT_TYPEHASH,\n', '                            user,\n', '                            spender,\n', '                            value,\n', '                            nonces[user]++,\n', '                            deadline\n', '                        )\n', '                    )\n', '                )\n', '            );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '        require(\n', '            recoveredAddress != address(0) && recoveredAddress == user,\n', '            "permit: INVALID_SIGNATURE"\n', '        );\n', '        _approve(user, spender, value);\n', '    }\n', '\n', '    //\n', '    // upgrade contract\n', '    //\n', '    function upgrade(address token) external onlyOwner {\n', '        deprecated = true;\n', '        upgradedAddress = token;\n', '    }\n', '\n', '    //\n', '    // ERC20 view functions\n', '    //\n', '    function balanceOf(address account) external view returns (uint256) {\n', '        if (deprecated) {\n', '            return IERC20(upgradedAddress).balanceOf(account);\n', '        }\n', '        return _balances[account];\n', '    }\n', '\n', '    function allowance(address account, address spender)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (deprecated) {\n', '            return IERC20(upgradedAddress).allowance(account, spender);\n', '        }\n', '        return _allowances[account][spender];\n', '    }\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        if (deprecated) {\n', '            return IERC20(upgradedAddress).totalSupply();\n', '        }\n', '        return _totalSupply;\n', '    }\n', '\n', '    //\n', '    // internal functions\n', '    //\n', '    function _approve(\n', '        address account,\n', '        address spender,\n', '        uint256 amount\n', '    ) private notOnBlacklist(account) notOnBlacklist(spender) notPaused {\n', '        _allowances[account][spender] = amount;\n', '        emit Approval(account, spender, amount);\n', '    }\n', '\n', '    function _allowanceTransfer(\n', '        address spender,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) private {\n', '        require(_allowances[from][spender] >= amount, ERROR_ATL);\n', '        require(_balances[from] >= amount, ERROR_BTL);\n', '\n', '        // exception for Uniswap "approve forever"\n', '        if (_allowances[from][spender] != type(uint256).max) {\n', '            _approve(from, spender, _allowances[from][spender] - amount);\n', '        }\n', '\n', '        _transfer(from, to, amount);\n', '    }\n', '\n', '    function _burn(address from, uint256 amount) private notPaused {\n', '        _balances[from] -= amount;\n', '        _totalSupply -= amount;\n', '        emit Transfer(from, address(0), amount);\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) private notOnBlacklist(from) notOnBlacklist(to) notPaused {\n', '        require(to != address(0), "Use burn instead");\n', '        require(from != address(0), "What a Terrible Failure");\n', '        _balances[from] -= amount;\n', '        _balances[to] += amount;\n', '        emit Transfer(from, to, amount);\n', '    }\n', '}\n', '\n', '// rav3n_pl was here']