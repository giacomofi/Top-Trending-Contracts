['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-06\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () public {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract OXYI is Ownable{\n', '    using SafeMath for uint256;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => bool) public whitelist;\n', '\n', '    string public name = "Oxyi Value Token";\n', '    string public symbol = "OXYI";\n', '    uint8 public decimals = 18;\n', '    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);\n', '    uint256 public totalPooled;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    constructor() public {\n', '        totalPooled = 50 * (uint256(10) ** decimals);\n', '        \n', "        // Initially assign all non-pooled tokens to the contract's creator.\n", '        balanceOf[msg.sender] = totalSupply.sub(totalPooled);\n', '        \n', '        emit Transfer(address(0), msg.sender, totalSupply.sub(totalPooled));\n', '    }\n', '    \n', '    // Ensure a redemption is profitable before allowing a redeem()\n', '    modifier profitable() {\n', '        require(is_profitable(), "Redeeming is not yet profitable.");\n', '        _;\n', '    } \n', '    \n', '    // VIEWS \n', '    \n', '    // Get the number of tokens to be redeemed from the pool\n', '    function numberRedeemed(uint256 amount) \n', '        public \n', '        view \n', '        returns (uint256 profit) {\n', '        uint256 numerator = amount.mul(totalPooled);  \n', '        uint256 denominator = totalSupply.sub(totalPooled);  \n', '        return numerator.div(denominator);\n', '    }\n', '    \n', '    // Check if more than 50% of the token is pooled\n', '    function is_profitable() \n', '        public \n', '        view \n', '        returns (bool _profitable) {\n', '        return totalPooled > totalSupply.sub(totalPooled);\n', '    }\n', '\n', '\n', '    // SETTERS\n', '\n', '    function addToWhitelist(address _addr) \n', '        public \n', '        onlyOwner {\n', '        whitelist[_addr] = true;\n', '    }\n', '    \n', '    function removeFromWhitelist(address _addr) \n', '        public \n', '        onlyOwner {\n', '        whitelist[_addr] = false;\n', '    }\n', '    \n', '    // TRANSFER FUNCTIONS \n', '    \n', '    // BOA-TOKEN <- Sell taxed\n', '    // TOKEN-BOA <- Buy (not taxed)\n', '    \n', '    function transfer(address to, uint256 value) \n', '        public \n', '        returns (bool success) {\n', '        require(balanceOf[msg.sender] >= value);\n', '        \n', '        if(whitelist[msg.sender]) return regular_transfer(to, value);\n', '        else return burn_transfer(to, value);\n', '    }\n', '    \n', '    function burn_transfer(address to, uint256 value) \n', '        private \n', '        returns (bool success) {\n', '        // send 1% to the pooled ledger\n', '        uint256 burned_amount = value.div(100);\n', '        \n', "        // withdraw from the user's balance\n", '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(burned_amount);\n', '        // increment the total pooled amount\n', '        totalPooled = totalPooled.add(burned_amount);\n', '        \n', '        value = value.sub(burned_amount);\n', '        \n', '        // perform a normal transfer on the remaining 99%\n', '        return regular_transfer(to, value);\n', '    }\n', '\n', '    function regular_transfer(address to, uint256 value) \n', '        private \n', '        returns (bool success) {\n', '        // perform a normal transfer \n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);  \n', '        balanceOf[to] = balanceOf[to].add(value);                   \n', '        emit Transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint256 value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        require(value <= balanceOf[from]);\n', '        require(value <= allowance[from][msg.sender]);\n', '\n', '        // allow feeless for the RED-BLUE uniswap pool\n', '        if(whitelist[msg.sender]) return regular_transferFrom(from, to, value);\n', '        else return burn_transferFrom(from, to, value); \n', '\n', '    }\n', '    \n', '    function burn_transferFrom(address from, address to, uint256 value) \n', '        private \n', '        returns (bool success) {\n', '        // send 1% to the pooled ledger\n', '        uint256 burned_amount = value.div(100);\n', '        \n', "        // remove from the spender's balance\n", '        balanceOf[from] = balanceOf[from].sub(burned_amount);\n', '        // increment the total pooled amount\n', '        totalPooled = totalPooled.add(burned_amount);\n', '        \n', '        // burn allowance (for approved spenders)\n', '        allowance[from][msg.sender] = allowance[from][msg.sender].sub(burned_amount);\n', '        \n', '        value = value.sub(burned_amount);\n', '        \n', '        // perform a normal transfer on the 99%\n', '        return regular_transferFrom(from, to, value);\n', '    }\n', '    \n', '    function regular_transferFrom(address from, address to, uint256 value) \n', '        private\n', '        returns (bool success) {\n', '        // transfer without adding to a pool\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        \n', '        // remove allowance (for approved spenders)\n', '        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        emit Transfer(from, to, value);\n', '        return true;\n', '    }\n', '    \n', '    // REDEEM AND BURN FUNCTIONS\n', '    \n', '    // amount = number of tokens to burn\n', '    function redeem(uint256 amount) \n', '        public \n', '        profitable \n', '        returns (bool success) {\n', '        // the amount must be less than the total amount pooled\n', '        require(amount <= balanceOf[msg.sender]);\n', '        require(totalPooled >= amount); \n', '    \tuint256 num_redeemed = numberRedeemed(amount);\n', '        \n', '        // make sure the number available to be redeemed is smaller than the available pool\n', '\t    require(num_redeemed < totalPooled);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(num_redeemed);\n', '        \n', '        emit Transfer(_owner, msg.sender, num_redeemed);\n', '        totalPooled = totalPooled.sub(num_redeemed);\n', '        \n', '        // burn the amount sent\n', '        return burn(amount);\n', '    }\n', '    \n', '    function burn(uint256 value) \n', '        private \n', '        returns (bool success) {\n', "        // burn from the user's ledger, transfer to 0x0\n", '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(value);  \n', '        balanceOf[address(0)] = balanceOf[address(0)].add(value);\n', '        emit Transfer(msg.sender, address(0), value);\n', '        \n', '        // remove the burned amount from the total supply\n', '        totalSupply = totalSupply.sub(value);\n', '        return true;\n', '    }\n', '    \n', '    // APPROVAL FUNCTIONS\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '\n', '    function approve(address spender, uint256 value)\n', '        public\n', '        returns (bool success)\n', '    {\n', '        allowance[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '}']