['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '// File: math/SafeMath.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    require(b <= a, "SafeMath: subtraction overflow");\n', '    return a - b;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Since Solidity automatically asserts when dividing by 0,\n', '    // but we only need it to revert.\n', '    require(b > 0, "SafeMath: division by zero");\n', '    return a / b;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    // Same reason as `div`.\n', '    require(b > 0, "SafeMath: modulo by zero");\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// File: token/erc20/IERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'interface IERC20 {\n', '  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '  function totalSupply() external view returns (uint256 _supply);\n', '  function balanceOf(address _owner) external view returns (uint256 _balance);\n', '\n', '  function approve(address _spender, uint256 _value) external returns (bool _success);\n', '  function allowance(address _owner, address _spender) external view returns (uint256 _value);\n', '\n', '  function transfer(address _to, uint256 _value) external returns (bool _success);\n', '  function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\n', '}\n', '\n', '// File: token/erc20/ERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', 'contract ERC20 is IERC20 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public totalSupply;\n', '  mapping (address => uint256) public balanceOf;\n', '  mapping (address => mapping (address => uint256)) internal _allowance;\n', '\n', '  function approve(address _spender, uint256 _value) public returns (bool) {\n', '    _approve(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) public view returns (uint256) {\n', '    return _allowance[_owner][_spender];\n', '  }\n', '\n', '  function increaseAllowance(address _spender, uint256 _value) public returns (bool) {\n', '    _approve(msg.sender, _spender, _allowance[msg.sender][_spender].add(_value));\n', '    return true;\n', '  }\n', '\n', '  function decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\n', '    _approve(msg.sender, _spender, _allowance[msg.sender][_spender].sub(_value));\n', '    return true;\n', '  }\n', '\n', '  function transfer(address _to, uint256 _value) public returns (bool _success) {\n', '    _transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n', '    _transfer(_from, _to, _value);\n', '    _approve(_from, msg.sender, _allowance[_from][msg.sender].sub(_value));\n', '    return true;\n', '  }\n', '\n', '  function _approve(address _owner, address _spender, uint256 _amount) internal {\n', '    require(_owner != address(0), "ERC20: approve from the zero address");\n', '    require(_spender != address(0), "ERC20: approve to the zero address");\n', '\n', '    _allowance[_owner][_spender] = _amount;\n', '    emit Approval(_owner, _spender, _amount);\n', '  }\n', '\n', '  function _transfer(address _from, address _to, uint256 _value) internal {\n', '    require(_from != address(0), "ERC20: transfer from the zero address");\n', '    require(_to != address(0), "ERC20: transfer to the zero address");\n', '    require(_to != address(this), "ERC20: transfer to this contract address");\n', '\n', '    balanceOf[_from] = balanceOf[_from].sub(_value);\n', '    balanceOf[_to] = balanceOf[_to].add(_value);\n', '    emit Transfer(_from, _to, _value);\n', '  }\n', '}\n', '\n', '// File: token/erc20/IERC20Detailed.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'interface IERC20Detailed {\n', '  function name() external view returns (string memory _name);\n', '  function symbol() external view returns (string memory _symbol);\n', '  function decimals() external view returns (uint8 _decimals);\n', '}\n', '\n', '// File: token/erc20/ERC20Detailed.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', 'contract ERC20Detailed is ERC20, IERC20Detailed {\n', '  string public name;\n', '  string public symbol;\n', '  uint8 public decimals;\n', '\n', '  constructor(string memory _name, string memory _symbol, uint8 _decimals) public {\n', '    name = _name;\n', '    symbol = _symbol;\n', '    decimals = _decimals;\n', '  }\n', '}\n', '\n', '// File: token/erc20/ERC20GatewayWhitelist.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'contract ERC20GatewayWhitelist is ERC20 {\n', '  address public mainchainGateway;\n', '\n', '  function allowance(address _owner, address _spender)\n', '    public\n', '    view\n', '    returns (uint256 _value)\n', '  {\n', '    if (_spender == mainchainGateway) return uint256(-1);\n', '\n', '    return _allowance[_owner][_spender];\n', '  }\n', '\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _value\n', '  )\n', '    public\n', '    returns (bool _success)\n', '  {\n', '    if (allowance(_from, msg.sender) != uint256(-1)) {\n', '      super._approve(_from, msg.sender, _allowance[_from][msg.sender].sub(_value));\n', '    }\n', '\n', '    _transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  function _setGateway(address _mainchainGateway) internal {\n', '    require(\n', '      _mainchainGateway != address(0),\n', '      "ERC20GatewayWhitelist: setting gateway to the zero address"\n', '    );\n', '    mainchainGateway = _mainchainGateway;\n', '  }\n', '}\n', '\n', '// File: access/HasAdmin.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'contract HasAdmin {\n', '  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\n', '  event AdminRemoved(address indexed _oldAdmin);\n', '\n', '  address public admin;\n', '\n', '  modifier onlyAdmin {\n', '    require(msg.sender == admin, "HasAdmin: not admin");\n', '    _;\n', '  }\n', '\n', '  constructor() internal {\n', '    admin = msg.sender;\n', '    emit AdminChanged(address(0), admin);\n', '  }\n', '\n', '  function changeAdmin(address _newAdmin) external onlyAdmin {\n', '    require(_newAdmin != address(0), "HasAdmin: new admin is the zero address");\n', '    emit AdminChanged(admin, _newAdmin);\n', '    admin = _newAdmin;\n', '  }\n', '\n', '  function removeAdmin() external onlyAdmin {\n', '    emit AdminRemoved(admin);\n', '    admin = address(0);\n', '  }\n', '}\n', '\n', '// File: access/HasMinters.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', 'contract HasMinters is HasAdmin {\n', '  event MinterAdded(address indexed _minter);\n', '  event MinterRemoved(address indexed _minter);\n', '\n', '  address[] public minters;\n', '  mapping (address => bool) public minter;\n', '\n', '  modifier onlyMinter {\n', '    require(minter[msg.sender]);\n', '    _;\n', '  }\n', '\n', '  function addMinters(address[] memory _addedMinters) public onlyAdmin {\n', '    address _minter;\n', '\n', '    for (uint256 i = 0; i < _addedMinters.length; i++) {\n', '      _minter = _addedMinters[i];\n', '\n', '      if (!minter[_minter]) {\n', '        minters.push(_minter);\n', '        minter[_minter] = true;\n', '        emit MinterAdded(_minter);\n', '      }\n', '    }\n', '  }\n', '\n', '  function removeMinters(address[] memory _removedMinters) public onlyAdmin {\n', '    address _minter;\n', '\n', '    for (uint256 i = 0; i < _removedMinters.length; i++) {\n', '      _minter = _removedMinters[i];\n', '\n', '      if (minter[_minter]) {\n', '        minter[_minter] = false;\n', '        emit MinterRemoved(_minter);\n', '      }\n', '    }\n', '\n', '    uint256 i = 0;\n', '\n', '    while (i < minters.length) {\n', '      _minter = minters[i];\n', '\n', '      if (!minter[_minter]) {\n', '        minters[i] = minters[minters.length - 1];\n', '        delete minters[minters.length - 1];\n', '        minters.length--;\n', '      } else {\n', '        i++;\n', '      }\n', '    }\n', '  }\n', '\n', '  function isMinter(address _addr) public view returns (bool) {\n', '    return minter[_addr];\n', '  }\n', '}\n', '\n', '// File: token/erc20/ERC20Mintable.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', 'contract ERC20Mintable is HasMinters, ERC20 {\n', '  function mint(address _to, uint256 _value) public onlyMinter returns (bool _success) {\n', '    return _mint(_to, _value);\n', '  }\n', '\n', '  function _mint(address _to, uint256 _value) internal returns (bool success) {\n', '    totalSupply = totalSupply.add(_value);\n', '    balanceOf[_to] = balanceOf[_to].add(_value);\n', '    emit Transfer(address(0), _to, _value);\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: SmoothLovePotion.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', 'contract SmoothLovePotion is ERC20Detailed, ERC20Mintable, ERC20GatewayWhitelist {\n', '  constructor(address _mainchainGateway)\n', '    public\n', '    ERC20Detailed("Smooth Love Potion", "SLP", 0)\n', '  {\n', '    _setGateway(_mainchainGateway);\n', '\n', '    address[] memory _minters = new address[](1);\n', '    _minters[0] = _mainchainGateway;\n', '    addMinters(_minters);\n', '  }\n', '}']