['# @version 0.2.11\n', '"""\n', '@title Tokenized Gauge Wrapper: Unit Protocol Edition\n', '@author Curve Finance\n', '@license MIT\n', '@notice Tokenizes gauge deposits to allow claiming of CRV when\n', '        deposited as a collateral within the unit.xyz Vault\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', '\n', 'interface LiquidityGauge:\n', '    def lp_token() -> address: view\n', '    def minter() -> address: view\n', '    def crv_token() -> address: view\n', '    def deposit(_value: uint256): nonpayable\n', '    def withdraw(_value: uint256): nonpayable\n', '    def claimable_tokens(addr: address) -> uint256: nonpayable\n', '\n', 'interface Minter:\n', '    def mint(gauge_addr: address): nonpayable\n', '\n', 'interface UnitVault:\n', '    def collaterals(asset: address, user: address) -> uint256: nonpayable\n', '\n', '\n', 'event Deposit:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event Withdraw:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event Transfer:\n', '    _from: indexed(address)\n', '    _to: indexed(address)\n', '    _value: uint256\n', '\n', 'event Approval:\n', '    _owner: indexed(address)\n', '    _spender: indexed(address)\n', '    _value: uint256\n', '\n', '\n', 'minter: public(address)\n', 'crv_token: public(address)\n', 'lp_token: public(address)\n', 'gauge: public(address)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'depositedBalanceOf: public(HashMap[address, uint256])\n', 'totalSupply: public(uint256)\n', 'allowances: HashMap[address, HashMap[address, uint256]]\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', '\n', '# caller -> recipient -> can deposit?\n', 'approved_to_deposit: public(HashMap[address, HashMap[address, bool]])\n', '\n', 'crv_integral: uint256\n', 'crv_integral_for: HashMap[address, uint256]\n', 'claimable_crv: public(HashMap[address, uint256])\n', '\n', '# [uint216 claimable balance][uint40 timestamp]\n', 'last_claim_data: uint256\n', '\n', '# https://github.com/unitprotocol/core/blob/master/contracts/Vault.sol\n', 'UNIT_VAULT: constant(address) = 0xb1cFF81b9305166ff1EFc49A129ad2AfCd7BCf19\n', '\n', '\n', '@external\n', 'def __init__(\n', '    _name: String[64],\n', '    _symbol: String[32],\n', '    _gauge: address,\n', '):\n', '    """\n', '    @notice Contract constructor\n', '    @param _name Token full name\n', '    @param _symbol Token symbol\n', '    @param _gauge Liquidity gauge contract address\n', '    """\n', '\n', '    self.name = _name\n', '    self.symbol = _symbol\n', '\n', '    lp_token: address = LiquidityGauge(_gauge).lp_token()\n', '    ERC20(lp_token).approve(_gauge, MAX_UINT256)\n', '\n', '    self.minter = LiquidityGauge(_gauge).minter()\n', '    self.crv_token = LiquidityGauge(_gauge).crv_token()\n', '    self.lp_token = lp_token\n', '    self.gauge = _gauge\n', '\n', '\n', '@external\n', 'def decimals() -> uint256:\n', '    return 18\n', '\n', '\n', '@internal\n', 'def _checkpoint(_user_addresses: address[2]):\n', '    claim_data: uint256 = self.last_claim_data\n', '    I: uint256 = self.crv_integral\n', '\n', '    if block.timestamp != claim_data % 2**40:\n', '        last_claimable: uint256 = shift(claim_data, -40)\n', '        claimable: uint256 = LiquidityGauge(self.gauge).claimable_tokens(self)\n', '        d_reward: uint256 = claimable - last_claimable\n', '        total_balance: uint256 = self.totalSupply\n', '        if total_balance > 0:\n', '            I += 10 ** 18 * d_reward / total_balance\n', '            self.crv_integral = I\n', '        self.last_claim_data = block.timestamp + shift(claimable, 40)\n', '\n', '    for addr in _user_addresses:\n', '        if addr in [ZERO_ADDRESS, UNIT_VAULT]:\n', '            # do not calculate an integral for the vault to ensure it cannot ever claim\n', '            continue\n', '        user_integral: uint256 = self.crv_integral_for[addr]\n', '        if user_integral < I:\n', '            user_balance: uint256 = self.balanceOf[addr] + self.depositedBalanceOf[addr]\n', '            self.claimable_crv[addr] += user_balance * (I - user_integral) / 10 ** 18\n', '            self.crv_integral_for[addr] = I\n', '\n', '\n', '@external\n', 'def user_checkpoint(addr: address) -> bool:\n', '    """\n', '    @notice Record a checkpoint for `addr`\n', '    @param addr User address\n', '    @return bool success\n', '    """\n', '    self._checkpoint([addr, ZERO_ADDRESS])\n', '    return True\n', '\n', '\n', '@external\n', 'def claimable_tokens(addr: address) -> uint256:\n', '    """\n', '    @notice Get the number of claimable tokens per user\n', '    @dev This function should be manually changed to "view" in the ABI\n', '    @return uint256 number of claimable tokens per user\n', '    """\n', '    self._checkpoint([addr, ZERO_ADDRESS])\n', '\n', '    return self.claimable_crv[addr]\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def claim_tokens(addr: address = msg.sender):\n', '    """\n', '    @notice Claim mintable CRV\n', '    @param addr Address to claim for\n', '    """\n', '    self._checkpoint([addr, ZERO_ADDRESS])\n', '\n', '    crv_token: address = self.crv_token\n', '    claimable: uint256 = self.claimable_crv[addr]\n', '    self.claimable_crv[addr] = 0\n', '\n', '    if ERC20(crv_token).balanceOf(self) < claimable:\n', '        Minter(self.minter).mint(self.gauge)\n', '        self.last_claim_data = block.timestamp\n', '\n', '    ERC20(crv_token).transfer(addr, claimable)\n', '\n', '\n', '@external\n', 'def set_approve_deposit(addr: address, can_deposit: bool):\n', '    """\n', '    @notice Set whether `addr` can deposit tokens for `msg.sender`\n', '    @param addr Address to set approval on\n', '    @param can_deposit bool - can this account deposit for `msg.sender`?\n', '    """\n', '    self.approved_to_deposit[addr][msg.sender] = can_deposit\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def deposit(_value: uint256, addr: address = msg.sender):\n', '    """\n', '    @notice Deposit `_value` LP tokens\n', '    @param _value Number of tokens to deposit\n', '    @param addr Address to deposit for\n', '    """\n', '    if addr != msg.sender:\n', '        assert self.approved_to_deposit[msg.sender][addr], "Not approved"\n', '\n', '    self._checkpoint([addr, ZERO_ADDRESS])\n', '\n', '    if _value != 0:\n', '        self.balanceOf[addr] += _value\n', '        self.totalSupply += _value\n', '\n', '        ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\n', '        LiquidityGauge(self.gauge).deposit(_value)\n', '\n', '    log Deposit(addr, _value)\n', '    log Transfer(ZERO_ADDRESS, addr, _value)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw(_value: uint256):\n', '    """\n', '    @notice Withdraw `_value` LP tokens\n', '    @param _value Number of tokens to withdraw\n', '    """\n', '    self._checkpoint([msg.sender, ZERO_ADDRESS])\n', '\n', '    if _value != 0:\n', '        self.balanceOf[msg.sender] -= _value\n', '        self.totalSupply -= _value\n', '\n', '        LiquidityGauge(self.gauge).withdraw(_value)\n', '        ERC20(self.lp_token).transfer(msg.sender, _value)\n', '\n', '    log Withdraw(msg.sender, _value)\n', '    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n', '\n', '\n', '@view\n', '@external\n', 'def allowance(_owner : address, _spender : address) -> uint256:\n', '    """\n', '    @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '    @param _owner The address which owns the funds.\n', '    @param _spender The address which will spend the funds.\n', '    @return An uint256 specifying the amount of tokens still available for the spender.\n', '    """\n', '    return self.allowances[_owner][_spender]\n', '\n', '\n', '@internal\n', 'def _transfer(_from: address, _to: address, _value: uint256):\n', '    self._checkpoint([_from, _to])\n', '\n', '    if _value != 0:\n', '        self.balanceOf[_from] -= _value\n', '        self.balanceOf[_to] += _value\n', '\n', '    log Transfer(_from, _to, _value)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def transfer(_to : address, _value : uint256) -> bool:\n', '    """\n', '    @dev Transfer token for a specified address\n', '    @param _to The address to transfer to.\n', '    @param _value The amount to be transferred.\n', '    """\n', '    self._transfer(msg.sender, _to, _value)\n', '\n', '    if msg.sender == UNIT_VAULT:\n', '        # when the transfer originates from the vault, consider it a withdrawal\n', '        # and adjust `depositedBalance` accordingly\n', '        self.depositedBalanceOf[_to] = UnitVault(UNIT_VAULT).collaterals(self, _to)\n', '\n', '    return True\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    """\n', '     @dev Transfer tokens from one address to another.\n', '     @param _from address The address which you want to send tokens from\n', '     @param _to address The address which you want to transfer to\n', '     @param _value uint256 the amount of tokens to be transferred\n', '    """\n', '    _allowance: uint256 = self.allowances[_from][msg.sender]\n', '    if _allowance != MAX_UINT256:\n', '        self.allowances[_from][msg.sender] = _allowance - _value\n', '\n', '    self._transfer(_from, _to, _value)\n', '\n', '    if _to == UNIT_VAULT:\n', '        # when a `transferFrom` directs into the vault, consider it a deposited\n', '        # balance so that the recipient may still claim CRV from it\n', '        self.depositedBalanceOf[_from] += _value\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Approve the passed address to transfer the specified amount of\n', '            tokens on behalf of msg.sender\n', '    @dev Beware that changing an allowance via this method brings the risk\n', '         that someone may use both the old and new allowance by unfortunate\n', '         transaction ordering. This may be mitigated with the use of\n', '         {increaseAllowance} and {decreaseAllowance}.\n', '         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will transfer the funds\n', '    @param _value The amount of tokens that may be transferred\n', '    @return bool success\n', '    """\n', '    self.allowances[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def increaseAllowance(_spender: address, _added_value: uint256) -> bool:\n', '    """\n', '    @notice Increase the allowance granted to `_spender` by the caller\n', '    @dev This is alternative to {approve} that can be used as a mitigation for\n', '         the potential race condition\n', '    @param _spender The address which will transfer the funds\n', '    @param _added_value The amount of to increase the allowance\n', '    @return bool success\n', '    """\n', '    allowance: uint256 = self.allowances[msg.sender][_spender] + _added_value\n', '    self.allowances[msg.sender][_spender] = allowance\n', '\n', '    log Approval(msg.sender, _spender, allowance)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\n', '    """\n', '    @notice Decrease the allowance granted to `_spender` by the caller\n', '    @dev This is alternative to {approve} that can be used as a mitigation for\n', '         the potential race condition\n', '    @param _spender The address which will transfer the funds\n', '    @param _subtracted_value The amount of to decrease the allowance\n', '    @return bool success\n', '    """\n', '    allowance: uint256 = self.allowances[msg.sender][_spender] - _subtracted_value\n', '    self.allowances[msg.sender][_spender] = allowance\n', '\n', '    log Approval(msg.sender, _spender, allowance)\n', '\n', '    return True']