['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-10\n', '*/\n', '\n', '// Sources flattened with hardhat v2.4.3 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts/token/ERC20/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/access/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() {\n', '        _setOwner(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        _setOwner(address(0));\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _setOwner(newOwner);\n', '    }\n', '\n', '    function _setOwner(address newOwner) private {\n', '        address oldOwner = _owner;\n', '        _owner = newOwner;\n', '        emit OwnershipTransferred(oldOwner, newOwner);\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IApi3Pool.sol\n', '\n', 'pragma solidity 0.8.6;\n', '\n', 'interface IApi3Pool {\n', '    struct Reward {\n', '        uint32 atBlock;\n', '        uint224 amount;\n', '        uint256 totalSharesThen;\n', '        uint256 totalStakeThen;\n', '    }\n', '\n', '    function EPOCH_LENGTH() external view returns (uint256);\n', '\n', '    function REWARD_VESTING_PERIOD() external view returns (uint256);\n', '\n', '    function genesisEpoch() external view returns (uint256);\n', '\n', '    function epochIndexToReward(uint256) external view returns (Reward memory);\n', '}\n', '\n', '\n', '// File contracts/interfaces/ITimelockManager.sol\n', '\n', 'pragma solidity 0.8.6;\n', '\n', 'interface ITimelockManager {\n', '    struct Timelock {\n', '        uint256 totalAmount;\n', '        uint256 remainingAmount;\n', '        uint256 releaseStart;\n', '        uint256 releaseEnd;\n', '    }\n', '\n', '    function timelocks(address) external view returns (Timelock memory);\n', '}\n', '\n', '\n', '// File contracts/LockedApi3.sol\n', '\n', 'pragma solidity 0.8.6;\n', '\n', '\n', '\n', '\n', 'contract LockedApi3 is Ownable {\n', '    event SetVestingAddresses(address[] vestingAddresses);\n', '\n', '    address public constant API3_TOKEN =\n', '        0x0b38210ea11411557c13457D4dA7dC6ea731B88a;\n', '    address public constant API3_POOL =\n', '        0x6dd655f10d4b9E242aE186D9050B68F725c76d76;\n', '    address public constant TIMELOCK_MANAGER =\n', '        0xFaef86994a37F1c8b2A5c73648F07dd4eFF02baA;\n', '    address public constant V1_TREASURY =\n', '        0xe7aF7c5982e073aC6525a34821fe1B3e8E432099;\n', '    address public constant PRIMARY_TREASURY =\n', '        0xD9F80Bdb37E6Bad114D747E60cE6d2aaF26704Ae;\n', '    address public constant SECONDARY_TREASURY =\n', '        0x556ECbb0311D350491Ba0EC7E019c354D7723CE0;\n', '\n', '    IERC20 public immutable api3Token;\n', '    IApi3Pool public immutable api3Pool;\n', '    ITimelockManager public immutable timelockManager;\n', '    address[] public vestingAddresses;\n', '\n', '    constructor() {\n', '        api3Token = IERC20(API3_TOKEN);\n', '        api3Pool = IApi3Pool(API3_POOL);\n', '        timelockManager = ITimelockManager(TIMELOCK_MANAGER);\n', '    }\n', '\n', '    function setVestingAddresses(address[] memory _vestingAddresses)\n', '        external\n', '        onlyOwner()\n', '    {\n', '        vestingAddresses = _vestingAddresses;\n', '        emit SetVestingAddresses(_vestingAddresses);\n', '    }\n', '\n', '    function getTotalLocked() external view returns (uint256 totalLocked) {\n', '        totalLocked = getTimelocked() + getLockedByGovernance();\n', '    }\n', '\n', '    function getTimelocked() public view returns (uint256 timelocked) {\n', '        timelocked = getLockedRewards() + getLockedVestings();\n', '    }\n', '\n', '    function getLockedByGovernance()\n', '        public\n', '        view\n', '        returns (uint256 lockedByGoverance)\n', '    {\n', '        lockedByGoverance =\n', '            api3Token.balanceOf(V1_TREASURY) +\n', '            api3Token.balanceOf(PRIMARY_TREASURY) +\n', '            api3Token.balanceOf(SECONDARY_TREASURY);\n', '    }\n', '\n', '    function getLockedRewards()\n', '        public\n', '        view\n', '        returns (uint256 totalLockedRewards)\n', '    {\n', '        uint256 currentEpoch = block.timestamp / api3Pool.EPOCH_LENGTH();\n', '        uint256 oldestLockedEpoch = currentEpoch -\n', '            api3Pool.REWARD_VESTING_PERIOD() +\n', '            1;\n', '        if (oldestLockedEpoch < api3Pool.genesisEpoch() + 1) {\n', '            oldestLockedEpoch = api3Pool.genesisEpoch() + 1;\n', '        }\n', '        for (\n', '            uint256 indEpoch = currentEpoch;\n', '            indEpoch >= oldestLockedEpoch;\n', '            indEpoch--\n', '        ) {\n', '            IApi3Pool.Reward memory lockedReward = api3Pool.epochIndexToReward(\n', '                indEpoch\n', '            );\n', '            if (lockedReward.atBlock != 0) {\n', '                totalLockedRewards += lockedReward.amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function getLockedVestings()\n', '        public\n', '        view\n', '        returns (uint256 totalLockedVestings)\n', '    {\n', '        for (\n', '            uint256 indVesting = 0;\n', '            indVesting < vestingAddresses.length;\n', '            indVesting++\n', '        ) {\n', '            ITimelockManager.Timelock memory timelock = timelockManager\n', '            .timelocks(vestingAddresses[indVesting]);\n', '            if (block.timestamp <= timelock.releaseStart) {\n', '                totalLockedVestings += timelock.totalAmount;\n', '            } else if (block.timestamp >= timelock.releaseEnd) {\n', '                continue;\n', '            } else {\n', '                uint256 totalTime = timelock.releaseEnd - timelock.releaseStart;\n', '                uint256 passedTime = block.timestamp - timelock.releaseStart;\n', '                uint256 unlocked = (timelock.totalAmount * passedTime) /\n', '                    totalTime;\n', '                totalLockedVestings += timelock.totalAmount - unlocked;\n', '            }\n', '        }\n', '    }\n', '}']