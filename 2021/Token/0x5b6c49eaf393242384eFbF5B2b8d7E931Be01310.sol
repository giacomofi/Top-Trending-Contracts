['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-06\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.4;\n', '\n', 'contract ERC20 {\n', '\n', '    uint256 totalsupply;\n', '    address admin;\n', '    \n', '    string name_;\n', '    string symbol_;\n', '    uint8 decimal_;\n', '    bool isOwner;\n', '    uint16 fee;\n', '    \n', '    constructor (string memory _name, string memory _symbol, uint8 _decimal) {\n', '        name_ = _name;\n', '        symbol_ = _symbol;\n', '        decimal_ = _decimal;\n', '        isOwner = true;\n', '        fee = 200;\n', '\n', '    }\n', '    modifier onlyAdmin {\n', '        require( msg.sender == admin, " Only Admin");\n', '        require( isOwner, "No owner of the contract");\n', '        _;\n', '    }\n', '    event Transfer (address indexed Sender, address indexed Receiver, uint256 NumTokens);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '    \n', '    function name() public view returns (string memory){\n', '        return name_;\n', '    }\n', '    function symbol() public view returns (string memory) {\n', '        return symbol_;\n', '    }\n', '    function decimals() public view returns (uint8) {\n', '        return decimal_;\n', '    }\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return totalsupply;\n', '    }\n', '    \n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        uint256 _tvalue = _value + _value*(fee/10000);\n', '        if (msg.sender == admin || _to == admin) {\n', '        require ( balances[msg.sender] >= _value, "Insufficient funds");\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;       \n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;    \n', '\n', '        } else {\n', '        require ( balances[msg.sender] >= _tvalue, "Insufficient funds");\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        _burnFee(_value, msg.sender);\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '        }\n', '    }\n', '    \n', '    \n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        uint256 _tvalue = _value + _value*(fee/10000);\n', '        if (_from == admin || _to == admin) {\n', '            require( balances[_from]>=_value, "Insufficient tokens");\n', '        require( allowed[_from][msg.sender] >= _value, "Not enough allowance");\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][msg.sender] -= _tvalue;\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '        } else {\n', '        require( balances[_from]>=_tvalue, "Insufficient tokens");\n', '        require( allowed[_from][msg.sender] >= _tvalue, "Not enough allowance");\n', '        balances[_from] -= _value;\n', '        balances[_to] += _value;\n', '        allowed[_from][msg.sender] -= _tvalue;\n', '        _burnFee(_value, _from);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '        }\n', '        \n', '    }\n', '          \n', '    function approve(address _spender, uint256 _value) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;  \n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    function _mint(uint256 _qty) internal onlyAdmin {\n', '        totalsupply += _qty;\n', '        balances[admin] += _qty;\n', '        emit Transfer(address(0), admin, _qty);\n', '    }\n', '    \n', '    function _burn(uint256 _qty) internal onlyAdmin {\n', '        require( balances[msg.sender] >= _qty, " not enough tokens to burn");\n', '        totalsupply -= _qty;\n', '        balances[msg.sender] -= _qty;\n', '        emit Transfer(msg.sender, address(0), _qty);\n', '    }\n', '\n', '    function _changeAdmin(address _newaddr) internal onlyAdmin {\n', '        admin = _newaddr;\n', '    }\n', '    function _renounceAdmin() internal onlyAdmin {\n', '        isOwner = false;\n', '    }\n', '    function _burnFee(uint256 _amt, address _addr) internal {\n', '        uint256 _qty = fee * _amt/10000;\n', '        require( balances[_addr] >= _qty, " not enough tokens to burn");\n', '        totalsupply -= _qty;\n', '        balances[_addr] -= _qty;\n', '        emit Transfer(_addr, address(0), _qty);\n', '    }\n', '    function setFee100x(uint16 _fee) public onlyAdmin {\n', '        fee = _fee;\n', '    }\n', '\n', '}\n', '\n', 'contract Rocket is ERC20 {\n', '\n', '    constructor () ERC20("Ethereum Rocket", "eROCKET", 18) {\n', '        admin = msg.sender;\n', '        _mint(5000000*10**18);\n', '    }\n', '\n', '    function newOwner(address _newOwner) public onlyAdmin {\n', '        _changeAdmin(_newOwner);\n', '    }\n', '    function renounceOwner() public onlyAdmin {\n', '        _renounceAdmin();\n', '    }\n', '\n', '    function mint(uint256 _qty) public onlyAdmin {\n', '        _mint(_qty);\n', '    }\n', '\n', '    function burn(uint256 _qty) public onlyAdmin {\n', '        _burn(_qty);\n', '    }\n', '    \n', '}']