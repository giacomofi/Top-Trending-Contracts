['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-26\n', '*/\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/* SPDX-License-Identifier: UNLICENSED */\n', '\n', '// ----------------------------------------------------------------------------\n', '// Safe maths\n', '// ----------------------------------------------------------------------------\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint c) {\n', '        require(b > 0);\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'abstract contract ERC20Interface {\n', '    function totalSupply() virtual public view returns (uint);\n', '    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n', '    function transfer(address to, uint tokens) virtual public returns (bool success);\n', '    function approve(address spender, uint tokens) virtual public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', 'struct Schedule {\n', '    uint32  start;\n', '    uint32  length;\n', '    uint256 initial;\n', '    uint256 tokens;\n', '}\n', '\n', '\n', 'contract Vesting is Owned, ERC20Interface {\n', '    using SafeMath for uint;\n', '\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '\n', '    mapping(address => Schedule) public schedules;\n', '    mapping(address => uint256) balances;\n', '    address public lockedTokenAddress;\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Constructor\n', '    // ------------------------------------------------------------------------\n', '    constructor() public {\n', '        symbol = "VTLM";\n', '        name = "Vesting Alien Worlds Trilium";\n', '        decimals = 4;\n', '    }\n', '\n', '    /* ERC-20 functions, null most of them */\n', '\n', '    function balanceOf(address tokenOwner) override virtual public view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    function totalSupply() override virtual public view returns (uint) {\n', '        return 0;\n', '    }\n', '\n', '    function allowance(address tokenOwner, address spender) override virtual public view returns (uint remaining){\n', '        return 0;\n', '    }\n', '\n', '    function transfer(address to, uint tokens) override virtual public returns (bool success) {\n', '        require(false, "Use the claim function, not transfer");\n', '    }\n', '\n', '    function approve(address spender, uint tokens) override virtual public returns (bool success) {\n', '        require(false, "Cannot approve spending");\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint tokens) override virtual public returns (bool success) {\n', '        require(false, "Use the claim function, not transferFrom");\n', '    }\n', '\n', '\n', '    /* My functions */\n', '\n', '    function vestedTotal(address user) private view returns (uint256){\n', '        uint256 time_now = block.timestamp;\n', '        uint256 vesting_seconds = 0;\n', '        Schedule memory s = schedules[user];\n', '\n', '        uint256 vested_total = balances[user];\n', '\n', '        if (s.start > 0) {\n', '            if (time_now >= s.start) {\n', '                vesting_seconds = time_now - s.start;\n', '\n', '                uint256 vest_per_second_sats = s.tokens.sub(s.initial);\n', '                vest_per_second_sats = vest_per_second_sats.div(s.length);\n', '                \n', '                vested_total = vesting_seconds.mul(vest_per_second_sats);\n', '                vested_total = vested_total.add(s.initial); // amount they can withdraw\n', '            }\n', '            else {\n', '                vested_total = 1;\n', '            }\n', '            \n', '            if (vested_total > s.tokens) {\n', '                vested_total = s.tokens;\n', '            }\n', '        }\n', '\n', '        return vested_total;\n', '    }\n', '\n', '    function maxClaim(address user) public view returns (uint256) {\n', '        uint256 vested_total = vestedTotal(user);\n', '        Schedule memory s = schedules[user];\n', '        uint256 max = 0;\n', '\n', '        if (s.start > 0){\n', '            uint256 claimed = s.tokens.sub(balances[user]);\n', '\n', '            max = vested_total.sub(claimed);\n', '\n', '            if (max > balances[user]){\n', '                max = balances[user];\n', '            }\n', '        }\n', '\n', '        return max;\n', '    }\n', '\n', '    function claim(uint256 amount) public {\n', '        require(lockedTokenAddress != address(0x0), "Locked token contract has not been set");\n', '        require(amount > 0, "Must claim more than 0");\n', '        require(balances[msg.sender] > 0, "No vesting balance found");\n', '\n', '        uint256 vested_total = vestedTotal(msg.sender);\n', '\n', '        Schedule memory s = schedules[msg.sender];\n', '        if (s.start > 0){\n', '            uint256 remaining_balance = balances[msg.sender].sub(amount);\n', '\n', '            if (vested_total < s.tokens) {\n', '                uint min_balance = s.tokens.sub(vested_total);\n', '                require(remaining_balance >= min_balance, "Cannot transfer this amount due to vesting locks");\n', '            }\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        ERC20Interface(lockedTokenAddress).transfer(msg.sender, amount);\n', '    }\n', '\n', '    function setSchedule(address user, uint32 start, uint32 length, uint256 initial, uint256 amount) public onlyOwner {\n', '        schedules[user].start = start;\n', '        schedules[user].length = length;\n', '        schedules[user].initial = initial;\n', '        schedules[user].tokens = amount;\n', '    }\n', '\n', '    function addTokens(address newOwner, uint256 amount) public onlyOwner {\n', '        require(lockedTokenAddress != address(0x0), "Locked token contract has not been set");\n', '\n', '        ERC20Interface tokenContract = ERC20Interface(lockedTokenAddress);\n', '\n', '        uint256 userAllowance = tokenContract.allowance(msg.sender, address(this));\n', '        uint256 fromBalance = tokenContract.balanceOf(msg.sender);\n', '        require(fromBalance >= amount, "Sender has insufficient balance");\n', '        require(userAllowance >= amount, "Please allow tokens to be spent by this contract");\n', '        tokenContract.transferFrom(msg.sender, address(this), amount);\n', '\n', '        balances[newOwner] = balances[newOwner].add(amount);\n', '        \n', '        emit Transfer(address(0x0), newOwner, amount);\n', '    }\n', '\n', '    function removeTokens(address owner, uint256 amount) public onlyOwner {\n', '        ERC20Interface tokenContract = ERC20Interface(lockedTokenAddress);\n', '        tokenContract.transfer(owner, amount);\n', '        \n', '        balances[owner] = balances[owner].sub(amount);\n', '    }\n', '\n', '    function setTokenContract(address _lockedTokenAddress) public onlyOwner {\n', '        lockedTokenAddress = _lockedTokenAddress;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Don't accept ETH\n", '    // ------------------------------------------------------------------------\n', '    receive () external payable {\n', '        revert();\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n', '    }\n', '}']