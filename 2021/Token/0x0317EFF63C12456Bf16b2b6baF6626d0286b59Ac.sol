['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction underflow");\n', '    }\n', '\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract LevTreasuryVester {\n', '    using SafeMath for uint256;\n', '\n', '    address public lev;\n', '    mapping(address => TreasuryVester) public _Treasury;\n', '\n', '    struct TreasuryVester {\n', '        uint256 vestingAmount;\n', '        uint256 vestingBegin;\n', '        uint256 vestingFirst;\n', '        uint256 vestingShare;\n', '        uint256 nextTime;\n', '        uint256 vestingCycle;\n', '    }\n', '\n', '    constructor(address _lev) public {\n', '        lev = _lev;\n', '    }\n', '\n', '    function creatTreasury(\n', '        address recipient_,\n', '        uint256 vestingAmount_,\n', '        uint256 vestingFirst_,\n', '        uint256 vestingShare_,\n', '        uint256 vestingBegin_,\n', '        uint256 vestingCycle_\n', '    ) external {\n', '        require(\n', '            vestingBegin_ >= block.timestamp,\n', '            "TreasuryVester::creat: vesting begin too early"\n', '        );\n', '        require(\n', '            vestingCycle_ >= 24 * 3600 * 30,\n', '            "TreasuryVester::creat: vesting cycle too small"\n', '        );\n', '        TreasuryVester storage treasury = _Treasury[recipient_];\n', '        require(\n', '            treasury.vestingAmount == 0,\n', '            "TreasuryVester::creat: recipient already exists"\n', '        );\n', '        treasury.vestingAmount = vestingAmount_;\n', '        treasury.vestingBegin = vestingBegin_;\n', '        treasury.vestingFirst = vestingFirst_;\n', '        treasury.vestingShare = vestingShare_;\n', '        treasury.nextTime = vestingBegin_;\n', '        treasury.vestingCycle = vestingCycle_;\n', '\n', '        ILev(lev).transferFrom(msg.sender, address(this), vestingAmount_);\n', '    }\n', '\n', '    function setRecipient(address recipient_) external {\n', '        TreasuryVester storage treasury = _Treasury[msg.sender];\n', '        TreasuryVester storage treasury2 = _Treasury[recipient_];\n', '        require(\n', '            treasury.vestingAmount > 0,\n', '            "TreasuryVester::setRecipient: unauthorized"\n', '        );\n', '        require(\n', '            treasury2.vestingAmount == 0,\n', '            "TreasuryVester::setRecipient: recipient already exists"\n', '        );\n', '        treasury2 = treasury;\n', '        treasury.vestingAmount = 0;\n', '    }\n', '\n', '    function claim() external {\n', '        TreasuryVester storage treasury = _Treasury[msg.sender];\n', '        require(\n', '            treasury.vestingAmount > 0,\n', '            "TreasuryVester::claim: not sufficient funds"\n', '        );\n', '        require(\n', '            block.timestamp >= treasury.nextTime,\n', '            "TreasuryVester::claim: not time yet"\n', '        );\n', '        uint256 amount;\n', '        if (treasury.nextTime == treasury.vestingBegin) {\n', '            amount = treasury.vestingFirst;\n', '        } else {\n', '            amount = treasury.vestingShare;\n', '        }\n', '        if (ILev(lev).balanceOf(address(this)) < amount) {\n', '            amount = ILev(lev).balanceOf(address(this));\n', '        }\n', '        if (treasury.vestingAmount < amount) {\n', '            amount = treasury.vestingAmount;\n', '        }\n', '        treasury.nextTime = treasury.nextTime.add(treasury.vestingCycle);\n', '        treasury.vestingAmount = treasury.vestingAmount.sub(amount);\n', '        ILev(lev).transfer(msg.sender, amount);\n', '    }\n', '}\n', '\n', 'interface ILev {\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address dst, uint256 rawAmount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}']